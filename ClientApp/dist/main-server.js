(function(e, a) { for(var i in a) e[i] = a[i]; }(exports, /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// object to store loaded chunks
/******/ 	// "0" means "already loaded"
/******/ 	var installedChunks = {
/******/ 		4: 0
/******/ 	};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/ 	// This file contains only the entry chunk.
/******/ 	// The chunk loading function for additional chunks
/******/ 	__webpack_require__.e = function requireEnsure(chunkId) {
/******/ 		// "0" is the signal for "already loaded"
/******/ 		if(installedChunks[chunkId] !== 0) {
/******/ 			var chunk = require("./" + chunkId + ".js");
/******/ 			var moreModules = chunk.modules, chunkIds = chunk.ids;
/******/ 			for(var moduleId in moreModules) {
/******/ 				modules[moduleId] = moreModules[moduleId];
/******/ 			}
/******/ 			for(var i = 0; i < chunkIds.length; i++)
/******/ 				installedChunks[chunkIds[i]] = 0;
/******/ 		}
/******/ 		return Promise.resolve();
/******/ 	};
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "dist/";
/******/
/******/ 	// uncatched error handler for webpack runtime
/******/ 	__webpack_require__.oe = function(err) {
/******/ 		process.nextTick(function() {
/******/ 			throw err; // catch this error by using System.import().catch()
/******/ 		});
/******/ 	};
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 66);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(2))(10);

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/* global global, define, System, Reflect, Promise */
var __extends;
var __assign;
var __rest;
var __decorate;
var __param;
var __metadata;
var __awaiter;
var __generator;
var __exportStar;
var __values;
var __read;
var __spread;
var __await;
var __asyncGenerator;
var __asyncDelegator;
var __asyncValues;
(function (factory) {
    var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
    if (true) {
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_RESULT__ = function (exports) { factory(createExporter(root, createExporter(exports))); }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    }
    else if (typeof module === "object" && typeof module.exports === "object") {
        factory(createExporter(root, createExporter(module.exports)));
    }
    else {
        factory(createExporter(root));
    }
    function createExporter(exports, previous) {
        return function (id, v) { return exports[id] = previous ? previous(id, v) : v; };
    }
})
(function (exporter) {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };

    __extends = function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };

    __assign = Object.assign || function (t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };

    __rest = function (s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
                t[p[i]] = s[p[i]];
        return t;
    };

    __decorate = function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };

    __param = function (paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); }
    };

    __metadata = function (metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
    };

    __awaiter = function (thisArg, _arguments, P, generator) {
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    };

    __generator = function (thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [0, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    };

    __exportStar = function (m, exports) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    };

    __values = function (o) {
        var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
        if (m) return m.call(o);
        return {
            next: function () {
                if (o && i >= o.length) o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
    };

    __read = function (o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    };

    __spread = function () {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    };

    __await = function (v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
    };

    __asyncGenerator = function (thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
        function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
        function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);  }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
    };

    __asyncDelegator = function (o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
        function verb(n, f) { if (o[n]) i[n] = function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; }; }
    };

    __asyncValues = function (o) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator];
        return m ? m.call(o) : typeof __values === "function" ? __values(o) : o[Symbol.iterator]();
    };

    exporter("__extends", __extends);
    exporter("__assign", __assign);
    exporter("__rest", __rest);
    exporter("__decorate", __decorate);
    exporter("__param", __param);
    exporter("__metadata", __metadata);
    exporter("__awaiter", __awaiter);
    exporter("__generator", __generator);
    exporter("__exportStar", __exportStar);
    exporter("__values", __values);
    exporter("__read", __read);
    exporter("__spread", __spread);
    exporter("__await", __await);
    exporter("__asyncGenerator", __asyncGenerator);
    exporter("__asyncDelegator", __asyncDelegator);
    exporter("__asyncValues", __asyncValues);
});

/***/ }),
/* 2 */
/***/ (function(module, exports) {

module.exports = require("./vendor");

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var DOMException = __webpack_require__(44);
var ERR = DOMException;
var isApiWritable = __webpack_require__(45).isApiWritable;

exports.NAMESPACE = {
  HTML: 'http://www.w3.org/1999/xhtml',
  XML: 'http://www.w3.org/XML/1998/namespace',
  XMLNS: 'http://www.w3.org/2000/xmlns/',
  MATHML: 'http://www.w3.org/1998/Math/MathML',
  SVG: 'http://www.w3.org/2000/svg',
  XLINK: 'http://www.w3.org/1999/xlink'
};

//
// Shortcut functions for throwing errors of various types.
//
exports.IndexSizeError = function() { throw new DOMException(ERR.INDEX_SIZE_ERR); };
exports.HierarchyRequestError = function() { throw new DOMException(ERR.HIERARCHY_REQUEST_ERR); };
exports.WrongDocumentError = function() { throw new DOMException(ERR.WRONG_DOCUMENT_ERR); };
exports.InvalidCharacterError = function() { throw new DOMException(ERR.INVALID_CHARACTER_ERR); };
exports.NoModificationAllowedError = function() { throw new DOMException(ERR.NO_MODIFICATION_ALLOWED_ERR); };
exports.NotFoundError = function() { throw new DOMException(ERR.NOT_FOUND_ERR); };
exports.NotSupportedError = function() { throw new DOMException(ERR.NOT_SUPPORTED_ERR); };
exports.InvalidStateError = function() { throw new DOMException(ERR.INVALID_STATE_ERR); };
exports.SyntaxError = function() { throw new DOMException(ERR.SYNTAX_ERR); };
exports.InvalidModificationError = function() { throw new DOMException(ERR.INVALID_MODIFICATION_ERR); };
exports.NamespaceError = function() { throw new DOMException(ERR.NAMESPACE_ERR); };
exports.InvalidAccessError = function() { throw new DOMException(ERR.INVALID_ACCESS_ERR); };
exports.TypeMismatchError = function() { throw new DOMException(ERR.TYPE_MISMATCH_ERR); };
exports.SecurityError = function() { throw new DOMException(ERR.SECURITY_ERR); };
exports.NetworkError = function() { throw new DOMException(ERR.NETWORK_ERR); };
exports.AbortError = function() { throw new DOMException(ERR.ABORT_ERR); };
exports.UrlMismatchError = function() { throw new DOMException(ERR.URL_MISMATCH_ERR); };
exports.QuotaExceededError = function() { throw new DOMException(ERR.QUOTA_EXCEEDED_ERR); };
exports.TimeoutError = function() { throw new DOMException(ERR.TIMEOUT_ERR); };
exports.InvalidNodeTypeError = function() { throw new DOMException(ERR.INVALID_NODE_TYPE_ERR); };
exports.DataCloneError = function() { throw new DOMException(ERR.DATA_CLONE_ERR); };

exports.nyi = function() {
  throw new Error("NotYetImplemented");
};

exports.assert = function(expr, msg) {
  if (!expr) {
    throw new Error("Assertion failed: " + (msg || "") + "\n" + new Error().stack);
  }
};

exports.expose = function(src, c) {
  for (var n in src) {
    Object.defineProperty(c.prototype, n, { value: src[n], writable: isApiWritable });
  }
};

exports.merge = function(a, b) {
  for (var n in b) {
    a[n] = b[n];
  }
};

// Compare two nodes based on their document order. This function is intended
// to be passed to sort(). Assumes that the array being sorted does not
// contain duplicates.  And that all nodes are connected and comparable.
// Clever code by ppk via jeresig.
exports.documentOrder = function(n,m) {
  /* jshint bitwise: false */
  return 3 - (n.compareDocumentPosition(m) & 6);
};

exports.toASCIILowerCase = function(s) {
  return s.replace(/[A-Z]+/g, function(t) { return t.toLowerCase(); });
};


/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = Node;

var EventTarget = __webpack_require__(41);
var utils = __webpack_require__(3);
var NAMESPACE = utils.NAMESPACE;

// All nodes have a nodeType and an ownerDocument.
// Once inserted, they also have a parentNode.
// This is an abstract class; all nodes in a document are instances
// of a subtype, so all the properties are defined by more specific
// constructors.
function Node() {
}

var ELEMENT_NODE                = Node.ELEMENT_NODE = 1;
var ATTRIBUTE_NODE              = Node.ATTRIBUTE_NODE = 2;
var TEXT_NODE                   = Node.TEXT_NODE = 3;
var CDATA_SECTION_NODE          = Node.CDATA_SECTION_NODE = 4;
var ENTITY_REFERENCE_NODE       = Node.ENTITY_REFERENCE_NODE = 5;
var ENTITY_NODE                 = Node.ENTITY_NODE = 6;
var PROCESSING_INSTRUCTION_NODE = Node.PROCESSING_INSTRUCTION_NODE = 7;
var COMMENT_NODE                = Node.COMMENT_NODE = 8;
var DOCUMENT_NODE               = Node.DOCUMENT_NODE = 9;
var DOCUMENT_TYPE_NODE          = Node.DOCUMENT_TYPE_NODE = 10;
var DOCUMENT_FRAGMENT_NODE      = Node.DOCUMENT_FRAGMENT_NODE = 11;
var NOTATION_NODE               = Node.NOTATION_NODE = 12;

var DOCUMENT_POSITION_DISCONNECTED            = Node.DOCUMENT_POSITION_DISCONNECTED = 0x01;
var DOCUMENT_POSITION_PRECEDING               = Node.DOCUMENT_POSITION_PRECEDING = 0x02;
var DOCUMENT_POSITION_FOLLOWING               = Node.DOCUMENT_POSITION_FOLLOWING = 0x04;
var DOCUMENT_POSITION_CONTAINS                = Node.DOCUMENT_POSITION_CONTAINS = 0x08;
var DOCUMENT_POSITION_CONTAINED_BY            = Node.DOCUMENT_POSITION_CONTAINED_BY = 0x10;
var DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC = Node.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC = 0x20;

var hasRawContent = {
  STYLE: true,
  SCRIPT: true,
  XMP: true,
  IFRAME: true,
  NOEMBED: true,
  NOFRAMES: true,
  PLAINTEXT: true
};

var emptyElements = {
  area: true,
  base: true,
  basefont: true,
  bgsound: true,
  br: true,
  col: true,
  embed: true,
  frame: true,
  hr: true,
  img: true,
  input: true,
  keygen: true,
  link: true,
  meta: true,
  param: true,
  source: true,
  track: true,
  wbr: true
};

var extraNewLine = {
  /* Removed in https://github.com/whatwg/html/issues/944
  pre: true,
  textarea: true,
  listing: true
  */
};

Node.prototype = Object.create(EventTarget.prototype, {

  // Node that are not inserted into the tree inherit a null parent
  parentNode: { value: null, writable: true },

  // XXX: the baseURI attribute is defined by dom core, but
  // a correct implementation of it requires HTML features, so
  // we'll come back to this later.
  baseURI: { get: utils.nyi },

  parentElement: { get: function() {
    return (this.parentNode && this.parentNode.nodeType===ELEMENT_NODE) ? this.parentNode : null;
  }},

  hasChildNodes: { value: function() {  // Overridden in leaf.js
    return this.childNodes.length > 0;
  }},

  firstChild: { get: function() {
    return this.childNodes.length === 0 ? null : this.childNodes[0];
  }},

  lastChild: { get: function() {
    return this.childNodes.length === 0 ? null : this.childNodes[this.childNodes.length-1];
  }},

  previousSibling: { get: function() {
    if (!this.parentNode) return null;
    var sibs = this.parentNode.childNodes, i = this.index;
    return i === 0 ? null : sibs[i-1];
  }},

  nextSibling: { get: function() {
    if (!this.parentNode) return null;
    var sibs = this.parentNode.childNodes, i = this.index;
    return i+1 === sibs.length ? null : sibs[i+1];
  }},


  _countChildrenOfType: { value: function(type) {
    var sum = 0, nodes = this.childNodes, length = nodes.length, i;
    for (i=0; i<length; i++) {
      if (nodes[i].nodeType === type) sum++;
    }
    return sum;
  }},

  _ensureInsertValid: { value: function _ensureInsertValid(node, child, isPreinsert) {
    var parent = this, i;
    if (!node.nodeType) throw new TypeError('not a node');
    // 1. If parent is not a Document, DocumentFragment, or Element
    // node, throw a HierarchyRequestError.
    switch (parent.nodeType) {
    case DOCUMENT_NODE:
    case DOCUMENT_FRAGMENT_NODE:
    case ELEMENT_NODE:
      break;
    default: utils.HierarchyRequestError();
    }
    // 2. If node is a host-including inclusive ancestor of parent,
    // throw a HierarchyRequestError.
    if (node.isAncestor(parent)) utils.HierarchyRequestError();
    // 3. If child is not null and its parent is not parent, then
    // throw a NotFoundError. (replaceChild omits the 'child is not null'
    // and throws a TypeError here if child is null.)
    if (child !== null || !isPreinsert) {
      if (child.parentNode !== parent) utils.NotFoundError();
    }
    // 4. If node is not a DocumentFragment, DocumentType, Element,
    // Text, ProcessingInstruction, or Comment node, throw a
    // HierarchyRequestError.
    switch (node.nodeType) {
    case DOCUMENT_FRAGMENT_NODE:
    case DOCUMENT_TYPE_NODE:
    case ELEMENT_NODE:
    case TEXT_NODE:
    case PROCESSING_INSTRUCTION_NODE:
    case COMMENT_NODE:
      break;
    default: utils.HierarchyRequestError();
    }
    // 5. If either node is a Text node and parent is a document, or
    // node is a doctype and parent is not a document, throw a
    // HierarchyRequestError.
    // 6. If parent is a document, and any of the statements below, switched
    // on node, are true, throw a HierarchyRequestError.
    if (parent.nodeType === DOCUMENT_NODE) {
      switch (node.nodeType) {
      case TEXT_NODE:
        utils.HierarchyRequestError();
        break;
      case DOCUMENT_FRAGMENT_NODE:
        // 6a1. If node has more than one element child or has a Text
        // node child.
        if (node._countChildrenOfType(TEXT_NODE) > 0)
          utils.HierarchyRequestError();
        switch (node._countChildrenOfType(ELEMENT_NODE)) {
        case 0:
          break;
        case 1:
          // 6a2. Otherwise, if node has one element child and either
          // parent has an element child, child is a doctype, or child
          // is not null and a doctype is following child. [preinsert]
          // 6a2. Otherwise, if node has one element child and either
          // parent has an element child that is not child or a
          // doctype is following child. [replaceWith]
          if (child !== null /* always true here for replaceWith */) {
            if (isPreinsert && child.nodeType === DOCUMENT_TYPE_NODE)
              utils.HierarchyRequestError();
            for (i=parent.childNodes.length-1; i>=0; i--) {
              if (parent.childNodes[i] === child) break;
              if (parent.childNodes[i].nodeType === DOCUMENT_TYPE_NODE)
                utils.HierarchyRequestError();
            }
          }
          i = parent._countChildrenOfType(ELEMENT_NODE);
          if (isPreinsert) {
            // "parent has an element child"
            if (i > 0)
              utils.HierarchyRequestError();
          } else {
            // "parent has an element child that is not child"
            if (i > 1 || (i === 1 && child.nodeType !== ELEMENT_NODE))
              utils.HierarchyRequestError();
          }
          break;
        default: // 6a1, continued. (more than one Element child)
          utils.HierarchyRequestError();
        }
        break;
      case ELEMENT_NODE:
        // 6b. parent has an element child, child is a doctype, or
        // child is not null and a doctype is following child. [preinsert]
        // 6b. parent has an element child that is not child or a
        // doctype is following child. [replaceWith]
        if (child !== null /* always true here for replaceWith */) {
          if (isPreinsert && child.nodeType === DOCUMENT_TYPE_NODE)
            utils.HierarchyRequestError();
          for (i=parent.childNodes.length-1; i>=0; i--) {
            if (parent.childNodes[i] === child) break;
            if (parent.childNodes[i].nodeType === DOCUMENT_TYPE_NODE)
              utils.HierarchyRequestError();
          }
        }
        i = parent._countChildrenOfType(ELEMENT_NODE);
        if (isPreinsert) {
          // "parent has an element child"
          if (i > 0)
            utils.HierarchyRequestError();
        } else {
          // "parent has an element child that is not child"
          if (i > 1 || (i === 1 && child.nodeType !== ELEMENT_NODE))
            utils.HierarchyRequestError();
        }
        break;
      case DOCUMENT_TYPE_NODE:
        // 6c. parent has a doctype child, child is non-null and an
        // element is preceding child, or child is null and parent has
        // an element child. [preinsert]
        // 6c. parent has a doctype child that is not child, or an
        // element is preceding child. [replaceWith]
        if (child === null) {
          if (parent._countChildrenOfType(ELEMENT_NODE))
            utils.HierarchyRequestError();
        } else {
          // child is always non-null for [replaceWith] case
          for (i=0; i<parent.childNodes.length; i++) {
            if (parent.childNodes[i] === child) break;
            if (parent.childNodes[i].nodeType === ELEMENT_NODE)
              utils.HierarchyRequestError();
          }
        }
        i = parent._countChildrenOfType(DOCUMENT_TYPE_NODE);
        if (isPreinsert) {
          // "parent has an doctype child"
          if (i > 0)
            utils.HierarchyRequestError();
        } else {
          // "parent has an doctype child that is not child"
          if (i > 1 || (i === 1 && child.nodeType !== DOCUMENT_TYPE_NODE))
            utils.HierarchyRequestError();
        }
        break;
      }
    } else {
      // 5, continued: (parent is not a document)
      if (node.nodeType === DOCUMENT_TYPE_NODE) utils.HierarchyRequestError();
    }
  }},

  insertBefore: { value: function insertBefore(node, child) {
    var parent = this;
    // 1. Ensure pre-insertion validity
    parent._ensureInsertValid(node, child, true);
    // 2. Let reference child be child.
    var refChild = child;
    // 3. If reference child is node, set it to node's next sibling
    if (refChild === node) { refChild = node.nextSibling; }
    // 4. Adopt node into parent's node document.
    parent.doc.adoptNode(node);
    // 5. Insert node into parent before reference child.
    if (refChild === null) {
      parent._appendChild(node);
    } else {
      node.insert(parent, refChild.index);
    }
    // 6. Return node
    return node;
  }},


  appendChild: { value: function(child) {
    // This invokes _appendChild after doing validity checks.
    return this.insertBefore(child, null);
  }},

  _appendChild: { value: function(child) {
    child.insert(this, this.childNodes.length);
    return child;
  }},

  removeChild: { value: function removeChild(child) {
    var parent = this;
    if (!child.nodeType) throw new TypeError('not a node');
    if (child.parentNode !== parent) utils.NotFoundError();
    child.remove();
    return child;
  }},

  // To replace a `child` with `node` within a `parent` (this)
  replaceChild: { value: function replaceChild(node, child) {
    var parent = this;
    // Ensure validity (slight differences from pre-insertion check)
    parent._ensureInsertValid(node, child, false);
    // Adopt node into parent's node document.
    if (node.doc !== parent.doc) {
      // XXX adoptNode has side-effect of removing node from its parent
      // and generating a mutation event, thus causing the _insertOrReplace
      // to generate two deletes and an insert instead of a 'move'
      // event.  It looks like the new MutationObserver stuff avoids
      // this problem, but for now let's only adopt (ie, remove `node`
      // from its parent) here if we need to.
      parent.doc.adoptNode(node);
    }
    // Do the replace.
    node._insertOrReplace(parent, child.index, true);
    return child;
  }},

  // See: http://ejohn.org/blog/comparing-document-position/
  contains: { value: function contains(node) {
    if (node === null) { return false; }
    if (this === node) { return true; /* inclusive descendant */ }
    /* jshint bitwise: false */
    return (this.compareDocumentPosition(node) &
            DOCUMENT_POSITION_CONTAINED_BY) !== 0;
  }},

  compareDocumentPosition: { value: function compareDocumentPosition(that){
    // Basic algorithm for finding the relative position of two nodes.
    // Make a list the ancestors of each node, starting with the
    // document element and proceeding down to the nodes themselves.
    // Then, loop through the lists, looking for the first element
    // that differs.  The order of those two elements give the
    // order of their descendant nodes.  Or, if one list is a prefix
    // of the other one, then that node contains the other.

    if (this === that) return 0;

    // If they're not owned by the same document or if one is rooted
    // and one is not, then they're disconnected.
    if (this.doc !== that.doc ||
      this.rooted !== that.rooted)
      return (DOCUMENT_POSITION_DISCONNECTED +
          DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC);

    // Get arrays of ancestors for this and that
    var these = [], those = [];
    for(var n = this; n !== null; n = n.parentNode) these.push(n);
    for(n = that; n !== null; n = n.parentNode) those.push(n);
    these.reverse();  // So we start with the outermost
    those.reverse();

    if (these[0] !== those[0]) // No common ancestor
      return (DOCUMENT_POSITION_DISCONNECTED +
          DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC);

    n = Math.min(these.length, those.length);
    for(var i = 1; i < n; i++) {
      if (these[i] !== those[i]) {
        // We found two different ancestors, so compare
        // their positions
        if (these[i].index < those[i].index)
          return DOCUMENT_POSITION_FOLLOWING;
        else
          return DOCUMENT_POSITION_PRECEDING;
      }
    }

    // If we get to here, then one of the nodes (the one with the
    // shorter list of ancestors) contains the other one.
    if (these.length < those.length)
      return (DOCUMENT_POSITION_FOLLOWING +
          DOCUMENT_POSITION_CONTAINED_BY);
    else
      return (DOCUMENT_POSITION_PRECEDING +
          DOCUMENT_POSITION_CONTAINS);
  }},

  isSameNode: {value : function isSameNode(node) {
    return this === node;
  }},


  // This method implements the generic parts of node equality testing
  // and defers to the (non-recursive) type-specific isEqual() method
  // defined by subclasses
  isEqualNode: { value: function isEqualNode(node) {
    if (!node) return false;
    if (node.nodeType !== this.nodeType) return false;

    // Check for same number of children
    // Check for children this way because it is more efficient
    // for childless leaf nodes.
    var n; // number of child nodes
    if (!this.firstChild) {
      n = 0;
      if (node.firstChild) return false;
    }
    else {
      n = this.childNodes.length;
      if (node.childNodes.length !== n) return false;
    }

    // Check type-specific properties for equality
    if (!this.isEqual(node)) return false;

    // Now check children for equality
    for(var i = 0; i < n; i++) {
      var c1 = this.childNodes[i], c2 = node.childNodes[i];
      if (!c1.isEqualNode(c2)) return false;
    }

    return true;
  }},

  // This method delegates shallow cloning to a clone() method
  // that each concrete subclass must implement
  cloneNode: { value: function(deep) {
    // Clone this node
    var clone = this.clone();

    // Handle the recursive case if necessary
    if (deep && this.firstChild) {
      for(var i = 0, n = this.childNodes.length; i < n; i++) {
        clone._appendChild(this.childNodes[i].cloneNode(true));
      }
    }

    return clone;
  }},

  lookupPrefix: { value: function lookupPrefix(ns) {
    var e;
    if (ns === '') return null;
    switch(this.nodeType) {
    case ELEMENT_NODE:
      return this.locateNamespacePrefix(ns);
    case DOCUMENT_NODE:
      e = this.documentElement;
      return e ? e.locateNamespacePrefix(ns) : null;
    case DOCUMENT_TYPE_NODE:
    case DOCUMENT_FRAGMENT_NODE:
      return null;
    default:
      e = this.parentElement;
      return e ? e.locateNamespacePrefix(ns) : null;
    }
  }},


  lookupNamespaceURI: {value: function lookupNamespaceURI(prefix) {
    var e;
    switch(this.nodeType) {
    case ELEMENT_NODE:
      return this.locateNamespace(prefix);
    case DOCUMENT_NODE:
      e = this.documentElement;
      return e ? e.locateNamespace(prefix) : null;
    case DOCUMENT_TYPE_NODE:
    case DOCUMENT_FRAGMENT_NODE:
      return null;
    default:
      e = this.parentElement;
      return e ? e.locateNamespace(prefix) : null;
    }
  }},

  isDefaultNamespace: { value: function isDefaultNamespace(ns) {
    var defaultns = this.lookupNamespaceURI(null);
    if (defaultns === null) defaultns = '';
    return ns === defaultns;
  }},

  // Utility methods for nodes.  Not part of the DOM

  // Return the index of this node in its parent.
  // Throw if no parent, or if this node is not a child of its parent
  index: { get: function() {
    utils.assert(this.parentNode);
    var kids = this.parentNode.childNodes;
    if (this._index === undefined || kids[this._index] !== this) {
      this._index = kids.indexOf(this);
      utils.assert(this._index !== -1);
    }
    return this._index;
  }},

  // Return true if this node is equal to or is an ancestor of that node
  // Note that nodes are considered to be ancestors of themselves
  isAncestor: { value: function(that) {
    // If they belong to different documents, then they're unrelated.
    if (this.doc !== that.doc) return false;
    // If one is rooted and one isn't then they're not related
    if (this.rooted !== that.rooted) return false;

    // Otherwise check by traversing the parentNode chain
    for(var e = that; e; e = e.parentNode) {
      if (e === this) return true;
    }
    return false;
  }},

  // DOMINO Changed the behavior to conform with the specs. See:
  // https://groups.google.com/d/topic/mozilla.dev.platform/77sIYcpdDmc/discussion
  ensureSameDoc: { value: function(that) {
    if (that.ownerDocument === null) {
      that.ownerDocument = this.doc;
    }
    else if(that.ownerDocument !== this.doc) {
      utils.WrongDocumentError();
    }
  }},

  // Remove all of this node's children.  This is a minor
  // optimization that only calls modify() once.
  removeChildren: { value: function removeChildren() {
    var n = this.childNodes.length;
    if (n) {
      var root = this.rooted ? this.ownerDocument : null;
      for(var i = 0; i < n; i++) {
        if (root) root.mutateRemove(this.childNodes[i]);
        this.childNodes[i].parentNode = null;
      }
      this.childNodes.length = 0; // Forget all children
      this.modify();              // Update last modified type once only
    }
  }},

  // Insert this node as a child of parent at the specified index,
  // firing mutation events as necessary
  insert: { value: function insert(parent, index) {
    this._insertOrReplace(parent, index, false);
  }},

  // Insert this node as a child of parent at the specified index,
  // or replace the specified child with this node, firing mutation events as
  // necessary
  _insertOrReplace: { value: function _insertOrReplace(parent, index, isReplace) {
    var child = this;
    var kids = parent.childNodes;

    if (child.nodeType === DOCUMENT_FRAGMENT_NODE && child.rooted) {
      utils.HierarchyRequestError();
    }

    // If we are already a child of the specified parent, then
    // the index may have to be adjusted.
    if (child.parentNode === parent) {
      var currentIndex = child.index;
      // If we're not moving the node, we're done now
      // XXX: or do DOM mutation events still have to be fired?
      if (currentIndex === index) return;

      // If the child is before the spot it is to be inserted at,
      // then when it is removed, the index of that spot will be
      // reduced.
      if (currentIndex < index) index--;
    }

    // Delete the old child
    if (isReplace) {
      var oldChild = parent.childNodes[index];
      if (oldChild.rooted) oldChild.doc.mutateRemove(oldChild);
      oldChild.parentNode = null;
    }

    // If both the child and the parent are rooted, then we want to
    // transplant the child without uprooting and rerooting it.
    if (child.rooted && parent.rooted) {
      // Remove the child from its current position in the tree
      // without calling remove(), since we don't want to uproot it.
      var curpar = child.parentNode;
      curpar.childNodes.splice(child.index, 1);
      curpar.modify();

      // And insert it as a child of its new parent
      child.parentNode = parent;
      if (isReplace) {
        kids[index] = child;
      } else {
        kids.splice(index, 0, child);
      }
      child._index = index;
      parent.modify();

      // Generate a move mutation event
      parent.doc.mutateMove(child);
    }
    else {
      if (child.nodeType === DOCUMENT_FRAGMENT_NODE) {
        var spliceArgs = [index, isReplace ? 1 : 0];
        var i;
        for (i = 0; i < child.childNodes.length; i++) {
          var fragChild = child.childNodes[i];
          spliceArgs.push(fragChild);
          fragChild.parentNode = parent;
          fragChild._index = index + i;
        }
        // Remove all nodes from the document fragment
        child.childNodes.length = 0;
        // Add all nodes to the new parent, overwriting the old child
        kids.splice.apply(kids, spliceArgs);
        // Call the mutation handlers
        // Use spliceArgs since the original array has been destroyed. The
        // liveness guarantee requires us to clone the array so that
        // references to the childNodes of the DocumentFragment will be empty
        // when the insertion handlers are called.
        if (parent.rooted) {
          parent.modify();
          for (i = 2; i < spliceArgs.length; i++) {
            parent.doc.mutateInsert(spliceArgs[i]);
          }
        }
      }
      else {
        // If the child already has a parent, it needs to be
        // removed from that parent, which may also uproot it
        if (child.parentNode) child.remove();

        // Now insert the child into the parent's array of children
        child.parentNode = parent;
        if (isReplace) {
          kids[index] = child;
        } else {
          kids.splice(index, 0, child);
        }
        child._index = index;

        // And root the child if necessary
        if (parent.rooted) {
          parent.modify();
          parent.doc.mutateInsert(child);
        }
      }
    }
  }},


  // Return the lastModTime value for this node. (For use as a
  // cache invalidation mechanism. If the node does not already
  // have one, initialize it from the owner document's modclock
  // property. (Note that modclock does not return the actual
  // time; it is simply a counter incremented on each document
  // modification)
  lastModTime: { get: function() {
    if (!this._lastModTime) {
      this._lastModTime = this.doc.modclock;
    }
    return this._lastModTime;
  }},

  // Increment the owner document's modclock and use the new
  // value to update the lastModTime value for this node and
  // all of its ancestors. Nodes that have never had their
  // lastModTime value queried do not need to have a
  // lastModTime property set on them since there is no
  // previously queried value to ever compare the new value
  // against, so only update nodes that already have a
  // _lastModTime property.
  modify: { value: function() {
    if (this.doc.modclock) { // Skip while doc.modclock == 0
      var time = ++this.doc.modclock;
      for(var n = this; n; n = n.parentElement) {
        if (n._lastModTime) {
          n._lastModTime = time;
        }
      }
    }
  }},

  // This attribute is not part of the DOM but is quite helpful.
  // It returns the document with which a node is associated.  Usually
  // this is the ownerDocument. But ownerDocument is null for the
  // document object itself, so this is a handy way to get the document
  // regardless of the node type
  doc: { get: function() {
    return this.ownerDocument || this;
  }},


  // If the node has a nid (node id), then it is rooted in a document
  rooted: { get: function() {
    return !!this._nid;
  }},

  normalize: { value: function() {
    for (var i=0; i < this.childNodes.length; i++) {
      var child = this.childNodes[i];

      if (child.normalize) {
        child.normalize();
      }

      if (child.nodeType !== Node.TEXT_NODE) {
        continue;
      }

      if (child.nodeValue === "") {
        this.removeChild(child);
        i--;
        continue;
      }

      if (i) {
        var prevChild = this.childNodes[i-1];

        if (prevChild.nodeType === Node.TEXT_NODE) {
          // remove the child and decrement i
          prevChild.appendData(child.nodeValue);

          this.removeChild(child);
          i--;
        }
      }
    }
  }},

  // Convert the children of a node to an HTML string.
  // This is used by the innerHTML getter
  // The serialization spec is at:
  // http://www.whatwg.org/specs/web-apps/current-work/multipage/the-end.html#serializing-html-fragments
  serialize: { value: function() {
    var s = '';
    for(var i = 0, n = this.childNodes.length; i < n; i++) {
      var kid = this.childNodes[i];
      switch(kid.nodeType) {
      case 1: //ELEMENT_NODE
        var ns = kid.namespaceURI;
        var html = ns === NAMESPACE.HTML;
        var tagname = (html || ns === NAMESPACE.SVG || ns === NAMESPACE.MATHML) ? kid.localName : kid.tagName;

        s += '<' + tagname;

        for(var j = 0, k = kid._numattrs; j < k; j++) {
          var a = kid._attr(j);
          s += ' ' + attrname(a);
          if (a.value !== undefined) s += '="' + escapeAttr(a.value) + '"';
        }
        s += '>';

        if (!(html && emptyElements[tagname])) {
          var ss = kid.serialize();
          if (html && extraNewLine[tagname] && ss.charAt(0)==='\n') s += '\n';
          // Serialize children and add end tag for all others
          s += ss;
          s += '</' + tagname + '>';
        }
        break;
      case 3: //TEXT_NODE
      case 4: //CDATA_SECTION_NODE
        var parenttag;
        if (this.nodeType === ELEMENT_NODE &&
          this.namespaceURI === NAMESPACE.HTML)
          parenttag = this.tagName;
        else
          parenttag = '';

        if (hasRawContent[parenttag] ||
            (parenttag==='NOSCRIPT' && this.ownerDocument._scripting_enabled)) {
          s += kid.data;
        } else {
          s += escape(kid.data);
        }
        break;
      case 8: //COMMENT_NODE
        s += '<!--' + kid.data + '-->';
        break;
      case 7: //PROCESSING_INSTRUCTION_NODE
        s += '<?' + kid.target + ' ' + kid.data + '?>';
        break;
      case 10: //DOCUMENT_TYPE_NODE
        s += '<!DOCTYPE ' + kid.name;

        if (false) {
          // Latest HTML serialization spec omits the public/system ID
          if (kid.publicID) {
            s += ' PUBLIC "' + kid.publicId + '"';
          }

          if (kid.systemId) {
            s += ' "' + kid.systemId + '"';
          }
        }

        s += '>';
        break;
      default:
        utils.InvalidState();
      }
    }

    return s;
  }},

  // mirror node type properties in the prototype, so they are present
  // in instances of Node (and subclasses)
  ELEMENT_NODE:                { value: ELEMENT_NODE },
  ATTRIBUTE_NODE:              { value: ATTRIBUTE_NODE },
  TEXT_NODE:                   { value: TEXT_NODE },
  CDATA_SECTION_NODE:          { value: CDATA_SECTION_NODE },
  ENTITY_REFERENCE_NODE:       { value: ENTITY_REFERENCE_NODE },
  ENTITY_NODE:                 { value: ENTITY_NODE },
  PROCESSING_INSTRUCTION_NODE: { value: PROCESSING_INSTRUCTION_NODE },
  COMMENT_NODE:                { value: COMMENT_NODE },
  DOCUMENT_NODE:               { value: DOCUMENT_NODE },
  DOCUMENT_TYPE_NODE:          { value: DOCUMENT_TYPE_NODE },
  DOCUMENT_FRAGMENT_NODE:      { value: DOCUMENT_FRAGMENT_NODE },
  NOTATION_NODE:               { value: NOTATION_NODE }
});

function escape(s) {
  return s.replace(/[&<>\u00A0]/g, function(c) {
    switch(c) {
    case '&': return '&amp;';
    case '<': return '&lt;';
    case '>': return '&gt;';
    case '\u00A0': return '&nbsp;';
    }
  });
}

function escapeAttr(s) {
  var toEscape = /[&"\u00A0]/g;
  if (!toEscape.test(s)) {
      // nothing to do, fast path
      return s;
  } else {
      return s.replace(toEscape, function(c) {
        switch(c) {
        case '&': return '&amp;';
        case '"': return '&quot;';
        case '\u00A0': return '&nbsp;';
        }
      });
  }
}

function attrname(a) {
  var ns = a.namespaceURI;
  if (!ns)
    return a.localName;
  if (ns === NAMESPACE.XML)
    return 'xml:' + a.localName;
  if (ns === NAMESPACE.XLINK)
    return 'xlink:' + a.localName;

  if (ns === NAMESPACE.XMLNS) {
    if (a.localName === 'xmlns') return 'xmlns';
    else return 'xmlns:' + a.localName;
  }
  return a.name;
}


/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(2))(25);

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(2))(24);

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(2))(0);

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = Event;

Event.CAPTURING_PHASE = 1;
Event.AT_TARGET = 2;
Event.BUBBLING_PHASE = 3;

function Event(type, dictionary) {
  // Initialize basic event properties
  this.type = '';
  this.target = null;
  this.currentTarget = null;
  this.eventPhase = Event.AT_TARGET;
  this.bubbles = false;
  this.cancelable = false;
  this.isTrusted = false;
  this.defaultPrevented = false;
  this.timeStamp = Date.now();

  // Initialize internal flags
  // XXX: Would it be better to inherit these defaults from the prototype?
  this._propagationStopped = false;
  this._immediatePropagationStopped = false;
  this._initialized = true;
  this._dispatching = false;

  // Now initialize based on the constructor arguments (if any)
  if (type) this.type = type;
  if (dictionary) {
    for(var p in dictionary) {
      this[p] = dictionary[p];
    }
  }
}

Event.prototype = Object.create(Object.prototype, {
  constructor: { value: Event },
  stopPropagation: { value: function stopPropagation() {
    this._propagationStopped = true;
  }},

  stopImmediatePropagation: { value: function stopImmediatePropagation() {
    this._propagationStopped = true;
    this._immediatePropagationStopped = true;
  }},

  preventDefault: { value: function preventDefault() {
    if (this.cancelable) this.defaultPrevented = true;
  }},

  initEvent: { value: function initEvent(type, bubbles, cancelable) {
    this._initialized = true;
    if (this._dispatching) return;

    this._propagationStopped = false;
    this._immediatePropagationStopped = false;
    this.defaultPrevented = false;
    this.isTrusted = false;

    this.target = null;
    this.type = type;
    this.bubbles = bubbles;
    this.cancelable = cancelable;
  }},

});


/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = Element;

var xml = __webpack_require__(21);
var utils = __webpack_require__(3);
var NAMESPACE = utils.NAMESPACE;
var attributes = __webpack_require__(46);
var Node = __webpack_require__(4);
var NodeList = __webpack_require__(13);
var FilteredElementList = __webpack_require__(78);
var DOMTokenList = __webpack_require__(47);
var select = __webpack_require__(22);
var ChildNode = __webpack_require__(23);
var NonDocumentTypeChildNode = __webpack_require__(48);

function Element(doc, localName, namespaceURI, prefix) {
  this.nodeType = Node.ELEMENT_NODE;
  this.ownerDocument = doc;
  this.localName = localName;
  this.namespaceURI = namespaceURI;
  this.prefix = prefix;

  this.tagName = (prefix !== null) ? prefix + ':' + localName : localName;

  if (namespaceURI !== NAMESPACE.HTML || (!namespaceURI && !doc.isHTML)) this.isHTML = false;

  if (this.isHTML) this.tagName = this.tagName.toUpperCase();

  this.childNodes = new NodeList();

  // These properties maintain the set of attributes
  this._attrsByQName = Object.create(null); // The qname->Attr map
  this._attrsByLName = Object.create(null); // The ns|lname->Attr map
  this._attrKeys = [];     // attr index -> ns|lname

  this._index = undefined;
}

function recursiveGetText(node, a) {
  if (node.nodeType === Node.TEXT_NODE) {
    a.push(node._data);
  }
  else {
    for(var i = 0, n = node.childNodes.length;  i < n; i++)
      recursiveGetText(node.childNodes[i], a);
  }
}

Element.prototype = Object.create(Node.prototype, {
  nodeName: { get: function() { return this.tagName; }},
  nodeValue: {
    get: function() {
      return null;
    },
    set: function() {}
  },
  textContent: {
    get: function() {
      var strings = [];
      recursiveGetText(this, strings);
      return strings.join('');
    },
    set: function(newtext) {
      this.removeChildren();
      if (newtext !== null && newtext !== '') {
        this._appendChild(this.ownerDocument.createTextNode(newtext));
      }
    }
  },
  innerHTML: {
    get: function() {
      return this.serialize();
    },
    set: utils.nyi
  },
  outerHTML: {
    get: function() {
      // "the attribute must return the result of running the HTML fragment
      // serialization algorithm on a fictional node whose only child is
      // the context object"
      var fictional = {
        childNodes: [ this ],
        nodeType: 0
      };
      return Node.prototype.serialize.call(fictional);
    },
    set: utils.nyi
  },

  children: { get: function() {
    if (!this._children) {
      this._children = new ChildrenCollection(this);
    }
    return this._children;
  }},

  attributes: { get: function() {
    if (!this._attributes) {
      this._attributes = new AttributesArray(this);
    }
    return this._attributes;
  }},


  firstElementChild: { get: function() {
    var kids = this.childNodes;
    for(var i = 0, n = kids.length; i < n; i++) {
      if (kids[i].nodeType === Node.ELEMENT_NODE) return kids[i];
    }
    return null;
  }},

  lastElementChild: { get: function() {
    var kids = this.childNodes;
    for(var i = kids.length-1; i >= 0; i--) {
      if (kids[i].nodeType === Node.ELEMENT_NODE) return kids[i];
    }
    return null;
  }},

  childElementCount: { get: function() {
    return this.children.length;
  }},


  // Return the next element, in source order, after this one or
  // null if there are no more.  If root element is specified,
  // then don't traverse beyond its subtree.
  //
  // This is not a DOM method, but is convenient for
  // lazy traversals of the tree.
  nextElement: { value: function(root) {
    if (!root) root = this.ownerDocument.documentElement;
    var next = this.firstElementChild;
    if (!next) {
      // don't use sibling if we're at root
      if (this===root) return null;
      next = this.nextElementSibling;
    }
    if (next) return next;

    // If we can't go down or across, then we have to go up
    // and across to the parent sibling or another ancestor's
    // sibling.  Be careful, though: if we reach the root
    // element, or if we reach the documentElement, then
    // the traversal ends.
    for(var parent = this.parentElement;
      parent && parent !== root;
      parent = parent.parentElement) {

      next = parent.nextElementSibling;
      if (next) return next;
    }

    return null;
  }},

  // XXX:
  // Tests are currently failing for this function.
  // Awaiting resolution of:
  // http://lists.w3.org/Archives/Public/www-dom/2011JulSep/0016.html
  getElementsByTagName: { value: function getElementsByTagName(lname) {
    var filter;
    if (!lname) return new NodeList();
    if (lname === '*')
      filter = function() { return true; };
    else if (this.isHTML)
      filter = htmlLocalNameElementFilter(lname);
    else
      filter = localNameElementFilter(lname);

    return new FilteredElementList(this, filter);
  }},

  getElementsByTagNameNS: { value: function getElementsByTagNameNS(ns, lname){
    var filter;
    if (ns === '*' && lname === '*')
      filter = function() { return true; };
    else if (ns === '*')
      filter = localNameElementFilter(lname);
    else if (lname === '*')
      filter = namespaceElementFilter(ns);
    else
      filter = namespaceLocalNameElementFilter(ns, lname);

    return new FilteredElementList(this, filter);
  }},

  getElementsByClassName: { value: function getElementsByClassName(names){
    names = String(names).trim();
    if (names === '') {
      var result = new NodeList(); // Empty node list
      return result;
    }
    names = names.split(/\s+/);  // Split on spaces
    return new FilteredElementList(this, classNamesElementFilter(names));
  }},

  getElementsByName: { value: function getElementsByName(name) {
    return new FilteredElementList(this, elementNameFilter(String(name)));
  }},

  // Overwritten in the constructor if not in the HTML namespace
  isHTML: { value: true, writable: true },

  // Utility methods used by the public API methods above
  clone: { value: function clone() {
    var e;

    // XXX:
    // Modify this to use the constructor directly or
    // avoid error checking in some other way. In case we try
    // to clone an invalid node that the parser inserted.
    //
    if (this.namespaceURI !== NAMESPACE.HTML || this.prefix)
      e = this.ownerDocument.createElementNS(this.namespaceURI,
                           this.tagName);
    else
      e = this.ownerDocument.createElement(this.localName);

    for(var i = 0, n = this._attrKeys.length; i < n; i++) {
      var lname = this._attrKeys[i];
      var a = this._attrsByLName[lname];
      var b = new Attr(e, a.localName, a.prefix, a.namespaceURI);
      b.data = a.data;
      e._attrsByLName[lname] = b;
      e._addQName(b);
    }
    e._attrKeys = this._attrKeys.concat();

    return e;
  }},

  isEqual: { value: function isEqual(that) {
    if (this.localName !== that.localName ||
      this.namespaceURI !== that.namespaceURI ||
      this.prefix !== that.prefix ||
      this._numattrs !== that._numattrs)
      return false;

    // Compare the sets of attributes, ignoring order
    // and ignoring attribute prefixes.
    for(var i = 0, n = this._numattrs; i < n; i++) {
      var a = this._attr(i);
      if (!that.hasAttributeNS(a.namespaceURI, a.localName))
        return false;
      if (that.getAttributeNS(a.namespaceURI,a.localName) !== a.value)
        return false;
    }

    return true;
  }},

  // This is the 'locate a namespace prefix' algorithm from the
  // DOMCore specification.  It is used by Node.lookupPrefix()
  locateNamespacePrefix: { value: function locateNamespacePrefix(ns) {
    if (this.namespaceURI === ns && this.prefix !== null)
      return this.prefix;

    for(var i = 0, n = this._numattrs; i < n; i++) {
      var a = this._attr(i);
      if (a.prefix === 'xmlns' && a.value === ns)
        return a.localName;
    }

    var parent = this.parentElement;
    return parent ? parent.locateNamespacePrefix(ns) : null;
  }},

  // This is the 'locate a namespace' algorithm for Element nodes
  // from the DOM Core spec.  It is used by Node.lookupNamespaceURI
  locateNamespace: { value: function locateNamespace(prefix) {
    if (this.prefix === prefix && this.namespaceURI !== null)
      return this.namespaceURI;

    for(var i = 0, n = this._numattrs; i < n; i++) {
      var a = this._attr(i);
      if ((a.prefix === 'xmlns' && a.localName === prefix) ||
        (a.prefix === null && a.localName === 'xmlns')) {
        return a.value || null;
      }
    }

    var parent = this.parentElement;
    return parent ? parent.locateNamespace(prefix) : null;
  }},

  //
  // Attribute handling methods and utilities
  //

  /*
   * Attributes in the DOM are tricky:
   *
   * - there are the 8 basic get/set/has/removeAttribute{NS} methods
   *
   * - but many HTML attributes are also 'reflected' through IDL
   *   attributes which means that they can be queried and set through
   *   regular properties of the element.  There is just one attribute
   *   value, but two ways to get and set it.
   *
   * - Different HTML element types have different sets of reflected
     attributes.
   *
   * - attributes can also be queried and set through the .attributes
   *   property of an element.  This property behaves like an array of
   *   Attr objects.  The value property of each Attr is writeable, so
   *   this is a third way to read and write attributes.
   *
   * - for efficiency, we really want to store attributes in some kind
   *   of name->attr map.  But the attributes[] array is an array, not a
   *   map, which is kind of unnatural.
   *
   * - When using namespaces and prefixes, and mixing the NS methods
   *   with the non-NS methods, it is apparently actually possible for
   *   an attributes[] array to have more than one attribute with the
   *   same qualified name.  And certain methods must operate on only
   *   the first attribute with such a name.  So for these methods, an
   *   inefficient array-like data structure would be easier to
   *   implement.
   *
   * - The attributes[] array is live, not a snapshot, so changes to the
   *   attributes must be immediately visible through existing arrays.
   *
   * - When attributes are queried and set through IDL properties
   *   (instead of the get/setAttributes() method or the attributes[]
   *   array) they may be subject to type conversions, URL
   *   normalization, etc., so some extra processing is required in that
   *   case.
   *
   * - But access through IDL properties is probably the most common
   *   case, so we'd like that to be as fast as possible.
   *
   * - We can't just store attribute values in their parsed idl form,
   *   because setAttribute() has to return whatever string is passed to
   *   getAttribute even if it is not a legal, parseable value. So
   *   attribute values must be stored in unparsed string form.
   *
   * - We need to be able to send change notifications or mutation
   *   events of some sort to the renderer whenever an attribute value
   *   changes, regardless of the way in which it changes.
   *
   * - Some attributes, such as id and class affect other parts of the
   *   DOM API, like getElementById and getElementsByClassName and so
   *   for efficiency, we need to specially track changes to these
   *   special attributes.
   *
   * - Some attributes like class have different names (className) when
   *   reflected.
   *
   * - Attributes whose names begin with the string 'data-' are treated
     specially.
   *
   * - Reflected attributes that have a boolean type in IDL have special
   *   behavior: setting them to false (in IDL) is the same as removing
   *   them with removeAttribute()
   *
   * - numeric attributes (like HTMLElement.tabIndex) can have default
   *   values that must be returned by the idl getter even if the
   *   content attribute does not exist. (The default tabIndex value
   *   actually varies based on the type of the element, so that is a
   *   tricky one).
   *
   * See
   * http://www.whatwg.org/specs/web-apps/current-work/multipage/urls.html#reflect
   * for rules on how attributes are reflected.
   *
   */

  getAttribute: { value: function getAttribute(qname) {
    if (this.isHTML) qname = utils.toASCIILowerCase(qname);
    var attr = this._attrsByQName[qname];
    if (!attr) return null;

    if (Array.isArray(attr))  // If there is more than one
      attr = attr[0];         // use the first

    return attr.value;
  }},

  getAttributeNS: { value: function getAttributeNS(ns, lname) {
    var attr = this._attrsByLName[(ns === null ? '' : ns) + '|' + lname];
    return attr ? attr.value : null;
  }},

  hasAttribute: { value: function hasAttribute(qname) {
    if (this.isHTML) qname = utils.toASCIILowerCase(qname);
    return this._attrsByQName[qname] !== undefined;
  }},

  hasAttributeNS: { value: function hasAttributeNS(ns, lname) {
    var key = (ns === null ? '' : ns) + '|' + lname;
    return this._attrsByLName[key] !== undefined;
  }},

  // Set the attribute without error checking. The parser uses this.
  _setAttribute: { value: function _setAttribute(qname, value) {
    // XXX: the spec says that this next search should be done
    // on the local name, but I think that is an error.
    // email pending on www-dom about it.
    var attr = this._attrsByQName[qname];
    var isnew;
    if (!attr) {
      attr = this._newattr(qname);
      isnew = true;
    }
    else {
      if (Array.isArray(attr)) attr = attr[0];
    }

    // Now set the attribute value on the new or existing Attr object.
    // The Attr.value setter method handles mutation events, etc.
    attr.value = value;
    if (this._attributes) this._attributes[qname] = attr;
    if (isnew && this._newattrhook) this._newattrhook(qname, value);
  }},

  // Check for errors, and then set the attribute
  setAttribute: { value: function setAttribute(qname, value) {
    if (!xml.isValidName(qname)) utils.InvalidCharacterError();
    if (this.isHTML) qname = utils.toASCIILowerCase(qname);
    if (qname.substring(0, 5) === 'xmlns') utils.NamespaceError();
    this._setAttribute(qname, String(value));
  }},


  // The version with no error checking used by the parser
  _setAttributeNS: { value: function _setAttributeNS(ns, qname, value) {
    var pos = qname.indexOf(':'), prefix, lname;
    if (pos === -1) {
      prefix = null;
      lname = qname;
    }
    else {
      prefix = qname.substring(0, pos);
      lname = qname.substring(pos+1);
    }

    var key = (ns === null ? '' : ns) + '|' + lname;
    if (ns === '') ns = null;

    var attr = this._attrsByLName[key];
    var isnew;
    if (!attr) {
      attr = new Attr(this, lname, prefix, ns);
      isnew = true;
      this._attrsByLName[key] = attr;
      this._attrKeys.push(key);

      // We also have to make the attr searchable by qname.
      // But we have to be careful because there may already
      // be an attr with this qname.
      this._addQName(attr);
    }
    else {
      // Calling setAttributeNS() can change the prefix of an
      // existing attribute!
      if (attr.prefix !== prefix) {
        // Unbind the old qname
        this._removeQName(attr);
        // Update the prefix
        attr.prefix = prefix;
        // Bind the new qname
        this._addQName(attr);

      }

    }
    attr.value = value; // Automatically sends mutation event
    if (isnew && this._newattrhook) this._newattrhook(qname, value);
  }},

  // Do error checking then call _setAttributeNS
  setAttributeNS: { value: function setAttributeNS(ns, qname, value) {
    if (!xml.isValidName(qname)) utils.InvalidCharacterError();
    if (!xml.isValidQName(qname)) utils.NamespaceError();

    var pos = qname.indexOf(':');
    var prefix = (pos === -1) ? null : qname.substring(0, pos);
    if (ns === '') ns = null;

    if ((prefix !== null && ns === null) ||
      (prefix === 'xml' && ns !== NAMESPACE.XML) ||
      ((qname === 'xmlns' || prefix === 'xmlns') &&
       (ns !== NAMESPACE.XMLNS)) ||
      (ns === NAMESPACE.XMLNS &&
       !(qname === 'xmlns' || prefix === 'xmlns')))
      utils.NamespaceError();

    this._setAttributeNS(ns, qname, String(value));
  }},

  removeAttribute: { value: function removeAttribute(qname) {
    if (this.isHTML) qname = utils.toASCIILowerCase(qname);

    var attr = this._attrsByQName[qname];
    if (!attr) return;

    // If there is more than one match for this qname
    // so don't delete the qname mapping, just remove the first
    // element from it.
    if (Array.isArray(attr)) {
      if (attr.length > 2) {
        attr = attr.shift();  // remove it from the array
      }
      else {
        this._attrsByQName[qname] = attr[1];
        attr = attr[0];
      }
    }
    else {
      // only a single match, so remove the qname mapping
      this._attrsByQName[qname] = undefined;
    }

    var ns = attr.namespaceURI;
    // Now attr is the removed attribute.  Figure out its
    // ns+lname key and remove it from the other mapping as well.
    var key = (ns === null ? '' : ns) + '|' + attr.localName;
    this._attrsByLName[key] = undefined;

    var i = this._attrKeys.indexOf(key);
    this._attrKeys.splice(i, 1);

    if (this._attributes)
      this._attributes[qname] = undefined;

    // Onchange handler for the attribute
    if (attr.onchange)
      attr.onchange(this, attr.localName, attr.value, null);

    // Mutation event
    if (this.rooted) this.ownerDocument.mutateRemoveAttr(attr);
  }},

  removeAttributeNS: { value: function removeAttributeNS(ns, lname) {
    var key = (ns === null ? '' : ns) + '|' + lname;
    var attr = this._attrsByLName[key];
    if (!attr) return;

    this._attrsByLName[key] = undefined;

    var i = this._attrKeys.indexOf(key);
    this._attrKeys.splice(i, 1);

    // Now find the same Attr object in the qname mapping and remove it
    // But be careful because there may be more than one match.
    this._removeQName(attr);

    // Onchange handler for the attribute
    if (attr.onchange)
      attr.onchange(this, attr.localName, attr.value, null);
    // Mutation event
    if (this.rooted) this.ownerDocument.mutateRemoveAttr(attr);
  }},

  // This 'raw' version of getAttribute is used by the getter functions
  // of reflected attributes. It skips some error checking and
  // namespace steps
  _getattr: { value: function _getattr(qname) {
    // Assume that qname is already lowercased, so don't do it here.
    // Also don't check whether attr is an array: a qname with no
    // prefix will never have two matching Attr objects (because
    // setAttributeNS doesn't allow a non-null namespace with a
    // null prefix.
    var attr = this._attrsByQName[qname];
    return attr ? attr.value : null;
  }},

  // The raw version of setAttribute for reflected idl attributes.
  _setattr: { value: function _setattr(qname, value) {
    var attr = this._attrsByQName[qname];
    var isnew;
    if (!attr) {
      attr = this._newattr(qname);
      isnew = true;
    }
    attr.value = String(value);
    if (this._attributes) this._attributes[qname] = attr;
    if (isnew && this._newattrhook) this._newattrhook(qname, value);
  }},

  // Create a new Attr object, insert it, and return it.
  // Used by setAttribute() and by set()
  _newattr: { value: function _newattr(qname) {
    var attr = new Attr(this, qname, null, null);
    var key = '|' + qname;
    this._attrsByQName[qname] = attr;
    this._attrsByLName[key] = attr;
    this._attrKeys.push(key);
    return attr;
  }},

  // Add a qname->Attr mapping to the _attrsByQName object, taking into
  // account that there may be more than one attr object with the
  // same qname
  _addQName: { value: function(attr) {
    var qname = attr.name;
    var existing = this._attrsByQName[qname];
    if (!existing) {
      this._attrsByQName[qname] = attr;
    }
    else if (Array.isArray(existing)) {
      existing.push(attr);
    }
    else {
      this._attrsByQName[qname] = [existing, attr];
    }
    if (this._attributes) this._attributes[qname] = attr;
  }},

  // Remove a qname->Attr mapping to the _attrsByQName object, taking into
  // account that there may be more than one attr object with the
  // same qname
  _removeQName: { value: function(attr) {
    var qname = attr.name;
    var target = this._attrsByQName[qname];

    if (Array.isArray(target)) {
      var idx = target.indexOf(attr);
      utils.assert(idx !== -1); // It must be here somewhere
      if (target.length === 2) {
        this._attrsByQName[qname] = target[1-idx];
      }
      else {
        target.splice(idx, 1);
      }
    }
    else {
      utils.assert(target === attr);  // If only one, it must match
      this._attrsByQName[qname] = undefined;
    }
  }},

  // Return the number of attributes
  _numattrs: { get: function() { return this._attrKeys.length; }},
  // Return the nth Attr object
  _attr: { value: function(n) {
    return this._attrsByLName[this._attrKeys[n]];
  }},

  // Define getters and setters for an 'id' property that reflects
  // the content attribute 'id'.
  id: attributes.property({name: 'id'}),

  // Define getters and setters for a 'className' property that reflects
  // the content attribute 'class'.
  className: attributes.property({name: 'class'}),

  classList: { get: function() {
    var self = this;
    if (this._classList) {
      return this._classList;
    }
    var dtlist = new DOMTokenList(
      function() {
        return self.className || "";
      },
      function(v) {
        self.className = v;
      }
    );
    this._classList = dtlist;
    return dtlist;
  }},

  matches: { value: function(selector) {
    return select.matches(this, selector);
  }},

  closest: { value: function(selector) {
    var el = this;
    while (el.matches && !el.matches(selector)) el = el.parentNode;
    return el.matches ? el : null;
  }},

  querySelector: { value: function(selector) {
    return select(selector, this)[0];
  }},

  querySelectorAll: { value: function(selector) {
    var nodes = select(selector, this);
    return nodes.item ? nodes : new NodeList(nodes);
  }}

});

Object.defineProperties(Element.prototype, ChildNode);
Object.defineProperties(Element.prototype, NonDocumentTypeChildNode);

// Register special handling for the id attribute
attributes.registerChangeHandler(Element, 'id',
 function(element, lname, oldval, newval) {
   if (element.rooted) {
     if (oldval) {
       element.ownerDocument.delId(oldval, element);
     }
     if (newval) {
       element.ownerDocument.addId(newval, element);
     }
   }
 }
);


// The Attr class represents a single attribute.  The values in
// _attrsByQName and _attrsByLName are instances of this class.
function Attr(elt, lname, prefix, namespace) {
  // Always remember what element we're associated with.
  // We need this to property handle mutations
  this.ownerElement = elt;

  if (!namespace && !prefix && elt._attributeChangeHandlers[lname])
    this.onchange = elt._attributeChangeHandlers[lname];

  // localName and namespace are constant for any attr object.
  // But value may change.  And so can prefix, and so, therefore can name.
  this.localName = lname;
  this.prefix = (prefix===null || prefix==='') ? null : ('' + prefix);
  this.namespaceURI = (namespace===null || namespace==='') ? null : ('' + namespace);
}

Attr.prototype = {
  get name() {
    return this.prefix ? this.prefix + ':' + this.localName : this.localName;
  },

  get value() {
    return this.data;
  },

  get specified() {
    // Deprecated
    return true;
  },

  set value(value) {
    var oldval = this.data;
    value = (value === undefined) ? '' : value + '';
    if (value === oldval) return;

    this.data = value;

    // Run the onchange hook for the attribute
    // if there is one.
    if (this.onchange)
      this.onchange(this.ownerElement,this.localName, oldval, value);

    // Generate a mutation event if the element is rooted
    if (this.ownerElement.rooted)
      this.ownerElement.ownerDocument.mutateAttr(this, oldval);
  },

  // Legacy aliases (see gh#70 and https://dom.spec.whatwg.org/#interface-attr)
  get nodeName() { return this.name; },
  get nodeValue() { return this.value; },
  get textContent() { return this.value; },
  set nodeValue(v) { this.value = v; },
  set textContent(v) { this.value = v; },
};


// The attributes property of an Element will be an instance of this class.
// This class is really just a dummy, though. It only defines a length
// property and an item() method. The AttrArrayProxy that
// defines the public API just uses the Element object itself.
function AttributesArray(elt) {
  this.element = elt;
  for (var name in elt._attrsByQName) {
    this[name] = elt._attrsByQName[name];
  }
}
AttributesArray.prototype = {
  get length() {
    return this.element._attrKeys.length;
  },
  item: function(n) {
    return this.element._attrsByLName[this.element._attrKeys[n]];
  }
};


// The children property of an Element will be an instance of this class.
// It defines length, item() and namedItem() and will be wrapped by an
// HTMLCollection when exposed through the DOM.
function ChildrenCollection(e) {
  this.element = e;
  this.updateCache();
}

ChildrenCollection.prototype = {
  get length() {
    this.updateCache();
    return this.childrenByNumber.length;
  },
  item: function item(n) {
    this.updateCache();
    return this.childrenByNumber[n] || null;
  },

  namedItem: function namedItem(name) {
    this.updateCache();
    return this.childrenByName[name] || null;
  },

  // This attribute returns the entire name->element map.
  // It is not part of the HTMLCollection API, but we need it in
  // src/HTMLCollectionProxy
  get namedItems() {
    this.updateCache();
    return this.childrenByName;
  },

  updateCache: function updateCache() {
    var namedElts = /^(a|applet|area|embed|form|frame|frameset|iframe|img|object)$/;
    if (this.lastModTime !== this.element.lastModTime) {
      this.lastModTime = this.element.lastModTime;

      var n = this.childrenByNumber && this.childrenByNumber.length || 0;
      for(var i = 0; i < n; i++) {
        this[i] = undefined;
      }

      this.childrenByNumber = [];
      this.childrenByName = Object.create(null);

      for(i = 0, n = this.element.childNodes.length; i < n; i++) {
        var c = this.element.childNodes[i];
        if (c.nodeType === Node.ELEMENT_NODE) {

          this[this.childrenByNumber.length] = c;
          this.childrenByNumber.push(c);

          // XXX Are there any requirements about the namespace
          // of the id property?
          var id = c.getAttribute('id');

          // If there is an id that is not already in use...
          if (id && !this.childrenByName[id])
            this.childrenByName[id] = c;

          // For certain HTML elements we check the name attribute
          var name = c.getAttribute('name');
          if (name &&
            this.element.namespaceURI === NAMESPACE.HTML &&
            namedElts.test(this.element.localName) &&
            !this.childrenByName[name])
            this.childrenByName[id] = c;
        }
      }
    }
  }
};

// These functions return predicates for filtering elements.
// They're used by the Document and Element classes for methods like
// getElementsByTagName and getElementsByClassName

function localNameElementFilter(lname) {
  return function(e) { return e.localName === lname; };
}

function htmlLocalNameElementFilter(lname) {
  var lclname = utils.toASCIILowerCase(lname);
  if (lclname === lname)
    return localNameElementFilter(lname);

  return function(e) {
    return e.isHTML ? e.localName === lclname : e.localName === lname;
  };
}

function namespaceElementFilter(ns) {
  return function(e) { return e.namespaceURI === ns; };
}

function namespaceLocalNameElementFilter(ns, lname) {
  return function(e) {
    return e.namespaceURI === ns && e.localName === lname;
  };
}

// XXX
// Optimize this when I implement classList.
function classNamesElementFilter(names) {
  return function(e) {
    var classAttr = e.getAttribute('class');
    if (!classAttr) return false;
    var classes = classAttr.trim().split(/\s+/);
    return names.every(function(n) {
      return classes.indexOf(n) !== -1;
    });
  };
}

function elementNameFilter(name) {
  return function(e) {
    return e.getAttribute('name') === name;
  };
}


/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(2))(379);

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * @license Angular v5.0.0-beta.7
 * (c) 2010-2017 Google, Inc. https://angular.io/
 * License: MIT
 */
(function (global, factory) {
	 true ? factory(exports, __webpack_require__(0), __webpack_require__(70), __webpack_require__(71), __webpack_require__(36), __webpack_require__(72), __webpack_require__(1), __webpack_require__(5), __webpack_require__(7)) :
	typeof define === 'function' && define.amd ? define(['exports', '@angular/core', 'rxjs/observable/of', 'rxjs/operator/concatMap', 'rxjs/operator/filter', 'rxjs/operator/map', 'tslib', '@angular/common', 'rxjs/Observable'], factory) :
	(factory((global.ng = global.ng || {}, global.ng.common = global.ng.common || {}, global.ng.common.http = {}),global.ng.core,global.Rx.Observable.prototype,global.Rx.Observable.prototype,global.Rx.Observable.prototype,global.Rx.Observable.prototype,global.tslib,global.ng.common,global.Rx));
}(this, (function (exports,_angular_core,rxjs_observable_of,rxjs_operator_concatMap,rxjs_operator_filter,rxjs_operator_map,tslib,_angular_common,rxjs_Observable) { 'use strict';

/**
 * @license Angular v5.0.0-beta.7
 * (c) 2010-2017 Google, Inc. https://angular.io/
 * License: MIT
 */
/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Transforms an `HttpRequest` into a stream of `HttpEvent`s, one of which will likely be a
 * `HttpResponse`.
 *
 * `HttpHandler` is injectable. When injected, the handler instance dispatches requests to the
 * first interceptor in the chain, which dispatches to the second, etc, eventually reaching the
 * `HttpBackend`.
 *
 * In an `HttpInterceptor`, the `HttpHandler` parameter is the next interceptor in the chain.
 *
 * \@stable
 * @abstract
 */
var HttpHandler = (function () {
    function HttpHandler() {
    }
    return HttpHandler;
}());
/**
 * A final `HttpHandler` which will dispatch the request via browser HTTP APIs to a backend.
 *
 * Interceptors sit between the `HttpClient` interface and the `HttpBackend`.
 *
 * When injected, `HttpBackend` dispatches requests directly to the backend, without going
 * through the interceptor chain.
 *
 * \@stable
 * @abstract
 */
var HttpBackend = (function () {
    function HttpBackend() {
    }
    return HttpBackend;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @record
 */
/**
 * Immutable set of Http headers, with lazy parsing.
 * \@stable
 */
var HttpHeaders = (function () {
    function HttpHeaders(headers) {
        var _this = this;
        /**
         * Internal map of lowercased header names to the normalized
         * form of the name (the form seen first).
         */
        this.normalizedNames = new Map();
        /**
         * Queued updates to be materialized the next initialization.
         */
        this.lazyUpdate = null;
        if (!headers) {
            this.headers = new Map();
        }
        else if (typeof headers === 'string') {
            this.lazyInit = function () {
                _this.headers = new Map();
                headers.split('\n').forEach(function (line) {
                    var /** @type {?} */ index = line.indexOf(':');
                    if (index > 0) {
                        var /** @type {?} */ name_1 = line.slice(0, index);
                        var /** @type {?} */ key = name_1.toLowerCase();
                        var /** @type {?} */ value = line.slice(index + 1).trim();
                        _this.maybeSetNormalizedName(name_1, key);
                        if (_this.headers.has(key)) {
                            /** @type {?} */ ((_this.headers.get(key))).push(value);
                        }
                        else {
                            _this.headers.set(key, [value]);
                        }
                    }
                });
            };
        }
        else {
            this.lazyInit = function () {
                _this.headers = new Map();
                Object.keys(headers).forEach(function (name) {
                    var /** @type {?} */ values = headers[name];
                    var /** @type {?} */ key = name.toLowerCase();
                    if (typeof values === 'string') {
                        values = [values];
                    }
                    if (values.length > 0) {
                        _this.headers.set(key, values);
                        _this.maybeSetNormalizedName(name, key);
                    }
                });
            };
        }
    }
    /**
     * Checks for existence of header by given name.
     */
    /**
     * Checks for existence of header by given name.
     * @param {?} name
     * @return {?}
     */
    HttpHeaders.prototype.has = /**
     * Checks for existence of header by given name.
     * @param {?} name
     * @return {?}
     */
    function (name) {
        this.init();
        return this.headers.has(name.toLowerCase());
    };
    /**
     * Returns first header that matches given name.
     */
    /**
     * Returns first header that matches given name.
     * @param {?} name
     * @return {?}
     */
    HttpHeaders.prototype.get = /**
     * Returns first header that matches given name.
     * @param {?} name
     * @return {?}
     */
    function (name) {
        this.init();
        var /** @type {?} */ values = this.headers.get(name.toLowerCase());
        return values && values.length > 0 ? values[0] : null;
    };
    /**
     * Returns the names of the headers
     */
    /**
     * Returns the names of the headers
     * @return {?}
     */
    HttpHeaders.prototype.keys = /**
     * Returns the names of the headers
     * @return {?}
     */
    function () {
        this.init();
        return Array.from(this.normalizedNames.values());
    };
    /**
     * Returns list of header values for a given name.
     */
    /**
     * Returns list of header values for a given name.
     * @param {?} name
     * @return {?}
     */
    HttpHeaders.prototype.getAll = /**
     * Returns list of header values for a given name.
     * @param {?} name
     * @return {?}
     */
    function (name) {
        this.init();
        return this.headers.get(name.toLowerCase()) || null;
    };
    /**
     * @param {?} name
     * @param {?} value
     * @return {?}
     */
    HttpHeaders.prototype.append = /**
     * @param {?} name
     * @param {?} value
     * @return {?}
     */
    function (name, value) {
        return this.clone({ name: name, value: value, op: 'a' });
    };
    /**
     * @param {?} name
     * @param {?} value
     * @return {?}
     */
    HttpHeaders.prototype.set = /**
     * @param {?} name
     * @param {?} value
     * @return {?}
     */
    function (name, value) {
        return this.clone({ name: name, value: value, op: 's' });
    };
    /**
     * @param {?} name
     * @param {?=} value
     * @return {?}
     */
    HttpHeaders.prototype.delete = /**
     * @param {?} name
     * @param {?=} value
     * @return {?}
     */
    function (name, value) {
        return this.clone({ name: name, value: value, op: 'd' });
    };
    /**
     * @param {?} name
     * @param {?} lcName
     * @return {?}
     */
    HttpHeaders.prototype.maybeSetNormalizedName = /**
     * @param {?} name
     * @param {?} lcName
     * @return {?}
     */
    function (name, lcName) {
        if (!this.normalizedNames.has(lcName)) {
            this.normalizedNames.set(lcName, name);
        }
    };
    /**
     * @return {?}
     */
    HttpHeaders.prototype.init = /**
     * @return {?}
     */
    function () {
        var _this = this;
        if (!!this.lazyInit) {
            if (this.lazyInit instanceof HttpHeaders) {
                this.copyFrom(this.lazyInit);
            }
            else {
                this.lazyInit();
            }
            this.lazyInit = null;
            if (!!this.lazyUpdate) {
                this.lazyUpdate.forEach(function (update) { return _this.applyUpdate(update); });
                this.lazyUpdate = null;
            }
        }
    };
    /**
     * @param {?} other
     * @return {?}
     */
    HttpHeaders.prototype.copyFrom = /**
     * @param {?} other
     * @return {?}
     */
    function (other) {
        var _this = this;
        other.init();
        Array.from(other.headers.keys()).forEach(function (key) {
            _this.headers.set(key, /** @type {?} */ ((other.headers.get(key))));
            _this.normalizedNames.set(key, /** @type {?} */ ((other.normalizedNames.get(key))));
        });
    };
    /**
     * @param {?} update
     * @return {?}
     */
    HttpHeaders.prototype.clone = /**
     * @param {?} update
     * @return {?}
     */
    function (update) {
        var /** @type {?} */ clone = new HttpHeaders();
        clone.lazyInit =
            (!!this.lazyInit && this.lazyInit instanceof HttpHeaders) ? this.lazyInit : this;
        clone.lazyUpdate = (this.lazyUpdate || []).concat([update]);
        return clone;
    };
    /**
     * @param {?} update
     * @return {?}
     */
    HttpHeaders.prototype.applyUpdate = /**
     * @param {?} update
     * @return {?}
     */
    function (update) {
        var /** @type {?} */ key = update.name.toLowerCase();
        switch (update.op) {
            case 'a':
            case 's':
                var /** @type {?} */ value = /** @type {?} */ ((update.value));
                if (typeof value === 'string') {
                    value = [value];
                }
                if (value.length === 0) {
                    return;
                }
                this.maybeSetNormalizedName(update.name, key);
                var /** @type {?} */ base = (update.op === 'a' ? this.headers.get(key) : undefined) || [];
                base.push.apply(base, value);
                this.headers.set(key, base);
                break;
            case 'd':
                var /** @type {?} */ toDelete_1 = /** @type {?} */ (update.value);
                if (!toDelete_1) {
                    this.headers.delete(key);
                    this.normalizedNames.delete(key);
                }
                else {
                    var /** @type {?} */ existing = this.headers.get(key);
                    if (!existing) {
                        return;
                    }
                    existing = existing.filter(function (value) { return toDelete_1.indexOf(value) === -1; });
                    if (existing.length === 0) {
                        this.headers.delete(key);
                        this.normalizedNames.delete(key);
                    }
                    else {
                        this.headers.set(key, existing);
                    }
                }
                break;
        }
    };
    /**
     * @internal
     */
    /**
     * \@internal
     * @param {?} fn
     * @return {?}
     */
    HttpHeaders.prototype.forEach = /**
     * \@internal
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
        var _this = this;
        this.init();
        Array.from(this.normalizedNames.keys())
            .forEach(function (key) { return fn(/** @type {?} */ ((_this.normalizedNames.get(key))), /** @type {?} */ ((_this.headers.get(key)))); });
    };
    return HttpHeaders;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * A codec for encoding and decoding parameters in URLs.
 *
 * Used by `HttpParams`.
 *
 * \@stable
 *
 * @record
 */

/**
 * A `HttpParameterCodec` that uses `encodeURIComponent` and `decodeURIComponent` to
 * serialize and parse URL parameter keys and values.
 *
 * \@stable
 */
var HttpUrlEncodingCodec = (function () {
    function HttpUrlEncodingCodec() {
    }
    /**
     * @param {?} k
     * @return {?}
     */
    HttpUrlEncodingCodec.prototype.encodeKey = /**
     * @param {?} k
     * @return {?}
     */
    function (k) { return standardEncoding(k); };
    /**
     * @param {?} v
     * @return {?}
     */
    HttpUrlEncodingCodec.prototype.encodeValue = /**
     * @param {?} v
     * @return {?}
     */
    function (v) { return standardEncoding(v); };
    /**
     * @param {?} k
     * @return {?}
     */
    HttpUrlEncodingCodec.prototype.decodeKey = /**
     * @param {?} k
     * @return {?}
     */
    function (k) { return decodeURIComponent(k); };
    /**
     * @param {?} v
     * @return {?}
     */
    HttpUrlEncodingCodec.prototype.decodeValue = /**
     * @param {?} v
     * @return {?}
     */
    function (v) { return decodeURIComponent(v); };
    return HttpUrlEncodingCodec;
}());
/**
 * @param {?} rawParams
 * @param {?} codec
 * @return {?}
 */
function paramParser(rawParams, codec) {
    var /** @type {?} */ map$$1 = new Map();
    if (rawParams.length > 0) {
        var /** @type {?} */ params = rawParams.split('&');
        params.forEach(function (param) {
            var /** @type {?} */ eqIdx = param.indexOf('=');
            var _a = eqIdx == -1 ?
                [codec.decodeKey(param), ''] :
                [codec.decodeKey(param.slice(0, eqIdx)), codec.decodeValue(param.slice(eqIdx + 1))], key = _a[0], val = _a[1];
            var /** @type {?} */ list = map$$1.get(key) || [];
            list.push(val);
            map$$1.set(key, list);
        });
    }
    return map$$1;
}
/**
 * @param {?} v
 * @return {?}
 */
function standardEncoding(v) {
    return encodeURIComponent(v)
        .replace(/%40/gi, '@')
        .replace(/%3A/gi, ':')
        .replace(/%24/gi, '$')
        .replace(/%2C/gi, ',')
        .replace(/%3B/gi, ';')
        .replace(/%2B/gi, '+')
        .replace(/%3D/gi, '=')
        .replace(/%3F/gi, '?')
        .replace(/%2F/gi, '/');
}
/**
 * An HTTP request/response body that represents serialized parameters,
 * per the MIME type `application/x-www-form-urlencoded`.
 *
 * This class is immutable - all mutation operations return a new instance.
 *
 * \@stable
 */
var HttpParams = (function () {
    function HttpParams(options) {
        if (options === void 0) { options = {}; }
        var _this = this;
        this.updates = null;
        this.cloneFrom = null;
        this.encoder = options.encoder || new HttpUrlEncodingCodec();
        if (!!options.fromString) {
            if (!!options.fromObject) {
                throw new Error("Cannot specify both fromString and fromObject.");
            }
            this.map = paramParser(options.fromString, this.encoder);
        }
        else if (!!options.fromObject) {
            this.map = new Map();
            Object.keys(options.fromObject).forEach(function (key) {
                var /** @type {?} */ value = (/** @type {?} */ (options.fromObject))[key]; /** @type {?} */
                ((_this.map)).set(key, Array.isArray(value) ? value : [value]);
            });
        }
        else {
            this.map = null;
        }
    }
    /**
     * Check whether the body has one or more values for the given parameter name.
     */
    /**
     * Check whether the body has one or more values for the given parameter name.
     * @param {?} param
     * @return {?}
     */
    HttpParams.prototype.has = /**
     * Check whether the body has one or more values for the given parameter name.
     * @param {?} param
     * @return {?}
     */
    function (param) {
        this.init();
        return /** @type {?} */ ((this.map)).has(param);
    };
    /**
     * Get the first value for the given parameter name, or `null` if it's not present.
     */
    /**
     * Get the first value for the given parameter name, or `null` if it's not present.
     * @param {?} param
     * @return {?}
     */
    HttpParams.prototype.get = /**
     * Get the first value for the given parameter name, or `null` if it's not present.
     * @param {?} param
     * @return {?}
     */
    function (param) {
        this.init();
        var /** @type {?} */ res = /** @type {?} */ ((this.map)).get(param);
        return !!res ? res[0] : null;
    };
    /**
     * Get all values for the given parameter name, or `null` if it's not present.
     */
    /**
     * Get all values for the given parameter name, or `null` if it's not present.
     * @param {?} param
     * @return {?}
     */
    HttpParams.prototype.getAll = /**
     * Get all values for the given parameter name, or `null` if it's not present.
     * @param {?} param
     * @return {?}
     */
    function (param) {
        this.init();
        return /** @type {?} */ ((this.map)).get(param) || null;
    };
    /**
     * Get all the parameter names for this body.
     */
    /**
     * Get all the parameter names for this body.
     * @return {?}
     */
    HttpParams.prototype.keys = /**
     * Get all the parameter names for this body.
     * @return {?}
     */
    function () {
        this.init();
        return Array.from(/** @type {?} */ ((this.map)).keys());
    };
    /**
     * Construct a new body with an appended value for the given parameter name.
     */
    /**
     * Construct a new body with an appended value for the given parameter name.
     * @param {?} param
     * @param {?} value
     * @return {?}
     */
    HttpParams.prototype.append = /**
     * Construct a new body with an appended value for the given parameter name.
     * @param {?} param
     * @param {?} value
     * @return {?}
     */
    function (param, value) { return this.clone({ param: param, value: value, op: 'a' }); };
    /**
     * Construct a new body with a new value for the given parameter name.
     */
    /**
     * Construct a new body with a new value for the given parameter name.
     * @param {?} param
     * @param {?} value
     * @return {?}
     */
    HttpParams.prototype.set = /**
     * Construct a new body with a new value for the given parameter name.
     * @param {?} param
     * @param {?} value
     * @return {?}
     */
    function (param, value) { return this.clone({ param: param, value: value, op: 's' }); };
    /**
     * Construct a new body with either the given value for the given parameter
     * removed, if a value is given, or all values for the given parameter removed
     * if not.
     */
    /**
     * Construct a new body with either the given value for the given parameter
     * removed, if a value is given, or all values for the given parameter removed
     * if not.
     * @param {?} param
     * @param {?=} value
     * @return {?}
     */
    HttpParams.prototype.delete = /**
     * Construct a new body with either the given value for the given parameter
     * removed, if a value is given, or all values for the given parameter removed
     * if not.
     * @param {?} param
     * @param {?=} value
     * @return {?}
     */
    function (param, value) { return this.clone({ param: param, value: value, op: 'd' }); };
    /**
     * Serialize the body to an encoded string, where key-value pairs (separated by `=`) are
     * separated by `&`s.
     */
    /**
     * Serialize the body to an encoded string, where key-value pairs (separated by `=`) are
     * separated by `&`s.
     * @return {?}
     */
    HttpParams.prototype.toString = /**
     * Serialize the body to an encoded string, where key-value pairs (separated by `=`) are
     * separated by `&`s.
     * @return {?}
     */
    function () {
        var _this = this;
        this.init();
        return this.keys()
            .map(function (key) {
            var /** @type {?} */ eKey = _this.encoder.encodeKey(key);
            return /** @type {?} */ ((/** @type {?} */ ((_this.map)).get(key))).map(function (value) { return eKey + '=' + _this.encoder.encodeValue(value); }).join('&');
        })
            .join('&');
    };
    /**
     * @param {?} update
     * @return {?}
     */
    HttpParams.prototype.clone = /**
     * @param {?} update
     * @return {?}
     */
    function (update) {
        var /** @type {?} */ clone = new HttpParams({ encoder: this.encoder });
        clone.cloneFrom = this.cloneFrom || this;
        clone.updates = (this.updates || []).concat([update]);
        return clone;
    };
    /**
     * @return {?}
     */
    HttpParams.prototype.init = /**
     * @return {?}
     */
    function () {
        var _this = this;
        if (this.map === null) {
            this.map = new Map();
        }
        if (this.cloneFrom !== null) {
            this.cloneFrom.init();
            this.cloneFrom.keys().forEach(function (key) { return /** @type {?} */ ((_this.map)).set(key, /** @type {?} */ ((/** @type {?} */ ((/** @type {?} */ ((_this.cloneFrom)).map)).get(key)))); }); /** @type {?} */
            ((this.updates)).forEach(function (update) {
                switch (update.op) {
                    case 'a':
                    case 's':
                        var /** @type {?} */ base = (update.op === 'a' ? /** @type {?} */ ((_this.map)).get(update.param) : undefined) || [];
                        base.push(/** @type {?} */ ((update.value))); /** @type {?} */
                        ((_this.map)).set(update.param, base);
                        break;
                    case 'd':
                        if (update.value !== undefined) {
                            var /** @type {?} */ base_1 = /** @type {?} */ ((_this.map)).get(update.param) || [];
                            var /** @type {?} */ idx = base_1.indexOf(update.value);
                            if (idx !== -1) {
                                base_1.splice(idx, 1);
                            }
                            if (base_1.length > 0) {
                                /** @type {?} */ ((_this.map)).set(update.param, base_1);
                            }
                            else {
                                /** @type {?} */ ((_this.map)).delete(update.param);
                            }
                        }
                        else {
                            /** @type {?} */ ((_this.map)).delete(update.param);
                            break;
                        }
                }
            });
            this.cloneFrom = null;
        }
    };
    return HttpParams;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * Determine whether the given HTTP method may include a body.
 * @param {?} method
 * @return {?}
 */
function mightHaveBody(method) {
    switch (method) {
        case 'DELETE':
        case 'GET':
        case 'HEAD':
        case 'OPTIONS':
        case 'JSONP':
            return false;
        default:
            return true;
    }
}
/**
 * Safely assert whether the given value is an ArrayBuffer.
 *
 * In some execution environments ArrayBuffer is not defined.
 * @param {?} value
 * @return {?}
 */
function isArrayBuffer(value) {
    return typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer;
}
/**
 * Safely assert whether the given value is a Blob.
 *
 * In some execution environments Blob is not defined.
 * @param {?} value
 * @return {?}
 */
function isBlob(value) {
    return typeof Blob !== 'undefined' && value instanceof Blob;
}
/**
 * Safely assert whether the given value is a FormData instance.
 *
 * In some execution environments FormData is not defined.
 * @param {?} value
 * @return {?}
 */
function isFormData(value) {
    return typeof FormData !== 'undefined' && value instanceof FormData;
}
/**
 * An outgoing HTTP request with an optional typed body.
 *
 * `HttpRequest` represents an outgoing request, including URL, method,
 * headers, body, and other request configuration options. Instances should be
 * assumed to be immutable. To modify a `HttpRequest`, the `clone`
 * method should be used.
 *
 * \@stable
 */
var HttpRequest = (function () {
    function HttpRequest(method, url, third, fourth) {
        this.url = url;
        /**
         * The request body, or `null` if one isn't set.
         *
         * Bodies are not enforced to be immutable, as they can include a reference to any
         * user-defined data type. However, interceptors should take care to preserve
         * idempotence by treating them as such.
         */
        this.body = null;
        /**
         * Whether this request should be made in a way that exposes progress events.
         *
         * Progress events are expensive (change detection runs on each event) and so
         * they should only be requested if the consumer intends to monitor them.
         */
        this.reportProgress = false;
        /**
         * Whether this request should be sent with outgoing credentials (cookies).
         */
        this.withCredentials = false;
        /**
         * The expected response type of the server.
         *
         * This is used to parse the response appropriately before returning it to
         * the requestee.
         */
        this.responseType = 'json';
        this.method = method.toUpperCase();
        // Next, need to figure out which argument holds the HttpRequestInit
        // options, if any.
        var /** @type {?} */ options;
        // Check whether a body argument is expected. The only valid way to omit
        // the body argument is to use a known no-body method like GET.
        if (mightHaveBody(this.method) || !!fourth) {
            // Body is the third argument, options are the fourth.
            this.body = /** @type {?} */ (third) || null;
            options = fourth;
        }
        else {
            // No body required, options are the third argument. The body stays null.
            options = /** @type {?} */ (third);
        }
        // If options have been passed, interpret them.
        if (options) {
            // Normalize reportProgress and withCredentials.
            this.reportProgress = !!options.reportProgress;
            this.withCredentials = !!options.withCredentials;
            // Override default response type of 'json' if one is provided.
            if (!!options.responseType) {
                this.responseType = options.responseType;
            }
            // Override headers if they're provided.
            if (!!options.headers) {
                this.headers = options.headers;
            }
            if (!!options.params) {
                this.params = options.params;
            }
        }
        // If no headers have been passed in, construct a new HttpHeaders instance.
        if (!this.headers) {
            this.headers = new HttpHeaders();
        }
        // If no parameters have been passed in, construct a new HttpUrlEncodedParams instance.
        if (!this.params) {
            this.params = new HttpParams();
            this.urlWithParams = url;
        }
        else {
            // Encode the parameters to a string in preparation for inclusion in the URL.
            var /** @type {?} */ params = this.params.toString();
            if (params.length === 0) {
                // No parameters, the visible URL is just the URL given at creation time.
                this.urlWithParams = url;
            }
            else {
                // Does the URL already have query parameters? Look for '?'.
                var /** @type {?} */ qIdx = url.indexOf('?');
                // There are 3 cases to handle:
                // 1) No existing parameters -> append '?' followed by params.
                // 2) '?' exists and is followed by existing query string ->
                //    append '&' followed by params.
                // 3) '?' exists at the end of the url -> append params directly.
                // This basically amounts to determining the character, if any, with
                // which to join the URL and parameters.
                var /** @type {?} */ sep = qIdx === -1 ? '?' : (qIdx < url.length - 1 ? '&' : '');
                this.urlWithParams = url + sep + params;
            }
        }
    }
    /**
     * Transform the free-form body into a serialized format suitable for
     * transmission to the server.
     */
    /**
     * Transform the free-form body into a serialized format suitable for
     * transmission to the server.
     * @return {?}
     */
    HttpRequest.prototype.serializeBody = /**
     * Transform the free-form body into a serialized format suitable for
     * transmission to the server.
     * @return {?}
     */
    function () {
        // If no body is present, no need to serialize it.
        if (this.body === null) {
            return null;
        }
        // Check whether the body is already in a serialized form. If so,
        // it can just be returned directly.
        if (isArrayBuffer(this.body) || isBlob(this.body) || isFormData(this.body) ||
            typeof this.body === 'string') {
            return this.body;
        }
        // Check whether the body is an instance of HttpUrlEncodedParams.
        if (this.body instanceof HttpParams) {
            return this.body.toString();
        }
        // Check whether the body is an object or array, and serialize with JSON if so.
        if (typeof this.body === 'object' || typeof this.body === 'boolean' ||
            Array.isArray(this.body)) {
            return JSON.stringify(this.body);
        }
        // Fall back on toString() for everything else.
        return (/** @type {?} */ (this.body)).toString();
    };
    /**
     * Examine the body and attempt to infer an appropriate MIME type
     * for it.
     *
     * If no such type can be inferred, this method will return `null`.
     */
    /**
     * Examine the body and attempt to infer an appropriate MIME type
     * for it.
     *
     * If no such type can be inferred, this method will return `null`.
     * @return {?}
     */
    HttpRequest.prototype.detectContentTypeHeader = /**
     * Examine the body and attempt to infer an appropriate MIME type
     * for it.
     *
     * If no such type can be inferred, this method will return `null`.
     * @return {?}
     */
    function () {
        // An empty body has no content type.
        if (this.body === null) {
            return null;
        }
        // FormData bodies rely on the browser's content type assignment.
        if (isFormData(this.body)) {
            return null;
        }
        // Blobs usually have their own content type. If it doesn't, then
        // no type can be inferred.
        if (isBlob(this.body)) {
            return this.body.type || null;
        }
        // Array buffers have unknown contents and thus no type can be inferred.
        if (isArrayBuffer(this.body)) {
            return null;
        }
        // Technically, strings could be a form of JSON data, but it's safe enough
        // to assume they're plain strings.
        if (typeof this.body === 'string') {
            return 'text/plain';
        }
        // `HttpUrlEncodedParams` has its own content-type.
        if (this.body instanceof HttpParams) {
            return 'application/x-www-form-urlencoded;charset=UTF-8';
        }
        // Arrays, objects, and numbers will be encoded as JSON.
        if (typeof this.body === 'object' || typeof this.body === 'number' ||
            Array.isArray(this.body)) {
            return 'application/json';
        }
        // No type could be inferred.
        return null;
    };
    /**
     * @param {?=} update
     * @return {?}
     */
    HttpRequest.prototype.clone = /**
     * @param {?=} update
     * @return {?}
     */
    function (update) {
        if (update === void 0) { update = {}; }
        // For method, url, and responseType, take the current value unless
        // it is overridden in the update hash.
        var /** @type {?} */ method = update.method || this.method;
        var /** @type {?} */ url = update.url || this.url;
        var /** @type {?} */ responseType = update.responseType || this.responseType;
        // The body is somewhat special - a `null` value in update.body means
        // whatever current body is present is being overridden with an empty
        // body, whereas an `undefined` value in update.body implies no
        // override.
        var /** @type {?} */ body = (update.body !== undefined) ? update.body : this.body;
        // Carefully handle the boolean options to differentiate between
        // `false` and `undefined` in the update args.
        var /** @type {?} */ withCredentials = (update.withCredentials !== undefined) ? update.withCredentials : this.withCredentials;
        var /** @type {?} */ reportProgress = (update.reportProgress !== undefined) ? update.reportProgress : this.reportProgress;
        // Headers and params may be appended to if `setHeaders` or
        // `setParams` are used.
        var /** @type {?} */ headers = update.headers || this.headers;
        var /** @type {?} */ params = update.params || this.params;
        // Check whether the caller has asked to add headers.
        if (update.setHeaders !== undefined) {
            // Set every requested header.
            headers =
                Object.keys(update.setHeaders)
                    .reduce(function (headers, name) { return headers.set(name, /** @type {?} */ ((update.setHeaders))[name]); }, headers);
        }
        // Check whether the caller has asked to set params.
        if (update.setParams) {
            // Set every requested param.
            params = Object.keys(update.setParams)
                .reduce(function (params, param) { return params.set(param, /** @type {?} */ ((update.setParams))[param]); }, params);
        }
        // Finally, construct the new HttpRequest using the pieces from above.
        return new HttpRequest(method, url, body, {
            params: params, headers: headers, reportProgress: reportProgress, responseType: responseType, withCredentials: withCredentials,
        });
    };
    return HttpRequest;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/** @enum {number} */
var HttpEventType = {
    /**
       * The request was sent out over the wire.
       */
    Sent: 0,
    /**
       * An upload progress event was received.
       */
    UploadProgress: 1,
    /**
       * The response status code and headers were received.
       */
    ResponseHeader: 2,
    /**
       * A download progress event was received.
       */
    DownloadProgress: 3,
    /**
       * The full response including the body was received.
       */
    Response: 4,
    /**
       * A custom event from an interceptor or a backend.
       */
    User: 5,
};
HttpEventType[HttpEventType.Sent] = "Sent";
HttpEventType[HttpEventType.UploadProgress] = "UploadProgress";
HttpEventType[HttpEventType.ResponseHeader] = "ResponseHeader";
HttpEventType[HttpEventType.DownloadProgress] = "DownloadProgress";
HttpEventType[HttpEventType.Response] = "Response";
HttpEventType[HttpEventType.User] = "User";
/**
 * Base interface for progress events.
 *
 * \@stable
 * @record
 */

/**
 * A download progress event.
 *
 * \@stable
 * @record
 */

/**
 * An upload progress event.
 *
 * \@stable
 * @record
 */

/**
 * An event indicating that the request was sent to the server. Useful
 * when a request may be retried multiple times, to distinguish between
 * retries on the final event stream.
 *
 * \@stable
 * @record
 */

/**
 * A user-defined event.
 *
 * Grouping all custom events under this type ensures they will be handled
 * and forwarded by all implementations of interceptors.
 *
 * \@stable
 * @record
 */

/**
 * An error that represents a failed attempt to JSON.parse text coming back
 * from the server.
 *
 * It bundles the Error object with the actual response body that failed to parse.
 *
 * \@stable
 * @record
 */

/**
 * Base class for both `HttpResponse` and `HttpHeaderResponse`.
 *
 * \@stable
 * @abstract
 */
var HttpResponseBase = (function () {
    /**
     * Super-constructor for all responses.
     *
     * The single parameter accepted is an initialization hash. Any properties
     * of the response passed there will override the default values.
     */
    function HttpResponseBase(init, defaultStatus, defaultStatusText) {
        if (defaultStatus === void 0) { defaultStatus = 200; }
        if (defaultStatusText === void 0) { defaultStatusText = 'OK'; }
        // If the hash has values passed, use them to initialize the response.
        // Otherwise use the default values.
        this.headers = init.headers || new HttpHeaders();
        this.status = init.status !== undefined ? init.status : defaultStatus;
        this.statusText = init.statusText || defaultStatusText;
        this.url = init.url || null;
        // Cache the ok value to avoid defining a getter.
        this.ok = this.status >= 200 && this.status < 300;
    }
    return HttpResponseBase;
}());
/**
 * A partial HTTP response which only includes the status and header data,
 * but no response body.
 *
 * `HttpHeaderResponse` is a `HttpEvent` available on the response
 * event stream, only when progress events are requested.
 *
 * \@stable
 */
var HttpHeaderResponse = (function (_super) {
    tslib.__extends(HttpHeaderResponse, _super);
    /**
     * Create a new `HttpHeaderResponse` with the given parameters.
     */
    function HttpHeaderResponse(init) {
        if (init === void 0) { init = {}; }
        var _this = _super.call(this, init) || this;
        _this.type = HttpEventType.ResponseHeader;
        return _this;
    }
    /**
     * Copy this `HttpHeaderResponse`, overriding its contents with the
     * given parameter hash.
     */
    /**
     * Copy this `HttpHeaderResponse`, overriding its contents with the
     * given parameter hash.
     * @param {?=} update
     * @return {?}
     */
    HttpHeaderResponse.prototype.clone = /**
     * Copy this `HttpHeaderResponse`, overriding its contents with the
     * given parameter hash.
     * @param {?=} update
     * @return {?}
     */
    function (update) {
        if (update === void 0) { update = {}; }
        // Perform a straightforward initialization of the new HttpHeaderResponse,
        // overriding the current parameters with new ones if given.
        return new HttpHeaderResponse({
            headers: update.headers || this.headers,
            status: update.status !== undefined ? update.status : this.status,
            statusText: update.statusText || this.statusText,
            url: update.url || this.url || undefined,
        });
    };
    return HttpHeaderResponse;
}(HttpResponseBase));
/**
 * A full HTTP response, including a typed response body (which may be `null`
 * if one was not returned).
 *
 * `HttpResponse` is a `HttpEvent` available on the response event
 * stream.
 *
 * \@stable
 */
var HttpResponse = (function (_super) {
    tslib.__extends(HttpResponse, _super);
    /**
     * Construct a new `HttpResponse`.
     */
    function HttpResponse(init) {
        if (init === void 0) { init = {}; }
        var _this = _super.call(this, init) || this;
        _this.type = HttpEventType.Response;
        _this.body = init.body || null;
        return _this;
    }
    /**
     * @param {?=} update
     * @return {?}
     */
    HttpResponse.prototype.clone = /**
     * @param {?=} update
     * @return {?}
     */
    function (update) {
        if (update === void 0) { update = {}; }
        return new HttpResponse({
            body: (update.body !== undefined) ? update.body : this.body,
            headers: update.headers || this.headers,
            status: (update.status !== undefined) ? update.status : this.status,
            statusText: update.statusText || this.statusText,
            url: update.url || this.url || undefined,
        });
    };
    return HttpResponse;
}(HttpResponseBase));
/**
 * A response that represents an error or failure, either from a
 * non-successful HTTP status, an error while executing the request,
 * or some other failure which occurred during the parsing of the response.
 *
 * Any error returned on the `Observable` response stream will be
 * wrapped in an `HttpErrorResponse` to provide additional context about
 * the state of the HTTP layer when the error occurred. The error property
 * will contain either a wrapped Error object or the error response returned
 * from the server.
 *
 * \@stable
 */
var HttpErrorResponse = (function (_super) {
    tslib.__extends(HttpErrorResponse, _super);
    function HttpErrorResponse(init) {
        var _this = 
        // Initialize with a default status of 0 / Unknown Error.
        _super.call(this, init, 0, 'Unknown Error') || this;
        _this.name = 'HttpErrorResponse';
        /**
         * Errors are never okay, even when the status code is in the 2xx success range.
         */
        _this.ok = false;
        // If the response was successful, then this was a parse error. Otherwise, it was
        // a protocol-level failure of some sort. Either the request failed in transit
        // or the server returned an unsuccessful status code.
        if (_this.status >= 200 && _this.status < 300) {
            _this.message = "Http failure during parsing for " + (init.url || '(unknown url)');
        }
        else {
            _this.message =
                "Http failure response for " + (init.url || '(unknown url)') + ": " + init.status + " " + init.statusText;
        }
        _this.error = init.error || null;
        return _this;
    }
    return HttpErrorResponse;
}(HttpResponseBase));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * Construct an instance of `HttpRequestOptions<T>` from a source `HttpMethodOptions` and
 * the given `body`. Basically, this clones the object and adds the body.
 * @template T
 * @param {?} options
 * @param {?} body
 * @return {?}
 */
function addBody(options, body) {
    return {
        body: body,
        headers: options.headers,
        observe: options.observe,
        params: options.params,
        reportProgress: options.reportProgress,
        responseType: options.responseType,
        withCredentials: options.withCredentials,
    };
}
/**
 * Perform HTTP requests.
 *
 * `HttpClient` is available as an injectable class, with methods to perform HTTP requests.
 * Each request method has multiple signatures, and the return type varies according to which
 * signature is called (mainly the values of `observe` and `responseType`).
 *
 * \@stable
 */
var HttpClient = (function () {
    function HttpClient(handler) {
        this.handler = handler;
    }
    /**
     * Constructs an `Observable` for a particular HTTP request that, when subscribed,
     * fires the request through the chain of registered interceptors and on to the
     * server.
     *
     * This method can be called in one of two ways. Either an `HttpRequest`
     * instance can be passed directly as the only parameter, or a method can be
     * passed as the first parameter, a string URL as the second, and an
     * options hash as the third.
     *
     * If a `HttpRequest` object is passed directly, an `Observable` of the
     * raw `HttpEvent` stream will be returned.
     *
     * If a request is instead built by providing a URL, the options object
     * determines the return type of `request()`. In addition to configuring
     * request parameters such as the outgoing headers and/or the body, the options
     * hash specifies two key pieces of information about the request: the
     * `responseType` and what to `observe`.
     *
     * The `responseType` value determines how a successful response body will be
     * parsed. If `responseType` is the default `json`, a type interface for the
     * resulting object may be passed as a type parameter to `request()`.
     *
     * The `observe` value determines the return type of `request()`, based on what
     * the consumer is interested in observing. A value of `events` will return an
     * `Observable<HttpEvent>` representing the raw `HttpEvent` stream,
     * including progress events by default. A value of `response` will return an
     * `Observable<HttpResponse<T>>` where the `T` parameter of `HttpResponse`
     * depends on the `responseType` and any optionally provided type parameter.
     * A value of `body` will return an `Observable<T>` with the same `T` body type.
     */
    /**
     * Constructs an `Observable` for a particular HTTP request that, when subscribed,
     * fires the request through the chain of registered interceptors and on to the
     * server.
     *
     * This method can be called in one of two ways. Either an `HttpRequest`
     * instance can be passed directly as the only parameter, or a method can be
     * passed as the first parameter, a string URL as the second, and an
     * options hash as the third.
     *
     * If a `HttpRequest` object is passed directly, an `Observable` of the
     * raw `HttpEvent` stream will be returned.
     *
     * If a request is instead built by providing a URL, the options object
     * determines the return type of `request()`. In addition to configuring
     * request parameters such as the outgoing headers and/or the body, the options
     * hash specifies two key pieces of information about the request: the
     * `responseType` and what to `observe`.
     *
     * The `responseType` value determines how a successful response body will be
     * parsed. If `responseType` is the default `json`, a type interface for the
     * resulting object may be passed as a type parameter to `request()`.
     *
     * The `observe` value determines the return type of `request()`, based on what
     * the consumer is interested in observing. A value of `events` will return an
     * `Observable<HttpEvent>` representing the raw `HttpEvent` stream,
     * including progress events by default. A value of `response` will return an
     * `Observable<HttpResponse<T>>` where the `T` parameter of `HttpResponse`
     * depends on the `responseType` and any optionally provided type parameter.
     * A value of `body` will return an `Observable<T>` with the same `T` body type.
     * @param {?} first
     * @param {?=} url
     * @param {?=} options
     * @return {?}
     */
    HttpClient.prototype.request = /**
     * Constructs an `Observable` for a particular HTTP request that, when subscribed,
     * fires the request through the chain of registered interceptors and on to the
     * server.
     *
     * This method can be called in one of two ways. Either an `HttpRequest`
     * instance can be passed directly as the only parameter, or a method can be
     * passed as the first parameter, a string URL as the second, and an
     * options hash as the third.
     *
     * If a `HttpRequest` object is passed directly, an `Observable` of the
     * raw `HttpEvent` stream will be returned.
     *
     * If a request is instead built by providing a URL, the options object
     * determines the return type of `request()`. In addition to configuring
     * request parameters such as the outgoing headers and/or the body, the options
     * hash specifies two key pieces of information about the request: the
     * `responseType` and what to `observe`.
     *
     * The `responseType` value determines how a successful response body will be
     * parsed. If `responseType` is the default `json`, a type interface for the
     * resulting object may be passed as a type parameter to `request()`.
     *
     * The `observe` value determines the return type of `request()`, based on what
     * the consumer is interested in observing. A value of `events` will return an
     * `Observable<HttpEvent>` representing the raw `HttpEvent` stream,
     * including progress events by default. A value of `response` will return an
     * `Observable<HttpResponse<T>>` where the `T` parameter of `HttpResponse`
     * depends on the `responseType` and any optionally provided type parameter.
     * A value of `body` will return an `Observable<T>` with the same `T` body type.
     * @param {?} first
     * @param {?=} url
     * @param {?=} options
     * @return {?}
     */
    function (first, url, options) {
        var _this = this;
        if (options === void 0) { options = {}; }
        var /** @type {?} */ req;
        // Firstly, check whether the primary argument is an instance of `HttpRequest`.
        if (first instanceof HttpRequest) {
            // It is. The other arguments must be undefined (per the signatures) and can be
            // ignored.
            req = /** @type {?} */ (first);
        }
        else {
            // It's a string, so it represents a URL. Construct a request based on it,
            // and incorporate the remaining arguments (assuming GET unless a method is
            // provided.
            // Figure out the headers.
            var /** @type {?} */ headers = undefined;
            if (!!options.headers !== undefined) {
                if (options.headers instanceof HttpHeaders) {
                    headers = options.headers;
                }
                else {
                    headers = new HttpHeaders(options.headers);
                }
            }
            // Sort out parameters.
            var /** @type {?} */ params = undefined;
            if (!!options.params) {
                if (options.params instanceof HttpParams) {
                    params = options.params;
                }
                else {
                    params = new HttpParams({ fromObject: options.params });
                }
            }
            // Construct the request.
            req = new HttpRequest(first, /** @type {?} */ ((url)), options.body || null, {
                headers: headers,
                params: params,
                reportProgress: options.reportProgress,
                // By default, JSON is assumed to be returned for all calls.
                responseType: options.responseType || 'json',
                withCredentials: options.withCredentials,
            });
        }
        // Start with an Observable.of() the initial request, and run the handler (which
        // includes all interceptors) inside a concatMap(). This way, the handler runs
        // inside an Observable chain, which causes interceptors to be re-run on every
        // subscription (this also makes retries re-run the handler, including interceptors).
        var /** @type {?} */ events$ = rxjs_operator_concatMap.concatMap.call(rxjs_observable_of.of(req), function (req) { return _this.handler.handle(req); });
        // If coming via the API signature which accepts a previously constructed HttpRequest,
        // the only option is to get the event stream. Otherwise, return the event stream if
        // that is what was requested.
        if (first instanceof HttpRequest || options.observe === 'events') {
            return events$;
        }
        // The requested stream contains either the full response or the body. In either
        // case, the first step is to filter the event stream to extract a stream of
        // responses(s).
        var /** @type {?} */ res$ = rxjs_operator_filter.filter.call(events$, function (event) { return event instanceof HttpResponse; });
        // Decide which stream to return.
        switch (options.observe || 'body') {
            case 'body':
                // The requested stream is the body. Map the response stream to the response
                // body. This could be done more simply, but a misbehaving interceptor might
                // transform the response body into a different format and ignore the requested
                // responseType. Guard against this by validating that the response is of the
                // requested type.
                switch (req.responseType) {
                    case 'arraybuffer':
                        return rxjs_operator_map.map.call(res$, function (res) {
                            // Validate that the body is an ArrayBuffer.
                            if (res.body !== null && !(res.body instanceof ArrayBuffer)) {
                                throw new Error('Response is not an ArrayBuffer.');
                            }
                            return res.body;
                        });
                    case 'blob':
                        return rxjs_operator_map.map.call(res$, function (res) {
                            // Validate that the body is a Blob.
                            if (res.body !== null && !(res.body instanceof Blob)) {
                                throw new Error('Response is not a Blob.');
                            }
                            return res.body;
                        });
                    case 'text':
                        return rxjs_operator_map.map.call(res$, function (res) {
                            // Validate that the body is a string.
                            if (res.body !== null && typeof res.body !== 'string') {
                                throw new Error('Response is not a string.');
                            }
                            return res.body;
                        });
                    case 'json':
                    default:
                        // No validation needed for JSON responses, as they can be of any type.
                        return rxjs_operator_map.map.call(res$, function (res) { return res.body; });
                }
            case 'response':
                // The response stream was requested directly, so return it.
                return res$;
            default:
                // Guard against new future observe types being added.
                throw new Error("Unreachable: unhandled observe type " + options.observe + "}");
        }
    };
    /**
     * Constructs an `Observable` which, when subscribed, will cause the configured
     * DELETE request to be executed on the server. See the individual overloads for
     * details of `delete()`'s return type based on the provided options.
     */
    /**
     * Constructs an `Observable` which, when subscribed, will cause the configured
     * DELETE request to be executed on the server. See the individual overloads for
     * details of `delete()`'s return type based on the provided options.
     * @param {?} url
     * @param {?=} options
     * @return {?}
     */
    HttpClient.prototype.delete = /**
     * Constructs an `Observable` which, when subscribed, will cause the configured
     * DELETE request to be executed on the server. See the individual overloads for
     * details of `delete()`'s return type based on the provided options.
     * @param {?} url
     * @param {?=} options
     * @return {?}
     */
    function (url, options) {
        if (options === void 0) { options = {}; }
        return this.request('DELETE', url, /** @type {?} */ (options));
    };
    /**
     * Constructs an `Observable` which, when subscribed, will cause the configured
     * GET request to be executed on the server. See the individual overloads for
     * details of `get()`'s return type based on the provided options.
     */
    /**
     * Constructs an `Observable` which, when subscribed, will cause the configured
     * GET request to be executed on the server. See the individual overloads for
     * details of `get()`'s return type based on the provided options.
     * @param {?} url
     * @param {?=} options
     * @return {?}
     */
    HttpClient.prototype.get = /**
     * Constructs an `Observable` which, when subscribed, will cause the configured
     * GET request to be executed on the server. See the individual overloads for
     * details of `get()`'s return type based on the provided options.
     * @param {?} url
     * @param {?=} options
     * @return {?}
     */
    function (url, options) {
        if (options === void 0) { options = {}; }
        return this.request('GET', url, /** @type {?} */ (options));
    };
    /**
     * Constructs an `Observable` which, when subscribed, will cause the configured
     * HEAD request to be executed on the server. See the individual overloads for
     * details of `head()`'s return type based on the provided options.
     */
    /**
     * Constructs an `Observable` which, when subscribed, will cause the configured
     * HEAD request to be executed on the server. See the individual overloads for
     * details of `head()`'s return type based on the provided options.
     * @param {?} url
     * @param {?=} options
     * @return {?}
     */
    HttpClient.prototype.head = /**
     * Constructs an `Observable` which, when subscribed, will cause the configured
     * HEAD request to be executed on the server. See the individual overloads for
     * details of `head()`'s return type based on the provided options.
     * @param {?} url
     * @param {?=} options
     * @return {?}
     */
    function (url, options) {
        if (options === void 0) { options = {}; }
        return this.request('HEAD', url, /** @type {?} */ (options));
    };
    /**
     * Constructs an `Observable` which, when subscribed, will cause a request
     * with the special method `JSONP` to be dispatched via the interceptor pipeline.
     *
     * A suitable interceptor must be installed (e.g. via the `HttpClientJsonpModule`).
     * If no such interceptor is reached, then the `JSONP` request will likely be
     * rejected by the configured backend.
     */
    /**
     * Constructs an `Observable` which, when subscribed, will cause a request
     * with the special method `JSONP` to be dispatched via the interceptor pipeline.
     *
     * A suitable interceptor must be installed (e.g. via the `HttpClientJsonpModule`).
     * If no such interceptor is reached, then the `JSONP` request will likely be
     * rejected by the configured backend.
     * @template T
     * @param {?} url
     * @param {?} callbackParam
     * @return {?}
     */
    HttpClient.prototype.jsonp = /**
     * Constructs an `Observable` which, when subscribed, will cause a request
     * with the special method `JSONP` to be dispatched via the interceptor pipeline.
     *
     * A suitable interceptor must be installed (e.g. via the `HttpClientJsonpModule`).
     * If no such interceptor is reached, then the `JSONP` request will likely be
     * rejected by the configured backend.
     * @template T
     * @param {?} url
     * @param {?} callbackParam
     * @return {?}
     */
    function (url, callbackParam) {
        return this.request('JSONP', url, {
            params: new HttpParams().append(callbackParam, 'JSONP_CALLBACK'),
            observe: 'body',
            responseType: 'json',
        });
    };
    /**
     * Constructs an `Observable` which, when subscribed, will cause the configured
     * OPTIONS request to be executed on the server. See the individual overloads for
     * details of `options()`'s return type based on the provided options.
     */
    /**
     * Constructs an `Observable` which, when subscribed, will cause the configured
     * OPTIONS request to be executed on the server. See the individual overloads for
     * details of `options()`'s return type based on the provided options.
     * @param {?} url
     * @param {?=} options
     * @return {?}
     */
    HttpClient.prototype.options = /**
     * Constructs an `Observable` which, when subscribed, will cause the configured
     * OPTIONS request to be executed on the server. See the individual overloads for
     * details of `options()`'s return type based on the provided options.
     * @param {?} url
     * @param {?=} options
     * @return {?}
     */
    function (url, options) {
        if (options === void 0) { options = {}; }
        return this.request('OPTIONS', url, /** @type {?} */ (options));
    };
    /**
     * Constructs an `Observable` which, when subscribed, will cause the configured
     * PATCH request to be executed on the server. See the individual overloads for
     * details of `patch()`'s return type based on the provided options.
     */
    /**
     * Constructs an `Observable` which, when subscribed, will cause the configured
     * PATCH request to be executed on the server. See the individual overloads for
     * details of `patch()`'s return type based on the provided options.
     * @param {?} url
     * @param {?} body
     * @param {?=} options
     * @return {?}
     */
    HttpClient.prototype.patch = /**
     * Constructs an `Observable` which, when subscribed, will cause the configured
     * PATCH request to be executed on the server. See the individual overloads for
     * details of `patch()`'s return type based on the provided options.
     * @param {?} url
     * @param {?} body
     * @param {?=} options
     * @return {?}
     */
    function (url, body, options) {
        if (options === void 0) { options = {}; }
        return this.request('PATCH', url, addBody(options, body));
    };
    /**
     * Constructs an `Observable` which, when subscribed, will cause the configured
     * POST request to be executed on the server. See the individual overloads for
     * details of `post()`'s return type based on the provided options.
     */
    /**
     * Constructs an `Observable` which, when subscribed, will cause the configured
     * POST request to be executed on the server. See the individual overloads for
     * details of `post()`'s return type based on the provided options.
     * @param {?} url
     * @param {?} body
     * @param {?=} options
     * @return {?}
     */
    HttpClient.prototype.post = /**
     * Constructs an `Observable` which, when subscribed, will cause the configured
     * POST request to be executed on the server. See the individual overloads for
     * details of `post()`'s return type based on the provided options.
     * @param {?} url
     * @param {?} body
     * @param {?=} options
     * @return {?}
     */
    function (url, body, options) {
        if (options === void 0) { options = {}; }
        return this.request('POST', url, addBody(options, body));
    };
    /**
     * Constructs an `Observable` which, when subscribed, will cause the configured
     * POST request to be executed on the server. See the individual overloads for
     * details of `post()`'s return type based on the provided options.
     */
    /**
     * Constructs an `Observable` which, when subscribed, will cause the configured
     * POST request to be executed on the server. See the individual overloads for
     * details of `post()`'s return type based on the provided options.
     * @param {?} url
     * @param {?} body
     * @param {?=} options
     * @return {?}
     */
    HttpClient.prototype.put = /**
     * Constructs an `Observable` which, when subscribed, will cause the configured
     * POST request to be executed on the server. See the individual overloads for
     * details of `post()`'s return type based on the provided options.
     * @param {?} url
     * @param {?} body
     * @param {?=} options
     * @return {?}
     */
    function (url, body, options) {
        if (options === void 0) { options = {}; }
        return this.request('PUT', url, addBody(options, body));
    };
    HttpClient.decorators = [
        { type: _angular_core.Injectable },
    ];
    /** @nocollapse */
    HttpClient.ctorParameters = function () { return [
        { type: HttpHandler, },
    ]; };
    return HttpClient;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * Intercepts `HttpRequest` and handles them.
 *
 * Most interceptors will transform the outgoing request before passing it to the
 * next interceptor in the chain, by calling `next.handle(transformedReq)`.
 *
 * In rare cases, interceptors may wish to completely handle a request themselves,
 * and not delegate to the remainder of the chain. This behavior is allowed.
 *
 * \@stable
 * @record
 */

/**
 * `HttpHandler` which applies an `HttpInterceptor` to an `HttpRequest`.
 *
 * \@stable
 */
var HttpInterceptorHandler = (function () {
    function HttpInterceptorHandler(next, interceptor) {
        this.next = next;
        this.interceptor = interceptor;
    }
    /**
     * @param {?} req
     * @return {?}
     */
    HttpInterceptorHandler.prototype.handle = /**
     * @param {?} req
     * @return {?}
     */
    function (req) {
        return this.interceptor.intercept(req, this.next);
    };
    return HttpInterceptorHandler;
}());
/**
 * A multi-provider token which represents the array of `HttpInterceptor`s that
 * are registered.
 *
 * \@stable
 */
var HTTP_INTERCEPTORS = new _angular_core.InjectionToken('HTTP_INTERCEPTORS');
var NoopInterceptor = (function () {
    function NoopInterceptor() {
    }
    /**
     * @param {?} req
     * @param {?} next
     * @return {?}
     */
    NoopInterceptor.prototype.intercept = /**
     * @param {?} req
     * @param {?} next
     * @return {?}
     */
    function (req, next) {
        return next.handle(req);
    };
    NoopInterceptor.decorators = [
        { type: _angular_core.Injectable },
    ];
    /** @nocollapse */
    NoopInterceptor.ctorParameters = function () { return []; };
    return NoopInterceptor;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
// Every request made through JSONP needs a callback name that's unique across the
// whole page. Each request is assigned an id and the callback name is constructed
// from that. The next id to be assigned is tracked in a global variable here that
// is shared among all applications on the page.
var nextRequestId = 0;
// Error text given when a JSONP script is injected, but doesn't invoke the callback
// passed in its URL.
var JSONP_ERR_NO_CALLBACK = 'JSONP injected script did not invoke callback.';
// Error text given when a request is passed to the JsonpClientBackend that doesn't
// have a request method JSONP.
var JSONP_ERR_WRONG_METHOD = 'JSONP requests must use JSONP request method.';
var JSONP_ERR_WRONG_RESPONSE_TYPE = 'JSONP requests must use Json response type.';
/**
 * DI token/abstract type representing a map of JSONP callbacks.
 *
 * In the browser, this should always be the `window` object.
 *
 * \@stable
 * @abstract
 */
var JsonpCallbackContext = (function () {
    function JsonpCallbackContext() {
    }
    return JsonpCallbackContext;
}());
/**
 * `HttpBackend` that only processes `HttpRequest` with the JSONP method,
 * by performing JSONP style requests.
 *
 * \@stable
 */
var JsonpClientBackend = (function () {
    function JsonpClientBackend(callbackMap, document) {
        this.callbackMap = callbackMap;
        this.document = document;
    }
    /**
     * Get the name of the next callback method, by incrementing the global `nextRequestId`.
     * @return {?}
     */
    JsonpClientBackend.prototype.nextCallback = /**
     * Get the name of the next callback method, by incrementing the global `nextRequestId`.
     * @return {?}
     */
    function () { return "ng_jsonp_callback_" + nextRequestId++; };
    /**
     * Process a JSONP request and return an event stream of the results.
     */
    /**
     * Process a JSONP request and return an event stream of the results.
     * @param {?} req
     * @return {?}
     */
    JsonpClientBackend.prototype.handle = /**
     * Process a JSONP request and return an event stream of the results.
     * @param {?} req
     * @return {?}
     */
    function (req) {
        var _this = this;
        // Firstly, check both the method and response type. If either doesn't match
        // then the request was improperly routed here and cannot be handled.
        if (req.method !== 'JSONP') {
            throw new Error(JSONP_ERR_WRONG_METHOD);
        }
        else if (req.responseType !== 'json') {
            throw new Error(JSONP_ERR_WRONG_RESPONSE_TYPE);
        }
        // Everything else happens inside the Observable boundary.
        return new rxjs_Observable.Observable(function (observer) {
            // The first step to make a request is to generate the callback name, and replace the
            // callback placeholder in the URL with the name. Care has to be taken here to ensure
            // a trailing &, if matched, gets inserted back into the URL in the correct place.
            var /** @type {?} */ callback = _this.nextCallback();
            var /** @type {?} */ url = req.urlWithParams.replace(/=JSONP_CALLBACK(&|$)/, "=" + callback + "$1");
            // Construct the <script> tag and point it at the URL.
            var /** @type {?} */ node = _this.document.createElement('script');
            node.src = url;
            // A JSONP request requires waiting for multiple callbacks. These variables
            // are closed over and track state across those callbacks.
            // The response object, if one has been received, or null otherwise.
            var /** @type {?} */ body = null;
            // Whether the response callback has been called.
            var /** @type {?} */ finished = false;
            // Whether the request has been cancelled (and thus any other callbacks)
            // should be ignored.
            var /** @type {?} */ cancelled = false;
            // Set the response callback in this.callbackMap (which will be the window
            // object in the browser. The script being loaded via the <script> tag will
            // eventually call this callback.
            // Set the response callback in this.callbackMap (which will be the window
            // object in the browser. The script being loaded via the <script> tag will
            // eventually call this callback.
            _this.callbackMap[callback] = function (data) {
                // Data has been received from the JSONP script. Firstly, delete this callback.
                delete _this.callbackMap[callback];
                // Next, make sure the request wasn't cancelled in the meantime.
                if (cancelled) {
                    return;
                }
                // Set state to indicate data was received.
                body = data;
                finished = true;
            };
            // cleanup() is a utility closure that removes the <script> from the page and
            // the response callback from the window. This logic is used in both the
            // success, error, and cancellation paths, so it's extracted out for convenience.
            var /** @type {?} */ cleanup = function () {
                // Remove the <script> tag if it's still on the page.
                if (node.parentNode) {
                    node.parentNode.removeChild(node);
                }
                // Remove the response callback from the callbackMap (window object in the
                // browser).
                delete _this.callbackMap[callback];
            };
            // onLoad() is the success callback which runs after the response callback
            // if the JSONP script loads successfully. The event itself is unimportant.
            // If something went wrong, onLoad() may run without the response callback
            // having been invoked.
            var /** @type {?} */ onLoad = function (event) {
                // Do nothing if the request has been cancelled.
                if (cancelled) {
                    return;
                }
                // Cleanup the page.
                cleanup();
                // Check whether the response callback has run.
                if (!finished) {
                    // It hasn't, something went wrong with the request. Return an error via
                    // the Observable error path. All JSONP errors have status 0.
                    observer.error(new HttpErrorResponse({
                        url: url,
                        status: 0,
                        statusText: 'JSONP Error',
                        error: new Error(JSONP_ERR_NO_CALLBACK),
                    }));
                    return;
                }
                // Success. body either contains the response body or null if none was
                // returned.
                observer.next(new HttpResponse({
                    body: body,
                    status: 200,
                    statusText: 'OK', url: url,
                }));
                // Complete the stream, the resposne is over.
                observer.complete();
            };
            // onError() is the error callback, which runs if the script returned generates
            // a Javascript error. It emits the error via the Observable error channel as
            // a HttpErrorResponse.
            var /** @type {?} */ onError = function (error) {
                // If the request was already cancelled, no need to emit anything.
                if (cancelled) {
                    return;
                }
                cleanup();
                // Wrap the error in a HttpErrorResponse.
                observer.error(new HttpErrorResponse({
                    error: error,
                    status: 0,
                    statusText: 'JSONP Error', url: url,
                }));
            };
            // Subscribe to both the success (load) and error events on the <script> tag,
            // and add it to the page.
            node.addEventListener('load', onLoad);
            node.addEventListener('error', onError);
            _this.document.body.appendChild(node);
            // The request has now been successfully sent.
            observer.next({ type: HttpEventType.Sent });
            // Cancellation handler.
            return function () {
                // Track the cancellation so event listeners won't do anything even if already scheduled.
                cancelled = true;
                // Remove the event listeners so they won't run if the events later fire.
                node.removeEventListener('load', onLoad);
                node.removeEventListener('error', onError);
                // And finally, clean up the page.
                cleanup();
            };
        });
    };
    JsonpClientBackend.decorators = [
        { type: _angular_core.Injectable },
    ];
    /** @nocollapse */
    JsonpClientBackend.ctorParameters = function () { return [
        { type: JsonpCallbackContext, },
        { type: undefined, decorators: [{ type: _angular_core.Inject, args: [_angular_common.DOCUMENT,] },] },
    ]; };
    return JsonpClientBackend;
}());
/**
 * An `HttpInterceptor` which identifies requests with the method JSONP and
 * shifts them to the `JsonpClientBackend`.
 *
 * \@stable
 */
var JsonpInterceptor = (function () {
    function JsonpInterceptor(jsonp) {
        this.jsonp = jsonp;
    }
    /**
     * @param {?} req
     * @param {?} next
     * @return {?}
     */
    JsonpInterceptor.prototype.intercept = /**
     * @param {?} req
     * @param {?} next
     * @return {?}
     */
    function (req, next) {
        if (req.method === 'JSONP') {
            return this.jsonp.handle(/** @type {?} */ (req));
        }
        // Fall through for normal HTTP requests.
        return next.handle(req);
    };
    JsonpInterceptor.decorators = [
        { type: _angular_core.Injectable },
    ];
    /** @nocollapse */
    JsonpInterceptor.ctorParameters = function () { return [
        { type: JsonpClientBackend, },
    ]; };
    return JsonpInterceptor;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var XSSI_PREFIX = /^\)\]\}',?\n/;
/**
 * Determine an appropriate URL for the response, by checking either
 * XMLHttpRequest.responseURL or the X-Request-URL header.
 * @param {?} xhr
 * @return {?}
 */
function getResponseUrl(xhr) {
    if ('responseURL' in xhr && xhr.responseURL) {
        return xhr.responseURL;
    }
    if (/^X-Request-URL:/m.test(xhr.getAllResponseHeaders())) {
        return xhr.getResponseHeader('X-Request-URL');
    }
    return null;
}
/**
 * A wrapper around the `XMLHttpRequest` constructor.
 *
 * \@stable
 * @abstract
 */
var XhrFactory = (function () {
    function XhrFactory() {
    }
    return XhrFactory;
}());
/**
 * A factory for \@{link HttpXhrBackend} that uses the `XMLHttpRequest` browser API.
 *
 * \@stable
 */
var BrowserXhr = (function () {
    function BrowserXhr() {
    }
    /**
     * @return {?}
     */
    BrowserXhr.prototype.build = /**
     * @return {?}
     */
    function () { return /** @type {?} */ ((new XMLHttpRequest())); };
    BrowserXhr.decorators = [
        { type: _angular_core.Injectable },
    ];
    /** @nocollapse */
    BrowserXhr.ctorParameters = function () { return []; };
    return BrowserXhr;
}());
/**
 * An `HttpBackend` which uses the XMLHttpRequest API to send
 * requests to a backend server.
 *
 * \@stable
 */
var HttpXhrBackend = (function () {
    function HttpXhrBackend(xhrFactory) {
        this.xhrFactory = xhrFactory;
    }
    /**
     * Process a request and return a stream of response events.
     */
    /**
     * Process a request and return a stream of response events.
     * @param {?} req
     * @return {?}
     */
    HttpXhrBackend.prototype.handle = /**
     * Process a request and return a stream of response events.
     * @param {?} req
     * @return {?}
     */
    function (req) {
        var _this = this;
        // Quick check to give a better error message when a user attempts to use
        // HttpClient.jsonp() without installing the JsonpClientModule
        if (req.method === 'JSONP') {
            throw new Error("Attempted to construct Jsonp request without JsonpClientModule installed.");
        }
        // Everything happens on Observable subscription.
        return new rxjs_Observable.Observable(function (observer) {
            // Start by setting up the XHR object with request method, URL, and withCredentials flag.
            var /** @type {?} */ xhr = _this.xhrFactory.build();
            xhr.open(req.method, req.urlWithParams);
            if (!!req.withCredentials) {
                xhr.withCredentials = true;
            }
            // Add all the requested headers.
            req.headers.forEach(function (name, values) { return xhr.setRequestHeader(name, values.join(',')); });
            // Add an Accept header if one isn't present already.
            if (!req.headers.has('Accept')) {
                xhr.setRequestHeader('Accept', 'application/json, text/plain, */*');
            }
            // Auto-detect the Content-Type header if one isn't present already.
            if (!req.headers.has('Content-Type')) {
                var /** @type {?} */ detectedType = req.detectContentTypeHeader();
                // Sometimes Content-Type detection fails.
                if (detectedType !== null) {
                    xhr.setRequestHeader('Content-Type', detectedType);
                }
            }
            // Set the responseType if one was requested.
            if (req.responseType) {
                var /** @type {?} */ responseType = req.responseType.toLowerCase();
                // JSON responses need to be processed as text. This is because if the server
                // returns an XSSI-prefixed JSON response, the browser will fail to parse it,
                // xhr.response will be null, and xhr.responseText cannot be accessed to
                // retrieve the prefixed JSON data in order to strip the prefix. Thus, all JSON
                // is parsed by first requesting text and then applying JSON.parse.
                xhr.responseType = /** @type {?} */ (((responseType !== 'json') ? responseType : 'text'));
            }
            // Serialize the request body if one is present. If not, this will be set to null.
            var /** @type {?} */ reqBody = req.serializeBody();
            // If progress events are enabled, response headers will be delivered
            // in two events - the HttpHeaderResponse event and the full HttpResponse
            // event. However, since response headers don't change in between these
            // two events, it doesn't make sense to parse them twice. So headerResponse
            // caches the data extracted from the response whenever it's first parsed,
            // to ensure parsing isn't duplicated.
            var /** @type {?} */ headerResponse = null;
            // partialFromXhr extracts the HttpHeaderResponse from the current XMLHttpRequest
            // state, and memoizes it into headerResponse.
            var /** @type {?} */ partialFromXhr = function () {
                if (headerResponse !== null) {
                    return headerResponse;
                }
                // Read status and normalize an IE9 bug (http://bugs.jquery.com/ticket/1450).
                var /** @type {?} */ status = xhr.status === 1223 ? 204 : xhr.status;
                var /** @type {?} */ statusText = xhr.statusText || 'OK';
                // Parse headers from XMLHttpRequest - this step is lazy.
                var /** @type {?} */ headers = new HttpHeaders(xhr.getAllResponseHeaders());
                // Read the response URL from the XMLHttpResponse instance and fall back on the
                // request URL.
                var /** @type {?} */ url = getResponseUrl(xhr) || req.url;
                // Construct the HttpHeaderResponse and memoize it.
                headerResponse = new HttpHeaderResponse({ headers: headers, status: status, statusText: statusText, url: url });
                return headerResponse;
            };
            // Next, a few closures are defined for the various events which XMLHttpRequest can
            // emit. This allows them to be unregistered as event listeners later.
            // First up is the load event, which represents a response being fully available.
            var /** @type {?} */ onLoad = function () {
                // Read response state from the memoized partial data.
                var _a = partialFromXhr(), headers = _a.headers, status = _a.status, statusText = _a.statusText, url = _a.url;
                // The body will be read out if present.
                var /** @type {?} */ body = null;
                if (status !== 204) {
                    // Use XMLHttpRequest.response if set, responseText otherwise.
                    body = (typeof xhr.response === 'undefined') ? xhr.responseText : xhr.response;
                }
                // Normalize another potential bug (this one comes from CORS).
                if (status === 0) {
                    status = !!body ? 200 : 0;
                }
                // ok determines whether the response will be transmitted on the event or
                // error channel. Unsuccessful status codes (not 2xx) will always be errors,
                // but a successful status code can still result in an error if the user
                // asked for JSON data and the body cannot be parsed as such.
                var /** @type {?} */ ok = status >= 200 && status < 300;
                // Check whether the body needs to be parsed as JSON (in many cases the browser
                // will have done that already).
                if (ok && req.responseType === 'json' && typeof body === 'string') {
                    // Attempt the parse. If it fails, a parse error should be delivered to the user.
                    body = body.replace(XSSI_PREFIX, '');
                    try {
                        body = JSON.parse(body);
                    }
                    catch (/** @type {?} */ error) {
                        // Even though the response status was 2xx, this is still an error.
                        ok = false;
                        // The parse error contains the text of the body that failed to parse.
                        body = /** @type {?} */ ({ error: error, text: body });
                    }
                }
                if (ok) {
                    // A successful response is delivered on the event stream.
                    observer.next(new HttpResponse({
                        body: body,
                        headers: headers,
                        status: status,
                        statusText: statusText,
                        url: url || undefined,
                    }));
                    // The full body has been received and delivered, no further events
                    // are possible. This request is complete.
                    observer.complete();
                }
                else {
                    // An unsuccessful request is delivered on the error channel.
                    observer.error(new HttpErrorResponse({
                        // The error in this case is the response body (error from the server).
                        error: body,
                        headers: headers,
                        status: status,
                        statusText: statusText,
                        url: url || undefined,
                    }));
                }
            };
            // The onError callback is called when something goes wrong at the network level.
            // Connection timeout, DNS error, offline, etc. These are actual errors, and are
            // transmitted on the error channel.
            var /** @type {?} */ onError = function (error) {
                var /** @type {?} */ res = new HttpErrorResponse({
                    error: error,
                    status: xhr.status || 0,
                    statusText: xhr.statusText || 'Unknown Error',
                });
                observer.error(res);
            };
            // The sentHeaders flag tracks whether the HttpResponseHeaders event
            // has been sent on the stream. This is necessary to track if progress
            // is enabled since the event will be sent on only the first download
            // progerss event.
            var /** @type {?} */ sentHeaders = false;
            // The download progress event handler, which is only registered if
            // progress events are enabled.
            var /** @type {?} */ onDownProgress = function (event) {
                // Send the HttpResponseHeaders event if it hasn't been sent already.
                if (!sentHeaders) {
                    observer.next(partialFromXhr());
                    sentHeaders = true;
                }
                // Start building the download progress event to deliver on the response
                // event stream.
                var /** @type {?} */ progressEvent = {
                    type: HttpEventType.DownloadProgress,
                    loaded: event.loaded,
                };
                // Set the total number of bytes in the event if it's available.
                if (event.lengthComputable) {
                    progressEvent.total = event.total;
                }
                // If the request was for text content and a partial response is
                // available on XMLHttpRequest, include it in the progress event
                // to allow for streaming reads.
                if (req.responseType === 'text' && !!xhr.responseText) {
                    progressEvent.partialText = xhr.responseText;
                }
                // Finally, fire the event.
                observer.next(progressEvent);
            };
            // The upload progress event handler, which is only registered if
            // progress events are enabled.
            var /** @type {?} */ onUpProgress = function (event) {
                // Upload progress events are simpler. Begin building the progress
                // event.
                var /** @type {?} */ progress = {
                    type: HttpEventType.UploadProgress,
                    loaded: event.loaded,
                };
                // If the total number of bytes being uploaded is available, include
                // it.
                if (event.lengthComputable) {
                    progress.total = event.total;
                }
                // Send the event.
                observer.next(progress);
            };
            // By default, register for load and error events.
            xhr.addEventListener('load', onLoad);
            xhr.addEventListener('error', onError);
            // Progress events are only enabled if requested.
            if (req.reportProgress) {
                // Download progress is always enabled if requested.
                xhr.addEventListener('progress', onDownProgress);
                // Upload progress depends on whether there is a body to upload.
                if (reqBody !== null && xhr.upload) {
                    xhr.upload.addEventListener('progress', onUpProgress);
                }
            }
            // Fire the request, and notify the event stream that it was fired.
            xhr.send(reqBody);
            observer.next({ type: HttpEventType.Sent });
            // This is the return from the Observable function, which is the
            // request cancellation handler.
            return function () {
                // On a cancellation, remove all registered event listeners.
                xhr.removeEventListener('error', onError);
                xhr.removeEventListener('load', onLoad);
                if (req.reportProgress) {
                    xhr.removeEventListener('progress', onDownProgress);
                    if (reqBody !== null && xhr.upload) {
                        xhr.upload.removeEventListener('progress', onUpProgress);
                    }
                }
                // Finally, abort the in-flight request.
                xhr.abort();
            };
        });
    };
    HttpXhrBackend.decorators = [
        { type: _angular_core.Injectable },
    ];
    /** @nocollapse */
    HttpXhrBackend.ctorParameters = function () { return [
        { type: XhrFactory, },
    ]; };
    return HttpXhrBackend;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var XSRF_COOKIE_NAME = new _angular_core.InjectionToken('XSRF_COOKIE_NAME');
var XSRF_HEADER_NAME = new _angular_core.InjectionToken('XSRF_HEADER_NAME');
/**
 * Retrieves the current XSRF token to use with the next outgoing request.
 *
 * \@stable
 * @abstract
 */
var HttpXsrfTokenExtractor = (function () {
    function HttpXsrfTokenExtractor() {
    }
    return HttpXsrfTokenExtractor;
}());
/**
 * `HttpXsrfTokenExtractor` which retrieves the token from a cookie.
 */
var HttpXsrfCookieExtractor = (function () {
    function HttpXsrfCookieExtractor(doc, platform, cookieName) {
        this.doc = doc;
        this.platform = platform;
        this.cookieName = cookieName;
        this.lastCookieString = '';
        this.lastToken = null;
        /**
         * \@internal for testing
         */
        this.parseCount = 0;
    }
    /**
     * @return {?}
     */
    HttpXsrfCookieExtractor.prototype.getToken = /**
     * @return {?}
     */
    function () {
        if (this.platform === 'server') {
            return null;
        }
        var /** @type {?} */ cookieString = this.doc.cookie || '';
        if (cookieString !== this.lastCookieString) {
            this.parseCount++;
            this.lastToken = _angular_common.ɵparseCookieValue(cookieString, this.cookieName);
            this.lastCookieString = cookieString;
        }
        return this.lastToken;
    };
    HttpXsrfCookieExtractor.decorators = [
        { type: _angular_core.Injectable },
    ];
    /** @nocollapse */
    HttpXsrfCookieExtractor.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: _angular_core.Inject, args: [_angular_common.DOCUMENT,] },] },
        { type: undefined, decorators: [{ type: _angular_core.Inject, args: [_angular_core.PLATFORM_ID,] },] },
        { type: undefined, decorators: [{ type: _angular_core.Inject, args: [XSRF_COOKIE_NAME,] },] },
    ]; };
    return HttpXsrfCookieExtractor;
}());
/**
 * `HttpInterceptor` which adds an XSRF token to eligible outgoing requests.
 */
var HttpXsrfInterceptor = (function () {
    function HttpXsrfInterceptor(tokenService, headerName) {
        this.tokenService = tokenService;
        this.headerName = headerName;
    }
    /**
     * @param {?} req
     * @param {?} next
     * @return {?}
     */
    HttpXsrfInterceptor.prototype.intercept = /**
     * @param {?} req
     * @param {?} next
     * @return {?}
     */
    function (req, next) {
        var /** @type {?} */ lcUrl = req.url.toLowerCase();
        // Skip both non-mutating requests and absolute URLs.
        // Non-mutating requests don't require a token, and absolute URLs require special handling
        // anyway as the cookie set
        // on our origin is not the same as the token expected by another origin.
        if (req.method === 'GET' || req.method === 'HEAD' || lcUrl.startsWith('http://') ||
            lcUrl.startsWith('https://')) {
            return next.handle(req);
        }
        var /** @type {?} */ token = this.tokenService.getToken();
        // Be careful not to overwrite an existing header of the same name.
        if (token !== null && !req.headers.has(this.headerName)) {
            req = req.clone({ headers: req.headers.set(this.headerName, token) });
        }
        return next.handle(req);
    };
    HttpXsrfInterceptor.decorators = [
        { type: _angular_core.Injectable },
    ];
    /** @nocollapse */
    HttpXsrfInterceptor.ctorParameters = function () { return [
        { type: HttpXsrfTokenExtractor, },
        { type: undefined, decorators: [{ type: _angular_core.Inject, args: [XSRF_HEADER_NAME,] },] },
    ]; };
    return HttpXsrfInterceptor;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * Constructs an `HttpHandler` that applies a bunch of `HttpInterceptor`s
 * to a request before passing it to the given `HttpBackend`.
 *
 * Meant to be used as a factory function within `HttpClientModule`.
 *
 * \@stable
 * @param {?} backend
 * @param {?=} interceptors
 * @return {?}
 */
function interceptingHandler(backend, interceptors) {
    if (interceptors === void 0) { interceptors = []; }
    if (!interceptors) {
        return backend;
    }
    return interceptors.reduceRight(function (next, interceptor) { return new HttpInterceptorHandler(next, interceptor); }, backend);
}
/**
 * Factory function that determines where to store JSONP callbacks.
 *
 * Ordinarily JSONP callbacks are stored on the `window` object, but this may not exist
 * in test environments. In that case, callbacks are stored on an anonymous object instead.
 *
 * \@stable
 * @return {?}
 */
function jsonpCallbackContext() {
    if (typeof window === 'object') {
        return window;
    }
    return {};
}
/**
 * `NgModule` which adds XSRF protection support to outgoing requests.
 *
 * Provided the server supports a cookie-based XSRF protection system, this
 * module can be used directly to configure XSRF protection with the correct
 * cookie and header names.
 *
 * If no such names are provided, the default is to use `X-XSRF-TOKEN` for
 * the header name and `XSRF-TOKEN` for the cookie name.
 *
 * \@stable
 */
var HttpClientXsrfModule = (function () {
    function HttpClientXsrfModule() {
    }
    /**
     * Disable the default XSRF protection.
     */
    /**
     * Disable the default XSRF protection.
     * @return {?}
     */
    HttpClientXsrfModule.disable = /**
     * Disable the default XSRF protection.
     * @return {?}
     */
    function () {
        return {
            ngModule: HttpClientXsrfModule,
            providers: [
                { provide: HttpXsrfInterceptor, useClass: NoopInterceptor },
            ],
        };
    };
    /**
     * Configure XSRF protection to use the given cookie name or header name,
     * or the default names (as described above) if not provided.
     */
    /**
     * Configure XSRF protection to use the given cookie name or header name,
     * or the default names (as described above) if not provided.
     * @param {?=} options
     * @return {?}
     */
    HttpClientXsrfModule.withOptions = /**
     * Configure XSRF protection to use the given cookie name or header name,
     * or the default names (as described above) if not provided.
     * @param {?=} options
     * @return {?}
     */
    function (options) {
        if (options === void 0) { options = {}; }
        return {
            ngModule: HttpClientXsrfModule,
            providers: [
                options.cookieName ? { provide: XSRF_COOKIE_NAME, useValue: options.cookieName } : [],
                options.headerName ? { provide: XSRF_HEADER_NAME, useValue: options.headerName } : [],
            ],
        };
    };
    HttpClientXsrfModule.decorators = [
        { type: _angular_core.NgModule, args: [{
                    providers: [
                        HttpXsrfInterceptor,
                        { provide: HTTP_INTERCEPTORS, useExisting: HttpXsrfInterceptor, multi: true },
                        { provide: HttpXsrfTokenExtractor, useClass: HttpXsrfCookieExtractor },
                        { provide: XSRF_COOKIE_NAME, useValue: 'XSRF-TOKEN' },
                        { provide: XSRF_HEADER_NAME, useValue: 'X-XSRF-TOKEN' },
                    ],
                },] },
    ];
    /** @nocollapse */
    HttpClientXsrfModule.ctorParameters = function () { return []; };
    return HttpClientXsrfModule;
}());
/**
 * `NgModule` which provides the `HttpClient` and associated services.
 *
 * Interceptors can be added to the chain behind `HttpClient` by binding them
 * to the multiprovider for `HTTP_INTERCEPTORS`.
 *
 * \@stable
 */
var HttpClientModule = (function () {
    function HttpClientModule() {
    }
    HttpClientModule.decorators = [
        { type: _angular_core.NgModule, args: [{
                    imports: [
                        HttpClientXsrfModule.withOptions({
                            cookieName: 'XSRF-TOKEN',
                            headerName: 'X-XSRF-TOKEN',
                        }),
                    ],
                    providers: [
                        HttpClient,
                        // HttpHandler is the backend + interceptors and is constructed
                        // using the interceptingHandler factory function.
                        {
                            provide: HttpHandler,
                            useFactory: interceptingHandler,
                            deps: [HttpBackend, [new _angular_core.Optional(), new _angular_core.Inject(HTTP_INTERCEPTORS)]],
                        },
                        HttpXhrBackend,
                        { provide: HttpBackend, useExisting: HttpXhrBackend },
                        BrowserXhr,
                        { provide: XhrFactory, useExisting: BrowserXhr },
                    ],
                },] },
    ];
    /** @nocollapse */
    HttpClientModule.ctorParameters = function () { return []; };
    return HttpClientModule;
}());
/**
 * `NgModule` which enables JSONP support in `HttpClient`.
 *
 * Without this module, Jsonp requests will reach the backend
 * with method JSONP, where they'll be rejected.
 *
 * \@stable
 */
var HttpClientJsonpModule = (function () {
    function HttpClientJsonpModule() {
    }
    HttpClientJsonpModule.decorators = [
        { type: _angular_core.NgModule, args: [{
                    providers: [
                        JsonpClientBackend,
                        { provide: JsonpCallbackContext, useFactory: jsonpCallbackContext },
                        { provide: HTTP_INTERCEPTORS, useClass: JsonpInterceptor, multi: true },
                    ],
                },] },
    ];
    /** @nocollapse */
    HttpClientJsonpModule.ctorParameters = function () { return []; };
    return HttpClientJsonpModule;
}());

exports.HttpBackend = HttpBackend;
exports.HttpHandler = HttpHandler;
exports.HttpClient = HttpClient;
exports.HttpHeaders = HttpHeaders;
exports.HTTP_INTERCEPTORS = HTTP_INTERCEPTORS;
exports.JsonpClientBackend = JsonpClientBackend;
exports.JsonpInterceptor = JsonpInterceptor;
exports.HttpClientJsonpModule = HttpClientJsonpModule;
exports.HttpClientModule = HttpClientModule;
exports.HttpClientXsrfModule = HttpClientXsrfModule;
exports.ɵinterceptingHandler = interceptingHandler;
exports.HttpParams = HttpParams;
exports.HttpUrlEncodingCodec = HttpUrlEncodingCodec;
exports.HttpRequest = HttpRequest;
exports.HttpErrorResponse = HttpErrorResponse;
exports.HttpEventType = HttpEventType;
exports.HttpHeaderResponse = HttpHeaderResponse;
exports.HttpResponse = HttpResponse;
exports.HttpResponseBase = HttpResponseBase;
exports.HttpXhrBackend = HttpXhrBackend;
exports.XhrFactory = XhrFactory;
exports.HttpXsrfTokenExtractor = HttpXsrfTokenExtractor;
exports.ɵa = NoopInterceptor;
exports.ɵb = JsonpCallbackContext;
exports.ɵc = jsonpCallbackContext;
exports.ɵd = BrowserXhr;
exports.ɵg = HttpXsrfCookieExtractor;
exports.ɵh = HttpXsrfInterceptor;
exports.ɵe = XSRF_COOKIE_NAME;
exports.ɵf = XSRF_HEADER_NAME;

Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=common-http.umd.js.map


/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = DOMImplementation;

var Document = __webpack_require__(20);
var DocumentType = __webpack_require__(28);
var HTMLParser = __webpack_require__(29);
var utils = __webpack_require__(3);
var xml = __webpack_require__(21);

// Each document must have its own instance of the domimplementation object
// Even though these objects have no state
function DOMImplementation() {}


// Feature/version pairs that DOMImplementation.hasFeature() returns
// true for.  It returns false for anything else.
var supportedFeatures = {
  'xml': { '': true, '1.0': true, '2.0': true },   // DOM Core
  'core': { '': true, '2.0': true },               // DOM Core
  'html': { '': true, '1.0': true, '2.0': true} ,  // HTML
  'xhtml': { '': true, '1.0': true, '2.0': true} , // HTML
};

DOMImplementation.prototype = {
  hasFeature: function hasFeature(feature, version) {
    var f = supportedFeatures[(feature || '').toLowerCase()];
    return (f && f[version || '']) || false;
  },

  createDocumentType: function createDocumentType(qualifiedName, publicId, systemId) {
    if (!xml.isValidName(qualifiedName)) utils.InvalidCharacterError();
    if (!xml.isValidQName(qualifiedName)) utils.NamespaceError();

    return new DocumentType(qualifiedName, publicId, systemId);
  },

  createDocument: function createDocument(namespace, qualifiedName, doctype) {
    //
    // Note that the current DOMCore spec makes it impossible to
    // create an HTML document with this function, even if the
    // namespace and doctype are propertly set.  See this thread:
    // http://lists.w3.org/Archives/Public/www-dom/2011AprJun/0132.html
    //
    var d = new Document(false, null);
    var e;

    if (qualifiedName)
      e = d.createElementNS(namespace, qualifiedName);
    else
      e = null;

    if (doctype) {
      if (doctype.ownerDocument) utils.WrongDocumentError();
      d.appendChild(doctype);
    }

    if (e) d.appendChild(e);

    return d;
  },

  createHTMLDocument: function createHTMLDocument(titleText) {
    var d = new Document(true, null);
    d.appendChild(new DocumentType('html'));
    var html = d.createElement('html');
    d.appendChild(html);
    var head = d.createElement('head');
    html.appendChild(head);
    var title = d.createElement('title');
    head.appendChild(title);
    title.appendChild(d.createTextNode(titleText));
    html.appendChild(d.createElement('body'));
    d.modclock = 1; // Start tracking modifications
    return d;
  },

  mozSetOutputMutationHandler: function(doc, handler) {
    doc.mutationHandler = handler;
  },

  mozGetInputMutationHandler: function(doc) {
    utils.nyi();
  },

  mozHTMLParser: HTMLParser,
};


/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = NodeList;

function item(i) {
  /* jshint validthis: true */
  return this[i];
}

function NodeList(a) {
  if (!a) a = [];
  a.item = item;
  return a;
}


/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = CharacterData;

var Leaf = __webpack_require__(50);
var utils = __webpack_require__(3);
var ChildNode = __webpack_require__(23);
var NonDocumentTypeChildNode = __webpack_require__(48);

function CharacterData() {
}

CharacterData.prototype = Object.create(Leaf.prototype, {
  // DOMString substringData(unsigned long offset,
  //               unsigned long count);
  // The substringData(offset, count) method must run these steps:
  //
  //     If offset is greater than the context object's
  //     length, throw an INDEX_SIZE_ERR exception and
  //     terminate these steps.
  //
  //     If offset+count is greater than the context
  //     object's length, return a DOMString whose value is
  //     the UTF-16 code units from the offsetth UTF-16 code
  //     unit to the end of data.
  //
  //     Return a DOMString whose value is the UTF-16 code
  //     units from the offsetth UTF-16 code unit to the
  //     offset+countth UTF-16 code unit in data.
  substringData: { value: function substringData(offset, count) {
    if (offset > this.data.length || offset < 0 || count < 0) 
      utils.IndexSizeError();
    return this.data.substring(offset, offset+count);
  }},

  // void appendData(DOMString data);
  // The appendData(data) method must append data to the context
  // object's data.
  appendData: { value: function appendData(data) {
    this.data = this.data + data;
  }},

  // void insertData(unsigned long offset, DOMString data);
  // The insertData(offset, data) method must run these steps:
  //
  //     If offset is greater than the context object's
  //     length, throw an INDEX_SIZE_ERR exception and
  //     terminate these steps.
  //
  //     Insert data into the context object's data after
  //     offset UTF-16 code units.
  //
  insertData: { value: function insertData(offset, data) {
    var curtext = this.data;
    if (offset > curtext.length || offset < 0) utils.IndexSizeError();
    var prefix = curtext.substring(0, offset),
    suffix = curtext.substring(offset);
    this.data = prefix + data + suffix;
  }},


  // void deleteData(unsigned long offset, unsigned long count);
  // The deleteData(offset, count) method must run these steps:
  //
  //     If offset is greater than the context object's
  //     length, throw an INDEX_SIZE_ERR exception and
  //     terminate these steps.
  //
  //     If offset+count is greater than the context
  //     object's length var count be length-offset.
  //
  //     Starting from offset UTF-16 code units remove count
  //     UTF-16 code units from the context object's data.
  deleteData: { value: function deleteData(offset, count) {
    var curtext = this.data, len = curtext.length;

    if (offset > len || offset < 0) utils.IndexSizeError();

    if (offset+count > len)
      count = len - offset;

    var prefix = curtext.substring(0, offset),
    suffix = curtext.substring(offset+count);

    this.data = prefix + suffix;
  }},


  // void replaceData(unsigned long offset, unsigned long count,
  //          DOMString data);
  //
  // The replaceData(offset, count, data) method must act as
  // if the deleteData() method is invoked with offset and
  // count as arguments followed by the insertData() method
  // with offset and data as arguments and re-throw any
  // exceptions these methods might have thrown.
  replaceData: { value: function replaceData(offset, count, data) {
    var curtext = this.data, len = curtext.length;

    if (offset > len || offset < 0) utils.IndexSizeError();

    if (offset+count > len)
      count = len - offset;

    var prefix = curtext.substring(0, offset),
    suffix = curtext.substring(offset+count);

    this.data = prefix + data + suffix;
  }},

  // Utility method that Node.isEqualNode() calls to test Text and
  // Comment nodes for equality.  It is okay to put it here, since
  // Node will have already verified that nodeType is equal
  isEqual: { value: function isEqual(n) {
    return this._data === n._data;
  }},

  length: { get: function() { return this.data.length; }}

});

Object.defineProperties(CharacterData.prototype, ChildNode);
Object.defineProperties(CharacterData.prototype, NonDocumentTypeChildNode);


/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var NodeFilter = {
  // Constants for acceptNode()
  FILTER_ACCEPT: 1,
  FILTER_REJECT: 2,
  FILTER_SKIP: 3,

  // Constants for whatToShow
  SHOW_ALL: 0xFFFFFFFF,
  SHOW_ELEMENT: 0x1,
  SHOW_ATTRIBUTE: 0x2, // historical
  SHOW_TEXT: 0x4,
  SHOW_CDATA_SECTION: 0x8, // historical
  SHOW_ENTITY_REFERENCE: 0x10, // historical
  SHOW_ENTITY: 0x20, // historical
  SHOW_PROCESSING_INSTRUCTION: 0x40,
  SHOW_COMMENT: 0x80,
  SHOW_DOCUMENT: 0x100,
  SHOW_DOCUMENT_TYPE: 0x200,
  SHOW_DOCUMENT_FRAGMENT: 0x400,
  SHOW_NOTATION: 0x800 // historical
};

module.exports = (NodeFilter.constructor = NodeFilter.prototype = NodeFilter);


/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(2))(377);

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(2))(96);

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(1);
var core_1 = __webpack_require__(0);
var router_1 = __webpack_require__(10);
var Rx_1 = __webpack_require__(103);
var UtilityService = /** @class */ (function () {
    function UtilityService(router) {
        this._router = router;
    }
    UtilityService.prototype.convertDateTime = function (date) {
        var _formattedDate = new Date(date.toString());
        return _formattedDate.toDateString();
    };
    UtilityService.prototype.navigate = function (path) {
        this._router.navigate([path]);
    };
    UtilityService.prototype.navigateToSignIn = function () {
        this.navigate('/login');
    };
    UtilityService.prototype.getParams = function () {
        var searchParams = window.location.search.split('?')[1];
        if (searchParams) {
            var paramsObj_1 = {};
            searchParams.split('&').forEach(function (i) {
                paramsObj_1[i.split('=')[0]] = i.split('=')[1];
            });
            return paramsObj_1;
        }
        return undefined;
    };
    UtilityService.prototype.readableColumnName = function (columnName) {
        // Convert underscores to spaces
        if (typeof (columnName) === 'undefined' || columnName === undefined || columnName === null) {
            return columnName;
        }
        if (typeof (columnName) !== 'string') {
            columnName = String(columnName);
        }
        return columnName.replace(/_+/g, ' ')
            .replace(/^[A-Z]+$/, function (match) {
            return ((match.charAt(0)).toUpperCase() + match.slice(1)).toLowerCase();
        })
            .replace(/([\w\u00C0-\u017F]+)/g, function (match) {
            return (match.charAt(0)).toUpperCase() + match.slice(1);
        })
            .replace(/(\w+?(?=[A-Z]))/g, '$1 ');
    };
    UtilityService.prototype.loadStyle = function (link) {
        if (this.isLoadedStyle(link)) {
            return Rx_1.Observable.of('');
        }
        else {
            var head = document.getElementsByTagName('head')[0];
            // Load jquery Ui
            var styleNode = document.createElement('link');
            styleNode.rel = 'stylesheet';
            styleNode.type = 'text/css';
            styleNode.href = link;
            styleNode.media = 'all';
            head.appendChild(styleNode);
            return Rx_1.Observable.fromEvent(styleNode, 'load');
        }
    };
    UtilityService.prototype.loadScript = function (script) {
        if (this.isLoadedScript(script)) {
            return Rx_1.Observable.of('');
        }
        else {
            var head = document.getElementsByTagName('head')[0];
            // Load jquery Ui
            var scriptNode = document.createElement('script');
            scriptNode.src = script;
            scriptNode.async = false;
            // scriptNode.type = 'text/javascript';
            // scriptNode.charset = 'utf-8';
            head.insertBefore(scriptNode, head.firstChild);
            return Rx_1.Observable.fromEvent(scriptNode, 'load');
        }
    };
    // Detect if library loaded
    UtilityService.prototype.isLoadedScript = function (lib) {
        return document.querySelectorAll('[src="' + lib + '"]').length > 0;
    };
    UtilityService.prototype.isLoadedStyle = function (lib) {
        return document.querySelectorAll('[href="' + lib + '"]').length > 0;
    };
    UtilityService = tslib_1.__decorate([
        core_1.Injectable(),
        tslib_1.__metadata("design:paramtypes", [router_1.Router])
    ], UtilityService);
    return UtilityService;
}());
exports.UtilityService = UtilityService;


/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * @license Angular v5.0.0-beta.7
 * (c) 2010-2017 Google, Inc. https://angular.io/
 * License: MIT
 */
(function (global, factory) {
	 true ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(factory((global.ng = global.ng || {}, global.ng.animations = {})));
}(this, (function (exports) { 'use strict';

/**
 * @license Angular v5.0.0-beta.7
 * (c) 2010-2017 Google, Inc. https://angular.io/
 * License: MIT
 */
/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * AnimationBuilder is an injectable service that is available when the {\@link
 * BrowserAnimationsModule BrowserAnimationsModule} or {\@link NoopAnimationsModule
 * NoopAnimationsModule} modules are used within an application.
 *
 * The purpose if this service is to produce an animation sequence programmatically within an
 * angular component or directive.
 *
 * Programmatic animations are first built and then a player is created when the build animation is
 * attached to an element.
 *
 * ```ts
 * // remember to include the BrowserAnimationsModule module for this to work...
 * import {AnimationBuilder} from '\@angular/animations';
 *
 * class MyCmp {
 *   constructor(private _builder: AnimationBuilder) {}
 *
 *   makeAnimation(element: any) {
 *     // first build the animation
 *     const myAnimation = this._builder.build([
 *       style({ width: 0 }),
 *       animate(1000, style({ width: '100px' }))
 *     ]);
 *
 *     // then create a player from it
 *     const player = myAnimation.create(element);
 *
 *     player.play();
 *   }
 * }
 * ```
 *
 * When an animation is built an instance of {\@link AnimationFactory AnimationFactory} will be
 * returned. Using that an {\@link AnimationPlayer AnimationPlayer} can be created which can then be
 * used to start the animation.
 *
 * \@experimental Animation support is experimental.
 * @abstract
 */
var AnimationBuilder = (function () {
    function AnimationBuilder() {
    }
    return AnimationBuilder;
}());
/**
 * An instance of `AnimationFactory` is returned from {\@link AnimationBuilder#build
 * AnimationBuilder.build}.
 *
 * \@experimental Animation support is experimental.
 * @abstract
 */
var AnimationFactory = (function () {
    function AnimationFactory() {
    }
    return AnimationFactory;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 * @record
 */

/**
 * \@experimental Animation support is experimental.
 */
var AUTO_STYLE = '*';
/**
 * \@experimental Animation support is experimental.
 * @record
 */

/**
 * Metadata representing the entry of animations. Instances of this interface are provided via the
 * animation DSL when the {\@link trigger trigger animation function} is called.
 *
 * \@experimental Animation support is experimental.
 * @record
 */

/**
 * Metadata representing the entry of animations. Instances of this interface are provided via the
 * animation DSL when the {\@link state state animation function} is called.
 *
 * \@experimental Animation support is experimental.
 * @record
 */

/**
 * Metadata representing the entry of animations. Instances of this interface are provided via the
 * animation DSL when the {\@link transition transition animation function} is called.
 *
 * \@experimental Animation support is experimental.
 * @record
 */

/**
 * \@experimental Animation support is experimental.
 * @record
 */

/**
 * \@experimental Animation support is experimental.
 * @record
 */

/**
 * Metadata representing the entry of animations. Instances of this interface are provided via the
 * animation DSL when the {\@link keyframes keyframes animation function} is called.
 *
 * \@experimental Animation support is experimental.
 * @record
 */

/**
 * Metadata representing the entry of animations. Instances of this interface are provided via the
 * animation DSL when the {\@link style style animation function} is called.
 *
 * \@experimental Animation support is experimental.
 * @record
 */

/**
 * Metadata representing the entry of animations. Instances of this interface are provided via the
 * animation DSL when the {\@link animate animate animation function} is called.
 *
 * \@experimental Animation support is experimental.
 * @record
 */

/**
 * Metadata representing the entry of animations. Instances of this interface are provided via the
 * animation DSL when the {\@link animateChild animateChild animation function} is called.
 *
 * \@experimental Animation support is experimental.
 * @record
 */

/**
 * Metadata representing the entry of animations. Instances of this interface are provided via the
 * animation DSL when the {\@link useAnimation useAnimation animation function} is called.
 *
 * \@experimental Animation support is experimental.
 * @record
 */

/**
 * Metadata representing the entry of animations. Instances of this interface are provided via the
 * animation DSL when the {\@link sequence sequence animation function} is called.
 *
 * \@experimental Animation support is experimental.
 * @record
 */

/**
 * Metadata representing the entry of animations. Instances of this interface are provided via the
 * animation DSL when the {\@link group group animation function} is called.
 *
 * \@experimental Animation support is experimental.
 * @record
 */

/**
 * Metadata representing the entry of animations. Instances of this interface are provided via the
 * animation DSL when the {\@link stagger stagger animation function} is called.
 *
 * \@experimental Animation support is experimental.
 * @record
 */

/**
 * `trigger` is an animation-specific function that is designed to be used inside of Angular's
 * animation DSL language. If this information is new, please navigate to the
 * {\@link Component#animations component animations metadata page} to gain a better
 * understanding of how animations in Angular are used.
 *
 * `trigger` Creates an animation trigger which will a list of {\@link state state} and
 * {\@link transition transition} entries that will be evaluated when the expression
 * bound to the trigger changes.
 *
 * Triggers are registered within the component annotation data under the
 * {\@link Component#animations animations section}. An animation trigger can be placed on an element
 * within a template by referencing the name of the trigger followed by the expression value that
 * the
 * trigger is bound to (in the form of `[\@triggerName]="expression"`.
 *
 * ### Usage
 *
 * `trigger` will create an animation trigger reference based on the provided `name` value. The
 * provided `animation` value is expected to be an array consisting of {\@link state state} and
 * {\@link transition transition} declarations.
 *
 * ```typescript
 * \@Component({
 *   selector: 'my-component',
 *   templateUrl: 'my-component-tpl.html',
 *   animations: [
 *     trigger("myAnimationTrigger", [
 *       state(...),
 *       state(...),
 *       transition(...),
 *       transition(...)
 *     ])
 *   ]
 * })
 * class MyComponent {
 *   myStatusExp = "something";
 * }
 * ```
 *
 * The template associated with this component will make use of the `myAnimationTrigger` animation
 * trigger by binding to an element within its template code.
 *
 * ```html
 * <!-- somewhere inside of my-component-tpl.html -->
 * <div [\@myAnimationTrigger]="myStatusExp">...</div>
 * ```
 *
 * ## Disable Animations
 * A special animation control binding called `\@.disabled` can be placed on an element which will
 * then disable animations for any inner animation triggers situated within the element as well as
 * any animations on the element itself.
 *
 * When true, the `\@.disabled` binding will prevent all animations from rendering. The example
 * below shows how to use this feature:
 *
 * ```ts
 * \@Component({
 *   selector: 'my-component',
 *   template: `
 *     <div [\@.disabled]="isDisabled">
 *       <div [\@childAnimation]="exp"></div>
 *     </div>
 *   `,
 *   animations: [
 *     trigger("childAnimation", [
 *       // ...
 *     ])
 *   ]
 * })
 * class MyComponent {
 *   isDisabled = true;
 *   exp = '...';
 * }
 * ```
 *
 * The `\@childAnimation` trigger will not animate because `\@.disabled` prevents it from happening
 * (when true).
 *
 * Note that `\@.disbled` will only disable all animations (this means any animations running on
 * the same element will also be disabled).
 *
 * ### Disabling Animations Application-wide
 * When an area of the template is set to have animations disabled, **all** inner components will
 * also have their animations disabled as well. This means that all animations for an angular
 * application can be disabled by placing a host binding set on `\@.disabled` on the topmost Angular
 * component.
 *
 * ```ts
 * import {Component, HostBinding} from '\@angular/core';
 *
 * \@Component({
 *   selector: 'app-component',
 *   templateUrl: 'app.component.html',
 * })
 * class AppComponent {
 *   \@HostBinding('\@.disabled')
 *   public animationsDisabled = true;
 * }
 * ```
 *
 * ### What about animations that us `query()` and `animateChild()`?
 * Despite inner animations being disabled, a parent animation can {\@link query query} for inner
 * elements located in disabled areas of the template and still animate them as it sees fit. This is
 * also the case for when a sub animation is queried by a parent and then later animated using {\@link
 * animateChild animateChild}.
 *
 * \@experimental Animation support is experimental.
 * @param {?} name
 * @param {?} definitions
 * @return {?}
 */
function trigger(name, definitions) {
    return { type: 7 /* Trigger */, name: name, definitions: definitions, options: {} };
}
/**
 * `animate` is an animation-specific function that is designed to be used inside of Angular's
 * animation DSL language. If this information is new, please navigate to the {\@link
 * Component#animations component animations metadata page} to gain a better understanding of
 * how animations in Angular are used.
 *
 * `animate` specifies an animation step that will apply the provided `styles` data for a given
 * amount of time based on the provided `timing` expression value. Calls to `animate` are expected
 * to be used within {\@link sequence an animation sequence}, {\@link group group}, or {\@link
 * transition transition}.
 *
 * ### Usage
 *
 * The `animate` function accepts two input parameters: `timing` and `styles`:
 *
 * - `timing` is a string based value that can be a combination of a duration with optional delay
 * and easing values. The format for the expression breaks down to `duration delay easing`
 * (therefore a value such as `1s 100ms ease-out` will be parse itself into `duration=1000,
 * delay=100, easing=ease-out`. If a numeric value is provided then that will be used as the
 * `duration` value in millisecond form.
 * - `styles` is the style input data which can either be a call to {\@link style style} or {\@link
 * keyframes keyframes}. If left empty then the styles from the destination state will be collected
 * and used (this is useful when describing an animation step that will complete an animation by
 * {\@link transition#the-final-animate-call animating to the final state}).
 *
 * ```typescript
 * // various functions for specifying timing data
 * animate(500, style(...))
 * animate("1s", style(...))
 * animate("100ms 0.5s", style(...))
 * animate("5s ease", style(...))
 * animate("5s 10ms cubic-bezier(.17,.67,.88,.1)", style(...))
 *
 * // either style() of keyframes() can be used
 * animate(500, style({ background: "red" }))
 * animate(500, keyframes([
 *   style({ background: "blue" })),
 *   style({ background: "red" }))
 * ])
 * ```
 *
 * {\@example core/animation/ts/dsl/animation_example.ts region='Component'}
 *
 * \@experimental Animation support is experimental.
 * @param {?} timings
 * @param {?=} styles
 * @return {?}
 */
function animate(timings, styles) {
    if (styles === void 0) { styles = null; }
    return { type: 4 /* Animate */, styles: styles, timings: timings };
}
/**
 * `group` is an animation-specific function that is designed to be used inside of Angular's
 * animation DSL language. If this information is new, please navigate to the {\@link
 * Component#animations component animations metadata page} to gain a better understanding of
 * how animations in Angular are used.
 *
 * `group` specifies a list of animation steps that are all run in parallel. Grouped animations are
 * useful when a series of styles must be animated/closed off at different starting/ending times.
 *
 * The `group` function can either be used within a {\@link sequence sequence} or a {\@link transition
 * transition} and it will only continue to the next instruction once all of the inner animation
 * steps have completed.
 *
 * ### Usage
 *
 * The `steps` data that is passed into the `group` animation function can either consist of {\@link
 * style style} or {\@link animate animate} function calls. Each call to `style()` or `animate()`
 * within a group will be executed instantly (use {\@link keyframes keyframes} or a {\@link
 * animate#usage animate() with a delay value} to offset styles to be applied at a later time).
 *
 * ```typescript
 * group([
 *   animate("1s", { background: "black" }))
 *   animate("2s", { color: "white" }))
 * ])
 * ```
 *
 * {\@example core/animation/ts/dsl/animation_example.ts region='Component'}
 *
 * \@experimental Animation support is experimental.
 * @param {?} steps
 * @param {?=} options
 * @return {?}
 */
function group(steps, options) {
    if (options === void 0) { options = null; }
    return { type: 3 /* Group */, steps: steps, options: options };
}
/**
 * `sequence` is an animation-specific function that is designed to be used inside of Angular's
 * animation DSL language. If this information is new, please navigate to the {\@link
 * Component#animations component animations metadata page} to gain a better understanding of
 * how animations in Angular are used.
 *
 * `sequence` Specifies a list of animation steps that are run one by one. (`sequence` is used by
 * default when an array is passed as animation data into {\@link transition transition}.)
 *
 * The `sequence` function can either be used within a {\@link group group} or a {\@link transition
 * transition} and it will only continue to the next instruction once each of the inner animation
 * steps have completed.
 *
 * To perform animation styling in parallel with other animation steps then have a look at the
 * {\@link group group} animation function.
 *
 * ### Usage
 *
 * The `steps` data that is passed into the `sequence` animation function can either consist of
 * {\@link style style} or {\@link animate animate} function calls. A call to `style()` will apply the
 * provided styling data immediately while a call to `animate()` will apply its styling data over a
 * given time depending on its timing data.
 *
 * ```typescript
 * sequence([
 *   style({ opacity: 0 })),
 *   animate("1s", { opacity: 1 }))
 * ])
 * ```
 *
 * {\@example core/animation/ts/dsl/animation_example.ts region='Component'}
 *
 * \@experimental Animation support is experimental.
 * @param {?} steps
 * @param {?=} options
 * @return {?}
 */
function sequence(steps, options) {
    if (options === void 0) { options = null; }
    return { type: 2 /* Sequence */, steps: steps, options: options };
}
/**
 * `style` is an animation-specific function that is designed to be used inside of Angular's
 * animation DSL language. If this information is new, please navigate to the {\@link
 * Component#animations component animations metadata page} to gain a better understanding of
 * how animations in Angular are used.
 *
 * `style` declares a key/value object containing CSS properties/styles that can then be used for
 * {\@link state animation states}, within an {\@link sequence animation sequence}, or as styling data
 * for both {\@link animate animate} and {\@link keyframes keyframes}.
 *
 * ### Usage
 *
 * `style` takes in a key/value string map as data and expects one or more CSS property/value pairs
 * to be defined.
 *
 * ```typescript
 * // string values are used for css properties
 * style({ background: "red", color: "blue" })
 *
 * // numerical (pixel) values are also supported
 * style({ width: 100, height: 0 })
 * ```
 *
 * #### Auto-styles (using `*`)
 *
 * When an asterix (`*`) character is used as a value then it will be detected from the element
 * being animated and applied as animation data when the animation starts.
 *
 * This feature proves useful for a state depending on layout and/or environment factors; in such
 * cases the styles are calculated just before the animation starts.
 *
 * ```typescript
 * // the steps below will animate from 0 to the
 * // actual height of the element
 * style({ height: 0 }),
 * animate("1s", style({ height: "*" }))
 * ```
 *
 * {\@example core/animation/ts/dsl/animation_example.ts region='Component'}
 *
 * \@experimental Animation support is experimental.
 * @param {?} tokens
 * @return {?}
 */
function style(tokens) {
    return { type: 6 /* Style */, styles: tokens, offset: null };
}
/**
 * `state` is an animation-specific function that is designed to be used inside of Angular's
 * animation DSL language. If this information is new, please navigate to the {\@link
 * Component#animations component animations metadata page} to gain a better understanding of
 * how animations in Angular are used.
 *
 * `state` declares an animation state within the given trigger. When a state is active within a
 * component then its associated styles will persist on the element that the trigger is attached to
 * (even when the animation ends).
 *
 * To animate between states, have a look at the animation {\@link transition transition} DSL
 * function. To register states to an animation trigger please have a look at the {\@link trigger
 * trigger} function.
 *
 * #### The `void` state
 *
 * The `void` state value is a reserved word that angular uses to determine when the element is not
 * apart of the application anymore (e.g. when an `ngIf` evaluates to false then the state of the
 * associated element is void).
 *
 * #### The `*` (default) state
 *
 * The `*` state (when styled) is a fallback state that will be used if the state that is being
 * animated is not declared within the trigger.
 *
 * ### Usage
 *
 * `state` will declare an animation state with its associated styles
 * within the given trigger.
 *
 * - `stateNameExpr` can be one or more state names separated by commas.
 * - `styles` refers to the {\@link style styling data} that will be persisted on the element once
 * the state has been reached.
 *
 * ```typescript
 * // "void" is a reserved name for a state and is used to represent
 * // the state in which an element is detached from from the application.
 * state("void", style({ height: 0 }))
 *
 * // user-defined states
 * state("closed", style({ height: 0 }))
 * state("open, visible", style({ height: "*" }))
 * ```
 *
 * {\@example core/animation/ts/dsl/animation_example.ts region='Component'}
 *
 * \@experimental Animation support is experimental.
 * @param {?} name
 * @param {?} styles
 * @param {?=} options
 * @return {?}
 */
function state(name, styles, options) {
    return { type: 0 /* State */, name: name, styles: styles, options: options };
}
/**
 * `keyframes` is an animation-specific function that is designed to be used inside of Angular's
 * animation DSL language. If this information is new, please navigate to the {\@link
 * Component#animations component animations metadata page} to gain a better understanding of
 * how animations in Angular are used.
 *
 * `keyframes` specifies a collection of {\@link style style} entries each optionally characterized
 * by an `offset` value.
 *
 * ### Usage
 *
 * The `keyframes` animation function is designed to be used alongside the {\@link animate animate}
 * animation function. Instead of applying animations from where they are currently to their
 * destination, keyframes can describe how each style entry is applied and at what point within the
 * animation arc (much like CSS Keyframe Animations do).
 *
 * For each `style()` entry an `offset` value can be set. Doing so allows to specifiy at what
 * percentage of the animate time the styles will be applied.
 *
 * ```typescript
 * // the provided offset values describe when each backgroundColor value is applied.
 * animate("5s", keyframes([
 *   style({ backgroundColor: "red", offset: 0 }),
 *   style({ backgroundColor: "blue", offset: 0.2 }),
 *   style({ backgroundColor: "orange", offset: 0.3 }),
 *   style({ backgroundColor: "black", offset: 1 })
 * ]))
 * ```
 *
 * Alternatively, if there are no `offset` values used within the style entries then the offsets
 * will be calculated automatically.
 *
 * ```typescript
 * animate("5s", keyframes([
 *   style({ backgroundColor: "red" }) // offset = 0
 *   style({ backgroundColor: "blue" }) // offset = 0.33
 *   style({ backgroundColor: "orange" }) // offset = 0.66
 *   style({ backgroundColor: "black" }) // offset = 1
 * ]))
 * ```
 *
 * {\@example core/animation/ts/dsl/animation_example.ts region='Component'}
 *
 * \@experimental Animation support is experimental.
 * @param {?} steps
 * @return {?}
 */
function keyframes(steps) {
    return { type: 5 /* Keyframes */, steps: steps };
}
/**
 * `transition` is an animation-specific function that is designed to be used inside of Angular's
 * animation DSL language. If this information is new, please navigate to the {\@link
 * Component#animations component animations metadata page} to gain a better understanding of
 * how animations in Angular are used.
 *
 * `transition` declares the {\@link sequence sequence of animation steps} that will be run when the
 * provided `stateChangeExpr` value is satisfied. The `stateChangeExpr` consists of a `state1 =>
 * state2` which consists of two known states (use an asterix (`*`) to refer to a dynamic starting
 * and/or ending state).
 *
 * A function can also be provided as the `stateChangeExpr` argument for a transition and this
 * function will be executed each time a state change occurs. If the value returned within the
 * function is true then the associated animation will be run.
 *
 * Animation transitions are placed within an {\@link trigger animation trigger}. For an transition
 * to animate to a state value and persist its styles then one or more {\@link state animation
 * states} is expected to be defined.
 *
 * ### Usage
 *
 * An animation transition is kicked off the `stateChangeExpr` predicate evaluates to true based on
 * what the previous state is and what the current state has become. In other words, if a transition
 * is defined that matches the old/current state criteria then the associated animation will be
 * triggered.
 *
 * ```typescript
 * // all transition/state changes are defined within an animation trigger
 * trigger("myAnimationTrigger", [
 *   // if a state is defined then its styles will be persisted when the
 *   // animation has fully completed itself
 *   state("on", style({ background: "green" })),
 *   state("off", style({ background: "grey" })),
 *
 *   // a transition animation that will be kicked off when the state value
 *   // bound to "myAnimationTrigger" changes from "on" to "off"
 *   transition("on => off", animate(500)),
 *
 *   // it is also possible to do run the same animation for both directions
 *   transition("on <=> off", animate(500)),
 *
 *   // or to define multiple states pairs separated by commas
 *   transition("on => off, off => void", animate(500)),
 *
 *   // this is a catch-all state change for when an element is inserted into
 *   // the page and the destination state is unknown
 *   transition("void => *", [
 *     style({ opacity: 0 }),
 *     animate(500)
 *   ]),
 *
 *   // this will capture a state change between any states
 *   transition("* => *", animate("1s 0s")),
 *
 *   // you can also go full out and include a function
 *   transition((fromState, toState) => {
 *     // when `true` then it will allow the animation below to be invoked
 *     return fromState == "off" && toState == "on";
 *   }, animate("1s 0s"))
 * ])
 * ```
 *
 * The template associated with this component will make use of the `myAnimationTrigger` animation
 * trigger by binding to an element within its template code.
 *
 * ```html
 * <!-- somewhere inside of my-component-tpl.html -->
 * <div [\@myAnimationTrigger]="myStatusExp">...</div>
 * ```
 *
 * #### The final `animate` call
 *
 * If the final step within the transition steps is a call to `animate()` that **only** uses a
 * timing value with **no style data** then it will be automatically used as the final animation arc
 * for the element to animate itself to the final state. This involves an automatic mix of
 * adding/removing CSS styles so that the element will be in the exact state it should be for the
 * applied state to be presented correctly.
 *
 * ```
 * // start off by hiding the element, but make sure that it animates properly to whatever state
 * // is currently active for "myAnimationTrigger"
 * transition("void => *", [
 *   style({ opacity: 0 }),
 *   animate(500)
 * ])
 * ```
 *
 * ### Using :enter and :leave
 *
 * Given that enter (insertion) and leave (removal) animations are so common, the `transition`
 * function accepts both `:enter` and `:leave` values which are aliases for the `void => *` and `*
 * => void` state changes.
 *
 * ```
 * transition(":enter", [
 *   style({ opacity: 0 }),
 *   animate(500, style({ opacity: 1 }))
 * ]),
 * transition(":leave", [
 *   animate(500, style({ opacity: 0 }))
 * ])
 * ```
 *
 * ### Using :increment and :decrement
 * In addition to the :enter and :leave transition aliases, the :increment and :decrement aliases
 * can be used to kick off a transition when a numeric value has increased or decreased in value.
 *
 * ```
 * import {group, animate, query, transition, style, trigger} from '\@angular/animations';
 * import {Component} from '\@angular/core';
 *
 * \@Component({
 *   selector: 'banner-carousel-component',
 *   styles: [`
 *     .banner-container {
 *        position:relative;
 *        height:500px;
 *        overflow:hidden;
 *      }
 *     .banner-container > .banner {
 *        position:absolute;
 *        left:0;
 *        top:0;
 *        font-size:200px;
 *        line-height:500px;
 *        font-weight:bold;
 *        text-align:center;
 *        width:100%;
 *      }
 *   `],
 *   template: `
 *     <button (click)="previous()">Previous</button>
 *     <button (click)="next()">Next</button>
 *     <hr>
 *     <div [\@bannerAnimation]="selectedIndex" class="banner-container">
 *       <div class="banner"> {{ banner }} </div>
 *     </div>
 *   `
 *   animations: [
 *     trigger('bannerAnimation', [
 *       transition(":increment", group([
 *         query(':enter', [
 *           style({ left: '100%' }),
 *           animate('0.5s ease-out', style('*'))
 *         ]),
 *         query(':leave', [
 *           animate('0.5s ease-out', style({ left: '-100%' }))
 *         ])
 *       ])),
 *       transition(":decrement", group([
 *         query(':enter', [
 *           style({ left: '-100%' }),
 *           animate('0.5s ease-out', style('*'))
 *         ]),
 *         query(':leave', [
 *           animate('0.5s ease-out', style({ left: '100%' }))
 *         ])
 *       ])),
 *     ])
 *   ]
 * })
 * class BannerCarouselComponent {
 *   allBanners: string[] = ['1', '2', '3', '4'];
 *   selectedIndex: number = 0;
 *
 *   get banners() {
 *      return [this.allBanners[this.selectedIndex]];
 *   }
 *
 *   previous() {
 *     this.selectedIndex = Math.max(this.selectedIndex - 1, 0);
 *   }
 *
 *   next() {
 *     this.selectedIndex = Math.min(this.selectedIndex + 1, this.allBanners.length - 1);
 *   }
 * }
 * ```
 *
 * {\@example core/animation/ts/dsl/animation_example.ts region='Component'}
 *
 * \@experimental Animation support is experimental.
 * @param {?} stateChangeExpr
 * @param {?} steps
 * @param {?=} options
 * @return {?}
 */
function transition(stateChangeExpr, steps, options) {
    if (options === void 0) { options = null; }
    return { type: 1 /* Transition */, expr: stateChangeExpr, animation: steps, options: options };
}
/**
 * `animation` is an animation-specific function that is designed to be used inside of Angular's
 * animation DSL language.
 *
 * `var myAnimation = animation(...)` is designed to produce a reusable animation that can be later
 * invoked in another animation or sequence. Reusable animations are designed to make use of
 * animation parameters and the produced animation can be used via the `useAnimation` method.
 *
 * ```
 * var fadeAnimation = animation([
 *   style({ opacity: '{{ start }}' }),
 *   animate('{{ time }}',
 *     style({ opacity: '{{ end }}'))
 * ], { params: { time: '1000ms', start: 0, end: 1 }});
 * ```
 *
 * If parameters are attached to an animation then they act as **default parameter values**. When an
 * animation is invoked via `useAnimation` then parameter values are allowed to be passed in
 * directly. If any of the passed in parameter values are missing then the default values will be
 * used.
 *
 * ```
 * useAnimation(fadeAnimation, {
 *   params: {
 *     time: '2s',
 *     start: 1,
 *     end: 0
 *   }
 * })
 * ```
 *
 * If one or more parameter values are missing before animated then an error will be thrown.
 *
 * \@experimental Animation support is experimental.
 * @param {?} steps
 * @param {?=} options
 * @return {?}
 */
function animation(steps, options) {
    if (options === void 0) { options = null; }
    return { type: 8 /* Reference */, animation: steps, options: options };
}
/**
 * `animateChild` is an animation-specific function that is designed to be used inside of Angular's
 * animation DSL language. It works by allowing a queried element to execute its own
 * animation within the animation sequence.
 *
 * Each time an animation is triggered in angular, the parent animation
 * will always get priority and any child animations will be blocked. In order
 * for a child animation to run, the parent animation must query each of the elements
 * containing child animations and then allow the animations to run using `animateChild`.
 *
 * The example HTML code below shows both parent and child elements that have animation
 * triggers that will execute at the same time.
 *
 * ```html
 * <!-- parent-child.component.html -->
 * <button (click)="exp =! exp">Toggle</button>
 * <hr>
 *
 * <div [\@parentAnimation]="exp">
 *   <header>Hello</header>
 *   <div [\@childAnimation]="exp">
 *       one
 *   </div>
 *   <div [\@childAnimation]="exp">
 *       two
 *   </div>
 *   <div [\@childAnimation]="exp">
 *       three
 *   </div>
 * </div>
 * ```
 *
 * Now when the `exp` value changes to true, only the `parentAnimation` animation will animate
 * because it has priority. However, using `query` and `animateChild` each of the inner animations
 * can also fire:
 *
 * ```ts
 * // parent-child.component.ts
 * import {trigger, transition, animate, style, query, animateChild} from '\@angular/animations';
 * \@Component({
 *   selector: 'parent-child-component',
 *   animations: [
 *     trigger('parentAnimation', [
 *       transition('false => true', [
 *         query('header', [
 *           style({ opacity: 0 }),
 *           animate(500, style({ opacity: 1 }))
 *         ]),
 *         query('\@childAnimation', [
 *           animateChild()
 *         ])
 *       ])
 *     ]),
 *     trigger('childAnimation', [
 *       transition('false => true', [
 *         style({ opacity: 0 }),
 *         animate(500, style({ opacity: 1 }))
 *       ])
 *     ])
 *   ]
 * })
 * class ParentChildCmp {
 *   exp: boolean = false;
 * }
 * ```
 *
 * In the animation code above, when the `parentAnimation` transition kicks off it first queries to
 * find the header element and fades it in. It then finds each of the sub elements that contain the
 * `\@childAnimation` trigger and then allows for their animations to fire.
 *
 * This example can be further extended by using stagger:
 *
 * ```ts
 * query('\@childAnimation', stagger(100, [
 *   animateChild()
 * ]))
 * ```
 *
 * Now each of the sub animations start off with respect to the `100ms` staggering step.
 *
 * ## The first frame of child animations
 * When sub animations are executed using `animateChild` the animation engine will always apply the
 * first frame of every sub animation immediately at the start of the animation sequence. This way
 * the parent animation does not need to set any initial styling data on the sub elements before the
 * sub animations kick off.
 *
 * In the example above the first frame of the `childAnimation`'s `false => true` transition
 * consists of a style of `opacity: 0`. This is applied immediately when the `parentAnimation`
 * animation transition sequence starts. Only then when the `\@childAnimation` is queried and called
 * with `animateChild` will it then animate to its destination of `opacity: 1`.
 *
 * Note that this feature designed to be used alongside {\@link query query()} and it will only work
 * with animations that are assigned using the Angular animation DSL (this means that CSS keyframes
 * and transitions are not handled by this API).
 *
 * \@experimental Animation support is experimental.
 * @param {?=} options
 * @return {?}
 */
function animateChild(options) {
    if (options === void 0) { options = null; }
    return { type: 9 /* AnimateChild */, options: options };
}
/**
 * `useAnimation` is an animation-specific function that is designed to be used inside of Angular's
 * animation DSL language. It is used to kick off a reusable animation that is created using {\@link
 * animation animation()}.
 *
 * \@experimental Animation support is experimental.
 * @param {?} animation
 * @param {?=} options
 * @return {?}
 */
function useAnimation(animation, options) {
    if (options === void 0) { options = null; }
    return { type: 10 /* AnimateRef */, animation: animation, options: options };
}
/**
 * `query` is an animation-specific function that is designed to be used inside of Angular's
 * animation DSL language.
 *
 * query() is used to find one or more inner elements within the current element that is
 * being animated within the sequence. The provided animation steps are applied
 * to the queried element (by default, an array is provided, then this will be
 * treated as an animation sequence).
 *
 * ### Usage
 *
 * query() is designed to collect mutiple elements and works internally by using
 * `element.querySelectorAll`. An additional options object can be provided which
 * can be used to limit the total amount of items to be collected.
 *
 * ```js
 * query('div', [
 *   animate(...),
 *   animate(...)
 * ], { limit: 1 })
 * ```
 *
 * query(), by default, will throw an error when zero items are found. If a query
 * has the `optional` flag set to true then this error will be ignored.
 *
 * ```js
 * query('.some-element-that-may-not-be-there', [
 *   animate(...),
 *   animate(...)
 * ], { optional: true })
 * ```
 *
 * ### Special Selector Values
 *
 * The selector value within a query can collect elements that contain angular-specific
 * characteristics
 * using special pseudo-selectors tokens.
 *
 * These include:
 *
 *  - Querying for newly inserted/removed elements using `query(":enter")`/`query(":leave")`
 *  - Querying all currently animating elements using `query(":animating")`
 *  - Querying elements that contain an animation trigger using `query("\@triggerName")`
 *  - Querying all elements that contain an animation triggers using `query("\@*")`
 *  - Including the current element into the animation sequence using `query(":self")`
 *
 *
 *  Each of these pseudo-selector tokens can be merged together into a combined query selector
 * string:
 *
 *  ```
 *  query(':self, .record:enter, .record:leave, \@subTrigger', [...])
 *  ```
 *
 * ### Demo
 *
 * ```
 * \@Component({
 *   selector: 'inner',
 *   template: `
 *     <div [\@queryAnimation]="exp">
 *       <h1>Title</h1>
 *       <div class="content">
 *         Blah blah blah
 *       </div>
 *     </div>
 *   `,
 *   animations: [
 *    trigger('queryAnimation', [
 *      transition('* => goAnimate', [
 *        // hide the inner elements
 *        query('h1', style({ opacity: 0 })),
 *        query('.content', style({ opacity: 0 })),
 *
 *        // animate the inner elements in, one by one
 *        query('h1', animate(1000, style({ opacity: 1 })),
 *        query('.content', animate(1000, style({ opacity: 1 })),
 *      ])
 *    ])
 *  ]
 * })
 * class Cmp {
 *   exp = '';
 *
 *   goAnimate() {
 *     this.exp = 'goAnimate';
 *   }
 * }
 * ```
 *
 * \@experimental Animation support is experimental.
 * @param {?} selector
 * @param {?} animation
 * @param {?=} options
 * @return {?}
 */
function query(selector, animation, options) {
    if (options === void 0) { options = null; }
    return { type: 11 /* Query */, selector: selector, animation: animation, options: options };
}
/**
 * `stagger` is an animation-specific function that is designed to be used inside of Angular's
 * animation DSL language. It is designed to be used inside of an animation {\@link query query()}
 * and works by issuing a timing gap between after each queried item is animated.
 *
 * ### Usage
 *
 * In the example below there is a container element that wraps a list of items stamped out
 * by an ngFor. The container element contains an animation trigger that will later be set
 * to query for each of the inner items.
 *
 * ```html
 * <!-- list.component.html -->
 * <button (click)="toggle()">Show / Hide Items</button>
 * <hr />
 * <div [\@listAnimation]="items.length">
 *   <div *ngFor="let item of items">
 *     {{ item }}
 *   </div>
 * </div>
 * ```
 *
 * The component code for this looks as such:
 *
 * ```ts
 * import {trigger, transition, style, animate, query, stagger} from '\@angular/animations';
 * \@Component({
 *   templateUrl: 'list.component.html',
 *   animations: [
 *     trigger('listAnimation', [
 *        //...
 *     ])
 *   ]
 * })
 * class ListComponent {
 *   items = [];
 *
 *   showItems() {
 *     this.items = [0,1,2,3,4];
 *   }
 *
 *   hideItems() {
 *     this.items = [];
 *   }
 *
 *   toggle() {
 *     this.items.length ? this.hideItems() : this.showItems();
 *   }
 * }
 * ```
 *
 * And now for the animation trigger code:
 *
 * ```ts
 * trigger('listAnimation', [
 *   transition('* => *', [ // each time the binding value changes
 *     query(':leave', [
 *       stagger(100, [
 *         animate('0.5s', style({ opacity: 0 }))
 *       ])
 *     ]),
 *     query(':enter', [
 *       style({ opacity: 0 }),
 *       stagger(100, [
 *         animate('0.5s', style({ opacity: 1 }))
 *       ])
 *     ])
 *   ])
 * ])
 * ```
 *
 * Now each time the items are added/removed then either the opacity
 * fade-in animation will run or each removed item will be faded out.
 * When either of these animations occur then a stagger effect will be
 * applied after each item's animation is started.
 *
 * \@experimental Animation support is experimental.
 * @param {?} timings
 * @param {?} animation
 * @return {?}
 */
function stagger(timings, animation) {
    return { type: 12 /* Stagger */, timings: timings, animation: animation };
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 * @param {?} cb
 * @return {?}
 */
function scheduleMicroTask(cb) {
    Promise.resolve(null).then(cb);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * AnimationPlayer controls an animation sequence that was produced from a programmatic animation.
 * (see {\@link AnimationBuilder AnimationBuilder} for more information on how to create programmatic
 * animations.)
 *
 * \@experimental Animation support is experimental.
 * @record
 */

/**
 * \@experimental Animation support is experimental.
 */
var NoopAnimationPlayer = (function () {
    function NoopAnimationPlayer() {
        this._onDoneFns = [];
        this._onStartFns = [];
        this._onDestroyFns = [];
        this._started = false;
        this._destroyed = false;
        this._finished = false;
        this.parentPlayer = null;
        this.totalTime = 0;
    }
    /**
     * @return {?}
     */
    NoopAnimationPlayer.prototype._onFinish = /**
     * @return {?}
     */
    function () {
        if (!this._finished) {
            this._finished = true;
            this._onDoneFns.forEach(function (fn) { return fn(); });
            this._onDoneFns = [];
        }
    };
    /**
     * @param {?} fn
     * @return {?}
     */
    NoopAnimationPlayer.prototype.onStart = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) { this._onStartFns.push(fn); };
    /**
     * @param {?} fn
     * @return {?}
     */
    NoopAnimationPlayer.prototype.onDone = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) { this._onDoneFns.push(fn); };
    /**
     * @param {?} fn
     * @return {?}
     */
    NoopAnimationPlayer.prototype.onDestroy = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) { this._onDestroyFns.push(fn); };
    /**
     * @return {?}
     */
    NoopAnimationPlayer.prototype.hasStarted = /**
     * @return {?}
     */
    function () { return this._started; };
    /**
     * @return {?}
     */
    NoopAnimationPlayer.prototype.init = /**
     * @return {?}
     */
    function () { };
    /**
     * @return {?}
     */
    NoopAnimationPlayer.prototype.play = /**
     * @return {?}
     */
    function () {
        if (!this.hasStarted()) {
            this.triggerMicrotask();
            this._onStart();
        }
        this._started = true;
    };
    /* @internal */
    /**
     * @return {?}
     */
    NoopAnimationPlayer.prototype.triggerMicrotask = /**
     * @return {?}
     */
    function () {
        var _this = this;
        scheduleMicroTask(function () { return _this._onFinish(); });
    };
    /**
     * @return {?}
     */
    NoopAnimationPlayer.prototype._onStart = /**
     * @return {?}
     */
    function () {
        this._onStartFns.forEach(function (fn) { return fn(); });
        this._onStartFns = [];
    };
    /**
     * @return {?}
     */
    NoopAnimationPlayer.prototype.pause = /**
     * @return {?}
     */
    function () { };
    /**
     * @return {?}
     */
    NoopAnimationPlayer.prototype.restart = /**
     * @return {?}
     */
    function () { };
    /**
     * @return {?}
     */
    NoopAnimationPlayer.prototype.finish = /**
     * @return {?}
     */
    function () { this._onFinish(); };
    /**
     * @return {?}
     */
    NoopAnimationPlayer.prototype.destroy = /**
     * @return {?}
     */
    function () {
        if (!this._destroyed) {
            this._destroyed = true;
            if (!this.hasStarted()) {
                this._onStart();
            }
            this.finish();
            this._onDestroyFns.forEach(function (fn) { return fn(); });
            this._onDestroyFns = [];
        }
    };
    /**
     * @return {?}
     */
    NoopAnimationPlayer.prototype.reset = /**
     * @return {?}
     */
    function () { };
    /**
     * @param {?} p
     * @return {?}
     */
    NoopAnimationPlayer.prototype.setPosition = /**
     * @param {?} p
     * @return {?}
     */
    function (p) { };
    /**
     * @return {?}
     */
    NoopAnimationPlayer.prototype.getPosition = /**
     * @return {?}
     */
    function () { return 0; };
    return NoopAnimationPlayer;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var AnimationGroupPlayer = (function () {
    function AnimationGroupPlayer(_players) {
        var _this = this;
        this._players = _players;
        this._onDoneFns = [];
        this._onStartFns = [];
        this._finished = false;
        this._started = false;
        this._destroyed = false;
        this._onDestroyFns = [];
        this.parentPlayer = null;
        this.totalTime = 0;
        var /** @type {?} */ doneCount = 0;
        var /** @type {?} */ destroyCount = 0;
        var /** @type {?} */ startCount = 0;
        var /** @type {?} */ total = this._players.length;
        if (total == 0) {
            scheduleMicroTask(function () { return _this._onFinish(); });
        }
        else {
            this._players.forEach(function (player) {
                player.parentPlayer = _this;
                player.onDone(function () {
                    if (++doneCount >= total) {
                        _this._onFinish();
                    }
                });
                player.onDestroy(function () {
                    if (++destroyCount >= total) {
                        _this._onDestroy();
                    }
                });
                player.onStart(function () {
                    if (++startCount >= total) {
                        _this._onStart();
                    }
                });
            });
        }
        this.totalTime = this._players.reduce(function (time, player) { return Math.max(time, player.totalTime); }, 0);
    }
    /**
     * @return {?}
     */
    AnimationGroupPlayer.prototype._onFinish = /**
     * @return {?}
     */
    function () {
        if (!this._finished) {
            this._finished = true;
            this._onDoneFns.forEach(function (fn) { return fn(); });
            this._onDoneFns = [];
        }
    };
    /**
     * @return {?}
     */
    AnimationGroupPlayer.prototype.init = /**
     * @return {?}
     */
    function () { this._players.forEach(function (player) { return player.init(); }); };
    /**
     * @param {?} fn
     * @return {?}
     */
    AnimationGroupPlayer.prototype.onStart = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) { this._onStartFns.push(fn); };
    /**
     * @return {?}
     */
    AnimationGroupPlayer.prototype._onStart = /**
     * @return {?}
     */
    function () {
        if (!this.hasStarted()) {
            this._onStartFns.forEach(function (fn) { return fn(); });
            this._onStartFns = [];
            this._started = true;
        }
    };
    /**
     * @param {?} fn
     * @return {?}
     */
    AnimationGroupPlayer.prototype.onDone = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) { this._onDoneFns.push(fn); };
    /**
     * @param {?} fn
     * @return {?}
     */
    AnimationGroupPlayer.prototype.onDestroy = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) { this._onDestroyFns.push(fn); };
    /**
     * @return {?}
     */
    AnimationGroupPlayer.prototype.hasStarted = /**
     * @return {?}
     */
    function () { return this._started; };
    /**
     * @return {?}
     */
    AnimationGroupPlayer.prototype.play = /**
     * @return {?}
     */
    function () {
        if (!this.parentPlayer) {
            this.init();
        }
        this._onStart();
        this._players.forEach(function (player) { return player.play(); });
    };
    /**
     * @return {?}
     */
    AnimationGroupPlayer.prototype.pause = /**
     * @return {?}
     */
    function () { this._players.forEach(function (player) { return player.pause(); }); };
    /**
     * @return {?}
     */
    AnimationGroupPlayer.prototype.restart = /**
     * @return {?}
     */
    function () { this._players.forEach(function (player) { return player.restart(); }); };
    /**
     * @return {?}
     */
    AnimationGroupPlayer.prototype.finish = /**
     * @return {?}
     */
    function () {
        this._onFinish();
        this._players.forEach(function (player) { return player.finish(); });
    };
    /**
     * @return {?}
     */
    AnimationGroupPlayer.prototype.destroy = /**
     * @return {?}
     */
    function () { this._onDestroy(); };
    /**
     * @return {?}
     */
    AnimationGroupPlayer.prototype._onDestroy = /**
     * @return {?}
     */
    function () {
        if (!this._destroyed) {
            this._destroyed = true;
            this._onFinish();
            this._players.forEach(function (player) { return player.destroy(); });
            this._onDestroyFns.forEach(function (fn) { return fn(); });
            this._onDestroyFns = [];
        }
    };
    /**
     * @return {?}
     */
    AnimationGroupPlayer.prototype.reset = /**
     * @return {?}
     */
    function () {
        this._players.forEach(function (player) { return player.reset(); });
        this._destroyed = false;
        this._finished = false;
        this._started = false;
    };
    /**
     * @param {?} p
     * @return {?}
     */
    AnimationGroupPlayer.prototype.setPosition = /**
     * @param {?} p
     * @return {?}
     */
    function (p) {
        var /** @type {?} */ timeAtPosition = p * this.totalTime;
        this._players.forEach(function (player) {
            var /** @type {?} */ position = player.totalTime ? Math.min(1, timeAtPosition / player.totalTime) : 1;
            player.setPosition(position);
        });
    };
    /**
     * @return {?}
     */
    AnimationGroupPlayer.prototype.getPosition = /**
     * @return {?}
     */
    function () {
        var /** @type {?} */ min = 0;
        this._players.forEach(function (player) {
            var /** @type {?} */ p = player.getPosition();
            min = Math.min(p, min);
        });
        return min;
    };
    Object.defineProperty(AnimationGroupPlayer.prototype, "players", {
        get: /**
         * @return {?}
         */
        function () { return this._players; },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    AnimationGroupPlayer.prototype.beforeDestroy = /**
     * @return {?}
     */
    function () {
        this.players.forEach(function (player) {
            if (player.beforeDestroy) {
                player.beforeDestroy();
            }
        });
    };
    return AnimationGroupPlayer;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var ɵPRE_STYLE = '!';

exports.AnimationBuilder = AnimationBuilder;
exports.AnimationFactory = AnimationFactory;
exports.AUTO_STYLE = AUTO_STYLE;
exports.animate = animate;
exports.animateChild = animateChild;
exports.animation = animation;
exports.group = group;
exports.keyframes = keyframes;
exports.query = query;
exports.sequence = sequence;
exports.stagger = stagger;
exports.state = state;
exports.style = style;
exports.transition = transition;
exports.trigger = trigger;
exports.useAnimation = useAnimation;
exports.NoopAnimationPlayer = NoopAnimationPlayer;
exports.ɵAnimationGroupPlayer = AnimationGroupPlayer;
exports.ɵPRE_STYLE = ɵPRE_STYLE;

Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=animations.umd.js.map


/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = Document;

var Node = __webpack_require__(4);
var NodeList = __webpack_require__(13);
var Element = __webpack_require__(9);
var Text = __webpack_require__(49);
var Comment = __webpack_require__(51);
var Event = __webpack_require__(8);
var DocumentFragment = __webpack_require__(52);
var ProcessingInstruction = __webpack_require__(53);
var DOMImplementation = __webpack_require__(12);
var TreeWalker = __webpack_require__(79);
var NodeIterator = __webpack_require__(80);
var NodeFilter = __webpack_require__(15);
var URL = __webpack_require__(24);
var select = __webpack_require__(22);
var events = __webpack_require__(55);
var xml = __webpack_require__(21);
var html = __webpack_require__(25);
var svg = __webpack_require__(60);
var utils = __webpack_require__(3);
var MUTATE = __webpack_require__(86);
var NAMESPACE = utils.NAMESPACE;
var isApiWritable = __webpack_require__(45).isApiWritable;

function Document(isHTML, address) {
  this.nodeType = Node.DOCUMENT_NODE;
  this.isHTML = isHTML;
  this._address = address || 'about:blank';
  this.readyState = 'loading';
  this.implementation = new DOMImplementation();

  // DOMCore says that documents are always associated with themselves
  this.ownerDocument = null; // ... but W3C tests expect null

  // These will be initialized by our custom versions of
  // appendChild and insertBefore that override the inherited
  // Node methods.
  // XXX: override those methods!
  this.doctype = null;
  this.documentElement = null;
  this.childNodes = new NodeList();

  // "Associated inert template document"
  this._templateDocCache = null;

  // Documents are always rooted, by definition
  this._nid = 1;
  this._nextnid = 2; // For numbering children of the document
  this._nodes = [null, this];  // nid to node map

  // This maintains the mapping from element ids to element nodes.
  // We may need to update this mapping every time a node is rooted
  // or uprooted, and any time an attribute is added, removed or changed
  // on a rooted element.
  this.byId = Object.create(null);

  // This property holds a monotonically increasing value akin to
  // a timestamp used to record the last modification time of nodes
  // and their subtrees. See the lastModTime attribute and modify()
  // method of the Node class. And see FilteredElementList for an example
  // of the use of lastModTime
  this.modclock = 0;
}

// Map from lowercase event category names (used as arguments to
// createEvent()) to the property name in the impl object of the
// event constructor.
var supportedEvents = {
  event: 'Event',
  customevent: 'CustomEvent',
  uievent: 'UIEvent',
  mouseevent: 'MouseEvent'
};

// Certain arguments to document.createEvent() must be treated specially
var replacementEvent = {
  events: 'event',
  htmlevents: 'event',
  mouseevents: 'mouseevent',
  mutationevents: 'mutationevent',
  uievents: 'uievent'
};

var mirrorAttr = function(f, name, defaultValue) {
  return {
    get: function() {
      var o = f.call(this);
      if (o) { return o[name]; }
      return defaultValue;
    },
    set: function(value) {
      var o = f.call(this);
      if (o) { o[name] = value; }
    },
  };
};

Document.prototype = Object.create(Node.prototype, {
  // This method allows dom.js to communicate with a renderer
  // that displays the document in some way
  // XXX: I should probably move this to the window object
  _setMutationHandler: { value: function(handler) {
    this.mutationHandler = handler;
  }},

  // This method allows dom.js to receive event notifications
  // from the renderer.
  // XXX: I should probably move this to the window object
  _dispatchRendererEvent: { value: function(targetNid, type, details) {
    var target = this._nodes[targetNid];
    if (!target) return;
    target._dispatchEvent(new Event(type, details), true);
  }},

  nodeName: { value: '#document'},
  nodeValue: {
    get: function() {
      return null;
    },
    set: function() {}
  },

  // XXX: DOMCore may remove documentURI, so it is NYI for now
  documentURI: { get: utils.nyi, set: utils.nyi },
  compatMode: { get: function() {
    // The _quirks property is set by the HTML parser
    return this._quirks ? 'BackCompat' : 'CSS1Compat';
  }},
  parentNode: { value: null },

  createTextNode: { value: function(data) {
    return new Text(this, '' + data);
  }},
  createComment: { value: function(data) {
    return new Comment(this, data);
  }},
  createDocumentFragment: { value: function() {
    return new DocumentFragment(this);
  }},
  createProcessingInstruction: { value: function(target, data) {
    if (!xml.isValidName(target) || data.indexOf('?>') !== -1)
      utils.InvalidCharacterError();
    return new ProcessingInstruction(this, target, data);
  }},

  createElement: { value: function(localName) {
    if (!xml.isValidName(localName)) utils.InvalidCharacterError();
    if (this.isHTML) localName = utils.toASCIILowerCase(localName);
    return html.createElement(this, localName, null);
  }, writable: isApiWritable },

  createElementNS: { value: function(namespace, qualifiedName) {
    if (!xml.isValidName(qualifiedName)) utils.InvalidCharacterError();
    if (!xml.isValidQName(qualifiedName)) utils.NamespaceError();

    var pos, prefix, localName;
    if ((pos = qualifiedName.indexOf(':')) !== -1) {
      prefix = qualifiedName.substring(0, pos);
      localName = qualifiedName.substring(pos+1);

      if (namespace === '' ||
        (prefix === 'xml' && namespace !== NAMESPACE.XML))
        utils.NamespaceError();
    }
    else {
      prefix = null;
      localName = qualifiedName;
    }

    if (((qualifiedName === 'xmlns' || prefix === 'xmlns') &&
       namespace !== NAMESPACE.XMLNS) ||
      (namespace === NAMESPACE.XMLNS &&
       qualifiedName !== 'xmlns' &&
       prefix !== 'xmlns'))
      utils.NamespaceError();

    if (namespace === NAMESPACE.HTML) {
      return html.createElement(this, localName, prefix);
    }
    else if (namespace === NAMESPACE.SVG) {
      return svg.createElement(this, localName, prefix);
    }

    return new Element(this, localName, namespace, prefix);
  }, writable: isApiWritable },

  createEvent: { value: function createEvent(interfaceName) {
    interfaceName = interfaceName.toLowerCase();
    var name = replacementEvent[interfaceName] || interfaceName;
    var constructor = events[supportedEvents[name]];

    if (constructor) {
      var e = new constructor();
      e._initialized = false;
      return e;
    }
    else {
      utils.NotSupportedError();
    }
  }},

  // See: http://www.w3.org/TR/dom/#dom-document-createtreewalker
  createTreeWalker: {value: function (root, whatToShow, filter) {
    whatToShow = whatToShow === undefined ? NodeFilter.SHOW_ALL : whatToShow;

    if (filter && typeof filter === 'object' &&
        typeof filter.acceptNode === 'function') {
      filter = filter.acceptNode.bind(filter);
      // Support filter being a function
      // https://developer.mozilla.org/en-US/docs/DOM/document.createTreeWalker
    }
    else if (typeof filter !== 'function') {
      filter = null;
    }
    return new TreeWalker(root, whatToShow, filter);
  }},

  // See: http://www.w3.org/TR/dom/#dom-document-createnodeiterator
  createNodeIterator: {value: function (root, whatToShow, filter) {
    whatToShow = whatToShow === undefined ? NodeFilter.SHOW_ALL : whatToShow;

    if (filter && typeof filter === 'object' &&
        typeof filter.acceptNode === 'function') {
      filter = filter.acceptNode.bind(filter);
      // Support filter being a function
      // https://developer.mozilla.org/en-US/docs/DOM/document.createNodeIterator
    }
    else if (typeof filter !== 'function') {
      filter = null;
    }
    return new NodeIterator(root, whatToShow, filter);
  }},

  // Maintain the documentElement and
  // doctype properties of the document.  Each of the following
  // methods chains to the Node implementation of the method
  // to do the actual inserting, removal or replacement.

  _updateDocTypeElement: { value: function _updateDocTypeElement() {
    var i, n, nodes = this.childNodes, length = nodes.length;
    this.doctype = this.documentElement = null;
    for (i=0; i<length; i++) {
      n = nodes[i];
      if (n.nodeType === Node.DOCUMENT_TYPE_NODE)
        this.doctype = n;
      else if (n.nodeType === Node.ELEMENT_NODE)
        this.documentElement = n;
    }
  }},

  insertBefore: { value: function insertBefore(child, refChild) {
    Node.prototype.insertBefore.call(this, child, refChild);
    this._updateDocTypeElement();
    return child;
  }},

  replaceChild: { value: function replaceChild(node, child) {
    Node.prototype.replaceChild.call(this, node, child);
    this._updateDocTypeElement();
    return child;
  }},

  removeChild: { value: function removeChild(child) {
    Node.prototype.removeChild.call(this, child);
    this._updateDocTypeElement();
    return child;
  }},

  getElementById: { value: function(id) {
    var n = this.byId[id];
    if (!n) return null;
    if (n instanceof MultiId) { // there was more than one element with this id
      return n.getFirst();
    }
    return n;
  }},

  _hasMultipleElementsWithId: { value: function(id) {
    // Used internally by querySelectorAll optimization
    return (this.byId[id] instanceof MultiId);
  }},

  // Just copy this method from the Element prototype
  getElementsByName: { value: Element.prototype.getElementsByName },
  getElementsByTagName: { value: Element.prototype.getElementsByTagName },
  getElementsByTagNameNS: { value: Element.prototype.getElementsByTagNameNS },
  getElementsByClassName: { value: Element.prototype.getElementsByClassName },

  adoptNode: { value: function adoptNode(node) {
    if (node.nodeType === Node.DOCUMENT_NODE) utils.NotSupportedError();

    if (node.parentNode) node.parentNode.removeChild(node);

    if (node.ownerDocument !== this)
      recursivelySetOwner(node, this);

    return node;
  }},

  importNode: { value: function importNode(node, deep) {
    return this.adoptNode(node.cloneNode(deep));
  }, writable: isApiWritable },

  // The following attributes and methods are from the HTML spec
  URL: { get: utils.nyi },
  domain: { get: utils.nyi, set: utils.nyi },
  referrer: { get: utils.nyi },
  cookie: { get: utils.nyi, set: utils.nyi },
  lastModified: { get: utils.nyi },
  location: {
	get: function() {
	  return this.defaultView ? this.defaultView.location : null; // gh #75
	},
	set: utils.nyi
  },
  _titleElement: {
    get: function() {
      // The title element of a document is the first title element in the
      // document in tree order, if there is one, or null otherwise.
      return this.getElementsByTagName('title').item(0) || null;
    }
  },
  title: {
    get: function() {
      var elt = this._titleElement;
      // The child text content of the title element, or '' if null.
      var value = elt ? elt.textContent : '';
      // Strip and collapse whitespace in value
      return value.replace(/[ \t\n\r\f]+/g, ' ').trim();
    },
    set: function(value) {
      var elt = this._titleElement;
      var head = this.head;
      if (!elt && !head) { return; /* according to spec */ }
      if (!elt) {
        elt = this.createElement('title');
        head.appendChild(elt);
      }
      elt.textContent = value;
    }
  },
  dir: mirrorAttr(function() {
    var htmlElement = this.documentElement;
    if (htmlElement && htmlElement.tagName === 'HTML') { return htmlElement; }
  }, 'dir', ''),
  fgColor: mirrorAttr(function() { return this.body; }, 'text', ''),
  linkColor: mirrorAttr(function() { return this.body; }, 'link', ''),
  vlinkColor: mirrorAttr(function() { return this.body; }, 'vLink', ''),
  alinkColor: mirrorAttr(function() { return this.body; }, 'aLink', ''),
  bgColor: mirrorAttr(function() { return this.body; }, 'bgColor', ''),

  // Return the first <body> child of the document element.
  // XXX For now, setting this attribute is not implemented.
  body: {
    get: function() {
      return namedHTMLChild(this.documentElement, 'body');
    },
    set: utils.nyi
  },
  // Return the first <head> child of the document element.
  head: { get: function() {
    return namedHTMLChild(this.documentElement, 'head');
  }},
  images: { get: utils.nyi },
  embeds: { get: utils.nyi },
  plugins: { get: utils.nyi },
  links: { get: utils.nyi },
  forms: { get: utils.nyi },
  scripts: { get: utils.nyi },
  innerHTML: {
    get: function() { return this.serialize(); },
    set: utils.nyi
  },
  outerHTML: {
    get: function() { return this.serialize(); },
    set: utils.nyi
  },

  write: { value: function(args) {
    if (!this.isHTML) utils.InvalidStateError();

    // XXX: still have to implement the ignore part
    if (!this._parser /* && this._ignore_destructive_writes > 0 */ )
      return;

    if (!this._parser) {
      // XXX call document.open, etc.
    }

    var s = arguments.join('');

    // If the Document object's reload override flag is set, then
    // append the string consisting of the concatenation of all the
    // arguments to the method to the Document's reload override
    // buffer.
    // XXX: don't know what this is about.  Still have to do it

    // If there is no pending parsing-blocking script, have the
    // tokenizer process the characters that were inserted, one at a
    // time, processing resulting tokens as they are emitted, and
    // stopping when the tokenizer reaches the insertion point or when
    // the processing of the tokenizer is aborted by the tree
    // construction stage (this can happen if a script end tag token is
    // emitted by the tokenizer).

    // XXX: still have to do the above. Sounds as if we don't
    // always call parse() here.  If we're blocked, then we just
    // insert the text into the stream but don't parse it reentrantly...

    // Invoke the parser reentrantly
    this._parser.parse(s);
  }},

  writeln: { value: function writeln(args) {
    this.write(Array.prototype.join.call(arguments, '') + '\n');
  }},

  open: { value: function() {
    this.documentElement = null;
  }},

  close: { value: function() {
    this.readyState = 'complete';
    var ev = new Event('DOMContentLoaded');
    this._dispatchEvent(ev, true);
    if (this.defaultView) {
      ev = new Event('load');
      this.defaultView._dispatchEvent(ev, true);
    }
  }},

  // Utility methods
  clone: { value: function clone() {
    // Can't clone an entire document
    utils.DataCloneError();
  }},

  isEqual: { value: function isEqual(n) {
    // Any two documents are shallowly equal.
    // Node.isEqualNode will also test the children
    return true;
  }},

  // Implementation-specific function.  Called when a text, comment,
  // or pi value changes.
  mutateValue: { value: function(node) {
    if (this.mutationHandler) {
      this.mutationHandler({
        type: MUTATE.VALUE,
        target: node,
        data: node.data
      });
    }
  }},

  // Invoked when an attribute's value changes. Attr holds the new
  // value.  oldval is the old value.  Attribute mutations can also
  // involve changes to the prefix (and therefore the qualified name)
  mutateAttr: { value: function(attr, oldval) {
    // Manage id->element mapping for getElementsById()
    // XXX: this special case id handling should not go here,
    // but in the attribute declaration for the id attribute
    /*
    if (attr.localName === 'id' && attr.namespaceURI === null) {
      if (oldval) delId(oldval, attr.ownerElement);
      addId(attr.value, attr.ownerElement);
    }
    */
    if (this.mutationHandler) {
      this.mutationHandler({
        type: MUTATE.ATTR,
        target: attr.ownerElement,
        attr: attr
      });
    }
  }},

  // Used by removeAttribute and removeAttributeNS for attributes.
  mutateRemoveAttr: { value: function(attr) {
/*
* This is now handled in Attributes.js
    // Manage id to element mapping
    if (attr.localName === 'id' && attr.namespaceURI === null) {
      this.delId(attr.value, attr.ownerElement);
    }
*/
    if (this.mutationHandler) {
      this.mutationHandler({
        type: MUTATE.REMOVE_ATTR,
        target: attr.ownerElement,
        attr: attr
      });
    }
  }},

  // Called by Node.removeChild, etc. to remove a rooted element from
  // the tree. Only needs to generate a single mutation event when a
  // node is removed, but must recursively mark all descendants as not
  // rooted.
  mutateRemove: { value: function(node) {
    // Send a single mutation event
    if (this.mutationHandler) {
      this.mutationHandler({
        type: MUTATE.REMOVE,
        target: node.parentNode,
        node: node
      });
    }

    // Mark this and all descendants as not rooted
    recursivelyUproot(node);
  }},

  // Called when a new element becomes rooted.  It must recursively
  // generate mutation events for each of the children, and mark them all
  // as rooted.
  mutateInsert: { value: function(node) {
    // Mark node and its descendants as rooted
    recursivelyRoot(node);

    // Send a single mutation event
    if (this.mutationHandler) {
      this.mutationHandler({
        type: MUTATE.INSERT,
        target: node.parentNode,
        node: node
      });
    }
  }},

  // Called when a rooted element is moved within the document
  mutateMove: { value: function(node) {
    if (this.mutationHandler) {
      this.mutationHandler({
        type: MUTATE.MOVE,
        target: node
      });
    }
  }},


  // Add a mapping from  id to n for n.ownerDocument
  addId: { value: function addId(id, n) {
    var val = this.byId[id];
    if (!val) {
      this.byId[id] = n;
    }
    else {
      // TODO: Add a way to opt-out console warnings
      //console.warn('Duplicate element id ' + id);
      if (!(val instanceof MultiId)) {
        val = new MultiId(val);
        this.byId[id] = val;
      }
      val.add(n);
    }
  }},

  // Delete the mapping from id to n for n.ownerDocument
  delId: { value: function delId(id, n) {
    var val = this.byId[id];
    utils.assert(val);

    if (val instanceof MultiId) {
      val.del(n);
      if (val.length === 1) { // convert back to a single node
        this.byId[id] = val.downgrade();
      }
    }
    else {
      this.byId[id] = undefined;
    }
  }},

  _resolve: { value: function(href) {
    //XXX: Cache the URL
    return new URL(this._documentBaseURL).resolve(href);
  }},

  _documentBaseURL: { get: function() {
    // XXX: This is not implemented correctly yet
    var url = this._address;
    if (url === 'about:blank') url = '/';

    var base = this.querySelector('base[href]');
    if (base) {
      return new URL(url).resolve(base.getAttribute('href'));
    }
    return url;

    // The document base URL of a Document object is the
    // absolute URL obtained by running these substeps:

    //     Let fallback base url be the document's address.

    //     If fallback base url is about:blank, and the
    //     Document's browsing context has a creator browsing
    //     context, then let fallback base url be the document
    //     base URL of the creator Document instead.

    //     If the Document is an iframe srcdoc document, then
    //     let fallback base url be the document base URL of
    //     the Document's browsing context's browsing context
    //     container's Document instead.

    //     If there is no base element that has an href
    //     attribute, then the document base URL is fallback
    //     base url; abort these steps. Otherwise, let url be
    //     the value of the href attribute of the first such
    //     element.

    //     Resolve url relative to fallback base url (thus,
    //     the base href attribute isn't affected by xml:base
    //     attributes).

    //     The document base URL is the result of the previous
    //     step if it was successful; otherwise it is fallback
    //     base url.
  }},

  _templateDoc: { get: function() {
    if (!this._templateDocCache) {
      // "associated inert template document"
      var newDoc = new Document(this.isHTML, this._address);
      this._templateDocCache = newDoc._templateDocCache = newDoc;
    }
    return this._templateDocCache;
  }},

  querySelector: { value: function(selector) {
    return select(selector, this)[0];
  }},

  querySelectorAll: { value: function(selector) {
    var nodes = select(selector, this);
    return nodes.item ? nodes : new NodeList(nodes);
  }}

});


var eventHandlerTypes = [
  'abort', 'canplay', 'canplaythrough', 'change', 'click', 'contextmenu',
  'cuechange', 'dblclick', 'drag', 'dragend', 'dragenter', 'dragleave',
  'dragover', 'dragstart', 'drop', 'durationchange', 'emptied', 'ended',
  'input', 'invalid', 'keydown', 'keypress', 'keyup', 'loadeddata',
  'loadedmetadata', 'loadstart', 'mousedown', 'mousemove', 'mouseout',
  'mouseover', 'mouseup', 'mousewheel', 'pause', 'play', 'playing',
  'progress', 'ratechange', 'readystatechange', 'reset', 'seeked',
  'seeking', 'select', 'show', 'stalled', 'submit', 'suspend',
  'timeupdate', 'volumechange', 'waiting',

  'blur', 'error', 'focus', 'load', 'scroll'
];

// Add event handler idl attribute getters and setters to Document
eventHandlerTypes.forEach(function(type) {
  // Define the event handler registration IDL attribute for this type
  Object.defineProperty(Document.prototype, 'on' + type, {
    get: function() {
      return this._getEventHandler(type);
    },
    set: function(v) {
      this._setEventHandler(type, v);
    }
  });
});

function namedHTMLChild(parent, name) {
  if (parent && parent.isHTML) {
    var kids = parent.childNodes;
    for(var i = 0, n = kids.length; i < n; i++) {
      if (kids[i].nodeType === Node.ELEMENT_NODE &&
        kids[i].localName === name &&
        kids[i].namespaceURI === NAMESPACE.HTML) {
        return kids[i];
      }
    }
  }
  return null;
}

function root(n) {
  n._nid = n.ownerDocument._nextnid++;
  n.ownerDocument._nodes[n._nid] = n;
  // Manage id to element mapping
  if (n.nodeType === Node.ELEMENT_NODE) {
    var id = n.getAttribute('id');
    if (id) n.ownerDocument.addId(id, n);

    // Script elements need to know when they're inserted
    // into the document
    if (n._roothook) n._roothook();
  }
}

function uproot(n) {
  // Manage id to element mapping
  if (n.nodeType === Node.ELEMENT_NODE) {
    var id = n.getAttribute('id');
    if (id) n.ownerDocument.delId(id, n);
  }
  n.ownerDocument._nodes[n._nid] = undefined;
  n._nid = undefined;
}

function recursivelyRoot(node) {
  root(node);
  // XXX:
  // accessing childNodes on a leaf node creates a new array the
  // first time, so be careful to write this loop so that it
  // doesn't do that. node is polymorphic, so maybe this is hard to
  // optimize?  Try switching on nodeType?
/*
  if (node.hasChildNodes()) {
    var kids = node.childNodes;
    for(var i = 0, n = kids.length;  i < n; i++)
      recursivelyRoot(kids[i]);
  }
*/
  if (node.nodeType === Node.ELEMENT_NODE) {
    var kids = node.childNodes;
    for(var i = 0, n = kids.length; i < n; i++)
      recursivelyRoot(kids[i]);
  }
}

function recursivelyUproot(node) {
  uproot(node);
  for(var i = 0, n = node.childNodes.length; i < n; i++)
    recursivelyUproot(node.childNodes[i]);
}

function recursivelySetOwner(node, owner) {
  node.ownerDocument = owner;
  node._lastModTime = undefined; // mod times are document-based
  var kids = node.childNodes;
  for(var i = 0, n = kids.length; i < n; i++)
    recursivelySetOwner(kids[i], owner);
}

// A class for storing multiple nodes with the same ID
function MultiId(node) {
  this.nodes = Object.create(null);
  this.nodes[node._nid] = node;
  this.length = 1;
  this.firstNode = undefined;
}

// Add a node to the list, with O(1) time
MultiId.prototype.add = function(node) {
  if (!this.nodes[node._nid]) {
    this.nodes[node._nid] = node;
    this.length++;
    this.firstNode = undefined;
  }
};

// Remove a node from the list, with O(1) time
MultiId.prototype.del = function(node) {
  if (this.nodes[node._nid]) {
    delete this.nodes[node._nid];
    this.length--;
    this.firstNode = undefined;
  }
};

// Get the first node from the list, in the document order
// Takes O(N) time in the size of the list, with a cache that is invalidated
// when the list is modified.
MultiId.prototype.getFirst = function() {
  /* jshint bitwise: false */
  if (!this.firstNode) {
    var nid;
    for (nid in this.nodes) {
      if (this.firstNode === undefined ||
        this.firstNode.compareDocumentPosition(this.nodes[nid]) & Node.DOCUMENT_POSITION_PRECEDING) {
        this.firstNode = this.nodes[nid];
      }
    }
  }
  return this.firstNode;
};

// If there is only one node left, return it. Otherwise return "this".
MultiId.prototype.downgrade = function() {
  if (this.length === 1) {
    var nid;
    for (nid in this.nodes) {
      return this.nodes[nid];
    }
  }
  return this;
};


/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// This grammar is from the XML and XML Namespace specs. It specifies whether
// a string (such as an element or attribute name) is a valid Name or QName.
//
// Name           ::= NameStartChar (NameChar)*
// NameStartChar  ::= ":" | [A-Z] | "_" | [a-z] |
//                    [#xC0-#xD6] | [#xD8-#xF6] | [#xF8-#x2FF] |
//                    [#x370-#x37D] | [#x37F-#x1FFF] |
//                    [#x200C-#x200D] | [#x2070-#x218F] |
//                    [#x2C00-#x2FEF] | [#x3001-#xD7FF] |
//                    [#xF900-#xFDCF] | [#xFDF0-#xFFFD] |
//                    [#x10000-#xEFFFF]
//
// NameChar       ::= NameStartChar | "-" | "." | [0-9] |
//                    #xB7 | [#x0300-#x036F] | [#x203F-#x2040]
//
// QName          ::= PrefixedName| UnprefixedName
// PrefixedName   ::= Prefix ':' LocalPart
// UnprefixedName ::= LocalPart
// Prefix         ::= NCName
// LocalPart      ::= NCName
// NCName         ::= Name - (Char* ':' Char*)
//                    # An XML Name, minus the ":"
//

exports.isValidName = isValidName;
exports.isValidQName = isValidQName;

// Most names will be ASCII only. Try matching against simple regexps first
var simplename = /^[_:A-Za-z][-.:\w]+$/;
var simpleqname = /^([_A-Za-z][-.\w]+|[_A-Za-z][-.\w]+:[_A-Za-z][-.\w]+)$/;

// If the regular expressions above fail, try more complex ones that work
// for any identifiers using codepoints from the Unicode BMP
var ncnamestartchars = "_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02ff\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD";
var ncnamechars = "-._A-Za-z0-9\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02ff\u0300-\u037D\u037F-\u1FFF\u200C\u200D\u203f\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD";

var ncname = "[" + ncnamestartchars + "][" + ncnamechars + "]*";
var namestartchars = ncnamestartchars + ":";
var namechars = ncnamechars + ":";
var name = new RegExp("^[" + namestartchars + "]" + "[" + namechars + "]*$");
var qname = new RegExp("^(" + ncname + "|" + ncname + ":" + ncname + ")$");

// XML says that these characters are also legal:
// [#x10000-#xEFFFF].  So if the patterns above fail, and the
// target string includes surrogates, then try the following
// patterns that allow surrogates and then run an extra validation
// step to make sure that the surrogates are in valid pairs and in
// the right range.  Note that since the characters \uf0000 to \u1f0000
// are not allowed, it means that the high surrogate can only go up to
// \uDB7f instead of \uDBFF.
var hassurrogates = /[\uD800-\uDB7F\uDC00-\uDFFF]/;
var surrogatechars = /[\uD800-\uDB7F\uDC00-\uDFFF]/g;
var surrogatepairs = /[\uD800-\uDB7F][\uDC00-\uDFFF]/g;

// Modify the variables above to allow surrogates
ncnamestartchars += "\uD800-\uDB7F\uDC00-\uDFFF";
ncnamechars += "\uD800-\uDB7F\uDC00-\uDFFF";
ncname = "[" + ncnamestartchars + "][" + ncnamechars + "]*";
namestartchars = ncnamestartchars + ":";
namechars = ncnamechars + ":";

// Build another set of regexps that include surrogates
var surrogatename = new RegExp("^[" + namestartchars + "]" + "[" + namechars + "]*$");
var surrogateqname = new RegExp("^(" + ncname + "|" + ncname + ":" + ncname + ")$");

function isValidName(s) {
  if (simplename.test(s)) return true; // Plain ASCII
  if (name.test(s)) return true; // Unicode BMP

  // Maybe the tests above failed because s includes surrogate pairs
  // Most likely, though, they failed for some more basic syntax problem
  if (!hassurrogates.test(s)) return false;

  // Is the string a valid name if we allow surrogates?
  if (!surrogatename.test(s)) return false;

  // Finally, are the surrogates all correctly paired up?
  var chars = s.match(surrogatechars), pairs = s.match(surrogatepairs);
  return pairs !== null && 2*pairs.length === chars.length;
}

function isValidQName(s) {
  if (simpleqname.test(s)) return true; // Plain ASCII
  if (qname.test(s)) return true; // Unicode BMP

  if (!hassurrogates.test(s)) return false;
  if (!surrogateqname.test(s)) return false;
  var chars = s.match(surrogatechars), pairs = s.match(surrogatepairs);
  return pairs !== null && 2*pairs.length === chars.length;
}


/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/* jshint eqnull: true */
/**
 * Zest (https://github.com/chjj/zest)
 * A css selector engine.
 * Copyright (c) 2011-2012, Christopher Jeffrey. (MIT Licensed)
 */

/**
 * Helpers
 */

var window = Object.create(null, {
  location: { get: function() {
    throw new Error('window.location is not supported.');
  } }
});

var compareDocumentPosition = function(a, b) {
      return a.compareDocumentPosition(b);
};

var order = function(a, b) {
  /* jshint bitwise: false */
  return compareDocumentPosition(a, b) & 2 ? 1 : -1;
};

var next = function(el) {
  while ((el = el.nextSibling)
         && el.nodeType !== 1);
  return el;
};

var prev = function(el) {
  while ((el = el.previousSibling)
         && el.nodeType !== 1);
  return el;
};

var child = function(el) {
  /*jshint -W084 */
  if (el = el.firstChild) {
    while (el.nodeType !== 1
           && (el = el.nextSibling));
  }
  return el;
};

var lastChild = function(el) {
  /*jshint -W084 */
  if (el = el.lastChild) {
    while (el.nodeType !== 1
           && (el = el.previousSibling));
  }
  return el;
};

var unquote = function(str) {
  if (!str) return str;
  var ch = str[0];
  if (ch === '"' || ch === '\'') {
    if (str[str.length-1] === ch) {
      str = str.slice(1, -1);
    } else {
      // bad string.
      str = str.slice(1);
    }
    return str.replace(rules.str_escape, function(s) {
      var m = /^\\(?:([0-9A-Fa-f]+)|([\r\n\f]+))/.exec(s);
      if (!m) { return s.slice(1); }
      if (m[2]) { return ''; /* escaped newlines are ignored in strings. */ }
      var cp = parseInt(m[1], 16);
      return String.fromCodePoint ? String.fromCodePoint(cp) :
        // Not all JavaScript implementations have String.fromCodePoint yet.
        String.fromCharCode(cp);
    });
  } else if (rules.ident.test(str)) {
    return decodeid(str);
  } else {
    // NUMBER, PERCENTAGE, DIMENSION, etc
    return str;
  }
};

var decodeid = function(str) {
  return str.replace(rules.escape, function(s) {
    var m = /^\\([0-9A-Fa-f]+)/.exec(s);
    if (!m) { return s[1]; }
    var cp = parseInt(m[1], 16);
    return String.fromCodePoint ? String.fromCodePoint(cp) :
      // Not all JavaScript implementations have String.fromCodePoint yet.
      String.fromCharCode(cp);
  });
};

var indexOf = (function() {
  if (Array.prototype.indexOf) {
    return Array.prototype.indexOf;
  }
  return function(obj, item) {
    var i = this.length;
    while (i--) {
      if (this[i] === item) return i;
    }
    return -1;
  };
})();

var makeInside = function(start, end) {
  var regex = rules.inside.source
    .replace(/</g, start)
    .replace(/>/g, end);

  return new RegExp(regex);
};

var replace = function(regex, name, val) {
  regex = regex.source;
  regex = regex.replace(name, val.source || val);
  return new RegExp(regex);
};

var truncateUrl = function(url, num) {
  return url
    .replace(/^(?:\w+:\/\/|\/+)/, '')
    .replace(/(?:\/+|\/*#.*?)$/, '')
    .split('/', num)
    .join('/');
};

/**
 * Handle `nth` Selectors
 */

var parseNth = function(param_, test) {
  var param = param_.replace(/\s+/g, '')
    , cap;

  if (param === 'even') {
    param = '2n+0';
  } else if (param === 'odd') {
    param = '2n+1';
  } else if (param.indexOf('n') === -1) {
    param = '0n' + param;
  }

  cap = /^([+-])?(\d+)?n([+-])?(\d+)?$/.exec(param);

  return {
    group: cap[1] === '-'
      ? -(cap[2] || 1)
      : +(cap[2] || 1),
    offset: cap[4]
      ? (cap[3] === '-' ? -cap[4] : +cap[4])
      : 0
  };
};

var nth = function(param_, test, last) {
  var param = parseNth(param_)
    , group = param.group
    , offset = param.offset
    , find = !last ? child : lastChild
    , advance = !last ? next : prev;

  return function(el) {
    if (el.parentNode.nodeType !== 1) return;

    var rel = find(el.parentNode)
      , pos = 0;

    while (rel) {
      if (test(rel, el)) pos++;
      if (rel === el) {
        pos -= offset;
        return group && pos
          ? (pos % group) === 0 && (pos < 0 === group < 0)
          : !pos;
      }
      rel = advance(rel);
    }
  };
};

/**
 * Simple Selectors
 */

var selectors = {
  '*': (function() {
    if (false/*function() {
      var el = document.createElement('div');
      el.appendChild(document.createComment(''));
      return !!el.getElementsByTagName('*')[0];
    }()*/) {
      return function(el) {
        if (el.nodeType === 1) return true;
      };
    }
    return function() {
      return true;
    };
  })(),
  'type': function(type) {
    type = type.toLowerCase();
    return function(el) {
      return el.nodeName.toLowerCase() === type;
    };
  },
  'attr': function(key, op, val, i) {
    op = operators[op];
    return function(el) {
      var attr;
      switch (key) {
        case 'for':
          attr = el.htmlFor;
          break;
        case 'class':
          // className is '' when non-existent
          // getAttribute('class') is null
          attr = el.className;
          if (attr === '' && el.getAttribute('class') == null) {
            attr = null;
          }
          break;
        case 'href':
          attr = el.getAttribute('href', 2);
          break;
        case 'title':
          // getAttribute('title') can be '' when non-existent sometimes?
          attr = el.getAttribute('title') || null;
          break;
        // careful with attributes with special getter functions
        case 'id':
        case 'lang':
        case 'dir':
        case 'accessKey':
        case 'hidden':
        case 'tabIndex':
        case 'style':
          if (el.getAttribute) {
            attr = el.getAttribute(key);
            break;
          }
        /* falls through */
        default:
          if (el.hasAttribute && !el.hasAttribute(key)) {
            break;
          }
          attr = el[key] != null
            ? el[key]
            : el.getAttribute && el.getAttribute(key);
          break;
      }
      if (attr == null) return;
      attr = attr + '';
      if (i) {
        attr = attr.toLowerCase();
        val = val.toLowerCase();
      }
      return op(attr, val);
    };
  },
  ':first-child': function(el) {
    return !prev(el) && el.parentNode.nodeType === 1;
  },
  ':last-child': function(el) {
    return !next(el) && el.parentNode.nodeType === 1;
  },
  ':only-child': function(el) {
    return !prev(el) && !next(el)
      && el.parentNode.nodeType === 1;
  },
  ':nth-child': function(param, last) {
    return nth(param, function() {
      return true;
    }, last);
  },
  ':nth-last-child': function(param) {
    return selectors[':nth-child'](param, true);
  },
  ':root': function(el) {
    return el.ownerDocument.documentElement === el;
  },
  ':empty': function(el) {
    return !el.firstChild;
  },
  ':not': function(sel) {
    var test = compileGroup(sel);
    return function(el) {
      return !test(el);
    };
  },
  ':first-of-type': function(el) {
    if (el.parentNode.nodeType !== 1) return;
    var type = el.nodeName;
    /*jshint -W084 */
    while (el = prev(el)) {
      if (el.nodeName === type) return;
    }
    return true;
  },
  ':last-of-type': function(el) {
    if (el.parentNode.nodeType !== 1) return;
    var type = el.nodeName;
    /*jshint -W084 */
    while (el = next(el)) {
      if (el.nodeName === type) return;
    }
    return true;
  },
  ':only-of-type': function(el) {
    return selectors[':first-of-type'](el)
        && selectors[':last-of-type'](el);
  },
  ':nth-of-type': function(param, last) {
    return nth(param, function(rel, el) {
      return rel.nodeName === el.nodeName;
    }, last);
  },
  ':nth-last-of-type': function(param) {
    return selectors[':nth-of-type'](param, true);
  },
  ':checked': function(el) {
    return !!(el.checked || el.selected);
  },
  ':indeterminate': function(el) {
    return !selectors[':checked'](el);
  },
  ':enabled': function(el) {
    return !el.disabled && el.type !== 'hidden';
  },
  ':disabled': function(el) {
    return !!el.disabled;
  },
  ':target': function(el) {
    return el.id === window.location.hash.substring(1);
  },
  ':focus': function(el) {
    return el === el.ownerDocument.activeElement;
  },
  ':matches': function(sel) {
    return compileGroup(sel);
  },
  ':nth-match': function(param, last) {
    var args = param.split(/\s*,\s*/)
      , arg = args.shift()
      , test = compileGroup(args.join(','));

    return nth(arg, test, last);
  },
  ':nth-last-match': function(param) {
    return selectors[':nth-match'](param, true);
  },
  ':links-here': function(el) {
    return el + '' === window.location + '';
  },
  ':lang': function(param) {
    return function(el) {
      while (el) {
        if (el.lang) return el.lang.indexOf(param) === 0;
        el = el.parentNode;
      }
    };
  },
  ':dir': function(param) {
    return function(el) {
      while (el) {
        if (el.dir) return el.dir === param;
        el = el.parentNode;
      }
    };
  },
  ':scope': function(el, con) {
    var context = con || el.ownerDocument;
    if (context.nodeType === 9) {
      return el === context.documentElement;
    }
    return el === context;
  },
  ':any-link': function(el) {
    return typeof el.href === 'string';
  },
  ':local-link': function(el) {
    if (el.nodeName) {
      return el.href && el.host === window.location.host;
    }
    var param = +el + 1;
    return function(el) {
      if (!el.href) return;

      var url = window.location + ''
        , href = el + '';

      return truncateUrl(url, param) === truncateUrl(href, param);
    };
  },
  ':default': function(el) {
    return !!el.defaultSelected;
  },
  ':valid': function(el) {
    return el.willValidate || (el.validity && el.validity.valid);
  },
  ':invalid': function(el) {
    return !selectors[':valid'](el);
  },
  ':in-range': function(el) {
    return el.value > el.min && el.value <= el.max;
  },
  ':out-of-range': function(el) {
    return !selectors[':in-range'](el);
  },
  ':required': function(el) {
    return !!el.required;
  },
  ':optional': function(el) {
    return !el.required;
  },
  ':read-only': function(el) {
    if (el.readOnly) return true;

    var attr = el.getAttribute('contenteditable')
      , prop = el.contentEditable
      , name = el.nodeName.toLowerCase();

    name = name !== 'input' && name !== 'textarea';

    return (name || el.disabled) && attr == null && prop !== 'true';
  },
  ':read-write': function(el) {
    return !selectors[':read-only'](el);
  },
  ':hover': function() {
    throw new Error(':hover is not supported.');
  },
  ':active': function() {
    throw new Error(':active is not supported.');
  },
  ':link': function() {
    throw new Error(':link is not supported.');
  },
  ':visited': function() {
    throw new Error(':visited is not supported.');
  },
  ':column': function() {
    throw new Error(':column is not supported.');
  },
  ':nth-column': function() {
    throw new Error(':nth-column is not supported.');
  },
  ':nth-last-column': function() {
    throw new Error(':nth-last-column is not supported.');
  },
  ':current': function() {
    throw new Error(':current is not supported.');
  },
  ':past': function() {
    throw new Error(':past is not supported.');
  },
  ':future': function() {
    throw new Error(':future is not supported.');
  },
  // Non-standard, for compatibility purposes.
  ':contains': function(param) {
    return function(el) {
      var text = el.innerText || el.textContent || el.value || '';
      return text.indexOf(param) !== -1;
    };
  },
  ':has': function(param) {
    return function(el) {
      return find(param, el).length > 0;
    };
  }
  // Potentially add more pseudo selectors for
  // compatibility with sizzle and most other
  // selector engines (?).
};

/**
 * Attribute Operators
 */

var operators = {
  '-': function() {
    return true;
  },
  '=': function(attr, val) {
    return attr === val;
  },
  '*=': function(attr, val) {
    return attr.indexOf(val) !== -1;
  },
  '~=': function(attr, val) {
    var i = attr.indexOf(val)
      , f
      , l;

    if (i === -1) return;
    f = attr[i - 1];
    l = attr[i + val.length];

    return (!f || f === ' ') && (!l || l === ' ');
  },
  '|=': function(attr, val) {
    var i = attr.indexOf(val)
      , l;

    if (i !== 0) return;
    l = attr[i + val.length];

    return l === '-' || !l;
  },
  '^=': function(attr, val) {
    return attr.indexOf(val) === 0;
  },
  '$=': function(attr, val) {
    return attr.indexOf(val) + val.length === attr.length;
  },
  // non-standard
  '!=': function(attr, val) {
    return attr !== val;
  }
};

/**
 * Combinator Logic
 */

var combinators = {
  ' ': function(test) {
    return function(el) {
      /*jshint -W084 */
      while (el = el.parentNode) {
        if (test(el)) return el;
      }
    };
  },
  '>': function(test) {
    return function(el) {
      /*jshint -W084 */
      if (el = el.parentNode) {
        return test(el) && el;
      }
    };
  },
  '+': function(test) {
    return function(el) {
      /*jshint -W084 */
      if (el = prev(el)) {
        return test(el) && el;
      }
    };
  },
  '~': function(test) {
    return function(el) {
      /*jshint -W084 */
      while (el = prev(el)) {
        if (test(el)) return el;
      }
    };
  },
  'noop': function(test) {
    return function(el) {
      return test(el) && el;
    };
  },
  'ref': function(test, name) {
    var node;

    function ref(el) {
      var doc = el.ownerDocument
        , nodes = doc.getElementsByTagName('*')
        , i = nodes.length;

      while (i--) {
        node = nodes[i];
        if (ref.test(el)) {
          node = null;
          return true;
        }
      }

      node = null;
    }

    ref.combinator = function(el) {
      if (!node || !node.getAttribute) return;

      var attr = node.getAttribute(name) || '';
      if (attr[0] === '#') attr = attr.substring(1);

      if (attr === el.id && test(node)) {
        return node;
      }
    };

    return ref;
  }
};

/**
 * Grammar
 */

var rules = {
  escape: /\\(?:[^0-9A-Fa-f\r\n]|[0-9A-Fa-f]{1,6}[\r\n\t ]?)/g,
  str_escape: /(escape)|\\(\n|\r\n?|\f)/g,
  nonascii: /[\u00A0-\uFFFF]/,
  cssid: /(?:(?!-?[0-9])(?:escape|nonascii|[-_a-zA-Z0-9])+)/,
  qname: /^ *(cssid|\*)/,
  simple: /^(?:([.#]cssid)|pseudo|attr)/,
  ref: /^ *\/(cssid)\/ */,
  combinator: /^(?: +([^ \w*.#\\]) +|( )+|([^ \w*.#\\]))(?! *$)/,
  attr: /^\[(cssid)(?:([^\w]?=)(inside))?\]/,
  pseudo: /^(:cssid)(?:\((inside)\))?/,
  inside: /(?:"(?:\\"|[^"])*"|'(?:\\'|[^'])*'|<[^"'>]*>|\\["'>]|[^"'>])*/,
  ident: /^(cssid)$/
};

rules.cssid = replace(rules.cssid, 'nonascii', rules.nonascii);
rules.cssid = replace(rules.cssid, 'escape', rules.escape);
rules.qname = replace(rules.qname, 'cssid', rules.cssid);
rules.simple = replace(rules.simple, 'cssid', rules.cssid);
rules.ref = replace(rules.ref, 'cssid', rules.cssid);
rules.attr = replace(rules.attr, 'cssid', rules.cssid);
rules.pseudo = replace(rules.pseudo, 'cssid', rules.cssid);
rules.inside = replace(rules.inside, '[^"\'>]*', rules.inside);
rules.attr = replace(rules.attr, 'inside', makeInside('\\[', '\\]'));
rules.pseudo = replace(rules.pseudo, 'inside', makeInside('\\(', '\\)'));
rules.simple = replace(rules.simple, 'pseudo', rules.pseudo);
rules.simple = replace(rules.simple, 'attr', rules.attr);
rules.ident = replace(rules.ident, 'cssid', rules.cssid);
rules.str_escape = replace(rules.str_escape, 'escape', rules.escape);

/**
 * Compiling
 */

var compile = function(sel_) {
  var sel = sel_.replace(/^\s+|\s+$/g, '')
    , test
    , filter = []
    , buff = []
    , subject
    , qname
    , cap
    , op
    , ref;

  /*jshint -W084 */
  while (sel) {
    if (cap = rules.qname.exec(sel)) {
      sel = sel.substring(cap[0].length);
      qname = cap[1];
      buff.push(tok(qname, true));
    } else if (cap = rules.simple.exec(sel)) {
      sel = sel.substring(cap[0].length);
      qname = '*';
      buff.push(tok(qname, true));
      buff.push(tok(cap));
    } else {
      throw new SyntaxError('Invalid selector.');
    }

    while (cap = rules.simple.exec(sel)) {
      sel = sel.substring(cap[0].length);
      buff.push(tok(cap));
    }

    if (sel[0] === '!') {
      sel = sel.substring(1);
      subject = makeSubject();
      subject.qname = qname;
      buff.push(subject.simple);
    }

    if (cap = rules.ref.exec(sel)) {
      sel = sel.substring(cap[0].length);
      ref = combinators.ref(makeSimple(buff), decodeid(cap[1]));
      filter.push(ref.combinator);
      buff = [];
      continue;
    }

    if (cap = rules.combinator.exec(sel)) {
      sel = sel.substring(cap[0].length);
      op = cap[1] || cap[2] || cap[3];
      if (op === ',') {
        filter.push(combinators.noop(makeSimple(buff)));
        break;
      }
    } else {
      op = 'noop';
    }

    if (!combinators[op]) { throw new SyntaxError('Bad combinator.'); }
    filter.push(combinators[op](makeSimple(buff)));
    buff = [];
  }

  test = makeTest(filter);
  test.qname = qname;
  test.sel = sel;

  if (subject) {
    subject.lname = test.qname;

    subject.test = test;
    subject.qname = subject.qname;
    subject.sel = test.sel;
    test = subject;
  }

  if (ref) {
    ref.test = test;
    ref.qname = test.qname;
    ref.sel = test.sel;
    test = ref;
  }

  return test;
};

var tok = function(cap, qname) {
  // qname
  if (qname) {
    return cap === '*'
      ? selectors['*']
      : selectors.type(decodeid(cap));
  }

  // class/id
  if (cap[1]) {
    return cap[1][0] === '.'
	  // XXX unescape here?  or in attr?
      ? selectors.attr('class', '~=', decodeid(cap[1].substring(1)))
      : selectors.attr('id', '=', decodeid(cap[1].substring(1)));
  }

  // pseudo-name
  // inside-pseudo
  if (cap[2]) {
    return cap[3]
      ? selectors[decodeid(cap[2])](unquote(cap[3]))
      : selectors[decodeid(cap[2])];
  }

  // attr name
  // attr op
  // attr value
  if (cap[4]) {
    return selectors.attr(decodeid(cap[4]), cap[5] || '-', unquote(cap[6]), false);
  }

  throw new SyntaxError('Unknown Selector.');
};

var makeSimple = function(func) {
  var l = func.length
    , i;

  // Potentially make sure
  // `el` is truthy.
  if (l < 2) return func[0];

  return function(el) {
    if (!el) return;
    for (i = 0; i < l; i++) {
      if (!func[i](el)) return;
    }
    return true;
  };
};

var makeTest = function(func) {
  if (func.length < 2) {
    return function(el) {
      return !!func[0](el);
    };
  }
  return function(el) {
    var i = func.length;
    while (i--) {
      if (!(el = func[i](el))) return;
    }
    return true;
  };
};

var makeSubject = function() {
  var target;

  function subject(el) {
    var node = el.ownerDocument
      , scope = node.getElementsByTagName(subject.lname)
      , i = scope.length;

    while (i--) {
      if (subject.test(scope[i]) && target === el) {
        target = null;
        return true;
      }
    }

    target = null;
  }

  subject.simple = function(el) {
    target = el;
    return true;
  };

  return subject;
};

var compileGroup = function(sel) {
  var test = compile(sel)
    , tests = [ test ];

  while (test.sel) {
    test = compile(test.sel);
    tests.push(test);
  }

  if (tests.length < 2) return test;

  return function(el) {
    var l = tests.length
      , i = 0;

    for (; i < l; i++) {
      if (tests[i](el)) return true;
    }
  };
};

/**
 * Selection
 */

var find = function(sel, node) {
  var results = []
    , test = compile(sel)
    , scope = node.getElementsByTagName(test.qname)
    , i = 0
    , el;

  /*jshint -W084 */
  while (el = scope[i++]) {
    if (test(el)) results.push(el);
  }

  if (test.sel) {
    while (test.sel) {
      test = compile(test.sel);
      scope = node.getElementsByTagName(test.qname);
      i = 0;
      /*jshint -W084 */
      while (el = scope[i++]) {
        if (test(el) && indexOf.call(results, el) === -1) {
          results.push(el);
        }
      }
    }
    results.sort(order);
  }

  return results;
};

/**
 * Expose
 */

module.exports = exports = function(sel, context) {
  /* when context isn't a DocumentFragment and the selector is simple: */
  var id, r;
  if (context.nodeType !== 11 && sel.indexOf(' ') === -1) {
    if (sel[0] === '#' && context.rooted && /^#[A-Z_][-A-Z0-9_]*$/i.test(sel)) {
      if (context.doc._hasMultipleElementsWithId) {
        id = sel.substring(1);
        if (!context.doc._hasMultipleElementsWithId(id)) {
          r = context.doc.getElementById(id);
          return r ? [r] : [];
        }
      }
    }
    if (sel[0] === '.' && /^\.\w+$/.test(sel)) {
      return context.getElementsByClassName(sel.substring(1));
    }
    if (/^\w+$/.test(sel)) {
      return context.getElementsByTagName(sel);
    }
  }
  /* do things the hard/slow way */
  return find(sel, context);
};

exports.selectors = selectors;
exports.operators = operators;
exports.combinators = combinators;

exports.matches = function(el, sel) {
  var test = { sel: sel };
  do {
    test = compile(test.sel);
    if (test(el)) { return true; }
  } while (test.sel);
  return false;
};


/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Node = __webpack_require__(4);

var createDocumentFragmentFromArguments = function(document, args) {
  var docFrag = document.createDocumentFragment();

  for (var i=0; i<args.length; i++) {
    var argItem = args[i];
    var isNode = argItem instanceof Node;
    docFrag.appendChild(isNode ? argItem :
                        document.createTextNode(String(argItem)));
  }

  return docFrag;
};

// The ChildNode interface contains methods that are particular to `Node`
// objects that can have a parent.  It is implemented by `Element`,
// `DocumentType`, and `CharacterData` objects.
var ChildNode = {

  // Inserts a set of Node or String objects in the children list of this
  // ChildNode's parent, just after this ChildNode.  String objects are
  // inserted as the equivalent Text nodes.
  after: { value: function after() {
    var argArr = Array.prototype.slice.call(arguments);
    var parentNode = this.parentNode, nextSibling = this.nextSibling;
    if (parentNode === null) { return; }
    // Find "viable next sibling"; that is, next one not in argArr
    while (nextSibling && argArr.some(function(v) { return v===nextSibling; }))
      nextSibling = nextSibling.nextSibling;
    // ok, parent and sibling are saved away since this node could itself
    // appear in argArr and we're about to move argArr to a document fragment.
    var docFrag = createDocumentFragmentFromArguments(this.doc, argArr);

    parentNode.insertBefore(docFrag, nextSibling);
  }},

  // Inserts a set of Node or String objects in the children list of this
  // ChildNode's parent, just before this ChildNode.  String objects are
  // inserted as the equivalent Text nodes.
  before: { value: function before() {
    var argArr = Array.prototype.slice.call(arguments);
    var parentNode = this.parentNode, prevSibling = this.previousSibling;
    if (parentNode === null) { return; }
    // Find "viable prev sibling"; that is, prev one not in argArr
    while (prevSibling && argArr.some(function(v) { return v===prevSibling; }))
      prevSibling = prevSibling.previousSibling;
    // ok, parent and sibling are saved away since this node could itself
    // appear in argArr and we're about to move argArr to a document fragment.
    var docFrag = createDocumentFragmentFromArguments(this.doc, argArr);

    var nextSibling =
        prevSibling ? prevSibling.nextSibling : parentNode.firstChild;
    parentNode.insertBefore(docFrag, nextSibling);
  }},

  // Remove this node from its parent
  remove: { value: function remove() {
    if (this.parentNode === null) return;

    // Send mutation events if necessary
    if (this.rooted && this.doc) this.doc.mutateRemove(this);

    // Remove this node from its parents array of children
    this.parentNode.childNodes.splice(this.index, 1);

    // Update the structure id for all ancestors
    this.parentNode.modify();

    // Forget this node's parent
    this.parentNode = null;
  }},

  // Replace this node with the nodes or strings provided as arguments.
  replaceWith: { value: function replaceWith() {
    var argArr = Array.prototype.slice.call(arguments);
    var parentNode = this.parentNode, nextSibling = this.nextSibling;
    if (parentNode === null) { return; }
    // Find "viable next sibling"; that is, next one not in argArr
    while (nextSibling && argArr.some(function(v) { return v===nextSibling; }))
      nextSibling = nextSibling.nextSibling;
    // ok, parent and sibling are saved away since this node could itself
    // appear in argArr and we're about to move argArr to a document fragment.
    var docFrag = createDocumentFragmentFromArguments(this.doc, argArr);
    if (this.parentNode === parentNode) {
      parentNode.replaceChild(docFrag, this);
    } else {
      // `this` was inserted into docFrag
      parentNode.insertBefore(docFrag, nextSibling);
    }
  }},

};

module.exports = ChildNode;


/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = URL;

function URL(url) {
  if (!url) return Object.create(URL.prototype);
  // Can't use String.trim() since it defines whitespace differently than HTML
  this.url = url.replace(/^[ \t\n\r\f]+|[ \t\n\r\f]+$/g, "");

  // See http://tools.ietf.org/html/rfc3986#appendix-B
  // and https://url.spec.whatwg.org/#parsing
  var match = URL.pattern.exec(this.url);
  if (match) {
    if (match[2]) this.scheme = match[2];
    if (match[4]) {
      // parse username/password
      var userinfo = match[4].match(URL.userinfoPattern);
      if (userinfo) {
        this.username = userinfo[1];
        this.password = userinfo[3];
        match[4] = match[4].substring(userinfo[0].length);
      }
      if (match[4].match(URL.portPattern)) {
        var pos = match[4].lastIndexOf(':');
        this.host = match[4].substring(0, pos);
        this.port = match[4].substring(pos+1);
      }
      else {
        this.host = match[4];
      }
    }
    if (match[5]) this.path = match[5];
    if (match[6]) this.query = match[7];
    if (match[8]) this.fragment = match[9];
  }
}

URL.pattern = /^(([^:\/?#]+):)?(\/\/([^\/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?$/;
URL.userinfoPattern = /^([^@:]*)(:([^@]*))?@/;
URL.portPattern = /:\d+$/;
URL.authorityPattern = /^[^:\/?#]+:\/\//;
URL.hierarchyPattern = /^[^:\/?#]+:\//;

// Return a percentEncoded version of s.
// S should be a single-character string
// XXX: needs to do utf-8 encoding?
URL.percentEncode = function percentEncode(s) {
  var c = s.charCodeAt(0);
  if (c < 256) return "%" + c.toString(16);
  else throw Error("can't percent-encode codepoints > 255 yet");
};

URL.prototype = {
  constructor: URL,

  // XXX: not sure if this is the precise definition of absolute
  isAbsolute: function() { return !!this.scheme; },
  isAuthorityBased: function() {
    return URL.authorityPattern.test(this.url);
  },
  isHierarchical: function() {
    return URL.hierarchyPattern.test(this.url);
  },

  toString: function() {
    var s = "";
    if (this.scheme !== undefined) s += this.scheme + ":";
    if (this.isAbsolute()) {
      s += '//';
      if (this.username || this.password) {
        s += this.username || '';
        if (this.password) {
          s += ':' + this.password;
        }
        s += '@';
      }
      s += this.host;
    }
    if (this.port !== undefined) s += ":" + this.port;
    if (this.path !== undefined) s += this.path;
    if (this.query !== undefined) s += "?" + this.query;
    if (this.fragment !== undefined) s += "#" + this.fragment;
    return s;
  },

  // See: http://tools.ietf.org/html/rfc3986#section-5.2
  // and https://url.spec.whatwg.org/#constructors
  resolve: function(relative) {
    var base = this;           // The base url we're resolving against
    var r = new URL(relative); // The relative reference url to resolve
    var t = new URL();         // The absolute target url we will return

    if (r.scheme !== undefined) {
      t.scheme = r.scheme;
      t.username = r.username;
      t.password = r.password;
      t.host = r.host;
      t.port = r.port;
      t.path = remove_dot_segments(r.path);
      t.query = r.query;
    }
    else {
      t.scheme = base.scheme;
      if (r.host !== undefined) {
        t.username = r.username;
        t.password = r.password;
        t.host = r.host;
        t.port = r.port;
        t.path = remove_dot_segments(r.path);
        t.query = r.query;
      }
      else {
        t.username = base.username;
        t.password = base.password;
        t.host = base.host;
        t.port = base.port;
        if (!r.path) { // undefined or empty
          t.path = base.path;
          if (r.query !== undefined)
            t.query = r.query;
          else
            t.query = base.query;
        }
        else {
          if (r.path.charAt(0) === "/") {
            t.path = remove_dot_segments(r.path);
          }
          else {
            t.path = merge(base.path, r.path);
            t.path = remove_dot_segments(t.path);
          }
          t.query = r.query;
        }
      }
    }
    t.fragment = r.fragment;

    return t.toString();


    function merge(basepath, refpath) {
      if (base.host !== undefined && !base.path)
        return "/" + refpath;

      var lastslash = basepath.lastIndexOf("/");
      if (lastslash === -1)
        return refpath;
      else
        return basepath.substring(0, lastslash+1) + refpath;
    }

    function remove_dot_segments(path) {
      if (!path) return path; // For "" or undefined

      var output = "";
      while(path.length > 0) {
        if (path === "." || path === "..") {
          path = "";
          break;
        }

        var twochars = path.substring(0,2);
        var threechars = path.substring(0,3);
        var fourchars = path.substring(0,4);
        if (threechars === "../") {
          path = path.substring(3);
        }
        else if (twochars === "./") {
          path = path.substring(2);
        }
        else if (threechars === "/./") {
          path = "/" + path.substring(3);
        }
        else if (twochars === "/." && path.length === 2) {
          path = "/";
        }
        else if (fourchars === "/../" ||
             (threechars === "/.." && path.length === 3)) {
          path = "/" + path.substring(4);

          output = output.replace(/\/?[^\/]*$/, "");
        }
        else {
          var segment = path.match(/(\/?([^\/]*))/)[0];
          output += segment;
          path = path.substring(segment.length);
        }
      }

      return output;
    }
  },
};


/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Node = __webpack_require__(4);
var Element = __webpack_require__(9);
var CSSStyleDeclaration = __webpack_require__(26);
var utils = __webpack_require__(3);
var URLUtils = __webpack_require__(56);
var defineElement = __webpack_require__(57);

var htmlElements = exports.elements = {};
var htmlNameToImpl = Object.create(null);

exports.createElement = function(doc, localName, prefix) {
  var impl = htmlNameToImpl[localName] || HTMLUnknownElement;
  return new impl(doc, localName, prefix);
};

function define(spec) {
  return defineElement(spec, HTMLElement, htmlElements, htmlNameToImpl);
}

function URL(attr) {
  return {
    get: function() {
      var v = this._getattr(attr);
      if (v === null) { return ''; }
      var url = this.doc._resolve(v);
      return (url === null) ? v : url;
    },
    set: function(value) {
      this._setattr(attr, value);
    }
  };
}

function CORS(attr) {
  return {
    get: function() {
      var v = this._getattr(attr);
      if (v === null) { return null; }
      if (v.toLowerCase() === 'use-credentials') { return 'use-credentials'; }
      return 'anonymous';
    },
    set: function(value) {
      if (value===null || value===undefined) {
        this.removeAttribute(attr);
      } else {
        this._setattr(attr, value);
      }
    }
  };
}

var REFERRER = {
  type: ["", "no-referrer", "no-referrer-when-downgrade", "same-origin", "origin", "strict-origin", "origin-when-cross-origin", "strict-origin-when-cross-origin", "unsafe-url"],
  missing: '',
};


// XXX: the default value for tabIndex should be 0 if the element is
// focusable and -1 if it is not.  But the full definition of focusable
// is actually hard to compute, so for now, I'll follow Firefox and
// just base the default value on the type of the element.
var focusableElements = {
  "A":true, "LINK":true, "BUTTON":true, "INPUT":true,
  "SELECT":true, "TEXTAREA":true, "COMMAND":true
};

var HTMLElement = exports.HTMLElement = define({
  superclass: Element,
  ctor: function HTMLElement(doc, localName, prefix) {
    Element.call(this, doc, localName, utils.NAMESPACE.HTML, prefix);
  },
  props: {
    innerHTML: {
      get: function() {
        return this.serialize();
      },
      set: function(v) {
        var parser = this.ownerDocument.implementation.mozHTMLParser(
          this.ownerDocument._address,
          this);
        parser.parse(v, true);
        var tmpdoc = parser.document();
        var root = tmpdoc.firstChild;
        var target = (this instanceof htmlNameToImpl.template) ?
            this.content : this;

        // Remove any existing children of this node
        while(target.hasChildNodes())
          target.removeChild(target.firstChild);

        // Now copy newly parsed children from the root to this node
        target.doc.adoptNode(root);
        while(root.hasChildNodes()) {
          target.appendChild(root.firstChild);
        }
      }
    },
    style: { get: function() {
      if (!this._style)
        this._style = new CSSStyleDeclaration(this);
      return this._style;
    }},

    click: { value: function() {
      if (this._click_in_progress) return;
      this._click_in_progress = true;
      try {
        if (this._pre_click_activation_steps)
          this._pre_click_activation_steps();

        var event = this.ownerDocument.createEvent("MouseEvent");
        event.initMouseEvent("click", true, true,
          this.ownerDocument.defaultView, 1,
          0, 0, 0, 0,
          // These 4 should be initialized with
          // the actually current keyboard state
          // somehow...
          false, false, false, false,
          0, null
        );

        // Dispatch this as an untrusted event since it is synthetic
        var success = this.dispatchEvent(event);

        if (success) {
          if (this._post_click_activation_steps)
            this._post_click_activation_steps(event);
        }
        else {
          if (this._cancelled_activation_steps)
            this._cancelled_activation_steps();
        }
      }
      finally {
        this._click_in_progress = false;
      }
    }}
  },
  attributes: {
    title: String,
    lang: String,
    dir: {type: ["ltr", "rtl", "auto"], missing: ''},
    accessKey: String,
    hidden: Boolean,
    tabIndex: {type: "long", default: function() {
      if (this.tagName in focusableElements ||
        this.contentEditable)
        return 0;
      else
        return -1;
    }}
  },
  events: [
    "abort", "canplay", "canplaythrough", "change", "click", "contextmenu",
    "cuechange", "dblclick", "drag", "dragend", "dragenter", "dragleave",
    "dragover", "dragstart", "drop", "durationchange", "emptied", "ended",
    "input", "invalid", "keydown", "keypress", "keyup", "loadeddata",
    "loadedmetadata", "loadstart", "mousedown", "mousemove", "mouseout",
    "mouseover", "mouseup", "mousewheel", "pause", "play", "playing",
    "progress", "ratechange", "readystatechange", "reset", "seeked",
    "seeking", "select", "show", "stalled", "submit", "suspend",
    "timeupdate", "volumechange", "waiting",

    // These last 5 event types will be overriden by HTMLBodyElement
    "blur", "error", "focus", "load", "scroll"
  ]
});


// XXX: reflect contextmenu as contextMenu, with element type


// style: the spec doesn't call this a reflected attribute.
//   may want to handle it manually.

// contentEditable: enumerated, not clear if it is actually
// reflected or requires custom getter/setter. Not listed as
// "limited to known values".  Raises syntax_err on bad setting,
// so I think this is custom.

// contextmenu: content is element id, idl type is an element
// draggable: boolean, but not a reflected attribute
// dropzone: reflected SettableTokenList, experimental, so don't
//   implement it right away.

// data-* attributes: need special handling in setAttribute?
// Or maybe that isn't necessary. Can I just scan the attribute list
// when building the dataset?  Liveness and caching issues?

// microdata attributes: many are simple reflected attributes, but
// I'm not going to implement this now.


var HTMLUnknownElement = define({
  ctor: function HTMLUnknownElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  }
});


var formAssociatedProps = {
  // See http://www.w3.org/TR/html5/association-of-controls-and-forms.html#form-owner
  form: { get: function() {
    return this._form;
  }}
};

define({
  tag: 'a',
  ctor: function HTMLAnchorElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  props: {
    _post_click_activation_steps: { value: function(e) {
      if (this.href) {
        // Follow the link
        // XXX: this is just a quick hack
        // XXX: the HTML spec probably requires more than this
        this.ownerDocument.defaultView.location = this.href;
      }
    }},
    blur: { value: function() {}},
    focus: { value: function() {}}
  },
  attributes: {
    href: URL,
    ping: String,
    download: String,
    target: String,
    rel: String,
    media: String,
    hreflang: String,
    type: String,
    referrerPolicy: REFERRER,
    // Obsolete
    coords: String,
    charset: String,
    name: String,
    rev: String,
    shape: String,
  }
});
URLUtils._inherit(htmlNameToImpl.a.prototype);

define({
  tag: 'area',
  ctor: function HTMLAreaElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  attributes: {
    alt: String,
    target: String,
    download: String,
    rel: String,
    media: String,
    href: URL,
    hreflang: String,
    type: String,
    shape: String,
    coords: String,
    ping: String,
    // XXX: also reflect relList
    referrerPolicy: REFERRER,
    // Obsolete
    noHref: Boolean,
  }
});

define({
  tag: 'br',
  ctor: function HTMLBRElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  attributes: {
    // Obsolete
    clear: String
  },
});

define({
  tag: 'base',
  ctor: function HTMLBaseElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  attributes: {
    "target": String
  }
});


define({
  tag: 'body',
  ctor: function HTMLBodyElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  // Certain event handler attributes on a <body> tag actually set
  // handlers for the window rather than just that element.  Define
  // getters and setters for those here.  Note that some of these override
  // properties on HTMLElement.prototype.
  // XXX: If I add support for <frameset>, these have to go there, too
  // XXX
  // When the Window object is implemented, these attribute will have
  // to work with the same-named attributes on the Window.
  events: [
    "afterprint", "beforeprint", "beforeunload", "blur", "error",
    "focus","hashchange", "load", "message", "offline", "online",
    "pagehide", "pageshow","popstate","resize","scroll","storage","unload",
  ],
  attributes: {
    // Obsolete
    text: { type: String, treatNullAsEmptyString: true },
    link: { type: String, treatNullAsEmptyString: true },
    vLink: { type: String, treatNullAsEmptyString: true },
    aLink: { type: String, treatNullAsEmptyString: true },
    bgColor: { type: String, treatNullAsEmptyString: true },
    background: String,
  }
});

define({
  tag: 'button',
  ctor: function HTMLButtonElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  props: formAssociatedProps,
  attributes: {
    name: String,
    value: String,
    disabled: Boolean,
    autofocus: Boolean,
    type: { type:["submit", "reset", "button", "menu"], missing: 'submit' },
    formTarget: String,
    formNoValidate: Boolean,
    formMethod: { type: ["get", "post", "dialog"], invalid: 'get', missing: '' },
    formEnctype: { type: ["application/x-www-form-urlencoded", "multipart/form-data", "text/plain"], invalid: "application/x-www-form-urlencoded", missing: '' },
  }
});

define({
  tag: 'dl',
  ctor: function HTMLDListElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  attributes: {
    // Obsolete
    compact: Boolean,
  }
});

define({
  tag: 'data',
  ctor: function HTMLDataElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  attributes: {
    value: String,
  }
});

define({
  tag: 'datalist',
  ctor: function HTMLDataListElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  }
});

define({
  tag: 'details',
  ctor: function HTMLDetailsElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  attributes: {
    "open": Boolean
  }
});

define({
  tag: 'div',
  ctor: function HTMLDivElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  attributes: {
    // Obsolete
    align: String
  }
});

define({
  tag: 'embed',
  ctor: function HTMLEmbedElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  attributes: {
    src: URL,
    type: String,
    width: String,
    height: String,
    // Obsolete
    align: String,
    name: String,
  }
});

define({
  tag: 'fieldset',
  ctor: function HTMLFieldSetElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  props: formAssociatedProps,
  attributes: {
    disabled: Boolean,
    name: String
  }
});

define({
  tag: 'form',
  ctor: function HTMLFormElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  attributes: {
    action: String,
    autocomplete: {type:['on', 'off'], missing: 'on'},
    name: String,
    acceptCharset: {name: "accept-charset"},
    target: String,
    noValidate: Boolean,
    method: { type: ["get", "post", "dialog"], invalid: 'get', missing: 'get' },
    // Both enctype and encoding reflect the enctype content attribute
    enctype: { type: ["application/x-www-form-urlencoded", "multipart/form-data", "text/plain"], invalid: "application/x-www-form-urlencoded", missing: "application/x-www-form-urlencoded" },
    encoding: {name: 'enctype', type: ["application/x-www-form-urlencoded", "multipart/form-data", "text/plain"], invalid: "application/x-www-form-urlencoded", missing: "application/x-www-form-urlencoded" },
  }
});

define({
  tag: 'hr',
  ctor: function HTMLHRElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  attributes: {
    // Obsolete
    align: String,
    color: String,
    noShade: Boolean,
    size: String,
    width: String,
  },
});

define({
  tag: 'head',
  ctor: function HTMLHeadElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  }
});

define({
  tags: ['h1','h2','h3','h4','h5','h6'],
  ctor: function HTMLHeadingElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  attributes: {
    // Obsolete
    align: String,
  },
});

define({
  tag: 'html',
  ctor: function HTMLHtmlElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  attributes: {
    // Obsolete
    version: String
  }
});

define({
  tag: 'iframe',
  ctor: function HTMLIFrameElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
    var Window = __webpack_require__(27); // Avoid circular dependencies.
    this._contentWindow = new Window();
  },
  props: {
    contentWindow: { get: function() {
      return this._contentWindow;
    } },
    contentDocument: { get: function() {
      return this.contentWindow.document;
    } },
  },
  attributes: {
    src: URL,
    srcdoc: String,
    name: String,
    width: String,
    height: String,
    // XXX: sandbox is a reflected settable token list
    seamless: Boolean,
    allowFullscreen: Boolean,
    allowUserMedia: Boolean,
    allowPaymentRequest: Boolean,
    referrerPolicy: REFERRER,
    // Obsolete
    align: String,
    scrolling: String,
    frameBorder: String,
    longDesc: URL,
    marginHeight: { type: String, treatNullAsEmptyString: true },
    marginWidth: { type: String, treatNullAsEmptyString: true },
  }
});

define({
  tag: 'img',
  ctor: function HTMLImageElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  attributes: {
    alt: String,
    src: URL,
    srcset: String,
    crossOrigin: CORS,
    useMap: String,
    isMap: Boolean,
    height: { type: "unsigned long", default: 0 },
    width: { type: "unsigned long", default: 0 },
    referrerPolicy: REFERRER,
    // Obsolete:
    name: String,
    lowsrc: URL,
    align: String,
    hspace: { type: "unsigned long", default: 0 },
    vspace: { type: "unsigned long", default: 0 },
    longDesc: URL,
    border: { type: String, treatNullAsEmptyString: true },
  }
});

define({
  tag: 'input',
  ctor: function HTMLInputElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  props: {
    form: formAssociatedProps.form,
    _post_click_activation_steps: { value: function(e) {
      if (this.type === 'checkbox') {
        this.checked = !this.checked;
      }
      else if (this.type === 'radio') {
        var group = this.form.getElementsByName(this.name);
        for (var i=group.length-1; i >= 0; i--) {
          var el = group[i];
          el.checked = (el === this);
        }
      }
    }},
  },
  attributes: {
    name: String,
    disabled: Boolean,
    autofocus: Boolean,
    accept: String,
    alt: String,
    max: String,
    min: String,
    pattern: String,
    placeholder: String,
    step: String,
    dirName: String,
    defaultValue: {name: 'value'},
    multiple: Boolean,
    required: Boolean,
    readOnly: Boolean,
    checked: Boolean,
    value: String,
    src: URL,
    defaultChecked: {name: 'checked', type: Boolean},
    size: {type: 'unsigned long', default: 20, min: 1, setmin: 1},
    maxLength: {type: 'unsigned long', min: 0, setmin: 0, default: -1},
    autocomplete: String, // It's complicated
    type: { type:
            ["text", "hidden", "search", "tel", "url", "email", "password",
             "datetime", "date", "month", "week", "time", "datetime-local",
             "number", "range", "color", "checkbox", "radio", "file", "submit",
             "image", "reset", "button"],
            missing: 'text' },
    formTarget: String,
    formNoValidate: Boolean,
    formMethod: { type: ["get", "post"], invalid: 'get', missing: '' },
    formEnctype: { type: ["application/x-www-form-urlencoded", "multipart/form-data", "text/plain"], invalid: "application/x-www-form-urlencoded", missing: '' },
    inputMode: { type: [ "verbatim", "latin", "latin-name", "latin-prose", "full-width-latin", "kana", "kana-name", "katakana", "numeric", "tel", "email", "url" ], missing: '' },
    // Obsolete
    align: String,
    useMap: String,
  }
});

define({
  tag: 'keygen',
  ctor: function HTMLKeygenElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  props: formAssociatedProps,
  attributes: {
    name: String,
    disabled: Boolean,
    autofocus: Boolean,
    challenge: String,
    keytype: { type:["rsa"], missing: '' },
  }
});

define({
  tag: 'li',
  ctor: function HTMLLIElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  attributes: {
    value: {type: "long", default: 0},
    // Obsolete
    type: String,
  }
});

define({
  tag: 'label',
  ctor: function HTMLLabelElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  props: formAssociatedProps,
  attributes: {
    htmlFor: {name: 'for', type: String}
  }
});

define({
  tag: 'legend',
  ctor: function HTMLLegendElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  attributes: {
    // Obsolete
    align: String
  },
});

define({
  tag: 'link',
  ctor: function HTMLLinkElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  attributes: {
    // XXX Reflect DOMSettableTokenList sizes also DOMTokenList relList
    href: URL,
    rel: String,
    media: String,
    hreflang: String,
    type: String,
    crossOrigin: CORS,
    nonce: String,
    integrity: String,
    referrerPolicy: REFERRER,
    // Obsolete
    charset: String,
    rev: String,
    target: String,
  }
});

define({
  tag: 'map',
  ctor: function HTMLMapElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  attributes: {
    name: String
  }
});

define({
  tag: 'menu',
  ctor: function HTMLMenuElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  attributes: {
    // XXX: not quite right, default should be popup if parent element is
    // popup.
    type: { type: [ 'context', 'popup', 'toolbar' ], missing: 'toolbar' },
    label: String,
    // Obsolete
    compact: Boolean,
  }
});

define({
  tag: 'meta',
  ctor: function HTMLMetaElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  attributes: {
    name: String,
    content: String,
    httpEquiv: {name: 'http-equiv', type: String},
    // Obsolete
    scheme: String,
  }
});

define({
  tag: 'meter',
  ctor: function HTMLMeterElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  props: formAssociatedProps
});

define({
  tags: ['ins', 'del'],
  ctor: function HTMLModElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  attributes: {
    cite: URL,
    dateTime: String
  }
});

define({
  tag: 'ol',
  ctor: function HTMLOListElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  props: {
    // Utility function (see the start attribute default value). Returns
    // the number of <li> children of this element
    _numitems: { get: function() {
      var items = 0;
      this.childNodes.forEach(function(n) {
        if (n.nodeType === Node.ELEMENT_NODE && n.tagName === "LI")
          items++;
      });
      return items;
    }}
  },
  attributes: {
    type: String,
    reversed: Boolean,
    start: {
      type: "long",
      default: function() {
       // The default value of the start attribute is 1 unless the list is
       // reversed. Then it is the # of li children
       if (this.reversed)
         return this._numitems;
       else
         return 1;
      }
    },
    // Obsolete
    compact: Boolean,
  }
});

define({
  tag: 'object',
  ctor: function HTMLObjectElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  props: formAssociatedProps,
  attributes: {
    data: URL,
    type: String,
    name: String,
    useMap: String,
    typeMustMatch: Boolean,
    width: String,
    height: String,
    // Obsolete
    align: String,
    archive: String,
    code: String,
    declare: Boolean,
    hspace: { type: "unsigned long", default: 0 },
    standby: String,
    vspace: { type: "unsigned long", default: 0 },
    codeBase: URL,
    codeType: String,
    border: { type: String, treatNullAsEmptyString: true },
  }
});

define({
  tag: 'optgroup',
  ctor: function HTMLOptGroupElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  attributes: {
    disabled: Boolean,
    label: String
  }
});

define({
  tag: 'option',
  ctor: function HTMLOptionElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  props: {
    form: { get: function() {
      var p = this.parentNode;
      while (p && p.nodeType === Node.ELEMENT_NODE) {
        if (p.localName === 'select') return p.form;
        p = p.parentNode;
      }
    }}
  },
  attributes: {
    disabled: Boolean,
    defaultSelected: {name: 'selected', type: Boolean},
    label: String,
    value: String,
  }
});

define({
  tag: 'output',
  ctor: function HTMLOutputElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  props: formAssociatedProps,
  attributes: {
    // XXX Reflect for/htmlFor as a settable token list
    name: String
  }
});

define({
  tag: 'p',
  ctor: function HTMLParagraphElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  attributes: {
    // Obsolete
    align: String
  }
});

define({
  tag: 'param',
  ctor: function HTMLParamElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  attributes: {
    name: String,
    value: String,
    // Obsolete
    type: String,
    valueType: String,
  }
});

define({
  tags: ['pre',/*legacy elements:*/'listing','xmp'],
  ctor: function HTMLPreElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  attributes: {
    // Obsolete
    width: { type: "long", default: 0 },
  }
});

define({
  tag: 'progress',
  ctor: function HTMLProgressElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  props: formAssociatedProps,
  attributes: {
    max: {type: Number, float: true, default: 1.0, min: 0}
  }
});

define({
  tags: ['q', 'blockquote'],
  ctor: function HTMLQuoteElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  attributes: {
    cite: URL
  }
});

define({
  tag: 'script',
  ctor: function HTMLScriptElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  props: {
    text: {
      get: function() {
        var s = "";
        for(var i = 0, n = this.childNodes.length; i < n; i++) {
          var child = this.childNodes[i];
          if (child.nodeType === Node.TEXT_NODE)
            s += child._data;
        }
        return s;
      },
      set: function(value) {
        this.removeChildren();
        if (value !== null && value !== "") {
          this.appendChild(this.ownerDocument.createTextNode(value));
        }
      }
    }
  },
  attributes: {
    src: URL,
    type: String,
    charset: String,
    defer: Boolean,
    async: Boolean,
    crossOrigin: CORS,
    nonce: String,
    integrity: String,
  }
});

define({
  tag: 'select',
  ctor: function HTMLSelectElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  props: {
    form: formAssociatedProps.form,
    options: { get: function() {
      return this.getElementsByTagName('option');
    }}
  },
  attributes: {
    name: String,
    disabled: Boolean,
    autofocus: Boolean,
    multiple: Boolean,
    required: Boolean,
    size: {type: "unsigned long", default: 0}
  }
});

define({
  tag: 'source',
  ctor: function HTMLSourceElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  attributes: {
    src: URL,
    type: String,
    media: String
  }
});

define({
  tag: 'span',
  ctor: function HTMLSpanElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  }
});

define({
  tag: 'style',
  ctor: function HTMLStyleElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  attributes: {
    media: String,
    type: String,
    scoped: Boolean
  }
});

define({
  tag: 'caption',
  ctor: function HTMLTableCaptionElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  attributes: {
    // Obsolete
    align: String,
  }
});


define({
  ctor: function HTMLTableCellElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  attributes: {
    colSpan: {type: "unsigned long", default: 1},
    rowSpan: {type: "unsigned long", default: 1},
    //XXX Also reflect settable token list headers
    scope: { type: ['row','col','rowgroup','colgroup'], missing: '' },
    abbr: String,
    // Obsolete
    align: String,
    axis: String,
    height: String,
    width: String,
    ch: { name: 'char', type: String },
    chOff: { name: 'charoff', type: String },
    noWrap: Boolean,
    vAlign: String,
    bgColor: { type: String, treatNullAsEmptyString: true },
  }
});

define({
  tags: ['col', 'colgroup'],
  ctor: function HTMLTableColElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  attributes: {
    span: {type: 'limited unsigned long with fallback', default: 1, min: 1},
    // Obsolete
    align: String,
    ch: { name: 'char', type: String },
    chOff: { name: 'charoff', type: String },
    vAlign: String,
    width: String,
  }
});

define({
  tag: 'table',
  ctor: function HTMLTableElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  props: {
    rows: { get: function() {
      return this.getElementsByTagName('tr');
    }}
  },
  attributes: {
    // Obsolete
    align: String,
    border: String,
    frame: String,
    rules: String,
    summary: String,
    width: String,
    bgColor: { type: String, treatNullAsEmptyString: true },
    cellPadding: { type: String, treatNullAsEmptyString: true },
    cellSpacing: { type: String, treatNullAsEmptyString: true },
  }
});

define({
  tag: 'template',
  ctor: function HTMLTemplateElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
    this._contentFragment = doc._templateDoc.createDocumentFragment();
  },
  props: {
    content: { get: function() { return this._contentFragment; } },
    serialize: { value: function() { return this.content.serialize(); } }
  }
});

define({
  tag: 'tr',
  ctor: function HTMLTableRowElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  props: {
    cells: { get: function() {
      return this.querySelectorAll('td,th');
    }}
  },
  attributes: {
    // Obsolete
    align: String,
    ch: { name: 'char', type: String },
    chOff: { name: 'charoff', type: String },
    vAlign: String,
    bgColor: { type: String, treatNullAsEmptyString: true },
  },
});

define({
  tags: ['thead', 'tfoot', 'tbody'],
  ctor: function HTMLTableSectionElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  props: {
    rows: { get: function() {
      return this.getElementsByTagName('tr');
    }}
  },
  attributes: {
    // Obsolete
    align: String,
    ch: { name: 'char', type: String },
    chOff: { name: 'charoff', type: String },
    vAlign: String,
  }
});

define({
  tag: 'textarea',
  ctor: function HTMLTextAreaElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  props: formAssociatedProps,
  attributes: {
    autocomplete: String, // It's complicated
    name: String,
    disabled: Boolean,
    autofocus: Boolean,
    placeholder: String,
    wrap: String,
    dirName: String,
    required: Boolean,
    readOnly: Boolean,
    rows: {type: 'limited unsigned long with fallback', default: 2 },
    cols: {type: 'limited unsigned long with fallback', default: 20 },
    maxLength: {type: 'unsigned long', min: 0, setmin: 0, default: -1},
    inputMode: { type: [ "verbatim", "latin", "latin-name", "latin-prose", "full-width-latin", "kana", "kana-name", "katakana", "numeric", "tel", "email", "url" ], missing: '' },
  }
});

define({
  tag: 'time',
  ctor: function HTMLTimeElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  attributes: {
    dateTime: String,
    pubDate: Boolean
  }
});

define({
  tag: 'title',
  ctor: function HTMLTitleElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  props: {
    text: { get: function() {
      return this.textContent;
    }}
  }
});

define({
  tag: 'ul',
  ctor: function HTMLUListElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  attributes: {
    type: String,
    // Obsolete
    compact: Boolean,
  }
});

define({
  ctor: function HTMLMediaElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  attributes: {
    src: URL,
    crossOrigin: CORS,
    preload: { type:["metadata", "none", "auto", {value: "", alias: "auto"}], missing: 'auto' },
    loop: Boolean,
    autoplay: Boolean,
    mediaGroup: String,
    controls: Boolean,
    defaultMuted: {name: "muted", type: Boolean}
  }
});

define({
  tag: 'audio',
  superclass: htmlElements.HTMLMediaElement,
  ctor: function HTMLAudioElement(doc, localName, prefix) {
    htmlElements.HTMLMediaElement.call(this, doc, localName, prefix);
  }
});

define({
  tag: 'video',
  superclass: htmlElements.HTMLMediaElement,
  ctor: function HTMLVideoElement(doc, localName, prefix) {
    htmlElements.HTMLMediaElement.call(this, doc, localName, prefix);
  },
  attributes: {
    poster: URL,
    width: {type: "unsigned long", min: 0, default: 0 },
    height: {type: "unsigned long", min: 0, default: 0 }
  }
});

define({
  tag: 'td',
  superclass: htmlElements.HTMLTableCellElement,
  ctor: function HTMLTableDataCellElement(doc, localName, prefix) {
    htmlElements.HTMLTableCellElement.call(this, doc, localName, prefix);
  }
});

define({
  tag: 'th',
  superclass: htmlElements.HTMLTableCellElement,
  ctor: function HTMLTableHeaderCellElement(doc, localName, prefix) {
    htmlElements.HTMLTableCellElement.call(this, doc, localName, prefix);
  },
});

define({
  tag: 'frameset',
  ctor: function HTMLFrameSetElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  }
});

define({
  tag: 'frame',
  ctor: function HTMLFrameElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  }
});

define({
  tag: 'canvas',
  ctor: function HTMLCanvasElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  props: {
    getContext: { value: utils.nyi },
    probablySupportsContext: { value: utils.nyi },
    setContext: { value: utils.nyi },
    transferControlToProxy: { value: utils.nyi },
    toDataURL: { value: utils.nyi },
    toBlob: { value: utils.nyi }
  },
  attributes: {
    width: { type: "unsigned long", default: 300},
    height: { type: "unsigned long", default: 150}
  }
});

define({
  tag: 'dialog',
  ctor: function HTMLDialogElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  props: {
    show: { value: utils.nyi },
    showModal: { value: utils.nyi },
    close: { value: utils.nyi }
  },
  attributes: {
    open: Boolean,
    returnValue: String
  }
});

define({
  tag: 'menuitem',
  ctor: function HTMLMenuItemElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  props: {
    // The menuitem's label
    _label: {
      get: function() {
        var val = this._getattr('label');
        if (val !== null && val !== '') { return val; }
        val = this.textContent;
        // Strip and collapse whitespace
        return val.replace(/[ \t\n\f\r]+/g, ' ').trim();
      }
    },
    // The menuitem label IDL attribute
    label: {
      get: function() {
        var val = this._getattr('label');
        if (val !== null) { return val; }
        return this._label;
      },
      set: function(v) {
        this._setattr('label', v);
      },
    }
  },
  attributes: {
    type: { type: ["command","checkbox","radio"], missing: 'command' },
    icon: URL,
    disabled: Boolean,
    checked: Boolean,
    radiogroup: String,
    default: Boolean
  }
});

define({
  tag: 'source',
  ctor: function HTMLSourceElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  attributes: {
    srcset: String,
    sizes: String,
    media: String,
    src: URL,
    type: String
  }
});

define({
  tag: 'track',
  ctor: function HTMLTrackElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  attributes: {
    src: URL,
    srclang: String,
    label: String,
    default: Boolean,
    kind: { type: ["subtitles", "captions", "descriptions", "chapters", "metadata"], missing: 'subtitles', invalid: 'metadata' },
  },
  props: {
    NONE: { get: function() { return 0; } },
    LOADING: { get: function() { return 1; } },
    LOADED: { get: function() { return 2; } },
    ERROR: { get: function() { return 3; } },
    readyState: { get: utils.nyi },
    track: { get: utils.nyi }
  }
});

define({
  tags: [
    "abbr", "address", "article", "aside", "b", "bdi", "bdo",
    "cite", "code", "dd", "dfn", "dt", "em", "figcaption", "figure",
    "footer", "header", "hgroup", "i", "kbd", "main", "mark", "nav", "noscript",
    "rb", "rp", "rt", "rtc", "ruby", "s", "samp", "section", "small", "strong",
    "sub", "summary", "sup", "u", "var", "wbr",
    // Legacy elements
    "acronym", "basefont", "big", "center", "nobr", "noembed", "noframes",
    "plaintext", "strike", "tt"
  ]
});


/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var parserlib = __webpack_require__(82);

module.exports = CSSStyleDeclaration;

function CSSStyleDeclaration(elt) {
  this._element = elt;
}

// Utility function for parsing style declarations
// Pass in a string like "margin-left: 5px; border-style: solid"
// and this function returns an object like
// {"margin-left":"5px", "border-style":"solid"}
function parseStyles(s) {
  var parser = new parserlib.css.Parser();
  var result = { property: Object.create(null), priority: Object.create(null) };
  parser.addListener("property", function(e) {
    if (e.invalid) return; // Skip errors
    result.property[e.property.text] = e.value.text;
    if (e.important) result.priority[e.property.text] = 'important';
  });
  s = (''+s).replace(/^;/, '');
  parser.parseStyleAttribute(s);
  return result;
}

var NO_CHANGE = {}; // Private marker object

CSSStyleDeclaration.prototype = Object.create(Object.prototype, {

  // Return the parsed form of the element's style attribute.
  // If the element's style attribute has never been parsed
  // or if it has changed since the last parse, then reparse it
  // Note that the styles don't get parsed until they're actually needed
  _parsed: { get: function() {
    if (!this._parsedStyles || this.cssText !== this._lastParsedText) {
      var text = this.cssText;
      this._parsedStyles = parseStyles(text);
      this._lastParsedText = text;
      delete this._names;
    }
    return this._parsedStyles;
  }},

  // Call this method any time the parsed representation of the
  // style changes.  It converts the style properties to a string and
  // sets cssText and the element's style attribute
  _serialize: { value: function() {
    var styles = this._parsed;
    var s = "";

    for(var name in styles.property) {
      if (s) s += " ";
      s += name + ": " + styles.property[name];
      if (styles.priority[name]) {
        s += " !" + styles.priority[name];
      }
      s += ";";
    }

    this.cssText = s;      // also sets the style attribute
    this._lastParsedText = s;  // so we don't reparse
    delete this._names;
  }},

  cssText: {
    get: function() {
      // XXX: this is a CSSStyleDeclaration for an element.
      // A different impl might be necessary for a set of styles
      // associated returned by getComputedStyle(), e.g.
      return this._element.getAttribute("style");
    },
    set: function(value) {
      // XXX: I should parse and serialize the value to
      // normalize it and remove errors. FF and chrome do that.
      this._element.setAttribute("style", value);
    }
  },

  length: { get: function() {
    if (!this._names)
      this._names = Object.getOwnPropertyNames(this._parsed.property);
    return this._names.length;
  }},

  item: { value: function(n) {
    if (!this._names)
      this._names = Object.getOwnPropertyNames(this._parsed.property);
    return this._names[n];
  }},

  getPropertyValue: { value: function(property) {
    property = property.toLowerCase();
    return this._parsed.property[property] || "";
  }},

  getPropertyPriority: { value: function(property) {
    property = property.toLowerCase();
    return this._parsed.priority[property] || "";
  }},

  setProperty: { value: function(property, value, priority) {
    property = property.toLowerCase();
    if (value === null || value === undefined) {
      value = "";
    }
    if (priority === null || priority === undefined) {
      priority = "";
    }

    // String coercion
    if (value !== NO_CHANGE) {
      value = "" + value;
    }

    if (value === "") {
      this.removeProperty(property);
      return;
    }

    if (priority !== "" && priority !== NO_CHANGE &&
        !/^important$/i.test(priority)) {
      return;
    }

    var styles = this._parsed;
    if (value === NO_CHANGE) {
      if (!styles.property[property]) {
        return; // Not a valid property name.
      }
      if (priority !== "") {
        styles.priority[property] = "important";
      } else {
        delete styles.priority[property];
      }
    } else {
      // We don't just accept the property value.  Instead
      // we parse it to ensure that it is something valid.
      // If it contains a semicolon it is invalid
      if (value.indexOf(";") !== -1) return;

      var newprops = parseStyles(property + ":" + value);
      if (Object.getOwnPropertyNames(newprops.property).length === 0) {
        return; // no valid property found
      }
      if (Object.getOwnPropertyNames(newprops.priority).length !== 0) {
        return; // if the value included '!important' it wasn't valid.
      }

      // XXX handle shorthand properties

      for (var p in newprops.property) {
        styles.property[p] = newprops.property[p];
        if (priority === NO_CHANGE) {
          continue;
        } else if (priority !== "") {
          styles.priority[p] = "important";
        } else if (styles.priority[p]) {
          delete styles.priority[p];
        }
      }
    }

    // Serialize and update cssText and element.style!
    this._serialize();
  }},

  setPropertyValue: { value: function(property, value) {
    return this.setProperty(property, value, NO_CHANGE);
  }},

  setPropertyPriority: { value: function(property, priority) {
    return this.setProperty(property, NO_CHANGE, priority);
  }},

  removeProperty: { value: function(property) {
    property = property.toLowerCase();
    var styles = this._parsed;
    if (property in styles.property) {
      delete styles.property[property];
      delete styles.priority[property];

      // Serialize and update cssText and element.style!
      this._serialize();
    }
  }},
});

var cssProperties = {
  background: "background",
  backgroundAttachment: "background-attachment",
  backgroundColor: "background-color",
  backgroundImage: "background-image",
  backgroundPosition: "background-position",
  backgroundRepeat: "background-repeat",
  border: "border",
  borderCollapse: "border-collapse",
  borderColor: "border-color",
  borderSpacing: "border-spacing",
  borderStyle: "border-style",
  borderTop: "border-top",
  borderRight: "border-right",
  borderBottom: "border-bottom",
  borderLeft: "border-left",
  borderTopColor: "border-top-color",
  borderRightColor: "border-right-color",
  borderBottomColor: "border-bottom-color",
  borderLeftColor: "border-left-color",
  borderTopStyle: "border-top-style",
  borderRightStyle: "border-right-style",
  borderBottomStyle: "border-bottom-style",
  borderLeftStyle: "border-left-style",
  borderTopWidth: "border-top-width",
  borderRightWidth: "border-right-width",
  borderBottomWidth: "border-bottom-width",
  borderLeftWidth: "border-left-width",
  borderWidth: "border-width",
  bottom: "bottom",
  captionSide: "caption-side",
  clear: "clear",
  clip: "clip",
  color: "color",
  content: "content",
  counterIncrement: "counter-increment",
  counterReset: "counter-reset",
  cursor: "cursor",
  direction: "direction",
  display: "display",
  emptyCells: "empty-cells",
  cssFloat: "float",
  font: "font",
  fontFamily: "font-family",
  fontSize: "font-size",
  fontSizeAdjust: "font-size-adjust",
  fontStretch: "font-stretch",
  fontStyle: "font-style",
  fontVariant: "font-variant",
  fontWeight: "font-weight",
  height: "height",
  left: "left",
  letterSpacing: "letter-spacing",
  lineHeight: "line-height",
  listStyle: "list-style",
  listStyleImage: "list-style-image",
  listStylePosition: "list-style-position",
  listStyleType: "list-style-type",
  margin: "margin",
  marginTop: "margin-top",
  marginRight: "margin-right",
  marginBottom: "margin-bottom",
  marginLeft: "margin-left",
  markerOffset: "marker-offset",
  marks: "marks",
  maxHeight: "max-height",
  maxWidth: "max-width",
  minHeight: "min-height",
  minWidth: "min-width",
  opacity: "opacity",
  orphans: "orphans",
  outline: "outline",
  outlineColor: "outline-color",
  outlineStyle: "outline-style",
  outlineWidth: "outline-width",
  overflow: "overflow",
  padding: "padding",
  paddingTop: "padding-top",
  paddingRight: "padding-right",
  paddingBottom: "padding-bottom",
  paddingLeft: "padding-left",
  page: "page",
  pageBreakAfter: "page-break-after",
  pageBreakBefore: "page-break-before",
  pageBreakInside: "page-break-inside",
  position: "position",
  quotes: "quotes",
  right: "right",
  size: "size",
  tableLayout: "table-layout",
  textAlign: "text-align",
  textDecoration: "text-decoration",
  textIndent: "text-indent",
  textShadow: "text-shadow",
  textTransform: "text-transform",
  top: "top",
  unicodeBidi: "unicode-bidi",
  verticalAlign: "vertical-align",
  visibility: "visibility",
  whiteSpace: "white-space",
  widows: "widows",
  width: "width",
  wordSpacing: "word-spacing",
  zIndex: "z-index",
};

for(var prop in cssProperties) defineStyleProperty(prop);

function defineStyleProperty(jsname) {
  var cssname = cssProperties[jsname];
  Object.defineProperty(CSSStyleDeclaration.prototype, jsname, {
    get: function() {
      return this.getPropertyValue(cssname);
    },
    set: function(value) {
      this.setProperty(cssname, value);
    }
  });
}


/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var DOMImplementation = __webpack_require__(12);
var EventTarget = __webpack_require__(41);
var Location = __webpack_require__(83);
var sloppy = __webpack_require__(58);
var utils = __webpack_require__(3);

module.exports = Window;

function Window(document) {
  this.document = document || new DOMImplementation().createHTMLDocument("");
  this.document._scripting_enabled = true;
  this.document.defaultView = this;
  this.location = new Location(this, this.document._address || 'about:blank');
}

Window.prototype = Object.create(EventTarget.prototype, {
  _run: { value: sloppy.Window_run },
  console: { value: console },
  history: { value: {
    back: utils.nyi,
    forward: utils.nyi,
    go: utils.nyi
  }},
  navigator: { value: __webpack_require__(84) },

  // Self-referential properties
  window: { get: function() { return this; }},
  self: { get: function() { return this; }},
  frames: { get: function() { return this; }},

  // Self-referential properties for a top-level window
  parent: { get: function() { return this; }},
  top: { get: function() { return this; }},

  // We don't support any other windows for now
  length: { value: 0 },           // no frames
  frameElement: { value: null },  // not part of a frame
  opener: { value: null },        // not opened by another window

  // The onload event handler.
  // XXX: need to support a bunch of other event types, too,
  // and have them interoperate with document.body.

  onload: {
    get: function() {
      return this._getEventHandler("load");
    },
    set: function(v) {
      this._setEventHandler("load", v);
    }
  },

  // XXX This is a completely broken implementation
  getComputedStyle: { value: function getComputedStyle(elt) {
    return elt.style;
  }}

});

utils.expose(__webpack_require__(85), Window);
utils.expose(__webpack_require__(59), Window);


/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = DocumentType;

var Node = __webpack_require__(4);
var Leaf = __webpack_require__(50);
var utils = __webpack_require__(3);
var ChildNode = __webpack_require__(23);

function DocumentType(name, publicId, systemId) {
  // Unlike other nodes, doctype nodes always start off unowned
  // until inserted
  this.nodeType = Node.DOCUMENT_TYPE_NODE;
  this.ownerDocument = null;
  this.name = name;
  this.publicId = publicId || "";
  this.systemId = systemId || "";
}

DocumentType.prototype = Object.create(Leaf.prototype, {
  nodeName: { get: function() { return this.name; }},
  nodeValue: {
    get: function() { return null; },
    set: function() {}
  },

  // Utility methods
  clone: { value: function clone() {
    utils.DataCloneError();
  }},

  isEqual: { value: function isEqual(n) {
    return this.name === n.name &&
      this.publicId === n.publicId &&
      this.systemId === n.systemId;
  }}
});

Object.defineProperties(DocumentType.prototype, ChildNode);


/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = HTMLParser;

var Document = __webpack_require__(20);
var DocumentType = __webpack_require__(28);
var Node = __webpack_require__(4);
var NAMESPACE = __webpack_require__(3).NAMESPACE;
var html = __webpack_require__(25);
var impl = html.elements;

var pushAll = Function.prototype.apply.bind(Array.prototype.push);

/*
 * This file contains an implementation of the HTML parsing algorithm.
 * The algorithm and the implementation are complex because HTML
 * explicitly defines how the parser should behave for all possible
 * valid and invalid inputs.
 *
 * Usage:
 *
 * The file defines a single HTMLParser() function, which dom.js exposes
 * publicly as document.implementation.mozHTMLParser(). This is a
 * factory function, not a constructor.
 *
 * When you call document.implementation.mozHTMLParser(), it returns
 * an object that has parse() and document() methods. To parse HTML text,
 * pass the text (in one or more chunks) to the parse() method.  When
 * you've passed all the text (on the last chunk, or afterward) pass
 * true as the second argument to parse() to tell the parser that there
 * is no more coming. Call document() to get the document object that
 * the parser is parsing into.  You can call this at any time, before
 * or after calling parse().
 *
 * The first argument to mozHTMLParser is the absolute URL of the document.
 *
 * The second argument is optional and is for internal use only.  Pass an
 * element as the fragmentContext to do innerHTML parsing for the
 * element.  To do innerHTML parsing on a document, pass null. Otherwise,
 * omit the 2nd argument. See HTMLElement.innerHTML for an example.  Note
 * that if you pass a context element, the end() method will return an
 * unwrapped document instead of a wrapped one.
 *
 * Implementation details:
 *
 * This is a long file of almost 7000 lines. It is structured as one
 * big function nested within another big function.  The outer
 * function defines a bunch of constant data, utility functions
 * that use that data, and a couple of classes used by the parser.
 * The outer function also defines and returns the
 * inner function. This inner function is the HTMLParser factory
 * function that implements the parser and holds all the parser state
 * as local variables.  The HTMLParser function is quite big because
 * it defines many nested functions that use those local variables.
 *
 * There are three tightly coupled parser stages: a scanner, a
 * tokenizer and a tree builder. In a (possibly misguided) attempt at
 * efficiency, the stages are not implemented as separate classes:
 * everything shares state and is (mostly) implemented in imperative
 * (rather than OO) style.
 *
 * The stages of the parser work like this: When the client code calls
 * the parser's parse() method, the specified string is passed to
 * scanChars(). The scanner loops through that string and passes characters
 * (sometimes one at a time, sometimes in chunks) to the tokenizer stage.
 * The tokenizer groups the characters into tokens: tags, endtags, runs
 * of text, comments, doctype declarations, and the end-of-file (EOF)
 * token.  These tokens are then passed to the tree building stage via
 * the insertToken() function.  The tree building stage builds up the
 * document tree.
 *
 * The tokenizer stage is a finite state machine.  Each state is
 * implemented as a function with a name that ends in "_state".  The
 * initial state is data_state(). The current tokenizer state is stored
 * in the variable 'tokenizer'.  Most state functions expect a single
 * integer argument which represents a single UTF-16 codepoint.  Some
 * states want more characters and set a lookahead property on
 * themselves.  The scanChars() function in the scanner checks for this
 * lookahead property.  If it doesn't exist, then scanChars() just passes
 * the next input character to the current tokenizer state function.
 * Otherwise, scanChars() looks ahead (a given # of characters, or for a
 * matching string, or for a matching regexp) and passes a string of
 * characters to the current tokenizer state function.
 *
 * As a shortcut, certain states of the tokenizer use regular expressions
 * to look ahead in the scanner's input buffer for runs of text, simple
 * tags and attributes.  For well-formed input, these shortcuts skip a
 * lot of state transitions and speed things up a bit.
 *
 * When a tokenizer state function has consumed a complete token, it
 * emits that token, by calling insertToken(), or by calling a utility
 * function that itself calls insertToken().  These tokens are passed to
 * the tree building stage, which is also a state machine.  Like the
 * tokenizer, the tree building states are implemented as functions, and
 * these functions have names that end with _mode (because the HTML spec
 * refers to them as insertion modes). The current insertion mode is held
 * by the 'parser' variable.  Each insertion mode function takes up to 4
 * arguments.  The first is a token type, represented by the constants
 * TAG, ENDTAG, TEXT, COMMENT, DOCTYPE and EOF.  The second argument is
 * the value of the token: the text or comment data, or tagname or
 * doctype.  For tags, the 3rd argument is an array of attributes.  For
 * DOCTYPES it is the optional public id.  For tags, the 4th argument is
 * true if the tag is self-closing. For doctypes, the 4th argument is the
 * optional system id.
 *
 * Search for "***" to find the major sub-divisions in the code.
 */


/***
 * Data prolog.  Lots of constants declared here, including some
 * very large objects.  They're used throughout the code that follows
 */
// Token types for the tree builder.
var EOF = -1;
var TEXT = 1;
var TAG = 2;
var ENDTAG = 3;
var COMMENT = 4;
var DOCTYPE = 5;

// A re-usable empty array
var NOATTRS = [];

// These DTD public ids put the browser in quirks mode
var quirkyPublicIds = /^HTML$|^-\/\/W3O\/\/DTD W3 HTML Strict 3\.0\/\/EN\/\/$|^-\/W3C\/DTD HTML 4\.0 Transitional\/EN$|^\+\/\/Silmaril\/\/dtd html Pro v0r11 19970101\/\/|^-\/\/AdvaSoft Ltd\/\/DTD HTML 3\.0 asWedit \+ extensions\/\/|^-\/\/AS\/\/DTD HTML 3\.0 asWedit \+ extensions\/\/|^-\/\/IETF\/\/DTD HTML 2\.0 Level 1\/\/|^-\/\/IETF\/\/DTD HTML 2\.0 Level 2\/\/|^-\/\/IETF\/\/DTD HTML 2\.0 Strict Level 1\/\/|^-\/\/IETF\/\/DTD HTML 2\.0 Strict Level 2\/\/|^-\/\/IETF\/\/DTD HTML 2\.0 Strict\/\/|^-\/\/IETF\/\/DTD HTML 2\.0\/\/|^-\/\/IETF\/\/DTD HTML 2\.1E\/\/|^-\/\/IETF\/\/DTD HTML 3\.0\/\/|^-\/\/IETF\/\/DTD HTML 3\.2 Final\/\/|^-\/\/IETF\/\/DTD HTML 3\.2\/\/|^-\/\/IETF\/\/DTD HTML 3\/\/|^-\/\/IETF\/\/DTD HTML Level 0\/\/|^-\/\/IETF\/\/DTD HTML Level 1\/\/|^-\/\/IETF\/\/DTD HTML Level 2\/\/|^-\/\/IETF\/\/DTD HTML Level 3\/\/|^-\/\/IETF\/\/DTD HTML Strict Level 0\/\/|^-\/\/IETF\/\/DTD HTML Strict Level 1\/\/|^-\/\/IETF\/\/DTD HTML Strict Level 2\/\/|^-\/\/IETF\/\/DTD HTML Strict Level 3\/\/|^-\/\/IETF\/\/DTD HTML Strict\/\/|^-\/\/IETF\/\/DTD HTML\/\/|^-\/\/Metrius\/\/DTD Metrius Presentational\/\/|^-\/\/Microsoft\/\/DTD Internet Explorer 2\.0 HTML Strict\/\/|^-\/\/Microsoft\/\/DTD Internet Explorer 2\.0 HTML\/\/|^-\/\/Microsoft\/\/DTD Internet Explorer 2\.0 Tables\/\/|^-\/\/Microsoft\/\/DTD Internet Explorer 3\.0 HTML Strict\/\/|^-\/\/Microsoft\/\/DTD Internet Explorer 3\.0 HTML\/\/|^-\/\/Microsoft\/\/DTD Internet Explorer 3\.0 Tables\/\/|^-\/\/Netscape Comm\. Corp\.\/\/DTD HTML\/\/|^-\/\/Netscape Comm\. Corp\.\/\/DTD Strict HTML\/\/|^-\/\/O'Reilly and Associates\/\/DTD HTML 2\.0\/\/|^-\/\/O'Reilly and Associates\/\/DTD HTML Extended 1\.0\/\/|^-\/\/O'Reilly and Associates\/\/DTD HTML Extended Relaxed 1\.0\/\/|^-\/\/SoftQuad Software\/\/DTD HoTMetaL PRO 6\.0::19990601::extensions to HTML 4\.0\/\/|^-\/\/SoftQuad\/\/DTD HoTMetaL PRO 4\.0::19971010::extensions to HTML 4\.0\/\/|^-\/\/Spyglass\/\/DTD HTML 2\.0 Extended\/\/|^-\/\/SQ\/\/DTD HTML 2\.0 HoTMetaL \+ extensions\/\/|^-\/\/Sun Microsystems Corp\.\/\/DTD HotJava HTML\/\/|^-\/\/Sun Microsystems Corp\.\/\/DTD HotJava Strict HTML\/\/|^-\/\/W3C\/\/DTD HTML 3 1995-03-24\/\/|^-\/\/W3C\/\/DTD HTML 3\.2 Draft\/\/|^-\/\/W3C\/\/DTD HTML 3\.2 Final\/\/|^-\/\/W3C\/\/DTD HTML 3\.2\/\/|^-\/\/W3C\/\/DTD HTML 3\.2S Draft\/\/|^-\/\/W3C\/\/DTD HTML 4\.0 Frameset\/\/|^-\/\/W3C\/\/DTD HTML 4\.0 Transitional\/\/|^-\/\/W3C\/\/DTD HTML Experimental 19960712\/\/|^-\/\/W3C\/\/DTD HTML Experimental 970421\/\/|^-\/\/W3C\/\/DTD W3 HTML\/\/|^-\/\/W3O\/\/DTD W3 HTML 3\.0\/\/|^-\/\/WebTechs\/\/DTD Mozilla HTML 2\.0\/\/|^-\/\/WebTechs\/\/DTD Mozilla HTML\/\//i;

var quirkySystemId = "http://www.ibm.com/data/dtd/v11/ibmxhtml1-transitional.dtd";

var conditionallyQuirkyPublicIds = /^-\/\/W3C\/\/DTD HTML 4\.01 Frameset\/\/|^-\/\/W3C\/\/DTD HTML 4\.01 Transitional\/\//i;

// These DTD public ids put the browser in limited quirks mode
var limitedQuirkyPublicIds = /^-\/\/W3C\/\/DTD XHTML 1\.0 Frameset\/\/|^-\/\/W3C\/\/DTD XHTML 1\.0 Transitional\/\//i;


// Element sets below. See the isA() function for a way to test
// whether an element is a member of a set
var specialSet = Object.create(null);
specialSet[NAMESPACE.HTML] = {
  __proto__: null,
  "address":true, "applet":true, "area":true, "article":true,
  "aside":true, "base":true, "basefont":true, "bgsound":true,
  "blockquote":true, "body":true, "br":true, "button":true,
  "caption":true, "center":true, "col":true, "colgroup":true,
  "dd":true, "details":true, "dir":true,
  "div":true, "dl":true, "dt":true, "embed":true,
  "fieldset":true, "figcaption":true, "figure":true, "footer":true,
  "form":true, "frame":true, "frameset":true, "h1":true,
  "h2":true, "h3":true, "h4":true, "h5":true,
  "h6":true, "head":true, "header":true, "hgroup":true,
  "hr":true, "html":true, "iframe":true, "img":true,
  "input":true, "li":true, "link":true,
  "listing":true, "main":true, "marquee":true, "menu":true, "meta":true,
  "nav":true, "noembed":true, "noframes":true, "noscript":true,
  "object":true, "ol":true, "p":true, "param":true,
  "plaintext":true, "pre":true, "script":true, "section":true,
  "select":true, "source":true, "style":true, "summary":true, "table":true,
  "tbody":true, "td":true, "template":true, "textarea":true, "tfoot":true,
  "th":true, "thead":true, "title":true, "tr":true, "track":true,
  // Note that "xmp" was removed from the "special" set in the latest
  // spec, apparently by accident; see
  // https://github.com/whatwg/html/pull/1919
  "ul":true, "wbr":true, "xmp":true
};
specialSet[NAMESPACE.SVG] = {
  __proto__: null,
  "foreignObject": true, "desc": true, "title": true
};
specialSet[NAMESPACE.MATHML] = {
  __proto__: null,
  "mi":true, "mo":true, "mn":true, "ms":true,
  "mtext":true, "annotation-xml":true
};

// The set of address, div, and p HTML tags
var addressdivpSet = Object.create(null);
addressdivpSet[NAMESPACE.HTML] = {
  __proto__: null,
  "address":true, "div":true, "p":true
};

var dddtSet = Object.create(null);
dddtSet[NAMESPACE.HTML] = {
  __proto__: null,
  "dd":true, "dt":true
};

var tablesectionrowSet = Object.create(null);
tablesectionrowSet[NAMESPACE.HTML] = {
  __proto__: null,
  "table":true, "thead":true, "tbody":true, "tfoot":true, "tr":true
};

var impliedEndTagsSet = Object.create(null);
impliedEndTagsSet[NAMESPACE.HTML] = {
  __proto__: null,
  "dd": true, "dt": true, "li": true, "menuitem": true, "optgroup": true,
  "option": true, "p": true, "rb": true, "rp": true, "rt": true, "rtc": true
};

var thoroughImpliedEndTagsSet = Object.create(null);
thoroughImpliedEndTagsSet[NAMESPACE.HTML] = {
  __proto__: null,
  "caption": true, "colgroup": true, "dd": true, "dt": true, "li": true,
  "optgroup": true, "option": true, "p": true, "rb": true, "rp": true,
  "rt": true, "rtc": true, "tbody": true, "td": true, "tfoot": true,
  "th": true, "thead": true, "tr": true
};

var tableContextSet = Object.create(null);
tableContextSet[NAMESPACE.HTML] = {
  __proto__: null,
  "table": true, "template": true, "html": true
};

var tableBodyContextSet = Object.create(null);
tableBodyContextSet[NAMESPACE.HTML] = {
  __proto__: null,
  "tbody": true, "tfoot": true, "thead": true, "template": true, "html": true
};

var tableRowContextSet = Object.create(null);
tableRowContextSet[NAMESPACE.HTML] = {
  __proto__: null,
  "tr": true, "template": true, "html": true
};

// See http://www.w3.org/TR/html5/forms.html#form-associated-element
var formassociatedSet = Object.create(null);
formassociatedSet[NAMESPACE.HTML] = {
  __proto__: null,
  "button": true, "fieldset": true, "input": true, "keygen": true,
  "object": true, "output": true, "select": true, "textarea": true,
  "img": true
};

var inScopeSet = Object.create(null);
inScopeSet[NAMESPACE.HTML]= {
  __proto__: null,
  "applet":true, "caption":true, "html":true, "table":true,
  "td":true, "th":true, "marquee":true, "object":true,
  "template":true
};
inScopeSet[NAMESPACE.MATHML] = {
  __proto__: null,
  "mi":true, "mo":true, "mn":true, "ms":true,
  "mtext":true, "annotation-xml":true
};
inScopeSet[NAMESPACE.SVG] = {
  __proto__: null,
  "foreignObject":true, "desc":true, "title":true
};

var inListItemScopeSet = Object.create(inScopeSet);
inListItemScopeSet[NAMESPACE.HTML] =
  Object.create(inScopeSet[NAMESPACE.HTML]);
inListItemScopeSet[NAMESPACE.HTML].ol = true;
inListItemScopeSet[NAMESPACE.HTML].ul = true;

var inButtonScopeSet = Object.create(inScopeSet);
inButtonScopeSet[NAMESPACE.HTML] =
  Object.create(inScopeSet[NAMESPACE.HTML]);
inButtonScopeSet[NAMESPACE.HTML].button = true;

var inTableScopeSet = Object.create(null);
inTableScopeSet[NAMESPACE.HTML] = {
  __proto__: null,
  "html":true, "table":true, "template":true
};

// The set of elements for select scope is the everything *except* these
var invertedSelectScopeSet = Object.create(null);
invertedSelectScopeSet[NAMESPACE.HTML] = {
  __proto__: null,
  "optgroup":true, "option":true
};

var mathmlTextIntegrationPointSet = Object.create(null);
mathmlTextIntegrationPointSet[NAMESPACE.MATHML] = {
  __proto__: null,
  mi: true,
  mo: true,
  mn: true,
  ms: true,
  mtext: true
};

var htmlIntegrationPointSet = Object.create(null);
htmlIntegrationPointSet[NAMESPACE.SVG] = {
  __proto__: null,
  foreignObject: true,
  desc: true,
  title: true
};

var foreignAttributes = {
  __proto__: null,
  "xlink:actuate": NAMESPACE.XLINK, "xlink:arcrole": NAMESPACE.XLINK,
  "xlink:href":   NAMESPACE.XLINK,  "xlink:role":    NAMESPACE.XLINK,
  "xlink:show":   NAMESPACE.XLINK,  "xlink:title":   NAMESPACE.XLINK,
  "xlink:type":   NAMESPACE.XLINK,  "xml:base":      NAMESPACE.XML,
  "xml:lang":     NAMESPACE.XML,    "xml:space":     NAMESPACE.XML,
  "xmlns":        NAMESPACE.XMLNS,  "xmlns:xlink":   NAMESPACE.XMLNS
};


// Lowercase to mixed case mapping for SVG attributes and tagnames
var svgAttrAdjustments = {
  __proto__: null,
  attributename: "attributeName", attributetype: "attributeType",
  basefrequency: "baseFrequency", baseprofile: "baseProfile",
  calcmode: "calcMode", clippathunits: "clipPathUnits",
  diffuseconstant: "diffuseConstant",
  edgemode: "edgeMode",
  filterunits: "filterUnits",
  glyphref: "glyphRef", gradienttransform: "gradientTransform",
  gradientunits: "gradientUnits", kernelmatrix: "kernelMatrix",
  kernelunitlength: "kernelUnitLength", keypoints: "keyPoints",
  keysplines: "keySplines", keytimes: "keyTimes",
  lengthadjust: "lengthAdjust", limitingconeangle: "limitingConeAngle",
  markerheight: "markerHeight", markerunits: "markerUnits",
  markerwidth: "markerWidth", maskcontentunits: "maskContentUnits",
  maskunits: "maskUnits", numoctaves: "numOctaves",
  pathlength: "pathLength", patterncontentunits: "patternContentUnits",
  patterntransform: "patternTransform", patternunits: "patternUnits",
  pointsatx: "pointsAtX", pointsaty: "pointsAtY",
  pointsatz: "pointsAtZ", preservealpha: "preserveAlpha",
  preserveaspectratio: "preserveAspectRatio",
  primitiveunits: "primitiveUnits", refx: "refX",
  refy: "refY", repeatcount: "repeatCount",
  repeatdur: "repeatDur", requiredextensions: "requiredExtensions",
  requiredfeatures: "requiredFeatures",
  specularconstant: "specularConstant",
  specularexponent: "specularExponent", spreadmethod: "spreadMethod",
  startoffset: "startOffset", stddeviation: "stdDeviation",
  stitchtiles: "stitchTiles", surfacescale: "surfaceScale",
  systemlanguage: "systemLanguage", tablevalues: "tableValues",
  targetx: "targetX", targety: "targetY",
  textlength: "textLength", viewbox: "viewBox",
  viewtarget: "viewTarget", xchannelselector: "xChannelSelector",
  ychannelselector: "yChannelSelector", zoomandpan: "zoomAndPan"
};

var svgTagNameAdjustments = {
  __proto__: null,
  altglyph: "altGlyph", altglyphdef: "altGlyphDef",
  altglyphitem: "altGlyphItem", animatecolor: "animateColor",
  animatemotion: "animateMotion", animatetransform: "animateTransform",
  clippath: "clipPath", feblend: "feBlend",
  fecolormatrix: "feColorMatrix",
  fecomponenttransfer: "feComponentTransfer", fecomposite: "feComposite",
  feconvolvematrix: "feConvolveMatrix",
  fediffuselighting: "feDiffuseLighting",
  fedisplacementmap: "feDisplacementMap",
  fedistantlight: "feDistantLight", feflood: "feFlood",
  fefunca: "feFuncA", fefuncb: "feFuncB",
  fefuncg: "feFuncG", fefuncr: "feFuncR",
  fegaussianblur: "feGaussianBlur", feimage: "feImage",
  femerge: "feMerge", femergenode: "feMergeNode",
  femorphology: "feMorphology", feoffset: "feOffset",
  fepointlight: "fePointLight", fespecularlighting: "feSpecularLighting",
  fespotlight: "feSpotLight", fetile: "feTile",
  feturbulence: "feTurbulence", foreignobject: "foreignObject",
  glyphref: "glyphRef", lineargradient: "linearGradient",
  radialgradient: "radialGradient", textpath: "textPath"
};


// Data for parsing numeric and named character references
// These next 3 objects are direct translations of tables
// in the HTML spec into JavaScript object format
var numericCharRefReplacements = {
  __proto__: null,
  0x00:0xFFFD, 0x80:0x20AC, 0x82:0x201A, 0x83:0x0192, 0x84:0x201E,
  0x85:0x2026, 0x86:0x2020, 0x87:0x2021, 0x88:0x02C6, 0x89:0x2030,
  0x8A:0x0160, 0x8B:0x2039, 0x8C:0x0152, 0x8E:0x017D, 0x91:0x2018,
  0x92:0x2019, 0x93:0x201C, 0x94:0x201D, 0x95:0x2022, 0x96:0x2013,
  0x97:0x2014, 0x98:0x02DC, 0x99:0x2122, 0x9A:0x0161, 0x9B:0x203A,
  0x9C:0x0153, 0x9E:0x017E, 0x9F:0x0178
};

/*
 * This table is generated with test/tools/update-entities.js
 */
var namedCharRefs = {
  __proto__: null,
  "AElig":0xc6, "AElig;":0xc6,
  "AMP":0x26, "AMP;":0x26,
  "Aacute":0xc1, "Aacute;":0xc1,
  "Abreve;":0x102, "Acirc":0xc2,
  "Acirc;":0xc2, "Acy;":0x410,
  "Afr;":[0xd835,0xdd04], "Agrave":0xc0,
  "Agrave;":0xc0, "Alpha;":0x391,
  "Amacr;":0x100, "And;":0x2a53,
  "Aogon;":0x104, "Aopf;":[0xd835,0xdd38],
  "ApplyFunction;":0x2061, "Aring":0xc5,
  "Aring;":0xc5, "Ascr;":[0xd835,0xdc9c],
  "Assign;":0x2254, "Atilde":0xc3,
  "Atilde;":0xc3, "Auml":0xc4,
  "Auml;":0xc4, "Backslash;":0x2216,
  "Barv;":0x2ae7, "Barwed;":0x2306,
  "Bcy;":0x411, "Because;":0x2235,
  "Bernoullis;":0x212c, "Beta;":0x392,
  "Bfr;":[0xd835,0xdd05], "Bopf;":[0xd835,0xdd39],
  "Breve;":0x2d8, "Bscr;":0x212c,
  "Bumpeq;":0x224e, "CHcy;":0x427,
  "COPY":0xa9, "COPY;":0xa9,
  "Cacute;":0x106, "Cap;":0x22d2,
  "CapitalDifferentialD;":0x2145, "Cayleys;":0x212d,
  "Ccaron;":0x10c, "Ccedil":0xc7,
  "Ccedil;":0xc7, "Ccirc;":0x108,
  "Cconint;":0x2230, "Cdot;":0x10a,
  "Cedilla;":0xb8, "CenterDot;":0xb7,
  "Cfr;":0x212d, "Chi;":0x3a7,
  "CircleDot;":0x2299, "CircleMinus;":0x2296,
  "CirclePlus;":0x2295, "CircleTimes;":0x2297,
  "ClockwiseContourIntegral;":0x2232, "CloseCurlyDoubleQuote;":0x201d,
  "CloseCurlyQuote;":0x2019, "Colon;":0x2237,
  "Colone;":0x2a74, "Congruent;":0x2261,
  "Conint;":0x222f, "ContourIntegral;":0x222e,
  "Copf;":0x2102, "Coproduct;":0x2210,
  "CounterClockwiseContourIntegral;":0x2233, "Cross;":0x2a2f,
  "Cscr;":[0xd835,0xdc9e], "Cup;":0x22d3,
  "CupCap;":0x224d, "DD;":0x2145,
  "DDotrahd;":0x2911, "DJcy;":0x402,
  "DScy;":0x405, "DZcy;":0x40f,
  "Dagger;":0x2021, "Darr;":0x21a1,
  "Dashv;":0x2ae4, "Dcaron;":0x10e,
  "Dcy;":0x414, "Del;":0x2207,
  "Delta;":0x394, "Dfr;":[0xd835,0xdd07],
  "DiacriticalAcute;":0xb4, "DiacriticalDot;":0x2d9,
  "DiacriticalDoubleAcute;":0x2dd, "DiacriticalGrave;":0x60,
  "DiacriticalTilde;":0x2dc, "Diamond;":0x22c4,
  "DifferentialD;":0x2146, "Dopf;":[0xd835,0xdd3b],
  "Dot;":0xa8, "DotDot;":0x20dc,
  "DotEqual;":0x2250, "DoubleContourIntegral;":0x222f,
  "DoubleDot;":0xa8, "DoubleDownArrow;":0x21d3,
  "DoubleLeftArrow;":0x21d0, "DoubleLeftRightArrow;":0x21d4,
  "DoubleLeftTee;":0x2ae4, "DoubleLongLeftArrow;":0x27f8,
  "DoubleLongLeftRightArrow;":0x27fa, "DoubleLongRightArrow;":0x27f9,
  "DoubleRightArrow;":0x21d2, "DoubleRightTee;":0x22a8,
  "DoubleUpArrow;":0x21d1, "DoubleUpDownArrow;":0x21d5,
  "DoubleVerticalBar;":0x2225, "DownArrow;":0x2193,
  "DownArrowBar;":0x2913, "DownArrowUpArrow;":0x21f5,
  "DownBreve;":0x311, "DownLeftRightVector;":0x2950,
  "DownLeftTeeVector;":0x295e, "DownLeftVector;":0x21bd,
  "DownLeftVectorBar;":0x2956, "DownRightTeeVector;":0x295f,
  "DownRightVector;":0x21c1, "DownRightVectorBar;":0x2957,
  "DownTee;":0x22a4, "DownTeeArrow;":0x21a7,
  "Downarrow;":0x21d3, "Dscr;":[0xd835,0xdc9f],
  "Dstrok;":0x110, "ENG;":0x14a,
  "ETH":0xd0, "ETH;":0xd0,
  "Eacute":0xc9, "Eacute;":0xc9,
  "Ecaron;":0x11a, "Ecirc":0xca,
  "Ecirc;":0xca, "Ecy;":0x42d,
  "Edot;":0x116, "Efr;":[0xd835,0xdd08],
  "Egrave":0xc8, "Egrave;":0xc8,
  "Element;":0x2208, "Emacr;":0x112,
  "EmptySmallSquare;":0x25fb, "EmptyVerySmallSquare;":0x25ab,
  "Eogon;":0x118, "Eopf;":[0xd835,0xdd3c],
  "Epsilon;":0x395, "Equal;":0x2a75,
  "EqualTilde;":0x2242, "Equilibrium;":0x21cc,
  "Escr;":0x2130, "Esim;":0x2a73,
  "Eta;":0x397, "Euml":0xcb,
  "Euml;":0xcb, "Exists;":0x2203,
  "ExponentialE;":0x2147, "Fcy;":0x424,
  "Ffr;":[0xd835,0xdd09], "FilledSmallSquare;":0x25fc,
  "FilledVerySmallSquare;":0x25aa, "Fopf;":[0xd835,0xdd3d],
  "ForAll;":0x2200, "Fouriertrf;":0x2131,
  "Fscr;":0x2131, "GJcy;":0x403,
  "GT":0x3e, "GT;":0x3e,
  "Gamma;":0x393, "Gammad;":0x3dc,
  "Gbreve;":0x11e, "Gcedil;":0x122,
  "Gcirc;":0x11c, "Gcy;":0x413,
  "Gdot;":0x120, "Gfr;":[0xd835,0xdd0a],
  "Gg;":0x22d9, "Gopf;":[0xd835,0xdd3e],
  "GreaterEqual;":0x2265, "GreaterEqualLess;":0x22db,
  "GreaterFullEqual;":0x2267, "GreaterGreater;":0x2aa2,
  "GreaterLess;":0x2277, "GreaterSlantEqual;":0x2a7e,
  "GreaterTilde;":0x2273, "Gscr;":[0xd835,0xdca2],
  "Gt;":0x226b, "HARDcy;":0x42a,
  "Hacek;":0x2c7, "Hat;":0x5e,
  "Hcirc;":0x124, "Hfr;":0x210c,
  "HilbertSpace;":0x210b, "Hopf;":0x210d,
  "HorizontalLine;":0x2500, "Hscr;":0x210b,
  "Hstrok;":0x126, "HumpDownHump;":0x224e,
  "HumpEqual;":0x224f, "IEcy;":0x415,
  "IJlig;":0x132, "IOcy;":0x401,
  "Iacute":0xcd, "Iacute;":0xcd,
  "Icirc":0xce, "Icirc;":0xce,
  "Icy;":0x418, "Idot;":0x130,
  "Ifr;":0x2111, "Igrave":0xcc,
  "Igrave;":0xcc, "Im;":0x2111,
  "Imacr;":0x12a, "ImaginaryI;":0x2148,
  "Implies;":0x21d2, "Int;":0x222c,
  "Integral;":0x222b, "Intersection;":0x22c2,
  "InvisibleComma;":0x2063, "InvisibleTimes;":0x2062,
  "Iogon;":0x12e, "Iopf;":[0xd835,0xdd40],
  "Iota;":0x399, "Iscr;":0x2110,
  "Itilde;":0x128, "Iukcy;":0x406,
  "Iuml":0xcf, "Iuml;":0xcf,
  "Jcirc;":0x134, "Jcy;":0x419,
  "Jfr;":[0xd835,0xdd0d], "Jopf;":[0xd835,0xdd41],
  "Jscr;":[0xd835,0xdca5], "Jsercy;":0x408,
  "Jukcy;":0x404, "KHcy;":0x425,
  "KJcy;":0x40c, "Kappa;":0x39a,
  "Kcedil;":0x136, "Kcy;":0x41a,
  "Kfr;":[0xd835,0xdd0e], "Kopf;":[0xd835,0xdd42],
  "Kscr;":[0xd835,0xdca6], "LJcy;":0x409,
  "LT":0x3c, "LT;":0x3c,
  "Lacute;":0x139, "Lambda;":0x39b,
  "Lang;":0x27ea, "Laplacetrf;":0x2112,
  "Larr;":0x219e, "Lcaron;":0x13d,
  "Lcedil;":0x13b, "Lcy;":0x41b,
  "LeftAngleBracket;":0x27e8, "LeftArrow;":0x2190,
  "LeftArrowBar;":0x21e4, "LeftArrowRightArrow;":0x21c6,
  "LeftCeiling;":0x2308, "LeftDoubleBracket;":0x27e6,
  "LeftDownTeeVector;":0x2961, "LeftDownVector;":0x21c3,
  "LeftDownVectorBar;":0x2959, "LeftFloor;":0x230a,
  "LeftRightArrow;":0x2194, "LeftRightVector;":0x294e,
  "LeftTee;":0x22a3, "LeftTeeArrow;":0x21a4,
  "LeftTeeVector;":0x295a, "LeftTriangle;":0x22b2,
  "LeftTriangleBar;":0x29cf, "LeftTriangleEqual;":0x22b4,
  "LeftUpDownVector;":0x2951, "LeftUpTeeVector;":0x2960,
  "LeftUpVector;":0x21bf, "LeftUpVectorBar;":0x2958,
  "LeftVector;":0x21bc, "LeftVectorBar;":0x2952,
  "Leftarrow;":0x21d0, "Leftrightarrow;":0x21d4,
  "LessEqualGreater;":0x22da, "LessFullEqual;":0x2266,
  "LessGreater;":0x2276, "LessLess;":0x2aa1,
  "LessSlantEqual;":0x2a7d, "LessTilde;":0x2272,
  "Lfr;":[0xd835,0xdd0f], "Ll;":0x22d8,
  "Lleftarrow;":0x21da, "Lmidot;":0x13f,
  "LongLeftArrow;":0x27f5, "LongLeftRightArrow;":0x27f7,
  "LongRightArrow;":0x27f6, "Longleftarrow;":0x27f8,
  "Longleftrightarrow;":0x27fa, "Longrightarrow;":0x27f9,
  "Lopf;":[0xd835,0xdd43], "LowerLeftArrow;":0x2199,
  "LowerRightArrow;":0x2198, "Lscr;":0x2112,
  "Lsh;":0x21b0, "Lstrok;":0x141,
  "Lt;":0x226a, "Map;":0x2905,
  "Mcy;":0x41c, "MediumSpace;":0x205f,
  "Mellintrf;":0x2133, "Mfr;":[0xd835,0xdd10],
  "MinusPlus;":0x2213, "Mopf;":[0xd835,0xdd44],
  "Mscr;":0x2133, "Mu;":0x39c,
  "NJcy;":0x40a, "Nacute;":0x143,
  "Ncaron;":0x147, "Ncedil;":0x145,
  "Ncy;":0x41d, "NegativeMediumSpace;":0x200b,
  "NegativeThickSpace;":0x200b, "NegativeThinSpace;":0x200b,
  "NegativeVeryThinSpace;":0x200b, "NestedGreaterGreater;":0x226b,
  "NestedLessLess;":0x226a, "NewLine;":0xa,
  "Nfr;":[0xd835,0xdd11], "NoBreak;":0x2060,
  "NonBreakingSpace;":0xa0, "Nopf;":0x2115,
  "Not;":0x2aec, "NotCongruent;":0x2262,
  "NotCupCap;":0x226d, "NotDoubleVerticalBar;":0x2226,
  "NotElement;":0x2209, "NotEqual;":0x2260,
  "NotEqualTilde;":[0x2242,0x338], "NotExists;":0x2204,
  "NotGreater;":0x226f, "NotGreaterEqual;":0x2271,
  "NotGreaterFullEqual;":[0x2267,0x338], "NotGreaterGreater;":[0x226b,0x338],
  "NotGreaterLess;":0x2279, "NotGreaterSlantEqual;":[0x2a7e,0x338],
  "NotGreaterTilde;":0x2275, "NotHumpDownHump;":[0x224e,0x338],
  "NotHumpEqual;":[0x224f,0x338], "NotLeftTriangle;":0x22ea,
  "NotLeftTriangleBar;":[0x29cf,0x338], "NotLeftTriangleEqual;":0x22ec,
  "NotLess;":0x226e, "NotLessEqual;":0x2270,
  "NotLessGreater;":0x2278, "NotLessLess;":[0x226a,0x338],
  "NotLessSlantEqual;":[0x2a7d,0x338], "NotLessTilde;":0x2274,
  "NotNestedGreaterGreater;":[0x2aa2,0x338], "NotNestedLessLess;":[0x2aa1,0x338],
  "NotPrecedes;":0x2280, "NotPrecedesEqual;":[0x2aaf,0x338],
  "NotPrecedesSlantEqual;":0x22e0, "NotReverseElement;":0x220c,
  "NotRightTriangle;":0x22eb, "NotRightTriangleBar;":[0x29d0,0x338],
  "NotRightTriangleEqual;":0x22ed, "NotSquareSubset;":[0x228f,0x338],
  "NotSquareSubsetEqual;":0x22e2, "NotSquareSuperset;":[0x2290,0x338],
  "NotSquareSupersetEqual;":0x22e3, "NotSubset;":[0x2282,0x20d2],
  "NotSubsetEqual;":0x2288, "NotSucceeds;":0x2281,
  "NotSucceedsEqual;":[0x2ab0,0x338], "NotSucceedsSlantEqual;":0x22e1,
  "NotSucceedsTilde;":[0x227f,0x338], "NotSuperset;":[0x2283,0x20d2],
  "NotSupersetEqual;":0x2289, "NotTilde;":0x2241,
  "NotTildeEqual;":0x2244, "NotTildeFullEqual;":0x2247,
  "NotTildeTilde;":0x2249, "NotVerticalBar;":0x2224,
  "Nscr;":[0xd835,0xdca9], "Ntilde":0xd1,
  "Ntilde;":0xd1, "Nu;":0x39d,
  "OElig;":0x152, "Oacute":0xd3,
  "Oacute;":0xd3, "Ocirc":0xd4,
  "Ocirc;":0xd4, "Ocy;":0x41e,
  "Odblac;":0x150, "Ofr;":[0xd835,0xdd12],
  "Ograve":0xd2, "Ograve;":0xd2,
  "Omacr;":0x14c, "Omega;":0x3a9,
  "Omicron;":0x39f, "Oopf;":[0xd835,0xdd46],
  "OpenCurlyDoubleQuote;":0x201c, "OpenCurlyQuote;":0x2018,
  "Or;":0x2a54, "Oscr;":[0xd835,0xdcaa],
  "Oslash":0xd8, "Oslash;":0xd8,
  "Otilde":0xd5, "Otilde;":0xd5,
  "Otimes;":0x2a37, "Ouml":0xd6,
  "Ouml;":0xd6, "OverBar;":0x203e,
  "OverBrace;":0x23de, "OverBracket;":0x23b4,
  "OverParenthesis;":0x23dc, "PartialD;":0x2202,
  "Pcy;":0x41f, "Pfr;":[0xd835,0xdd13],
  "Phi;":0x3a6, "Pi;":0x3a0,
  "PlusMinus;":0xb1, "Poincareplane;":0x210c,
  "Popf;":0x2119, "Pr;":0x2abb,
  "Precedes;":0x227a, "PrecedesEqual;":0x2aaf,
  "PrecedesSlantEqual;":0x227c, "PrecedesTilde;":0x227e,
  "Prime;":0x2033, "Product;":0x220f,
  "Proportion;":0x2237, "Proportional;":0x221d,
  "Pscr;":[0xd835,0xdcab], "Psi;":0x3a8,
  "QUOT":0x22, "QUOT;":0x22,
  "Qfr;":[0xd835,0xdd14], "Qopf;":0x211a,
  "Qscr;":[0xd835,0xdcac], "RBarr;":0x2910,
  "REG":0xae, "REG;":0xae,
  "Racute;":0x154, "Rang;":0x27eb,
  "Rarr;":0x21a0, "Rarrtl;":0x2916,
  "Rcaron;":0x158, "Rcedil;":0x156,
  "Rcy;":0x420, "Re;":0x211c,
  "ReverseElement;":0x220b, "ReverseEquilibrium;":0x21cb,
  "ReverseUpEquilibrium;":0x296f, "Rfr;":0x211c,
  "Rho;":0x3a1, "RightAngleBracket;":0x27e9,
  "RightArrow;":0x2192, "RightArrowBar;":0x21e5,
  "RightArrowLeftArrow;":0x21c4, "RightCeiling;":0x2309,
  "RightDoubleBracket;":0x27e7, "RightDownTeeVector;":0x295d,
  "RightDownVector;":0x21c2, "RightDownVectorBar;":0x2955,
  "RightFloor;":0x230b, "RightTee;":0x22a2,
  "RightTeeArrow;":0x21a6, "RightTeeVector;":0x295b,
  "RightTriangle;":0x22b3, "RightTriangleBar;":0x29d0,
  "RightTriangleEqual;":0x22b5, "RightUpDownVector;":0x294f,
  "RightUpTeeVector;":0x295c, "RightUpVector;":0x21be,
  "RightUpVectorBar;":0x2954, "RightVector;":0x21c0,
  "RightVectorBar;":0x2953, "Rightarrow;":0x21d2,
  "Ropf;":0x211d, "RoundImplies;":0x2970,
  "Rrightarrow;":0x21db, "Rscr;":0x211b,
  "Rsh;":0x21b1, "RuleDelayed;":0x29f4,
  "SHCHcy;":0x429, "SHcy;":0x428,
  "SOFTcy;":0x42c, "Sacute;":0x15a,
  "Sc;":0x2abc, "Scaron;":0x160,
  "Scedil;":0x15e, "Scirc;":0x15c,
  "Scy;":0x421, "Sfr;":[0xd835,0xdd16],
  "ShortDownArrow;":0x2193, "ShortLeftArrow;":0x2190,
  "ShortRightArrow;":0x2192, "ShortUpArrow;":0x2191,
  "Sigma;":0x3a3, "SmallCircle;":0x2218,
  "Sopf;":[0xd835,0xdd4a], "Sqrt;":0x221a,
  "Square;":0x25a1, "SquareIntersection;":0x2293,
  "SquareSubset;":0x228f, "SquareSubsetEqual;":0x2291,
  "SquareSuperset;":0x2290, "SquareSupersetEqual;":0x2292,
  "SquareUnion;":0x2294, "Sscr;":[0xd835,0xdcae],
  "Star;":0x22c6, "Sub;":0x22d0,
  "Subset;":0x22d0, "SubsetEqual;":0x2286,
  "Succeeds;":0x227b, "SucceedsEqual;":0x2ab0,
  "SucceedsSlantEqual;":0x227d, "SucceedsTilde;":0x227f,
  "SuchThat;":0x220b, "Sum;":0x2211,
  "Sup;":0x22d1, "Superset;":0x2283,
  "SupersetEqual;":0x2287, "Supset;":0x22d1,
  "THORN":0xde, "THORN;":0xde,
  "TRADE;":0x2122, "TSHcy;":0x40b,
  "TScy;":0x426, "Tab;":0x9,
  "Tau;":0x3a4, "Tcaron;":0x164,
  "Tcedil;":0x162, "Tcy;":0x422,
  "Tfr;":[0xd835,0xdd17], "Therefore;":0x2234,
  "Theta;":0x398, "ThickSpace;":[0x205f,0x200a],
  "ThinSpace;":0x2009, "Tilde;":0x223c,
  "TildeEqual;":0x2243, "TildeFullEqual;":0x2245,
  "TildeTilde;":0x2248, "Topf;":[0xd835,0xdd4b],
  "TripleDot;":0x20db, "Tscr;":[0xd835,0xdcaf],
  "Tstrok;":0x166, "Uacute":0xda,
  "Uacute;":0xda, "Uarr;":0x219f,
  "Uarrocir;":0x2949, "Ubrcy;":0x40e,
  "Ubreve;":0x16c, "Ucirc":0xdb,
  "Ucirc;":0xdb, "Ucy;":0x423,
  "Udblac;":0x170, "Ufr;":[0xd835,0xdd18],
  "Ugrave":0xd9, "Ugrave;":0xd9,
  "Umacr;":0x16a, "UnderBar;":0x5f,
  "UnderBrace;":0x23df, "UnderBracket;":0x23b5,
  "UnderParenthesis;":0x23dd, "Union;":0x22c3,
  "UnionPlus;":0x228e, "Uogon;":0x172,
  "Uopf;":[0xd835,0xdd4c], "UpArrow;":0x2191,
  "UpArrowBar;":0x2912, "UpArrowDownArrow;":0x21c5,
  "UpDownArrow;":0x2195, "UpEquilibrium;":0x296e,
  "UpTee;":0x22a5, "UpTeeArrow;":0x21a5,
  "Uparrow;":0x21d1, "Updownarrow;":0x21d5,
  "UpperLeftArrow;":0x2196, "UpperRightArrow;":0x2197,
  "Upsi;":0x3d2, "Upsilon;":0x3a5,
  "Uring;":0x16e, "Uscr;":[0xd835,0xdcb0],
  "Utilde;":0x168, "Uuml":0xdc,
  "Uuml;":0xdc, "VDash;":0x22ab,
  "Vbar;":0x2aeb, "Vcy;":0x412,
  "Vdash;":0x22a9, "Vdashl;":0x2ae6,
  "Vee;":0x22c1, "Verbar;":0x2016,
  "Vert;":0x2016, "VerticalBar;":0x2223,
  "VerticalLine;":0x7c, "VerticalSeparator;":0x2758,
  "VerticalTilde;":0x2240, "VeryThinSpace;":0x200a,
  "Vfr;":[0xd835,0xdd19], "Vopf;":[0xd835,0xdd4d],
  "Vscr;":[0xd835,0xdcb1], "Vvdash;":0x22aa,
  "Wcirc;":0x174, "Wedge;":0x22c0,
  "Wfr;":[0xd835,0xdd1a], "Wopf;":[0xd835,0xdd4e],
  "Wscr;":[0xd835,0xdcb2], "Xfr;":[0xd835,0xdd1b],
  "Xi;":0x39e, "Xopf;":[0xd835,0xdd4f],
  "Xscr;":[0xd835,0xdcb3], "YAcy;":0x42f,
  "YIcy;":0x407, "YUcy;":0x42e,
  "Yacute":0xdd, "Yacute;":0xdd,
  "Ycirc;":0x176, "Ycy;":0x42b,
  "Yfr;":[0xd835,0xdd1c], "Yopf;":[0xd835,0xdd50],
  "Yscr;":[0xd835,0xdcb4], "Yuml;":0x178,
  "ZHcy;":0x416, "Zacute;":0x179,
  "Zcaron;":0x17d, "Zcy;":0x417,
  "Zdot;":0x17b, "ZeroWidthSpace;":0x200b,
  "Zeta;":0x396, "Zfr;":0x2128,
  "Zopf;":0x2124, "Zscr;":[0xd835,0xdcb5],
  "aacute":0xe1, "aacute;":0xe1,
  "abreve;":0x103, "ac;":0x223e,
  "acE;":[0x223e,0x333], "acd;":0x223f,
  "acirc":0xe2, "acirc;":0xe2,
  "acute":0xb4, "acute;":0xb4,
  "acy;":0x430, "aelig":0xe6,
  "aelig;":0xe6, "af;":0x2061,
  "afr;":[0xd835,0xdd1e], "agrave":0xe0,
  "agrave;":0xe0, "alefsym;":0x2135,
  "aleph;":0x2135, "alpha;":0x3b1,
  "amacr;":0x101, "amalg;":0x2a3f,
  "amp":0x26, "amp;":0x26,
  "and;":0x2227, "andand;":0x2a55,
  "andd;":0x2a5c, "andslope;":0x2a58,
  "andv;":0x2a5a, "ang;":0x2220,
  "ange;":0x29a4, "angle;":0x2220,
  "angmsd;":0x2221, "angmsdaa;":0x29a8,
  "angmsdab;":0x29a9, "angmsdac;":0x29aa,
  "angmsdad;":0x29ab, "angmsdae;":0x29ac,
  "angmsdaf;":0x29ad, "angmsdag;":0x29ae,
  "angmsdah;":0x29af, "angrt;":0x221f,
  "angrtvb;":0x22be, "angrtvbd;":0x299d,
  "angsph;":0x2222, "angst;":0xc5,
  "angzarr;":0x237c, "aogon;":0x105,
  "aopf;":[0xd835,0xdd52], "ap;":0x2248,
  "apE;":0x2a70, "apacir;":0x2a6f,
  "ape;":0x224a, "apid;":0x224b,
  "apos;":0x27, "approx;":0x2248,
  "approxeq;":0x224a, "aring":0xe5,
  "aring;":0xe5, "ascr;":[0xd835,0xdcb6],
  "ast;":0x2a, "asymp;":0x2248,
  "asympeq;":0x224d, "atilde":0xe3,
  "atilde;":0xe3, "auml":0xe4,
  "auml;":0xe4, "awconint;":0x2233,
  "awint;":0x2a11, "bNot;":0x2aed,
  "backcong;":0x224c, "backepsilon;":0x3f6,
  "backprime;":0x2035, "backsim;":0x223d,
  "backsimeq;":0x22cd, "barvee;":0x22bd,
  "barwed;":0x2305, "barwedge;":0x2305,
  "bbrk;":0x23b5, "bbrktbrk;":0x23b6,
  "bcong;":0x224c, "bcy;":0x431,
  "bdquo;":0x201e, "becaus;":0x2235,
  "because;":0x2235, "bemptyv;":0x29b0,
  "bepsi;":0x3f6, "bernou;":0x212c,
  "beta;":0x3b2, "beth;":0x2136,
  "between;":0x226c, "bfr;":[0xd835,0xdd1f],
  "bigcap;":0x22c2, "bigcirc;":0x25ef,
  "bigcup;":0x22c3, "bigodot;":0x2a00,
  "bigoplus;":0x2a01, "bigotimes;":0x2a02,
  "bigsqcup;":0x2a06, "bigstar;":0x2605,
  "bigtriangledown;":0x25bd, "bigtriangleup;":0x25b3,
  "biguplus;":0x2a04, "bigvee;":0x22c1,
  "bigwedge;":0x22c0, "bkarow;":0x290d,
  "blacklozenge;":0x29eb, "blacksquare;":0x25aa,
  "blacktriangle;":0x25b4, "blacktriangledown;":0x25be,
  "blacktriangleleft;":0x25c2, "blacktriangleright;":0x25b8,
  "blank;":0x2423, "blk12;":0x2592,
  "blk14;":0x2591, "blk34;":0x2593,
  "block;":0x2588, "bne;":[0x3d,0x20e5],
  "bnequiv;":[0x2261,0x20e5], "bnot;":0x2310,
  "bopf;":[0xd835,0xdd53], "bot;":0x22a5,
  "bottom;":0x22a5, "bowtie;":0x22c8,
  "boxDL;":0x2557, "boxDR;":0x2554,
  "boxDl;":0x2556, "boxDr;":0x2553,
  "boxH;":0x2550, "boxHD;":0x2566,
  "boxHU;":0x2569, "boxHd;":0x2564,
  "boxHu;":0x2567, "boxUL;":0x255d,
  "boxUR;":0x255a, "boxUl;":0x255c,
  "boxUr;":0x2559, "boxV;":0x2551,
  "boxVH;":0x256c, "boxVL;":0x2563,
  "boxVR;":0x2560, "boxVh;":0x256b,
  "boxVl;":0x2562, "boxVr;":0x255f,
  "boxbox;":0x29c9, "boxdL;":0x2555,
  "boxdR;":0x2552, "boxdl;":0x2510,
  "boxdr;":0x250c, "boxh;":0x2500,
  "boxhD;":0x2565, "boxhU;":0x2568,
  "boxhd;":0x252c, "boxhu;":0x2534,
  "boxminus;":0x229f, "boxplus;":0x229e,
  "boxtimes;":0x22a0, "boxuL;":0x255b,
  "boxuR;":0x2558, "boxul;":0x2518,
  "boxur;":0x2514, "boxv;":0x2502,
  "boxvH;":0x256a, "boxvL;":0x2561,
  "boxvR;":0x255e, "boxvh;":0x253c,
  "boxvl;":0x2524, "boxvr;":0x251c,
  "bprime;":0x2035, "breve;":0x2d8,
  "brvbar":0xa6, "brvbar;":0xa6,
  "bscr;":[0xd835,0xdcb7], "bsemi;":0x204f,
  "bsim;":0x223d, "bsime;":0x22cd,
  "bsol;":0x5c, "bsolb;":0x29c5,
  "bsolhsub;":0x27c8, "bull;":0x2022,
  "bullet;":0x2022, "bump;":0x224e,
  "bumpE;":0x2aae, "bumpe;":0x224f,
  "bumpeq;":0x224f, "cacute;":0x107,
  "cap;":0x2229, "capand;":0x2a44,
  "capbrcup;":0x2a49, "capcap;":0x2a4b,
  "capcup;":0x2a47, "capdot;":0x2a40,
  "caps;":[0x2229,0xfe00], "caret;":0x2041,
  "caron;":0x2c7, "ccaps;":0x2a4d,
  "ccaron;":0x10d, "ccedil":0xe7,
  "ccedil;":0xe7, "ccirc;":0x109,
  "ccups;":0x2a4c, "ccupssm;":0x2a50,
  "cdot;":0x10b, "cedil":0xb8,
  "cedil;":0xb8, "cemptyv;":0x29b2,
  "cent":0xa2, "cent;":0xa2,
  "centerdot;":0xb7, "cfr;":[0xd835,0xdd20],
  "chcy;":0x447, "check;":0x2713,
  "checkmark;":0x2713, "chi;":0x3c7,
  "cir;":0x25cb, "cirE;":0x29c3,
  "circ;":0x2c6, "circeq;":0x2257,
  "circlearrowleft;":0x21ba, "circlearrowright;":0x21bb,
  "circledR;":0xae, "circledS;":0x24c8,
  "circledast;":0x229b, "circledcirc;":0x229a,
  "circleddash;":0x229d, "cire;":0x2257,
  "cirfnint;":0x2a10, "cirmid;":0x2aef,
  "cirscir;":0x29c2, "clubs;":0x2663,
  "clubsuit;":0x2663, "colon;":0x3a,
  "colone;":0x2254, "coloneq;":0x2254,
  "comma;":0x2c, "commat;":0x40,
  "comp;":0x2201, "compfn;":0x2218,
  "complement;":0x2201, "complexes;":0x2102,
  "cong;":0x2245, "congdot;":0x2a6d,
  "conint;":0x222e, "copf;":[0xd835,0xdd54],
  "coprod;":0x2210, "copy":0xa9,
  "copy;":0xa9, "copysr;":0x2117,
  "crarr;":0x21b5, "cross;":0x2717,
  "cscr;":[0xd835,0xdcb8], "csub;":0x2acf,
  "csube;":0x2ad1, "csup;":0x2ad0,
  "csupe;":0x2ad2, "ctdot;":0x22ef,
  "cudarrl;":0x2938, "cudarrr;":0x2935,
  "cuepr;":0x22de, "cuesc;":0x22df,
  "cularr;":0x21b6, "cularrp;":0x293d,
  "cup;":0x222a, "cupbrcap;":0x2a48,
  "cupcap;":0x2a46, "cupcup;":0x2a4a,
  "cupdot;":0x228d, "cupor;":0x2a45,
  "cups;":[0x222a,0xfe00], "curarr;":0x21b7,
  "curarrm;":0x293c, "curlyeqprec;":0x22de,
  "curlyeqsucc;":0x22df, "curlyvee;":0x22ce,
  "curlywedge;":0x22cf, "curren":0xa4,
  "curren;":0xa4, "curvearrowleft;":0x21b6,
  "curvearrowright;":0x21b7, "cuvee;":0x22ce,
  "cuwed;":0x22cf, "cwconint;":0x2232,
  "cwint;":0x2231, "cylcty;":0x232d,
  "dArr;":0x21d3, "dHar;":0x2965,
  "dagger;":0x2020, "daleth;":0x2138,
  "darr;":0x2193, "dash;":0x2010,
  "dashv;":0x22a3, "dbkarow;":0x290f,
  "dblac;":0x2dd, "dcaron;":0x10f,
  "dcy;":0x434, "dd;":0x2146,
  "ddagger;":0x2021, "ddarr;":0x21ca,
  "ddotseq;":0x2a77, "deg":0xb0,
  "deg;":0xb0, "delta;":0x3b4,
  "demptyv;":0x29b1, "dfisht;":0x297f,
  "dfr;":[0xd835,0xdd21], "dharl;":0x21c3,
  "dharr;":0x21c2, "diam;":0x22c4,
  "diamond;":0x22c4, "diamondsuit;":0x2666,
  "diams;":0x2666, "die;":0xa8,
  "digamma;":0x3dd, "disin;":0x22f2,
  "div;":0xf7, "divide":0xf7,
  "divide;":0xf7, "divideontimes;":0x22c7,
  "divonx;":0x22c7, "djcy;":0x452,
  "dlcorn;":0x231e, "dlcrop;":0x230d,
  "dollar;":0x24, "dopf;":[0xd835,0xdd55],
  "dot;":0x2d9, "doteq;":0x2250,
  "doteqdot;":0x2251, "dotminus;":0x2238,
  "dotplus;":0x2214, "dotsquare;":0x22a1,
  "doublebarwedge;":0x2306, "downarrow;":0x2193,
  "downdownarrows;":0x21ca, "downharpoonleft;":0x21c3,
  "downharpoonright;":0x21c2, "drbkarow;":0x2910,
  "drcorn;":0x231f, "drcrop;":0x230c,
  "dscr;":[0xd835,0xdcb9], "dscy;":0x455,
  "dsol;":0x29f6, "dstrok;":0x111,
  "dtdot;":0x22f1, "dtri;":0x25bf,
  "dtrif;":0x25be, "duarr;":0x21f5,
  "duhar;":0x296f, "dwangle;":0x29a6,
  "dzcy;":0x45f, "dzigrarr;":0x27ff,
  "eDDot;":0x2a77, "eDot;":0x2251,
  "eacute":0xe9, "eacute;":0xe9,
  "easter;":0x2a6e, "ecaron;":0x11b,
  "ecir;":0x2256, "ecirc":0xea,
  "ecirc;":0xea, "ecolon;":0x2255,
  "ecy;":0x44d, "edot;":0x117,
  "ee;":0x2147, "efDot;":0x2252,
  "efr;":[0xd835,0xdd22], "eg;":0x2a9a,
  "egrave":0xe8, "egrave;":0xe8,
  "egs;":0x2a96, "egsdot;":0x2a98,
  "el;":0x2a99, "elinters;":0x23e7,
  "ell;":0x2113, "els;":0x2a95,
  "elsdot;":0x2a97, "emacr;":0x113,
  "empty;":0x2205, "emptyset;":0x2205,
  "emptyv;":0x2205, "emsp13;":0x2004,
  "emsp14;":0x2005, "emsp;":0x2003,
  "eng;":0x14b, "ensp;":0x2002,
  "eogon;":0x119, "eopf;":[0xd835,0xdd56],
  "epar;":0x22d5, "eparsl;":0x29e3,
  "eplus;":0x2a71, "epsi;":0x3b5,
  "epsilon;":0x3b5, "epsiv;":0x3f5,
  "eqcirc;":0x2256, "eqcolon;":0x2255,
  "eqsim;":0x2242, "eqslantgtr;":0x2a96,
  "eqslantless;":0x2a95, "equals;":0x3d,
  "equest;":0x225f, "equiv;":0x2261,
  "equivDD;":0x2a78, "eqvparsl;":0x29e5,
  "erDot;":0x2253, "erarr;":0x2971,
  "escr;":0x212f, "esdot;":0x2250,
  "esim;":0x2242, "eta;":0x3b7,
  "eth":0xf0, "eth;":0xf0,
  "euml":0xeb, "euml;":0xeb,
  "euro;":0x20ac, "excl;":0x21,
  "exist;":0x2203, "expectation;":0x2130,
  "exponentiale;":0x2147, "fallingdotseq;":0x2252,
  "fcy;":0x444, "female;":0x2640,
  "ffilig;":0xfb03, "fflig;":0xfb00,
  "ffllig;":0xfb04, "ffr;":[0xd835,0xdd23],
  "filig;":0xfb01, "fjlig;":[0x66,0x6a],
  "flat;":0x266d, "fllig;":0xfb02,
  "fltns;":0x25b1, "fnof;":0x192,
  "fopf;":[0xd835,0xdd57], "forall;":0x2200,
  "fork;":0x22d4, "forkv;":0x2ad9,
  "fpartint;":0x2a0d, "frac12":0xbd,
  "frac12;":0xbd, "frac13;":0x2153,
  "frac14":0xbc, "frac14;":0xbc,
  "frac15;":0x2155, "frac16;":0x2159,
  "frac18;":0x215b, "frac23;":0x2154,
  "frac25;":0x2156, "frac34":0xbe,
  "frac34;":0xbe, "frac35;":0x2157,
  "frac38;":0x215c, "frac45;":0x2158,
  "frac56;":0x215a, "frac58;":0x215d,
  "frac78;":0x215e, "frasl;":0x2044,
  "frown;":0x2322, "fscr;":[0xd835,0xdcbb],
  "gE;":0x2267, "gEl;":0x2a8c,
  "gacute;":0x1f5, "gamma;":0x3b3,
  "gammad;":0x3dd, "gap;":0x2a86,
  "gbreve;":0x11f, "gcirc;":0x11d,
  "gcy;":0x433, "gdot;":0x121,
  "ge;":0x2265, "gel;":0x22db,
  "geq;":0x2265, "geqq;":0x2267,
  "geqslant;":0x2a7e, "ges;":0x2a7e,
  "gescc;":0x2aa9, "gesdot;":0x2a80,
  "gesdoto;":0x2a82, "gesdotol;":0x2a84,
  "gesl;":[0x22db,0xfe00], "gesles;":0x2a94,
  "gfr;":[0xd835,0xdd24], "gg;":0x226b,
  "ggg;":0x22d9, "gimel;":0x2137,
  "gjcy;":0x453, "gl;":0x2277,
  "glE;":0x2a92, "gla;":0x2aa5,
  "glj;":0x2aa4, "gnE;":0x2269,
  "gnap;":0x2a8a, "gnapprox;":0x2a8a,
  "gne;":0x2a88, "gneq;":0x2a88,
  "gneqq;":0x2269, "gnsim;":0x22e7,
  "gopf;":[0xd835,0xdd58], "grave;":0x60,
  "gscr;":0x210a, "gsim;":0x2273,
  "gsime;":0x2a8e, "gsiml;":0x2a90,
  "gt":0x3e, "gt;":0x3e,
  "gtcc;":0x2aa7, "gtcir;":0x2a7a,
  "gtdot;":0x22d7, "gtlPar;":0x2995,
  "gtquest;":0x2a7c, "gtrapprox;":0x2a86,
  "gtrarr;":0x2978, "gtrdot;":0x22d7,
  "gtreqless;":0x22db, "gtreqqless;":0x2a8c,
  "gtrless;":0x2277, "gtrsim;":0x2273,
  "gvertneqq;":[0x2269,0xfe00], "gvnE;":[0x2269,0xfe00],
  "hArr;":0x21d4, "hairsp;":0x200a,
  "half;":0xbd, "hamilt;":0x210b,
  "hardcy;":0x44a, "harr;":0x2194,
  "harrcir;":0x2948, "harrw;":0x21ad,
  "hbar;":0x210f, "hcirc;":0x125,
  "hearts;":0x2665, "heartsuit;":0x2665,
  "hellip;":0x2026, "hercon;":0x22b9,
  "hfr;":[0xd835,0xdd25], "hksearow;":0x2925,
  "hkswarow;":0x2926, "hoarr;":0x21ff,
  "homtht;":0x223b, "hookleftarrow;":0x21a9,
  "hookrightarrow;":0x21aa, "hopf;":[0xd835,0xdd59],
  "horbar;":0x2015, "hscr;":[0xd835,0xdcbd],
  "hslash;":0x210f, "hstrok;":0x127,
  "hybull;":0x2043, "hyphen;":0x2010,
  "iacute":0xed, "iacute;":0xed,
  "ic;":0x2063, "icirc":0xee,
  "icirc;":0xee, "icy;":0x438,
  "iecy;":0x435, "iexcl":0xa1,
  "iexcl;":0xa1, "iff;":0x21d4,
  "ifr;":[0xd835,0xdd26], "igrave":0xec,
  "igrave;":0xec, "ii;":0x2148,
  "iiiint;":0x2a0c, "iiint;":0x222d,
  "iinfin;":0x29dc, "iiota;":0x2129,
  "ijlig;":0x133, "imacr;":0x12b,
  "image;":0x2111, "imagline;":0x2110,
  "imagpart;":0x2111, "imath;":0x131,
  "imof;":0x22b7, "imped;":0x1b5,
  "in;":0x2208, "incare;":0x2105,
  "infin;":0x221e, "infintie;":0x29dd,
  "inodot;":0x131, "int;":0x222b,
  "intcal;":0x22ba, "integers;":0x2124,
  "intercal;":0x22ba, "intlarhk;":0x2a17,
  "intprod;":0x2a3c, "iocy;":0x451,
  "iogon;":0x12f, "iopf;":[0xd835,0xdd5a],
  "iota;":0x3b9, "iprod;":0x2a3c,
  "iquest":0xbf, "iquest;":0xbf,
  "iscr;":[0xd835,0xdcbe], "isin;":0x2208,
  "isinE;":0x22f9, "isindot;":0x22f5,
  "isins;":0x22f4, "isinsv;":0x22f3,
  "isinv;":0x2208, "it;":0x2062,
  "itilde;":0x129, "iukcy;":0x456,
  "iuml":0xef, "iuml;":0xef,
  "jcirc;":0x135, "jcy;":0x439,
  "jfr;":[0xd835,0xdd27], "jmath;":0x237,
  "jopf;":[0xd835,0xdd5b], "jscr;":[0xd835,0xdcbf],
  "jsercy;":0x458, "jukcy;":0x454,
  "kappa;":0x3ba, "kappav;":0x3f0,
  "kcedil;":0x137, "kcy;":0x43a,
  "kfr;":[0xd835,0xdd28], "kgreen;":0x138,
  "khcy;":0x445, "kjcy;":0x45c,
  "kopf;":[0xd835,0xdd5c], "kscr;":[0xd835,0xdcc0],
  "lAarr;":0x21da, "lArr;":0x21d0,
  "lAtail;":0x291b, "lBarr;":0x290e,
  "lE;":0x2266, "lEg;":0x2a8b,
  "lHar;":0x2962, "lacute;":0x13a,
  "laemptyv;":0x29b4, "lagran;":0x2112,
  "lambda;":0x3bb, "lang;":0x27e8,
  "langd;":0x2991, "langle;":0x27e8,
  "lap;":0x2a85, "laquo":0xab,
  "laquo;":0xab, "larr;":0x2190,
  "larrb;":0x21e4, "larrbfs;":0x291f,
  "larrfs;":0x291d, "larrhk;":0x21a9,
  "larrlp;":0x21ab, "larrpl;":0x2939,
  "larrsim;":0x2973, "larrtl;":0x21a2,
  "lat;":0x2aab, "latail;":0x2919,
  "late;":0x2aad, "lates;":[0x2aad,0xfe00],
  "lbarr;":0x290c, "lbbrk;":0x2772,
  "lbrace;":0x7b, "lbrack;":0x5b,
  "lbrke;":0x298b, "lbrksld;":0x298f,
  "lbrkslu;":0x298d, "lcaron;":0x13e,
  "lcedil;":0x13c, "lceil;":0x2308,
  "lcub;":0x7b, "lcy;":0x43b,
  "ldca;":0x2936, "ldquo;":0x201c,
  "ldquor;":0x201e, "ldrdhar;":0x2967,
  "ldrushar;":0x294b, "ldsh;":0x21b2,
  "le;":0x2264, "leftarrow;":0x2190,
  "leftarrowtail;":0x21a2, "leftharpoondown;":0x21bd,
  "leftharpoonup;":0x21bc, "leftleftarrows;":0x21c7,
  "leftrightarrow;":0x2194, "leftrightarrows;":0x21c6,
  "leftrightharpoons;":0x21cb, "leftrightsquigarrow;":0x21ad,
  "leftthreetimes;":0x22cb, "leg;":0x22da,
  "leq;":0x2264, "leqq;":0x2266,
  "leqslant;":0x2a7d, "les;":0x2a7d,
  "lescc;":0x2aa8, "lesdot;":0x2a7f,
  "lesdoto;":0x2a81, "lesdotor;":0x2a83,
  "lesg;":[0x22da,0xfe00], "lesges;":0x2a93,
  "lessapprox;":0x2a85, "lessdot;":0x22d6,
  "lesseqgtr;":0x22da, "lesseqqgtr;":0x2a8b,
  "lessgtr;":0x2276, "lesssim;":0x2272,
  "lfisht;":0x297c, "lfloor;":0x230a,
  "lfr;":[0xd835,0xdd29], "lg;":0x2276,
  "lgE;":0x2a91, "lhard;":0x21bd,
  "lharu;":0x21bc, "lharul;":0x296a,
  "lhblk;":0x2584, "ljcy;":0x459,
  "ll;":0x226a, "llarr;":0x21c7,
  "llcorner;":0x231e, "llhard;":0x296b,
  "lltri;":0x25fa, "lmidot;":0x140,
  "lmoust;":0x23b0, "lmoustache;":0x23b0,
  "lnE;":0x2268, "lnap;":0x2a89,
  "lnapprox;":0x2a89, "lne;":0x2a87,
  "lneq;":0x2a87, "lneqq;":0x2268,
  "lnsim;":0x22e6, "loang;":0x27ec,
  "loarr;":0x21fd, "lobrk;":0x27e6,
  "longleftarrow;":0x27f5, "longleftrightarrow;":0x27f7,
  "longmapsto;":0x27fc, "longrightarrow;":0x27f6,
  "looparrowleft;":0x21ab, "looparrowright;":0x21ac,
  "lopar;":0x2985, "lopf;":[0xd835,0xdd5d],
  "loplus;":0x2a2d, "lotimes;":0x2a34,
  "lowast;":0x2217, "lowbar;":0x5f,
  "loz;":0x25ca, "lozenge;":0x25ca,
  "lozf;":0x29eb, "lpar;":0x28,
  "lparlt;":0x2993, "lrarr;":0x21c6,
  "lrcorner;":0x231f, "lrhar;":0x21cb,
  "lrhard;":0x296d, "lrm;":0x200e,
  "lrtri;":0x22bf, "lsaquo;":0x2039,
  "lscr;":[0xd835,0xdcc1], "lsh;":0x21b0,
  "lsim;":0x2272, "lsime;":0x2a8d,
  "lsimg;":0x2a8f, "lsqb;":0x5b,
  "lsquo;":0x2018, "lsquor;":0x201a,
  "lstrok;":0x142, "lt":0x3c,
  "lt;":0x3c, "ltcc;":0x2aa6,
  "ltcir;":0x2a79, "ltdot;":0x22d6,
  "lthree;":0x22cb, "ltimes;":0x22c9,
  "ltlarr;":0x2976, "ltquest;":0x2a7b,
  "ltrPar;":0x2996, "ltri;":0x25c3,
  "ltrie;":0x22b4, "ltrif;":0x25c2,
  "lurdshar;":0x294a, "luruhar;":0x2966,
  "lvertneqq;":[0x2268,0xfe00], "lvnE;":[0x2268,0xfe00],
  "mDDot;":0x223a, "macr":0xaf,
  "macr;":0xaf, "male;":0x2642,
  "malt;":0x2720, "maltese;":0x2720,
  "map;":0x21a6, "mapsto;":0x21a6,
  "mapstodown;":0x21a7, "mapstoleft;":0x21a4,
  "mapstoup;":0x21a5, "marker;":0x25ae,
  "mcomma;":0x2a29, "mcy;":0x43c,
  "mdash;":0x2014, "measuredangle;":0x2221,
  "mfr;":[0xd835,0xdd2a], "mho;":0x2127,
  "micro":0xb5, "micro;":0xb5,
  "mid;":0x2223, "midast;":0x2a,
  "midcir;":0x2af0, "middot":0xb7,
  "middot;":0xb7, "minus;":0x2212,
  "minusb;":0x229f, "minusd;":0x2238,
  "minusdu;":0x2a2a, "mlcp;":0x2adb,
  "mldr;":0x2026, "mnplus;":0x2213,
  "models;":0x22a7, "mopf;":[0xd835,0xdd5e],
  "mp;":0x2213, "mscr;":[0xd835,0xdcc2],
  "mstpos;":0x223e, "mu;":0x3bc,
  "multimap;":0x22b8, "mumap;":0x22b8,
  "nGg;":[0x22d9,0x338], "nGt;":[0x226b,0x20d2],
  "nGtv;":[0x226b,0x338], "nLeftarrow;":0x21cd,
  "nLeftrightarrow;":0x21ce, "nLl;":[0x22d8,0x338],
  "nLt;":[0x226a,0x20d2], "nLtv;":[0x226a,0x338],
  "nRightarrow;":0x21cf, "nVDash;":0x22af,
  "nVdash;":0x22ae, "nabla;":0x2207,
  "nacute;":0x144, "nang;":[0x2220,0x20d2],
  "nap;":0x2249, "napE;":[0x2a70,0x338],
  "napid;":[0x224b,0x338], "napos;":0x149,
  "napprox;":0x2249, "natur;":0x266e,
  "natural;":0x266e, "naturals;":0x2115,
  "nbsp":0xa0, "nbsp;":0xa0,
  "nbump;":[0x224e,0x338], "nbumpe;":[0x224f,0x338],
  "ncap;":0x2a43, "ncaron;":0x148,
  "ncedil;":0x146, "ncong;":0x2247,
  "ncongdot;":[0x2a6d,0x338], "ncup;":0x2a42,
  "ncy;":0x43d, "ndash;":0x2013,
  "ne;":0x2260, "neArr;":0x21d7,
  "nearhk;":0x2924, "nearr;":0x2197,
  "nearrow;":0x2197, "nedot;":[0x2250,0x338],
  "nequiv;":0x2262, "nesear;":0x2928,
  "nesim;":[0x2242,0x338], "nexist;":0x2204,
  "nexists;":0x2204, "nfr;":[0xd835,0xdd2b],
  "ngE;":[0x2267,0x338], "nge;":0x2271,
  "ngeq;":0x2271, "ngeqq;":[0x2267,0x338],
  "ngeqslant;":[0x2a7e,0x338], "nges;":[0x2a7e,0x338],
  "ngsim;":0x2275, "ngt;":0x226f,
  "ngtr;":0x226f, "nhArr;":0x21ce,
  "nharr;":0x21ae, "nhpar;":0x2af2,
  "ni;":0x220b, "nis;":0x22fc,
  "nisd;":0x22fa, "niv;":0x220b,
  "njcy;":0x45a, "nlArr;":0x21cd,
  "nlE;":[0x2266,0x338], "nlarr;":0x219a,
  "nldr;":0x2025, "nle;":0x2270,
  "nleftarrow;":0x219a, "nleftrightarrow;":0x21ae,
  "nleq;":0x2270, "nleqq;":[0x2266,0x338],
  "nleqslant;":[0x2a7d,0x338], "nles;":[0x2a7d,0x338],
  "nless;":0x226e, "nlsim;":0x2274,
  "nlt;":0x226e, "nltri;":0x22ea,
  "nltrie;":0x22ec, "nmid;":0x2224,
  "nopf;":[0xd835,0xdd5f], "not":0xac,
  "not;":0xac, "notin;":0x2209,
  "notinE;":[0x22f9,0x338], "notindot;":[0x22f5,0x338],
  "notinva;":0x2209, "notinvb;":0x22f7,
  "notinvc;":0x22f6, "notni;":0x220c,
  "notniva;":0x220c, "notnivb;":0x22fe,
  "notnivc;":0x22fd, "npar;":0x2226,
  "nparallel;":0x2226, "nparsl;":[0x2afd,0x20e5],
  "npart;":[0x2202,0x338], "npolint;":0x2a14,
  "npr;":0x2280, "nprcue;":0x22e0,
  "npre;":[0x2aaf,0x338], "nprec;":0x2280,
  "npreceq;":[0x2aaf,0x338], "nrArr;":0x21cf,
  "nrarr;":0x219b, "nrarrc;":[0x2933,0x338],
  "nrarrw;":[0x219d,0x338], "nrightarrow;":0x219b,
  "nrtri;":0x22eb, "nrtrie;":0x22ed,
  "nsc;":0x2281, "nsccue;":0x22e1,
  "nsce;":[0x2ab0,0x338], "nscr;":[0xd835,0xdcc3],
  "nshortmid;":0x2224, "nshortparallel;":0x2226,
  "nsim;":0x2241, "nsime;":0x2244,
  "nsimeq;":0x2244, "nsmid;":0x2224,
  "nspar;":0x2226, "nsqsube;":0x22e2,
  "nsqsupe;":0x22e3, "nsub;":0x2284,
  "nsubE;":[0x2ac5,0x338], "nsube;":0x2288,
  "nsubset;":[0x2282,0x20d2], "nsubseteq;":0x2288,
  "nsubseteqq;":[0x2ac5,0x338], "nsucc;":0x2281,
  "nsucceq;":[0x2ab0,0x338], "nsup;":0x2285,
  "nsupE;":[0x2ac6,0x338], "nsupe;":0x2289,
  "nsupset;":[0x2283,0x20d2], "nsupseteq;":0x2289,
  "nsupseteqq;":[0x2ac6,0x338], "ntgl;":0x2279,
  "ntilde":0xf1, "ntilde;":0xf1,
  "ntlg;":0x2278, "ntriangleleft;":0x22ea,
  "ntrianglelefteq;":0x22ec, "ntriangleright;":0x22eb,
  "ntrianglerighteq;":0x22ed, "nu;":0x3bd,
  "num;":0x23, "numero;":0x2116,
  "numsp;":0x2007, "nvDash;":0x22ad,
  "nvHarr;":0x2904, "nvap;":[0x224d,0x20d2],
  "nvdash;":0x22ac, "nvge;":[0x2265,0x20d2],
  "nvgt;":[0x3e,0x20d2], "nvinfin;":0x29de,
  "nvlArr;":0x2902, "nvle;":[0x2264,0x20d2],
  "nvlt;":[0x3c,0x20d2], "nvltrie;":[0x22b4,0x20d2],
  "nvrArr;":0x2903, "nvrtrie;":[0x22b5,0x20d2],
  "nvsim;":[0x223c,0x20d2], "nwArr;":0x21d6,
  "nwarhk;":0x2923, "nwarr;":0x2196,
  "nwarrow;":0x2196, "nwnear;":0x2927,
  "oS;":0x24c8, "oacute":0xf3,
  "oacute;":0xf3, "oast;":0x229b,
  "ocir;":0x229a, "ocirc":0xf4,
  "ocirc;":0xf4, "ocy;":0x43e,
  "odash;":0x229d, "odblac;":0x151,
  "odiv;":0x2a38, "odot;":0x2299,
  "odsold;":0x29bc, "oelig;":0x153,
  "ofcir;":0x29bf, "ofr;":[0xd835,0xdd2c],
  "ogon;":0x2db, "ograve":0xf2,
  "ograve;":0xf2, "ogt;":0x29c1,
  "ohbar;":0x29b5, "ohm;":0x3a9,
  "oint;":0x222e, "olarr;":0x21ba,
  "olcir;":0x29be, "olcross;":0x29bb,
  "oline;":0x203e, "olt;":0x29c0,
  "omacr;":0x14d, "omega;":0x3c9,
  "omicron;":0x3bf, "omid;":0x29b6,
  "ominus;":0x2296, "oopf;":[0xd835,0xdd60],
  "opar;":0x29b7, "operp;":0x29b9,
  "oplus;":0x2295, "or;":0x2228,
  "orarr;":0x21bb, "ord;":0x2a5d,
  "order;":0x2134, "orderof;":0x2134,
  "ordf":0xaa, "ordf;":0xaa,
  "ordm":0xba, "ordm;":0xba,
  "origof;":0x22b6, "oror;":0x2a56,
  "orslope;":0x2a57, "orv;":0x2a5b,
  "oscr;":0x2134, "oslash":0xf8,
  "oslash;":0xf8, "osol;":0x2298,
  "otilde":0xf5, "otilde;":0xf5,
  "otimes;":0x2297, "otimesas;":0x2a36,
  "ouml":0xf6, "ouml;":0xf6,
  "ovbar;":0x233d, "par;":0x2225,
  "para":0xb6, "para;":0xb6,
  "parallel;":0x2225, "parsim;":0x2af3,
  "parsl;":0x2afd, "part;":0x2202,
  "pcy;":0x43f, "percnt;":0x25,
  "period;":0x2e, "permil;":0x2030,
  "perp;":0x22a5, "pertenk;":0x2031,
  "pfr;":[0xd835,0xdd2d], "phi;":0x3c6,
  "phiv;":0x3d5, "phmmat;":0x2133,
  "phone;":0x260e, "pi;":0x3c0,
  "pitchfork;":0x22d4, "piv;":0x3d6,
  "planck;":0x210f, "planckh;":0x210e,
  "plankv;":0x210f, "plus;":0x2b,
  "plusacir;":0x2a23, "plusb;":0x229e,
  "pluscir;":0x2a22, "plusdo;":0x2214,
  "plusdu;":0x2a25, "pluse;":0x2a72,
  "plusmn":0xb1, "plusmn;":0xb1,
  "plussim;":0x2a26, "plustwo;":0x2a27,
  "pm;":0xb1, "pointint;":0x2a15,
  "popf;":[0xd835,0xdd61], "pound":0xa3,
  "pound;":0xa3, "pr;":0x227a,
  "prE;":0x2ab3, "prap;":0x2ab7,
  "prcue;":0x227c, "pre;":0x2aaf,
  "prec;":0x227a, "precapprox;":0x2ab7,
  "preccurlyeq;":0x227c, "preceq;":0x2aaf,
  "precnapprox;":0x2ab9, "precneqq;":0x2ab5,
  "precnsim;":0x22e8, "precsim;":0x227e,
  "prime;":0x2032, "primes;":0x2119,
  "prnE;":0x2ab5, "prnap;":0x2ab9,
  "prnsim;":0x22e8, "prod;":0x220f,
  "profalar;":0x232e, "profline;":0x2312,
  "profsurf;":0x2313, "prop;":0x221d,
  "propto;":0x221d, "prsim;":0x227e,
  "prurel;":0x22b0, "pscr;":[0xd835,0xdcc5],
  "psi;":0x3c8, "puncsp;":0x2008,
  "qfr;":[0xd835,0xdd2e], "qint;":0x2a0c,
  "qopf;":[0xd835,0xdd62], "qprime;":0x2057,
  "qscr;":[0xd835,0xdcc6], "quaternions;":0x210d,
  "quatint;":0x2a16, "quest;":0x3f,
  "questeq;":0x225f, "quot":0x22,
  "quot;":0x22, "rAarr;":0x21db,
  "rArr;":0x21d2, "rAtail;":0x291c,
  "rBarr;":0x290f, "rHar;":0x2964,
  "race;":[0x223d,0x331], "racute;":0x155,
  "radic;":0x221a, "raemptyv;":0x29b3,
  "rang;":0x27e9, "rangd;":0x2992,
  "range;":0x29a5, "rangle;":0x27e9,
  "raquo":0xbb, "raquo;":0xbb,
  "rarr;":0x2192, "rarrap;":0x2975,
  "rarrb;":0x21e5, "rarrbfs;":0x2920,
  "rarrc;":0x2933, "rarrfs;":0x291e,
  "rarrhk;":0x21aa, "rarrlp;":0x21ac,
  "rarrpl;":0x2945, "rarrsim;":0x2974,
  "rarrtl;":0x21a3, "rarrw;":0x219d,
  "ratail;":0x291a, "ratio;":0x2236,
  "rationals;":0x211a, "rbarr;":0x290d,
  "rbbrk;":0x2773, "rbrace;":0x7d,
  "rbrack;":0x5d, "rbrke;":0x298c,
  "rbrksld;":0x298e, "rbrkslu;":0x2990,
  "rcaron;":0x159, "rcedil;":0x157,
  "rceil;":0x2309, "rcub;":0x7d,
  "rcy;":0x440, "rdca;":0x2937,
  "rdldhar;":0x2969, "rdquo;":0x201d,
  "rdquor;":0x201d, "rdsh;":0x21b3,
  "real;":0x211c, "realine;":0x211b,
  "realpart;":0x211c, "reals;":0x211d,
  "rect;":0x25ad, "reg":0xae,
  "reg;":0xae, "rfisht;":0x297d,
  "rfloor;":0x230b, "rfr;":[0xd835,0xdd2f],
  "rhard;":0x21c1, "rharu;":0x21c0,
  "rharul;":0x296c, "rho;":0x3c1,
  "rhov;":0x3f1, "rightarrow;":0x2192,
  "rightarrowtail;":0x21a3, "rightharpoondown;":0x21c1,
  "rightharpoonup;":0x21c0, "rightleftarrows;":0x21c4,
  "rightleftharpoons;":0x21cc, "rightrightarrows;":0x21c9,
  "rightsquigarrow;":0x219d, "rightthreetimes;":0x22cc,
  "ring;":0x2da, "risingdotseq;":0x2253,
  "rlarr;":0x21c4, "rlhar;":0x21cc,
  "rlm;":0x200f, "rmoust;":0x23b1,
  "rmoustache;":0x23b1, "rnmid;":0x2aee,
  "roang;":0x27ed, "roarr;":0x21fe,
  "robrk;":0x27e7, "ropar;":0x2986,
  "ropf;":[0xd835,0xdd63], "roplus;":0x2a2e,
  "rotimes;":0x2a35, "rpar;":0x29,
  "rpargt;":0x2994, "rppolint;":0x2a12,
  "rrarr;":0x21c9, "rsaquo;":0x203a,
  "rscr;":[0xd835,0xdcc7], "rsh;":0x21b1,
  "rsqb;":0x5d, "rsquo;":0x2019,
  "rsquor;":0x2019, "rthree;":0x22cc,
  "rtimes;":0x22ca, "rtri;":0x25b9,
  "rtrie;":0x22b5, "rtrif;":0x25b8,
  "rtriltri;":0x29ce, "ruluhar;":0x2968,
  "rx;":0x211e, "sacute;":0x15b,
  "sbquo;":0x201a, "sc;":0x227b,
  "scE;":0x2ab4, "scap;":0x2ab8,
  "scaron;":0x161, "sccue;":0x227d,
  "sce;":0x2ab0, "scedil;":0x15f,
  "scirc;":0x15d, "scnE;":0x2ab6,
  "scnap;":0x2aba, "scnsim;":0x22e9,
  "scpolint;":0x2a13, "scsim;":0x227f,
  "scy;":0x441, "sdot;":0x22c5,
  "sdotb;":0x22a1, "sdote;":0x2a66,
  "seArr;":0x21d8, "searhk;":0x2925,
  "searr;":0x2198, "searrow;":0x2198,
  "sect":0xa7, "sect;":0xa7,
  "semi;":0x3b, "seswar;":0x2929,
  "setminus;":0x2216, "setmn;":0x2216,
  "sext;":0x2736, "sfr;":[0xd835,0xdd30],
  "sfrown;":0x2322, "sharp;":0x266f,
  "shchcy;":0x449, "shcy;":0x448,
  "shortmid;":0x2223, "shortparallel;":0x2225,
  "shy":0xad, "shy;":0xad,
  "sigma;":0x3c3, "sigmaf;":0x3c2,
  "sigmav;":0x3c2, "sim;":0x223c,
  "simdot;":0x2a6a, "sime;":0x2243,
  "simeq;":0x2243, "simg;":0x2a9e,
  "simgE;":0x2aa0, "siml;":0x2a9d,
  "simlE;":0x2a9f, "simne;":0x2246,
  "simplus;":0x2a24, "simrarr;":0x2972,
  "slarr;":0x2190, "smallsetminus;":0x2216,
  "smashp;":0x2a33, "smeparsl;":0x29e4,
  "smid;":0x2223, "smile;":0x2323,
  "smt;":0x2aaa, "smte;":0x2aac,
  "smtes;":[0x2aac,0xfe00], "softcy;":0x44c,
  "sol;":0x2f, "solb;":0x29c4,
  "solbar;":0x233f, "sopf;":[0xd835,0xdd64],
  "spades;":0x2660, "spadesuit;":0x2660,
  "spar;":0x2225, "sqcap;":0x2293,
  "sqcaps;":[0x2293,0xfe00], "sqcup;":0x2294,
  "sqcups;":[0x2294,0xfe00], "sqsub;":0x228f,
  "sqsube;":0x2291, "sqsubset;":0x228f,
  "sqsubseteq;":0x2291, "sqsup;":0x2290,
  "sqsupe;":0x2292, "sqsupset;":0x2290,
  "sqsupseteq;":0x2292, "squ;":0x25a1,
  "square;":0x25a1, "squarf;":0x25aa,
  "squf;":0x25aa, "srarr;":0x2192,
  "sscr;":[0xd835,0xdcc8], "ssetmn;":0x2216,
  "ssmile;":0x2323, "sstarf;":0x22c6,
  "star;":0x2606, "starf;":0x2605,
  "straightepsilon;":0x3f5, "straightphi;":0x3d5,
  "strns;":0xaf, "sub;":0x2282,
  "subE;":0x2ac5, "subdot;":0x2abd,
  "sube;":0x2286, "subedot;":0x2ac3,
  "submult;":0x2ac1, "subnE;":0x2acb,
  "subne;":0x228a, "subplus;":0x2abf,
  "subrarr;":0x2979, "subset;":0x2282,
  "subseteq;":0x2286, "subseteqq;":0x2ac5,
  "subsetneq;":0x228a, "subsetneqq;":0x2acb,
  "subsim;":0x2ac7, "subsub;":0x2ad5,
  "subsup;":0x2ad3, "succ;":0x227b,
  "succapprox;":0x2ab8, "succcurlyeq;":0x227d,
  "succeq;":0x2ab0, "succnapprox;":0x2aba,
  "succneqq;":0x2ab6, "succnsim;":0x22e9,
  "succsim;":0x227f, "sum;":0x2211,
  "sung;":0x266a, "sup1":0xb9,
  "sup1;":0xb9, "sup2":0xb2,
  "sup2;":0xb2, "sup3":0xb3,
  "sup3;":0xb3, "sup;":0x2283,
  "supE;":0x2ac6, "supdot;":0x2abe,
  "supdsub;":0x2ad8, "supe;":0x2287,
  "supedot;":0x2ac4, "suphsol;":0x27c9,
  "suphsub;":0x2ad7, "suplarr;":0x297b,
  "supmult;":0x2ac2, "supnE;":0x2acc,
  "supne;":0x228b, "supplus;":0x2ac0,
  "supset;":0x2283, "supseteq;":0x2287,
  "supseteqq;":0x2ac6, "supsetneq;":0x228b,
  "supsetneqq;":0x2acc, "supsim;":0x2ac8,
  "supsub;":0x2ad4, "supsup;":0x2ad6,
  "swArr;":0x21d9, "swarhk;":0x2926,
  "swarr;":0x2199, "swarrow;":0x2199,
  "swnwar;":0x292a, "szlig":0xdf,
  "szlig;":0xdf, "target;":0x2316,
  "tau;":0x3c4, "tbrk;":0x23b4,
  "tcaron;":0x165, "tcedil;":0x163,
  "tcy;":0x442, "tdot;":0x20db,
  "telrec;":0x2315, "tfr;":[0xd835,0xdd31],
  "there4;":0x2234, "therefore;":0x2234,
  "theta;":0x3b8, "thetasym;":0x3d1,
  "thetav;":0x3d1, "thickapprox;":0x2248,
  "thicksim;":0x223c, "thinsp;":0x2009,
  "thkap;":0x2248, "thksim;":0x223c,
  "thorn":0xfe, "thorn;":0xfe,
  "tilde;":0x2dc, "times":0xd7,
  "times;":0xd7, "timesb;":0x22a0,
  "timesbar;":0x2a31, "timesd;":0x2a30,
  "tint;":0x222d, "toea;":0x2928,
  "top;":0x22a4, "topbot;":0x2336,
  "topcir;":0x2af1, "topf;":[0xd835,0xdd65],
  "topfork;":0x2ada, "tosa;":0x2929,
  "tprime;":0x2034, "trade;":0x2122,
  "triangle;":0x25b5, "triangledown;":0x25bf,
  "triangleleft;":0x25c3, "trianglelefteq;":0x22b4,
  "triangleq;":0x225c, "triangleright;":0x25b9,
  "trianglerighteq;":0x22b5, "tridot;":0x25ec,
  "trie;":0x225c, "triminus;":0x2a3a,
  "triplus;":0x2a39, "trisb;":0x29cd,
  "tritime;":0x2a3b, "trpezium;":0x23e2,
  "tscr;":[0xd835,0xdcc9], "tscy;":0x446,
  "tshcy;":0x45b, "tstrok;":0x167,
  "twixt;":0x226c, "twoheadleftarrow;":0x219e,
  "twoheadrightarrow;":0x21a0, "uArr;":0x21d1,
  "uHar;":0x2963, "uacute":0xfa,
  "uacute;":0xfa, "uarr;":0x2191,
  "ubrcy;":0x45e, "ubreve;":0x16d,
  "ucirc":0xfb, "ucirc;":0xfb,
  "ucy;":0x443, "udarr;":0x21c5,
  "udblac;":0x171, "udhar;":0x296e,
  "ufisht;":0x297e, "ufr;":[0xd835,0xdd32],
  "ugrave":0xf9, "ugrave;":0xf9,
  "uharl;":0x21bf, "uharr;":0x21be,
  "uhblk;":0x2580, "ulcorn;":0x231c,
  "ulcorner;":0x231c, "ulcrop;":0x230f,
  "ultri;":0x25f8, "umacr;":0x16b,
  "uml":0xa8, "uml;":0xa8,
  "uogon;":0x173, "uopf;":[0xd835,0xdd66],
  "uparrow;":0x2191, "updownarrow;":0x2195,
  "upharpoonleft;":0x21bf, "upharpoonright;":0x21be,
  "uplus;":0x228e, "upsi;":0x3c5,
  "upsih;":0x3d2, "upsilon;":0x3c5,
  "upuparrows;":0x21c8, "urcorn;":0x231d,
  "urcorner;":0x231d, "urcrop;":0x230e,
  "uring;":0x16f, "urtri;":0x25f9,
  "uscr;":[0xd835,0xdcca], "utdot;":0x22f0,
  "utilde;":0x169, "utri;":0x25b5,
  "utrif;":0x25b4, "uuarr;":0x21c8,
  "uuml":0xfc, "uuml;":0xfc,
  "uwangle;":0x29a7, "vArr;":0x21d5,
  "vBar;":0x2ae8, "vBarv;":0x2ae9,
  "vDash;":0x22a8, "vangrt;":0x299c,
  "varepsilon;":0x3f5, "varkappa;":0x3f0,
  "varnothing;":0x2205, "varphi;":0x3d5,
  "varpi;":0x3d6, "varpropto;":0x221d,
  "varr;":0x2195, "varrho;":0x3f1,
  "varsigma;":0x3c2, "varsubsetneq;":[0x228a,0xfe00],
  "varsubsetneqq;":[0x2acb,0xfe00], "varsupsetneq;":[0x228b,0xfe00],
  "varsupsetneqq;":[0x2acc,0xfe00], "vartheta;":0x3d1,
  "vartriangleleft;":0x22b2, "vartriangleright;":0x22b3,
  "vcy;":0x432, "vdash;":0x22a2,
  "vee;":0x2228, "veebar;":0x22bb,
  "veeeq;":0x225a, "vellip;":0x22ee,
  "verbar;":0x7c, "vert;":0x7c,
  "vfr;":[0xd835,0xdd33], "vltri;":0x22b2,
  "vnsub;":[0x2282,0x20d2], "vnsup;":[0x2283,0x20d2],
  "vopf;":[0xd835,0xdd67], "vprop;":0x221d,
  "vrtri;":0x22b3, "vscr;":[0xd835,0xdccb],
  "vsubnE;":[0x2acb,0xfe00], "vsubne;":[0x228a,0xfe00],
  "vsupnE;":[0x2acc,0xfe00], "vsupne;":[0x228b,0xfe00],
  "vzigzag;":0x299a, "wcirc;":0x175,
  "wedbar;":0x2a5f, "wedge;":0x2227,
  "wedgeq;":0x2259, "weierp;":0x2118,
  "wfr;":[0xd835,0xdd34], "wopf;":[0xd835,0xdd68],
  "wp;":0x2118, "wr;":0x2240,
  "wreath;":0x2240, "wscr;":[0xd835,0xdccc],
  "xcap;":0x22c2, "xcirc;":0x25ef,
  "xcup;":0x22c3, "xdtri;":0x25bd,
  "xfr;":[0xd835,0xdd35], "xhArr;":0x27fa,
  "xharr;":0x27f7, "xi;":0x3be,
  "xlArr;":0x27f8, "xlarr;":0x27f5,
  "xmap;":0x27fc, "xnis;":0x22fb,
  "xodot;":0x2a00, "xopf;":[0xd835,0xdd69],
  "xoplus;":0x2a01, "xotime;":0x2a02,
  "xrArr;":0x27f9, "xrarr;":0x27f6,
  "xscr;":[0xd835,0xdccd], "xsqcup;":0x2a06,
  "xuplus;":0x2a04, "xutri;":0x25b3,
  "xvee;":0x22c1, "xwedge;":0x22c0,
  "yacute":0xfd, "yacute;":0xfd,
  "yacy;":0x44f, "ycirc;":0x177,
  "ycy;":0x44b, "yen":0xa5,
  "yen;":0xa5, "yfr;":[0xd835,0xdd36],
  "yicy;":0x457, "yopf;":[0xd835,0xdd6a],
  "yscr;":[0xd835,0xdcce], "yucy;":0x44e,
  "yuml":0xff, "yuml;":0xff,
  "zacute;":0x17a, "zcaron;":0x17e,
  "zcy;":0x437, "zdot;":0x17c,
  "zeetrf;":0x2128, "zeta;":0x3b6,
  "zfr;":[0xd835,0xdd37], "zhcy;":0x436,
  "zigrarr;":0x21dd, "zopf;":[0xd835,0xdd6b],
  "zscr;":[0xd835,0xdccf], "zwj;":0x200d,
  "zwnj;":0x200c,
};
/*
 * This regexp is generated with test/tools/update-entities.js
 * It will always match at least one character -- but note that there
 * are no entities whose names are a single character long.
 */
var NAMEDCHARREF = /(A(?:Elig;?|MP;?|acute;?|breve;|c(?:irc;?|y;)|fr;|grave;?|lpha;|macr;|nd;|o(?:gon;|pf;)|pplyFunction;|ring;?|s(?:cr;|sign;)|tilde;?|uml;?)|B(?:a(?:ckslash;|r(?:v;|wed;))|cy;|e(?:cause;|rnoullis;|ta;)|fr;|opf;|reve;|scr;|umpeq;)|C(?:Hcy;|OPY;?|a(?:cute;|p(?:;|italDifferentialD;)|yleys;)|c(?:aron;|edil;?|irc;|onint;)|dot;|e(?:dilla;|nterDot;)|fr;|hi;|ircle(?:Dot;|Minus;|Plus;|Times;)|lo(?:ckwiseContourIntegral;|seCurly(?:DoubleQuote;|Quote;))|o(?:lon(?:;|e;)|n(?:gruent;|int;|tourIntegral;)|p(?:f;|roduct;)|unterClockwiseContourIntegral;)|ross;|scr;|up(?:;|Cap;))|D(?:D(?:;|otrahd;)|Jcy;|Scy;|Zcy;|a(?:gger;|rr;|shv;)|c(?:aron;|y;)|el(?:;|ta;)|fr;|i(?:a(?:critical(?:Acute;|Do(?:t;|ubleAcute;)|Grave;|Tilde;)|mond;)|fferentialD;)|o(?:pf;|t(?:;|Dot;|Equal;)|uble(?:ContourIntegral;|Do(?:t;|wnArrow;)|L(?:eft(?:Arrow;|RightArrow;|Tee;)|ong(?:Left(?:Arrow;|RightArrow;)|RightArrow;))|Right(?:Arrow;|Tee;)|Up(?:Arrow;|DownArrow;)|VerticalBar;)|wn(?:Arrow(?:;|Bar;|UpArrow;)|Breve;|Left(?:RightVector;|TeeVector;|Vector(?:;|Bar;))|Right(?:TeeVector;|Vector(?:;|Bar;))|Tee(?:;|Arrow;)|arrow;))|s(?:cr;|trok;))|E(?:NG;|TH;?|acute;?|c(?:aron;|irc;?|y;)|dot;|fr;|grave;?|lement;|m(?:acr;|pty(?:SmallSquare;|VerySmallSquare;))|o(?:gon;|pf;)|psilon;|qu(?:al(?:;|Tilde;)|ilibrium;)|s(?:cr;|im;)|ta;|uml;?|x(?:ists;|ponentialE;))|F(?:cy;|fr;|illed(?:SmallSquare;|VerySmallSquare;)|o(?:pf;|rAll;|uriertrf;)|scr;)|G(?:Jcy;|T;?|amma(?:;|d;)|breve;|c(?:edil;|irc;|y;)|dot;|fr;|g;|opf;|reater(?:Equal(?:;|Less;)|FullEqual;|Greater;|Less;|SlantEqual;|Tilde;)|scr;|t;)|H(?:ARDcy;|a(?:cek;|t;)|circ;|fr;|ilbertSpace;|o(?:pf;|rizontalLine;)|s(?:cr;|trok;)|ump(?:DownHump;|Equal;))|I(?:Ecy;|Jlig;|Ocy;|acute;?|c(?:irc;?|y;)|dot;|fr;|grave;?|m(?:;|a(?:cr;|ginaryI;)|plies;)|n(?:t(?:;|e(?:gral;|rsection;))|visible(?:Comma;|Times;))|o(?:gon;|pf;|ta;)|scr;|tilde;|u(?:kcy;|ml;?))|J(?:c(?:irc;|y;)|fr;|opf;|s(?:cr;|ercy;)|ukcy;)|K(?:Hcy;|Jcy;|appa;|c(?:edil;|y;)|fr;|opf;|scr;)|L(?:Jcy;|T;?|a(?:cute;|mbda;|ng;|placetrf;|rr;)|c(?:aron;|edil;|y;)|e(?:ft(?:A(?:ngleBracket;|rrow(?:;|Bar;|RightArrow;))|Ceiling;|Do(?:ubleBracket;|wn(?:TeeVector;|Vector(?:;|Bar;)))|Floor;|Right(?:Arrow;|Vector;)|T(?:ee(?:;|Arrow;|Vector;)|riangle(?:;|Bar;|Equal;))|Up(?:DownVector;|TeeVector;|Vector(?:;|Bar;))|Vector(?:;|Bar;)|arrow;|rightarrow;)|ss(?:EqualGreater;|FullEqual;|Greater;|Less;|SlantEqual;|Tilde;))|fr;|l(?:;|eftarrow;)|midot;|o(?:ng(?:Left(?:Arrow;|RightArrow;)|RightArrow;|left(?:arrow;|rightarrow;)|rightarrow;)|pf;|wer(?:LeftArrow;|RightArrow;))|s(?:cr;|h;|trok;)|t;)|M(?:ap;|cy;|e(?:diumSpace;|llintrf;)|fr;|inusPlus;|opf;|scr;|u;)|N(?:Jcy;|acute;|c(?:aron;|edil;|y;)|e(?:gative(?:MediumSpace;|Thi(?:ckSpace;|nSpace;)|VeryThinSpace;)|sted(?:GreaterGreater;|LessLess;)|wLine;)|fr;|o(?:Break;|nBreakingSpace;|pf;|t(?:;|C(?:ongruent;|upCap;)|DoubleVerticalBar;|E(?:lement;|qual(?:;|Tilde;)|xists;)|Greater(?:;|Equal;|FullEqual;|Greater;|Less;|SlantEqual;|Tilde;)|Hump(?:DownHump;|Equal;)|Le(?:ftTriangle(?:;|Bar;|Equal;)|ss(?:;|Equal;|Greater;|Less;|SlantEqual;|Tilde;))|Nested(?:GreaterGreater;|LessLess;)|Precedes(?:;|Equal;|SlantEqual;)|R(?:everseElement;|ightTriangle(?:;|Bar;|Equal;))|S(?:quareSu(?:bset(?:;|Equal;)|perset(?:;|Equal;))|u(?:bset(?:;|Equal;)|cceeds(?:;|Equal;|SlantEqual;|Tilde;)|perset(?:;|Equal;)))|Tilde(?:;|Equal;|FullEqual;|Tilde;)|VerticalBar;))|scr;|tilde;?|u;)|O(?:Elig;|acute;?|c(?:irc;?|y;)|dblac;|fr;|grave;?|m(?:acr;|ega;|icron;)|opf;|penCurly(?:DoubleQuote;|Quote;)|r;|s(?:cr;|lash;?)|ti(?:lde;?|mes;)|uml;?|ver(?:B(?:ar;|rac(?:e;|ket;))|Parenthesis;))|P(?:artialD;|cy;|fr;|hi;|i;|lusMinus;|o(?:incareplane;|pf;)|r(?:;|ecedes(?:;|Equal;|SlantEqual;|Tilde;)|ime;|o(?:duct;|portion(?:;|al;)))|s(?:cr;|i;))|Q(?:UOT;?|fr;|opf;|scr;)|R(?:Barr;|EG;?|a(?:cute;|ng;|rr(?:;|tl;))|c(?:aron;|edil;|y;)|e(?:;|verse(?:E(?:lement;|quilibrium;)|UpEquilibrium;))|fr;|ho;|ight(?:A(?:ngleBracket;|rrow(?:;|Bar;|LeftArrow;))|Ceiling;|Do(?:ubleBracket;|wn(?:TeeVector;|Vector(?:;|Bar;)))|Floor;|T(?:ee(?:;|Arrow;|Vector;)|riangle(?:;|Bar;|Equal;))|Up(?:DownVector;|TeeVector;|Vector(?:;|Bar;))|Vector(?:;|Bar;)|arrow;)|o(?:pf;|undImplies;)|rightarrow;|s(?:cr;|h;)|uleDelayed;)|S(?:H(?:CHcy;|cy;)|OFTcy;|acute;|c(?:;|aron;|edil;|irc;|y;)|fr;|hort(?:DownArrow;|LeftArrow;|RightArrow;|UpArrow;)|igma;|mallCircle;|opf;|q(?:rt;|uare(?:;|Intersection;|Su(?:bset(?:;|Equal;)|perset(?:;|Equal;))|Union;))|scr;|tar;|u(?:b(?:;|set(?:;|Equal;))|c(?:ceeds(?:;|Equal;|SlantEqual;|Tilde;)|hThat;)|m;|p(?:;|erset(?:;|Equal;)|set;)))|T(?:HORN;?|RADE;|S(?:Hcy;|cy;)|a(?:b;|u;)|c(?:aron;|edil;|y;)|fr;|h(?:e(?:refore;|ta;)|i(?:ckSpace;|nSpace;))|ilde(?:;|Equal;|FullEqual;|Tilde;)|opf;|ripleDot;|s(?:cr;|trok;))|U(?:a(?:cute;?|rr(?:;|ocir;))|br(?:cy;|eve;)|c(?:irc;?|y;)|dblac;|fr;|grave;?|macr;|n(?:der(?:B(?:ar;|rac(?:e;|ket;))|Parenthesis;)|ion(?:;|Plus;))|o(?:gon;|pf;)|p(?:Arrow(?:;|Bar;|DownArrow;)|DownArrow;|Equilibrium;|Tee(?:;|Arrow;)|arrow;|downarrow;|per(?:LeftArrow;|RightArrow;)|si(?:;|lon;))|ring;|scr;|tilde;|uml;?)|V(?:Dash;|bar;|cy;|dash(?:;|l;)|e(?:e;|r(?:bar;|t(?:;|ical(?:Bar;|Line;|Separator;|Tilde;))|yThinSpace;))|fr;|opf;|scr;|vdash;)|W(?:circ;|edge;|fr;|opf;|scr;)|X(?:fr;|i;|opf;|scr;)|Y(?:Acy;|Icy;|Ucy;|acute;?|c(?:irc;|y;)|fr;|opf;|scr;|uml;)|Z(?:Hcy;|acute;|c(?:aron;|y;)|dot;|e(?:roWidthSpace;|ta;)|fr;|opf;|scr;)|a(?:acute;?|breve;|c(?:;|E;|d;|irc;?|ute;?|y;)|elig;?|f(?:;|r;)|grave;?|l(?:e(?:fsym;|ph;)|pha;)|m(?:a(?:cr;|lg;)|p;?)|n(?:d(?:;|and;|d;|slope;|v;)|g(?:;|e;|le;|msd(?:;|a(?:a;|b;|c;|d;|e;|f;|g;|h;))|rt(?:;|vb(?:;|d;))|s(?:ph;|t;)|zarr;))|o(?:gon;|pf;)|p(?:;|E;|acir;|e;|id;|os;|prox(?:;|eq;))|ring;?|s(?:cr;|t;|ymp(?:;|eq;))|tilde;?|uml;?|w(?:conint;|int;))|b(?:Not;|a(?:ck(?:cong;|epsilon;|prime;|sim(?:;|eq;))|r(?:vee;|wed(?:;|ge;)))|brk(?:;|tbrk;)|c(?:ong;|y;)|dquo;|e(?:caus(?:;|e;)|mptyv;|psi;|rnou;|t(?:a;|h;|ween;))|fr;|ig(?:c(?:ap;|irc;|up;)|o(?:dot;|plus;|times;)|s(?:qcup;|tar;)|triangle(?:down;|up;)|uplus;|vee;|wedge;)|karow;|l(?:a(?:ck(?:lozenge;|square;|triangle(?:;|down;|left;|right;))|nk;)|k(?:1(?:2;|4;)|34;)|ock;)|n(?:e(?:;|quiv;)|ot;)|o(?:pf;|t(?:;|tom;)|wtie;|x(?:D(?:L;|R;|l;|r;)|H(?:;|D;|U;|d;|u;)|U(?:L;|R;|l;|r;)|V(?:;|H;|L;|R;|h;|l;|r;)|box;|d(?:L;|R;|l;|r;)|h(?:;|D;|U;|d;|u;)|minus;|plus;|times;|u(?:L;|R;|l;|r;)|v(?:;|H;|L;|R;|h;|l;|r;)))|prime;|r(?:eve;|vbar;?)|s(?:cr;|emi;|im(?:;|e;)|ol(?:;|b;|hsub;))|u(?:ll(?:;|et;)|mp(?:;|E;|e(?:;|q;))))|c(?:a(?:cute;|p(?:;|and;|brcup;|c(?:ap;|up;)|dot;|s;)|r(?:et;|on;))|c(?:a(?:ps;|ron;)|edil;?|irc;|ups(?:;|sm;))|dot;|e(?:dil;?|mptyv;|nt(?:;|erdot;|))|fr;|h(?:cy;|eck(?:;|mark;)|i;)|ir(?:;|E;|c(?:;|eq;|le(?:arrow(?:left;|right;)|d(?:R;|S;|ast;|circ;|dash;)))|e;|fnint;|mid;|scir;)|lubs(?:;|uit;)|o(?:lon(?:;|e(?:;|q;))|m(?:ma(?:;|t;)|p(?:;|fn;|le(?:ment;|xes;)))|n(?:g(?:;|dot;)|int;)|p(?:f;|rod;|y(?:;|sr;|)))|r(?:arr;|oss;)|s(?:cr;|u(?:b(?:;|e;)|p(?:;|e;)))|tdot;|u(?:darr(?:l;|r;)|e(?:pr;|sc;)|larr(?:;|p;)|p(?:;|brcap;|c(?:ap;|up;)|dot;|or;|s;)|r(?:arr(?:;|m;)|ly(?:eq(?:prec;|succ;)|vee;|wedge;)|ren;?|vearrow(?:left;|right;))|vee;|wed;)|w(?:conint;|int;)|ylcty;)|d(?:Arr;|Har;|a(?:gger;|leth;|rr;|sh(?:;|v;))|b(?:karow;|lac;)|c(?:aron;|y;)|d(?:;|a(?:gger;|rr;)|otseq;)|e(?:g;?|lta;|mptyv;)|f(?:isht;|r;)|har(?:l;|r;)|i(?:am(?:;|ond(?:;|suit;)|s;)|e;|gamma;|sin;|v(?:;|ide(?:;|ontimes;|)|onx;))|jcy;|lc(?:orn;|rop;)|o(?:llar;|pf;|t(?:;|eq(?:;|dot;)|minus;|plus;|square;)|ublebarwedge;|wn(?:arrow;|downarrows;|harpoon(?:left;|right;)))|r(?:bkarow;|c(?:orn;|rop;))|s(?:c(?:r;|y;)|ol;|trok;)|t(?:dot;|ri(?:;|f;))|u(?:arr;|har;)|wangle;|z(?:cy;|igrarr;))|e(?:D(?:Dot;|ot;)|a(?:cute;?|ster;)|c(?:aron;|ir(?:;|c;?)|olon;|y;)|dot;|e;|f(?:Dot;|r;)|g(?:;|rave;?|s(?:;|dot;))|l(?:;|inters;|l;|s(?:;|dot;))|m(?:acr;|pty(?:;|set;|v;)|sp(?:1(?:3;|4;)|;))|n(?:g;|sp;)|o(?:gon;|pf;)|p(?:ar(?:;|sl;)|lus;|si(?:;|lon;|v;))|q(?:c(?:irc;|olon;)|s(?:im;|lant(?:gtr;|less;))|u(?:als;|est;|iv(?:;|DD;))|vparsl;)|r(?:Dot;|arr;)|s(?:cr;|dot;|im;)|t(?:a;|h;?)|u(?:ml;?|ro;)|x(?:cl;|ist;|p(?:ectation;|onentiale;)))|f(?:allingdotseq;|cy;|emale;|f(?:ilig;|l(?:ig;|lig;)|r;)|ilig;|jlig;|l(?:at;|lig;|tns;)|nof;|o(?:pf;|r(?:all;|k(?:;|v;)))|partint;|r(?:a(?:c(?:1(?:2;?|3;|4;?|5;|6;|8;)|2(?:3;|5;)|3(?:4;?|5;|8;)|45;|5(?:6;|8;)|78;)|sl;)|own;)|scr;)|g(?:E(?:;|l;)|a(?:cute;|mma(?:;|d;)|p;)|breve;|c(?:irc;|y;)|dot;|e(?:;|l;|q(?:;|q;|slant;)|s(?:;|cc;|dot(?:;|o(?:;|l;))|l(?:;|es;)))|fr;|g(?:;|g;)|imel;|jcy;|l(?:;|E;|a;|j;)|n(?:E;|ap(?:;|prox;)|e(?:;|q(?:;|q;))|sim;)|opf;|rave;|s(?:cr;|im(?:;|e;|l;))|t(?:;|c(?:c;|ir;)|dot;|lPar;|quest;|r(?:a(?:pprox;|rr;)|dot;|eq(?:less;|qless;)|less;|sim;)|)|v(?:ertneqq;|nE;))|h(?:Arr;|a(?:irsp;|lf;|milt;|r(?:dcy;|r(?:;|cir;|w;)))|bar;|circ;|e(?:arts(?:;|uit;)|llip;|rcon;)|fr;|ks(?:earow;|warow;)|o(?:arr;|mtht;|ok(?:leftarrow;|rightarrow;)|pf;|rbar;)|s(?:cr;|lash;|trok;)|y(?:bull;|phen;))|i(?:acute;?|c(?:;|irc;?|y;)|e(?:cy;|xcl;?)|f(?:f;|r;)|grave;?|i(?:;|i(?:int;|nt;)|nfin;|ota;)|jlig;|m(?:a(?:cr;|g(?:e;|line;|part;)|th;)|of;|ped;)|n(?:;|care;|fin(?:;|tie;)|odot;|t(?:;|cal;|e(?:gers;|rcal;)|larhk;|prod;))|o(?:cy;|gon;|pf;|ta;)|prod;|quest;?|s(?:cr;|in(?:;|E;|dot;|s(?:;|v;)|v;))|t(?:;|ilde;)|u(?:kcy;|ml;?))|j(?:c(?:irc;|y;)|fr;|math;|opf;|s(?:cr;|ercy;)|ukcy;)|k(?:appa(?:;|v;)|c(?:edil;|y;)|fr;|green;|hcy;|jcy;|opf;|scr;)|l(?:A(?:arr;|rr;|tail;)|Barr;|E(?:;|g;)|Har;|a(?:cute;|emptyv;|gran;|mbda;|ng(?:;|d;|le;)|p;|quo;?|rr(?:;|b(?:;|fs;)|fs;|hk;|lp;|pl;|sim;|tl;)|t(?:;|ail;|e(?:;|s;)))|b(?:arr;|brk;|r(?:ac(?:e;|k;)|k(?:e;|sl(?:d;|u;))))|c(?:aron;|e(?:dil;|il;)|ub;|y;)|d(?:ca;|quo(?:;|r;)|r(?:dhar;|ushar;)|sh;)|e(?:;|ft(?:arrow(?:;|tail;)|harpoon(?:down;|up;)|leftarrows;|right(?:arrow(?:;|s;)|harpoons;|squigarrow;)|threetimes;)|g;|q(?:;|q;|slant;)|s(?:;|cc;|dot(?:;|o(?:;|r;))|g(?:;|es;)|s(?:approx;|dot;|eq(?:gtr;|qgtr;)|gtr;|sim;)))|f(?:isht;|loor;|r;)|g(?:;|E;)|h(?:ar(?:d;|u(?:;|l;))|blk;)|jcy;|l(?:;|arr;|corner;|hard;|tri;)|m(?:idot;|oust(?:;|ache;))|n(?:E;|ap(?:;|prox;)|e(?:;|q(?:;|q;))|sim;)|o(?:a(?:ng;|rr;)|brk;|ng(?:left(?:arrow;|rightarrow;)|mapsto;|rightarrow;)|oparrow(?:left;|right;)|p(?:ar;|f;|lus;)|times;|w(?:ast;|bar;)|z(?:;|enge;|f;))|par(?:;|lt;)|r(?:arr;|corner;|har(?:;|d;)|m;|tri;)|s(?:aquo;|cr;|h;|im(?:;|e;|g;)|q(?:b;|uo(?:;|r;))|trok;)|t(?:;|c(?:c;|ir;)|dot;|hree;|imes;|larr;|quest;|r(?:Par;|i(?:;|e;|f;))|)|ur(?:dshar;|uhar;)|v(?:ertneqq;|nE;))|m(?:DDot;|a(?:cr;?|l(?:e;|t(?:;|ese;))|p(?:;|sto(?:;|down;|left;|up;))|rker;)|c(?:omma;|y;)|dash;|easuredangle;|fr;|ho;|i(?:cro;?|d(?:;|ast;|cir;|dot;?)|nus(?:;|b;|d(?:;|u;)))|l(?:cp;|dr;)|nplus;|o(?:dels;|pf;)|p;|s(?:cr;|tpos;)|u(?:;|ltimap;|map;))|n(?:G(?:g;|t(?:;|v;))|L(?:eft(?:arrow;|rightarrow;)|l;|t(?:;|v;))|Rightarrow;|V(?:Dash;|dash;)|a(?:bla;|cute;|ng;|p(?:;|E;|id;|os;|prox;)|tur(?:;|al(?:;|s;)))|b(?:sp;?|ump(?:;|e;))|c(?:a(?:p;|ron;)|edil;|ong(?:;|dot;)|up;|y;)|dash;|e(?:;|Arr;|ar(?:hk;|r(?:;|ow;))|dot;|quiv;|s(?:ear;|im;)|xist(?:;|s;))|fr;|g(?:E;|e(?:;|q(?:;|q;|slant;)|s;)|sim;|t(?:;|r;))|h(?:Arr;|arr;|par;)|i(?:;|s(?:;|d;)|v;)|jcy;|l(?:Arr;|E;|arr;|dr;|e(?:;|ft(?:arrow;|rightarrow;)|q(?:;|q;|slant;)|s(?:;|s;))|sim;|t(?:;|ri(?:;|e;)))|mid;|o(?:pf;|t(?:;|in(?:;|E;|dot;|v(?:a;|b;|c;))|ni(?:;|v(?:a;|b;|c;))|))|p(?:ar(?:;|allel;|sl;|t;)|olint;|r(?:;|cue;|e(?:;|c(?:;|eq;))))|r(?:Arr;|arr(?:;|c;|w;)|ightarrow;|tri(?:;|e;))|s(?:c(?:;|cue;|e;|r;)|hort(?:mid;|parallel;)|im(?:;|e(?:;|q;))|mid;|par;|qsu(?:be;|pe;)|u(?:b(?:;|E;|e;|set(?:;|eq(?:;|q;)))|cc(?:;|eq;)|p(?:;|E;|e;|set(?:;|eq(?:;|q;)))))|t(?:gl;|ilde;?|lg;|riangle(?:left(?:;|eq;)|right(?:;|eq;)))|u(?:;|m(?:;|ero;|sp;))|v(?:Dash;|Harr;|ap;|dash;|g(?:e;|t;)|infin;|l(?:Arr;|e;|t(?:;|rie;))|r(?:Arr;|trie;)|sim;)|w(?:Arr;|ar(?:hk;|r(?:;|ow;))|near;))|o(?:S;|a(?:cute;?|st;)|c(?:ir(?:;|c;?)|y;)|d(?:ash;|blac;|iv;|ot;|sold;)|elig;|f(?:cir;|r;)|g(?:on;|rave;?|t;)|h(?:bar;|m;)|int;|l(?:arr;|c(?:ir;|ross;)|ine;|t;)|m(?:acr;|ega;|i(?:cron;|d;|nus;))|opf;|p(?:ar;|erp;|lus;)|r(?:;|arr;|d(?:;|er(?:;|of;)|f;?|m;?)|igof;|or;|slope;|v;)|s(?:cr;|lash;?|ol;)|ti(?:lde;?|mes(?:;|as;))|uml;?|vbar;)|p(?:ar(?:;|a(?:;|llel;|)|s(?:im;|l;)|t;)|cy;|er(?:cnt;|iod;|mil;|p;|tenk;)|fr;|h(?:i(?:;|v;)|mmat;|one;)|i(?:;|tchfork;|v;)|l(?:an(?:ck(?:;|h;)|kv;)|us(?:;|acir;|b;|cir;|d(?:o;|u;)|e;|mn;?|sim;|two;))|m;|o(?:intint;|pf;|und;?)|r(?:;|E;|ap;|cue;|e(?:;|c(?:;|approx;|curlyeq;|eq;|n(?:approx;|eqq;|sim;)|sim;))|ime(?:;|s;)|n(?:E;|ap;|sim;)|o(?:d;|f(?:alar;|line;|surf;)|p(?:;|to;))|sim;|urel;)|s(?:cr;|i;)|uncsp;)|q(?:fr;|int;|opf;|prime;|scr;|u(?:at(?:ernions;|int;)|est(?:;|eq;)|ot;?))|r(?:A(?:arr;|rr;|tail;)|Barr;|Har;|a(?:c(?:e;|ute;)|dic;|emptyv;|ng(?:;|d;|e;|le;)|quo;?|rr(?:;|ap;|b(?:;|fs;)|c;|fs;|hk;|lp;|pl;|sim;|tl;|w;)|t(?:ail;|io(?:;|nals;)))|b(?:arr;|brk;|r(?:ac(?:e;|k;)|k(?:e;|sl(?:d;|u;))))|c(?:aron;|e(?:dil;|il;)|ub;|y;)|d(?:ca;|ldhar;|quo(?:;|r;)|sh;)|e(?:al(?:;|ine;|part;|s;)|ct;|g;?)|f(?:isht;|loor;|r;)|h(?:ar(?:d;|u(?:;|l;))|o(?:;|v;))|i(?:ght(?:arrow(?:;|tail;)|harpoon(?:down;|up;)|left(?:arrows;|harpoons;)|rightarrows;|squigarrow;|threetimes;)|ng;|singdotseq;)|l(?:arr;|har;|m;)|moust(?:;|ache;)|nmid;|o(?:a(?:ng;|rr;)|brk;|p(?:ar;|f;|lus;)|times;)|p(?:ar(?:;|gt;)|polint;)|rarr;|s(?:aquo;|cr;|h;|q(?:b;|uo(?:;|r;)))|t(?:hree;|imes;|ri(?:;|e;|f;|ltri;))|uluhar;|x;)|s(?:acute;|bquo;|c(?:;|E;|a(?:p;|ron;)|cue;|e(?:;|dil;)|irc;|n(?:E;|ap;|sim;)|polint;|sim;|y;)|dot(?:;|b;|e;)|e(?:Arr;|ar(?:hk;|r(?:;|ow;))|ct;?|mi;|swar;|tm(?:inus;|n;)|xt;)|fr(?:;|own;)|h(?:arp;|c(?:hcy;|y;)|ort(?:mid;|parallel;)|y;?)|i(?:gma(?:;|f;|v;)|m(?:;|dot;|e(?:;|q;)|g(?:;|E;)|l(?:;|E;)|ne;|plus;|rarr;))|larr;|m(?:a(?:llsetminus;|shp;)|eparsl;|i(?:d;|le;)|t(?:;|e(?:;|s;)))|o(?:ftcy;|l(?:;|b(?:;|ar;))|pf;)|pa(?:des(?:;|uit;)|r;)|q(?:c(?:ap(?:;|s;)|up(?:;|s;))|su(?:b(?:;|e;|set(?:;|eq;))|p(?:;|e;|set(?:;|eq;)))|u(?:;|ar(?:e;|f;)|f;))|rarr;|s(?:cr;|etmn;|mile;|tarf;)|t(?:ar(?:;|f;)|r(?:aight(?:epsilon;|phi;)|ns;))|u(?:b(?:;|E;|dot;|e(?:;|dot;)|mult;|n(?:E;|e;)|plus;|rarr;|s(?:et(?:;|eq(?:;|q;)|neq(?:;|q;))|im;|u(?:b;|p;)))|cc(?:;|approx;|curlyeq;|eq;|n(?:approx;|eqq;|sim;)|sim;)|m;|ng;|p(?:1;?|2;?|3;?|;|E;|d(?:ot;|sub;)|e(?:;|dot;)|hs(?:ol;|ub;)|larr;|mult;|n(?:E;|e;)|plus;|s(?:et(?:;|eq(?:;|q;)|neq(?:;|q;))|im;|u(?:b;|p;))))|w(?:Arr;|ar(?:hk;|r(?:;|ow;))|nwar;)|zlig;?)|t(?:a(?:rget;|u;)|brk;|c(?:aron;|edil;|y;)|dot;|elrec;|fr;|h(?:e(?:re(?:4;|fore;)|ta(?:;|sym;|v;))|i(?:ck(?:approx;|sim;)|nsp;)|k(?:ap;|sim;)|orn;?)|i(?:lde;|mes(?:;|b(?:;|ar;)|d;|)|nt;)|o(?:ea;|p(?:;|bot;|cir;|f(?:;|ork;))|sa;)|prime;|r(?:ade;|i(?:angle(?:;|down;|left(?:;|eq;)|q;|right(?:;|eq;))|dot;|e;|minus;|plus;|sb;|time;)|pezium;)|s(?:c(?:r;|y;)|hcy;|trok;)|w(?:ixt;|ohead(?:leftarrow;|rightarrow;)))|u(?:Arr;|Har;|a(?:cute;?|rr;)|br(?:cy;|eve;)|c(?:irc;?|y;)|d(?:arr;|blac;|har;)|f(?:isht;|r;)|grave;?|h(?:ar(?:l;|r;)|blk;)|l(?:c(?:orn(?:;|er;)|rop;)|tri;)|m(?:acr;|l;?)|o(?:gon;|pf;)|p(?:arrow;|downarrow;|harpoon(?:left;|right;)|lus;|si(?:;|h;|lon;)|uparrows;)|r(?:c(?:orn(?:;|er;)|rop;)|ing;|tri;)|scr;|t(?:dot;|ilde;|ri(?:;|f;))|u(?:arr;|ml;?)|wangle;)|v(?:Arr;|Bar(?:;|v;)|Dash;|a(?:ngrt;|r(?:epsilon;|kappa;|nothing;|p(?:hi;|i;|ropto;)|r(?:;|ho;)|s(?:igma;|u(?:bsetneq(?:;|q;)|psetneq(?:;|q;)))|t(?:heta;|riangle(?:left;|right;))))|cy;|dash;|e(?:e(?:;|bar;|eq;)|llip;|r(?:bar;|t;))|fr;|ltri;|nsu(?:b;|p;)|opf;|prop;|rtri;|s(?:cr;|u(?:bn(?:E;|e;)|pn(?:E;|e;)))|zigzag;)|w(?:circ;|e(?:d(?:bar;|ge(?:;|q;))|ierp;)|fr;|opf;|p;|r(?:;|eath;)|scr;)|x(?:c(?:ap;|irc;|up;)|dtri;|fr;|h(?:Arr;|arr;)|i;|l(?:Arr;|arr;)|map;|nis;|o(?:dot;|p(?:f;|lus;)|time;)|r(?:Arr;|arr;)|s(?:cr;|qcup;)|u(?:plus;|tri;)|vee;|wedge;)|y(?:ac(?:ute;?|y;)|c(?:irc;|y;)|en;?|fr;|icy;|opf;|scr;|u(?:cy;|ml;?))|z(?:acute;|c(?:aron;|y;)|dot;|e(?:etrf;|ta;)|fr;|hcy;|igrarr;|opf;|scr;|w(?:j;|nj;)))|[\s\S]/g;

var NAMEDCHARREF_MAXLEN = 32;

// Regular expression constants used by the tokenizer and parser

// Note that \r is included in all of these regexps because it will need
// to be converted to LF by the scanChars() function.
var DBLQUOTEATTRVAL = /[^\r"&\u0000]+/g;
var SINGLEQUOTEATTRVAL = /[^\r'&\u0000]+/g;
var UNQUOTEDATTRVAL = /[^\r\t\n\f &>\u0000]+/g;
var TAGNAME = /[^\r\t\n\f \/>A-Z\u0000]+/g;
var ATTRNAME = /[^\r\t\n\f \/=>A-Z\u0000]+/g;

var CDATATEXT = /[^\]\r\u0000\uffff]*/g;
var DATATEXT = /[^&<\r\u0000\uffff]*/g;
var RAWTEXT = /[^<\r\u0000\uffff]*/g;
var PLAINTEXT = /[^\r\u0000\uffff]*/g;
// Since we don't have the 'sticky tag', add '|.' to the end of SIMPLETAG
// and SIMPLEATTR so that we are guaranteed to always match.  This prevents
// us from scanning past the lastIndex set. (Note that the desired matches
// are always greater than 1 char long, so longest-match will ensure that .
// is not matched unless the desired match fails.)
var SIMPLETAG = /(?:(\/)?([a-z]+)>)|[\s\S]/g;
var SIMPLEATTR = /(?:([-a-z]+)[ \t\n\f]*=[ \t\n\f]*('[^'&\r\u0000]*'|"[^"&\r\u0000]*"|[^\t\n\r\f "&'\u0000>][^&> \t\n\r\f\u0000]*[ \t\n\f]))|[\s\S]/g;

var NONWS = /[^\x09\x0A\x0C\x0D\x20]/;
var ALLNONWS = /[^\x09\x0A\x0C\x0D\x20]/g; // like above, with g flag
var NONWSNONNUL = /[^\x00\x09\x0A\x0C\x0D\x20]/; // don't allow NUL either
var LEADINGWS = /^[\x09\x0A\x0C\x0D\x20]+/;
var NULCHARS = /\x00/g;

/***
 * These are utility functions that don't use any of the parser's
 * internal state.
 */
function buf2str(buf) {
  var CHUNKSIZE=16384;
  if (buf.length < CHUNKSIZE) {
    return String.fromCharCode.apply(String, buf);
  }
  // special case for large strings, to avoid busting the stack.
  var result = '';
  for (var i = 0; i < buf.length; i += CHUNKSIZE) {
    result += String.fromCharCode.apply(String, buf.slice(i, i+CHUNKSIZE));
  }
  return result;
}

function str2buf(s) {
  var result = [];
  for (var i=0; i<s.length; i++) {
    result[i] = s.charCodeAt(i);
  }
  return result;
}

// Determine whether the element is a member of the set.
// The set is an object that maps namespaces to objects. The objects
// then map local tagnames to the value true if that tag is part of the set
function isA(elt, set) {
  if (typeof set === 'string') {
    // convenience case for testing a particular HTML element
    return elt.namespaceURI === NAMESPACE.HTML &&
      elt.localName === set;
  }
  var tagnames = set[elt.namespaceURI];
  return tagnames && tagnames[elt.localName];
}

function isMathmlTextIntegrationPoint(n) {
  return isA(n, mathmlTextIntegrationPointSet);
}

function isHTMLIntegrationPoint(n) {
  if (isA(n, htmlIntegrationPointSet)) return true;
  if (n.namespaceURI === NAMESPACE.MATHML &&
    n.localName === "annotation-xml") {
    var encoding = n.getAttribute("encoding");
    if (encoding) encoding = encoding.toLowerCase();
    if (encoding === "text/html" ||
      encoding === "application/xhtml+xml")
      return true;
  }
  return false;
}

function adjustSVGTagName(name) {
  if (name in svgTagNameAdjustments)
    return svgTagNameAdjustments[name];
  else
    return name;
}

function adjustSVGAttributes(attrs) {
  for(var i = 0, n = attrs.length; i < n; i++) {
    if (attrs[i][0] in svgAttrAdjustments) {
      attrs[i][0] = svgAttrAdjustments[attrs[i][0]];
    }
  }
}

function adjustMathMLAttributes(attrs) {
  for(var i = 0, n = attrs.length; i < n; i++) {
    if (attrs[i][0] === "definitionurl") {
      attrs[i][0] = "definitionURL";
      break;
    }
  }
}

function adjustForeignAttributes(attrs) {
  for(var i = 0, n = attrs.length; i < n; i++) {
    if (attrs[i][0] in foreignAttributes) {
      // Attributes with namespaces get a 3rd element:
      // [Qname, value, namespace]
      attrs[i].push(foreignAttributes[attrs[i][0]]);
    }
  }
}

// For each attribute in attrs, if elt doesn't have an attribute
// by that name, add the attribute to elt
// XXX: I'm ignoring namespaces for now
function transferAttributes(attrs, elt) {
  for(var i = 0, n = attrs.length; i < n; i++) {
    var name = attrs[i][0], value = attrs[i][1];
    if (elt.hasAttribute(name)) continue;
    elt._setAttribute(name, value);
  }
}

/***
 * The ElementStack class
 */
HTMLParser.ElementStack = function ElementStack() {
  this.elements = [];
  this.top = null; // stack.top is the "current node" in the spec
};

/*
// This is for debugging only
HTMLParser.ElementStack.prototype.toString = function(e) {
  return "STACK: " +
  this.elements.map(function(e) {return e.localName;}).join("-");
}
*/

HTMLParser.ElementStack.prototype.push = function(e) {
  this.elements.push(e);
  this.top = e;
};

HTMLParser.ElementStack.prototype.pop = function(e) {
  this.elements.pop();
  this.top = this.elements[this.elements.length-1];
};

// Pop elements off the stack up to and including the first
// element with the specified (HTML) tagname
HTMLParser.ElementStack.prototype.popTag = function(tag) {
  for(var i = this.elements.length-1; i > 0; i--) {
    var e = this.elements[i];
    if (isA(e, tag)) break;
  }
  this.elements.length = i;
  this.top = this.elements[i-1];
};

// Pop elements off the stack up to and including the first
// element that is an instance of the specified type
HTMLParser.ElementStack.prototype.popElementType = function(type) {
  for(var i = this.elements.length-1; i > 0; i--) {
    if (this.elements[i] instanceof type) break;
  }
  this.elements.length = i;
  this.top = this.elements[i-1];
};

// Pop elements off the stack up to and including the element e.
// Note that this is very different from removeElement()
// This requires that e is on the stack.
HTMLParser.ElementStack.prototype.popElement = function(e) {
  for(var i = this.elements.length-1; i > 0; i--) {
    if (this.elements[i] === e) break;
  }
  this.elements.length = i;
  this.top = this.elements[i-1];
};

// Remove a specific element from the stack.
// Do nothing if the element is not on the stack
HTMLParser.ElementStack.prototype.removeElement = function(e) {
  if (this.top === e) this.pop();
  else {
    var idx = this.elements.lastIndexOf(e);
    if (idx !== -1)
      this.elements.splice(idx, 1);
  }
};

HTMLParser.ElementStack.prototype.clearToContext = function(set) {
  // Note that we don't loop to 0. Never pop the <html> elt off.
  for(var i = this.elements.length-1; i > 0; i--) {
    if (isA(this.elements[i], set)) break;
  }
  this.elements.length = i+1;
  this.top = this.elements[i];
};

HTMLParser.ElementStack.prototype.contains = function(tag) {
  return this.inSpecificScope(tag, Object.create(null));
};

HTMLParser.ElementStack.prototype.inSpecificScope = function(tag, set) {
  for(var i = this.elements.length-1; i >= 0; i--) {
    var elt = this.elements[i];
    if (isA(elt, tag)) return true;
    if (isA(elt, set)) return false;
  }
  return false;
};

// Like the above, but for a specific element, not a tagname
HTMLParser.ElementStack.prototype.elementInSpecificScope = function(target, set) {
  for(var i = this.elements.length-1; i >= 0; i--) {
    var elt = this.elements[i];
    if (elt === target) return true;
    if (isA(elt, set)) return false;
  }
  return false;
};

// Like the above, but for an element interface, not a tagname
HTMLParser.ElementStack.prototype.elementTypeInSpecificScope = function(target, set) {
  for(var i = this.elements.length-1; i >= 0; i--) {
    var elt = this.elements[i];
    if (elt instanceof target) return true;
    if (isA(elt, set)) return false;
  }
  return false;
};

HTMLParser.ElementStack.prototype.inScope = function(tag) {
  return this.inSpecificScope(tag, inScopeSet);
};

HTMLParser.ElementStack.prototype.elementInScope = function(e) {
  return this.elementInSpecificScope(e, inScopeSet);
};

HTMLParser.ElementStack.prototype.elementTypeInScope = function(type) {
  return this.elementTypeInSpecificScope(type, inScopeSet);
};

HTMLParser.ElementStack.prototype.inButtonScope = function(tag) {
  return this.inSpecificScope(tag, inButtonScopeSet);
};

HTMLParser.ElementStack.prototype.inListItemScope = function(tag) {
  return this.inSpecificScope(tag, inListItemScopeSet);
};

HTMLParser.ElementStack.prototype.inTableScope = function(tag) {
  return this.inSpecificScope(tag, inTableScopeSet);
};

HTMLParser.ElementStack.prototype.inSelectScope = function(tag) {
  // Can't implement this one with inSpecificScope, since it involves
  // a set defined by inverting another set. So implement manually.
  for(var i = this.elements.length-1; i >= 0; i--) {
    var elt = this.elements[i];
    if (elt.namespaceURI !== NAMESPACE.HTML) return false;
    var localname = elt.localName;
    if (localname === tag) return true;
    if (localname !== "optgroup" && localname !== "option")
      return false;
  }
  return false;
};

HTMLParser.ElementStack.prototype.generateImpliedEndTags = function(butnot, thorough) {
  var endTagSet = thorough ? thoroughImpliedEndTagsSet : impliedEndTagsSet;
  for(var i = this.elements.length-1; i >= 0; i--) {
    var e = this.elements[i];
    if (butnot && isA(e, butnot)) break;
    if (!isA(this.elements[i], endTagSet)) break;
  }

  this.elements.length = i+1;
  this.top = this.elements[i];
};

/***
 * The ActiveFormattingElements class
 */
HTMLParser.ActiveFormattingElements = function AFE() {
  this.list = []; // elements
  this.attrs = []; // attribute tokens for cloning
};

HTMLParser.ActiveFormattingElements.prototype.MARKER = { localName: "|" };

/*
// For debugging
HTMLParser.ActiveFormattingElements.prototype.toString = function() {
  return "AFE: " +
  this.list.map(function(e) { return e.localName; }).join("-");
}
*/

HTMLParser.ActiveFormattingElements.prototype.insertMarker = function() {
  this.list.push(this.MARKER);
  this.attrs.push(this.MARKER);
};

HTMLParser.ActiveFormattingElements.prototype.push = function(elt, attrs) {
  // Scan backwards: if there are already 3 copies of this element
  // before we encounter a marker, then drop the last one
  var count = 0;
  for(var i = this.list.length-1; i >= 0; i--) {
    if (this.list[i] === this.MARKER) break;
    // equal() is defined below
    if (equal(elt, this.list[i], this.attrs[i])) {
      count++;
      if (count === 3) {
        this.list.splice(i, 1);
        this.attrs.splice(i, 1);
        break;
      }
    }
  }


  // Now push the element onto the list
  this.list.push(elt);

  // Copy the attributes and push those on, too
  var attrcopy = [];
  for(var ii = 0; ii < attrs.length; ii++) {
    attrcopy[ii] = attrs[ii];
  }

  this.attrs.push(attrcopy);

  // This function defines equality of two elements for the purposes
  // of the AFE list.  Note that it compares the new elements
  // attributes to the saved array of attributes associated with
  // the old element because a script could have changed the
  // old element's set of attributes
  function equal(newelt, oldelt, oldattrs) {
    if (newelt.localName !== oldelt.localName) return false;
    if (newelt._numattrs !== oldattrs.length) return false;
    for(var i = 0, n = oldattrs.length; i < n; i++) {
      var oldname = oldattrs[i][0];
      var oldval = oldattrs[i][1];
      if (!newelt.hasAttribute(oldname)) return false;
      if (newelt.getAttribute(oldname) !== oldval) return false;
    }
    return true;
  }
};

HTMLParser.ActiveFormattingElements.prototype.clearToMarker = function() {
  for(var i = this.list.length-1; i >= 0; i--) {
    if (this.list[i] === this.MARKER) break;
  }
  if (i < 0) i = 0;
  this.list.length = i;
  this.attrs.length = i;
};

// Find and return the last element with the specified tag between the
// end of the list and the last marker on the list.
// Used when parsing <a> in_body_mode()
HTMLParser.ActiveFormattingElements.prototype.findElementByTag = function(tag) {
  for(var i = this.list.length-1; i >= 0; i--) {
    var elt = this.list[i];
    if (elt === this.MARKER) break;
    if (elt.localName === tag) return elt;
  }
  return null;
};

HTMLParser.ActiveFormattingElements.prototype.indexOf = function(e) {
  return this.list.lastIndexOf(e);
};

// Find the element e in the list and remove it
// Used when parsing <a> in_body()
HTMLParser.ActiveFormattingElements.prototype.remove = function(e) {
  var idx = this.list.lastIndexOf(e);
  if (idx !== -1) {
    this.list.splice(idx, 1);
    this.attrs.splice(idx, 1);
  }
};

// Find element a in the list and replace it with element b
// XXX: Do I need to handle attributes here?
HTMLParser.ActiveFormattingElements.prototype.replace = function(a, b, attrs) {
  var idx = this.list.lastIndexOf(a);
  if (idx !== -1) {
    this.list[idx] = b;
    this.attrs[idx] = attrs;
  }
};

// Find a in the list and insert b after it
// This is only used for insert a bookmark object, so the
// attrs array doesn't really matter
HTMLParser.ActiveFormattingElements.prototype.insertAfter = function(a,b) {
  var idx = this.list.lastIndexOf(a);
  if (idx !== -1) {
    this.list.splice(idx, 0, b);
    this.attrs.splice(idx, 0, b);
  }
};




/***
 * This is the parser factory function. It is the return value of
 * the outer closure that it is defined within.  Most of the parser
 * implementation details are inside this function.
 */
function HTMLParser(address, fragmentContext, options) {
  /***
   * These are the parser's state variables
   */
  // Scanner state
  var chars = null;
  var numchars = 0; // Length of chars
  var nextchar = 0; // Index of next char
  var input_complete = false; // Becomes true when end() called.
  var scanner_skip_newline = false; // If previous char was CR
  var reentrant_invocations = 0;
  var saved_scanner_state = [];
  var leftovers = "";
  var first_batch = true;
  var paused = 0; // Becomes non-zero while loading scripts


  // Tokenizer state
  var tokenizer = data_state; // Current tokenizer state
  var return_state;
  var character_reference_code;
  var tagnamebuf = "";
  var lasttagname = ""; // holds the target end tag for text states
  var tempbuf = [];
  var attrnamebuf = "";
  var attrvaluebuf = "";
  var commentbuf = [];
  var doctypenamebuf = [];
  var doctypepublicbuf = [];
  var doctypesystembuf = [];
  var attributes = [];
  var is_end_tag = false;

  // Tree builder state
  var parser = initial_mode; // Current insertion mode
  var originalInsertionMode = null; // A saved insertion mode
  var templateInsertionModes = []; // Stack of template insertion modes.
  var stack = new HTMLParser.ElementStack(); // Stack of open elements
  var afe = new HTMLParser.ActiveFormattingElements(); // mis-nested tags
  var fragment = (fragmentContext!==undefined); // For innerHTML, etc.
  var head_element_pointer = null;
  var form_element_pointer = null;
  var scripting_enabled = true;
  if (fragmentContext) {
	scripting_enabled = fragmentContext.ownerDocument._scripting_enabled;
  }
  if (options && options.scripting_enabled === false)
    scripting_enabled = false;
  var frameset_ok = true;
  var force_quirks = false;
  var pending_table_text;
  var text_integration_mode; // XXX a spec bug workaround?

  // A single run of characters, buffered up to be sent to
  // the parser as a single string.
  var textrun = [];
  var textIncludesNUL = false;
  var ignore_linefeed = false;

  /***
   * This is the parser object that will be the return value of this
   * factory function, which is some 5000 lines below.
   * Note that the variable "parser" is the current state of the
   * parser's state machine.  This variable "htmlparser" is the
   * return value and defines the public API of the parser
   */
  var htmlparser = {
    document: function() {
      return doc;
    },

    // Internal function used from HTMLScriptElement to pause the
    // parser while a script is being loaded from the network
    pause: function() {
      // print("pausing parser");
      paused++;
    },

    // Called when a script finishes loading
    resume: function() {
      // print("resuming parser");
      paused--;
      // XXX: added this to force a resumption.
      // Is this the right thing to do?
      this.parse("");
    },

    // Parse the HTML text s.
    // The second argument should be true if there is no more
    // text to be parsed, and should be false or omitted otherwise.
    // The second argument must not be set for recursive invocations
    // from document.write()
    parse: function(s, end) {

      // If we're paused, remember the text to parse, but
      // don't parse it now.
      if (paused > 0) {
        leftovers += s;
        return;
      }


      if (reentrant_invocations === 0) {
        // A normal, top-level invocation
        if (leftovers) {
          s = leftovers + s;
          leftovers = "";
        }

        // Add a special marker character to the end of
        // the buffer.  If the scanner is at the end of
        // the buffer and input_complete is set, then this
        // character will transform into an EOF token.
        // Having an actual character that represents EOF
        // in the character buffer makes lookahead regexp
        // matching work more easily, and this is
        // important for character references.
        if (end) {
          s += "\uFFFF";
          input_complete = true; // Makes scanChars() send EOF
        }

        chars = s;
        numchars = s.length;
        nextchar = 0;

        if (first_batch) {
          // We skip a leading Byte Order Mark (\uFEFF)
          // on first batch of text we're given
          first_batch = false;
          if (chars.charCodeAt(0) === 0xFEFF) nextchar = 1;
        }

        reentrant_invocations++;
        scanChars();
        leftovers = chars.substring(nextchar, numchars);
        reentrant_invocations--;
      }
      else {
        // This is the re-entrant case, which we have to
        // handle a little differently.
        reentrant_invocations++;

        // Save current scanner state
        saved_scanner_state.push(chars, numchars, nextchar);

        // Set new scanner state
        chars = s;
        numchars = s.length;
        nextchar = 0;

        // Now scan as many of these new chars as we can
        scanChars();

        leftovers = chars.substring(nextchar, numchars);

        // restore old scanner state
        nextchar = saved_scanner_state.pop();
        numchars = saved_scanner_state.pop();
        chars = saved_scanner_state.pop();

        // If there were leftover chars from this invocation
        // insert them into the pending invocation's buffer
        // and trim already processed chars at the same time
        if (leftovers) {
          chars = leftovers + chars.substring(nextchar);
          numchars = chars.length;
          nextchar = 0;
          leftovers = "";
        }

        // Decrement the counter
        reentrant_invocations--;
      }
    }
  };


  // This is the document we'll be building up
  var doc = new Document(true, address);

  // The document needs to know about the parser, for document.write().
  // This _parser property will be deleted when we're done parsing.
  doc._parser = htmlparser;

  // XXX I think that any document we use this parser on should support
  // scripts. But I may need to configure that through a parser parameter
  // Only documents with windows ("browsing contexts" to be precise)
  // allow scripting.
  doc._scripting_enabled = scripting_enabled;


  /***
   * The actual code of the HTMLParser() factory function begins here.
   */

  if (fragmentContext) { // for innerHTML parsing
    if (fragmentContext.ownerDocument._quirks)
      doc._quirks = true;
    if (fragmentContext.ownerDocument._limitedQuirks)
      doc._limitedQuirks = true;

    // Set the initial tokenizer state
    if (fragmentContext.namespaceURI === NAMESPACE.HTML) {
      switch(fragmentContext.localName) {
      case "title":
      case "textarea":
        tokenizer = rcdata_state;
        break;
      case "style":
      case "xmp":
      case "iframe":
      case "noembed":
      case "noframes":
      case "script":
      case "plaintext":
        tokenizer = plaintext_state;
        break;
      case "noscript":
        if (scripting_enabled)
          tokenizer = plaintext_state;
      }
    }

    var root = doc.createElement("html");
    doc._appendChild(root);
    stack.push(root);
    if (fragmentContext instanceof impl.HTMLTemplateElement) {
      templateInsertionModes.push(in_template_mode);
    }
    resetInsertionMode();

    for(var e = fragmentContext; e !== null; e = e.parentElement) {
      if (e instanceof impl.HTMLFormElement) {
        form_element_pointer = e;
        break;
      }
    }
  }

  /***
   * Scanner functions
   */
  // Loop through the characters in chars, and pass them one at a time
  // to the tokenizer FSM. Return when no more characters can be processed
  // (This may leave 1 or more characters in the buffer: like a CR
  // waiting to see if the next char is LF, or for states that require
  // lookahead...)
  function scanChars() {
    var codepoint, s, pattern, eof;

    while(nextchar < numchars) {

      // If we just tokenized a </script> tag, then the paused flag
      // may have been set to tell us to stop tokenizing while
      // the script is loading
      if (paused > 0) {
        return;
      }


      switch(typeof tokenizer.lookahead) {
      case 'undefined':
        codepoint = chars.charCodeAt(nextchar++);
        if (scanner_skip_newline) {
          scanner_skip_newline = false;
          if (codepoint === 0x000A) {
            nextchar++;
            continue;
          }
        }
        switch(codepoint) {
        case 0x000D:
          // CR always turns into LF, but if the next character
          // is LF, then that second LF is skipped.
          if (nextchar < numchars) {
            if (chars.charCodeAt(nextchar) === 0x000A)
              nextchar++;
          }
          else {
            // We don't know the next char right now, so we
            // can't check if it is a LF.  So set a flag
            scanner_skip_newline = true;
          }

          // In either case, emit a LF
          tokenizer(0x000A);

          break;
        case 0xFFFF:
          if (input_complete && nextchar === numchars) {
            tokenizer(EOF); // codepoint will be 0xFFFF here
            break;
          }
          /* falls through */
        default:
          tokenizer(codepoint);
          break;
        }
        break;

      case 'number':
        codepoint = chars.charCodeAt(nextchar);

        // The only tokenizer states that require fixed lookahead
        // only consume alphanum characters, so we don't have
        // to worry about CR and LF in this case

        // tokenizer wants n chars of lookahead
        var n = tokenizer.lookahead;
        var needsString = true;
        if (n < 0) {
          needsString = false;
          n = -n;
        }

        if (n < numchars - nextchar) {
          // If we can look ahead that far
          s = needsString ? chars.substring(nextchar, nextchar+n) : null;
          eof = false;
        }
        else { // if we don't have that many characters
          if (input_complete) { // If no more are coming
            // Just return what we have
            s = needsString ? chars.substring(nextchar, numchars) : null;
            eof = true;
            if (codepoint === 0xFFFF && nextchar === numchars-1)
              codepoint = EOF;
          }
          else {
            // Return now and wait for more chars later
            return;
          }
        }
        tokenizer(codepoint, s, eof);
        break;
      case 'string':
        codepoint = chars.charCodeAt(nextchar);

        // tokenizer wants characters up to a matching string
        pattern = tokenizer.lookahead;
        var pos = chars.indexOf(pattern, nextchar);
        if (pos !== -1) {
          s = chars.substring(nextchar, pos + pattern.length);
          eof = false;
        }
        else {  // No match
          // If more characters coming, wait for them
          if (!input_complete) return;

          // Otherwise, we've got to return what we've got
          s = chars.substring(nextchar, numchars);
          if (codepoint === 0xFFFF && nextchar === numchars-1)
            codepoint = EOF;
          eof = true;
        }

        // The tokenizer states that require this kind of
        // lookahead have to be careful to handle CR characters
        // correctly
        tokenizer(codepoint, s, eof);
        break;
      }
    }
  }


  /***
   * Tokenizer utility functions
   */
  function addAttribute(name,value) {
    // Make sure there isn't already an attribute with this name
    // If there is, ignore this one.
    for(var i = 0; i < attributes.length; i++) {
      if (attributes[i][0] === name) return;
    }

    if (value !== undefined) {
      attributes.push([name, value]);
    }
    else {
      attributes.push([name]);
    }
  }

  // Shortcut for simple attributes
  function handleSimpleAttribute() {
    SIMPLEATTR.lastIndex = nextchar-1;
    var matched = SIMPLEATTR.exec(chars);
    if (!matched) throw new Error("should never happen");
    var name = matched[1];
    if (!name) return false;
    var value = matched[2];
    var len = value.length;
    switch(value[0]) {
    case '"':
    case "'":
      value = value.substring(1, len-1);
      nextchar += (matched[0].length-1);
      tokenizer = after_attribute_value_quoted_state;
      break;
    default:
      tokenizer = before_attribute_name_state;
      nextchar += (matched[0].length-1);
      value = value.substring(0, len-1);
      break;
    }

    // Make sure there isn't already an attribute with this name
    // If there is, ignore this one.
    for(var i = 0; i < attributes.length; i++) {
      if (attributes[i][0] === name) return true;
    }

    attributes.push([name, value]);
    return true;
  }

  function beginTagName() {
    is_end_tag = false;
    tagnamebuf = "";
    attributes.length = 0;
  }
  function beginEndTagName() {
    is_end_tag = true;
    tagnamebuf = "";
    attributes.length = 0;
  }

  function beginTempBuf() { tempbuf.length = 0; }
  function beginAttrName() { attrnamebuf = ""; }
  function beginAttrValue() { attrvaluebuf = ""; }
  function beginComment() { commentbuf.length = 0; }
  function beginDoctype() {
    doctypenamebuf.length = 0;
    doctypepublicbuf = null;
    doctypesystembuf = null;
  }
  function beginDoctypePublicId() { doctypepublicbuf = []; }
  function beginDoctypeSystemId() { doctypesystembuf = []; }
  function forcequirks() { force_quirks = true; }
  function cdataAllowed() {
    return stack.top &&
      stack.top.namespaceURI !== "http://www.w3.org/1999/xhtml";
  }

  // Return true if the codepoints in the specified buffer match the
  // characters of lasttagname
  function appropriateEndTag(buf) {
    return lasttagname === buf;
  }

  function flushText() {
    if (textrun.length > 0) {
      var s = buf2str(textrun);
      textrun.length = 0;

      if (ignore_linefeed) {
        ignore_linefeed = false;
        if (s[0] === "\n") s = s.substring(1);
        if (s.length === 0) return;
      }

      insertToken(TEXT, s);
      textIncludesNUL = false;
    }
    ignore_linefeed = false;
  }

  // Consume chars matched by the pattern and return them as a string. Starts
  // matching at the current position, so users should drop the current char
  // otherwise.
  function getMatchingChars(pattern) {
    pattern.lastIndex = nextchar - 1;
    var match = pattern.exec(chars);
    if (match && match.index === nextchar - 1) {
      match = match[0];
      nextchar += match.length - 1;
      /* Careful!  Make sure we haven't matched the EOF character! */
      if (input_complete && nextchar === numchars) {
        // Oops, backup one.
        match = match.slice(0, -1);
        nextchar--;
      }
      return match;
    } else {
      throw new Error("should never happen");
    }
  }

  // emit a string of chars that match a regexp
  // Returns false if no chars matched.
  function emitCharsWhile(pattern) {
    pattern.lastIndex = nextchar-1;
    var match = pattern.exec(chars)[0];
    if (!match) return false;
    emitCharString(match);
    nextchar += match.length - 1;
    return true;
  }

  // This is used by CDATA sections
  function emitCharString(s) {
    if (textrun.length > 0) flushText();

    if (ignore_linefeed) {
      ignore_linefeed = false;
      if (s[0] === "\n") s = s.substring(1);
      if (s.length === 0) return;
    }

    insertToken(TEXT, s);
  }

  function emitTag() {
    if (is_end_tag) insertToken(ENDTAG, tagnamebuf);
    else {
      // Remember the last open tag we emitted
      var tagname = tagnamebuf;
      tagnamebuf = "";
      lasttagname = tagname;
      insertToken(TAG, tagname, attributes);
    }
  }


  // A shortcut: look ahead and if this is a open or close tag
  // in lowercase with no spaces and no attributes, just emit it now.
  function emitSimpleTag() {
    SIMPLETAG.lastIndex = nextchar;
    var matched = SIMPLETAG.exec(chars);
    if (!matched) throw new Error("should never happen");
    var tagname = matched[2];
    if (!tagname) return false;
    var endtag = matched[1];
    if (endtag) {
      nextchar += (tagname.length+2);
      insertToken(ENDTAG, tagname);
    }
    else {
      nextchar += (tagname.length+1);
      lasttagname = tagname;
      insertToken(TAG, tagname, NOATTRS);
    }
    return true;
  }

  function emitSelfClosingTag() {
    if (is_end_tag) insertToken(ENDTAG, tagnamebuf, null, true);
    else {
      insertToken(TAG, tagnamebuf, attributes, true);
    }
  }

  function emitDoctype() {
    insertToken(DOCTYPE,
          buf2str(doctypenamebuf),
          doctypepublicbuf ? buf2str(doctypepublicbuf) : undefined,
          doctypesystembuf ? buf2str(doctypesystembuf) : undefined);
  }

  function emitEOF() {
    flushText();
    parser(EOF); // EOF never goes to insertForeignContent()
    doc.modclock = 1; // Start tracking modifications
  }

  // Insert a token, either using the current parser insertion mode
  // (for HTML stuff) or using the insertForeignToken() method.
  var insertToken = htmlparser.insertToken = function insertToken(t, value, arg3, arg4) {
    flushText();
    var current = stack.top;

    if (!current || current.namespaceURI === NAMESPACE.HTML) {
      // This is the common case
      parser(t, value, arg3, arg4);
    }
    else {
      // Otherwise we may need to insert this token as foreign content
      if (t !== TAG && t !== TEXT) {
        insertForeignToken(t, value, arg3, arg4);
      }
      else {
        // But in some cases we treat it as regular content
        if ((isMathmlTextIntegrationPoint(current) &&
           (t === TEXT ||
            (t === TAG &&
             value !== "mglyph" && value !== "malignmark"))) ||
          (t === TAG &&
           value === "svg" &&
           current.namespaceURI === NAMESPACE.MATHML &&
           current.localName === "annotation-xml") ||
          isHTMLIntegrationPoint(current)) {

          // XXX: the text_integration_mode stuff is an
          // attempted bug workaround of mine
          text_integration_mode = true;
          parser(t, value, arg3, arg4);
          text_integration_mode = false;
        }
        // Otherwise it is foreign content
        else {
          insertForeignToken(t, value, arg3, arg4);
        }
      }
    }
  };


  /***
   * Tree building utility functions
   */
  function insertComment(data) {
    var parent = stack.top;
    if (foster_parent_mode && isA(parent, tablesectionrowSet)) {
      fosterParent(function(doc) { return doc.createComment(data); });
    } else {
      // "If the adjusted insertion location is inside a template element,
      // let it instead be inside the template element's template contents"
      if (parent instanceof impl.HTMLTemplateElement) {
        parent = parent.content;
      }
      parent._appendChild(parent.ownerDocument.createComment(data));
    }
  }

  function insertText(s) {
    var parent = stack.top;
    if (foster_parent_mode && isA(parent, tablesectionrowSet)) {
      fosterParent(function(doc) { return doc.createTextNode(s); });
    } else {
      // "If the adjusted insertion location is inside a template element,
      // let it instead be inside the template element's template contents"
      if (parent instanceof impl.HTMLTemplateElement) {
        parent = parent.content;
      }
      // "If there is a Text node immediately before the adjusted insertion
      // location, then append data to that Text node's data."
      var lastChild = parent.lastChild;
      if (lastChild && lastChild.nodeType === Node.TEXT_NODE) {
        lastChild.appendData(s);
      } else {
        parent._appendChild(parent.ownerDocument.createTextNode(s));
      }
    }
  }

  function createHTMLElt(doc, name, attrs) {
    // Create the element this way, rather than with
    // doc.createElement because createElement() does error
    // checking on the element name that we need to avoid here.
    var elt = html.createElement(doc, name, null);

    if (attrs) {
      for(var i = 0, n = attrs.length; i < n; i++) {
        // Use the _ version to avoid testing the validity
        // of the attribute name
        elt._setAttribute(attrs[i][0], attrs[i][1]);
      }
    }
    // XXX
    // If the element is a resettable form element,
    // run its reset algorithm now
    // XXX
    // handle case where form-element-pointer is not null
    return elt;
  }

  // The in_table insertion mode turns on this flag, and that makes
  // insertHTMLElement use the foster parenting algorithm for elements
  // tags inside a table
  var foster_parent_mode = false;

  function insertHTMLElement(name, attrs) {
    var elt = insertElement(function(doc) {
      return createHTMLElt(doc, name, attrs);
    });

    // XXX
    // If this is a form element, set its form attribute property here
    if (isA(elt, formassociatedSet)) {
      elt._form = form_element_pointer;
    }

    return elt;
  }

  // Insert the element into the open element or foster parent it
  function insertElement(eltFunc) {
    var elt;
    if (foster_parent_mode && isA(stack.top, tablesectionrowSet)) {
      elt = fosterParent(eltFunc);
    }
    else if (stack.top instanceof impl.HTMLTemplateElement) {
      // "If the adjusted insertion location is inside a template element,
      // let it instead be inside the template element's template contents"
      elt = eltFunc(stack.top.content.ownerDocument);
      stack.top.content._appendChild(elt);
    } else {
      elt = eltFunc(stack.top.ownerDocument);
      stack.top._appendChild(elt);
    }

    stack.push(elt);
    return elt;
  }

  function insertForeignElement(name, attrs, ns) {
    return insertElement(function(doc) {
      var elt = doc.createElementNS(ns, name);
      if (attrs) {
        for(var i = 0, n = attrs.length; i < n; i++) {
          var attr = attrs[i];
          if (attr.length === 2)
            elt._setAttribute(attr[0], attr[1]);
          else {
            elt._setAttributeNS(attr[2], attr[0], attr[1]);
          }
        }
      }
      return elt;
    });
  }

  function lastElementOfType(type) {
    for(var i = stack.elements.length-1; i >= 0; i--) {
      if (stack.elements[i] instanceof type) {
        return i;
      }
    }
    return -1;
  }

  function fosterParent(eltFunc) {
    var parent, before, lastTable = -1, lastTemplate = -1, elt;

    lastTable = lastElementOfType(impl.HTMLTableElement);
    lastTemplate = lastElementOfType(impl.HTMLTemplateElement);

    if (lastTemplate >= 0 && (lastTable < 0 || lastTemplate > lastTable)) {
      parent = stack.elements[lastTemplate];
    } else if (lastTable >= 0) {
      parent = stack.elements[lastTable].parentNode;
      if (parent) {
        before = stack.elements[lastTable];
      } else {
        parent = stack.elements[lastTable - 1];
      }
    }
    if (!parent) parent = stack.elements[0]; // the `html` element.

    // "If the adjusted insertion location is inside a template element,
    // let it instead be inside the template element's template contents"
    if (parent instanceof impl.HTMLTemplateElement) {
      parent = parent.content;
    }
    // Create element in the appropriate document.
    elt = eltFunc(parent.ownerDocument);

    if (elt.nodeType === Node.TEXT_NODE) {
      var prev;
      if (before) prev = before.previousSibling;
      else prev = parent.lastChild;
      if (prev && prev.nodeType === Node.TEXT_NODE) {
        prev.appendData(elt.data);
        return elt;
      }
    }
    if (before)
      parent.insertBefore(elt, before);
    else
      parent._appendChild(elt);
    return elt;
  }


  function resetInsertionMode() {
    var last = false;
    for(var i = stack.elements.length-1; i >= 0; i--) {
      var node = stack.elements[i];
      if (i === 0) {
        last = true;
        if (fragment) {
          node = fragmentContext;
        }
      }
      if (node.namespaceURI === NAMESPACE.HTML) {
        var tag = node.localName;
        switch(tag) {
        case "select":
          for(var j = i; j > 0; ) {
            var ancestor = stack.elements[--j];
            if (ancestor instanceof impl.HTMLTemplateElement) {
              break;
            } else if (ancestor instanceof impl.HTMLTableElement) {
              parser = in_select_in_table_mode;
              return;
            }
          }
          parser = in_select_mode;
          return;
        case "tr":
          parser = in_row_mode;
          return;
        case "tbody":
        case "tfoot":
        case "thead":
          parser = in_table_body_mode;
          return;
        case "caption":
          parser = in_caption_mode;
          return;
        case "colgroup":
          parser = in_column_group_mode;
          return;
        case "table":
          parser = in_table_mode;
          return;
        case "template":
          parser = templateInsertionModes[templateInsertionModes.length-1];
          return;
        case "body":
          parser = in_body_mode;
          return;
        case "frameset":
          parser = in_frameset_mode;
          return;
        case "html":
          if (head_element_pointer === null) {
            parser = before_head_mode;
          } else {
            parser = after_head_mode;
          }
          return;
        default:
          if (!last) {
            if (tag === "head") {
              parser = in_head_mode;
              return;
            }
            if (tag === "td" || tag === "th") {
              parser = in_cell_mode;
              return;
            }
          }
        }
      }
      if (last) {
        parser = in_body_mode;
        return;
      }
    }
  }


  function parseRawText(name, attrs) {
    insertHTMLElement(name, attrs);
    tokenizer = rawtext_state;
    originalInsertionMode = parser;
    parser = text_mode;
  }

  function parseRCDATA(name, attrs) {
    insertHTMLElement(name, attrs);
    tokenizer = rcdata_state;
    originalInsertionMode = parser;
    parser = text_mode;
  }

  // Make a copy of element i on the list of active formatting
  // elements, using its original attributes, not current
  // attributes (which may have been modified by a script)
  function afeclone(doc, i) {
    return {
      elt: createHTMLElt(doc, afe.list[i].localName, afe.attrs[i]),
      attrs: afe.attrs[i],
    };
  }


  function afereconstruct() {
    if (afe.list.length === 0) return;
    var entry = afe.list[afe.list.length-1];
    // If the last is a marker , do nothing
    if (entry === afe.MARKER) return;
    // Or if it is an open element, do nothing
    if (stack.elements.lastIndexOf(entry) !== -1) return;

    // Loop backward through the list until we find a marker or an
    // open element, and then move forward one from there.
    for(var i = afe.list.length-2; i >= 0; i--) {
      entry = afe.list[i];
      if (entry === afe.MARKER) break;
      if (stack.elements.lastIndexOf(entry) !== -1) break;
    }

    // Now loop forward, starting from the element after the current
    // one, recreating formatting elements and pushing them back onto
    // the list of open elements
    for(i = i+1; i < afe.list.length; i++) {
      var newelt = insertElement(function(doc) { return afeclone(doc, i).elt; });
      afe.list[i] = newelt;
    }
  }

  // Used by the adoptionAgency() function
  var BOOKMARK = {localName:"BM"};

  function adoptionAgency(tag) {
    // If the current node is an HTML element whose tag name is subject,
    // and the current node is not in the list of active formatting
    // elements, then pop the current node off the stack of open
    // elements and abort these steps.
    if (isA(stack.top, tag) && afe.indexOf(stack.top) === -1) {
      stack.pop();
      return true; // no more handling required
    }

    // Let outer loop counter be zero.
    var outer = 0;

    // Outer loop: If outer loop counter is greater than or
    // equal to eight, then abort these steps.
    while(outer < 8) {
      // Increment outer loop counter by one.
      outer++;

      // Let the formatting element be the last element in the list
      // of active formatting elements that: is between the end of
      // the list and the last scope marker in the list, if any, or
      // the start of the list otherwise, and has the same tag name
      // as the token.
      var fmtelt = afe.findElementByTag(tag);

      // If there is no such node, then abort these steps and instead
      // act as described in the "any other end tag" entry below.
      if (!fmtelt) {
        return false; // false means handle by the default case
      }

      // Otherwise, if there is such a node, but that node is not in
      // the stack of open elements, then this is a parse error;
      // remove the element from the list, and abort these steps.
      var index = stack.elements.lastIndexOf(fmtelt);
      if (index === -1) {
        afe.remove(fmtelt);
        return true;   // true means no more handling required
      }

      // Otherwise, if there is such a node, and that node is also in
      // the stack of open elements, but the element is not in scope,
      // then this is a parse error; ignore the token, and abort
      // these steps.
      if (!stack.elementInScope(fmtelt)) {
        return true;
      }

      // Let the furthest block be the topmost node in the stack of
      // open elements that is lower in the stack than the formatting
      // element, and is an element in the special category. There
      // might not be one.
      var furthestblock = null, furthestblockindex;
      for(var i = index+1; i < stack.elements.length; i++) {
        if (isA(stack.elements[i], specialSet)) {
          furthestblock = stack.elements[i];
          furthestblockindex = i;
          break;
        }
      }

      // If there is no furthest block, then the UA must skip the
      // subsequent steps and instead just pop all the nodes from the
      // bottom of the stack of open elements, from the current node
      // up to and including the formatting element, and remove the
      // formatting element from the list of active formatting
      // elements.
      if (!furthestblock) {
        stack.popElement(fmtelt);
        afe.remove(fmtelt);
        return true;
      }
      else {
        // Let the common ancestor be the element immediately above
        // the formatting element in the stack of open elements.
        var ancestor = stack.elements[index-1];

        // Let a bookmark note the position of the formatting
        // element in the list of active formatting elements
        // relative to the elements on either side of it in the
        // list.
        afe.insertAfter(fmtelt, BOOKMARK);

        // Let node and last node be the furthest block.
        var node = furthestblock;
        var lastnode = furthestblock;
        var nodeindex = furthestblockindex;
        var nodeafeindex;

        // Let inner loop counter be zero.
        var inner = 0;

        while (true) {

          // Increment inner loop counter by one.
          inner++;

          // Let node be the element immediately above node in
          // the stack of open elements, or if node is no longer
          // in the stack of open elements (e.g. because it got
          // removed by this algorithm), the element that was
          // immediately above node in the stack of open elements
          // before node was removed.
          node = stack.elements[--nodeindex];

          // If node is the formatting element, then go
          // to the next step in the overall algorithm.
          if (node === fmtelt) break;

          // If the inner loop counter is greater than three and node
          // is in the list of active formatting elements, then remove
          // node from the list of active formatting elements.
          nodeafeindex = afe.indexOf(node);
          if (inner > 3 && nodeafeindex !== -1) {
            afe.remove(node);
            nodeafeindex = -1;
          }

          // If node is not in the list of active formatting
          // elements, then remove node from the stack of open
          // elements and then go back to the step labeled inner
          // loop.
          if (nodeafeindex === -1) {
            stack.removeElement(node);
            continue;
          }

          // Create an element for the token for which the
          // element node was created with common ancestor as
          // the intended parent, replace the entry for node
          // in the list of active formatting elements with an
          // entry for the new element, replace the entry for
          // node in the stack of open elements with an entry for
          // the new element, and let node be the new element.
          var newelt = afeclone(ancestor.ownerDocument, nodeafeindex);
          afe.replace(node, newelt.elt, newelt.attrs);
          stack.elements[nodeindex] = newelt.elt;
          node = newelt.elt;

          // If last node is the furthest block, then move the
          // aforementioned bookmark to be immediately after the
          // new node in the list of active formatting elements.
          if (lastnode === furthestblock) {
            afe.remove(BOOKMARK);
            afe.insertAfter(newelt.elt, BOOKMARK);
          }

          // Insert last node into node, first removing it from
          // its previous parent node if any.
          node._appendChild(lastnode);

          // Let last node be node.
          lastnode = node;
        }

        // If the common ancestor node is a table, tbody, tfoot,
        // thead, or tr element, then, foster parent whatever last
        // node ended up being in the previous step, first removing
        // it from its previous parent node if any.
        if (foster_parent_mode && isA(ancestor, tablesectionrowSet)) {
          fosterParent(function() { return lastnode; });
        }
        // Otherwise, append whatever last node ended up being in
        // the previous step to the common ancestor node, first
        // removing it from its previous parent node if any.
        else if (ancestor instanceof impl.HTMLTemplateElement) {
          ancestor.content._appendChild(lastnode);
        } else {
          ancestor._appendChild(lastnode);
        }

        // Create an element for the token for which the
        // formatting element was created, with furthest block
        // as the intended parent.
        var newelt2 = afeclone(furthestblock.ownerDocument, afe.indexOf(fmtelt));

        // Take all of the child nodes of the furthest block and
        // append them to the element created in the last step.
        while(furthestblock.hasChildNodes()) {
          newelt2.elt._appendChild(furthestblock.firstChild);
        }

        // Append that new element to the furthest block.
        furthestblock._appendChild(newelt2.elt);

        // Remove the formatting element from the list of active
        // formatting elements, and insert the new element into the
        // list of active formatting elements at the position of
        // the aforementioned bookmark.
        afe.remove(fmtelt);
        afe.replace(BOOKMARK, newelt2.elt, newelt2.attrs);

        // Remove the formatting element from the stack of open
        // elements, and insert the new element into the stack of
        // open elements immediately below the position of the
        // furthest block in that stack.
        stack.removeElement(fmtelt);
        var pos = stack.elements.lastIndexOf(furthestblock);
        stack.elements.splice(pos+1, 0, newelt2.elt);
      }
    }

    return true;
  }

  // We do this when we get /script in in_text_mode
  function handleScriptEnd() {
    // XXX:
    // This is just a stub implementation right now and doesn't run scripts.
    // Getting this method right involves the event loop, URL resolution
    // script fetching etc. For now I just want to be able to parse
    // documents and test the parser.

    //var script = stack.top;
    stack.pop();
    parser = originalInsertionMode;
    //script._prepare();
    return;

    // XXX: here is what this method is supposed to do

    // Provide a stable state.

    // Let script be the current node (which will be a script
    // element).

    // Pop the current node off the stack of open elements.

    // Switch the insertion mode to the original insertion mode.

    // Let the old insertion point have the same value as the current
    // insertion point. Let the insertion point be just before the
    // next input character.

    // Increment the parser's script nesting level by one.

    // Prepare the script. This might cause some script to execute,
    // which might cause new characters to be inserted into the
    // tokenizer, and might cause the tokenizer to output more tokens,
    // resulting in a reentrant invocation of the parser.

    // Decrement the parser's script nesting level by one. If the
    // parser's script nesting level is zero, then set the parser
    // pause flag to false.

    // Let the insertion point have the value of the old insertion
    // point. (In other words, restore the insertion point to its
    // previous value. This value might be the "undefined" value.)

    // At this stage, if there is a pending parsing-blocking script,
    // then:

    // If the script nesting level is not zero:

    //   Set the parser pause flag to true, and abort the processing
    //   of any nested invocations of the tokenizer, yielding
    //   control back to the caller. (Tokenization will resume when
    //   the caller returns to the "outer" tree construction stage.)

    //   The tree construction stage of this particular parser is
    //   being called reentrantly, say from a call to
    //   document.write().

    // Otherwise:

    //     Run these steps:

    //       Let the script be the pending parsing-blocking
    //       script. There is no longer a pending
    //       parsing-blocking script.

    //       Block the tokenizer for this instance of the HTML
    //       parser, such that the event loop will not run tasks
    //       that invoke the tokenizer.

    //       If the parser's Document has a style sheet that is
    //       blocking scripts or the script's "ready to be
    //       parser-executed" flag is not set: spin the event
    //       loop until the parser's Document has no style sheet
    //       that is blocking scripts and the script's "ready to
    //       be parser-executed" flag is set.

    //       Unblock the tokenizer for this instance of the HTML
    //       parser, such that tasks that invoke the tokenizer
    //       can again be run.

    //       Let the insertion point be just before the next
    //       input character.

    //       Increment the parser's script nesting level by one
    //       (it should be zero before this step, so this sets
    //       it to one).

    //       Execute the script.

    //       Decrement the parser's script nesting level by
    //       one. If the parser's script nesting level is zero
    //       (which it always should be at this point), then set
    //       the parser pause flag to false.

    //       Let the insertion point be undefined again.

    //       If there is once again a pending parsing-blocking
    //       script, then repeat these steps from step 1.


  }

  function stopParsing() {
    // XXX This is just a temporary implementation to get the parser working.
    // A full implementation involves scripts and events and the event loop.

    // Remove the link from document to parser.
    // This is instead of "set the insertion point to undefined".
    // It means that document.write() can't write into the doc anymore.
    delete doc._parser;

    stack.elements.length = 0; // pop everything off

    // If there is a window object associated with the document
    // then trigger an load event on it
    if (doc.defaultView) {
      doc.defaultView.dispatchEvent(new impl.Event("load",{}));
    }

  }

  /****
   * Tokenizer states
   */

  /**
   * This file was partially mechanically generated from
   * http://www.whatwg.org/specs/web-apps/current-work/multipage/tokenization.html
   *
   * After mechanical conversion, it was further converted from
   * prose to JS by hand, but the intent is that it is a very
   * faithful rendering of the HTML tokenization spec in
   * JavaScript.
   *
   * It is not a goal of this tokenizer to detect or report
   * parse errors.
   *
   * XXX The tokenizer is supposed to work with straight UTF32
   * codepoints. But I don't think it has any dependencies on
   * any character outside of the BMP so I think it is safe to
   * pass it UTF16 characters. I don't think it will ever change
   * state in the middle of a surrogate pair.
   */

  /*
   * Each state is represented by a function.  For most states, the
   * scanner simply passes the next character (as an integer
   * codepoint) to the current state function and automatically
   * consumes the character.  If the state function can't process
   * the character it can call pushback() to push it back to the
   * scanner.
   *
   * Some states require lookahead, though.  If a state function has
   * a lookahead property, then it is invoked differently.  In this
   * case, the scanner invokes the function with 3 arguments: 1) the
   * next codepoint 2) a string of lookahead text 3) a boolean that
   * is true if the lookahead goes all the way to the EOF. (XXX
   * actually maybe this third is not necessary... the lookahead
   * could just include \uFFFF?)
   *
   * If the lookahead property of a state function is an integer, it
   * specifies the number of characters required. If it is a string,
   * then the scanner will scan for that string and return all
   * characters up to and including that sequence, or up to EOF.  If
   * the lookahead property is a regexp, then the scanner will match
   * the regexp at the current point and return the matching string.
   *
   * States that require lookahead are responsible for explicitly
   * consuming the characters they process. They do this by
   * incrementing nextchar by the number of processed characters.
   */
  function reconsume(c, new_state) {
    tokenizer = new_state;
    nextchar--; // pushback
  }

  function data_state(c) {
    switch(c) {
    case 0x0026: // AMPERSAND
      return_state = data_state;
      tokenizer = character_reference_state;
      break;
    case 0x003C: // LESS-THAN SIGN
      if (emitSimpleTag()) // Shortcut for <p>, <dl>, </div> etc.
        break;
      tokenizer = tag_open_state;
      break;
    case 0x0000: // NULL
      // Usually null characters emitted by the tokenizer will be
      // ignored by the tree builder, but sometimes they'll be
      // converted to \uFFFD.  I don't want to have the search every
      // string emitted to replace NULs, so I'll set a flag
      // if I've emitted a NUL.
      textrun.push(c);
      textIncludesNUL = true;
      break;
    case -1: // EOF
      emitEOF();
      break;
    default:
      // Instead of just pushing a single character and then
      // coming back to the very same place, lookahead and
      // emit everything we can at once.
      /*jshint -W030 */
      emitCharsWhile(DATATEXT) || textrun.push(c);
      break;
    }
  }

  function rcdata_state(c) {
    // Save the open tag so we can find a matching close tag
    switch(c) {
    case 0x0026: // AMPERSAND
      return_state = rcdata_state;
      tokenizer = character_reference_state;
      break;
    case 0x003C: // LESS-THAN SIGN
      tokenizer = rcdata_less_than_sign_state;
      break;
    case 0x0000: // NULL
      textrun.push(0xFFFD); // REPLACEMENT CHARACTER
      textIncludesNUL = true;
      break;
    case -1: // EOF
      emitEOF();
      break;
    default:
      textrun.push(c);
      break;
    }
  }

  function rawtext_state(c) {
    switch(c) {
    case 0x003C: // LESS-THAN SIGN
      tokenizer = rawtext_less_than_sign_state;
      break;
    case 0x0000: // NULL
      textrun.push(0xFFFD); // REPLACEMENT CHARACTER
      break;
    case -1: // EOF
      emitEOF();
      break;
    default:
      /*jshint -W030 */
      emitCharsWhile(RAWTEXT) || textrun.push(c);
      break;
    }
  }

  function script_data_state(c) {
    switch(c) {
    case 0x003C: // LESS-THAN SIGN
      tokenizer = script_data_less_than_sign_state;
      break;
    case 0x0000: // NULL
      textrun.push(0xFFFD); // REPLACEMENT CHARACTER
      break;
    case -1: // EOF
      emitEOF();
      break;
    default:
      /*jshint -W030 */
      emitCharsWhile(RAWTEXT) || textrun.push(c);
      break;
    }
  }

  function plaintext_state(c) {
    switch(c) {
    case 0x0000: // NULL
      textrun.push(0xFFFD); // REPLACEMENT CHARACTER
      break;
    case -1: // EOF
      emitEOF();
      break;
    default:
      /*jshint -W030 */
      emitCharsWhile(PLAINTEXT) || textrun.push(c);
      break;
    }
  }

  function tag_open_state(c) {
    switch(c) {
    case 0x0021: // EXCLAMATION MARK
      tokenizer = markup_declaration_open_state;
      break;
    case 0x002F: // SOLIDUS
      tokenizer = end_tag_open_state;
      break;
    case 0x0041:  // [A-Z]
    case 0x0042:case 0x0043:case 0x0044:case 0x0045:case 0x0046:
    case 0x0047:case 0x0048:case 0x0049:case 0x004A:case 0x004B:
    case 0x004C:case 0x004D:case 0x004E:case 0x004F:case 0x0050:
    case 0x0051:case 0x0052:case 0x0053:case 0x0054:case 0x0055:
    case 0x0056:case 0x0057:case 0x0058:case 0x0059:case 0x005A:
    case 0x0061:  // [a-z]
    case 0x0062:case 0x0063:case 0x0064:case 0x0065:case 0x0066:
    case 0x0067:case 0x0068:case 0x0069:case 0x006A:case 0x006B:
    case 0x006C:case 0x006D:case 0x006E:case 0x006F:case 0x0070:
    case 0x0071:case 0x0072:case 0x0073:case 0x0074:case 0x0075:
    case 0x0076:case 0x0077:case 0x0078:case 0x0079:case 0x007A:
      beginTagName();
      reconsume(c, tag_name_state);
      break;
    case 0x003F: // QUESTION MARK
      reconsume(c, bogus_comment_state);
      break;
    default:
      textrun.push(0x003C); // LESS-THAN SIGN
      reconsume(c, data_state);
      break;
    }
  }

  function end_tag_open_state(c) {
    switch(c) {
    case 0x0041:  // [A-Z]
    case 0x0042:case 0x0043:case 0x0044:case 0x0045:case 0x0046:
    case 0x0047:case 0x0048:case 0x0049:case 0x004A:case 0x004B:
    case 0x004C:case 0x004D:case 0x004E:case 0x004F:case 0x0050:
    case 0x0051:case 0x0052:case 0x0053:case 0x0054:case 0x0055:
    case 0x0056:case 0x0057:case 0x0058:case 0x0059:case 0x005A:
    case 0x0061:  // [a-z]
    case 0x0062:case 0x0063:case 0x0064:case 0x0065:case 0x0066:
    case 0x0067:case 0x0068:case 0x0069:case 0x006A:case 0x006B:
    case 0x006C:case 0x006D:case 0x006E:case 0x006F:case 0x0070:
    case 0x0071:case 0x0072:case 0x0073:case 0x0074:case 0x0075:
    case 0x0076:case 0x0077:case 0x0078:case 0x0079:case 0x007A:
      beginEndTagName();
      reconsume(c, tag_name_state);
      break;
    case 0x003E: // GREATER-THAN SIGN
      tokenizer = data_state;
      break;
    case -1: // EOF
      textrun.push(0x003C); // LESS-THAN SIGN
      textrun.push(0x002F); // SOLIDUS
      emitEOF();
      break;
    default:
      reconsume(c, bogus_comment_state);
      break;
    }
  }

  function tag_name_state(c) {
    switch(c) {
    case 0x0009: // CHARACTER TABULATION (tab)
    case 0x000A: // LINE FEED (LF)
    case 0x000C: // FORM FEED (FF)
    case 0x0020: // SPACE
      tokenizer = before_attribute_name_state;
      break;
    case 0x002F: // SOLIDUS
      tokenizer = self_closing_start_tag_state;
      break;
    case 0x003E: // GREATER-THAN SIGN
      tokenizer = data_state;
      emitTag();
      break;
    case 0x0041:  // [A-Z]
    case 0x0042:case 0x0043:case 0x0044:case 0x0045:case 0x0046:
    case 0x0047:case 0x0048:case 0x0049:case 0x004A:case 0x004B:
    case 0x004C:case 0x004D:case 0x004E:case 0x004F:case 0x0050:
    case 0x0051:case 0x0052:case 0x0053:case 0x0054:case 0x0055:
    case 0x0056:case 0x0057:case 0x0058:case 0x0059:case 0x005A:
      tagnamebuf += String.fromCharCode(c + 0x0020);
      break;
    case 0x0000: // NULL
      tagnamebuf += String.fromCharCode(0xFFFD /* REPLACEMENT CHARACTER */);
      break;
    case -1: // EOF
      emitEOF();
      break;
    default:
      tagnamebuf += getMatchingChars(TAGNAME);
      break;
    }
  }

  function rcdata_less_than_sign_state(c) {
    /* identical to the RAWTEXT less-than sign state, except s/RAWTEXT/RCDATA/g */
    if (c === 0x002F) {  // SOLIDUS
      beginTempBuf();
      tokenizer = rcdata_end_tag_open_state;
    }
    else {
      textrun.push(0x003C); // LESS-THAN SIGN
      reconsume(c, rcdata_state);
    }
  }

  function rcdata_end_tag_open_state(c) {
    /* identical to the RAWTEXT (and Script data) end tag open state, except s/RAWTEXT/RCDATA/g */
    switch(c) {
    case 0x0041:  // [A-Z]
    case 0x0042:case 0x0043:case 0x0044:case 0x0045:case 0x0046:
    case 0x0047:case 0x0048:case 0x0049:case 0x004A:case 0x004B:
    case 0x004C:case 0x004D:case 0x004E:case 0x004F:case 0x0050:
    case 0x0051:case 0x0052:case 0x0053:case 0x0054:case 0x0055:
    case 0x0056:case 0x0057:case 0x0058:case 0x0059:case 0x005A:
    case 0x0061:  // [a-z]
    case 0x0062:case 0x0063:case 0x0064:case 0x0065:case 0x0066:
    case 0x0067:case 0x0068:case 0x0069:case 0x006A:case 0x006B:
    case 0x006C:case 0x006D:case 0x006E:case 0x006F:case 0x0070:
    case 0x0071:case 0x0072:case 0x0073:case 0x0074:case 0x0075:
    case 0x0076:case 0x0077:case 0x0078:case 0x0079:case 0x007A:
      beginEndTagName();
      reconsume(c, rcdata_end_tag_name_state);
      break;
    default:
      textrun.push(0x003C); // LESS-THAN SIGN
      textrun.push(0x002F); // SOLIDUS
      reconsume(c, rcdata_state);
      break;
    }
  }

  function rcdata_end_tag_name_state(c) {
    /* identical to the RAWTEXT (and Script data) end tag name state, except s/RAWTEXT/RCDATA/g */
    switch(c) {
    case 0x0009: // CHARACTER TABULATION (tab)
    case 0x000A: // LINE FEED (LF)
    case 0x000C: // FORM FEED (FF)
    case 0x0020: // SPACE
      if (appropriateEndTag(tagnamebuf)) {
        tokenizer = before_attribute_name_state;
        return;
      }
      break;
    case 0x002F: // SOLIDUS
      if (appropriateEndTag(tagnamebuf)) {
        tokenizer = self_closing_start_tag_state;
        return;
      }
      break;
    case 0x003E: // GREATER-THAN SIGN
      if (appropriateEndTag(tagnamebuf)) {
        tokenizer = data_state;
        emitTag();
        return;
      }
      break;
    case 0x0041:  // [A-Z]
    case 0x0042:case 0x0043:case 0x0044:case 0x0045:case 0x0046:
    case 0x0047:case 0x0048:case 0x0049:case 0x004A:case 0x004B:
    case 0x004C:case 0x004D:case 0x004E:case 0x004F:case 0x0050:
    case 0x0051:case 0x0052:case 0x0053:case 0x0054:case 0x0055:
    case 0x0056:case 0x0057:case 0x0058:case 0x0059:case 0x005A:

      tagnamebuf += String.fromCharCode(c + 0x0020);
      tempbuf.push(c);
      return;
    case 0x0061:  // [a-z]
    case 0x0062:case 0x0063:case 0x0064:case 0x0065:case 0x0066:
    case 0x0067:case 0x0068:case 0x0069:case 0x006A:case 0x006B:
    case 0x006C:case 0x006D:case 0x006E:case 0x006F:case 0x0070:
    case 0x0071:case 0x0072:case 0x0073:case 0x0074:case 0x0075:
    case 0x0076:case 0x0077:case 0x0078:case 0x0079:case 0x007A:

      tagnamebuf += String.fromCharCode(c);
      tempbuf.push(c);
      return;
    default:
      break;
    }

    // If we don't return in one of the cases above, then this was not
    // an appropriately matching close tag, so back out by emitting all
    // the characters as text
    textrun.push(0x003C); // LESS-THAN SIGN
    textrun.push(0x002F); // SOLIDUS
    pushAll(textrun, tempbuf);
    reconsume(c, rcdata_state);
  }

  function rawtext_less_than_sign_state(c) {
    /* identical to the RCDATA less-than sign state, except s/RCDATA/RAWTEXT/g
     */
    if (c === 0x002F) { // SOLIDUS
      beginTempBuf();
      tokenizer = rawtext_end_tag_open_state;
    }
    else {
      textrun.push(0x003C); // LESS-THAN SIGN
      reconsume(c, rawtext_state);
    }
  }

  function rawtext_end_tag_open_state(c) {
    /* identical to the RCDATA (and Script data) end tag open state, except s/RCDATA/RAWTEXT/g */
    switch(c) {
    case 0x0041:  // [A-Z]
    case 0x0042:case 0x0043:case 0x0044:case 0x0045:case 0x0046:
    case 0x0047:case 0x0048:case 0x0049:case 0x004A:case 0x004B:
    case 0x004C:case 0x004D:case 0x004E:case 0x004F:case 0x0050:
    case 0x0051:case 0x0052:case 0x0053:case 0x0054:case 0x0055:
    case 0x0056:case 0x0057:case 0x0058:case 0x0059:case 0x005A:
    case 0x0061:  // [a-z]
    case 0x0062:case 0x0063:case 0x0064:case 0x0065:case 0x0066:
    case 0x0067:case 0x0068:case 0x0069:case 0x006A:case 0x006B:
    case 0x006C:case 0x006D:case 0x006E:case 0x006F:case 0x0070:
    case 0x0071:case 0x0072:case 0x0073:case 0x0074:case 0x0075:
    case 0x0076:case 0x0077:case 0x0078:case 0x0079:case 0x007A:
      beginEndTagName();
      reconsume(c, rawtext_end_tag_name_state);
      break;
    default:
      textrun.push(0x003C); // LESS-THAN SIGN
      textrun.push(0x002F); // SOLIDUS
      reconsume(c, rawtext_state);
      break;
    }
  }

  function rawtext_end_tag_name_state(c) {
    /* identical to the RCDATA (and Script data) end tag name state, except s/RCDATA/RAWTEXT/g */
    switch(c) {
    case 0x0009: // CHARACTER TABULATION (tab)
    case 0x000A: // LINE FEED (LF)
    case 0x000C: // FORM FEED (FF)
    case 0x0020: // SPACE
      if (appropriateEndTag(tagnamebuf)) {
        tokenizer = before_attribute_name_state;
        return;
      }
      break;
    case 0x002F: // SOLIDUS
      if (appropriateEndTag(tagnamebuf)) {
        tokenizer = self_closing_start_tag_state;
        return;
      }
      break;
    case 0x003E: // GREATER-THAN SIGN
      if (appropriateEndTag(tagnamebuf)) {
        tokenizer = data_state;
        emitTag();
        return;
      }
      break;
    case 0x0041:  // [A-Z]
    case 0x0042:case 0x0043:case 0x0044:case 0x0045:case 0x0046:
    case 0x0047:case 0x0048:case 0x0049:case 0x004A:case 0x004B:
    case 0x004C:case 0x004D:case 0x004E:case 0x004F:case 0x0050:
    case 0x0051:case 0x0052:case 0x0053:case 0x0054:case 0x0055:
    case 0x0056:case 0x0057:case 0x0058:case 0x0059:case 0x005A:
      tagnamebuf += String.fromCharCode(c + 0x0020);
      tempbuf.push(c);
      return;
    case 0x0061:  // [a-z]
    case 0x0062:case 0x0063:case 0x0064:case 0x0065:case 0x0066:
    case 0x0067:case 0x0068:case 0x0069:case 0x006A:case 0x006B:
    case 0x006C:case 0x006D:case 0x006E:case 0x006F:case 0x0070:
    case 0x0071:case 0x0072:case 0x0073:case 0x0074:case 0x0075:
    case 0x0076:case 0x0077:case 0x0078:case 0x0079:case 0x007A:
      tagnamebuf += String.fromCharCode(c);
      tempbuf.push(c);
      return;
    default:
      break;
    }

    // If we don't return in one of the cases above, then this was not
    // an appropriately matching close tag, so back out by emitting all
    // the characters as text
    textrun.push(0x003C); // LESS-THAN SIGN
    textrun.push(0x002F); // SOLIDUS
    pushAll(textrun,tempbuf);
    reconsume(c, rawtext_state);
  }

  function script_data_less_than_sign_state(c) {
    switch(c) {
    case 0x002F: // SOLIDUS
      beginTempBuf();
      tokenizer = script_data_end_tag_open_state;
      break;
    case 0x0021: // EXCLAMATION MARK
      tokenizer = script_data_escape_start_state;
      textrun.push(0x003C); // LESS-THAN SIGN
      textrun.push(0x0021); // EXCLAMATION MARK
      break;
    default:
      textrun.push(0x003C); // LESS-THAN SIGN
      reconsume(c, script_data_state);
      break;
    }
  }

  function script_data_end_tag_open_state(c) {
    /* identical to the RCDATA (and RAWTEXT) end tag open state, except s/RCDATA/Script data/g */
    switch(c) {
    case 0x0041:  // [A-Z]
    case 0x0042:case 0x0043:case 0x0044:case 0x0045:case 0x0046:
    case 0x0047:case 0x0048:case 0x0049:case 0x004A:case 0x004B:
    case 0x004C:case 0x004D:case 0x004E:case 0x004F:case 0x0050:
    case 0x0051:case 0x0052:case 0x0053:case 0x0054:case 0x0055:
    case 0x0056:case 0x0057:case 0x0058:case 0x0059:case 0x005A:
    case 0x0061:  // [a-z]
    case 0x0062:case 0x0063:case 0x0064:case 0x0065:case 0x0066:
    case 0x0067:case 0x0068:case 0x0069:case 0x006A:case 0x006B:
    case 0x006C:case 0x006D:case 0x006E:case 0x006F:case 0x0070:
    case 0x0071:case 0x0072:case 0x0073:case 0x0074:case 0x0075:
    case 0x0076:case 0x0077:case 0x0078:case 0x0079:case 0x007A:
      beginEndTagName();
      reconsume(c, script_data_end_tag_name_state);
      break;
    default:
      textrun.push(0x003C); // LESS-THAN SIGN
      textrun.push(0x002F); // SOLIDUS
      reconsume(c, script_data_state);
      break;
    }
  }

  function script_data_end_tag_name_state(c) {
    /* identical to the RCDATA (and RAWTEXT) end tag name state, except s/RCDATA/Script data/g */
    switch(c) {
    case 0x0009: // CHARACTER TABULATION (tab)
    case 0x000A: // LINE FEED (LF)
    case 0x000C: // FORM FEED (FF)
    case 0x0020: // SPACE
      if (appropriateEndTag(tagnamebuf)) {
        tokenizer = before_attribute_name_state;
        return;
      }
      break;
    case 0x002F: // SOLIDUS
      if (appropriateEndTag(tagnamebuf)) {
        tokenizer = self_closing_start_tag_state;
        return;
      }
      break;
    case 0x003E: // GREATER-THAN SIGN
      if (appropriateEndTag(tagnamebuf)) {
        tokenizer = data_state;
        emitTag();
        return;
      }
      break;
    case 0x0041:  // [A-Z]
    case 0x0042:case 0x0043:case 0x0044:case 0x0045:case 0x0046:
    case 0x0047:case 0x0048:case 0x0049:case 0x004A:case 0x004B:
    case 0x004C:case 0x004D:case 0x004E:case 0x004F:case 0x0050:
    case 0x0051:case 0x0052:case 0x0053:case 0x0054:case 0x0055:
    case 0x0056:case 0x0057:case 0x0058:case 0x0059:case 0x005A:

      tagnamebuf += String.fromCharCode(c + 0x0020);
      tempbuf.push(c);
      return;
    case 0x0061:  // [a-z]
    case 0x0062:case 0x0063:case 0x0064:case 0x0065:case 0x0066:
    case 0x0067:case 0x0068:case 0x0069:case 0x006A:case 0x006B:
    case 0x006C:case 0x006D:case 0x006E:case 0x006F:case 0x0070:
    case 0x0071:case 0x0072:case 0x0073:case 0x0074:case 0x0075:
    case 0x0076:case 0x0077:case 0x0078:case 0x0079:case 0x007A:

      tagnamebuf += String.fromCharCode(c);
      tempbuf.push(c);
      return;
    default:
      break;
    }

    // If we don't return in one of the cases above, then this was not
    // an appropriately matching close tag, so back out by emitting all
    // the characters as text
    textrun.push(0x003C); // LESS-THAN SIGN
    textrun.push(0x002F); // SOLIDUS
    pushAll(textrun,tempbuf);
    reconsume(c, script_data_state);
  }

  function script_data_escape_start_state(c) {
    if (c === 0x002D) { // HYPHEN-MINUS
      tokenizer = script_data_escape_start_dash_state;
      textrun.push(0x002D); // HYPHEN-MINUS
    }
    else {
      reconsume(c, script_data_state);
    }
  }

  function script_data_escape_start_dash_state(c) {
    if (c === 0x002D) { // HYPHEN-MINUS
      tokenizer = script_data_escaped_dash_dash_state;
      textrun.push(0x002D); // HYPHEN-MINUS
    }
    else {
      reconsume(c, script_data_state);
    }
  }

  function script_data_escaped_state(c) {
    switch(c) {
    case 0x002D: // HYPHEN-MINUS
      tokenizer = script_data_escaped_dash_state;
      textrun.push(0x002D); // HYPHEN-MINUS
      break;
    case 0x003C: // LESS-THAN SIGN
      tokenizer = script_data_escaped_less_than_sign_state;
      break;
    case 0x0000: // NULL
      textrun.push(0xFFFD); // REPLACEMENT CHARACTER
      break;
    case -1: // EOF
      emitEOF();
      break;
    default:
      textrun.push(c);
      break;
    }
  }

  function script_data_escaped_dash_state(c) {
    switch(c) {
    case 0x002D: // HYPHEN-MINUS
      tokenizer = script_data_escaped_dash_dash_state;
      textrun.push(0x002D); // HYPHEN-MINUS
      break;
    case 0x003C: // LESS-THAN SIGN
      tokenizer = script_data_escaped_less_than_sign_state;
      break;
    case 0x0000: // NULL
      tokenizer = script_data_escaped_state;
      textrun.push(0xFFFD); // REPLACEMENT CHARACTER
      break;
    case -1: // EOF
      emitEOF();
      break;
    default:
      tokenizer = script_data_escaped_state;
      textrun.push(c);
      break;
    }
  }

  function script_data_escaped_dash_dash_state(c) {
    switch(c) {
    case 0x002D: // HYPHEN-MINUS
      textrun.push(0x002D); // HYPHEN-MINUS
      break;
    case 0x003C: // LESS-THAN SIGN
      tokenizer = script_data_escaped_less_than_sign_state;
      break;
    case 0x003E: // GREATER-THAN SIGN
      tokenizer = script_data_state;
      textrun.push(0x003E); // GREATER-THAN SIGN
      break;
    case 0x0000: // NULL
      tokenizer = script_data_escaped_state;
      textrun.push(0xFFFD); // REPLACEMENT CHARACTER
      break;
    case -1: // EOF
      emitEOF();
      break;
    default:
      tokenizer = script_data_escaped_state;
      textrun.push(c);
      break;
    }
  }

  function script_data_escaped_less_than_sign_state(c) {
    switch(c) {
    case 0x002F: // SOLIDUS
      beginTempBuf();
      tokenizer = script_data_escaped_end_tag_open_state;
      break;
    case 0x0041:  // [A-Z]
    case 0x0042:case 0x0043:case 0x0044:case 0x0045:case 0x0046:
    case 0x0047:case 0x0048:case 0x0049:case 0x004A:case 0x004B:
    case 0x004C:case 0x004D:case 0x004E:case 0x004F:case 0x0050:
    case 0x0051:case 0x0052:case 0x0053:case 0x0054:case 0x0055:
    case 0x0056:case 0x0057:case 0x0058:case 0x0059:case 0x005A:
    case 0x0061:  // [a-z]
    case 0x0062:case 0x0063:case 0x0064:case 0x0065:case 0x0066:
    case 0x0067:case 0x0068:case 0x0069:case 0x006A:case 0x006B:
    case 0x006C:case 0x006D:case 0x006E:case 0x006F:case 0x0070:
    case 0x0071:case 0x0072:case 0x0073:case 0x0074:case 0x0075:
    case 0x0076:case 0x0077:case 0x0078:case 0x0079:case 0x007A:
      beginTempBuf();
      textrun.push(0x003C); // LESS-THAN SIGN
      reconsume(c, script_data_double_escape_start_state);
      break;
    default:
      textrun.push(0x003C); // LESS-THAN SIGN
      reconsume(c, script_data_escaped_state);
      break;
    }
  }

  function script_data_escaped_end_tag_open_state(c) {
    switch(c) {
    case 0x0041:  // [A-Z]
    case 0x0042:case 0x0043:case 0x0044:case 0x0045:case 0x0046:
    case 0x0047:case 0x0048:case 0x0049:case 0x004A:case 0x004B:
    case 0x004C:case 0x004D:case 0x004E:case 0x004F:case 0x0050:
    case 0x0051:case 0x0052:case 0x0053:case 0x0054:case 0x0055:
    case 0x0056:case 0x0057:case 0x0058:case 0x0059:case 0x005A:
    case 0x0061:  // [a-z]
    case 0x0062:case 0x0063:case 0x0064:case 0x0065:case 0x0066:
    case 0x0067:case 0x0068:case 0x0069:case 0x006A:case 0x006B:
    case 0x006C:case 0x006D:case 0x006E:case 0x006F:case 0x0070:
    case 0x0071:case 0x0072:case 0x0073:case 0x0074:case 0x0075:
    case 0x0076:case 0x0077:case 0x0078:case 0x0079:case 0x007A:
      beginEndTagName();
      reconsume(c, script_data_escaped_end_tag_name_state);
      break;
    default:
      textrun.push(0x003C); // LESS-THAN SIGN
      textrun.push(0x002F); // SOLIDUS
      reconsume(c, script_data_escaped_state);
      break;
    }
  }

  function script_data_escaped_end_tag_name_state(c) {
    switch(c) {
    case 0x0009: // CHARACTER TABULATION (tab)
    case 0x000A: // LINE FEED (LF)
    case 0x000C: // FORM FEED (FF)
    case 0x0020: // SPACE
      if (appropriateEndTag(tagnamebuf)) {
        tokenizer = before_attribute_name_state;
        return;
      }
      break;
    case 0x002F: // SOLIDUS
      if (appropriateEndTag(tagnamebuf)) {
        tokenizer = self_closing_start_tag_state;
        return;
      }
      break;
    case 0x003E: // GREATER-THAN SIGN
      if (appropriateEndTag(tagnamebuf)) {
        tokenizer = data_state;
        emitTag();
        return;
      }
      break;
    case 0x0041:  // [A-Z]
    case 0x0042:case 0x0043:case 0x0044:case 0x0045:case 0x0046:
    case 0x0047:case 0x0048:case 0x0049:case 0x004A:case 0x004B:
    case 0x004C:case 0x004D:case 0x004E:case 0x004F:case 0x0050:
    case 0x0051:case 0x0052:case 0x0053:case 0x0054:case 0x0055:
    case 0x0056:case 0x0057:case 0x0058:case 0x0059:case 0x005A:
      tagnamebuf += String.fromCharCode(c + 0x0020);
      tempbuf.push(c);
      return;
    case 0x0061:  // [a-z]
    case 0x0062:case 0x0063:case 0x0064:case 0x0065:case 0x0066:
    case 0x0067:case 0x0068:case 0x0069:case 0x006A:case 0x006B:
    case 0x006C:case 0x006D:case 0x006E:case 0x006F:case 0x0070:
    case 0x0071:case 0x0072:case 0x0073:case 0x0074:case 0x0075:
    case 0x0076:case 0x0077:case 0x0078:case 0x0079:case 0x007A:
      tagnamebuf += String.fromCharCode(c);
      tempbuf.push(c);
      return;
    default:
      break;
    }

    // We get here in the default case, and if the closing tagname
    // is not an appropriate tagname.
    textrun.push(0x003C); // LESS-THAN SIGN
    textrun.push(0x002F); // SOLIDUS
    pushAll(textrun,tempbuf);
    reconsume(c, script_data_escaped_state);
  }

  function script_data_double_escape_start_state(c) {
    switch(c) {
    case 0x0009: // CHARACTER TABULATION (tab)
    case 0x000A: // LINE FEED (LF)
    case 0x000C: // FORM FEED (FF)
    case 0x0020: // SPACE
    case 0x002F: // SOLIDUS
    case 0x003E: // GREATER-THAN SIGN
      if (buf2str(tempbuf) === "script") {
        tokenizer = script_data_double_escaped_state;
      }
      else {
        tokenizer = script_data_escaped_state;
      }
      textrun.push(c);
      break;
    case 0x0041:  // [A-Z]
    case 0x0042:case 0x0043:case 0x0044:case 0x0045:case 0x0046:
    case 0x0047:case 0x0048:case 0x0049:case 0x004A:case 0x004B:
    case 0x004C:case 0x004D:case 0x004E:case 0x004F:case 0x0050:
    case 0x0051:case 0x0052:case 0x0053:case 0x0054:case 0x0055:
    case 0x0056:case 0x0057:case 0x0058:case 0x0059:case 0x005A:
      tempbuf.push(c + 0x0020);
      textrun.push(c);
      break;
    case 0x0061:  // [a-z]
    case 0x0062:case 0x0063:case 0x0064:case 0x0065:case 0x0066:
    case 0x0067:case 0x0068:case 0x0069:case 0x006A:case 0x006B:
    case 0x006C:case 0x006D:case 0x006E:case 0x006F:case 0x0070:
    case 0x0071:case 0x0072:case 0x0073:case 0x0074:case 0x0075:
    case 0x0076:case 0x0077:case 0x0078:case 0x0079:case 0x007A:
      tempbuf.push(c);
      textrun.push(c);
      break;
    default:
      reconsume(c, script_data_escaped_state);
      break;
    }
  }

  function script_data_double_escaped_state(c) {
    switch(c) {
    case 0x002D: // HYPHEN-MINUS
      tokenizer = script_data_double_escaped_dash_state;
      textrun.push(0x002D); // HYPHEN-MINUS
      break;
    case 0x003C: // LESS-THAN SIGN
      tokenizer = script_data_double_escaped_less_than_sign_state;
      textrun.push(0x003C); // LESS-THAN SIGN
      break;
    case 0x0000: // NULL
      textrun.push(0xFFFD); // REPLACEMENT CHARACTER
      break;
    case -1: // EOF
      emitEOF();
      break;
    default:
      textrun.push(c);
      break;
    }
  }

  function script_data_double_escaped_dash_state(c) {
    switch(c) {
    case 0x002D: // HYPHEN-MINUS
      tokenizer = script_data_double_escaped_dash_dash_state;
      textrun.push(0x002D); // HYPHEN-MINUS
      break;
    case 0x003C: // LESS-THAN SIGN
      tokenizer = script_data_double_escaped_less_than_sign_state;
      textrun.push(0x003C); // LESS-THAN SIGN
      break;
    case 0x0000: // NULL
      tokenizer = script_data_double_escaped_state;
      textrun.push(0xFFFD); // REPLACEMENT CHARACTER
      break;
    case -1: // EOF
      emitEOF();
      break;
    default:
      tokenizer = script_data_double_escaped_state;
      textrun.push(c);
      break;
    }
  }

  function script_data_double_escaped_dash_dash_state(c) {
    switch(c) {
    case 0x002D: // HYPHEN-MINUS
      textrun.push(0x002D); // HYPHEN-MINUS
      break;
    case 0x003C: // LESS-THAN SIGN
      tokenizer = script_data_double_escaped_less_than_sign_state;
      textrun.push(0x003C); // LESS-THAN SIGN
      break;
    case 0x003E: // GREATER-THAN SIGN
      tokenizer = script_data_state;
      textrun.push(0x003E); // GREATER-THAN SIGN
      break;
    case 0x0000: // NULL
      tokenizer = script_data_double_escaped_state;
      textrun.push(0xFFFD); // REPLACEMENT CHARACTER
      break;
    case -1: // EOF
      emitEOF();
      break;
    default:
      tokenizer = script_data_double_escaped_state;
      textrun.push(c);
      break;
    }
  }

  function script_data_double_escaped_less_than_sign_state(c) {
    if (c === 0x002F) { // SOLIDUS
      beginTempBuf();
      tokenizer = script_data_double_escape_end_state;
      textrun.push(0x002F); // SOLIDUS
    }
    else {
      reconsume(c, script_data_double_escaped_state);
    }
  }

  function script_data_double_escape_end_state(c) {
    switch(c) {
    case 0x0009: // CHARACTER TABULATION (tab)
    case 0x000A: // LINE FEED (LF)
    case 0x000C: // FORM FEED (FF)
    case 0x0020: // SPACE
    case 0x002F: // SOLIDUS
    case 0x003E: // GREATER-THAN SIGN
      if (buf2str(tempbuf) === "script") {
        tokenizer = script_data_escaped_state;
      }
      else {
        tokenizer = script_data_double_escaped_state;
      }
      textrun.push(c);
      break;
    case 0x0041:  // [A-Z]
    case 0x0042:case 0x0043:case 0x0044:case 0x0045:case 0x0046:
    case 0x0047:case 0x0048:case 0x0049:case 0x004A:case 0x004B:
    case 0x004C:case 0x004D:case 0x004E:case 0x004F:case 0x0050:
    case 0x0051:case 0x0052:case 0x0053:case 0x0054:case 0x0055:
    case 0x0056:case 0x0057:case 0x0058:case 0x0059:case 0x005A:
      tempbuf.push(c + 0x0020);
      textrun.push(c);
      break;
    case 0x0061:  // [a-z]
    case 0x0062:case 0x0063:case 0x0064:case 0x0065:case 0x0066:
    case 0x0067:case 0x0068:case 0x0069:case 0x006A:case 0x006B:
    case 0x006C:case 0x006D:case 0x006E:case 0x006F:case 0x0070:
    case 0x0071:case 0x0072:case 0x0073:case 0x0074:case 0x0075:
    case 0x0076:case 0x0077:case 0x0078:case 0x0079:case 0x007A:
      tempbuf.push(c);
      textrun.push(c);
      break;
    default:
      reconsume(c, script_data_double_escaped_state);
      break;
    }
  }

  function before_attribute_name_state(c) {
    switch(c) {
    case 0x0009: // CHARACTER TABULATION (tab)
    case 0x000A: // LINE FEED (LF)
    case 0x000C: // FORM FEED (FF)
    case 0x0020: // SPACE
      /* Ignore the character. */
      break;
    // For SOLIDUS, GREATER-THAN SIGN, and EOF, spec says "reconsume in
    // the after attribute name state", but in our implementation that
    // state always has an active attribute in attrnamebuf.  Just clone
    // the rules here, without the addAttribute business.
    case 0x002F: // SOLIDUS
      tokenizer = self_closing_start_tag_state;
      break;
    case 0x003E: // GREATER-THAN SIGN
      tokenizer = data_state;
      emitTag();
      break;
    case -1: // EOF
      emitEOF();
      break;
    case 0x003D: // EQUALS SIGN
      beginAttrName();
      attrnamebuf += String.fromCharCode(c);
      tokenizer = attribute_name_state;
      break;
    default:
      if (handleSimpleAttribute()) break;
      beginAttrName();
      reconsume(c, attribute_name_state);
      break;
    }
  }

  // beginAttrName() must have been called before this point
  // There is an active attribute in attrnamebuf (but not attrvaluebuf)
  function attribute_name_state(c) {
    switch(c) {
    case 0x0009: // CHARACTER TABULATION (tab)
    case 0x000A: // LINE FEED (LF)
    case 0x000C: // FORM FEED (FF)
    case 0x0020: // SPACE
    case 0x002F: // SOLIDUS
    case 0x003E: // GREATER-THAN SIGN
    case -1: // EOF
      reconsume(c, after_attribute_name_state);
      break;
    case 0x003D: // EQUALS SIGN
      tokenizer = before_attribute_value_state;
      break;
    case 0x0041:  // [A-Z]
    case 0x0042:case 0x0043:case 0x0044:case 0x0045:case 0x0046:
    case 0x0047:case 0x0048:case 0x0049:case 0x004A:case 0x004B:
    case 0x004C:case 0x004D:case 0x004E:case 0x004F:case 0x0050:
    case 0x0051:case 0x0052:case 0x0053:case 0x0054:case 0x0055:
    case 0x0056:case 0x0057:case 0x0058:case 0x0059:case 0x005A:
      attrnamebuf += String.fromCharCode(c + 0x0020);
      break;
    case 0x0000: // NULL
      attrnamebuf += String.fromCharCode(0xFFFD /* REPLACEMENT CHARACTER */);
      break;
    case 0x0022: // QUOTATION MARK
    case 0x0027: // APOSTROPHE
    case 0x003C: // LESS-THAN SIGN
      /* falls through */
    default:
      attrnamebuf += getMatchingChars(ATTRNAME);
      break;
    }
  }

  // There is an active attribute in attrnamebuf, but not yet in attrvaluebuf.
  function after_attribute_name_state(c) {
    switch(c) {
    case 0x0009: // CHARACTER TABULATION (tab)
    case 0x000A: // LINE FEED (LF)
    case 0x000C: // FORM FEED (FF)
    case 0x0020: // SPACE
      /* Ignore the character. */
      break;
    case 0x002F: // SOLIDUS
      // Keep in sync with before_attribute_name_state.
      addAttribute(attrnamebuf);
      tokenizer = self_closing_start_tag_state;
      break;
    case 0x003D: // EQUALS SIGN
      tokenizer = before_attribute_value_state;
      break;
    case 0x003E: // GREATER-THAN SIGN
      // Keep in sync with before_attribute_name_state.
      tokenizer = data_state;
      addAttribute(attrnamebuf);
      emitTag();
      break;
    case -1: // EOF
      // Keep in sync with before_attribute_name_state.
      addAttribute(attrnamebuf);
      emitEOF();
      break;
    default:
      addAttribute(attrnamebuf);
      beginAttrName();
      reconsume(c, attribute_name_state);
      break;
    }
  }

  function before_attribute_value_state(c) {
    switch(c) {
    case 0x0009: // CHARACTER TABULATION (tab)
    case 0x000A: // LINE FEED (LF)
    case 0x000C: // FORM FEED (FF)
    case 0x0020: // SPACE
      /* Ignore the character. */
      break;
    case 0x0022: // QUOTATION MARK
      beginAttrValue();
      tokenizer = attribute_value_double_quoted_state;
      break;
    case 0x0027: // APOSTROPHE
      beginAttrValue();
      tokenizer = attribute_value_single_quoted_state;
      break;
    case 0x003E: // GREATER-THAN SIGN
      /* falls through */
    default:
      beginAttrValue();
      reconsume(c, attribute_value_unquoted_state);
      break;
    }
  }

  function attribute_value_double_quoted_state(c) {
    switch(c) {
    case 0x0022: // QUOTATION MARK
      addAttribute(attrnamebuf, attrvaluebuf);
      tokenizer = after_attribute_value_quoted_state;
      break;
    case 0x0026: // AMPERSAND
      return_state = attribute_value_double_quoted_state;
      tokenizer = character_reference_state;
      break;
    case 0x0000: // NULL
      attrvaluebuf += String.fromCharCode(0xFFFD /* REPLACEMENT CHARACTER */);
      break;
    case -1: // EOF
      emitEOF();
      break;
    case 0x000A: // LF
      // this could be a converted \r, so don't use getMatchingChars
      attrvaluebuf += String.fromCharCode(c);
      break;
    default:
      attrvaluebuf += getMatchingChars(DBLQUOTEATTRVAL);
      break;
    }
  }

  function attribute_value_single_quoted_state(c) {
    switch(c) {
    case 0x0027: // APOSTROPHE
      addAttribute(attrnamebuf, attrvaluebuf);
      tokenizer = after_attribute_value_quoted_state;
      break;
    case 0x0026: // AMPERSAND
      return_state = attribute_value_single_quoted_state;
      tokenizer = character_reference_state;
      break;
    case 0x0000: // NULL
      attrvaluebuf += String.fromCharCode(0xFFFD /* REPLACEMENT CHARACTER */);
      break;
    case -1: // EOF
      emitEOF();
      break;
    case 0x000A: // LF
      // this could be a converted \r, so don't use getMatchingChars
      attrvaluebuf += String.fromCharCode(c);
      break;
    default:
      attrvaluebuf += getMatchingChars(SINGLEQUOTEATTRVAL);
      break;
    }
  }

  function attribute_value_unquoted_state(c) {
    switch(c) {
    case 0x0009: // CHARACTER TABULATION (tab)
    case 0x000A: // LINE FEED (LF)
    case 0x000C: // FORM FEED (FF)
    case 0x0020: // SPACE
      addAttribute(attrnamebuf, attrvaluebuf);
      tokenizer = before_attribute_name_state;
      break;
    case 0x0026: // AMPERSAND
      return_state = attribute_value_unquoted_state;
      tokenizer = character_reference_state;
      break;
    case 0x003E: // GREATER-THAN SIGN
      addAttribute(attrnamebuf, attrvaluebuf);
      tokenizer = data_state;
      emitTag();
      break;
    case 0x0000: // NULL
      attrvaluebuf += String.fromCharCode(0xFFFD /* REPLACEMENT CHARACTER */);
      break;
    case -1: // EOF
      nextchar--; // pushback
      tokenizer = data_state;
      break;
    case 0x0022: // QUOTATION MARK
    case 0x0027: // APOSTROPHE
    case 0x003C: // LESS-THAN SIGN
    case 0x003D: // EQUALS SIGN
    case 0x0060: // GRAVE ACCENT
      /* falls through */
    default:
      attrvaluebuf += getMatchingChars(UNQUOTEDATTRVAL);
      break;
    }
  }

  function after_attribute_value_quoted_state(c) {
    switch(c) {
    case 0x0009: // CHARACTER TABULATION (tab)
    case 0x000A: // LINE FEED (LF)
    case 0x000C: // FORM FEED (FF)
    case 0x0020: // SPACE
      tokenizer = before_attribute_name_state;
      break;
    case 0x002F: // SOLIDUS
      tokenizer = self_closing_start_tag_state;
      break;
    case 0x003E: // GREATER-THAN SIGN
      tokenizer = data_state;
      emitTag();
      break;
    case -1: // EOF
      emitEOF();
      break;
    default:
      reconsume(c, before_attribute_name_state);
      break;
    }
  }

  function self_closing_start_tag_state(c) {
    switch(c) {
    case 0x003E: // GREATER-THAN SIGN
      // Set the <i>self-closing flag</i> of the current tag token.
      tokenizer = data_state;
      emitSelfClosingTag(true);
      break;
    case -1: // EOF
      emitEOF();
      break;
    default:
      reconsume(c, before_attribute_name_state);
      break;
    }
  }

  function bogus_comment_state(c, lookahead, eof) {
    var len = lookahead.length;

    if (eof) {
      nextchar += len-1; // don't consume the eof
    }
    else {
      nextchar += len;
    }

    var comment = lookahead.substring(0, len-1);

    comment = comment.replace(/\u0000/g,"\uFFFD");
    comment = comment.replace(/\u000D\u000A/g,"\u000A");
    comment = comment.replace(/\u000D/g,"\u000A");

    insertToken(COMMENT, comment);
    tokenizer = data_state;
  }
  bogus_comment_state.lookahead = ">";

  function markup_declaration_open_state(c, lookahead, eof) {
    if (lookahead[0] === "-" && lookahead[1] === "-") {
      nextchar += 2;
      beginComment();
      tokenizer = comment_start_state;
      return;
    }

    if (lookahead.toUpperCase() === "DOCTYPE") {
      nextchar += 7;
      tokenizer = doctype_state;
    }
    else if (lookahead === "[CDATA[" && cdataAllowed()) {
      nextchar += 7;
      tokenizer = cdata_section_state;
    }
    else {
      tokenizer = bogus_comment_state;
    }
  }
  markup_declaration_open_state.lookahead = 7;

  function comment_start_state(c) {
    beginComment();
    switch(c) {
    case 0x002D: // HYPHEN-MINUS
      tokenizer = comment_start_dash_state;
      break;
    case 0x003E: // GREATER-THAN SIGN
      tokenizer = data_state;
      insertToken(COMMENT, buf2str(commentbuf));
      break; /* see comment in comment end state */
    default:
      reconsume(c, comment_state);
      break;
    }
  }

  function comment_start_dash_state(c) {
    switch(c) {
    case 0x002D: // HYPHEN-MINUS
      tokenizer = comment_end_state;
      break;
    case 0x003E: // GREATER-THAN SIGN
      tokenizer = data_state;
      insertToken(COMMENT, buf2str(commentbuf));
      break;
    case -1: // EOF
      insertToken(COMMENT, buf2str(commentbuf));
      emitEOF();
      break; /* see comment in comment end state */
    default:
      commentbuf.push(0x002D /* HYPHEN-MINUS */);
      reconsume(c, comment_state);
      break;
    }
  }

  function comment_state(c) {
    switch(c) {
    case 0x003C: // LESS-THAN SIGN
      commentbuf.push(c);
      tokenizer = comment_less_than_sign_state;
      break;
    case 0x002D: // HYPHEN-MINUS
      tokenizer = comment_end_dash_state;
      break;
    case 0x0000: // NULL
      commentbuf.push(0xFFFD /* REPLACEMENT CHARACTER */);
      break;
    case -1: // EOF
      insertToken(COMMENT, buf2str(commentbuf));
      emitEOF();
      break; /* see comment in comment end state */
    default:
      commentbuf.push(c);
      break;
    }
  }

  function comment_less_than_sign_state(c) {
    switch(c) {
    case 0x0021: // EXCLAMATION MARK
      commentbuf.push(c);
      tokenizer = comment_less_than_sign_bang_state;
      break;
    case 0x003C: // LESS-THAN SIGN
      commentbuf.push(c);
      break;
    default:
      reconsume(c, comment_state);
      break;
    }
  }

  function comment_less_than_sign_bang_state(c) {
    switch(c) {
    case 0x002D: // HYPHEN-MINUS
      tokenizer = comment_less_than_sign_bang_dash_state;
      break;
    default:
      reconsume(c, comment_state);
      break;
    }
  }

  function comment_less_than_sign_bang_dash_state(c) {
    switch(c) {
    case 0x002D: // HYPHEN-MINUS
      tokenizer = comment_less_than_sign_bang_dash_dash_state;
      break;
    default:
      reconsume(c, comment_end_dash_state);
      break;
    }
  }

  function comment_less_than_sign_bang_dash_dash_state(c) {
    switch(c) {
    case 0x003E: // GREATER-THAN SIGN
    case -1: // EOF
      reconsume(c, comment_end_state);
      break;
    default:
      // parse error
      reconsume(c, comment_end_state);
      break;
    }
  }

  function comment_end_dash_state(c) {
    switch(c) {
    case 0x002D: // HYPHEN-MINUS
      tokenizer = comment_end_state;
      break;
    case -1: // EOF
      insertToken(COMMENT, buf2str(commentbuf));
      emitEOF();
      break; /* see comment in comment end state */
    default:
      commentbuf.push(0x002D /* HYPHEN-MINUS */);
      reconsume(c, comment_state);
      break;
    }
  }

  function comment_end_state(c) {
    switch(c) {
    case 0x003E: // GREATER-THAN SIGN
      tokenizer = data_state;
      insertToken(COMMENT, buf2str(commentbuf));
      break;
    case 0x0021: // EXCLAMATION MARK
      tokenizer = comment_end_bang_state;
      break;
    case 0x002D: // HYPHEN-MINUS
      commentbuf.push(0x002D);
      break;
    case -1: // EOF
      insertToken(COMMENT, buf2str(commentbuf));
      emitEOF();
      break; /* For security reasons: otherwise, hostile user could put a script in a comment e.g. in a blog comment and then DOS the server so that the end tag isn't read, and then the commented script tag would be treated as live code */
    default:
      commentbuf.push(0x002D);
      commentbuf.push(0x002D);
      reconsume(c, comment_state);
      break;
    }
  }

  function comment_end_bang_state(c) {
    switch(c) {
    case 0x002D: // HYPHEN-MINUS
      commentbuf.push(0x002D);
      commentbuf.push(0x002D);
      commentbuf.push(0x0021);
      tokenizer = comment_end_dash_state;
      break;
    case 0x003E: // GREATER-THAN SIGN
      tokenizer = data_state;
      insertToken(COMMENT, buf2str(commentbuf));
      break;
    case -1: // EOF
      insertToken(COMMENT, buf2str(commentbuf));
      emitEOF();
      break; /* see comment in comment end state */
    default:
      commentbuf.push(0x002D);
      commentbuf.push(0x002D);
      commentbuf.push(0x0021);
      reconsume(c, comment_state);
      break;
    }
  }

  function doctype_state(c) {
    switch(c) {
    case 0x0009: // CHARACTER TABULATION (tab)
    case 0x000A: // LINE FEED (LF)
    case 0x000C: // FORM FEED (FF)
    case 0x0020: // SPACE
      tokenizer = before_doctype_name_state;
      break;
    case -1: // EOF
      beginDoctype();
      forcequirks();
      emitDoctype();
      emitEOF();
      break;
    default:
      reconsume(c, before_doctype_name_state);
      break;
    }
  }

  function before_doctype_name_state(c) {
    switch(c) {
    case 0x0009: // CHARACTER TABULATION (tab)
    case 0x000A: // LINE FEED (LF)
    case 0x000C: // FORM FEED (FF)
    case 0x0020: // SPACE
      /* Ignore the character. */
      break;
    case 0x0041:  // [A-Z]
    case 0x0042:case 0x0043:case 0x0044:case 0x0045:case 0x0046:
    case 0x0047:case 0x0048:case 0x0049:case 0x004A:case 0x004B:
    case 0x004C:case 0x004D:case 0x004E:case 0x004F:case 0x0050:
    case 0x0051:case 0x0052:case 0x0053:case 0x0054:case 0x0055:
    case 0x0056:case 0x0057:case 0x0058:case 0x0059:case 0x005A:
      beginDoctype();
      doctypenamebuf.push(c + 0x0020);
      tokenizer = doctype_name_state;
      break;
    case 0x0000: // NULL
      beginDoctype();
      doctypenamebuf.push(0xFFFD);
      tokenizer = doctype_name_state;
      break;
    case 0x003E: // GREATER-THAN SIGN
      beginDoctype();
      forcequirks();
      tokenizer = data_state;
      emitDoctype();
      break;
    case -1: // EOF
      beginDoctype();
      forcequirks();
      emitDoctype();
      emitEOF();
      break;
    default:
      beginDoctype();
      doctypenamebuf.push(c);
      tokenizer = doctype_name_state;
      break;
    }
  }

  function doctype_name_state(c) {
    switch(c) {
    case 0x0009: // CHARACTER TABULATION (tab)
    case 0x000A: // LINE FEED (LF)
    case 0x000C: // FORM FEED (FF)
    case 0x0020: // SPACE
      tokenizer = after_doctype_name_state;
      break;
    case 0x003E: // GREATER-THAN SIGN
      tokenizer = data_state;
      emitDoctype();
      break;
    case 0x0041:  // [A-Z]
    case 0x0042:case 0x0043:case 0x0044:case 0x0045:case 0x0046:
    case 0x0047:case 0x0048:case 0x0049:case 0x004A:case 0x004B:
    case 0x004C:case 0x004D:case 0x004E:case 0x004F:case 0x0050:
    case 0x0051:case 0x0052:case 0x0053:case 0x0054:case 0x0055:
    case 0x0056:case 0x0057:case 0x0058:case 0x0059:case 0x005A:
      doctypenamebuf.push(c + 0x0020);
      break;
    case 0x0000: // NULL
      doctypenamebuf.push(0xFFFD /* REPLACEMENT CHARACTER */);
      break;
    case -1: // EOF
      forcequirks();
      emitDoctype();
      emitEOF();
      break;
    default:
      doctypenamebuf.push(c);
      break;
    }
  }

  function after_doctype_name_state(c, lookahead, eof) {
    switch(c) {
    case 0x0009: // CHARACTER TABULATION (tab)
    case 0x000A: // LINE FEED (LF)
    case 0x000C: // FORM FEED (FF)
    case 0x0020: // SPACE
      /* Ignore the character. */
      nextchar += 1;
      break;
    case 0x003E: // GREATER-THAN SIGN
      tokenizer = data_state;
      nextchar += 1;
      emitDoctype();
      break;
    case -1: // EOF
      forcequirks();
      emitDoctype();
      emitEOF();
      break;
    default:
      lookahead = lookahead.toUpperCase();
      if (lookahead === "PUBLIC") {
        nextchar += 6;
        tokenizer = after_doctype_public_keyword_state;
      }
      else if (lookahead === "SYSTEM") {
        nextchar += 6;
        tokenizer = after_doctype_system_keyword_state;
      }
      else {
        forcequirks();
        tokenizer = bogus_doctype_state;
      }
      break;
    }
  }
  after_doctype_name_state.lookahead = 6;

  function after_doctype_public_keyword_state(c) {
    switch(c) {
    case 0x0009: // CHARACTER TABULATION (tab)
    case 0x000A: // LINE FEED (LF)
    case 0x000C: // FORM FEED (FF)
    case 0x0020: // SPACE
      tokenizer = before_doctype_public_identifier_state;
      break;
    case 0x0022: // QUOTATION MARK
      beginDoctypePublicId();
      tokenizer = doctype_public_identifier_double_quoted_state;
      break;
    case 0x0027: // APOSTROPHE
      beginDoctypePublicId();
      tokenizer = doctype_public_identifier_single_quoted_state;
      break;
    case 0x003E: // GREATER-THAN SIGN
      forcequirks();
      tokenizer = data_state;
      emitDoctype();
      break;
    case -1: // EOF
      forcequirks();
      emitDoctype();
      emitEOF();
      break;
    default:
      forcequirks();
      tokenizer = bogus_doctype_state;
      break;
    }
  }

  function before_doctype_public_identifier_state(c) {
    switch(c) {
    case 0x0009: // CHARACTER TABULATION (tab)
    case 0x000A: // LINE FEED (LF)
    case 0x000C: // FORM FEED (FF)
    case 0x0020: // SPACE
      /* Ignore the character. */
      break;
    case 0x0022: // QUOTATION MARK
      beginDoctypePublicId();
      tokenizer = doctype_public_identifier_double_quoted_state;
      break;
    case 0x0027: // APOSTROPHE
      beginDoctypePublicId();
      tokenizer = doctype_public_identifier_single_quoted_state;
      break;
    case 0x003E: // GREATER-THAN SIGN
      forcequirks();
      tokenizer = data_state;
      emitDoctype();
      break;
    case -1: // EOF
      forcequirks();
      emitDoctype();
      emitEOF();
      break;
    default:
      forcequirks();
      tokenizer = bogus_doctype_state;
      break;
    }
  }

  function doctype_public_identifier_double_quoted_state(c) {
    switch(c) {
    case 0x0022: // QUOTATION MARK
      tokenizer = after_doctype_public_identifier_state;
      break;
    case 0x0000: // NULL
      doctypepublicbuf.push(0xFFFD /* REPLACEMENT CHARACTER */);
      break;
    case 0x003E: // GREATER-THAN SIGN
      forcequirks();
      tokenizer = data_state;
      emitDoctype();
      break;
    case -1: // EOF
      forcequirks();
      emitDoctype();
      emitEOF();
      break;
    default:
      doctypepublicbuf.push(c);
      break;
    }
  }

  function doctype_public_identifier_single_quoted_state(c) {
    switch(c) {
    case 0x0027: // APOSTROPHE
      tokenizer = after_doctype_public_identifier_state;
      break;
    case 0x0000: // NULL
      doctypepublicbuf.push(0xFFFD /* REPLACEMENT CHARACTER */);
      break;
    case 0x003E: // GREATER-THAN SIGN
      forcequirks();
      tokenizer = data_state;
      emitDoctype();
      break;
    case -1: // EOF
      forcequirks();
      emitDoctype();
      emitEOF();
      break;
    default:
      doctypepublicbuf.push(c);
      break;
    }
  }

  function after_doctype_public_identifier_state(c) {
    switch(c) {
    case 0x0009: // CHARACTER TABULATION (tab)
    case 0x000A: // LINE FEED (LF)
    case 0x000C: // FORM FEED (FF)
    case 0x0020: // SPACE
      tokenizer = between_doctype_public_and_system_identifiers_state;
      break;
    case 0x003E: // GREATER-THAN SIGN
      tokenizer = data_state;
      emitDoctype();
      break;
    case 0x0022: // QUOTATION MARK
      beginDoctypeSystemId();
      tokenizer = doctype_system_identifier_double_quoted_state;
      break;
    case 0x0027: // APOSTROPHE
      beginDoctypeSystemId();
      tokenizer = doctype_system_identifier_single_quoted_state;
      break;
    case -1: // EOF
      forcequirks();
      emitDoctype();
      emitEOF();
      break;
    default:
      forcequirks();
      tokenizer = bogus_doctype_state;
      break;
    }
  }

  function between_doctype_public_and_system_identifiers_state(c) {
    switch(c) {
    case 0x0009: // CHARACTER TABULATION (tab)
    case 0x000A: // LINE FEED (LF)
    case 0x000C: // FORM FEED (FF)
    case 0x0020: // SPACE Ignore the character.
      break;
    case 0x003E: // GREATER-THAN SIGN
      tokenizer = data_state;
      emitDoctype();
      break;
    case 0x0022: // QUOTATION MARK
      beginDoctypeSystemId();
      tokenizer = doctype_system_identifier_double_quoted_state;
      break;
    case 0x0027: // APOSTROPHE
      beginDoctypeSystemId();
      tokenizer = doctype_system_identifier_single_quoted_state;
      break;
    case -1: // EOF
      forcequirks();
      emitDoctype();
      emitEOF();
      break;
    default:
      forcequirks();
      tokenizer = bogus_doctype_state;
      break;
    }
  }

  function after_doctype_system_keyword_state(c) {
    switch(c) {
    case 0x0009: // CHARACTER TABULATION (tab)
    case 0x000A: // LINE FEED (LF)
    case 0x000C: // FORM FEED (FF)
    case 0x0020: // SPACE
      tokenizer = before_doctype_system_identifier_state;
      break;
    case 0x0022: // QUOTATION MARK
      beginDoctypeSystemId();
      tokenizer = doctype_system_identifier_double_quoted_state;
      break;
    case 0x0027: // APOSTROPHE
      beginDoctypeSystemId();
      tokenizer = doctype_system_identifier_single_quoted_state;
      break;
    case 0x003E: // GREATER-THAN SIGN
      forcequirks();
      tokenizer = data_state;
      emitDoctype();
      break;
    case -1: // EOF
      forcequirks();
      emitDoctype();
      emitEOF();
      break;
    default:
      forcequirks();
      tokenizer = bogus_doctype_state;
      break;
    }
  }

  function before_doctype_system_identifier_state(c) {
    switch(c) {
    case 0x0009: // CHARACTER TABULATION (tab)
    case 0x000A: // LINE FEED (LF)
    case 0x000C: // FORM FEED (FF)
    case 0x0020: // SPACE Ignore the character.
      break;
    case 0x0022: // QUOTATION MARK
      beginDoctypeSystemId();
      tokenizer = doctype_system_identifier_double_quoted_state;
      break;
    case 0x0027: // APOSTROPHE
      beginDoctypeSystemId();
      tokenizer = doctype_system_identifier_single_quoted_state;
      break;
    case 0x003E: // GREATER-THAN SIGN
      forcequirks();
      tokenizer = data_state;
      emitDoctype();
      break;
    case -1: // EOF
      forcequirks();
      emitDoctype();
      emitEOF();
      break;
    default:
      forcequirks();
      tokenizer = bogus_doctype_state;
      break;
    }
  }

  function doctype_system_identifier_double_quoted_state(c) {
    switch(c) {
    case 0x0022: // QUOTATION MARK
      tokenizer = after_doctype_system_identifier_state;
      break;
    case 0x0000: // NULL
      doctypesystembuf.push(0xFFFD /* REPLACEMENT CHARACTER */);
      break;
    case 0x003E: // GREATER-THAN SIGN
      forcequirks();
      tokenizer = data_state;
      emitDoctype();
      break;
    case -1: // EOF
      forcequirks();
      emitDoctype();
      emitEOF();
      break;
    default:
      doctypesystembuf.push(c);
      break;
    }
  }

  function doctype_system_identifier_single_quoted_state(c) {
    switch(c) {
    case 0x0027: // APOSTROPHE
      tokenizer = after_doctype_system_identifier_state;
      break;
    case 0x0000: // NULL
      doctypesystembuf.push(0xFFFD /* REPLACEMENT CHARACTER */);
      break;
    case 0x003E: // GREATER-THAN SIGN
      forcequirks();
      tokenizer = data_state;
      emitDoctype();
      break;
    case -1: // EOF
      forcequirks();
      emitDoctype();
      emitEOF();
      break;
    default:
      doctypesystembuf.push(c);
      break;
    }
  }

  function after_doctype_system_identifier_state(c) {
    switch(c) {
    case 0x0009: // CHARACTER TABULATION (tab)
    case 0x000A: // LINE FEED (LF)
    case 0x000C: // FORM FEED (FF)
    case 0x0020: // SPACE
      /* Ignore the character. */
      break;
    case 0x003E: // GREATER-THAN SIGN
      tokenizer = data_state;
      emitDoctype();
      break;
    case -1: // EOF
      forcequirks();
      emitDoctype();
      emitEOF();
      break;
    default:
      tokenizer = bogus_doctype_state;
      /* This does *not* set the DOCTYPE token's force-quirks flag. */
      break;
    }
  }

  function bogus_doctype_state(c) {
    switch(c) {
    case 0x003E: // GREATER-THAN SIGN
      tokenizer = data_state;
      emitDoctype();
      break;
    case -1: // EOF
      emitDoctype();
      emitEOF();
      break;
    default:
      /* Ignore the character. */
      break;
    }
  }

  function cdata_section_state(c) {
    switch(c) {
    case 0x005D: // RIGHT SQUARE BRACKET
      tokenizer = cdata_section_bracket_state;
      break;
    case -1: // EOF
      emitEOF();
      break;
    case 0x0000: // NULL
      textIncludesNUL = true;
      /* fall through */
    default:
      // Instead of just pushing a single character and then
      // coming back to the very same place, lookahead and
      // emit everything we can at once.
      /*jshint -W030 */
      emitCharsWhile(CDATATEXT) || textrun.push(c);
      break;
    }
  }

  function cdata_section_bracket_state(c) {
    switch(c) {
    case 0x005D: // RIGHT SQUARE BRACKET
      tokenizer = cdata_section_end_state;
      break;
    default:
      textrun.push(0x005D);
      reconsume(c, cdata_section_state);
      break;
    }
  }

  function cdata_section_end_state(c) {
    switch(c) {
    case 0x005D: // RIGHT SQUARE BRACKET
      textrun.push(0x005D);
      break;
    case 0x003E: // GREATER-THAN SIGN
      flushText();
      tokenizer = data_state;
      break;
    default:
      textrun.push(0x005D);
      textrun.push(0x005D);
      reconsume(c, cdata_section_state);
      break;
    }
  }

  function character_reference_state(c) {
    beginTempBuf();
    tempbuf.push(0x0026);
    switch(c) {
    case 0x0009: // TAB
    case 0x000A: // LINE FEED
    case 0x000C: // FORM FEED
    case 0x0020: // SPACE
    case 0x003C: // LESS-THAN SIGN
    case 0x0026: // AMPERSAND
    case -1: // EOF
      reconsume(c, character_reference_end_state);
      break;
    case 0x0023: // NUMBER SIGN
      tempbuf.push(c);
      tokenizer = numeric_character_reference_state;
      break;
    default:
      reconsume(c, named_character_reference_state);
      break;
    }
  }

  function named_character_reference_state(c) {
    NAMEDCHARREF.lastIndex = nextchar; // w/ lookahead no char has been consumed
    var matched = NAMEDCHARREF.exec(chars);
    if (!matched) throw new Error("should never happen");
    var name = matched[1];
    if (!name) {
      // If no match can be made, switch to the character reference end state
      tokenizer = character_reference_end_state;
      return;
    }

    // Consume the matched characters and append them to temporary buffer
    nextchar += name.length;
    pushAll(tempbuf, str2buf(name));

    switch(return_state) {
    case attribute_value_double_quoted_state:
    case attribute_value_single_quoted_state:
    case attribute_value_unquoted_state:
      // If the character reference was consumed as part of an attribute...
      if (name[name.length-1] !== ';') { // ...and the last char is not ;
        if (/[=A-Za-z0-9]/.test(chars[nextchar])) {
          tokenizer = character_reference_end_state;
          return;
        }
      }
      break;
    default:
      break;
    }

    beginTempBuf();
    var rv = namedCharRefs[name];
    if (typeof rv === 'number') {
      tempbuf.push(rv);
    } else {
      pushAll(tempbuf, rv);
    }
    tokenizer = character_reference_end_state;
  }
  // We might need to pause tokenization until we have enough characters
  // in the buffer for longest possible character reference.
  named_character_reference_state.lookahead = -NAMEDCHARREF_MAXLEN;

  function numeric_character_reference_state(c) {
    character_reference_code = 0;
    switch(c) {
    case 0x0078: // x
    case 0x0058: // X
      tempbuf.push(c);
      tokenizer = hexadecimal_character_reference_start_state;
      break;
    default:
      reconsume(c, decimal_character_reference_start_state);
      break;
    }
  }

  function hexadecimal_character_reference_start_state(c) {
    switch(c) {
    case 0x0030: case 0x0031: case 0x0032: case 0x0033: case 0x0034:
    case 0x0035: case 0x0036: case 0x0037: case 0x0038: case 0x0039: // [0-9]
    case 0x0041: case 0x0042: case 0x0043: case 0x0044: case 0x0045:
    case 0x0046: // [A-F]
    case 0x0061: case 0x0062: case 0x0063: case 0x0064: case 0x0065:
    case 0x0066: // [a-f]
      reconsume(c, hexadecimal_character_reference_state);
      break;
    default:
      reconsume(c, character_reference_end_state);
      break;
    }
  }

  function decimal_character_reference_start_state(c) {
    switch(c) {
    case 0x0030: case 0x0031: case 0x0032: case 0x0033: case 0x0034:
    case 0x0035: case 0x0036: case 0x0037: case 0x0038: case 0x0039: // [0-9]
      reconsume(c, decimal_character_reference_state);
      break;
    default:
      reconsume(c, character_reference_end_state);
      break;
    }
  }

  function hexadecimal_character_reference_state(c) {
    switch(c) {
    case 0x0041: case 0x0042: case 0x0043: case 0x0044: case 0x0045:
    case 0x0046: // [A-F]
      character_reference_code *= 16;
      character_reference_code += (c - 0x0037);
      break;
    case 0x0061: case 0x0062: case 0x0063: case 0x0064: case 0x0065:
    case 0x0066: // [a-f]
      character_reference_code *= 16;
      character_reference_code += (c - 0x0057);
      break;
    case 0x0030: case 0x0031: case 0x0032: case 0x0033: case 0x0034:
    case 0x0035: case 0x0036: case 0x0037: case 0x0038: case 0x0039: // [0-9]
      character_reference_code *= 16;
      character_reference_code += (c - 0x0030);
      break;
    case 0x003B: // SEMICOLON
      tokenizer = numeric_character_reference_end_state;
      break;
    default:
      reconsume(c, numeric_character_reference_end_state);
      break;
    }
  }

  function decimal_character_reference_state(c) {
    switch(c) {
    case 0x0030: case 0x0031: case 0x0032: case 0x0033: case 0x0034:
    case 0x0035: case 0x0036: case 0x0037: case 0x0038: case 0x0039: // [0-9]
      character_reference_code *= 10;
      character_reference_code += (c - 0x0030);
      break;
    case 0x003B: // SEMICOLON
      tokenizer = numeric_character_reference_end_state;
      break;
    default:
      reconsume(c, numeric_character_reference_end_state);
      break;
    }
  }

  function numeric_character_reference_end_state(c) {
    if (character_reference_code in numericCharRefReplacements) {
      character_reference_code = numericCharRefReplacements[character_reference_code];
    } else if (character_reference_code > 0x10FFFF || (character_reference_code >= 0xD800 && character_reference_code < 0xE000)) {
      character_reference_code = 0xFFFD;
    }

    beginTempBuf();
    if (character_reference_code <= 0xFFFF) {
      tempbuf.push(character_reference_code);
    } else {
      character_reference_code = character_reference_code - 0x10000;
      /* jshint bitwise: false */
      tempbuf.push(0xD800 + (character_reference_code >> 10));
      tempbuf.push(0xDC00 + (character_reference_code & 0x03FF));
    }
    reconsume(c, character_reference_end_state);
  }

  function character_reference_end_state(c) {
    switch(return_state) {
    case attribute_value_double_quoted_state:
    case attribute_value_single_quoted_state:
    case attribute_value_unquoted_state:
      // append each character to the current attribute's value
      attrvaluebuf += buf2str(tempbuf);
      break;
    default:
      pushAll(textrun, tempbuf);
      break;
    }
    reconsume(c, return_state);
  }

  /***
   * The tree builder insertion modes
   */

  // 11.2.5.4.1 The "initial" insertion mode
  function initial_mode(t, value, arg3, arg4) {
    switch(t) {
    case 1: // TEXT
      value = value.replace(LEADINGWS, ""); // Ignore spaces
      if (value.length === 0) return; // Are we done?
      break; // Handle anything non-space text below
    case 4: // COMMENT
      doc._appendChild(doc.createComment(value));
      return;
    case 5: // DOCTYPE
      var name = value;
      var publicid = arg3;
      var systemid = arg4;
      // Use the constructor directly instead of
      // implementation.createDocumentType because the create
      // function throws errors on invalid characters, and
      // we don't want the parser to throw them.
      doc.appendChild(new DocumentType(name,publicid, systemid));

      // Note that there is no public API for setting quirks mode We can
      // do this here because we have access to implementation details
      if (force_quirks ||
        name.toLowerCase() !== "html" ||
        quirkyPublicIds.test(publicid) ||
        (systemid && systemid.toLowerCase() === quirkySystemId) ||
        (systemid === undefined &&
         conditionallyQuirkyPublicIds.test(publicid)))
        doc._quirks = true;
      else if (limitedQuirkyPublicIds.test(publicid) ||
           (systemid !== undefined &&
            conditionallyQuirkyPublicIds.test(publicid)))
        doc._limitedQuirks = true;
      parser = before_html_mode;
      return;
    }

    // tags or non-whitespace text
    doc._quirks = true;
    parser = before_html_mode;
    parser(t,value,arg3,arg4);
  }

  // 11.2.5.4.2 The "before html" insertion mode
  function before_html_mode(t,value,arg3,arg4) {
    var elt;
    switch(t) {
    case 1: // TEXT
      value = value.replace(LEADINGWS, ""); // Ignore spaces
      if (value.length === 0) return; // Are we done?
      break; // Handle anything non-space text below
    case 5: // DOCTYPE
      /* ignore the token */
      return;
    case 4: // COMMENT
      doc._appendChild(doc.createComment(value));
      return;
    case 2: // TAG
      if (value === "html") {
        elt = createHTMLElt(doc, value, arg3);
        stack.push(elt);
        doc.appendChild(elt);
        // XXX: handle application cache here
        parser = before_head_mode;
        return;
      }
      break;
    case 3: // ENDTAG
      switch(value) {
      case "html":
      case "head":
      case "body":
      case "br":
        break;  // fall through on these
      default:
        return; // ignore most end tags
      }
    }

    // Anything that didn't get handled above is handled like this:
    elt = createHTMLElt(doc, "html", null);
    stack.push(elt);
    doc.appendChild(elt);
    // XXX: handle application cache here
    parser = before_head_mode;
    parser(t,value,arg3,arg4);
  }

  // 11.2.5.4.3 The "before head" insertion mode
  function before_head_mode(t,value,arg3,arg4) {
    switch(t) {
    case 1: // TEXT
      value = value.replace(LEADINGWS, "");  // Ignore spaces
      if (value.length === 0) return; // Are we done?
      break;  // Handle anything non-space text below
    case 5: // DOCTYPE
      /* ignore the token */
      return;
    case 4: // COMMENT
      insertComment(value);
      return;
    case 2: // TAG
      switch(value) {
      case "html":
        in_body_mode(t,value,arg3,arg4);
        return;
      case "head":
        var elt = insertHTMLElement(value, arg3);
        head_element_pointer = elt;
        parser = in_head_mode;
        return;
      }
      break;
    case 3: // ENDTAG
      switch(value) {
      case "html":
      case "head":
      case "body":
      case "br":
        break;
      default:
        return; // ignore most end tags
      }
    }

    // If not handled explicitly above
    before_head_mode(TAG, "head", null); // create a head tag
    parser(t, value, arg3, arg4); // then try again with this token
  }

  function in_head_mode(t, value, arg3, arg4) {
    switch(t) {
    case 1: // TEXT
      var ws = value.match(LEADINGWS);
      if (ws) {
        insertText(ws[0]);
        value = value.substring(ws[0].length);
      }
      if (value.length === 0) return;
      break; // Handle non-whitespace below
    case 4: // COMMENT
      insertComment(value);
      return;
    case 5: // DOCTYPE
      return;
    case 2: // TAG
      switch(value) {
      case "html":
        in_body_mode(t, value, arg3, arg4);
        return;
      case "meta":
        // XXX:
        // May need to change the encoding based on this tag
        /* falls through */
      case "base":
      case "basefont":
      case "bgsound":
      case "link":
        insertHTMLElement(value, arg3);
        stack.pop();
        return;
      case "title":
        parseRCDATA(value, arg3);
        return;
      case "noscript":
        if (!scripting_enabled) {
          insertHTMLElement(value, arg3);
          parser = in_head_noscript_mode;
          return;
        }
        // Otherwise, if scripting is enabled...
        /* falls through */
      case "noframes":
      case "style":
        parseRawText(value,arg3);
        return;
      case "script":
        insertElement(function(doc) {
          var elt = createHTMLElt(doc, value, arg3);
          elt._parser_inserted = true;
          elt._force_async = false;
          if (fragment) elt._already_started = true;
          flushText();
          return elt;
        });
        tokenizer = script_data_state;
        originalInsertionMode = parser;
        parser = text_mode;
        return;
      case "template":
        insertHTMLElement(value, arg3);
        afe.insertMarker();
        frameset_ok = false;
        parser = in_template_mode;
        templateInsertionModes.push(parser);
        return;
      case "head":
        return; // ignore it
      }
      break;
    case 3: // ENDTAG
      switch(value) {
      case "head":
        stack.pop();
        parser = after_head_mode;
        return;
      case "body":
      case "html":
      case "br":
        break; // handle these at the bottom of the function
      case "template":
        if (!stack.contains("template")) {
          return;
        }
        stack.generateImpliedEndTags(null, "thorough");
        stack.popTag("template");
        afe.clearToMarker();
        templateInsertionModes.pop();
        resetInsertionMode();
        return;
      default:
        // ignore any other end tag
        return;
      }
      break;
    }

    // If not handled above
    in_head_mode(ENDTAG, "head", null);   // synthetic </head>
    parser(t, value, arg3, arg4);   // Then redo this one
  }

  // 13.2.5.4.5 The "in head noscript" insertion mode
  function in_head_noscript_mode(t, value, arg3, arg4) {
    switch(t) {
    case 5: // DOCTYPE
      return;
    case 4: // COMMENT
      in_head_mode(t, value);
      return;
    case 1: // TEXT
      var ws = value.match(LEADINGWS);
      if (ws) {
        in_head_mode(t, ws[0]);
        value = value.substring(ws[0].length);
      }
      if (value.length === 0) return; // no more text
      break; // Handle non-whitespace below
    case 2: // TAG
      switch(value) {
      case "html":
        in_body_mode(t, value, arg3, arg4);
        return;
      case "basefont":
      case "bgsound":
      case "link":
      case "meta":
      case "noframes":
      case "style":
        in_head_mode(t, value, arg3);
        return;
      case "head":
      case "noscript":
        return;
      }
      break;
    case 3: // ENDTAG
      switch(value) {
      case "noscript":
        stack.pop();
        parser = in_head_mode;
        return;
      case "br":
        break;  // goes to the outer default
      default:
        return; // ignore other end tags
      }
      break;
    }

    // If not handled above
    in_head_noscript_mode(ENDTAG, "noscript", null);
    parser(t, value, arg3, arg4);
  }

  function after_head_mode(t, value, arg3, arg4) {
    switch(t) {
    case 1: // TEXT
      var ws = value.match(LEADINGWS);
      if (ws) {
        insertText(ws[0]);
        value = value.substring(ws[0].length);
      }
      if (value.length === 0) return;
      break; // Handle non-whitespace below
    case 4: // COMMENT
      insertComment(value);
      return;
    case 5: // DOCTYPE
      return;
    case 2: // TAG
      switch(value) {
      case "html":
        in_body_mode(t, value, arg3, arg4);
        return;
      case "body":
        insertHTMLElement(value, arg3);
        frameset_ok = false;
        parser = in_body_mode;
        return;
      case "frameset":
        insertHTMLElement(value, arg3);
        parser = in_frameset_mode;
        return;
      case "base":
      case "basefont":
      case "bgsound":
      case "link":
      case "meta":
      case "noframes":
      case "script":
      case "style":
      case "template":
      case "title":
        stack.push(head_element_pointer);
        in_head_mode(TAG, value, arg3);
        stack.removeElement(head_element_pointer);
        return;
      case "head":
        return;
      }
      break;
    case 3: // ENDTAG
      switch(value) {
      case "template":
        return in_head_mode(t, value, arg3, arg4);
      case "body":
      case "html":
      case "br":
        break;
      default:
        return;  // ignore any other end tag
      }
      break;
    }

    after_head_mode(TAG, "body", null);
    frameset_ok = true;
    parser(t, value, arg3, arg4);
  }

  // 13.2.5.4.7 The "in body" insertion mode
  function in_body_mode(t,value,arg3,arg4) {
    var body, i, node, elt;
    switch(t) {
    case 1: // TEXT
      if (textIncludesNUL) {
        value = value.replace(NULCHARS, "");
        if (value.length === 0) return;
      }
      // If any non-space characters
      if (frameset_ok && NONWS.test(value))
        frameset_ok = false;
      afereconstruct();
      insertText(value);
      return;
    case 5: // DOCTYPE
      return;
    case 4: // COMMENT
      insertComment(value);
      return;
    case -1: // EOF
      if (templateInsertionModes.length) {
        return in_template_mode(t);
      }
      stopParsing();
      return;
    case 2: // TAG
      switch(value) {
      case "html":
        if (stack.contains("template")) {
          return;
        }
        transferAttributes(arg3, stack.elements[0]);
        return;
      case "base":
      case "basefont":
      case "bgsound":
      case "link":
      case "meta":
      case "noframes":
      case "script":
      case "style":
      case "template":
      case "title":
        in_head_mode(TAG, value, arg3);
        return;
      case "body":
        body = stack.elements[1];
        if (!body || !(body instanceof impl.HTMLBodyElement) ||
            stack.contains("template"))
          return;
        frameset_ok = false;
        transferAttributes(arg3, body);
        return;
      case "frameset":
        if (!frameset_ok) return;
        body = stack.elements[1];
        if (!body || !(body instanceof impl.HTMLBodyElement))
          return;
        if (body.parentNode) body.parentNode.removeChild(body);
        while(!(stack.top instanceof impl.HTMLHtmlElement))
          stack.pop();
        insertHTMLElement(value, arg3);
        parser = in_frameset_mode;
        return;

      case "address":
      case "article":
      case "aside":
      case "blockquote":
      case "center":
      case "details":
      case "dialog":
      case "dir":
      case "div":
      case "dl":
      case "fieldset":
      case "figcaption":
      case "figure":
      case "footer":
      case "header":
      case "hgroup":
      case "main":
      case "nav":
      case "ol":
      case "p":
      case "section":
      case "summary":
      case "ul":
        if (stack.inButtonScope("p")) in_body_mode(ENDTAG, "p");
        insertHTMLElement(value, arg3);
        return;

      case "menu":
        if (stack.inButtonScope("p")) in_body_mode(ENDTAG, "p");
        if (isA(stack.top, 'menuitem')) {
          stack.pop();
        }
        insertHTMLElement(value, arg3);
        return;

      case "h1":
      case "h2":
      case "h3":
      case "h4":
      case "h5":
      case "h6":
        if (stack.inButtonScope("p")) in_body_mode(ENDTAG, "p");
        if (stack.top instanceof impl.HTMLHeadingElement)
          stack.pop();
        insertHTMLElement(value, arg3);
        return;

      case "pre":
      case "listing":
        if (stack.inButtonScope("p")) in_body_mode(ENDTAG, "p");
        insertHTMLElement(value, arg3);
        ignore_linefeed = true;
        frameset_ok = false;
        return;

      case "form":
        if (form_element_pointer && !stack.contains("template")) return;
        if (stack.inButtonScope("p")) in_body_mode(ENDTAG, "p");
        elt = insertHTMLElement(value, arg3);
        if (!stack.contains("template"))
          form_element_pointer = elt;
        return;

      case "li":
        frameset_ok = false;
        for(i = stack.elements.length-1; i >= 0; i--) {
          node = stack.elements[i];
          if (node instanceof impl.HTMLLIElement) {
            in_body_mode(ENDTAG, "li");
            break;
          }
          if (isA(node, specialSet) && !isA(node, addressdivpSet))
            break;
        }
        if (stack.inButtonScope("p")) in_body_mode(ENDTAG, "p");
        insertHTMLElement(value, arg3);
        return;

      case "dd":
      case "dt":
        frameset_ok = false;
        for(i = stack.elements.length-1; i >= 0; i--) {
          node = stack.elements[i];
          if (isA(node, dddtSet)) {
            in_body_mode(ENDTAG, node.localName);
            break;
          }
          if (isA(node, specialSet) && !isA(node, addressdivpSet))
            break;
        }
        if (stack.inButtonScope("p")) in_body_mode(ENDTAG, "p");
        insertHTMLElement(value, arg3);
        return;

      case "plaintext":
        if (stack.inButtonScope("p")) in_body_mode(ENDTAG, "p");
        insertHTMLElement(value, arg3);
        tokenizer = plaintext_state;
        return;

      case "button":
        if (stack.inScope("button")) {
          in_body_mode(ENDTAG, "button");
          parser(t, value, arg3, arg4);
        }
        else {
          afereconstruct();
          insertHTMLElement(value, arg3);
          frameset_ok = false;
        }
        return;

      case "a":
        var activeElement = afe.findElementByTag("a");
        if (activeElement) {
          in_body_mode(ENDTAG, value);
          afe.remove(activeElement);
          stack.removeElement(activeElement);
        }
        /* falls through */
      case "b":
      case "big":
      case "code":
      case "em":
      case "font":
      case "i":
      case "s":
      case "small":
      case "strike":
      case "strong":
      case "tt":
      case "u":
        afereconstruct();
        afe.push(insertHTMLElement(value,arg3), arg3);
        return;

      case "nobr":
        afereconstruct();

        if (stack.inScope(value)) {
          in_body_mode(ENDTAG, value);
          afereconstruct();
        }
        afe.push(insertHTMLElement(value,arg3), arg3);
        return;

      case "applet":
      case "marquee":
      case "object":
        afereconstruct();
        insertHTMLElement(value,arg3);
        afe.insertMarker();
        frameset_ok = false;
        return;

      case "table":
        if (!doc._quirks && stack.inButtonScope("p")) {
          in_body_mode(ENDTAG, "p");
        }
        insertHTMLElement(value,arg3);
        frameset_ok = false;
        parser = in_table_mode;
        return;

      case "area":
      case "br":
      case "embed":
      case "img":
      case "keygen":
      case "wbr":
        afereconstruct();
        insertHTMLElement(value,arg3);
        stack.pop();
        frameset_ok = false;
        return;

      case "input":
        afereconstruct();
        elt = insertHTMLElement(value,arg3);
        stack.pop();
        var type = elt.getAttribute("type");
        if (!type || type.toLowerCase() !== "hidden")
          frameset_ok = false;
        return;

      case "param":
      case "source":
      case "track":
        insertHTMLElement(value,arg3);
        stack.pop();
        return;

      case "hr":
        if (stack.inButtonScope("p")) in_body_mode(ENDTAG, "p");
        if (isA(stack.top, 'menuitem')) {
          stack.pop();
        }
        insertHTMLElement(value,arg3);
        stack.pop();
        frameset_ok = false;
        return;

      case "image":
        in_body_mode(TAG, "img", arg3, arg4);
        return;

      case "textarea":
        insertHTMLElement(value,arg3);
        ignore_linefeed = true;
        frameset_ok = false;
        tokenizer = rcdata_state;
        originalInsertionMode = parser;
        parser = text_mode;
        return;

      case "xmp":
        if (stack.inButtonScope("p")) in_body_mode(ENDTAG, "p");
        afereconstruct();
        frameset_ok = false;
        parseRawText(value, arg3);
        return;

      case "iframe":
        frameset_ok = false;
        parseRawText(value, arg3);
        return;

      case "noembed":
        parseRawText(value,arg3);
        return;

      case "noscript":
        if (scripting_enabled) {
          parseRawText(value,arg3);
          return;
        }
        break;  // XXX Otherwise treat it as any other open tag?

      case "select":
        afereconstruct();
        insertHTMLElement(value,arg3);
        frameset_ok = false;
        if (parser === in_table_mode ||
          parser === in_caption_mode ||
          parser === in_table_body_mode ||
          parser === in_row_mode ||
          parser === in_cell_mode)
          parser = in_select_in_table_mode;
        else
          parser = in_select_mode;
        return;

      case "optgroup":
      case "option":
        if (stack.top instanceof impl.HTMLOptionElement) {
          in_body_mode(ENDTAG, "option");
        }
        afereconstruct();
        insertHTMLElement(value,arg3);
        return;

      case "menuitem":
        if (isA(stack.top, 'menuitem')) {
          stack.pop();
        }
        afereconstruct();
        insertHTMLElement(value, arg3);
        return;

      case "rb":
      case "rtc":
        if (stack.inScope("ruby")) {
          stack.generateImpliedEndTags();
        }
        insertHTMLElement(value,arg3);
        return;

      case "rp":
      case "rt":
        if (stack.inScope("ruby")) {
          stack.generateImpliedEndTags("rtc");
        }
        insertHTMLElement(value,arg3);
        return;

      case "math":
        afereconstruct();
        adjustMathMLAttributes(arg3);
        adjustForeignAttributes(arg3);
        insertForeignElement(value, arg3, NAMESPACE.MATHML);
        if (arg4) // self-closing flag
          stack.pop();
        return;

      case "svg":
        afereconstruct();
        adjustSVGAttributes(arg3);
        adjustForeignAttributes(arg3);
        insertForeignElement(value, arg3, NAMESPACE.SVG);
        if (arg4) // self-closing flag
          stack.pop();
        return;

      case "caption":
      case "col":
      case "colgroup":
      case "frame":
      case "head":
      case "tbody":
      case "td":
      case "tfoot":
      case "th":
      case "thead":
      case "tr":
        // Ignore table tags if we're not in_table mode
        return;
      }

      // Handle any other start tag here
      // (and also noscript tags when scripting is disabled)
      afereconstruct();
      insertHTMLElement(value,arg3);
      return;

    case 3: // ENDTAG
      switch(value) {
      case "template":
        in_head_mode(ENDTAG, value, arg3);
        return;
      case "body":
        if (!stack.inScope("body")) return;
        parser = after_body_mode;
        return;
      case "html":
        if (!stack.inScope("body")) return;
        parser = after_body_mode;
        parser(t, value, arg3);
        return;

      case "address":
      case "article":
      case "aside":
      case "blockquote":
      case "button":
      case "center":
      case "details":
      case "dialog":
      case "dir":
      case "div":
      case "dl":
      case "fieldset":
      case "figcaption":
      case "figure":
      case "footer":
      case "header":
      case "hgroup":
      case "listing":
      case "main":
      case "menu":
      case "nav":
      case "ol":
      case "pre":
      case "section":
      case "summary":
      case "ul":
        // Ignore if there is not a matching open tag
        if (!stack.inScope(value)) return;
        stack.generateImpliedEndTags();
        stack.popTag(value);
        return;

      case "form":
        if (!stack.contains("template")) {
          var openform = form_element_pointer;
          form_element_pointer = null;
          if (!openform || !stack.elementInScope(openform)) return;
          stack.generateImpliedEndTags();
          stack.removeElement(openform);
        } else {
          if (!stack.inScope("form")) return;
          stack.generateImpliedEndTags();
          stack.popTag("form");
        }
        return;

      case "p":
        if (!stack.inButtonScope(value)) {
          in_body_mode(TAG, value, null);
          parser(t, value, arg3, arg4);
        }
        else {
          stack.generateImpliedEndTags(value);
          stack.popTag(value);
        }
        return;

      case "li":
        if (!stack.inListItemScope(value)) return;
        stack.generateImpliedEndTags(value);
        stack.popTag(value);
        return;

      case "dd":
      case "dt":
        if (!stack.inScope(value)) return;
        stack.generateImpliedEndTags(value);
        stack.popTag(value);
        return;

      case "h1":
      case "h2":
      case "h3":
      case "h4":
      case "h5":
      case "h6":
        if (!stack.elementTypeInScope(impl.HTMLHeadingElement)) return;
        stack.generateImpliedEndTags();
        stack.popElementType(impl.HTMLHeadingElement);
        return;

      case "sarcasm":
        // Take a deep breath, and then:
        break;

      case "a":
      case "b":
      case "big":
      case "code":
      case "em":
      case "font":
      case "i":
      case "nobr":
      case "s":
      case "small":
      case "strike":
      case "strong":
      case "tt":
      case "u":
        var result = adoptionAgency(value);
        if (result) return;  // If we did something we're done
        break;         // Go to the "any other end tag" case

      case "applet":
      case "marquee":
      case "object":
        if (!stack.inScope(value)) return;
        stack.generateImpliedEndTags();
        stack.popTag(value);
        afe.clearToMarker();
        return;

      case "br":
        in_body_mode(TAG, value, null);  // Turn </br> into <br>
        return;
      }

      // Any other end tag goes here
      for(i = stack.elements.length-1; i >= 0; i--) {
        node = stack.elements[i];
        if (isA(node, value)) {
          stack.generateImpliedEndTags(value);
          stack.popElement(node);
          break;
        }
        else if (isA(node, specialSet)) {
          return;
        }
      }

      return;
    }
  }

  function text_mode(t, value, arg3, arg4) {
    switch(t) {
    case 1: // TEXT
      insertText(value);
      return;
    case -1: // EOF
      if (stack.top instanceof impl.HTMLScriptElement)
        stack.top._already_started = true;
      stack.pop();
      parser = originalInsertionMode;
      parser(t);
      return;
    case 3: // ENDTAG
      if (value === "script") {
        handleScriptEnd();
      }
      else {
        stack.pop();
        parser = originalInsertionMode;
      }
      return;
    default:
      // We should never get any other token types
      return;
    }
  }

  function in_table_mode(t, value, arg3, arg4) {
    function getTypeAttr(attrs) {
      for(var i = 0, n = attrs.length; i < n; i++) {
        if (attrs[i][0] === "type")
          return attrs[i][1].toLowerCase();
      }
      return null;
    }

    switch(t) {
    case 1: // TEXT
      // XXX the text_integration_mode stuff is
      // just a hack I made up
      if (text_integration_mode) {
        in_body_mode(t, value, arg3, arg4);
        return;
      }
      else if (isA(stack.top, tablesectionrowSet)) {
        pending_table_text = [];
        originalInsertionMode = parser;
        parser = in_table_text_mode;
        parser(t, value, arg3, arg4);
        return;
      }
      break;
    case 4: // COMMENT
      insertComment(value);
      return;
    case 5: // DOCTYPE
      return;
    case 2: // TAG
      switch(value) {
      case "caption":
        stack.clearToContext(tableContextSet);
        afe.insertMarker();
        insertHTMLElement(value,arg3);
        parser = in_caption_mode;
        return;
      case "colgroup":
        stack.clearToContext(tableContextSet);
        insertHTMLElement(value,arg3);
        parser = in_column_group_mode;
        return;
      case "col":
        in_table_mode(TAG, "colgroup", null);
        parser(t, value, arg3, arg4);
        return;
      case "tbody":
      case "tfoot":
      case "thead":
        stack.clearToContext(tableContextSet);
        insertHTMLElement(value,arg3);
        parser = in_table_body_mode;
        return;
      case "td":
      case "th":
      case "tr":
        in_table_mode(TAG, "tbody", null);
        parser(t, value, arg3, arg4);
        return;

      case "table":
        if (!stack.inTableScope(value)) {
          return; // Ignore the token
        }
        in_table_mode(ENDTAG, value);
        parser(t, value, arg3, arg4);
        return;

      case "style":
      case "script":
      case "template":
        in_head_mode(t, value, arg3, arg4);
        return;

      case "input":
        var type = getTypeAttr(arg3);
        if (type !== "hidden") break;  // to the anything else case
        insertHTMLElement(value,arg3);
        stack.pop();
        return;

      case "form":
        if (form_element_pointer || stack.contains("template")) return;
        form_element_pointer = insertHTMLElement(value, arg3);
        stack.popElement(form_element_pointer);
        return;
      }
      break;
    case 3: // ENDTAG
      switch(value) {
      case "table":
        if (!stack.inTableScope(value)) return;
        stack.popTag(value);
        resetInsertionMode();
        return;
      case "body":
      case "caption":
      case "col":
      case "colgroup":
      case "html":
      case "tbody":
      case "td":
      case "tfoot":
      case "th":
      case "thead":
      case "tr":
        return;
      case "template":
        in_head_mode(t, value, arg3, arg4);
        return;
      }

      break;
    case -1: // EOF
      in_body_mode(t, value, arg3, arg4);
      return;
    }

    // This is the anything else case
    foster_parent_mode = true;
    in_body_mode(t, value, arg3, arg4);
    foster_parent_mode = false;
  }

  function in_table_text_mode(t, value, arg3, arg4) {
    if (t === TEXT) {
      if (textIncludesNUL) {
        value = value.replace(NULCHARS, "");
        if (value.length === 0) return;
      }
      pending_table_text.push(value);
    }
    else {
      var s = pending_table_text.join("");
      pending_table_text.length = 0;
      if (NONWS.test(s)) { // If any non-whitespace characters
        // This must be the same code as the "anything else"
        // case of the in_table mode above.
        foster_parent_mode = true;
        in_body_mode(TEXT, s);
        foster_parent_mode = false;
      }
      else {
        insertText(s);
      }
      parser = originalInsertionMode;
      parser(t, value, arg3, arg4);
    }
  }


  function in_caption_mode(t, value, arg3, arg4) {
    function end_caption() {
      if (!stack.inTableScope("caption")) return false;
      stack.generateImpliedEndTags();
      stack.popTag("caption");
      afe.clearToMarker();
      parser = in_table_mode;
      return true;
    }

    switch(t) {
    case 2: // TAG
      switch(value) {
      case "caption":
      case "col":
      case "colgroup":
      case "tbody":
      case "td":
      case "tfoot":
      case "th":
      case "thead":
      case "tr":
        if (end_caption()) parser(t, value, arg3, arg4);
        return;
      }
      break;
    case 3: // ENDTAG
      switch(value) {
      case "caption":
        end_caption();
        return;
      case "table":
        if (end_caption()) parser(t, value, arg3, arg4);
        return;
      case "body":
      case "col":
      case "colgroup":
      case "html":
      case "tbody":
      case "td":
      case "tfoot":
      case "th":
      case "thead":
      case "tr":
        return;
      }
      break;
    }

    // The Anything Else case
    in_body_mode(t, value, arg3, arg4);
  }

  function in_column_group_mode(t, value, arg3, arg4) {
    switch(t) {
    case 1: // TEXT
      var ws = value.match(LEADINGWS);
      if (ws) {
        insertText(ws[0]);
        value = value.substring(ws[0].length);
      }
      if (value.length === 0) return;
      break; // Handle non-whitespace below

    case 4: // COMMENT
      insertComment(value);
      return;
    case 5: // DOCTYPE
      return;
    case 2: // TAG
      switch(value) {
      case "html":
        in_body_mode(t, value, arg3, arg4);
        return;
      case "col":
        insertHTMLElement(value, arg3);
        stack.pop();
        return;
      case "template":
        in_head_mode(t, value, arg3, arg4);
        return;
      }
      break;
    case 3: // ENDTAG
      switch(value) {
      case "colgroup":
        if (!isA(stack.top, 'colgroup')) {
          return; // Ignore the token.
        }
        stack.pop();
        parser = in_table_mode;
        return;
      case "col":
        return;
      case "template":
        in_head_mode(t, value, arg3, arg4);
        return;
      }
      break;
    case -1: // EOF
      in_body_mode(t, value, arg3, arg4);
      return;
    }

    // Anything else
    if (!isA(stack.top, 'colgroup')) {
      return; // Ignore the token.
    }
    in_column_group_mode(ENDTAG, "colgroup");
    parser(t, value, arg3, arg4);
  }

  function in_table_body_mode(t, value, arg3, arg4) {
    function endsect() {
      if (!stack.inTableScope("tbody") &&
        !stack.inTableScope("thead") &&
        !stack.inTableScope("tfoot"))
        return;
      stack.clearToContext(tableBodyContextSet);
      in_table_body_mode(ENDTAG, stack.top.localName, null);
      parser(t, value, arg3, arg4);
    }

    switch(t) {
    case 2: // TAG
      switch(value) {
      case "tr":
        stack.clearToContext(tableBodyContextSet);
        insertHTMLElement(value, arg3);
        parser = in_row_mode;
        return;
      case "th":
      case "td":
        in_table_body_mode(TAG, "tr", null);
        parser(t, value, arg3, arg4);
        return;
      case "caption":
      case "col":
      case "colgroup":
      case "tbody":
      case "tfoot":
      case "thead":
        endsect();
        return;
      }
      break;
    case 3: // ENDTAG
      switch(value) {
      case "table":
        endsect();
        return;
      case "tbody":
      case "tfoot":
      case "thead":
        if (stack.inTableScope(value)) {
          stack.clearToContext(tableBodyContextSet);
          stack.pop();
          parser = in_table_mode;
        }
        return;
      case "body":
      case "caption":
      case "col":
      case "colgroup":
      case "html":
      case "td":
      case "th":
      case "tr":
        return;
      }
      break;
    }

    // Anything else:
    in_table_mode(t, value, arg3, arg4);
  }

  function in_row_mode(t, value, arg3, arg4) {
    function endrow() {
      if (!stack.inTableScope("tr")) return false;
      stack.clearToContext(tableRowContextSet);
      stack.pop();
      parser = in_table_body_mode;
      return true;
    }

    switch(t) {
    case 2: // TAG
      switch(value) {
      case "th":
      case "td":
        stack.clearToContext(tableRowContextSet);
        insertHTMLElement(value, arg3);
        parser = in_cell_mode;
        afe.insertMarker();
        return;
      case "caption":
      case "col":
      case "colgroup":
      case "tbody":
      case "tfoot":
      case "thead":
      case "tr":
        if (endrow()) parser(t, value, arg3, arg4);
        return;
      }
      break;
    case 3: // ENDTAG
      switch(value) {
      case "tr":
        endrow();
        return;
      case "table":
        if (endrow()) parser(t, value, arg3, arg4);
        return;
      case "tbody":
      case "tfoot":
      case "thead":
        if (stack.inTableScope(value)) {
          if (endrow()) parser(t, value, arg3, arg4);
        }
        return;
      case "body":
      case "caption":
      case "col":
      case "colgroup":
      case "html":
      case "td":
      case "th":
        return;
      }
      break;
    }

    // anything else
    in_table_mode(t, value, arg3, arg4);
  }

  function in_cell_mode(t, value, arg3, arg4) {
    switch(t) {
    case 2: // TAG
      switch(value) {
      case "caption":
      case "col":
      case "colgroup":
      case "tbody":
      case "td":
      case "tfoot":
      case "th":
      case "thead":
      case "tr":
        if (stack.inTableScope("td")) {
          in_cell_mode(ENDTAG, "td");
          parser(t, value, arg3, arg4);
        }
        else if (stack.inTableScope("th")) {
          in_cell_mode(ENDTAG, "th");
          parser(t, value, arg3, arg4);
        }
        return;
      }
      break;
    case 3: // ENDTAG
      switch(value) {
      case "td":
      case "th":
        if (!stack.inTableScope(value)) return;
        stack.generateImpliedEndTags();
        stack.popTag(value);
        afe.clearToMarker();
        parser = in_row_mode;
        return;

      case "body":
      case "caption":
      case "col":
      case "colgroup":
      case "html":
        return;

      case "table":
      case "tbody":
      case "tfoot":
      case "thead":
      case "tr":
        if (!stack.inTableScope(value)) return;
        in_cell_mode(ENDTAG, stack.inTableScope("td") ? "td" : "th");
        parser(t, value, arg3, arg4);
        return;
      }
      break;
    }

    // anything else
    in_body_mode(t, value, arg3, arg4);
  }

  function in_select_mode(t, value, arg3, arg4) {
    switch(t) {
    case 1: // TEXT
      if (textIncludesNUL) {
        value = value.replace(NULCHARS, "");
        if (value.length === 0) return;
      }
      insertText(value);
      return;
    case 4: // COMMENT
      insertComment(value);
      return;
    case 5: // DOCTYPE
      return;
    case -1: // EOF
      in_body_mode(t, value, arg3, arg4);
      return;
    case 2: // TAG
      switch(value) {
      case "html":
        in_body_mode(t, value, arg3, arg4);
        return;
      case "option":
        if (stack.top instanceof impl.HTMLOptionElement)
          in_select_mode(ENDTAG, value);
        insertHTMLElement(value, arg3);
        return;
      case "optgroup":
        if (stack.top instanceof impl.HTMLOptionElement)
          in_select_mode(ENDTAG, "option");
        if (stack.top instanceof impl.HTMLOptGroupElement)
          in_select_mode(ENDTAG, value);
        insertHTMLElement(value, arg3);
        return;
      case "select":
        in_select_mode(ENDTAG, value); // treat it as a close tag
        return;

      case "input":
      case "keygen":
      case "textarea":
        if (!stack.inSelectScope("select")) return;
        in_select_mode(ENDTAG, "select");
        parser(t, value, arg3, arg4);
        return;

      case "script":
      case "template":
        in_head_mode(t, value, arg3, arg4);
        return;
      }
      break;
    case 3: // ENDTAG
      switch(value) {
      case "optgroup":
        if (stack.top instanceof impl.HTMLOptionElement &&
          stack.elements[stack.elements.length-2] instanceof
          impl.HTMLOptGroupElement) {
          in_select_mode(ENDTAG, "option");
        }
        if (stack.top instanceof impl.HTMLOptGroupElement)
          stack.pop();

        return;

      case "option":
        if (stack.top instanceof impl.HTMLOptionElement)
          stack.pop();
        return;

      case "select":
        if (!stack.inSelectScope(value)) return;
        stack.popTag(value);
        resetInsertionMode();
        return;

      case "template":
        in_head_mode(t, value, arg3, arg4);
        return;
      }

      break;
    }

    // anything else: just ignore the token
  }

  function in_select_in_table_mode(t, value, arg3, arg4) {
    switch(value) {
    case "caption":
    case "table":
    case "tbody":
    case "tfoot":
    case "thead":
    case "tr":
    case "td":
    case "th":
      switch(t) {
      case 2: // TAG
        in_select_in_table_mode(ENDTAG, "select");
        parser(t, value, arg3, arg4);
        return;
      case 3: // ENDTAG
        if (stack.inTableScope(value)) {
          in_select_in_table_mode(ENDTAG, "select");
          parser(t, value, arg3, arg4);
        }
        return;
      }
    }

    // anything else
    in_select_mode(t, value, arg3, arg4);
  }

  function in_template_mode(t, value, arg3, arg4) {
    function switchModeAndReprocess(mode) {
      parser = mode;
      templateInsertionModes[templateInsertionModes.length-1] = parser;
      parser(t, value, arg3, arg4);
    }
    switch(t) {
    case 1: // TEXT
    case 4: // COMMENT
    case 5: // DOCTYPE
      in_body_mode(t, value, arg3, arg4);
      return;
    case -1: // EOF
      if (!stack.contains("template")) {
        stopParsing();
      } else {
        stack.popTag("template");
        afe.clearToMarker();
        templateInsertionModes.pop();
        resetInsertionMode();
        parser(t, value, arg3, arg4);
      }
      return;
    case 2: // TAG
      switch(value) {
      case "base":
      case "basefont":
      case "bgsound":
      case "link":
      case "meta":
      case "noframes":
      case "script":
      case "style":
      case "template":
      case "title":
        in_head_mode(t, value, arg3, arg4);
        return;
      case "caption":
      case "colgroup":
      case "tbody":
      case "tfoot":
      case "thead":
        switchModeAndReprocess(in_table_mode);
        return;
      case "col":
        switchModeAndReprocess(in_column_group_mode);
        return;
      case "tr":
        switchModeAndReprocess(in_table_body_mode);
        return;
      case "td":
      case "th":
        switchModeAndReprocess(in_row_mode);
        return;
      }
      switchModeAndReprocess(in_body_mode);
      return;
    case 3: // ENDTAG
      switch(value) {
      case "template":
        in_head_mode(t, value, arg3, arg4);
        return;
      default:
        return;
      }
    }
  }

  function after_body_mode(t, value, arg3, arg4) {
    switch(t) {
    case 1: // TEXT
      // If any non-space chars, handle below
      if (NONWS.test(value)) break;
      in_body_mode(t, value);
      return;
    case 4: // COMMENT
      // Append it to the <html> element
      stack.elements[0]._appendChild(doc.createComment(value));
      return;
    case 5: // DOCTYPE
      return;
    case -1: // EOF
      stopParsing();
      return;
    case 2: // TAG
      if (value === "html") {
        in_body_mode(t, value, arg3, arg4);
        return;
      }
      break; // for any other tags
    case 3: // ENDTAG
      if (value === "html") {
        if (fragment) return;
        parser = after_after_body_mode;
        return;
      }
      break; // for any other tags
    }

    // anything else
    parser = in_body_mode;
    parser(t, value, arg3, arg4);
  }

  function in_frameset_mode(t, value, arg3, arg4) {
    switch(t) {
    case 1: // TEXT
      // Ignore any non-space characters
      value = value.replace(ALLNONWS, "");
      if (value.length > 0) insertText(value);
      return;
    case 4: // COMMENT
      insertComment(value);
      return;
    case 5: // DOCTYPE
      return;
    case -1: // EOF
      stopParsing();
      return;
    case 2: // TAG
      switch(value) {
      case "html":
        in_body_mode(t, value, arg3, arg4);
        return;
      case "frameset":
        insertHTMLElement(value, arg3);
        return;
      case "frame":
        insertHTMLElement(value, arg3);
        stack.pop();
        return;
      case "noframes":
        in_head_mode(t, value, arg3, arg4);
        return;
      }
      break;
    case 3: // ENDTAG
      if (value === "frameset") {
        if (fragment && stack.top instanceof impl.HTMLHtmlElement)
          return;
        stack.pop();
        if (!fragment &&
          !(stack.top instanceof impl.HTMLFrameSetElement))
          parser = after_frameset_mode;
        return;
      }
      break;
    }

    // ignore anything else
  }

  function after_frameset_mode(t, value, arg3, arg4) {
    switch(t) {
    case 1: // TEXT
      // Ignore any non-space characters
      value = value.replace(ALLNONWS, "");
      if (value.length > 0) insertText(value);
      return;
    case 4: // COMMENT
      insertComment(value);
      return;
    case 5: // DOCTYPE
      return;
    case -1: // EOF
      stopParsing();
      return;
    case 2: // TAG
      switch(value) {
      case "html":
        in_body_mode(t, value, arg3, arg4);
        return;
      case "noframes":
        in_head_mode(t, value, arg3, arg4);
        return;
      }
      break;
    case 3: // ENDTAG
      if (value === "html") {
        parser = after_after_frameset_mode;
        return;
      }
      break;
    }

    // ignore anything else
  }

  function after_after_body_mode(t, value, arg3, arg4) {
    switch(t) {
    case 1: // TEXT
      // If any non-space chars, handle below
      if (NONWS.test(value)) break;
      in_body_mode(t, value, arg3, arg4);
      return;
    case 4: // COMMENT
      doc._appendChild(doc.createComment(value));
      return;
    case 5: // DOCTYPE
      in_body_mode(t, value, arg3, arg4);
      return;
    case -1: // EOF
      stopParsing();
      return;
    case 2: // TAG
      if (value === "html") {
        in_body_mode(t, value, arg3, arg4);
        return;
      }
      break;
    }

    // anything else
    parser = in_body_mode;
    parser(t, value, arg3, arg4);
  }

  function after_after_frameset_mode(t, value, arg3, arg4) {
    switch(t) {
    case 1: // TEXT
      // Ignore any non-space characters
      value = value.replace(ALLNONWS, "");
      if (value.length > 0)
        in_body_mode(t, value, arg3, arg4);
      return;
    case 4: // COMMENT
      doc._appendChild(doc.createComment(value));
      return;
    case 5: // DOCTYPE
      in_body_mode(t, value, arg3, arg4);
      return;
    case -1: // EOF
      stopParsing();
      return;
    case 2: // TAG
      switch(value) {
      case "html":
        in_body_mode(t, value, arg3, arg4);
        return;
      case "noframes":
        in_head_mode(t, value, arg3, arg4);
        return;
      }
      break;
    }

    // ignore anything else
  }


  // 13.2.5.5 The rules for parsing tokens in foreign content
  //
  // This is like one of the insertion modes above, but is
  // invoked somewhat differently when the current token is not HTML.
  // See the insertToken() function.
  function insertForeignToken(t, value, arg3, arg4) {
    // A <font> tag is an HTML font tag if it has a color, font, or size
    // attribute.  Otherwise we assume it is foreign content
    function isHTMLFont(attrs) {
      for(var i = 0, n = attrs.length; i < n; i++) {
        switch(attrs[i][0]) {
        case "color":
        case "face":
        case "size":
          return true;
        }
      }
      return false;
    }

    var current;

    switch(t) {
    case 1: // TEXT
      // If any non-space, non-nul characters
      if (frameset_ok && NONWSNONNUL.test(value))
        frameset_ok = false;
      if (textIncludesNUL) {
        value = value.replace(NULCHARS, "\uFFFD");
      }
      insertText(value);
      return;
    case 4: // COMMENT
      insertComment(value);
      return;
    case 5: // DOCTYPE
      // ignore it
      return;
    case 2: // TAG
      switch(value) {
      case "font":
        if (!isHTMLFont(arg3)) break;
        /* falls through */
      case "b":
      case "big":
      case "blockquote":
      case "body":
      case "br":
      case "center":
      case "code":
      case "dd":
      case "div":
      case "dl":
      case "dt":
      case "em":
      case "embed":
      case "h1":
      case "h2":
      case "h3":
      case "h4":
      case "h5":
      case "h6":
      case "head":
      case "hr":
      case "i":
      case "img":
      case "li":
      case "listing":
      case "menu":
      case "meta":
      case "nobr":
      case "ol":
      case "p":
      case "pre":
      case "ruby":
      case "s":
      case "small":
      case "span":
      case "strong":
      case "strike":
      case "sub":
      case "sup":
      case "table":
      case "tt":
      case "u":
      case "ul":
      case "var":
        if (fragment) {
          break;
        }
        do {
          stack.pop();
          current = stack.top;
        } while(current.namespaceURI !== NAMESPACE.HTML &&
            !isMathmlTextIntegrationPoint(current) &&
            !isHTMLIntegrationPoint(current));

        insertToken(t, value, arg3, arg4);  // reprocess
        return;
      }

      // Any other start tag case goes here
      current = (stack.elements.length===1 && fragment) ? fragmentContext :
        stack.top;
      if (current.namespaceURI === NAMESPACE.MATHML) {
        adjustMathMLAttributes(arg3);
      }
      else if (current.namespaceURI === NAMESPACE.SVG) {
        value = adjustSVGTagName(value);
        adjustSVGAttributes(arg3);
      }
      adjustForeignAttributes(arg3);

      insertForeignElement(value, arg3, current.namespaceURI);
      if (arg4) { // the self-closing flag
        if (value === 'script' && current.namespaceURI === NAMESPACE.SVG) {
          // XXX deal with SVG scripts here
        }
        stack.pop();
      }
      return;

    case 3: // ENDTAG
      current = stack.top;
      if (value === "script" &&
        current.namespaceURI === NAMESPACE.SVG &&
        current.localName === "script") {

        stack.pop();

        // XXX
        // Deal with SVG scripts here
      }
      else {
        // The any other end tag case
        var i = stack.elements.length-1;
        var node = stack.elements[i];
        for(;;) {
          if (node.localName.toLowerCase() === value) {
            stack.popElement(node);
            break;
          }
          node = stack.elements[--i];
          // If non-html, keep looping
          if (node.namespaceURI !== NAMESPACE.HTML)
            continue;
          // Otherwise process the end tag as html
          parser(t, value, arg3, arg4);
          break;
        }
      }
      return;
    }
  }

  /***
   * Finally, this is the end of the HTMLParser() factory function.
   * It returns the htmlparser object with the append() and end() methods.
   */

  // Sneak another method into the htmlparser object to allow us to run
  // tokenizer tests.  This can be commented out in production code.
  // This is a hook for testing the tokenizer. It has to be here
  // because the tokenizer details are all hidden away within the closure.
  // It should return an array of tokens generated while parsing the
  // input string.
  htmlparser.testTokenizer = function(input, initialState, lastStartTag, charbychar) {
    var tokens = [];

    switch(initialState) {
    case "PCDATA state":
      tokenizer = data_state;
      break;
    case "RCDATA state":
      tokenizer = rcdata_state;
      break;
    case "RAWTEXT state":
      tokenizer = rawtext_state;
      break;
    case "PLAINTEXT state":
      tokenizer = plaintext_state;
      break;
    }

    if (lastStartTag) {
      lasttagname = lastStartTag;
    }

    insertToken = function(t, value, arg3, arg4) {
      flushText();
      switch(t) {
      case 1: // TEXT
        if (tokens.length > 0 &&
          tokens[tokens.length-1][0] === "Character") {
          tokens[tokens.length-1][1] += value;
        }
        else tokens.push(["Character", value]);
        break;
      case 4: // COMMENT
        tokens.push(["Comment", value]);
        break;
      case 5: // DOCTYPE
        tokens.push(["DOCTYPE", value,
               arg3 === undefined ? null : arg3,
               arg4 === undefined ? null : arg4,
               !force_quirks]);
        break;
      case 2: // TAG
        var attrs = Object.create(null);
        for(var i = 0; i < arg3.length; i++) {
          // XXX: does attribute order matter?
          var a = arg3[i];
          if (a.length === 1) {
            attrs[a[0]] = "";
          }
          else {
            attrs[a[0]] = a[1];
          }
        }
        var token = ["StartTag", value, attrs];
        if (arg4) token.push(true);
        tokens.push(token);
        break;
      case 3: // ENDTAG
        tokens.push(["EndTag", value]);
        break;
      case -1: // EOF
        break;
      }
    };

    if (!charbychar) {
      this.parse(input, true);
    }
    else {
      for(var i = 0; i < input.length; i++) {
        this.parse(input[i]);
      }
      this.parse("", true);
    }
    return tokens;
  };

  // Return the parser object from the HTMLParser() factory function
  return htmlparser;
}


/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(2))(381);

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(1);
var core_1 = __webpack_require__(0);
var http_1 = __webpack_require__(11);
var http_2 = __webpack_require__(37);
var Observable_1 = __webpack_require__(7);
var Subject_1 = __webpack_require__(39);
var core_2 = __webpack_require__(0);
var common_1 = __webpack_require__(5);
var utility_service_1 = __webpack_require__(18);
var data_service_options_1 = __webpack_require__(113);
var DataService = /** @class */ (function () {
    function DataService(http, us, platformId) {
        this.http = http;
        this.us = us;
        this.platformId = platformId;
        // Define the internal Subject we'll use to push the command count
        this.pendingCommandsSubject = new Subject_1.Subject();
        this.pendingCommandCount = 0;
        this.pendingCommands$ = this.pendingCommandsSubject.asObservable();
    }
    // I perform a GET request to the API, appending the given params
    // as URL search parameters. Returns a stream.
    DataService.prototype.get = function (url, params) {
        var options = new data_service_options_1.DataServiceOptions();
        options.method = http_2.RequestMethod.Get;
        options.url = url;
        options.params = params;
        return this.request(options);
    };
    // I perform a POST request to the API. If both the params and data
    // are present, the params will be appended as URL search parameters
    // and the data will be serialized as a JSON payload. If only the
    // data is present, it will be serialized as a JSON payload. Returns
    // a stream.
    DataService.prototype.post = function (url, data, params) {
        if (!data) {
            data = params;
            params = {};
        }
        var options = new data_service_options_1.DataServiceOptions();
        options.method = http_2.RequestMethod.Post;
        options.url = url;
        options.params = params;
        options.data = data;
        return this.request(options);
    };
    DataService.prototype.put = function (url, data, params) {
        if (!data) {
            data = params;
            params = {};
        }
        var options = new data_service_options_1.DataServiceOptions();
        options.method = http_2.RequestMethod.Put;
        options.url = url;
        options.params = params;
        options.data = data;
        return this.request(options);
    };
    DataService.prototype.delete = function (url) {
        var options = new data_service_options_1.DataServiceOptions();
        options.method = http_2.RequestMethod.Delete;
        options.url = url;
        return this.request(options);
    };
    DataService.prototype.request = function (options) {
        var _this = this;
        options.method = (options.method || http_2.RequestMethod.Get);
        options.url = (options.url || '');
        options.headers = (options.headers || {});
        options.params = (options.params || {});
        options.data = (options.data || {});
        this.interpolateUrl(options);
        this.addContentType(options);
        // Client only code.
        // because it uses global window/documents stuff
        if (common_1.isPlatformBrowser(this.platformId)) {
            this.addXsrfToken(options);
            this.addAuthToken(options);
        }
        var requestOptions = {
            method: options.method,
            url: options.url,
            headers: options.headers,
            search: this.buildUrlSearchParams(options.params),
            body: JSON.stringify(options.data)
        };
        this.pendingCommandsSubject.next(++this.pendingCommandCount);
        var stream = this.http.request(this.toMethodString(options.method), options.url, requestOptions)
            .catch(function (error) {
            _this.handleErrors(error);
            return Observable_1.Observable.throw(error);
        })
            .catch(function (error) {
            return Observable_1.Observable.throw(error);
        })
            .finally(function () {
            _this.pendingCommandsSubject.next(--_this.pendingCommandCount);
        });
        return stream;
    };
    DataService.prototype.addContentType = function (options) {
        // if (options.method !== RequestMethod.Get) {
        options.headers['Content-Type'] = 'application/json; charset=UTF-8';
        // }
        return options;
    };
    DataService.prototype.addAuthToken = function (options) {
        var authTokenString = localStorage.getItem('auth-token');
        if (authTokenString) {
            var authTokenModel = JSON.parse(authTokenString);
            // tslint:disable-next-line:whitespace
            options.headers.Authorization = 'Bearer ' + authTokenModel.access_token;
        }
        return options;
    };
    DataService.prototype.extractValue = function (collection, key) {
        var value = collection[key];
        delete (collection[key]);
        return value;
    };
    DataService.prototype.addXsrfToken = function (options) {
        var xsrfToken = this.getXsrfCookie();
        if (xsrfToken) {
            options.headers['X-XSRF-TOKEN'] = xsrfToken;
        }
        return options;
    };
    DataService.prototype.getXsrfCookie = function () {
        var matches = document.cookie.match(/\bXSRF-TOKEN=([^\s;]+)/);
        try {
            return matches ? decodeURIComponent(matches[1]) : '';
        }
        catch (decodeError) {
            return '';
        }
    };
    // private addCors(options: DataServiceOptions): DataServiceOptions {
    //     options.headers['Access-Control-Allow-Origin'] = '*';
    //     return options;
    // }
    DataService.prototype.buildUrlSearchParams = function (params) {
        var searchParams = new http_2.URLSearchParams();
        for (var key in params) {
            if (params.hasOwnProperty(key)) {
                searchParams.append(key, params[key]);
            }
        }
        return searchParams;
    };
    DataService.prototype.interpolateUrl = function (options) {
        var _this = this;
        options.url = options.url.replace(/:([a-zA-Z]+[\w-]*)/g, function ($0, token) {
            // Try to move matching token from the params collection.
            if (options.params.hasOwnProperty(token)) {
                return (_this.extractValue(options.params, token));
            }
            // Try to move matching token from the data collection.
            if (options.data.hasOwnProperty(token)) {
                return (_this.extractValue(options.data, token));
            }
            // If a matching value couldn't be found, just replace
            // the token with the empty string.
            return ('');
        });
        // Clean up any repeating slashes.
        options.url = options.url.replace(/\/{2,}/g, '/');
        // Clean up any trailing slashes.
        options.url = options.url.replace(/\/+$/g, '');
        return options;
    };
    // private unwrapHttpError(error: any): any {
    //     try {
    //         return (error.json());
    //     } catch (jsonError) {
    //         return ({
    //             code: -1,
    //             message: 'An unexpected error occurred.'
    //         });
    //     }
    // }
    DataService.prototype.handleErrors = function (error) {
        if (error.status === 401) {
            sessionStorage.clear();
            this.us.navigateToSignIn();
        }
        else if (error.status === 403) {
            // Forbidden
            this.us.navigateToSignIn();
        }
    };
    DataService.prototype.toMethodString = function (method) {
        switch (method) {
            case http_2.RequestMethod.Get:
                return 'GET';
            case http_2.RequestMethod.Post:
                return 'POST';
            case http_2.RequestMethod.Put:
                return 'PUT';
            case http_2.RequestMethod.Delete:
                return 'DELETE';
            case http_2.RequestMethod.Patch:
                return 'PATCH';
            default:
                return 'GET';
        }
    };
    DataService = tslib_1.__decorate([
        core_1.Injectable(),
        tslib_1.__param(2, core_2.Inject(core_2.PLATFORM_ID)),
        tslib_1.__metadata("design:paramtypes", [http_1.HttpClient, utility_service_1.UtilityService, Object])
    ], DataService);
    return DataService;
}());
exports.DataService = DataService;


/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var ControlBase = /** @class */ (function () {
    function ControlBase(options) {
        if (options === void 0) { options = {}; }
        this.value = options.value;
        this.key = options.key || '';
        this.label = options.label || '';
        this.placeholder = options.placeholder || '';
        this.required = !!options.required;
        this.minlength = options.minlength;
        this.maxlength = options.maxlength;
        this.order = options.order === undefined ? 1 : options.order;
        this.type = options.type || '';
        this.class = options.class || '';
    }
    return ControlBase;
}());
exports.ControlBase = ControlBase;


/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(1);
var core_1 = __webpack_require__(0);
var http_1 = __webpack_require__(11);
var utility_service_1 = __webpack_require__(18);
var Observable_1 = __webpack_require__(7);
var angular2_jwt_1 = __webpack_require__(104);
var AccountService = /** @class */ (function () {
    function AccountService(http, utilityService) {
        this.http = http;
        this.utilityService = utilityService;
        this.tokenKey = 'auth-token';
        this.jwtHelper = new angular2_jwt_1.JwtHelper();
    }
    Object.defineProperty(AccountService.prototype, "isLoggedIn", {
        get: function () {
            if (this.accessToken) {
                return !this.jwtHelper.isTokenExpired(this.accessToken);
            }
            return false;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AccountService.prototype, "user", {
        get: function () {
            if (this.accessToken) {
                return this.jwtHelper.decodeToken(this.accessToken);
            }
            return undefined;
        },
        enumerable: true,
        configurable: true
    });
    AccountService.prototype.login = function (user) {
        var _this = this;
        // data can be any since it can either be a refresh tokens or login details
        // The request for tokens must be x-www-form-urlencoded
        var headers = new http_1.HttpHeaders({ 'Content-Type': 'application/x-www-form-urlencoded' });
        var options = { headers: headers };
        Object.assign(user, {
            grant_type: 'password',
            // offline_access is required for a refresh token
            scope: ['openid offline_access client_id profile email roles']
        });
        return this.http.post('/connect/token', this.encodeObjectToParams(user), options)
            .map(function (tokens) {
            var now = new Date();
            tokens.expiration_date = new Date(now.getTime() + (tokens.expires_in ? (tokens.expires_in * 1000) : 0)).getTime().toString();
            // const profile = this.jwtHelper.decodeToken(tokens.id_token ? tokens.id_token : '') as ProfileModel;
            localStorage.setItem(_this.tokenKey, JSON.stringify(tokens));
        });
    };
    AccountService.prototype.register = function (data) {
        return this.http.post('api/account/register', data)
            .catch(function (res) { return Observable_1.Observable.throw(res.json()); });
    };
    AccountService.prototype.logout = function () {
        localStorage.removeItem(this.tokenKey);
        this.utilityService.navigateToSignIn();
    };
    AccountService.prototype.encodeObjectToParams = function (obj) {
        return Object.keys(obj)
            .map(function (key) { return encodeURIComponent(key) + '=' + encodeURIComponent(obj[key]); })
            .join('&');
    };
    Object.defineProperty(AccountService.prototype, "accessToken", {
        get: function () {
            var token = '';
            var ticket = localStorage.getItem(this.tokenKey);
            if (ticket) {
                token = JSON.parse(ticket).id_token;
            }
            return token;
        },
        enumerable: true,
        configurable: true
    });
    AccountService = tslib_1.__decorate([
        core_1.Injectable(),
        tslib_1.__metadata("design:paramtypes", [http_1.HttpClient, utility_service_1.UtilityService])
    ], AccountService);
    return AccountService;
}());
exports.AccountService = AccountService;


/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * @license Angular v5.0.0-beta.7
 * (c) 2010-2017 Google, Inc. https://angular.io/
 * License: MIT
 */
(function (global, factory) {
	 true ? factory(exports, __webpack_require__(0), __webpack_require__(6), __webpack_require__(35), __webpack_require__(5), __webpack_require__(11), __webpack_require__(37), __webpack_require__(73), __webpack_require__(38), __webpack_require__(7), __webpack_require__(39), __webpack_require__(40), __webpack_require__(74), __webpack_require__(36), __webpack_require__(75), __webpack_require__(76)) :
	typeof define === 'function' && define.amd ? define(['exports', '@angular/core', '@angular/platform-browser', '@angular/animations/browser', '@angular/common', '@angular/common/http', '@angular/http', '@angular/platform-browser-dynamic', '@angular/platform-browser/animations', 'rxjs/Observable', 'rxjs/Subject', 'url', '@angular/compiler', 'rxjs/operator/filter', 'rxjs/operator/first', 'rxjs/operator/toPromise'], factory) :
	(factory((global.ng = global.ng || {}, global.ng.platformServer = {}),global.ng.core,global.ng.platformBrowser,global._angular_animations_browser,global.ng.common,global._angular_common_http,global._angular_http,global._angular_platformBrowserDynamic,global._angular_platformBrowser_animations,global.Rx,global.Rx,global.url,global.ng.compiler,global.Rx.Observable.prototype,global.Rx.Observable.prototype,global.Rx.Observable.prototype));
}(this, (function (exports,_angular_core,_angular_platformBrowser,_angular_animations_browser,_angular_common,_angular_common_http,_angular_http,_angular_platformBrowserDynamic,_angular_platformBrowser_animations,rxjs_Observable,rxjs_Subject,url,_angular_compiler,rxjs_operator_filter,rxjs_operator_first,rxjs_operator_toPromise) { 'use strict';

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = Object.setPrototypeOf ||
    ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
    function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

/**
 * @license Angular v5.0.0-beta.7
 * (c) 2010-2017 Google, Inc. https://angular.io/
 * License: MIT
 */
/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var domino = __webpack_require__(77);
/**
 * @param {?} methodName
 * @return {?}
 */
function _notImplemented(methodName) {
    return new Error('This method is not implemented in DominoAdapter: ' + methodName);
}
/**
 * Parses a document string to a Document object.
 * @param {?} html
 * @param {?=} url
 * @return {?}
 */
function parseDocument(html, url$$1) {
    if (url$$1 === void 0) { url$$1 = '/'; }
    var /** @type {?} */ window = domino.createWindow(html, url$$1);
    var /** @type {?} */ doc = window.document;
    return doc;
}
/**
 * Serializes a document to string.
 * @param {?} doc
 * @return {?}
 */
function serializeDocument(doc) {
    return (/** @type {?} */ (doc)).serialize();
}
/**
 * DOM Adapter for the server platform based on https://github.com/fgnass/domino.
 */
var DominoAdapter = (function (_super) {
    __extends(DominoAdapter, _super);
    function DominoAdapter() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * @return {?}
     */
    DominoAdapter.makeCurrent = /**
     * @return {?}
     */
    function () { _angular_platformBrowser.ɵsetRootDomAdapter(new DominoAdapter()); };
    /**
     * @param {?} error
     * @return {?}
     */
    DominoAdapter.prototype.logError = /**
     * @param {?} error
     * @return {?}
     */
    function (error) { console.error(error); };
    // tslint:disable-next-line:no-console
    /**
     * @param {?} error
     * @return {?}
     */
    DominoAdapter.prototype.log = /**
     * @param {?} error
     * @return {?}
     */
    function (error) { console.log(error); };
    /**
     * @param {?} error
     * @return {?}
     */
    DominoAdapter.prototype.logGroup = /**
     * @param {?} error
     * @return {?}
     */
    function (error) { console.error(error); };
    /**
     * @return {?}
     */
    DominoAdapter.prototype.logGroupEnd = /**
     * @return {?}
     */
    function () { };
    /**
     * @return {?}
     */
    DominoAdapter.prototype.supportsDOMEvents = /**
     * @return {?}
     */
    function () { return false; };
    /**
     * @return {?}
     */
    DominoAdapter.prototype.supportsNativeShadowDOM = /**
     * @return {?}
     */
    function () { return false; };
    /**
     * @param {?} nodeA
     * @param {?} nodeB
     * @return {?}
     */
    DominoAdapter.prototype.contains = /**
     * @param {?} nodeA
     * @param {?} nodeB
     * @return {?}
     */
    function (nodeA, nodeB) {
        var /** @type {?} */ inner = nodeB;
        while (inner) {
            if (inner === nodeA)
                return true;
            inner = inner.parent;
        }
        return false;
    };
    /**
     * @return {?}
     */
    DominoAdapter.prototype.createHtmlDocument = /**
     * @return {?}
     */
    function () {
        return parseDocument('<html><head><title>fakeTitle</title></head><body></body></html>');
    };
    /**
     * @return {?}
     */
    DominoAdapter.prototype.getDefaultDocument = /**
     * @return {?}
     */
    function () {
        if (!DominoAdapter.defaultDoc) {
            DominoAdapter.defaultDoc = domino.createDocument();
        }
        return DominoAdapter.defaultDoc;
    };
    /**
     * @param {?} el
     * @param {?=} doc
     * @return {?}
     */
    DominoAdapter.prototype.createShadowRoot = /**
     * @param {?} el
     * @param {?=} doc
     * @return {?}
     */
    function (el, doc) {
        if (doc === void 0) { doc = document; }
        el.shadowRoot = doc.createDocumentFragment();
        el.shadowRoot.parent = el;
        return el.shadowRoot;
    };
    /**
     * @param {?} el
     * @return {?}
     */
    DominoAdapter.prototype.getShadowRoot = /**
     * @param {?} el
     * @return {?}
     */
    function (el) { return el.shadowRoot; };
    /**
     * @param {?} node
     * @return {?}
     */
    DominoAdapter.prototype.isTextNode = /**
     * @param {?} node
     * @return {?}
     */
    function (node) { return node.nodeType === DominoAdapter.defaultDoc.TEXT_NODE; };
    /**
     * @param {?} node
     * @return {?}
     */
    DominoAdapter.prototype.isCommentNode = /**
     * @param {?} node
     * @return {?}
     */
    function (node) {
        return node.nodeType === DominoAdapter.defaultDoc.COMMENT_NODE;
    };
    /**
     * @param {?} node
     * @return {?}
     */
    DominoAdapter.prototype.isElementNode = /**
     * @param {?} node
     * @return {?}
     */
    function (node) {
        return node ? node.nodeType === DominoAdapter.defaultDoc.ELEMENT_NODE : false;
    };
    /**
     * @param {?} node
     * @return {?}
     */
    DominoAdapter.prototype.hasShadowRoot = /**
     * @param {?} node
     * @return {?}
     */
    function (node) { return node.shadowRoot != null; };
    /**
     * @param {?} node
     * @return {?}
     */
    DominoAdapter.prototype.isShadowRoot = /**
     * @param {?} node
     * @return {?}
     */
    function (node) { return this.getShadowRoot(node) == node; };
    /**
     * @param {?} el
     * @param {?} name
     * @return {?}
     */
    DominoAdapter.prototype.getProperty = /**
     * @param {?} el
     * @param {?} name
     * @return {?}
     */
    function (el, name) {
        if (name === 'href') {
            // Domino tries tp resolve href-s which we do not want. Just return the
            // atribute value.
            return this.getAttribute(el, 'href');
        }
        else if (name === 'innerText') {
            // Domino does not support innerText. Just map it to textContent.
            return el.textContent;
        }
        return (/** @type {?} */ (el))[name];
    };
    /**
     * @param {?} el
     * @param {?} name
     * @param {?} value
     * @return {?}
     */
    DominoAdapter.prototype.setProperty = /**
     * @param {?} el
     * @param {?} name
     * @param {?} value
     * @return {?}
     */
    function (el, name, value) {
        if (name === 'href') {
            // Eventhough the server renderer reflects any properties to attributes
            // map 'href' to atribute just to handle when setProperty is directly called.
            this.setAttribute(el, 'href', value);
        }
        else if (name === 'innerText') {
            // Domino does not support innerText. Just map it to textContent.
            el.textContent = value;
        }
        (/** @type {?} */ (el))[name] = value;
    };
    /**
     * @param {?} doc
     * @param {?} target
     * @return {?}
     */
    DominoAdapter.prototype.getGlobalEventTarget = /**
     * @param {?} doc
     * @param {?} target
     * @return {?}
     */
    function (doc, target) {
        if (target === 'window') {
            return doc.defaultView;
        }
        if (target === 'document') {
            return doc;
        }
        if (target === 'body') {
            return doc.body;
        }
        return null;
    };
    /**
     * @param {?} doc
     * @return {?}
     */
    DominoAdapter.prototype.getBaseHref = /**
     * @param {?} doc
     * @return {?}
     */
    function (doc) {
        var /** @type {?} */ base = this.querySelector(doc.documentElement, 'base');
        var /** @type {?} */ href = '';
        if (base) {
            href = this.getHref(base);
        }
        // TODO(alxhub): Need relative path logic from BrowserDomAdapter here?
        return href;
    };
    /** @internal */
    /**
     * \@internal
     * @param {?} element
     * @return {?}
     */
    DominoAdapter.prototype._readStyleAttribute = /**
     * \@internal
     * @param {?} element
     * @return {?}
     */
    function (element) {
        var /** @type {?} */ styleMap = {};
        var /** @type {?} */ styleAttribute = element.getAttribute('style');
        if (styleAttribute) {
            var /** @type {?} */ styleList = styleAttribute.split(/;+/g);
            for (var /** @type {?} */ i = 0; i < styleList.length; i++) {
                if (styleList[i].length > 0) {
                    var /** @type {?} */ style = /** @type {?} */ (styleList[i]);
                    var /** @type {?} */ colon = style.indexOf(':');
                    if (colon === -1) {
                        throw new Error("Invalid CSS style: " + style);
                    }
                    (/** @type {?} */ (styleMap))[style.substr(0, colon).trim()] = style.substr(colon + 1).trim();
                }
            }
        }
        return styleMap;
    };
    /** @internal */
    /**
     * \@internal
     * @param {?} element
     * @param {?} styleMap
     * @return {?}
     */
    DominoAdapter.prototype._writeStyleAttribute = /**
     * \@internal
     * @param {?} element
     * @param {?} styleMap
     * @return {?}
     */
    function (element, styleMap) {
        var /** @type {?} */ styleAttrValue = '';
        for (var /** @type {?} */ key in styleMap) {
            var /** @type {?} */ newValue = styleMap[key];
            if (newValue) {
                styleAttrValue += key + ':' + styleMap[key] + ';';
            }
        }
        element.setAttribute('style', styleAttrValue);
    };
    /**
     * @param {?} element
     * @param {?} styleName
     * @param {?=} styleValue
     * @return {?}
     */
    DominoAdapter.prototype.setStyle = /**
     * @param {?} element
     * @param {?} styleName
     * @param {?=} styleValue
     * @return {?}
     */
    function (element, styleName, styleValue) {
        var /** @type {?} */ styleMap = this._readStyleAttribute(element);
        (/** @type {?} */ (styleMap))[styleName] = styleValue;
        this._writeStyleAttribute(element, styleMap);
    };
    /**
     * @param {?} element
     * @param {?} styleName
     * @return {?}
     */
    DominoAdapter.prototype.removeStyle = /**
     * @param {?} element
     * @param {?} styleName
     * @return {?}
     */
    function (element, styleName) { this.setStyle(element, styleName, null); };
    /**
     * @param {?} element
     * @param {?} styleName
     * @return {?}
     */
    DominoAdapter.prototype.getStyle = /**
     * @param {?} element
     * @param {?} styleName
     * @return {?}
     */
    function (element, styleName) {
        var /** @type {?} */ styleMap = this._readStyleAttribute(element);
        return styleMap.hasOwnProperty(styleName) ? (/** @type {?} */ (styleMap))[styleName] : '';
    };
    /**
     * @param {?} element
     * @param {?} styleName
     * @param {?=} styleValue
     * @return {?}
     */
    DominoAdapter.prototype.hasStyle = /**
     * @param {?} element
     * @param {?} styleName
     * @param {?=} styleValue
     * @return {?}
     */
    function (element, styleName, styleValue) {
        var /** @type {?} */ value = this.getStyle(element, styleName) || '';
        return styleValue ? value == styleValue : value.length > 0;
    };
    /**
     * @param {?} el
     * @param {?} evt
     * @return {?}
     */
    DominoAdapter.prototype.dispatchEvent = /**
     * @param {?} el
     * @param {?} evt
     * @return {?}
     */
    function (el, evt) {
        el.dispatchEvent(evt);
        // Dispatch the event to the window also.
        var /** @type {?} */ doc = el.ownerDocument || el;
        var /** @type {?} */ win = (/** @type {?} */ (doc)).defaultView;
        if (win) {
            win.dispatchEvent(evt);
        }
    };
    /**
     * @return {?}
     */
    DominoAdapter.prototype.getHistory = /**
     * @return {?}
     */
    function () { throw _notImplemented('getHistory'); };
    /**
     * @return {?}
     */
    DominoAdapter.prototype.getLocation = /**
     * @return {?}
     */
    function () { throw _notImplemented('getLocation'); };
    /**
     * @return {?}
     */
    DominoAdapter.prototype.getUserAgent = /**
     * @return {?}
     */
    function () { return 'Fake user agent'; };
    /**
     * @return {?}
     */
    DominoAdapter.prototype.supportsWebAnimation = /**
     * @return {?}
     */
    function () { return false; };
    /**
     * @return {?}
     */
    DominoAdapter.prototype.performanceNow = /**
     * @return {?}
     */
    function () { return Date.now(); };
    /**
     * @return {?}
     */
    DominoAdapter.prototype.getAnimationPrefix = /**
     * @return {?}
     */
    function () { return ''; };
    /**
     * @return {?}
     */
    DominoAdapter.prototype.getTransitionEnd = /**
     * @return {?}
     */
    function () { return 'transitionend'; };
    /**
     * @return {?}
     */
    DominoAdapter.prototype.supportsAnimation = /**
     * @return {?}
     */
    function () { return true; };
    /**
     * @param {?} el
     * @return {?}
     */
    DominoAdapter.prototype.getDistributedNodes = /**
     * @param {?} el
     * @return {?}
     */
    function (el) { throw _notImplemented('getDistributedNodes'); };
    /**
     * @return {?}
     */
    DominoAdapter.prototype.supportsCookies = /**
     * @return {?}
     */
    function () { return false; };
    /**
     * @param {?} name
     * @return {?}
     */
    DominoAdapter.prototype.getCookie = /**
     * @param {?} name
     * @return {?}
     */
    function (name) { throw _notImplemented('getCookie'); };
    /**
     * @param {?} name
     * @param {?} value
     * @return {?}
     */
    DominoAdapter.prototype.setCookie = /**
     * @param {?} name
     * @param {?} value
     * @return {?}
     */
    function (name, value) { throw _notImplemented('setCookie'); };
    return DominoAdapter;
}(_angular_platformBrowser.ɵBrowserDomAdapter));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * Representation of the current platform state.
 *
 * \@experimental
 */
var PlatformState = (function () {
    function PlatformState(_doc) {
        this._doc = _doc;
    }
    /**
     * Renders the current state of the platform to string.
     */
    /**
     * Renders the current state of the platform to string.
     * @return {?}
     */
    PlatformState.prototype.renderToString = /**
     * Renders the current state of the platform to string.
     * @return {?}
     */
    function () { return serializeDocument(this._doc); };
    /**
     * Returns the current DOM state.
     */
    /**
     * Returns the current DOM state.
     * @return {?}
     */
    PlatformState.prototype.getDocument = /**
     * Returns the current DOM state.
     * @return {?}
     */
    function () { return this._doc; };
    PlatformState.decorators = [
        { type: _angular_core.Injectable },
    ];
    /** @nocollapse */
    PlatformState.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: _angular_core.Inject, args: [_angular_platformBrowser.DOCUMENT,] },] },
    ]; };
    return PlatformState;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var xhr2 = __webpack_require__(87);
var isAbsoluteUrl = /^[a-zA-Z\-\+.]+:\/\//;
/**
 * @param {?} url
 * @return {?}
 */
function validateRequestUrl(url$$1) {
    if (!isAbsoluteUrl.test(url$$1)) {
        throw new Error("URLs requested via Http on the server must be absolute. URL: " + url$$1);
    }
}
var ServerXhr = (function () {
    function ServerXhr() {
    }
    /**
     * @return {?}
     */
    ServerXhr.prototype.build = /**
     * @return {?}
     */
    function () { return new xhr2.XMLHttpRequest(); };
    ServerXhr.decorators = [
        { type: _angular_core.Injectable },
    ];
    /** @nocollapse */
    ServerXhr.ctorParameters = function () { return []; };
    return ServerXhr;
}());
var ServerXsrfStrategy = (function () {
    function ServerXsrfStrategy() {
    }
    /**
     * @param {?} req
     * @return {?}
     */
    ServerXsrfStrategy.prototype.configureRequest = /**
     * @param {?} req
     * @return {?}
     */
    function (req) { };
    ServerXsrfStrategy.decorators = [
        { type: _angular_core.Injectable },
    ];
    /** @nocollapse */
    ServerXsrfStrategy.ctorParameters = function () { return []; };
    return ServerXsrfStrategy;
}());
/**
 * @abstract
 */
var ZoneMacroTaskWrapper = (function () {
    function ZoneMacroTaskWrapper() {
    }
    /**
     * @param {?} request
     * @return {?}
     */
    ZoneMacroTaskWrapper.prototype.wrap = /**
     * @param {?} request
     * @return {?}
     */
    function (request) {
        var _this = this;
        return new rxjs_Observable.Observable(function (observer) {
            var /** @type {?} */ task = /** @type {?} */ ((null));
            var /** @type {?} */ scheduled = false;
            var /** @type {?} */ sub = null;
            var /** @type {?} */ savedResult = null;
            var /** @type {?} */ savedError = null;
            var /** @type {?} */ scheduleTask = function (_task) {
                task = _task;
                scheduled = true;
                var /** @type {?} */ delegate = _this.delegate(request);
                sub = delegate.subscribe(function (res) { return savedResult = res; }, function (err) {
                    if (!scheduled) {
                        throw new Error('An http observable was completed twice. This shouldn\'t happen, please file a bug.');
                    }
                    savedError = err;
                    scheduled = false;
                    task.invoke();
                }, function () {
                    if (!scheduled) {
                        throw new Error('An http observable was completed twice. This shouldn\'t happen, please file a bug.');
                    }
                    scheduled = false;
                    task.invoke();
                });
            };
            var /** @type {?} */ cancelTask = function (_task) {
                if (!scheduled) {
                    return;
                }
                scheduled = false;
                if (sub) {
                    sub.unsubscribe();
                    sub = null;
                }
            };
            var /** @type {?} */ onComplete = function () {
                if (savedError !== null) {
                    observer.error(savedError);
                }
                else {
                    observer.next(savedResult);
                    observer.complete();
                }
            };
            // MockBackend for Http is synchronous, which means that if scheduleTask is by
            // scheduleMacroTask, the request will hit MockBackend and the response will be
            // sent, causing task.invoke() to be called.
            var /** @type {?} */ _task = Zone.current.scheduleMacroTask('ZoneMacroTaskWrapper.subscribe', onComplete, {}, function () { return null; }, cancelTask);
            scheduleTask(_task);
            return function () {
                if (scheduled && task) {
                    task.zone.cancelTask(task);
                    scheduled = false;
                }
                if (sub) {
                    sub.unsubscribe();
                    sub = null;
                }
            };
        });
    };
    return ZoneMacroTaskWrapper;
}());
var ZoneMacroTaskConnection = (function (_super) {
    __extends(ZoneMacroTaskConnection, _super);
    function ZoneMacroTaskConnection(request, backend) {
        var _this = _super.call(this) || this;
        _this.request = request;
        _this.backend = backend;
        validateRequestUrl(request.url);
        _this.response = _this.wrap(request);
        return _this;
    }
    /**
     * @param {?} request
     * @return {?}
     */
    ZoneMacroTaskConnection.prototype.delegate = /**
     * @param {?} request
     * @return {?}
     */
    function (request) {
        this.lastConnection = this.backend.createConnection(request);
        return /** @type {?} */ (this.lastConnection.response);
    };
    Object.defineProperty(ZoneMacroTaskConnection.prototype, "readyState", {
        get: /**
         * @return {?}
         */
        function () {
            return !!this.lastConnection ? this.lastConnection.readyState : _angular_http.ReadyState.Unsent;
        },
        enumerable: true,
        configurable: true
    });
    return ZoneMacroTaskConnection;
}(ZoneMacroTaskWrapper));
var ZoneMacroTaskBackend = (function () {
    function ZoneMacroTaskBackend(backend) {
        this.backend = backend;
    }
    /**
     * @param {?} request
     * @return {?}
     */
    ZoneMacroTaskBackend.prototype.createConnection = /**
     * @param {?} request
     * @return {?}
     */
    function (request) {
        return new ZoneMacroTaskConnection(request, this.backend);
    };
    return ZoneMacroTaskBackend;
}());
var ZoneClientBackend = (function (_super) {
    __extends(ZoneClientBackend, _super);
    function ZoneClientBackend(backend) {
        var _this = _super.call(this) || this;
        _this.backend = backend;
        return _this;
    }
    /**
     * @param {?} request
     * @return {?}
     */
    ZoneClientBackend.prototype.handle = /**
     * @param {?} request
     * @return {?}
     */
    function (request) { return this.wrap(request); };
    /**
     * @param {?} request
     * @return {?}
     */
    ZoneClientBackend.prototype.delegate = /**
     * @param {?} request
     * @return {?}
     */
    function (request) {
        return this.backend.handle(request);
    };
    return ZoneClientBackend;
}(ZoneMacroTaskWrapper));
/**
 * @param {?} xhrBackend
 * @param {?} options
 * @return {?}
 */
function httpFactory(xhrBackend, options) {
    var /** @type {?} */ macroBackend = new ZoneMacroTaskBackend(xhrBackend);
    return new _angular_http.Http(macroBackend, options);
}
/**
 * @param {?} backend
 * @param {?} interceptors
 * @return {?}
 */
function zoneWrappedInterceptingHandler(backend, interceptors) {
    var /** @type {?} */ realBackend = _angular_common_http.ɵinterceptingHandler(backend, interceptors);
    return new ZoneClientBackend(realBackend);
}
var SERVER_HTTP_PROVIDERS = [
    { provide: _angular_http.Http, useFactory: httpFactory, deps: [_angular_http.XHRBackend, _angular_http.RequestOptions] },
    { provide: _angular_http.BrowserXhr, useClass: ServerXhr }, { provide: _angular_http.XSRFStrategy, useClass: ServerXsrfStrategy },
    { provide: _angular_common_http.XhrFactory, useClass: ServerXhr }, {
        provide: _angular_common_http.HttpHandler,
        useFactory: zoneWrappedInterceptingHandler,
        deps: [_angular_common_http.HttpBackend, [new _angular_core.Optional(), _angular_common_http.HTTP_INTERCEPTORS]]
    }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * Config object passed to initialize the platform.
 *
 * \@experimental
 * @record
 */

/**
 * The DI token for setting the initial config for the platform.
 *
 * \@experimental
 */
var INITIAL_CONFIG = new _angular_core.InjectionToken('Server.INITIAL_CONFIG');
/**
 * A function that will be executed when calling `renderModuleFactory` or `renderModule` just
 * before current platform state is rendered to string.
 *
 * \@experimental
 */
var BEFORE_APP_SERIALIZED = new _angular_core.InjectionToken('Server.RENDER_MODULE_HOOK');

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @param {?} urlStr
 * @return {?}
 */
function parseUrl(urlStr) {
    var /** @type {?} */ parsedUrl = url.parse(urlStr);
    return {
        pathname: parsedUrl.pathname || '',
        search: parsedUrl.search || '',
        hash: parsedUrl.hash || '',
    };
}
/**
 * Server-side implementation of URL state. Implements `pathname`, `search`, and `hash`
 * but not the state stack.
 */
var ServerPlatformLocation = (function () {
    function ServerPlatformLocation(_doc, _config) {
        this._doc = _doc;
        this._path = '/';
        this._search = '';
        this._hash = '';
        this._hashUpdate = new rxjs_Subject.Subject();
        var /** @type {?} */ config = /** @type {?} */ (_config);
        if (!!config && !!config.url) {
            var /** @type {?} */ parsedUrl = parseUrl(config.url);
            this._path = parsedUrl.pathname;
            this._search = parsedUrl.search;
            this._hash = parsedUrl.hash;
        }
    }
    /**
     * @return {?}
     */
    ServerPlatformLocation.prototype.getBaseHrefFromDOM = /**
     * @return {?}
     */
    function () { return /** @type {?} */ ((_angular_platformBrowser.ɵgetDOM().getBaseHref(this._doc))); };
    /**
     * @param {?} fn
     * @return {?}
     */
    ServerPlatformLocation.prototype.onPopState = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
        // No-op: a state stack is not implemented, so
        // no events will ever come.
    };
    /**
     * @param {?} fn
     * @return {?}
     */
    ServerPlatformLocation.prototype.onHashChange = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) { this._hashUpdate.subscribe(fn); };
    Object.defineProperty(ServerPlatformLocation.prototype, "pathname", {
        get: /**
         * @return {?}
         */
        function () { return this._path; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ServerPlatformLocation.prototype, "search", {
        get: /**
         * @return {?}
         */
        function () { return this._search; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ServerPlatformLocation.prototype, "hash", {
        get: /**
         * @return {?}
         */
        function () { return this._hash; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ServerPlatformLocation.prototype, "url", {
        get: /**
         * @return {?}
         */
        function () { return "" + this.pathname + this.search + this.hash; },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} value
     * @param {?} oldUrl
     * @return {?}
     */
    ServerPlatformLocation.prototype.setHash = /**
     * @param {?} value
     * @param {?} oldUrl
     * @return {?}
     */
    function (value, oldUrl) {
        var _this = this;
        if (this._hash === value) {
            // Don't fire events if the hash has not changed.
            return;
        }
        this._hash = value;
        var /** @type {?} */ newUrl = this.url;
        scheduleMicroTask(function () { return _this._hashUpdate.next(/** @type {?} */ ({ type: 'hashchange', oldUrl: oldUrl, newUrl: newUrl })); });
    };
    /**
     * @param {?} state
     * @param {?} title
     * @param {?} newUrl
     * @return {?}
     */
    ServerPlatformLocation.prototype.replaceState = /**
     * @param {?} state
     * @param {?} title
     * @param {?} newUrl
     * @return {?}
     */
    function (state, title, newUrl) {
        var /** @type {?} */ oldUrl = this.url;
        var /** @type {?} */ parsedUrl = parseUrl(newUrl);
        this._path = parsedUrl.pathname;
        this._search = parsedUrl.search;
        this.setHash(parsedUrl.hash, oldUrl);
    };
    /**
     * @param {?} state
     * @param {?} title
     * @param {?} newUrl
     * @return {?}
     */
    ServerPlatformLocation.prototype.pushState = /**
     * @param {?} state
     * @param {?} title
     * @param {?} newUrl
     * @return {?}
     */
    function (state, title, newUrl) {
        this.replaceState(state, title, newUrl);
    };
    /**
     * @return {?}
     */
    ServerPlatformLocation.prototype.forward = /**
     * @return {?}
     */
    function () { throw new Error('Not implemented'); };
    /**
     * @return {?}
     */
    ServerPlatformLocation.prototype.back = /**
     * @return {?}
     */
    function () { throw new Error('Not implemented'); };
    ServerPlatformLocation.decorators = [
        { type: _angular_core.Injectable },
    ];
    /** @nocollapse */
    ServerPlatformLocation.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: _angular_core.Inject, args: [_angular_platformBrowser.DOCUMENT,] },] },
        { type: undefined, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Inject, args: [INITIAL_CONFIG,] },] },
    ]; };
    return ServerPlatformLocation;
}());
/**
 * @param {?} fn
 * @return {?}
 */
function scheduleMicroTask(fn) {
    Zone.current.scheduleMicroTask('scheduleMicrotask', fn);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var EMPTY_ARRAY = [];
var ServerRendererFactory2 = (function () {
    function ServerRendererFactory2(ngZone, document, sharedStylesHost) {
        this.ngZone = ngZone;
        this.document = document;
        this.sharedStylesHost = sharedStylesHost;
        this.rendererByCompId = new Map();
        this.schema = new _angular_compiler.DomElementSchemaRegistry();
        this.defaultRenderer = new DefaultServerRenderer2(document, ngZone, this.schema);
    }
    
    /**
     * @param {?} element
     * @param {?} type
     * @return {?}
     */
    ServerRendererFactory2.prototype.createRenderer = /**
     * @param {?} element
     * @param {?} type
     * @return {?}
     */
    function (element, type) {
        if (!element || !type) {
            return this.defaultRenderer;
        }
        switch (type.encapsulation) {
            case _angular_core.ViewEncapsulation.Native:
            case _angular_core.ViewEncapsulation.Emulated: {
                var /** @type {?} */ renderer = this.rendererByCompId.get(type.id);
                if (!renderer) {
                    renderer = new EmulatedEncapsulationServerRenderer2(this.document, this.ngZone, this.sharedStylesHost, this.schema, type);
                    this.rendererByCompId.set(type.id, renderer);
                }
                (/** @type {?} */ (renderer)).applyToHost(element);
                return renderer;
            }
            case _angular_core.ViewEncapsulation.Native:
                throw new Error('Native encapsulation is not supported on the server!');
            default: {
                if (!this.rendererByCompId.has(type.id)) {
                    var /** @type {?} */ styles = _angular_platformBrowser.ɵflattenStyles(type.id, type.styles, []);
                    this.sharedStylesHost.addStyles(styles);
                    this.rendererByCompId.set(type.id, this.defaultRenderer);
                }
                return this.defaultRenderer;
            }
        }
    };
    /**
     * @return {?}
     */
    ServerRendererFactory2.prototype.begin = /**
     * @return {?}
     */
    function () { };
    /**
     * @return {?}
     */
    ServerRendererFactory2.prototype.end = /**
     * @return {?}
     */
    function () { };
    ServerRendererFactory2.decorators = [
        { type: _angular_core.Injectable },
    ];
    /** @nocollapse */
    ServerRendererFactory2.ctorParameters = function () { return [
        { type: _angular_core.NgZone, },
        { type: undefined, decorators: [{ type: _angular_core.Inject, args: [_angular_platformBrowser.DOCUMENT,] },] },
        { type: _angular_platformBrowser.ɵSharedStylesHost, },
    ]; };
    return ServerRendererFactory2;
}());
var DefaultServerRenderer2 = (function () {
    function DefaultServerRenderer2(document, ngZone, schema) {
        this.document = document;
        this.ngZone = ngZone;
        this.schema = schema;
        this.data = Object.create(null);
    }
    /**
     * @return {?}
     */
    DefaultServerRenderer2.prototype.destroy = /**
     * @return {?}
     */
    function () { };
    /**
     * @param {?} name
     * @param {?=} namespace
     * @param {?=} debugInfo
     * @return {?}
     */
    DefaultServerRenderer2.prototype.createElement = /**
     * @param {?} name
     * @param {?=} namespace
     * @param {?=} debugInfo
     * @return {?}
     */
    function (name, namespace, debugInfo) {
        if (namespace) {
            return _angular_platformBrowser.ɵgetDOM().createElementNS(_angular_platformBrowser.ɵNAMESPACE_URIS[namespace], name);
        }
        return _angular_platformBrowser.ɵgetDOM().createElement(name);
    };
    /**
     * @param {?} value
     * @param {?=} debugInfo
     * @return {?}
     */
    DefaultServerRenderer2.prototype.createComment = /**
     * @param {?} value
     * @param {?=} debugInfo
     * @return {?}
     */
    function (value, debugInfo) { return _angular_platformBrowser.ɵgetDOM().createComment(value); };
    /**
     * @param {?} value
     * @param {?=} debugInfo
     * @return {?}
     */
    DefaultServerRenderer2.prototype.createText = /**
     * @param {?} value
     * @param {?=} debugInfo
     * @return {?}
     */
    function (value, debugInfo) { return _angular_platformBrowser.ɵgetDOM().createTextNode(value); };
    /**
     * @param {?} parent
     * @param {?} newChild
     * @return {?}
     */
    DefaultServerRenderer2.prototype.appendChild = /**
     * @param {?} parent
     * @param {?} newChild
     * @return {?}
     */
    function (parent, newChild) { _angular_platformBrowser.ɵgetDOM().appendChild(parent, newChild); };
    /**
     * @param {?} parent
     * @param {?} newChild
     * @param {?} refChild
     * @return {?}
     */
    DefaultServerRenderer2.prototype.insertBefore = /**
     * @param {?} parent
     * @param {?} newChild
     * @param {?} refChild
     * @return {?}
     */
    function (parent, newChild, refChild) {
        if (parent) {
            _angular_platformBrowser.ɵgetDOM().insertBefore(parent, refChild, newChild);
        }
    };
    /**
     * @param {?} parent
     * @param {?} oldChild
     * @return {?}
     */
    DefaultServerRenderer2.prototype.removeChild = /**
     * @param {?} parent
     * @param {?} oldChild
     * @return {?}
     */
    function (parent, oldChild) {
        if (parent) {
            _angular_platformBrowser.ɵgetDOM().removeChild(parent, oldChild);
        }
    };
    /**
     * @param {?} selectorOrNode
     * @param {?=} debugInfo
     * @return {?}
     */
    DefaultServerRenderer2.prototype.selectRootElement = /**
     * @param {?} selectorOrNode
     * @param {?=} debugInfo
     * @return {?}
     */
    function (selectorOrNode, debugInfo) {
        var /** @type {?} */ el;
        if (typeof selectorOrNode === 'string') {
            el = _angular_platformBrowser.ɵgetDOM().querySelector(this.document, selectorOrNode);
            if (!el) {
                throw new Error("The selector \"" + selectorOrNode + "\" did not match any elements");
            }
        }
        else {
            el = selectorOrNode;
        }
        _angular_platformBrowser.ɵgetDOM().clearNodes(el);
        return el;
    };
    /**
     * @param {?} node
     * @return {?}
     */
    DefaultServerRenderer2.prototype.parentNode = /**
     * @param {?} node
     * @return {?}
     */
    function (node) { return _angular_platformBrowser.ɵgetDOM().parentElement(node); };
    /**
     * @param {?} node
     * @return {?}
     */
    DefaultServerRenderer2.prototype.nextSibling = /**
     * @param {?} node
     * @return {?}
     */
    function (node) { return _angular_platformBrowser.ɵgetDOM().nextSibling(node); };
    /**
     * @param {?} el
     * @param {?} name
     * @param {?} value
     * @param {?=} namespace
     * @return {?}
     */
    DefaultServerRenderer2.prototype.setAttribute = /**
     * @param {?} el
     * @param {?} name
     * @param {?} value
     * @param {?=} namespace
     * @return {?}
     */
    function (el, name, value, namespace) {
        if (namespace) {
            _angular_platformBrowser.ɵgetDOM().setAttributeNS(el, _angular_platformBrowser.ɵNAMESPACE_URIS[namespace], namespace + ':' + name, value);
        }
        else {
            _angular_platformBrowser.ɵgetDOM().setAttribute(el, name, value);
        }
    };
    /**
     * @param {?} el
     * @param {?} name
     * @param {?=} namespace
     * @return {?}
     */
    DefaultServerRenderer2.prototype.removeAttribute = /**
     * @param {?} el
     * @param {?} name
     * @param {?=} namespace
     * @return {?}
     */
    function (el, name, namespace) {
        if (namespace) {
            _angular_platformBrowser.ɵgetDOM().removeAttributeNS(el, _angular_platformBrowser.ɵNAMESPACE_URIS[namespace], name);
        }
        else {
            _angular_platformBrowser.ɵgetDOM().removeAttribute(el, name);
        }
    };
    /**
     * @param {?} el
     * @param {?} name
     * @return {?}
     */
    DefaultServerRenderer2.prototype.addClass = /**
     * @param {?} el
     * @param {?} name
     * @return {?}
     */
    function (el, name) { _angular_platformBrowser.ɵgetDOM().addClass(el, name); };
    /**
     * @param {?} el
     * @param {?} name
     * @return {?}
     */
    DefaultServerRenderer2.prototype.removeClass = /**
     * @param {?} el
     * @param {?} name
     * @return {?}
     */
    function (el, name) { _angular_platformBrowser.ɵgetDOM().removeClass(el, name); };
    /**
     * @param {?} el
     * @param {?} style
     * @param {?} value
     * @param {?} flags
     * @return {?}
     */
    DefaultServerRenderer2.prototype.setStyle = /**
     * @param {?} el
     * @param {?} style
     * @param {?} value
     * @param {?} flags
     * @return {?}
     */
    function (el, style, value, flags) {
        _angular_platformBrowser.ɵgetDOM().setStyle(el, style, value);
    };
    /**
     * @param {?} el
     * @param {?} style
     * @param {?} flags
     * @return {?}
     */
    DefaultServerRenderer2.prototype.removeStyle = /**
     * @param {?} el
     * @param {?} style
     * @param {?} flags
     * @return {?}
     */
    function (el, style, flags) {
        _angular_platformBrowser.ɵgetDOM().removeStyle(el, style);
    };
    /**
     * @param {?} tagName
     * @param {?} propertyName
     * @return {?}
     */
    DefaultServerRenderer2.prototype._isSafeToReflectProperty = /**
     * @param {?} tagName
     * @param {?} propertyName
     * @return {?}
     */
    function (tagName, propertyName) {
        return this.schema.securityContext(tagName, propertyName, true) ===
            this.schema.securityContext(tagName, propertyName, false);
    };
    /**
     * @param {?} el
     * @param {?} name
     * @param {?} value
     * @return {?}
     */
    DefaultServerRenderer2.prototype.setProperty = /**
     * @param {?} el
     * @param {?} name
     * @param {?} value
     * @return {?}
     */
    function (el, name, value) {
        checkNoSyntheticProp(name, 'property');
        _angular_platformBrowser.ɵgetDOM().setProperty(el, name, value);
        // Mirror property values for known HTML element properties in the attributes.
        var /** @type {?} */ tagName = (/** @type {?} */ (el.tagName)).toLowerCase();
        if (value != null && (typeof value === 'number' || typeof value == 'string') &&
            this.schema.hasElement(tagName, EMPTY_ARRAY) &&
            this.schema.hasProperty(tagName, name, EMPTY_ARRAY) &&
            this._isSafeToReflectProperty(tagName, name)) {
            this.setAttribute(el, name, value.toString());
        }
    };
    /**
     * @param {?} node
     * @param {?} value
     * @return {?}
     */
    DefaultServerRenderer2.prototype.setValue = /**
     * @param {?} node
     * @param {?} value
     * @return {?}
     */
    function (node, value) { _angular_platformBrowser.ɵgetDOM().setText(node, value); };
    /**
     * @param {?} target
     * @param {?} eventName
     * @param {?} callback
     * @return {?}
     */
    DefaultServerRenderer2.prototype.listen = /**
     * @param {?} target
     * @param {?} eventName
     * @param {?} callback
     * @return {?}
     */
    function (target, eventName, callback) {
        var _this = this;
        // Note: We are not using the EventsPlugin here as this is not needed
        // to run our tests.
        checkNoSyntheticProp(eventName, 'listener');
        var /** @type {?} */ el = typeof target === 'string' ? _angular_platformBrowser.ɵgetDOM().getGlobalEventTarget(this.document, target) : target;
        var /** @type {?} */ outsideHandler = function (event) { return _this.ngZone.runGuarded(function () { return callback(event); }); };
        return this.ngZone.runOutsideAngular(function () { return /** @type {?} */ (_angular_platformBrowser.ɵgetDOM().onAndCancel(el, eventName, outsideHandler)); });
    };
    return DefaultServerRenderer2;
}());
var AT_CHARCODE = '@'.charCodeAt(0);
/**
 * @param {?} name
 * @param {?} nameKind
 * @return {?}
 */
function checkNoSyntheticProp(name, nameKind) {
    if (name.charCodeAt(0) === AT_CHARCODE) {
        throw new Error("Found the synthetic " + nameKind + " " + name + ". Please include either \"BrowserAnimationsModule\" or \"NoopAnimationsModule\" in your application.");
    }
}
var EmulatedEncapsulationServerRenderer2 = (function (_super) {
    __extends(EmulatedEncapsulationServerRenderer2, _super);
    function EmulatedEncapsulationServerRenderer2(document, ngZone, sharedStylesHost, schema, component) {
        var _this = _super.call(this, document, ngZone, schema) || this;
        _this.component = component;
        var /** @type {?} */ styles = _angular_platformBrowser.ɵflattenStyles(component.id, component.styles, []);
        sharedStylesHost.addStyles(styles);
        _this.contentAttr = _angular_platformBrowser.ɵshimContentAttribute(component.id);
        _this.hostAttr = _angular_platformBrowser.ɵshimHostAttribute(component.id);
        return _this;
    }
    /**
     * @param {?} element
     * @return {?}
     */
    EmulatedEncapsulationServerRenderer2.prototype.applyToHost = /**
     * @param {?} element
     * @return {?}
     */
    function (element) { _super.prototype.setAttribute.call(this, element, this.hostAttr, ''); };
    /**
     * @param {?} parent
     * @param {?} name
     * @return {?}
     */
    EmulatedEncapsulationServerRenderer2.prototype.createElement = /**
     * @param {?} parent
     * @param {?} name
     * @return {?}
     */
    function (parent, name) {
        var /** @type {?} */ el = _super.prototype.createElement.call(this, parent, name);
        _super.prototype.setAttribute.call(this, el, this.contentAttr, '');
        return el;
    };
    return EmulatedEncapsulationServerRenderer2;
}(DefaultServerRenderer2));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var ServerStylesHost = (function (_super) {
    __extends(ServerStylesHost, _super);
    function ServerStylesHost(doc, transitionId) {
        var _this = _super.call(this) || this;
        _this.doc = doc;
        _this.transitionId = transitionId;
        _this.head = null;
        _this.head = _angular_platformBrowser.ɵgetDOM().getElementsByTagName(doc, 'head')[0];
        return _this;
    }
    /**
     * @param {?} style
     * @return {?}
     */
    ServerStylesHost.prototype._addStyle = /**
     * @param {?} style
     * @return {?}
     */
    function (style) {
        var /** @type {?} */ adapter = _angular_platformBrowser.ɵgetDOM();
        var /** @type {?} */ el = adapter.createElement('style');
        adapter.setText(el, style);
        if (!!this.transitionId) {
            adapter.setAttribute(el, 'ng-transition', this.transitionId);
        }
        adapter.appendChild(this.head, el);
    };
    /**
     * @param {?} additions
     * @return {?}
     */
    ServerStylesHost.prototype.onStylesAdded = /**
     * @param {?} additions
     * @return {?}
     */
    function (additions) {
        var _this = this;
        additions.forEach(function (style) { return _this._addStyle(style); });
    };
    ServerStylesHost.decorators = [
        { type: _angular_core.Injectable },
    ];
    /** @nocollapse */
    ServerStylesHost.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: _angular_core.Inject, args: [_angular_platformBrowser.DOCUMENT,] },] },
        { type: undefined, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Inject, args: [_angular_platformBrowser.ɵTRANSITION_ID,] },] },
    ]; };
    return ServerStylesHost;
}(_angular_platformBrowser.ɵSharedStylesHost));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var INTERNAL_SERVER_PLATFORM_PROVIDERS = [
    { provide: _angular_platformBrowser.DOCUMENT, useFactory: _document, deps: [_angular_core.Injector] },
    { provide: _angular_core.PLATFORM_ID, useValue: _angular_common.ɵPLATFORM_SERVER_ID },
    { provide: _angular_core.PLATFORM_INITIALIZER, useFactory: initDominoAdapter, multi: true, deps: [_angular_core.Injector] }, {
        provide: _angular_common.PlatformLocation,
        useClass: ServerPlatformLocation,
        deps: [_angular_platformBrowser.DOCUMENT, [_angular_core.Optional, INITIAL_CONFIG]]
    },
    { provide: PlatformState, deps: [_angular_platformBrowser.DOCUMENT] },
    // Add special provider that allows multiple instances of platformServer* to be created.
    { provide: _angular_core.ɵALLOW_MULTIPLE_PLATFORMS, useValue: true }
];
/**
 * @param {?} injector
 * @return {?}
 */
function initDominoAdapter(injector) {
    return function () { DominoAdapter.makeCurrent(); };
}
/**
 * @param {?} renderer
 * @param {?} engine
 * @param {?} zone
 * @return {?}
 */
function instantiateServerRendererFactory(renderer, engine, zone) {
    return new _angular_platformBrowser_animations.ɵAnimationRendererFactory(renderer, engine, zone);
}
var SERVER_RENDER_PROVIDERS = [
    ServerRendererFactory2,
    {
        provide: _angular_core.RendererFactory2,
        useFactory: instantiateServerRendererFactory,
        deps: [ServerRendererFactory2, _angular_animations_browser.ɵAnimationEngine, _angular_core.NgZone]
    },
    ServerStylesHost,
    { provide: _angular_platformBrowser.ɵSharedStylesHost, useExisting: ServerStylesHost },
];
/**
 * The ng module for the server.
 *
 * \@experimental
 */
var ServerModule = (function () {
    function ServerModule() {
    }
    ServerModule.decorators = [
        { type: _angular_core.NgModule, args: [{
                    exports: [_angular_platformBrowser.BrowserModule],
                    imports: [_angular_http.HttpModule, _angular_common_http.HttpClientModule, _angular_platformBrowser_animations.NoopAnimationsModule],
                    providers: [
                        SERVER_RENDER_PROVIDERS,
                        SERVER_HTTP_PROVIDERS,
                        { provide: _angular_core.Testability, useValue: null },
                    ],
                },] },
    ];
    /** @nocollapse */
    ServerModule.ctorParameters = function () { return []; };
    return ServerModule;
}());
/**
 * @param {?} injector
 * @return {?}
 */
function _document(injector) {
    var /** @type {?} */ config = injector.get(INITIAL_CONFIG, null);
    if (config && config.document) {
        return parseDocument(config.document, config.url);
    }
    else {
        return _angular_platformBrowser.ɵgetDOM().createHtmlDocument();
    }
}
/**
 * \@experimental
 */
var platformServer = _angular_core.createPlatformFactory(_angular_core.platformCore, 'server', INTERNAL_SERVER_PLATFORM_PROVIDERS);
/**
 * The server platform that supports the runtime compiler.
 *
 * \@experimental
 */
var platformDynamicServer = _angular_core.createPlatformFactory(_angular_platformBrowserDynamic.ɵplatformCoreDynamic, 'serverDynamic', INTERNAL_SERVER_PLATFORM_PROVIDERS);

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * @param {?} platformFactory
 * @param {?} options
 * @return {?}
 */
function _getPlatform(platformFactory, options) {
    var /** @type {?} */ extraProviders = options.extraProviders ? options.extraProviders : [];
    return platformFactory([
        { provide: INITIAL_CONFIG, useValue: { document: options.document, url: options.url } },
        extraProviders
    ]);
}
/**
 * @template T
 * @param {?} platform
 * @param {?} moduleRefPromise
 * @return {?}
 */
function _render(platform, moduleRefPromise) {
    return moduleRefPromise.then(function (moduleRef) {
        var /** @type {?} */ transitionId = moduleRef.injector.get(_angular_platformBrowser.ɵTRANSITION_ID, null);
        if (!transitionId) {
            throw new Error("renderModule[Factory]() requires the use of BrowserModule.withServerTransition() to ensure\nthe server-rendered app can be properly bootstrapped into a client app.");
        }
        var /** @type {?} */ applicationRef = moduleRef.injector.get(_angular_core.ApplicationRef);
        return rxjs_operator_toPromise.toPromise
            .call(rxjs_operator_first.first.call(rxjs_operator_filter.filter.call(applicationRef.isStable, function (isStable) { return isStable; })))
            .then(function () {
            var /** @type {?} */ platformState = platform.injector.get(PlatformState);
            // Run any BEFORE_APP_SERIALIZED callbacks just before rendering to string.
            var /** @type {?} */ callbacks = moduleRef.injector.get(BEFORE_APP_SERIALIZED, null);
            if (callbacks) {
                for (var _i = 0, callbacks_1 = callbacks; _i < callbacks_1.length; _i++) {
                    var callback = callbacks_1[_i];
                    try {
                        callback();
                    }
                    catch (/** @type {?} */ e) {
                        // Ignore exceptions.
                        console.warn('Ignoring BEFORE_APP_SERIALIZED Exception: ', e);
                    }
                }
            }
            var /** @type {?} */ output = platformState.renderToString();
            platform.destroy();
            return output;
        });
    });
}
/**
 * Renders a Module to string.
 *
 * `document` is the full document HTML of the page to render, as a string.
 * `url` is the URL for the current render request.
 * `extraProviders` are the platform level providers for the current render request.
 *
 * Do not use this in a production server environment. Use pre-compiled {\@link NgModuleFactory} with
 * {\@link renderModuleFactory} instead.
 *
 * \@experimental
 * @template T
 * @param {?} module
 * @param {?} options
 * @return {?}
 */
function renderModule(module, options) {
    var /** @type {?} */ platform = _getPlatform(platformDynamicServer, options);
    return _render(platform, platform.bootstrapModule(module));
}
/**
 * Renders a {\@link NgModuleFactory} to string.
 *
 * `document` is the full document HTML of the page to render, as a string.
 * `url` is the URL for the current render request.
 * `extraProviders` are the platform level providers for the current render request.
 *
 * \@experimental
 * @template T
 * @param {?} moduleFactory
 * @param {?} options
 * @return {?}
 */
function renderModuleFactory(moduleFactory, options) {
    var /** @type {?} */ platform = _getPlatform(platformServer, options);
    return _render(platform, platform.bootstrapModuleFactory(moduleFactory));
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * @module
 * @description
 * Entry point for all public APIs of the common package.
 */
/**
 * \@stable
 */
var VERSION = new _angular_core.Version('5.0.0-beta.7');

exports.PlatformState = PlatformState;
exports.ServerModule = ServerModule;
exports.platformDynamicServer = platformDynamicServer;
exports.platformServer = platformServer;
exports.BEFORE_APP_SERIALIZED = BEFORE_APP_SERIALIZED;
exports.INITIAL_CONFIG = INITIAL_CONFIG;
exports.renderModule = renderModule;
exports.renderModuleFactory = renderModuleFactory;
exports.VERSION = VERSION;
exports.ɵINTERNAL_SERVER_PLATFORM_PROVIDERS = INTERNAL_SERVER_PLATFORM_PROVIDERS;
exports.ɵSERVER_RENDER_PROVIDERS = SERVER_RENDER_PROVIDERS;
exports.ɵServerRendererFactory2 = ServerRendererFactory2;
exports.ɵg = SERVER_HTTP_PROVIDERS;
exports.ɵc = ServerXhr;
exports.ɵd = ServerXsrfStrategy;
exports.ɵe = httpFactory;
exports.ɵf = zoneWrappedInterceptingHandler;
exports.ɵa = instantiateServerRendererFactory;
exports.ɵb = ServerStylesHost;

Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=platform-server.umd.js.map


/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * @license Angular v5.0.0-beta.7
 * (c) 2010-2017 Google, Inc. https://angular.io/
 * License: MIT
 */
(function (global, factory) {
	 true ? factory(exports, __webpack_require__(19)) :
	typeof define === 'function' && define.amd ? define(['exports', '@angular/animations'], factory) :
	(factory((global.ng = global.ng || {}, global.ng.animations = global.ng.animations || {}, global.ng.animations.browser = {}),global.ng.animations));
}(this, (function (exports,_angular_animations) { 'use strict';

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = Object.setPrototypeOf ||
    ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
    function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = Object.assign || function __assign(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }
    return t;
};

/**
 * @license Angular v5.0.0-beta.7
 * (c) 2010-2017 Google, Inc. https://angular.io/
 * License: MIT
 */
/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * @param {?} players
 * @return {?}
 */
function optimizeGroupPlayer(players) {
    switch (players.length) {
        case 0:
            return new _angular_animations.NoopAnimationPlayer();
        case 1:
            return players[0];
        default:
            return new _angular_animations.ɵAnimationGroupPlayer(players);
    }
}
/**
 * @param {?} driver
 * @param {?} normalizer
 * @param {?} element
 * @param {?} keyframes
 * @param {?=} preStyles
 * @param {?=} postStyles
 * @return {?}
 */
function normalizeKeyframes(driver, normalizer, element, keyframes, preStyles, postStyles) {
    if (preStyles === void 0) { preStyles = {}; }
    if (postStyles === void 0) { postStyles = {}; }
    var /** @type {?} */ errors = [];
    var /** @type {?} */ normalizedKeyframes = [];
    var /** @type {?} */ previousOffset = -1;
    var /** @type {?} */ previousKeyframe = null;
    keyframes.forEach(function (kf) {
        var /** @type {?} */ offset = /** @type {?} */ (kf['offset']);
        var /** @type {?} */ isSameOffset = offset == previousOffset;
        var /** @type {?} */ normalizedKeyframe = (isSameOffset && previousKeyframe) || {};
        Object.keys(kf).forEach(function (prop) {
            var /** @type {?} */ normalizedProp = prop;
            var /** @type {?} */ normalizedValue = kf[prop];
            if (prop !== 'offset') {
                normalizedProp = normalizer.normalizePropertyName(normalizedProp, errors);
                switch (normalizedValue) {
                    case _angular_animations.ɵPRE_STYLE:
                        normalizedValue = preStyles[prop];
                        break;
                    case _angular_animations.AUTO_STYLE:
                        normalizedValue = postStyles[prop];
                        break;
                    default:
                        normalizedValue =
                            normalizer.normalizeStyleValue(prop, normalizedProp, normalizedValue, errors);
                        break;
                }
            }
            normalizedKeyframe[normalizedProp] = normalizedValue;
        });
        if (!isSameOffset) {
            normalizedKeyframes.push(normalizedKeyframe);
        }
        previousKeyframe = normalizedKeyframe;
        previousOffset = offset;
    });
    if (errors.length) {
        var /** @type {?} */ LINE_START = '\n - ';
        throw new Error("Unable to animate due to the following errors:" + LINE_START + errors.join(LINE_START));
    }
    return normalizedKeyframes;
}
/**
 * @param {?} player
 * @param {?} eventName
 * @param {?} event
 * @param {?} callback
 * @return {?}
 */
function listenOnPlayer(player, eventName, event, callback) {
    switch (eventName) {
        case 'start':
            player.onStart(function () { return callback(event && copyAnimationEvent(event, 'start', player.totalTime)); });
            break;
        case 'done':
            player.onDone(function () { return callback(event && copyAnimationEvent(event, 'done', player.totalTime)); });
            break;
        case 'destroy':
            player.onDestroy(function () { return callback(event && copyAnimationEvent(event, 'destroy', player.totalTime)); });
            break;
    }
}
/**
 * @param {?} e
 * @param {?=} phaseName
 * @param {?=} totalTime
 * @return {?}
 */
function copyAnimationEvent(e, phaseName, totalTime) {
    var /** @type {?} */ event = makeAnimationEvent(e.element, e.triggerName, e.fromState, e.toState, phaseName || e.phaseName, totalTime == undefined ? e.totalTime : totalTime);
    var /** @type {?} */ data = (/** @type {?} */ (e))['_data'];
    if (data != null) {
        (/** @type {?} */ (event))['_data'] = data;
    }
    return event;
}
/**
 * @param {?} element
 * @param {?} triggerName
 * @param {?} fromState
 * @param {?} toState
 * @param {?=} phaseName
 * @param {?=} totalTime
 * @return {?}
 */
function makeAnimationEvent(element, triggerName, fromState, toState, phaseName, totalTime) {
    if (phaseName === void 0) { phaseName = ''; }
    if (totalTime === void 0) { totalTime = 0; }
    return { element: element, triggerName: triggerName, fromState: fromState, toState: toState, phaseName: phaseName, totalTime: totalTime };
}
/**
 * @param {?} map
 * @param {?} key
 * @param {?} defaultValue
 * @return {?}
 */
function getOrSetAsInMap(map, key, defaultValue) {
    var /** @type {?} */ value;
    if (map instanceof Map) {
        value = map.get(key);
        if (!value) {
            map.set(key, value = defaultValue);
        }
    }
    else {
        value = map[key];
        if (!value) {
            value = map[key] = defaultValue;
        }
    }
    return value;
}
/**
 * @param {?} command
 * @return {?}
 */
function parseTimelineCommand(command) {
    var /** @type {?} */ separatorPos = command.indexOf(':');
    var /** @type {?} */ id = command.substring(1, separatorPos);
    var /** @type {?} */ action = command.substr(separatorPos + 1);
    return [id, action];
}
var _contains = function (elm1, elm2) { return false; };
var _matches = function (element, selector) {
    return false;
};
var _query = function (element, selector, multi) {
    return [];
};
if (typeof Element != 'undefined') {
    // this is well supported in all browsers
    _contains = function (elm1, elm2) { return /** @type {?} */ (elm1.contains(elm2)); };
    if (Element.prototype.matches) {
        _matches = function (element, selector) { return element.matches(selector); };
    }
    else {
        var /** @type {?} */ proto = /** @type {?} */ (Element.prototype);
        var /** @type {?} */ fn_1 = proto.matchesSelector || proto.mozMatchesSelector || proto.msMatchesSelector ||
            proto.oMatchesSelector || proto.webkitMatchesSelector;
        if (fn_1) {
            _matches = function (element, selector) { return fn_1.apply(element, [selector]); };
        }
    }
    _query = function (element, selector, multi) {
        var /** @type {?} */ results = [];
        if (multi) {
            results.push.apply(results, element.querySelectorAll(selector));
        }
        else {
            var /** @type {?} */ elm = element.querySelector(selector);
            if (elm) {
                results.push(elm);
            }
        }
        return results;
    };
}
var _CACHED_BODY = null;
/**
 * @param {?} prop
 * @return {?}
 */
function validateStyleProperty(prop) {
    if (!_CACHED_BODY) {
        _CACHED_BODY = getBodyNode() || {};
    }
    return /** @type {?} */ ((_CACHED_BODY)).style ? prop in /** @type {?} */ ((_CACHED_BODY)).style : true;
}
/**
 * @return {?}
 */
function getBodyNode() {
    if (typeof document != 'undefined') {
        return document.body;
    }
    return null;
}
var matchesElement = _matches;
var containsElement = _contains;
var invokeQuery = _query;

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * \@experimental
 */
var NoopAnimationDriver = (function () {
    function NoopAnimationDriver() {
    }
    /**
     * @param {?} prop
     * @return {?}
     */
    NoopAnimationDriver.prototype.validateStyleProperty = /**
     * @param {?} prop
     * @return {?}
     */
    function (prop) { return validateStyleProperty(prop); };
    /**
     * @param {?} element
     * @param {?} selector
     * @return {?}
     */
    NoopAnimationDriver.prototype.matchesElement = /**
     * @param {?} element
     * @param {?} selector
     * @return {?}
     */
    function (element, selector) {
        return matchesElement(element, selector);
    };
    /**
     * @param {?} elm1
     * @param {?} elm2
     * @return {?}
     */
    NoopAnimationDriver.prototype.containsElement = /**
     * @param {?} elm1
     * @param {?} elm2
     * @return {?}
     */
    function (elm1, elm2) { return containsElement(elm1, elm2); };
    /**
     * @param {?} element
     * @param {?} selector
     * @param {?} multi
     * @return {?}
     */
    NoopAnimationDriver.prototype.query = /**
     * @param {?} element
     * @param {?} selector
     * @param {?} multi
     * @return {?}
     */
    function (element, selector, multi) {
        return invokeQuery(element, selector, multi);
    };
    /**
     * @param {?} element
     * @param {?} prop
     * @param {?=} defaultValue
     * @return {?}
     */
    NoopAnimationDriver.prototype.computeStyle = /**
     * @param {?} element
     * @param {?} prop
     * @param {?=} defaultValue
     * @return {?}
     */
    function (element, prop, defaultValue) {
        return defaultValue || '';
    };
    /**
     * @param {?} element
     * @param {?} keyframes
     * @param {?} duration
     * @param {?} delay
     * @param {?} easing
     * @param {?=} previousPlayers
     * @return {?}
     */
    NoopAnimationDriver.prototype.animate = /**
     * @param {?} element
     * @param {?} keyframes
     * @param {?} duration
     * @param {?} delay
     * @param {?} easing
     * @param {?=} previousPlayers
     * @return {?}
     */
    function (element, keyframes, duration, delay, easing, previousPlayers) {
        if (previousPlayers === void 0) { previousPlayers = []; }
        return new _angular_animations.NoopAnimationPlayer();
    };
    return NoopAnimationDriver;
}());
/**
 * \@experimental
 * @abstract
 */
var AnimationDriver = (function () {
    function AnimationDriver() {
    }
    AnimationDriver.NOOP = new NoopAnimationDriver();
    return AnimationDriver;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var ONE_SECOND = 1000;
var SUBSTITUTION_EXPR_START = '{{';
var SUBSTITUTION_EXPR_END = '}}';
var ENTER_CLASSNAME = 'ng-enter';
var LEAVE_CLASSNAME = 'ng-leave';
var ENTER_SELECTOR = '.ng-enter';
var LEAVE_SELECTOR = '.ng-leave';
var NG_TRIGGER_CLASSNAME = 'ng-trigger';
var NG_TRIGGER_SELECTOR = '.ng-trigger';
var NG_ANIMATING_CLASSNAME = 'ng-animating';
var NG_ANIMATING_SELECTOR = '.ng-animating';
/**
 * @param {?} value
 * @return {?}
 */
function resolveTimingValue(value) {
    if (typeof value == 'number')
        return value;
    var /** @type {?} */ matches = (/** @type {?} */ (value)).match(/^(-?[\.\d]+)(m?s)/);
    if (!matches || matches.length < 2)
        return 0;
    return _convertTimeValueToMS(parseFloat(matches[1]), matches[2]);
}
/**
 * @param {?} value
 * @param {?} unit
 * @return {?}
 */
function _convertTimeValueToMS(value, unit) {
    switch (unit) {
        case 's':
            return value * ONE_SECOND;
        default:
            // ms or something else
            return value;
    }
}
/**
 * @param {?} timings
 * @param {?} errors
 * @param {?=} allowNegativeValues
 * @return {?}
 */
function resolveTiming(timings, errors, allowNegativeValues) {
    return timings.hasOwnProperty('duration') ? /** @type {?} */ (timings) :
        parseTimeExpression(/** @type {?} */ (timings), errors, allowNegativeValues);
}
/**
 * @param {?} exp
 * @param {?} errors
 * @param {?=} allowNegativeValues
 * @return {?}
 */
function parseTimeExpression(exp, errors, allowNegativeValues) {
    var /** @type {?} */ regex = /^(-?[\.\d]+)(m?s)(?:\s+(-?[\.\d]+)(m?s))?(?:\s+([-a-z]+(?:\(.+?\))?))?$/i;
    var /** @type {?} */ duration;
    var /** @type {?} */ delay = 0;
    var /** @type {?} */ easing = '';
    if (typeof exp === 'string') {
        var /** @type {?} */ matches = exp.match(regex);
        if (matches === null) {
            errors.push("The provided timing value \"" + exp + "\" is invalid.");
            return { duration: 0, delay: 0, easing: '' };
        }
        duration = _convertTimeValueToMS(parseFloat(matches[1]), matches[2]);
        var /** @type {?} */ delayMatch = matches[3];
        if (delayMatch != null) {
            delay = _convertTimeValueToMS(Math.floor(parseFloat(delayMatch)), matches[4]);
        }
        var /** @type {?} */ easingVal = matches[5];
        if (easingVal) {
            easing = easingVal;
        }
    }
    else {
        duration = /** @type {?} */ (exp);
    }
    if (!allowNegativeValues) {
        var /** @type {?} */ containsErrors = false;
        var /** @type {?} */ startIndex = errors.length;
        if (duration < 0) {
            errors.push("Duration values below 0 are not allowed for this animation step.");
            containsErrors = true;
        }
        if (delay < 0) {
            errors.push("Delay values below 0 are not allowed for this animation step.");
            containsErrors = true;
        }
        if (containsErrors) {
            errors.splice(startIndex, 0, "The provided timing value \"" + exp + "\" is invalid.");
        }
    }
    return { duration: duration, delay: delay, easing: easing };
}
/**
 * @param {?} obj
 * @param {?=} destination
 * @return {?}
 */
function copyObj(obj, destination) {
    if (destination === void 0) { destination = {}; }
    Object.keys(obj).forEach(function (prop) { destination[prop] = obj[prop]; });
    return destination;
}
/**
 * @param {?} styles
 * @return {?}
 */
function normalizeStyles(styles) {
    var /** @type {?} */ normalizedStyles = {};
    if (Array.isArray(styles)) {
        styles.forEach(function (data) { return copyStyles(data, false, normalizedStyles); });
    }
    else {
        copyStyles(styles, false, normalizedStyles);
    }
    return normalizedStyles;
}
/**
 * @param {?} styles
 * @param {?} readPrototype
 * @param {?=} destination
 * @return {?}
 */
function copyStyles(styles, readPrototype, destination) {
    if (destination === void 0) { destination = {}; }
    if (readPrototype) {
        // we make use of a for-in loop so that the
        // prototypically inherited properties are
        // revealed from the backFill map
        for (var /** @type {?} */ prop in styles) {
            destination[prop] = styles[prop];
        }
    }
    else {
        copyObj(styles, destination);
    }
    return destination;
}
/**
 * @param {?} element
 * @param {?} styles
 * @return {?}
 */
function setStyles(element, styles) {
    if (element['style']) {
        Object.keys(styles).forEach(function (prop) {
            var /** @type {?} */ camelProp = dashCaseToCamelCase(prop);
            element.style[camelProp] = styles[prop];
        });
    }
}
/**
 * @param {?} element
 * @param {?} styles
 * @return {?}
 */
function eraseStyles(element, styles) {
    if (element['style']) {
        Object.keys(styles).forEach(function (prop) {
            var /** @type {?} */ camelProp = dashCaseToCamelCase(prop);
            element.style[camelProp] = '';
        });
    }
}
/**
 * @param {?} steps
 * @return {?}
 */
function normalizeAnimationEntry(steps) {
    if (Array.isArray(steps)) {
        if (steps.length == 1)
            return steps[0];
        return _angular_animations.sequence(steps);
    }
    return /** @type {?} */ (steps);
}
/**
 * @param {?} value
 * @param {?} options
 * @param {?} errors
 * @return {?}
 */
function validateStyleParams(value, options, errors) {
    var /** @type {?} */ params = options.params || {};
    var /** @type {?} */ matches = extractStyleParams(value);
    if (matches.length) {
        matches.forEach(function (varName) {
            if (!params.hasOwnProperty(varName)) {
                errors.push("Unable to resolve the local animation param " + varName + " in the given list of values");
            }
        });
    }
}
var PARAM_REGEX = new RegExp(SUBSTITUTION_EXPR_START + "\\s*(.+?)\\s*" + SUBSTITUTION_EXPR_END, 'g');
/**
 * @param {?} value
 * @return {?}
 */
function extractStyleParams(value) {
    var /** @type {?} */ params = [];
    if (typeof value === 'string') {
        var /** @type {?} */ val = value.toString();
        var /** @type {?} */ match = void 0;
        while (match = PARAM_REGEX.exec(val)) {
            params.push(/** @type {?} */ (match[1]));
        }
        PARAM_REGEX.lastIndex = 0;
    }
    return params;
}
/**
 * @param {?} value
 * @param {?} params
 * @param {?} errors
 * @return {?}
 */
function interpolateParams(value, params, errors) {
    var /** @type {?} */ original = value.toString();
    var /** @type {?} */ str = original.replace(PARAM_REGEX, function (_, varName) {
        var /** @type {?} */ localVal = params[varName];
        // this means that the value was never overidden by the data passed in by the user
        if (!params.hasOwnProperty(varName)) {
            errors.push("Please provide a value for the animation param " + varName);
            localVal = '';
        }
        return localVal.toString();
    });
    // we do this to assert that numeric values stay as they are
    return str == original ? value : str;
}
/**
 * @param {?} iterator
 * @return {?}
 */
function iteratorToArray(iterator) {
    var /** @type {?} */ arr = [];
    var /** @type {?} */ item = iterator.next();
    while (!item.done) {
        arr.push(item.value);
        item = iterator.next();
    }
    return arr;
}
/**
 * @param {?} source
 * @param {?} destination
 * @return {?}
 */

var DASH_CASE_REGEXP = /-+([a-z0-9])/g;
/**
 * @param {?} input
 * @return {?}
 */
function dashCaseToCamelCase(input) {
    return input.replace(DASH_CASE_REGEXP, function () {
        var m = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            m[_i] = arguments[_i];
        }
        return m[1].toUpperCase();
    });
}
/**
 * @param {?} duration
 * @param {?} delay
 * @return {?}
 */
function allowPreviousPlayerStylesMerge(duration, delay) {
    return duration === 0 || delay === 0;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var EMPTY_ANIMATION_OPTIONS = {};
/**
 * @record
 */

/**
 * @abstract
 */
var Ast = (function () {
    function Ast() {
        this.options = EMPTY_ANIMATION_OPTIONS;
    }
    Object.defineProperty(Ast.prototype, "params", {
        get: /**
         * @return {?}
         */
        function () { return this.options['params'] || null; },
        enumerable: true,
        configurable: true
    });
    return Ast;
}());
var TriggerAst = (function (_super) {
    __extends(TriggerAst, _super);
    function TriggerAst(name, states, transitions) {
        var _this = _super.call(this) || this;
        _this.name = name;
        _this.states = states;
        _this.transitions = transitions;
        _this.queryCount = 0;
        _this.depCount = 0;
        return _this;
    }
    /**
     * @param {?} visitor
     * @param {?} context
     * @return {?}
     */
    TriggerAst.prototype.visit = /**
     * @param {?} visitor
     * @param {?} context
     * @return {?}
     */
    function (visitor, context) { return visitor.visitTrigger(this, context); };
    return TriggerAst;
}(Ast));
var StateAst = (function (_super) {
    __extends(StateAst, _super);
    function StateAst(name, style$$1) {
        var _this = _super.call(this) || this;
        _this.name = name;
        _this.style = style$$1;
        return _this;
    }
    /**
     * @param {?} visitor
     * @param {?} context
     * @return {?}
     */
    StateAst.prototype.visit = /**
     * @param {?} visitor
     * @param {?} context
     * @return {?}
     */
    function (visitor, context) { return visitor.visitState(this, context); };
    return StateAst;
}(Ast));
var TransitionAst = (function (_super) {
    __extends(TransitionAst, _super);
    function TransitionAst(matchers, animation) {
        var _this = _super.call(this) || this;
        _this.matchers = matchers;
        _this.animation = animation;
        _this.queryCount = 0;
        _this.depCount = 0;
        return _this;
    }
    /**
     * @param {?} visitor
     * @param {?} context
     * @return {?}
     */
    TransitionAst.prototype.visit = /**
     * @param {?} visitor
     * @param {?} context
     * @return {?}
     */
    function (visitor, context) { return visitor.visitTransition(this, context); };
    return TransitionAst;
}(Ast));
var SequenceAst = (function (_super) {
    __extends(SequenceAst, _super);
    function SequenceAst(steps) {
        var _this = _super.call(this) || this;
        _this.steps = steps;
        return _this;
    }
    /**
     * @param {?} visitor
     * @param {?} context
     * @return {?}
     */
    SequenceAst.prototype.visit = /**
     * @param {?} visitor
     * @param {?} context
     * @return {?}
     */
    function (visitor, context) { return visitor.visitSequence(this, context); };
    return SequenceAst;
}(Ast));
var GroupAst = (function (_super) {
    __extends(GroupAst, _super);
    function GroupAst(steps) {
        var _this = _super.call(this) || this;
        _this.steps = steps;
        return _this;
    }
    /**
     * @param {?} visitor
     * @param {?} context
     * @return {?}
     */
    GroupAst.prototype.visit = /**
     * @param {?} visitor
     * @param {?} context
     * @return {?}
     */
    function (visitor, context) { return visitor.visitGroup(this, context); };
    return GroupAst;
}(Ast));
var AnimateAst = (function (_super) {
    __extends(AnimateAst, _super);
    function AnimateAst(timings, style$$1) {
        var _this = _super.call(this) || this;
        _this.timings = timings;
        _this.style = style$$1;
        return _this;
    }
    /**
     * @param {?} visitor
     * @param {?} context
     * @return {?}
     */
    AnimateAst.prototype.visit = /**
     * @param {?} visitor
     * @param {?} context
     * @return {?}
     */
    function (visitor, context) { return visitor.visitAnimate(this, context); };
    return AnimateAst;
}(Ast));
var StyleAst = (function (_super) {
    __extends(StyleAst, _super);
    function StyleAst(styles, easing, offset) {
        var _this = _super.call(this) || this;
        _this.styles = styles;
        _this.easing = easing;
        _this.offset = offset;
        _this.isEmptyStep = false;
        _this.containsDynamicStyles = false;
        return _this;
    }
    /**
     * @param {?} visitor
     * @param {?} context
     * @return {?}
     */
    StyleAst.prototype.visit = /**
     * @param {?} visitor
     * @param {?} context
     * @return {?}
     */
    function (visitor, context) { return visitor.visitStyle(this, context); };
    return StyleAst;
}(Ast));
var KeyframesAst = (function (_super) {
    __extends(KeyframesAst, _super);
    function KeyframesAst(styles) {
        var _this = _super.call(this) || this;
        _this.styles = styles;
        return _this;
    }
    /**
     * @param {?} visitor
     * @param {?} context
     * @return {?}
     */
    KeyframesAst.prototype.visit = /**
     * @param {?} visitor
     * @param {?} context
     * @return {?}
     */
    function (visitor, context) { return visitor.visitKeyframes(this, context); };
    return KeyframesAst;
}(Ast));
var ReferenceAst = (function (_super) {
    __extends(ReferenceAst, _super);
    function ReferenceAst(animation) {
        var _this = _super.call(this) || this;
        _this.animation = animation;
        return _this;
    }
    /**
     * @param {?} visitor
     * @param {?} context
     * @return {?}
     */
    ReferenceAst.prototype.visit = /**
     * @param {?} visitor
     * @param {?} context
     * @return {?}
     */
    function (visitor, context) { return visitor.visitReference(this, context); };
    return ReferenceAst;
}(Ast));
var AnimateChildAst = (function (_super) {
    __extends(AnimateChildAst, _super);
    function AnimateChildAst() {
        return _super.call(this) || this;
    }
    /**
     * @param {?} visitor
     * @param {?} context
     * @return {?}
     */
    AnimateChildAst.prototype.visit = /**
     * @param {?} visitor
     * @param {?} context
     * @return {?}
     */
    function (visitor, context) { return visitor.visitAnimateChild(this, context); };
    return AnimateChildAst;
}(Ast));
var AnimateRefAst = (function (_super) {
    __extends(AnimateRefAst, _super);
    function AnimateRefAst(animation) {
        var _this = _super.call(this) || this;
        _this.animation = animation;
        return _this;
    }
    /**
     * @param {?} visitor
     * @param {?} context
     * @return {?}
     */
    AnimateRefAst.prototype.visit = /**
     * @param {?} visitor
     * @param {?} context
     * @return {?}
     */
    function (visitor, context) { return visitor.visitAnimateRef(this, context); };
    return AnimateRefAst;
}(Ast));
var QueryAst = (function (_super) {
    __extends(QueryAst, _super);
    function QueryAst(selector, limit, optional, includeSelf, animation) {
        var _this = _super.call(this) || this;
        _this.selector = selector;
        _this.limit = limit;
        _this.optional = optional;
        _this.includeSelf = includeSelf;
        _this.animation = animation;
        return _this;
    }
    /**
     * @param {?} visitor
     * @param {?} context
     * @return {?}
     */
    QueryAst.prototype.visit = /**
     * @param {?} visitor
     * @param {?} context
     * @return {?}
     */
    function (visitor, context) { return visitor.visitQuery(this, context); };
    return QueryAst;
}(Ast));
var StaggerAst = (function (_super) {
    __extends(StaggerAst, _super);
    function StaggerAst(timings, animation) {
        var _this = _super.call(this) || this;
        _this.timings = timings;
        _this.animation = animation;
        return _this;
    }
    /**
     * @param {?} visitor
     * @param {?} context
     * @return {?}
     */
    StaggerAst.prototype.visit = /**
     * @param {?} visitor
     * @param {?} context
     * @return {?}
     */
    function (visitor, context) { return visitor.visitStagger(this, context); };
    return StaggerAst;
}(Ast));
var TimingAst = (function (_super) {
    __extends(TimingAst, _super);
    function TimingAst(duration, delay, easing) {
        if (delay === void 0) { delay = 0; }
        if (easing === void 0) { easing = null; }
        var _this = _super.call(this) || this;
        _this.duration = duration;
        _this.delay = delay;
        _this.easing = easing;
        return _this;
    }
    /**
     * @param {?} visitor
     * @param {?} context
     * @return {?}
     */
    TimingAst.prototype.visit = /**
     * @param {?} visitor
     * @param {?} context
     * @return {?}
     */
    function (visitor, context) { return visitor.visitTiming(this, context); };
    return TimingAst;
}(Ast));
var DynamicTimingAst = (function (_super) {
    __extends(DynamicTimingAst, _super);
    function DynamicTimingAst(value) {
        var _this = _super.call(this, 0, 0, '') || this;
        _this.value = value;
        return _this;
    }
    /**
     * @param {?} visitor
     * @param {?} context
     * @return {?}
     */
    DynamicTimingAst.prototype.visit = /**
     * @param {?} visitor
     * @param {?} context
     * @return {?}
     */
    function (visitor, context) { return visitor.visitTiming(this, context); };
    return DynamicTimingAst;
}(TimingAst));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @record
 */

/**
 * @param {?} visitor
 * @param {?} node
 * @param {?} context
 * @return {?}
 */
function visitAnimationNode(visitor, node, context) {
    switch (node.type) {
        case 7 /* Trigger */:
            return visitor.visitTrigger(/** @type {?} */ (node), context);
        case 0 /* State */:
            return visitor.visitState(/** @type {?} */ (node), context);
        case 1 /* Transition */:
            return visitor.visitTransition(/** @type {?} */ (node), context);
        case 2 /* Sequence */:
            return visitor.visitSequence(/** @type {?} */ (node), context);
        case 3 /* Group */:
            return visitor.visitGroup(/** @type {?} */ (node), context);
        case 4 /* Animate */:
            return visitor.visitAnimate(/** @type {?} */ (node), context);
        case 5 /* Keyframes */:
            return visitor.visitKeyframes(/** @type {?} */ (node), context);
        case 6 /* Style */:
            return visitor.visitStyle(/** @type {?} */ (node), context);
        case 8 /* Reference */:
            return visitor.visitReference(/** @type {?} */ (node), context);
        case 9 /* AnimateChild */:
            return visitor.visitAnimateChild(/** @type {?} */ (node), context);
        case 10 /* AnimateRef */:
            return visitor.visitAnimateRef(/** @type {?} */ (node), context);
        case 11 /* Query */:
            return visitor.visitQuery(/** @type {?} */ (node), context);
        case 12 /* Stagger */:
            return visitor.visitStagger(/** @type {?} */ (node), context);
        default:
            throw new Error("Unable to resolve animation metadata node #" + node.type);
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var ANY_STATE = '*';
/**
 * @param {?} transitionValue
 * @param {?} errors
 * @return {?}
 */
function parseTransitionExpr(transitionValue, errors) {
    var /** @type {?} */ expressions = [];
    if (typeof transitionValue == 'string') {
        (/** @type {?} */ (transitionValue))
            .split(/\s*,\s*/)
            .forEach(function (str) { return parseInnerTransitionStr(str, expressions, errors); });
    }
    else {
        expressions.push(/** @type {?} */ (transitionValue));
    }
    return expressions;
}
/**
 * @param {?} eventStr
 * @param {?} expressions
 * @param {?} errors
 * @return {?}
 */
function parseInnerTransitionStr(eventStr, expressions, errors) {
    if (eventStr[0] == ':') {
        var /** @type {?} */ result = parseAnimationAlias(eventStr, errors);
        if (typeof result == 'function') {
            expressions.push(result);
            return;
        }
        eventStr = /** @type {?} */ (result);
    }
    var /** @type {?} */ match = eventStr.match(/^(\*|[-\w]+)\s*(<?[=-]>)\s*(\*|[-\w]+)$/);
    if (match == null || match.length < 4) {
        errors.push("The provided transition expression \"" + eventStr + "\" is not supported");
        return expressions;
    }
    var /** @type {?} */ fromState = match[1];
    var /** @type {?} */ separator = match[2];
    var /** @type {?} */ toState = match[3];
    expressions.push(makeLambdaFromStates(fromState, toState));
    var /** @type {?} */ isFullAnyStateExpr = fromState == ANY_STATE && toState == ANY_STATE;
    if (separator[0] == '<' && !isFullAnyStateExpr) {
        expressions.push(makeLambdaFromStates(toState, fromState));
    }
}
/**
 * @param {?} alias
 * @param {?} errors
 * @return {?}
 */
function parseAnimationAlias(alias, errors) {
    switch (alias) {
        case ':enter':
            return 'void => *';
        case ':leave':
            return '* => void';
        case ':increment':
            return function (fromState, toState) { return parseFloat(toState) > parseFloat(fromState); };
        case ':decrement':
            return function (fromState, toState) { return parseFloat(toState) < parseFloat(fromState); };
        default:
            errors.push("The transition alias value \"" + alias + "\" is not supported");
            return '* => *';
    }
}
/**
 * @param {?} lhs
 * @param {?} rhs
 * @return {?}
 */
function makeLambdaFromStates(lhs, rhs) {
    return function (fromState, toState) {
        var /** @type {?} */ lhsMatch = lhs == ANY_STATE || lhs == fromState;
        var /** @type {?} */ rhsMatch = rhs == ANY_STATE || rhs == toState;
        if (!lhsMatch && typeof fromState === 'boolean') {
            lhsMatch = fromState ? lhs === 'true' : lhs === 'false';
        }
        if (!rhsMatch && typeof toState === 'boolean') {
            rhsMatch = toState ? rhs === 'true' : rhs === 'false';
        }
        return lhsMatch && rhsMatch;
    };
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var SELF_TOKEN = ':self';
var SELF_TOKEN_REGEX = new RegExp("s*" + SELF_TOKEN + "s*,?", 'g');
/**
 * @param {?} driver
 * @param {?} metadata
 * @param {?} errors
 * @return {?}
 */
function buildAnimationAst(driver, metadata, errors) {
    return new AnimationAstBuilderVisitor(driver).build(metadata, errors);
}
var LEAVE_TOKEN = ':leave';
var LEAVE_TOKEN_REGEX = new RegExp(LEAVE_TOKEN, 'g');
var ENTER_TOKEN = ':enter';
var ENTER_TOKEN_REGEX = new RegExp(ENTER_TOKEN, 'g');
var ROOT_SELECTOR = '';
var AnimationAstBuilderVisitor = (function () {
    function AnimationAstBuilderVisitor(_driver) {
        this._driver = _driver;
    }
    /**
     * @param {?} metadata
     * @param {?} errors
     * @return {?}
     */
    AnimationAstBuilderVisitor.prototype.build = /**
     * @param {?} metadata
     * @param {?} errors
     * @return {?}
     */
    function (metadata, errors) {
        var /** @type {?} */ context = new AnimationAstBuilderContext(errors);
        this._resetContextStyleTimingState(context);
        return /** @type {?} */ (visitAnimationNode(this, normalizeAnimationEntry(metadata), context));
    };
    /**
     * @param {?} context
     * @return {?}
     */
    AnimationAstBuilderVisitor.prototype._resetContextStyleTimingState = /**
     * @param {?} context
     * @return {?}
     */
    function (context) {
        context.currentQuerySelector = ROOT_SELECTOR;
        context.collectedStyles = {};
        context.collectedStyles[ROOT_SELECTOR] = {};
        context.currentTime = 0;
    };
    /**
     * @param {?} metadata
     * @param {?} context
     * @return {?}
     */
    AnimationAstBuilderVisitor.prototype.visitTrigger = /**
     * @param {?} metadata
     * @param {?} context
     * @return {?}
     */
    function (metadata, context) {
        var _this = this;
        var /** @type {?} */ queryCount = context.queryCount = 0;
        var /** @type {?} */ depCount = context.depCount = 0;
        var /** @type {?} */ states = [];
        var /** @type {?} */ transitions = [];
        metadata.definitions.forEach(function (def) {
            _this._resetContextStyleTimingState(context);
            if (def.type == 0 /* State */) {
                var /** @type {?} */ stateDef_1 = /** @type {?} */ (def);
                var /** @type {?} */ name_1 = stateDef_1.name;
                name_1.split(/\s*,\s*/).forEach(function (n) {
                    stateDef_1.name = n;
                    states.push(_this.visitState(stateDef_1, context));
                });
                stateDef_1.name = name_1;
            }
            else if (def.type == 1 /* Transition */) {
                var /** @type {?} */ transition = _this.visitTransition(/** @type {?} */ (def), context);
                queryCount += transition.queryCount;
                depCount += transition.depCount;
                transitions.push(transition);
            }
            else {
                context.errors.push('only state() and transition() definitions can sit inside of a trigger()');
            }
        });
        var /** @type {?} */ ast = new TriggerAst(metadata.name, states, transitions);
        ast.options = normalizeAnimationOptions(metadata.options);
        ast.queryCount = queryCount;
        ast.depCount = depCount;
        return ast;
    };
    /**
     * @param {?} metadata
     * @param {?} context
     * @return {?}
     */
    AnimationAstBuilderVisitor.prototype.visitState = /**
     * @param {?} metadata
     * @param {?} context
     * @return {?}
     */
    function (metadata, context) {
        var /** @type {?} */ styleAst = this.visitStyle(metadata.styles, context);
        var /** @type {?} */ astParams = (metadata.options && metadata.options.params) || null;
        if (styleAst.containsDynamicStyles) {
            var /** @type {?} */ missingSubs_1 = new Set();
            var /** @type {?} */ params_1 = astParams || {};
            styleAst.styles.forEach(function (value) {
                if (isObject(value)) {
                    var /** @type {?} */ stylesObj_1 = /** @type {?} */ (value);
                    Object.keys(stylesObj_1).forEach(function (prop) {
                        extractStyleParams(stylesObj_1[prop]).forEach(function (sub) {
                            if (!params_1.hasOwnProperty(sub)) {
                                missingSubs_1.add(sub);
                            }
                        });
                    });
                }
            });
            if (missingSubs_1.size) {
                var /** @type {?} */ missingSubsArr = iteratorToArray(missingSubs_1.values());
                context.errors.push("state(\"" + metadata.name + "\", ...) must define default values for all the following style substitutions: " + missingSubsArr.join(', '));
            }
        }
        var /** @type {?} */ stateAst = new StateAst(metadata.name, styleAst);
        if (astParams) {
            stateAst.options = { params: astParams };
        }
        return stateAst;
    };
    /**
     * @param {?} metadata
     * @param {?} context
     * @return {?}
     */
    AnimationAstBuilderVisitor.prototype.visitTransition = /**
     * @param {?} metadata
     * @param {?} context
     * @return {?}
     */
    function (metadata, context) {
        context.queryCount = 0;
        context.depCount = 0;
        var /** @type {?} */ entry = visitAnimationNode(this, normalizeAnimationEntry(metadata.animation), context);
        var /** @type {?} */ matchers = parseTransitionExpr(metadata.expr, context.errors);
        var /** @type {?} */ ast = new TransitionAst(matchers, entry);
        ast.options = normalizeAnimationOptions(metadata.options);
        ast.queryCount = context.queryCount;
        ast.depCount = context.depCount;
        return ast;
    };
    /**
     * @param {?} metadata
     * @param {?} context
     * @return {?}
     */
    AnimationAstBuilderVisitor.prototype.visitSequence = /**
     * @param {?} metadata
     * @param {?} context
     * @return {?}
     */
    function (metadata, context) {
        var _this = this;
        var /** @type {?} */ ast = new SequenceAst(metadata.steps.map(function (s) { return visitAnimationNode(_this, s, context); }));
        ast.options = normalizeAnimationOptions(metadata.options);
        return ast;
    };
    /**
     * @param {?} metadata
     * @param {?} context
     * @return {?}
     */
    AnimationAstBuilderVisitor.prototype.visitGroup = /**
     * @param {?} metadata
     * @param {?} context
     * @return {?}
     */
    function (metadata, context) {
        var _this = this;
        var /** @type {?} */ currentTime = context.currentTime;
        var /** @type {?} */ furthestTime = 0;
        var /** @type {?} */ steps = metadata.steps.map(function (step) {
            context.currentTime = currentTime;
            var /** @type {?} */ innerAst = visitAnimationNode(_this, step, context);
            furthestTime = Math.max(furthestTime, context.currentTime);
            return innerAst;
        });
        context.currentTime = furthestTime;
        var /** @type {?} */ ast = new GroupAst(steps);
        ast.options = normalizeAnimationOptions(metadata.options);
        return ast;
    };
    /**
     * @param {?} metadata
     * @param {?} context
     * @return {?}
     */
    AnimationAstBuilderVisitor.prototype.visitAnimate = /**
     * @param {?} metadata
     * @param {?} context
     * @return {?}
     */
    function (metadata, context) {
        var /** @type {?} */ timingAst = constructTimingAst(metadata.timings, context.errors);
        context.currentAnimateTimings = timingAst;
        var /** @type {?} */ styles;
        var /** @type {?} */ styleMetadata = metadata.styles ? metadata.styles : _angular_animations.style({});
        if (styleMetadata.type == 5 /* Keyframes */) {
            styles = this.visitKeyframes(/** @type {?} */ (styleMetadata), context);
        }
        else {
            var /** @type {?} */ styleMetadata_1 = /** @type {?} */ (metadata.styles);
            var /** @type {?} */ isEmpty = false;
            if (!styleMetadata_1) {
                isEmpty = true;
                var /** @type {?} */ newStyleData = {};
                if (timingAst.easing) {
                    newStyleData['easing'] = timingAst.easing;
                }
                styleMetadata_1 = _angular_animations.style(newStyleData);
            }
            context.currentTime += timingAst.duration + timingAst.delay;
            var /** @type {?} */ styleAst = this.visitStyle(styleMetadata_1, context);
            styleAst.isEmptyStep = isEmpty;
            styles = styleAst;
        }
        context.currentAnimateTimings = null;
        return new AnimateAst(timingAst, styles);
    };
    /**
     * @param {?} metadata
     * @param {?} context
     * @return {?}
     */
    AnimationAstBuilderVisitor.prototype.visitStyle = /**
     * @param {?} metadata
     * @param {?} context
     * @return {?}
     */
    function (metadata, context) {
        var /** @type {?} */ ast = this._makeStyleAst(metadata, context);
        this._validateStyleAst(ast, context);
        return ast;
    };
    /**
     * @param {?} metadata
     * @param {?} context
     * @return {?}
     */
    AnimationAstBuilderVisitor.prototype._makeStyleAst = /**
     * @param {?} metadata
     * @param {?} context
     * @return {?}
     */
    function (metadata, context) {
        var /** @type {?} */ styles = [];
        if (Array.isArray(metadata.styles)) {
            (/** @type {?} */ (metadata.styles)).forEach(function (styleTuple) {
                if (typeof styleTuple == 'string') {
                    if (styleTuple == _angular_animations.AUTO_STYLE) {
                        styles.push(/** @type {?} */ (styleTuple));
                    }
                    else {
                        context.errors.push("The provided style string value " + styleTuple + " is not allowed.");
                    }
                }
                else {
                    styles.push(/** @type {?} */ (styleTuple));
                }
            });
        }
        else {
            styles.push(metadata.styles);
        }
        var /** @type {?} */ containsDynamicStyles = false;
        var /** @type {?} */ collectedEasing = null;
        styles.forEach(function (styleData) {
            if (isObject(styleData)) {
                var /** @type {?} */ styleMap = /** @type {?} */ (styleData);
                var /** @type {?} */ easing = styleMap['easing'];
                if (easing) {
                    collectedEasing = /** @type {?} */ (easing);
                    delete styleMap['easing'];
                }
                if (!containsDynamicStyles) {
                    for (var /** @type {?} */ prop in styleMap) {
                        var /** @type {?} */ value = styleMap[prop];
                        if (value.toString().indexOf(SUBSTITUTION_EXPR_START) >= 0) {
                            containsDynamicStyles = true;
                            break;
                        }
                    }
                }
            }
        });
        var /** @type {?} */ ast = new StyleAst(styles, collectedEasing, metadata.offset);
        ast.containsDynamicStyles = containsDynamicStyles;
        return ast;
    };
    /**
     * @param {?} ast
     * @param {?} context
     * @return {?}
     */
    AnimationAstBuilderVisitor.prototype._validateStyleAst = /**
     * @param {?} ast
     * @param {?} context
     * @return {?}
     */
    function (ast, context) {
        var _this = this;
        var /** @type {?} */ timings = context.currentAnimateTimings;
        var /** @type {?} */ endTime = context.currentTime;
        var /** @type {?} */ startTime = context.currentTime;
        if (timings && startTime > 0) {
            startTime -= timings.duration + timings.delay;
        }
        ast.styles.forEach(function (tuple) {
            if (typeof tuple == 'string')
                return;
            Object.keys(tuple).forEach(function (prop) {
                if (!_this._driver.validateStyleProperty(prop)) {
                    context.errors.push("The provided animation property \"" + prop + "\" is not a supported CSS property for animations");
                    return;
                }
                var /** @type {?} */ collectedStyles = context.collectedStyles[/** @type {?} */ ((context.currentQuerySelector))];
                var /** @type {?} */ collectedEntry = collectedStyles[prop];
                var /** @type {?} */ updateCollectedStyle = true;
                if (collectedEntry) {
                    if (startTime != endTime && startTime >= collectedEntry.startTime &&
                        endTime <= collectedEntry.endTime) {
                        context.errors.push("The CSS property \"" + prop + "\" that exists between the times of \"" + collectedEntry.startTime + "ms\" and \"" + collectedEntry.endTime + "ms\" is also being animated in a parallel animation between the times of \"" + startTime + "ms\" and \"" + endTime + "ms\"");
                        updateCollectedStyle = false;
                    }
                    // we always choose the smaller start time value since we
                    // want to have a record of the entire animation window where
                    // the style property is being animated in between
                    startTime = collectedEntry.startTime;
                }
                if (updateCollectedStyle) {
                    collectedStyles[prop] = { startTime: startTime, endTime: endTime };
                }
                if (context.options) {
                    validateStyleParams(tuple[prop], context.options, context.errors);
                }
            });
        });
    };
    /**
     * @param {?} metadata
     * @param {?} context
     * @return {?}
     */
    AnimationAstBuilderVisitor.prototype.visitKeyframes = /**
     * @param {?} metadata
     * @param {?} context
     * @return {?}
     */
    function (metadata, context) {
        var _this = this;
        if (!context.currentAnimateTimings) {
            context.errors.push("keyframes() must be placed inside of a call to animate()");
            return new KeyframesAst([]);
        }
        var /** @type {?} */ MAX_KEYFRAME_OFFSET = 1;
        var /** @type {?} */ totalKeyframesWithOffsets = 0;
        var /** @type {?} */ offsets = [];
        var /** @type {?} */ offsetsOutOfOrder = false;
        var /** @type {?} */ keyframesOutOfRange = false;
        var /** @type {?} */ previousOffset = 0;
        var /** @type {?} */ keyframes = metadata.steps.map(function (styles) {
            var /** @type {?} */ style$$1 = _this._makeStyleAst(styles, context);
            var /** @type {?} */ offsetVal = style$$1.offset != null ? style$$1.offset : consumeOffset(style$$1.styles);
            var /** @type {?} */ offset = 0;
            if (offsetVal != null) {
                totalKeyframesWithOffsets++;
                offset = style$$1.offset = offsetVal;
            }
            keyframesOutOfRange = keyframesOutOfRange || offset < 0 || offset > 1;
            offsetsOutOfOrder = offsetsOutOfOrder || offset < previousOffset;
            previousOffset = offset;
            offsets.push(offset);
            return style$$1;
        });
        if (keyframesOutOfRange) {
            context.errors.push("Please ensure that all keyframe offsets are between 0 and 1");
        }
        if (offsetsOutOfOrder) {
            context.errors.push("Please ensure that all keyframe offsets are in order");
        }
        var /** @type {?} */ length = metadata.steps.length;
        var /** @type {?} */ generatedOffset = 0;
        if (totalKeyframesWithOffsets > 0 && totalKeyframesWithOffsets < length) {
            context.errors.push("Not all style() steps within the declared keyframes() contain offsets");
        }
        else if (totalKeyframesWithOffsets == 0) {
            generatedOffset = MAX_KEYFRAME_OFFSET / (length - 1);
        }
        var /** @type {?} */ limit = length - 1;
        var /** @type {?} */ currentTime = context.currentTime;
        var /** @type {?} */ currentAnimateTimings = /** @type {?} */ ((context.currentAnimateTimings));
        var /** @type {?} */ animateDuration = currentAnimateTimings.duration;
        keyframes.forEach(function (kf, i) {
            var /** @type {?} */ offset = generatedOffset > 0 ? (i == limit ? 1 : (generatedOffset * i)) : offsets[i];
            var /** @type {?} */ durationUpToThisFrame = offset * animateDuration;
            context.currentTime = currentTime + currentAnimateTimings.delay + durationUpToThisFrame;
            currentAnimateTimings.duration = durationUpToThisFrame;
            _this._validateStyleAst(kf, context);
            kf.offset = offset;
        });
        return new KeyframesAst(keyframes);
    };
    /**
     * @param {?} metadata
     * @param {?} context
     * @return {?}
     */
    AnimationAstBuilderVisitor.prototype.visitReference = /**
     * @param {?} metadata
     * @param {?} context
     * @return {?}
     */
    function (metadata, context) {
        var /** @type {?} */ entry = visitAnimationNode(this, normalizeAnimationEntry(metadata.animation), context);
        var /** @type {?} */ ast = new ReferenceAst(entry);
        ast.options = normalizeAnimationOptions(metadata.options);
        return ast;
    };
    /**
     * @param {?} metadata
     * @param {?} context
     * @return {?}
     */
    AnimationAstBuilderVisitor.prototype.visitAnimateChild = /**
     * @param {?} metadata
     * @param {?} context
     * @return {?}
     */
    function (metadata, context) {
        context.depCount++;
        var /** @type {?} */ ast = new AnimateChildAst();
        ast.options = normalizeAnimationOptions(metadata.options);
        return ast;
    };
    /**
     * @param {?} metadata
     * @param {?} context
     * @return {?}
     */
    AnimationAstBuilderVisitor.prototype.visitAnimateRef = /**
     * @param {?} metadata
     * @param {?} context
     * @return {?}
     */
    function (metadata, context) {
        var /** @type {?} */ animation = this.visitReference(metadata.animation, context);
        var /** @type {?} */ ast = new AnimateRefAst(animation);
        ast.options = normalizeAnimationOptions(metadata.options);
        return ast;
    };
    /**
     * @param {?} metadata
     * @param {?} context
     * @return {?}
     */
    AnimationAstBuilderVisitor.prototype.visitQuery = /**
     * @param {?} metadata
     * @param {?} context
     * @return {?}
     */
    function (metadata, context) {
        var /** @type {?} */ parentSelector = /** @type {?} */ ((context.currentQuerySelector));
        var /** @type {?} */ options = /** @type {?} */ ((metadata.options || {}));
        context.queryCount++;
        context.currentQuery = metadata;
        var _a = normalizeSelector(metadata.selector), selector = _a[0], includeSelf = _a[1];
        context.currentQuerySelector =
            parentSelector.length ? (parentSelector + ' ' + selector) : selector;
        getOrSetAsInMap(context.collectedStyles, context.currentQuerySelector, {});
        var /** @type {?} */ entry = visitAnimationNode(this, normalizeAnimationEntry(metadata.animation), context);
        context.currentQuery = null;
        context.currentQuerySelector = parentSelector;
        var /** @type {?} */ ast = new QueryAst(selector, options.limit || 0, !!options.optional, includeSelf, entry);
        ast.originalSelector = metadata.selector;
        ast.options = normalizeAnimationOptions(metadata.options);
        return ast;
    };
    /**
     * @param {?} metadata
     * @param {?} context
     * @return {?}
     */
    AnimationAstBuilderVisitor.prototype.visitStagger = /**
     * @param {?} metadata
     * @param {?} context
     * @return {?}
     */
    function (metadata, context) {
        if (!context.currentQuery) {
            context.errors.push("stagger() can only be used inside of query()");
        }
        var /** @type {?} */ timings = metadata.timings === 'full' ?
            { duration: 0, delay: 0, easing: 'full' } :
            resolveTiming(metadata.timings, context.errors, true);
        var /** @type {?} */ animation = visitAnimationNode(this, normalizeAnimationEntry(metadata.animation), context);
        return new StaggerAst(timings, animation);
    };
    return AnimationAstBuilderVisitor;
}());
/**
 * @param {?} selector
 * @return {?}
 */
function normalizeSelector(selector) {
    var /** @type {?} */ hasAmpersand = selector.split(/\s*,\s*/).find(function (token) { return token == SELF_TOKEN; }) ? true : false;
    if (hasAmpersand) {
        selector = selector.replace(SELF_TOKEN_REGEX, '');
    }
    selector = selector.replace(ENTER_TOKEN_REGEX, ENTER_SELECTOR)
        .replace(LEAVE_TOKEN_REGEX, LEAVE_SELECTOR)
        .replace(/@\*/g, NG_TRIGGER_SELECTOR)
        .replace(/@\w+/g, function (match) { return NG_TRIGGER_SELECTOR + '-' + match.substr(1); })
        .replace(/:animating/g, NG_ANIMATING_SELECTOR);
    return [selector, hasAmpersand];
}
/**
 * @param {?} obj
 * @return {?}
 */
function normalizeParams(obj) {
    return obj ? copyObj(obj) : null;
}
var AnimationAstBuilderContext = (function () {
    function AnimationAstBuilderContext(errors) {
        this.errors = errors;
        this.queryCount = 0;
        this.depCount = 0;
        this.currentTransition = null;
        this.currentQuery = null;
        this.currentQuerySelector = null;
        this.currentAnimateTimings = null;
        this.currentTime = 0;
        this.collectedStyles = {};
        this.options = null;
    }
    return AnimationAstBuilderContext;
}());
/**
 * @param {?} styles
 * @return {?}
 */
function consumeOffset(styles) {
    if (typeof styles == 'string')
        return null;
    var /** @type {?} */ offset = null;
    if (Array.isArray(styles)) {
        styles.forEach(function (styleTuple) {
            if (isObject(styleTuple) && styleTuple.hasOwnProperty('offset')) {
                var /** @type {?} */ obj = /** @type {?} */ (styleTuple);
                offset = parseFloat(/** @type {?} */ (obj['offset']));
                delete obj['offset'];
            }
        });
    }
    else if (isObject(styles) && styles.hasOwnProperty('offset')) {
        var /** @type {?} */ obj = /** @type {?} */ (styles);
        offset = parseFloat(/** @type {?} */ (obj['offset']));
        delete obj['offset'];
    }
    return offset;
}
/**
 * @param {?} value
 * @return {?}
 */
function isObject(value) {
    return !Array.isArray(value) && typeof value == 'object';
}
/**
 * @param {?} value
 * @param {?} errors
 * @return {?}
 */
function constructTimingAst(value, errors) {
    var /** @type {?} */ timings = null;
    if (value.hasOwnProperty('duration')) {
        timings = /** @type {?} */ (value);
    }
    else if (typeof value == 'number') {
        var /** @type {?} */ duration = resolveTiming(/** @type {?} */ (value), errors).duration;
        return new TimingAst(/** @type {?} */ (value), 0, '');
    }
    var /** @type {?} */ strValue = /** @type {?} */ (value);
    var /** @type {?} */ isDynamic = strValue.split(/\s+/).some(function (v) { return v.charAt(0) == '{' && v.charAt(1) == '{'; });
    if (isDynamic) {
        return new DynamicTimingAst(strValue);
    }
    timings = timings || resolveTiming(strValue, errors);
    return new TimingAst(timings.duration, timings.delay, timings.easing);
}
/**
 * @param {?} options
 * @return {?}
 */
function normalizeAnimationOptions(options) {
    if (options) {
        options = copyObj(options);
        if (options['params']) {
            options['params'] = /** @type {?} */ ((normalizeParams(options['params'])));
        }
    }
    else {
        options = {};
    }
    return options;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @record
 */

/**
 * @param {?} element
 * @param {?} keyframes
 * @param {?} preStyleProps
 * @param {?} postStyleProps
 * @param {?} duration
 * @param {?} delay
 * @param {?=} easing
 * @param {?=} subTimeline
 * @return {?}
 */
function createTimelineInstruction(element, keyframes, preStyleProps, postStyleProps, duration, delay, easing, subTimeline) {
    if (easing === void 0) { easing = null; }
    if (subTimeline === void 0) { subTimeline = false; }
    return {
        type: 1 /* TimelineAnimation */,
        element: element,
        keyframes: keyframes,
        preStyleProps: preStyleProps,
        postStyleProps: postStyleProps,
        duration: duration,
        delay: delay,
        totalTime: duration + delay, easing: easing, subTimeline: subTimeline
    };
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var ElementInstructionMap = (function () {
    function ElementInstructionMap() {
        this._map = new Map();
    }
    /**
     * @param {?} element
     * @return {?}
     */
    ElementInstructionMap.prototype.consume = /**
     * @param {?} element
     * @return {?}
     */
    function (element) {
        var /** @type {?} */ instructions = this._map.get(element);
        if (instructions) {
            this._map.delete(element);
        }
        else {
            instructions = [];
        }
        return instructions;
    };
    /**
     * @param {?} element
     * @param {?} instructions
     * @return {?}
     */
    ElementInstructionMap.prototype.append = /**
     * @param {?} element
     * @param {?} instructions
     * @return {?}
     */
    function (element, instructions) {
        var /** @type {?} */ existingInstructions = this._map.get(element);
        if (!existingInstructions) {
            this._map.set(element, existingInstructions = []);
        }
        existingInstructions.push.apply(existingInstructions, instructions);
    };
    /**
     * @param {?} element
     * @return {?}
     */
    ElementInstructionMap.prototype.has = /**
     * @param {?} element
     * @return {?}
     */
    function (element) { return this._map.has(element); };
    /**
     * @return {?}
     */
    ElementInstructionMap.prototype.clear = /**
     * @return {?}
     */
    function () { this._map.clear(); };
    return ElementInstructionMap;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var ONE_FRAME_IN_MILLISECONDS = 1;
/**
 * @param {?} driver
 * @param {?} rootElement
 * @param {?} ast
 * @param {?=} startingStyles
 * @param {?=} finalStyles
 * @param {?=} options
 * @param {?=} subInstructions
 * @param {?=} errors
 * @return {?}
 */
function buildAnimationTimelines(driver, rootElement, ast, startingStyles, finalStyles, options, subInstructions, errors) {
    if (startingStyles === void 0) { startingStyles = {}; }
    if (finalStyles === void 0) { finalStyles = {}; }
    if (errors === void 0) { errors = []; }
    return new AnimationTimelineBuilderVisitor().buildKeyframes(driver, rootElement, ast, startingStyles, finalStyles, options, subInstructions, errors);
}
var AnimationTimelineBuilderVisitor = (function () {
    function AnimationTimelineBuilderVisitor() {
    }
    /**
     * @param {?} driver
     * @param {?} rootElement
     * @param {?} ast
     * @param {?} startingStyles
     * @param {?} finalStyles
     * @param {?} options
     * @param {?=} subInstructions
     * @param {?=} errors
     * @return {?}
     */
    AnimationTimelineBuilderVisitor.prototype.buildKeyframes = /**
     * @param {?} driver
     * @param {?} rootElement
     * @param {?} ast
     * @param {?} startingStyles
     * @param {?} finalStyles
     * @param {?} options
     * @param {?=} subInstructions
     * @param {?=} errors
     * @return {?}
     */
    function (driver, rootElement, ast, startingStyles, finalStyles, options, subInstructions, errors) {
        if (errors === void 0) { errors = []; }
        subInstructions = subInstructions || new ElementInstructionMap();
        var /** @type {?} */ context = new AnimationTimelineContext(driver, rootElement, subInstructions, errors, []);
        context.options = options;
        context.currentTimeline.setStyles([startingStyles], null, context.errors, options);
        ast.visit(this, context);
        // this checks to see if an actual animation happened
        var /** @type {?} */ timelines = context.timelines.filter(function (timeline) { return timeline.containsAnimation(); });
        if (timelines.length && Object.keys(finalStyles).length) {
            var /** @type {?} */ tl = timelines[timelines.length - 1];
            if (!tl.allowOnlyTimelineStyles()) {
                tl.setStyles([finalStyles], null, context.errors, options);
            }
        }
        return timelines.length ? timelines.map(function (timeline) { return timeline.buildKeyframes(); }) :
            [createTimelineInstruction(rootElement, [], [], [], 0, 0, '', false)];
    };
    /**
     * @param {?} ast
     * @param {?} context
     * @return {?}
     */
    AnimationTimelineBuilderVisitor.prototype.visitTrigger = /**
     * @param {?} ast
     * @param {?} context
     * @return {?}
     */
    function (ast, context) {
        // these values are not visited in this AST
    };
    /**
     * @param {?} ast
     * @param {?} context
     * @return {?}
     */
    AnimationTimelineBuilderVisitor.prototype.visitState = /**
     * @param {?} ast
     * @param {?} context
     * @return {?}
     */
    function (ast, context) {
        // these values are not visited in this AST
    };
    /**
     * @param {?} ast
     * @param {?} context
     * @return {?}
     */
    AnimationTimelineBuilderVisitor.prototype.visitTransition = /**
     * @param {?} ast
     * @param {?} context
     * @return {?}
     */
    function (ast, context) {
        // these values are not visited in this AST
    };
    /**
     * @param {?} ast
     * @param {?} context
     * @return {?}
     */
    AnimationTimelineBuilderVisitor.prototype.visitAnimateChild = /**
     * @param {?} ast
     * @param {?} context
     * @return {?}
     */
    function (ast, context) {
        var /** @type {?} */ elementInstructions = context.subInstructions.consume(context.element);
        if (elementInstructions) {
            var /** @type {?} */ innerContext = context.createSubContext(ast.options);
            var /** @type {?} */ startTime = context.currentTimeline.currentTime;
            var /** @type {?} */ endTime = this._visitSubInstructions(elementInstructions, innerContext, /** @type {?} */ (innerContext.options));
            if (startTime != endTime) {
                // we do this on the upper context because we created a sub context for
                // the sub child animations
                context.transformIntoNewTimeline(endTime);
            }
        }
        context.previousNode = ast;
    };
    /**
     * @param {?} ast
     * @param {?} context
     * @return {?}
     */
    AnimationTimelineBuilderVisitor.prototype.visitAnimateRef = /**
     * @param {?} ast
     * @param {?} context
     * @return {?}
     */
    function (ast, context) {
        var /** @type {?} */ innerContext = context.createSubContext(ast.options);
        innerContext.transformIntoNewTimeline();
        this.visitReference(ast.animation, innerContext);
        context.transformIntoNewTimeline(innerContext.currentTimeline.currentTime);
        context.previousNode = ast;
    };
    /**
     * @param {?} instructions
     * @param {?} context
     * @param {?} options
     * @return {?}
     */
    AnimationTimelineBuilderVisitor.prototype._visitSubInstructions = /**
     * @param {?} instructions
     * @param {?} context
     * @param {?} options
     * @return {?}
     */
    function (instructions, context, options) {
        var /** @type {?} */ startTime = context.currentTimeline.currentTime;
        var /** @type {?} */ furthestTime = startTime;
        // this is a special-case for when a user wants to skip a sub
        // animation from being fired entirely.
        var /** @type {?} */ duration = options.duration != null ? resolveTimingValue(options.duration) : null;
        var /** @type {?} */ delay = options.delay != null ? resolveTimingValue(options.delay) : null;
        if (duration !== 0) {
            instructions.forEach(function (instruction) {
                var /** @type {?} */ instructionTimings = context.appendInstructionToTimeline(instruction, duration, delay);
                furthestTime =
                    Math.max(furthestTime, instructionTimings.duration + instructionTimings.delay);
            });
        }
        return furthestTime;
    };
    /**
     * @param {?} ast
     * @param {?} context
     * @return {?}
     */
    AnimationTimelineBuilderVisitor.prototype.visitReference = /**
     * @param {?} ast
     * @param {?} context
     * @return {?}
     */
    function (ast, context) {
        context.updateOptions(ast.options, true);
        ast.animation.visit(this, context);
        context.previousNode = ast;
    };
    /**
     * @param {?} ast
     * @param {?} context
     * @return {?}
     */
    AnimationTimelineBuilderVisitor.prototype.visitSequence = /**
     * @param {?} ast
     * @param {?} context
     * @return {?}
     */
    function (ast, context) {
        var _this = this;
        var /** @type {?} */ subContextCount = context.subContextCount;
        var /** @type {?} */ ctx = context;
        var /** @type {?} */ options = ast.options;
        if (options && (options.params || options.delay)) {
            ctx = context.createSubContext(options);
            ctx.transformIntoNewTimeline();
            if (options.delay != null) {
                if (ctx.previousNode instanceof StyleAst) {
                    ctx.currentTimeline.snapshotCurrentStyles();
                    ctx.previousNode = DEFAULT_NOOP_PREVIOUS_NODE;
                }
                var /** @type {?} */ delay = resolveTimingValue(options.delay);
                ctx.delayNextStep(delay);
            }
        }
        if (ast.steps.length) {
            ast.steps.forEach(function (s) { return s.visit(_this, ctx); });
            // this is here just incase the inner steps only contain or end with a style() call
            ctx.currentTimeline.applyStylesToKeyframe();
            // this means that some animation function within the sequence
            // ended up creating a sub timeline (which means the current
            // timeline cannot overlap with the contents of the sequence)
            if (ctx.subContextCount > subContextCount) {
                ctx.transformIntoNewTimeline();
            }
        }
        context.previousNode = ast;
    };
    /**
     * @param {?} ast
     * @param {?} context
     * @return {?}
     */
    AnimationTimelineBuilderVisitor.prototype.visitGroup = /**
     * @param {?} ast
     * @param {?} context
     * @return {?}
     */
    function (ast, context) {
        var _this = this;
        var /** @type {?} */ innerTimelines = [];
        var /** @type {?} */ furthestTime = context.currentTimeline.currentTime;
        var /** @type {?} */ delay = ast.options && ast.options.delay ? resolveTimingValue(ast.options.delay) : 0;
        ast.steps.forEach(function (s) {
            var /** @type {?} */ innerContext = context.createSubContext(ast.options);
            if (delay) {
                innerContext.delayNextStep(delay);
            }
            s.visit(_this, innerContext);
            furthestTime = Math.max(furthestTime, innerContext.currentTimeline.currentTime);
            innerTimelines.push(innerContext.currentTimeline);
        });
        // this operation is run after the AST loop because otherwise
        // if the parent timeline's collected styles were updated then
        // it would pass in invalid data into the new-to-be forked items
        innerTimelines.forEach(function (timeline) { return context.currentTimeline.mergeTimelineCollectedStyles(timeline); });
        context.transformIntoNewTimeline(furthestTime);
        context.previousNode = ast;
    };
    /**
     * @param {?} ast
     * @param {?} context
     * @return {?}
     */
    AnimationTimelineBuilderVisitor.prototype.visitTiming = /**
     * @param {?} ast
     * @param {?} context
     * @return {?}
     */
    function (ast, context) {
        if (ast instanceof DynamicTimingAst) {
            var /** @type {?} */ strValue = context.params ?
                interpolateParams(ast.value, context.params, context.errors) :
                ast.value.toString();
            return resolveTiming(strValue, context.errors);
        }
        else {
            return { duration: ast.duration, delay: ast.delay, easing: ast.easing };
        }
    };
    /**
     * @param {?} ast
     * @param {?} context
     * @return {?}
     */
    AnimationTimelineBuilderVisitor.prototype.visitAnimate = /**
     * @param {?} ast
     * @param {?} context
     * @return {?}
     */
    function (ast, context) {
        var /** @type {?} */ timings = context.currentAnimateTimings = this.visitTiming(ast.timings, context);
        var /** @type {?} */ timeline = context.currentTimeline;
        if (timings.delay) {
            context.incrementTime(timings.delay);
            timeline.snapshotCurrentStyles();
        }
        var /** @type {?} */ style$$1 = ast.style;
        if (style$$1 instanceof KeyframesAst) {
            this.visitKeyframes(style$$1, context);
        }
        else {
            context.incrementTime(timings.duration);
            this.visitStyle(/** @type {?} */ (style$$1), context);
            timeline.applyStylesToKeyframe();
        }
        context.currentAnimateTimings = null;
        context.previousNode = ast;
    };
    /**
     * @param {?} ast
     * @param {?} context
     * @return {?}
     */
    AnimationTimelineBuilderVisitor.prototype.visitStyle = /**
     * @param {?} ast
     * @param {?} context
     * @return {?}
     */
    function (ast, context) {
        var /** @type {?} */ timeline = context.currentTimeline;
        var /** @type {?} */ timings = /** @type {?} */ ((context.currentAnimateTimings));
        // this is a special case for when a style() call
        // directly follows  an animate() call (but not inside of an animate() call)
        if (!timings && timeline.getCurrentStyleProperties().length) {
            timeline.forwardFrame();
        }
        var /** @type {?} */ easing = (timings && timings.easing) || ast.easing;
        if (ast.isEmptyStep) {
            timeline.applyEmptyStep(easing);
        }
        else {
            timeline.setStyles(ast.styles, easing, context.errors, context.options);
        }
        context.previousNode = ast;
    };
    /**
     * @param {?} ast
     * @param {?} context
     * @return {?}
     */
    AnimationTimelineBuilderVisitor.prototype.visitKeyframes = /**
     * @param {?} ast
     * @param {?} context
     * @return {?}
     */
    function (ast, context) {
        var /** @type {?} */ currentAnimateTimings = /** @type {?} */ ((context.currentAnimateTimings));
        var /** @type {?} */ startTime = (/** @type {?} */ ((context.currentTimeline))).duration;
        var /** @type {?} */ duration = currentAnimateTimings.duration;
        var /** @type {?} */ innerContext = context.createSubContext();
        var /** @type {?} */ innerTimeline = innerContext.currentTimeline;
        innerTimeline.easing = currentAnimateTimings.easing;
        ast.styles.forEach(function (step) {
            var /** @type {?} */ offset = step.offset || 0;
            innerTimeline.forwardTime(offset * duration);
            innerTimeline.setStyles(step.styles, step.easing, context.errors, context.options);
            innerTimeline.applyStylesToKeyframe();
        });
        // this will ensure that the parent timeline gets all the styles from
        // the child even if the new timeline below is not used
        context.currentTimeline.mergeTimelineCollectedStyles(innerTimeline);
        // we do this because the window between this timeline and the sub timeline
        // should ensure that the styles within are exactly the same as they were before
        context.transformIntoNewTimeline(startTime + duration);
        context.previousNode = ast;
    };
    /**
     * @param {?} ast
     * @param {?} context
     * @return {?}
     */
    AnimationTimelineBuilderVisitor.prototype.visitQuery = /**
     * @param {?} ast
     * @param {?} context
     * @return {?}
     */
    function (ast, context) {
        var _this = this;
        // in the event that the first step before this is a style step we need
        // to ensure the styles are applied before the children are animated
        var /** @type {?} */ startTime = context.currentTimeline.currentTime;
        var /** @type {?} */ options = /** @type {?} */ ((ast.options || {}));
        var /** @type {?} */ delay = options.delay ? resolveTimingValue(options.delay) : 0;
        if (delay && (context.previousNode instanceof StyleAst ||
            (startTime == 0 && context.currentTimeline.getCurrentStyleProperties().length))) {
            context.currentTimeline.snapshotCurrentStyles();
            context.previousNode = DEFAULT_NOOP_PREVIOUS_NODE;
        }
        var /** @type {?} */ furthestTime = startTime;
        var /** @type {?} */ elms = context.invokeQuery(ast.selector, ast.originalSelector, ast.limit, ast.includeSelf, options.optional ? true : false, context.errors);
        context.currentQueryTotal = elms.length;
        var /** @type {?} */ sameElementTimeline = null;
        elms.forEach(function (element, i) {
            context.currentQueryIndex = i;
            var /** @type {?} */ innerContext = context.createSubContext(ast.options, element);
            if (delay) {
                innerContext.delayNextStep(delay);
            }
            if (element === context.element) {
                sameElementTimeline = innerContext.currentTimeline;
            }
            ast.animation.visit(_this, innerContext);
            // this is here just incase the inner steps only contain or end
            // with a style() call (which is here to signal that this is a preparatory
            // call to style an element before it is animated again)
            innerContext.currentTimeline.applyStylesToKeyframe();
            var /** @type {?} */ endTime = innerContext.currentTimeline.currentTime;
            furthestTime = Math.max(furthestTime, endTime);
        });
        context.currentQueryIndex = 0;
        context.currentQueryTotal = 0;
        context.transformIntoNewTimeline(furthestTime);
        if (sameElementTimeline) {
            context.currentTimeline.mergeTimelineCollectedStyles(sameElementTimeline);
            context.currentTimeline.snapshotCurrentStyles();
        }
        context.previousNode = ast;
    };
    /**
     * @param {?} ast
     * @param {?} context
     * @return {?}
     */
    AnimationTimelineBuilderVisitor.prototype.visitStagger = /**
     * @param {?} ast
     * @param {?} context
     * @return {?}
     */
    function (ast, context) {
        var /** @type {?} */ parentContext = /** @type {?} */ ((context.parentContext));
        var /** @type {?} */ tl = context.currentTimeline;
        var /** @type {?} */ timings = ast.timings;
        var /** @type {?} */ duration = Math.abs(timings.duration);
        var /** @type {?} */ maxTime = duration * (context.currentQueryTotal - 1);
        var /** @type {?} */ delay = duration * context.currentQueryIndex;
        var /** @type {?} */ staggerTransformer = timings.duration < 0 ? 'reverse' : timings.easing;
        switch (staggerTransformer) {
            case 'reverse':
                delay = maxTime - delay;
                break;
            case 'full':
                delay = parentContext.currentStaggerTime;
                break;
        }
        var /** @type {?} */ timeline = context.currentTimeline;
        if (delay) {
            timeline.delayNextStep(delay);
        }
        var /** @type {?} */ startingTime = timeline.currentTime;
        ast.animation.visit(this, context);
        context.previousNode = ast;
        // time = duration + delay
        // the reason why this computation is so complex is because
        // the inner timeline may either have a delay value or a stretched
        // keyframe depending on if a subtimeline is not used or is used.
        parentContext.currentStaggerTime =
            (tl.currentTime - startingTime) + (tl.startTime - parentContext.currentTimeline.startTime);
    };
    return AnimationTimelineBuilderVisitor;
}());
var DEFAULT_NOOP_PREVIOUS_NODE = /** @type {?} */ ({});
var AnimationTimelineContext = (function () {
    function AnimationTimelineContext(_driver, element, subInstructions, errors, timelines, initialTimeline) {
        this._driver = _driver;
        this.element = element;
        this.subInstructions = subInstructions;
        this.errors = errors;
        this.timelines = timelines;
        this.parentContext = null;
        this.currentAnimateTimings = null;
        this.previousNode = DEFAULT_NOOP_PREVIOUS_NODE;
        this.subContextCount = 0;
        this.options = {};
        this.currentQueryIndex = 0;
        this.currentQueryTotal = 0;
        this.currentStaggerTime = 0;
        this.currentTimeline = initialTimeline || new TimelineBuilder(this._driver, element, 0);
        timelines.push(this.currentTimeline);
    }
    Object.defineProperty(AnimationTimelineContext.prototype, "params", {
        get: /**
         * @return {?}
         */
        function () { return this.options.params; },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} options
     * @param {?=} skipIfExists
     * @return {?}
     */
    AnimationTimelineContext.prototype.updateOptions = /**
     * @param {?} options
     * @param {?=} skipIfExists
     * @return {?}
     */
    function (options, skipIfExists) {
        var _this = this;
        if (!options)
            return;
        var /** @type {?} */ newOptions = /** @type {?} */ (options);
        var /** @type {?} */ optionsToUpdate = this.options;
        // NOTE: this will get patched up when other animation methods support duration overrides
        if (newOptions.duration != null) {
            (/** @type {?} */ (optionsToUpdate)).duration = resolveTimingValue(newOptions.duration);
        }
        if (newOptions.delay != null) {
            optionsToUpdate.delay = resolveTimingValue(newOptions.delay);
        }
        var /** @type {?} */ newParams = newOptions.params;
        if (newParams) {
            var /** @type {?} */ paramsToUpdate_1 = /** @type {?} */ ((optionsToUpdate.params));
            if (!paramsToUpdate_1) {
                paramsToUpdate_1 = this.options.params = {};
            }
            Object.keys(newParams).forEach(function (name) {
                if (!skipIfExists || !paramsToUpdate_1.hasOwnProperty(name)) {
                    paramsToUpdate_1[name] = interpolateParams(newParams[name], paramsToUpdate_1, _this.errors);
                }
            });
        }
    };
    /**
     * @return {?}
     */
    AnimationTimelineContext.prototype._copyOptions = /**
     * @return {?}
     */
    function () {
        var /** @type {?} */ options = {};
        if (this.options) {
            var /** @type {?} */ oldParams_1 = this.options.params;
            if (oldParams_1) {
                var /** @type {?} */ params_1 = options['params'] = {};
                Object.keys(this.options.params).forEach(function (name) { params_1[name] = oldParams_1[name]; });
            }
        }
        return options;
    };
    /**
     * @param {?=} options
     * @param {?=} element
     * @param {?=} newTime
     * @return {?}
     */
    AnimationTimelineContext.prototype.createSubContext = /**
     * @param {?=} options
     * @param {?=} element
     * @param {?=} newTime
     * @return {?}
     */
    function (options, element, newTime) {
        if (options === void 0) { options = null; }
        var /** @type {?} */ target = element || this.element;
        var /** @type {?} */ context = new AnimationTimelineContext(this._driver, target, this.subInstructions, this.errors, this.timelines, this.currentTimeline.fork(target, newTime || 0));
        context.previousNode = this.previousNode;
        context.currentAnimateTimings = this.currentAnimateTimings;
        context.options = this._copyOptions();
        context.updateOptions(options);
        context.currentQueryIndex = this.currentQueryIndex;
        context.currentQueryTotal = this.currentQueryTotal;
        context.parentContext = this;
        this.subContextCount++;
        return context;
    };
    /**
     * @param {?=} newTime
     * @return {?}
     */
    AnimationTimelineContext.prototype.transformIntoNewTimeline = /**
     * @param {?=} newTime
     * @return {?}
     */
    function (newTime) {
        this.previousNode = DEFAULT_NOOP_PREVIOUS_NODE;
        this.currentTimeline = this.currentTimeline.fork(this.element, newTime);
        this.timelines.push(this.currentTimeline);
        return this.currentTimeline;
    };
    /**
     * @param {?} instruction
     * @param {?} duration
     * @param {?} delay
     * @return {?}
     */
    AnimationTimelineContext.prototype.appendInstructionToTimeline = /**
     * @param {?} instruction
     * @param {?} duration
     * @param {?} delay
     * @return {?}
     */
    function (instruction, duration, delay) {
        var /** @type {?} */ updatedTimings = {
            duration: duration != null ? duration : instruction.duration,
            delay: this.currentTimeline.currentTime + (delay != null ? delay : 0) + instruction.delay,
            easing: ''
        };
        var /** @type {?} */ builder = new SubTimelineBuilder(this._driver, instruction.element, instruction.keyframes, instruction.preStyleProps, instruction.postStyleProps, updatedTimings, instruction.stretchStartingKeyframe);
        this.timelines.push(builder);
        return updatedTimings;
    };
    /**
     * @param {?} time
     * @return {?}
     */
    AnimationTimelineContext.prototype.incrementTime = /**
     * @param {?} time
     * @return {?}
     */
    function (time) {
        this.currentTimeline.forwardTime(this.currentTimeline.duration + time);
    };
    /**
     * @param {?} delay
     * @return {?}
     */
    AnimationTimelineContext.prototype.delayNextStep = /**
     * @param {?} delay
     * @return {?}
     */
    function (delay) {
        // negative delays are not yet supported
        if (delay > 0) {
            this.currentTimeline.delayNextStep(delay);
        }
    };
    /**
     * @param {?} selector
     * @param {?} originalSelector
     * @param {?} limit
     * @param {?} includeSelf
     * @param {?} optional
     * @param {?} errors
     * @return {?}
     */
    AnimationTimelineContext.prototype.invokeQuery = /**
     * @param {?} selector
     * @param {?} originalSelector
     * @param {?} limit
     * @param {?} includeSelf
     * @param {?} optional
     * @param {?} errors
     * @return {?}
     */
    function (selector, originalSelector, limit, includeSelf, optional, errors) {
        var /** @type {?} */ results = [];
        if (includeSelf) {
            results.push(this.element);
        }
        if (selector.length > 0) {
            // if :self is only used then the selector is empty
            var /** @type {?} */ multi = limit != 1;
            results.push.apply(results, this._driver.query(this.element, selector, multi));
        }
        if (!optional && results.length == 0) {
            errors.push("`query(\"" + originalSelector + "\")` returned zero elements. (Use `query(\"" + originalSelector + "\", { optional: true })` if you wish to allow this.)");
        }
        return results;
    };
    return AnimationTimelineContext;
}());
var TimelineBuilder = (function () {
    function TimelineBuilder(_driver, element, startTime, _elementTimelineStylesLookup) {
        this._driver = _driver;
        this.element = element;
        this.startTime = startTime;
        this._elementTimelineStylesLookup = _elementTimelineStylesLookup;
        this.duration = 0;
        this._previousKeyframe = {};
        this._currentKeyframe = {};
        this._keyframes = new Map();
        this._styleSummary = {};
        this._pendingStyles = {};
        this._backFill = {};
        this._currentEmptyStepKeyframe = null;
        if (!this._elementTimelineStylesLookup) {
            this._elementTimelineStylesLookup = new Map();
        }
        this._localTimelineStyles = Object.create(this._backFill, {});
        this._globalTimelineStyles = /** @type {?} */ ((this._elementTimelineStylesLookup.get(element)));
        if (!this._globalTimelineStyles) {
            this._globalTimelineStyles = this._localTimelineStyles;
            this._elementTimelineStylesLookup.set(element, this._localTimelineStyles);
        }
        this._loadKeyframe();
    }
    /**
     * @return {?}
     */
    TimelineBuilder.prototype.containsAnimation = /**
     * @return {?}
     */
    function () {
        switch (this._keyframes.size) {
            case 0:
                return false;
            case 1:
                return this.getCurrentStyleProperties().length > 0;
            default:
                return true;
        }
    };
    /**
     * @return {?}
     */
    TimelineBuilder.prototype.getCurrentStyleProperties = /**
     * @return {?}
     */
    function () { return Object.keys(this._currentKeyframe); };
    Object.defineProperty(TimelineBuilder.prototype, "currentTime", {
        get: /**
         * @return {?}
         */
        function () { return this.startTime + this.duration; },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} delay
     * @return {?}
     */
    TimelineBuilder.prototype.delayNextStep = /**
     * @param {?} delay
     * @return {?}
     */
    function (delay) {
        // in the event that a style() step is placed right before a stagger()
        // and that style() step is the very first style() value in the animation
        // then we need to make a copy of the keyframe [0, copy, 1] so that the delay
        // properly applies the style() values to work with the stagger...
        var /** @type {?} */ hasPreStyleStep = this._keyframes.size == 1 && Object.keys(this._pendingStyles).length;
        if (this.duration || hasPreStyleStep) {
            this.forwardTime(this.currentTime + delay);
            if (hasPreStyleStep) {
                this.snapshotCurrentStyles();
            }
        }
        else {
            this.startTime += delay;
        }
    };
    /**
     * @param {?} element
     * @param {?=} currentTime
     * @return {?}
     */
    TimelineBuilder.prototype.fork = /**
     * @param {?} element
     * @param {?=} currentTime
     * @return {?}
     */
    function (element, currentTime) {
        this.applyStylesToKeyframe();
        return new TimelineBuilder(this._driver, element, currentTime || this.currentTime, this._elementTimelineStylesLookup);
    };
    /**
     * @return {?}
     */
    TimelineBuilder.prototype._loadKeyframe = /**
     * @return {?}
     */
    function () {
        if (this._currentKeyframe) {
            this._previousKeyframe = this._currentKeyframe;
        }
        this._currentKeyframe = /** @type {?} */ ((this._keyframes.get(this.duration)));
        if (!this._currentKeyframe) {
            this._currentKeyframe = Object.create(this._backFill, {});
            this._keyframes.set(this.duration, this._currentKeyframe);
        }
    };
    /**
     * @return {?}
     */
    TimelineBuilder.prototype.forwardFrame = /**
     * @return {?}
     */
    function () {
        this.duration += ONE_FRAME_IN_MILLISECONDS;
        this._loadKeyframe();
    };
    /**
     * @param {?} time
     * @return {?}
     */
    TimelineBuilder.prototype.forwardTime = /**
     * @param {?} time
     * @return {?}
     */
    function (time) {
        this.applyStylesToKeyframe();
        this.duration = time;
        this._loadKeyframe();
    };
    /**
     * @param {?} prop
     * @param {?} value
     * @return {?}
     */
    TimelineBuilder.prototype._updateStyle = /**
     * @param {?} prop
     * @param {?} value
     * @return {?}
     */
    function (prop, value) {
        this._localTimelineStyles[prop] = value;
        this._globalTimelineStyles[prop] = value;
        this._styleSummary[prop] = { time: this.currentTime, value: value };
    };
    /**
     * @return {?}
     */
    TimelineBuilder.prototype.allowOnlyTimelineStyles = /**
     * @return {?}
     */
    function () { return this._currentEmptyStepKeyframe !== this._currentKeyframe; };
    /**
     * @param {?} easing
     * @return {?}
     */
    TimelineBuilder.prototype.applyEmptyStep = /**
     * @param {?} easing
     * @return {?}
     */
    function (easing) {
        var _this = this;
        if (easing) {
            this._previousKeyframe['easing'] = easing;
        }
        // special case for animate(duration):
        // all missing styles are filled with a `*` value then
        // if any destination styles are filled in later on the same
        // keyframe then they will override the overridden styles
        // We use `_globalTimelineStyles` here because there may be
        // styles in previous keyframes that are not present in this timeline
        Object.keys(this._globalTimelineStyles).forEach(function (prop) {
            _this._backFill[prop] = _this._globalTimelineStyles[prop] || _angular_animations.AUTO_STYLE;
            _this._currentKeyframe[prop] = _angular_animations.AUTO_STYLE;
        });
        this._currentEmptyStepKeyframe = this._currentKeyframe;
    };
    /**
     * @param {?} input
     * @param {?} easing
     * @param {?} errors
     * @param {?=} options
     * @return {?}
     */
    TimelineBuilder.prototype.setStyles = /**
     * @param {?} input
     * @param {?} easing
     * @param {?} errors
     * @param {?=} options
     * @return {?}
     */
    function (input, easing, errors, options) {
        var _this = this;
        if (easing) {
            this._previousKeyframe['easing'] = easing;
        }
        var /** @type {?} */ params = (options && options.params) || {};
        var /** @type {?} */ styles = flattenStyles(input, this._globalTimelineStyles);
        Object.keys(styles).forEach(function (prop) {
            var /** @type {?} */ val = interpolateParams(styles[prop], params, errors);
            _this._pendingStyles[prop] = val;
            if (!_this._localTimelineStyles.hasOwnProperty(prop)) {
                _this._backFill[prop] = _this._globalTimelineStyles.hasOwnProperty(prop) ?
                    _this._globalTimelineStyles[prop] :
                    _angular_animations.AUTO_STYLE;
            }
            _this._updateStyle(prop, val);
        });
    };
    /**
     * @return {?}
     */
    TimelineBuilder.prototype.applyStylesToKeyframe = /**
     * @return {?}
     */
    function () {
        var _this = this;
        var /** @type {?} */ styles = this._pendingStyles;
        var /** @type {?} */ props = Object.keys(styles);
        if (props.length == 0)
            return;
        this._pendingStyles = {};
        props.forEach(function (prop) {
            var /** @type {?} */ val = styles[prop];
            _this._currentKeyframe[prop] = val;
        });
        Object.keys(this._localTimelineStyles).forEach(function (prop) {
            if (!_this._currentKeyframe.hasOwnProperty(prop)) {
                _this._currentKeyframe[prop] = _this._localTimelineStyles[prop];
            }
        });
    };
    /**
     * @return {?}
     */
    TimelineBuilder.prototype.snapshotCurrentStyles = /**
     * @return {?}
     */
    function () {
        var _this = this;
        Object.keys(this._localTimelineStyles).forEach(function (prop) {
            var /** @type {?} */ val = _this._localTimelineStyles[prop];
            _this._pendingStyles[prop] = val;
            _this._updateStyle(prop, val);
        });
    };
    /**
     * @return {?}
     */
    TimelineBuilder.prototype.getFinalKeyframe = /**
     * @return {?}
     */
    function () { return this._keyframes.get(this.duration); };
    Object.defineProperty(TimelineBuilder.prototype, "properties", {
        get: /**
         * @return {?}
         */
        function () {
            var /** @type {?} */ properties = [];
            for (var /** @type {?} */ prop in this._currentKeyframe) {
                properties.push(prop);
            }
            return properties;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} timeline
     * @return {?}
     */
    TimelineBuilder.prototype.mergeTimelineCollectedStyles = /**
     * @param {?} timeline
     * @return {?}
     */
    function (timeline) {
        var _this = this;
        Object.keys(timeline._styleSummary).forEach(function (prop) {
            var /** @type {?} */ details0 = _this._styleSummary[prop];
            var /** @type {?} */ details1 = timeline._styleSummary[prop];
            if (!details0 || details1.time > details0.time) {
                _this._updateStyle(prop, details1.value);
            }
        });
    };
    /**
     * @return {?}
     */
    TimelineBuilder.prototype.buildKeyframes = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.applyStylesToKeyframe();
        var /** @type {?} */ preStyleProps = new Set();
        var /** @type {?} */ postStyleProps = new Set();
        var /** @type {?} */ isEmpty = this._keyframes.size === 1 && this.duration === 0;
        var /** @type {?} */ finalKeyframes = [];
        this._keyframes.forEach(function (keyframe, time) {
            var /** @type {?} */ finalKeyframe = copyStyles(keyframe, true);
            Object.keys(finalKeyframe).forEach(function (prop) {
                var /** @type {?} */ value = finalKeyframe[prop];
                if (value == _angular_animations.ɵPRE_STYLE) {
                    preStyleProps.add(prop);
                }
                else if (value == _angular_animations.AUTO_STYLE) {
                    postStyleProps.add(prop);
                }
            });
            if (!isEmpty) {
                finalKeyframe['offset'] = time / _this.duration;
            }
            finalKeyframes.push(finalKeyframe);
        });
        var /** @type {?} */ preProps = preStyleProps.size ? iteratorToArray(preStyleProps.values()) : [];
        var /** @type {?} */ postProps = postStyleProps.size ? iteratorToArray(postStyleProps.values()) : [];
        // special case for a 0-second animation (which is designed just to place styles onscreen)
        if (isEmpty) {
            var /** @type {?} */ kf0 = finalKeyframes[0];
            var /** @type {?} */ kf1 = copyObj(kf0);
            kf0['offset'] = 0;
            kf1['offset'] = 1;
            finalKeyframes = [kf0, kf1];
        }
        return createTimelineInstruction(this.element, finalKeyframes, preProps, postProps, this.duration, this.startTime, this.easing, false);
    };
    return TimelineBuilder;
}());
var SubTimelineBuilder = (function (_super) {
    __extends(SubTimelineBuilder, _super);
    function SubTimelineBuilder(driver, element, keyframes, preStyleProps, postStyleProps, timings, _stretchStartingKeyframe) {
        if (_stretchStartingKeyframe === void 0) { _stretchStartingKeyframe = false; }
        var _this = _super.call(this, driver, element, timings.delay) || this;
        _this.element = element;
        _this.keyframes = keyframes;
        _this.preStyleProps = preStyleProps;
        _this.postStyleProps = postStyleProps;
        _this._stretchStartingKeyframe = _stretchStartingKeyframe;
        _this.timings = { duration: timings.duration, delay: timings.delay, easing: timings.easing };
        return _this;
    }
    /**
     * @return {?}
     */
    SubTimelineBuilder.prototype.containsAnimation = /**
     * @return {?}
     */
    function () { return this.keyframes.length > 1; };
    /**
     * @return {?}
     */
    SubTimelineBuilder.prototype.buildKeyframes = /**
     * @return {?}
     */
    function () {
        var /** @type {?} */ keyframes = this.keyframes;
        var _a = this.timings, delay = _a.delay, duration = _a.duration, easing = _a.easing;
        if (this._stretchStartingKeyframe && delay) {
            var /** @type {?} */ newKeyframes = [];
            var /** @type {?} */ totalTime = duration + delay;
            var /** @type {?} */ startingGap = delay / totalTime;
            // the original starting keyframe now starts once the delay is done
            var /** @type {?} */ newFirstKeyframe = copyStyles(keyframes[0], false);
            newFirstKeyframe['offset'] = 0;
            newKeyframes.push(newFirstKeyframe);
            var /** @type {?} */ oldFirstKeyframe = copyStyles(keyframes[0], false);
            oldFirstKeyframe['offset'] = roundOffset(startingGap);
            newKeyframes.push(oldFirstKeyframe);
            /*
                    When the keyframe is stretched then it means that the delay before the animation
                    starts is gone. Instead the first keyframe is placed at the start of the animation
                    and it is then copied to where it starts when the original delay is over. This basically
                    means nothing animates during that delay, but the styles are still renderered. For this
                    to work the original offset values that exist in the original keyframes must be "warped"
                    so that they can take the new keyframe + delay into account.
            
                    delay=1000, duration=1000, keyframes = 0 .5 1
            
                    turns into
            
                    delay=0, duration=2000, keyframes = 0 .33 .66 1
                   */
            // offsets between 1 ... n -1 are all warped by the keyframe stretch
            var /** @type {?} */ limit = keyframes.length - 1;
            for (var /** @type {?} */ i = 1; i <= limit; i++) {
                var /** @type {?} */ kf = copyStyles(keyframes[i], false);
                var /** @type {?} */ oldOffset = /** @type {?} */ (kf['offset']);
                var /** @type {?} */ timeAtKeyframe = delay + oldOffset * duration;
                kf['offset'] = roundOffset(timeAtKeyframe / totalTime);
                newKeyframes.push(kf);
            }
            // the new starting keyframe should be added at the start
            duration = totalTime;
            delay = 0;
            easing = '';
            keyframes = newKeyframes;
        }
        return createTimelineInstruction(this.element, keyframes, this.preStyleProps, this.postStyleProps, duration, delay, easing, true);
    };
    return SubTimelineBuilder;
}(TimelineBuilder));
/**
 * @param {?} offset
 * @param {?=} decimalPoints
 * @return {?}
 */
function roundOffset(offset, decimalPoints) {
    if (decimalPoints === void 0) { decimalPoints = 3; }
    var /** @type {?} */ mult = Math.pow(10, decimalPoints - 1);
    return Math.round(offset * mult) / mult;
}
/**
 * @param {?} input
 * @param {?} allStyles
 * @return {?}
 */
function flattenStyles(input, allStyles) {
    var /** @type {?} */ styles = {};
    var /** @type {?} */ allProperties;
    input.forEach(function (token) {
        if (token === '*') {
            allProperties = allProperties || Object.keys(allStyles);
            allProperties.forEach(function (prop) { styles[prop] = _angular_animations.AUTO_STYLE; });
        }
        else {
            copyStyles(/** @type {?} */ (token), false, styles);
        }
    });
    return styles;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var Animation = (function () {
    function Animation(_driver, input) {
        this._driver = _driver;
        var /** @type {?} */ errors = [];
        var /** @type {?} */ ast = buildAnimationAst(_driver, input, errors);
        if (errors.length) {
            var /** @type {?} */ errorMessage = "animation validation failed:\n" + errors.join("\n");
            throw new Error(errorMessage);
        }
        this._animationAst = ast;
    }
    /**
     * @param {?} element
     * @param {?} startingStyles
     * @param {?} destinationStyles
     * @param {?} options
     * @param {?=} subInstructions
     * @return {?}
     */
    Animation.prototype.buildTimelines = /**
     * @param {?} element
     * @param {?} startingStyles
     * @param {?} destinationStyles
     * @param {?} options
     * @param {?=} subInstructions
     * @return {?}
     */
    function (element, startingStyles, destinationStyles, options, subInstructions) {
        var /** @type {?} */ start = Array.isArray(startingStyles) ? normalizeStyles(startingStyles) : /** @type {?} */ (startingStyles);
        var /** @type {?} */ dest = Array.isArray(destinationStyles) ? normalizeStyles(destinationStyles) : /** @type {?} */ (destinationStyles);
        var /** @type {?} */ errors = [];
        subInstructions = subInstructions || new ElementInstructionMap();
        var /** @type {?} */ result = buildAnimationTimelines(this._driver, element, this._animationAst, start, dest, options, subInstructions, errors);
        if (errors.length) {
            var /** @type {?} */ errorMessage = "animation building failed:\n" + errors.join("\n");
            throw new Error(errorMessage);
        }
        return result;
    };
    return Animation;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * \@experimental Animation support is experimental.
 * @abstract
 */
var AnimationStyleNormalizer = (function () {
    function AnimationStyleNormalizer() {
    }
    return AnimationStyleNormalizer;
}());
/**
 * \@experimental Animation support is experimental.
 */
var NoopAnimationStyleNormalizer = (function () {
    function NoopAnimationStyleNormalizer() {
    }
    /**
     * @param {?} propertyName
     * @param {?} errors
     * @return {?}
     */
    NoopAnimationStyleNormalizer.prototype.normalizePropertyName = /**
     * @param {?} propertyName
     * @param {?} errors
     * @return {?}
     */
    function (propertyName, errors) { return propertyName; };
    /**
     * @param {?} userProvidedProperty
     * @param {?} normalizedProperty
     * @param {?} value
     * @param {?} errors
     * @return {?}
     */
    NoopAnimationStyleNormalizer.prototype.normalizeStyleValue = /**
     * @param {?} userProvidedProperty
     * @param {?} normalizedProperty
     * @param {?} value
     * @param {?} errors
     * @return {?}
     */
    function (userProvidedProperty, normalizedProperty, value, errors) {
        return /** @type {?} */ (value);
    };
    return NoopAnimationStyleNormalizer;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var WebAnimationsStyleNormalizer = (function (_super) {
    __extends(WebAnimationsStyleNormalizer, _super);
    function WebAnimationsStyleNormalizer() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * @param {?} propertyName
     * @param {?} errors
     * @return {?}
     */
    WebAnimationsStyleNormalizer.prototype.normalizePropertyName = /**
     * @param {?} propertyName
     * @param {?} errors
     * @return {?}
     */
    function (propertyName, errors) {
        return dashCaseToCamelCase(propertyName);
    };
    /**
     * @param {?} userProvidedProperty
     * @param {?} normalizedProperty
     * @param {?} value
     * @param {?} errors
     * @return {?}
     */
    WebAnimationsStyleNormalizer.prototype.normalizeStyleValue = /**
     * @param {?} userProvidedProperty
     * @param {?} normalizedProperty
     * @param {?} value
     * @param {?} errors
     * @return {?}
     */
    function (userProvidedProperty, normalizedProperty, value, errors) {
        var /** @type {?} */ unit = '';
        var /** @type {?} */ strVal = value.toString().trim();
        if (DIMENSIONAL_PROP_MAP[normalizedProperty] && value !== 0 && value !== '0') {
            if (typeof value === 'number') {
                unit = 'px';
            }
            else {
                var /** @type {?} */ valAndSuffixMatch = value.match(/^[+-]?[\d\.]+([a-z]*)$/);
                if (valAndSuffixMatch && valAndSuffixMatch[1].length == 0) {
                    errors.push("Please provide a CSS unit value for " + userProvidedProperty + ":" + value);
                }
            }
        }
        return strVal + unit;
    };
    return WebAnimationsStyleNormalizer;
}(AnimationStyleNormalizer));
var DIMENSIONAL_PROP_MAP = makeBooleanMap('width,height,minWidth,minHeight,maxWidth,maxHeight,left,top,bottom,right,fontSize,outlineWidth,outlineOffset,paddingTop,paddingLeft,paddingBottom,paddingRight,marginTop,marginLeft,marginBottom,marginRight,borderRadius,borderWidth,borderTopWidth,borderLeftWidth,borderRightWidth,borderBottomWidth,textIndent,perspective'
    .split(','));
/**
 * @param {?} keys
 * @return {?}
 */
function makeBooleanMap(keys) {
    var /** @type {?} */ map = {};
    keys.forEach(function (key) { return map[key] = true; });
    return map;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @record
 */

/**
 * @param {?} element
 * @param {?} triggerName
 * @param {?} fromState
 * @param {?} toState
 * @param {?} isRemovalTransition
 * @param {?} fromStyles
 * @param {?} toStyles
 * @param {?} timelines
 * @param {?} queriedElements
 * @param {?} preStyleProps
 * @param {?} postStyleProps
 * @param {?=} errors
 * @return {?}
 */
function createTransitionInstruction(element, triggerName, fromState, toState, isRemovalTransition, fromStyles, toStyles, timelines, queriedElements, preStyleProps, postStyleProps, errors) {
    return {
        type: 0 /* TransitionAnimation */,
        element: element,
        triggerName: triggerName,
        isRemovalTransition: isRemovalTransition,
        fromState: fromState,
        fromStyles: fromStyles,
        toState: toState,
        toStyles: toStyles,
        timelines: timelines,
        queriedElements: queriedElements,
        preStyleProps: preStyleProps,
        postStyleProps: postStyleProps,
        errors: errors
    };
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var EMPTY_OBJECT = {};
var AnimationTransitionFactory = (function () {
    function AnimationTransitionFactory(_triggerName, ast, _stateStyles) {
        this._triggerName = _triggerName;
        this.ast = ast;
        this._stateStyles = _stateStyles;
    }
    /**
     * @param {?} currentState
     * @param {?} nextState
     * @return {?}
     */
    AnimationTransitionFactory.prototype.match = /**
     * @param {?} currentState
     * @param {?} nextState
     * @return {?}
     */
    function (currentState, nextState) {
        return oneOrMoreTransitionsMatch(this.ast.matchers, currentState, nextState);
    };
    /**
     * @param {?} stateName
     * @param {?} params
     * @param {?} errors
     * @return {?}
     */
    AnimationTransitionFactory.prototype.buildStyles = /**
     * @param {?} stateName
     * @param {?} params
     * @param {?} errors
     * @return {?}
     */
    function (stateName, params, errors) {
        var /** @type {?} */ backupStateStyler = this._stateStyles['*'];
        var /** @type {?} */ stateStyler = this._stateStyles[stateName];
        var /** @type {?} */ backupStyles = backupStateStyler ? backupStateStyler.buildStyles(params, errors) : {};
        return stateStyler ? stateStyler.buildStyles(params, errors) : backupStyles;
    };
    /**
     * @param {?} driver
     * @param {?} element
     * @param {?} currentState
     * @param {?} nextState
     * @param {?=} currentOptions
     * @param {?=} nextOptions
     * @param {?=} subInstructions
     * @return {?}
     */
    AnimationTransitionFactory.prototype.build = /**
     * @param {?} driver
     * @param {?} element
     * @param {?} currentState
     * @param {?} nextState
     * @param {?=} currentOptions
     * @param {?=} nextOptions
     * @param {?=} subInstructions
     * @return {?}
     */
    function (driver, element, currentState, nextState, currentOptions, nextOptions, subInstructions) {
        var /** @type {?} */ errors = [];
        var /** @type {?} */ transitionAnimationParams = this.ast.options && this.ast.options.params || EMPTY_OBJECT;
        var /** @type {?} */ currentAnimationParams = currentOptions && currentOptions.params || EMPTY_OBJECT;
        var /** @type {?} */ currentStateStyles = this.buildStyles(currentState, currentAnimationParams, errors);
        var /** @type {?} */ nextAnimationParams = nextOptions && nextOptions.params || EMPTY_OBJECT;
        var /** @type {?} */ nextStateStyles = this.buildStyles(nextState, nextAnimationParams, errors);
        var /** @type {?} */ queriedElements = new Set();
        var /** @type {?} */ preStyleMap = new Map();
        var /** @type {?} */ postStyleMap = new Map();
        var /** @type {?} */ isRemoval = nextState === 'void';
        var /** @type {?} */ animationOptions = { params: __assign({}, transitionAnimationParams, nextAnimationParams) };
        var /** @type {?} */ timelines = buildAnimationTimelines(driver, element, this.ast.animation, currentStateStyles, nextStateStyles, animationOptions, subInstructions, errors);
        if (errors.length) {
            return createTransitionInstruction(element, this._triggerName, currentState, nextState, isRemoval, currentStateStyles, nextStateStyles, [], [], preStyleMap, postStyleMap, errors);
        }
        timelines.forEach(function (tl) {
            var /** @type {?} */ elm = tl.element;
            var /** @type {?} */ preProps = getOrSetAsInMap(preStyleMap, elm, {});
            tl.preStyleProps.forEach(function (prop) { return preProps[prop] = true; });
            var /** @type {?} */ postProps = getOrSetAsInMap(postStyleMap, elm, {});
            tl.postStyleProps.forEach(function (prop) { return postProps[prop] = true; });
            if (elm !== element) {
                queriedElements.add(elm);
            }
        });
        var /** @type {?} */ queriedElementsList = iteratorToArray(queriedElements.values());
        return createTransitionInstruction(element, this._triggerName, currentState, nextState, isRemoval, currentStateStyles, nextStateStyles, timelines, queriedElementsList, preStyleMap, postStyleMap);
    };
    return AnimationTransitionFactory;
}());
/**
 * @param {?} matchFns
 * @param {?} currentState
 * @param {?} nextState
 * @return {?}
 */
function oneOrMoreTransitionsMatch(matchFns, currentState, nextState) {
    return matchFns.some(function (fn) { return fn(currentState, nextState); });
}
var AnimationStateStyles = (function () {
    function AnimationStateStyles(styles, defaultParams) {
        this.styles = styles;
        this.defaultParams = defaultParams;
    }
    /**
     * @param {?} params
     * @param {?} errors
     * @return {?}
     */
    AnimationStateStyles.prototype.buildStyles = /**
     * @param {?} params
     * @param {?} errors
     * @return {?}
     */
    function (params, errors) {
        var /** @type {?} */ finalStyles = {};
        var /** @type {?} */ combinedParams = copyObj(this.defaultParams);
        Object.keys(params).forEach(function (key) {
            var /** @type {?} */ value = params[key];
            if (value != null) {
                combinedParams[key] = value;
            }
        });
        this.styles.styles.forEach(function (value) {
            if (typeof value !== 'string') {
                var /** @type {?} */ styleObj_1 = /** @type {?} */ (value);
                Object.keys(styleObj_1).forEach(function (prop) {
                    var /** @type {?} */ val = styleObj_1[prop];
                    if (val.length > 1) {
                        val = interpolateParams(val, combinedParams, errors);
                    }
                    finalStyles[prop] = val;
                });
            }
        });
        return finalStyles;
    };
    return AnimationStateStyles;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * \@experimental Animation support is experimental.
 * @param {?} name
 * @param {?} ast
 * @return {?}
 */
function buildTrigger(name, ast) {
    return new AnimationTrigger(name, ast);
}
/**
 * \@experimental Animation support is experimental.
 */
var AnimationTrigger = (function () {
    function AnimationTrigger(name, ast) {
        var _this = this;
        this.name = name;
        this.ast = ast;
        this.transitionFactories = [];
        this.states = {};
        ast.states.forEach(function (ast) {
            var /** @type {?} */ defaultParams = (ast.options && ast.options.params) || {};
            _this.states[ast.name] = new AnimationStateStyles(ast.style, defaultParams);
        });
        balanceProperties(this.states, 'true', '1');
        balanceProperties(this.states, 'false', '0');
        ast.transitions.forEach(function (ast) {
            _this.transitionFactories.push(new AnimationTransitionFactory(name, ast, _this.states));
        });
        this.fallbackTransition = createFallbackTransition(name, this.states);
    }
    Object.defineProperty(AnimationTrigger.prototype, "containsQueries", {
        get: /**
         * @return {?}
         */
        function () { return this.ast.queryCount > 0; },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} currentState
     * @param {?} nextState
     * @return {?}
     */
    AnimationTrigger.prototype.matchTransition = /**
     * @param {?} currentState
     * @param {?} nextState
     * @return {?}
     */
    function (currentState, nextState) {
        var /** @type {?} */ entry = this.transitionFactories.find(function (f) { return f.match(currentState, nextState); });
        return entry || null;
    };
    /**
     * @param {?} currentState
     * @param {?} params
     * @param {?} errors
     * @return {?}
     */
    AnimationTrigger.prototype.matchStyles = /**
     * @param {?} currentState
     * @param {?} params
     * @param {?} errors
     * @return {?}
     */
    function (currentState, params, errors) {
        return this.fallbackTransition.buildStyles(currentState, params, errors);
    };
    return AnimationTrigger;
}());
/**
 * @param {?} triggerName
 * @param {?} states
 * @return {?}
 */
function createFallbackTransition(triggerName, states) {
    var /** @type {?} */ matchers = [function (fromState, toState) { return true; }];
    var /** @type {?} */ animation = new SequenceAst([]);
    var /** @type {?} */ transition = new TransitionAst(matchers, animation);
    return new AnimationTransitionFactory(triggerName, transition, states);
}
/**
 * @param {?} obj
 * @param {?} key1
 * @param {?} key2
 * @return {?}
 */
function balanceProperties(obj, key1, key2) {
    if (obj.hasOwnProperty(key1)) {
        if (!obj.hasOwnProperty(key2)) {
            obj[key2] = obj[key1];
        }
    }
    else if (obj.hasOwnProperty(key2)) {
        obj[key1] = obj[key2];
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var EMPTY_INSTRUCTION_MAP = new ElementInstructionMap();
var TimelineAnimationEngine = (function () {
    function TimelineAnimationEngine(_driver, _normalizer) {
        this._driver = _driver;
        this._normalizer = _normalizer;
        this._animations = {};
        this._playersById = {};
        this.players = [];
    }
    /**
     * @param {?} id
     * @param {?} metadata
     * @return {?}
     */
    TimelineAnimationEngine.prototype.register = /**
     * @param {?} id
     * @param {?} metadata
     * @return {?}
     */
    function (id, metadata) {
        var /** @type {?} */ errors = [];
        var /** @type {?} */ ast = buildAnimationAst(this._driver, metadata, errors);
        if (errors.length) {
            throw new Error("Unable to build the animation due to the following errors: " + errors.join("\n"));
        }
        else {
            this._animations[id] = ast;
        }
    };
    /**
     * @param {?} i
     * @param {?} preStyles
     * @param {?=} postStyles
     * @return {?}
     */
    TimelineAnimationEngine.prototype._buildPlayer = /**
     * @param {?} i
     * @param {?} preStyles
     * @param {?=} postStyles
     * @return {?}
     */
    function (i, preStyles, postStyles) {
        var /** @type {?} */ element = i.element;
        var /** @type {?} */ keyframes = normalizeKeyframes(this._driver, this._normalizer, element, i.keyframes, preStyles, postStyles);
        return this._driver.animate(element, keyframes, i.duration, i.delay, i.easing, []);
    };
    /**
     * @param {?} id
     * @param {?} element
     * @param {?=} options
     * @return {?}
     */
    TimelineAnimationEngine.prototype.create = /**
     * @param {?} id
     * @param {?} element
     * @param {?=} options
     * @return {?}
     */
    function (id, element, options) {
        var _this = this;
        if (options === void 0) { options = {}; }
        var /** @type {?} */ errors = [];
        var /** @type {?} */ ast = this._animations[id];
        var /** @type {?} */ instructions;
        var /** @type {?} */ autoStylesMap = new Map();
        if (ast) {
            instructions = buildAnimationTimelines(this._driver, element, ast, {}, {}, options, EMPTY_INSTRUCTION_MAP, errors);
            instructions.forEach(function (inst) {
                var /** @type {?} */ styles = getOrSetAsInMap(autoStylesMap, inst.element, {});
                inst.postStyleProps.forEach(function (prop) { return styles[prop] = null; });
            });
        }
        else {
            errors.push('The requested animation doesn\'t exist or has already been destroyed');
            instructions = [];
        }
        if (errors.length) {
            throw new Error("Unable to create the animation due to the following errors: " + errors.join("\n"));
        }
        autoStylesMap.forEach(function (styles, element) {
            Object.keys(styles).forEach(function (prop) { styles[prop] = _this._driver.computeStyle(element, prop, _angular_animations.AUTO_STYLE); });
        });
        var /** @type {?} */ players = instructions.map(function (i) {
            var /** @type {?} */ styles = autoStylesMap.get(i.element);
            return _this._buildPlayer(i, {}, styles);
        });
        var /** @type {?} */ player = optimizeGroupPlayer(players);
        this._playersById[id] = player;
        player.onDestroy(function () { return _this.destroy(id); });
        this.players.push(player);
        return player;
    };
    /**
     * @param {?} id
     * @return {?}
     */
    TimelineAnimationEngine.prototype.destroy = /**
     * @param {?} id
     * @return {?}
     */
    function (id) {
        var /** @type {?} */ player = this._getPlayer(id);
        player.destroy();
        delete this._playersById[id];
        var /** @type {?} */ index = this.players.indexOf(player);
        if (index >= 0) {
            this.players.splice(index, 1);
        }
    };
    /**
     * @param {?} id
     * @return {?}
     */
    TimelineAnimationEngine.prototype._getPlayer = /**
     * @param {?} id
     * @return {?}
     */
    function (id) {
        var /** @type {?} */ player = this._playersById[id];
        if (!player) {
            throw new Error("Unable to find the timeline player referenced by " + id);
        }
        return player;
    };
    /**
     * @param {?} id
     * @param {?} element
     * @param {?} eventName
     * @param {?} callback
     * @return {?}
     */
    TimelineAnimationEngine.prototype.listen = /**
     * @param {?} id
     * @param {?} element
     * @param {?} eventName
     * @param {?} callback
     * @return {?}
     */
    function (id, element, eventName, callback) {
        // triggerName, fromState, toState are all ignored for timeline animations
        var /** @type {?} */ baseEvent = makeAnimationEvent(element, '', '', '');
        listenOnPlayer(this._getPlayer(id), eventName, baseEvent, callback);
        return function () { };
    };
    /**
     * @param {?} id
     * @param {?} element
     * @param {?} command
     * @param {?} args
     * @return {?}
     */
    TimelineAnimationEngine.prototype.command = /**
     * @param {?} id
     * @param {?} element
     * @param {?} command
     * @param {?} args
     * @return {?}
     */
    function (id, element, command, args) {
        if (command == 'register') {
            this.register(id, /** @type {?} */ (args[0]));
            return;
        }
        if (command == 'create') {
            var /** @type {?} */ options = /** @type {?} */ ((args[0] || {}));
            this.create(id, element, options);
            return;
        }
        var /** @type {?} */ player = this._getPlayer(id);
        switch (command) {
            case 'play':
                player.play();
                break;
            case 'pause':
                player.pause();
                break;
            case 'reset':
                player.reset();
                break;
            case 'restart':
                player.restart();
                break;
            case 'finish':
                player.finish();
                break;
            case 'init':
                player.init();
                break;
            case 'setPosition':
                player.setPosition(parseFloat(/** @type {?} */ (args[0])));
                break;
            case 'destroy':
                this.destroy(id);
                break;
        }
    };
    return TimelineAnimationEngine;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var QUEUED_CLASSNAME = 'ng-animate-queued';
var QUEUED_SELECTOR = '.ng-animate-queued';
var DISABLED_CLASSNAME = 'ng-animate-disabled';
var DISABLED_SELECTOR = '.ng-animate-disabled';
var EMPTY_PLAYER_ARRAY = [];
var NULL_REMOVAL_STATE = {
    namespaceId: '',
    setForRemoval: null,
    hasAnimation: false,
    removedBeforeQueried: false
};
var NULL_REMOVED_QUERIED_STATE = {
    namespaceId: '',
    setForRemoval: null,
    hasAnimation: false,
    removedBeforeQueried: true
};
/**
 * @record
 */

var REMOVAL_FLAG = '__ng_removed';
/**
 * @record
 */

var StateValue = (function () {
    function StateValue(input) {
        var /** @type {?} */ isObj = input && input.hasOwnProperty('value');
        var /** @type {?} */ value = isObj ? input['value'] : input;
        this.value = normalizeTriggerValue(value);
        if (isObj) {
            var /** @type {?} */ options = copyObj(/** @type {?} */ (input));
            delete options['value'];
            this.options = /** @type {?} */ (options);
        }
        else {
            this.options = {};
        }
        if (!this.options.params) {
            this.options.params = {};
        }
    }
    Object.defineProperty(StateValue.prototype, "params", {
        get: /**
         * @return {?}
         */
        function () { return /** @type {?} */ (this.options.params); },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} options
     * @return {?}
     */
    StateValue.prototype.absorbOptions = /**
     * @param {?} options
     * @return {?}
     */
    function (options) {
        var /** @type {?} */ newParams = options.params;
        if (newParams) {
            var /** @type {?} */ oldParams_1 = /** @type {?} */ ((this.options.params));
            Object.keys(newParams).forEach(function (prop) {
                if (oldParams_1[prop] == null) {
                    oldParams_1[prop] = newParams[prop];
                }
            });
        }
    };
    return StateValue;
}());
var VOID_VALUE = 'void';
var DEFAULT_STATE_VALUE = new StateValue(VOID_VALUE);
var DELETED_STATE_VALUE = new StateValue('DELETED');
var AnimationTransitionNamespace = (function () {
    function AnimationTransitionNamespace(id, hostElement, _engine) {
        this.id = id;
        this.hostElement = hostElement;
        this._engine = _engine;
        this.players = [];
        this._triggers = {};
        this._queue = [];
        this._elementListeners = new Map();
        this._hostClassName = 'ng-tns-' + id;
        addClass(hostElement, this._hostClassName);
    }
    /**
     * @param {?} element
     * @param {?} name
     * @param {?} phase
     * @param {?} callback
     * @return {?}
     */
    AnimationTransitionNamespace.prototype.listen = /**
     * @param {?} element
     * @param {?} name
     * @param {?} phase
     * @param {?} callback
     * @return {?}
     */
    function (element, name, phase, callback) {
        var _this = this;
        if (!this._triggers.hasOwnProperty(name)) {
            throw new Error("Unable to listen on the animation trigger event \"" + phase + "\" because the animation trigger \"" + name + "\" doesn't exist!");
        }
        if (phase == null || phase.length == 0) {
            throw new Error("Unable to listen on the animation trigger \"" + name + "\" because the provided event is undefined!");
        }
        if (!isTriggerEventValid(phase)) {
            throw new Error("The provided animation trigger event \"" + phase + "\" for the animation trigger \"" + name + "\" is not supported!");
        }
        var /** @type {?} */ listeners = getOrSetAsInMap(this._elementListeners, element, []);
        var /** @type {?} */ data = { name: name, phase: phase, callback: callback };
        listeners.push(data);
        var /** @type {?} */ triggersWithStates = getOrSetAsInMap(this._engine.statesByElement, element, {});
        if (!triggersWithStates.hasOwnProperty(name)) {
            addClass(element, NG_TRIGGER_CLASSNAME);
            addClass(element, NG_TRIGGER_CLASSNAME + '-' + name);
            triggersWithStates[name] = null;
        }
        return function () {
            // the event listener is removed AFTER the flush has occurred such
            // that leave animations callbacks can fire (otherwise if the node
            // is removed in between then the listeners would be deregistered)
            // the event listener is removed AFTER the flush has occurred such
            // that leave animations callbacks can fire (otherwise if the node
            // is removed in between then the listeners would be deregistered)
            _this._engine.afterFlush(function () {
                var /** @type {?} */ index = listeners.indexOf(data);
                if (index >= 0) {
                    listeners.splice(index, 1);
                }
                if (!_this._triggers[name]) {
                    delete triggersWithStates[name];
                }
            });
        };
    };
    /**
     * @param {?} name
     * @param {?} ast
     * @return {?}
     */
    AnimationTransitionNamespace.prototype.register = /**
     * @param {?} name
     * @param {?} ast
     * @return {?}
     */
    function (name, ast) {
        if (this._triggers[name]) {
            // throw
            return false;
        }
        else {
            this._triggers[name] = ast;
            return true;
        }
    };
    /**
     * @param {?} name
     * @return {?}
     */
    AnimationTransitionNamespace.prototype._getTrigger = /**
     * @param {?} name
     * @return {?}
     */
    function (name) {
        var /** @type {?} */ trigger = this._triggers[name];
        if (!trigger) {
            throw new Error("The provided animation trigger \"" + name + "\" has not been registered!");
        }
        return trigger;
    };
    /**
     * @param {?} element
     * @param {?} triggerName
     * @param {?} value
     * @param {?=} defaultToFallback
     * @return {?}
     */
    AnimationTransitionNamespace.prototype.trigger = /**
     * @param {?} element
     * @param {?} triggerName
     * @param {?} value
     * @param {?=} defaultToFallback
     * @return {?}
     */
    function (element, triggerName, value, defaultToFallback) {
        var _this = this;
        if (defaultToFallback === void 0) { defaultToFallback = true; }
        var /** @type {?} */ trigger = this._getTrigger(triggerName);
        var /** @type {?} */ player = new TransitionAnimationPlayer(this.id, triggerName, element);
        var /** @type {?} */ triggersWithStates = this._engine.statesByElement.get(element);
        if (!triggersWithStates) {
            addClass(element, NG_TRIGGER_CLASSNAME);
            addClass(element, NG_TRIGGER_CLASSNAME + '-' + triggerName);
            this._engine.statesByElement.set(element, triggersWithStates = {});
        }
        var /** @type {?} */ fromState = triggersWithStates[triggerName];
        var /** @type {?} */ toState = new StateValue(value);
        var /** @type {?} */ isObj = value && value.hasOwnProperty('value');
        if (!isObj && fromState) {
            toState.absorbOptions(fromState.options);
        }
        triggersWithStates[triggerName] = toState;
        if (!fromState) {
            fromState = DEFAULT_STATE_VALUE;
        }
        else if (fromState === DELETED_STATE_VALUE) {
            return player;
        }
        var /** @type {?} */ isRemoval = toState.value === VOID_VALUE;
        // normally this isn't reached by here, however, if an object expression
        // is passed in then it may be a new object each time. Comparing the value
        // is important since that will stay the same despite there being a new object.
        // The removal arc here is special cased because the same element is triggered
        // twice in the event that it contains animations on the outer/inner portions
        // of the host container
        if (!isRemoval && fromState.value === toState.value) {
            // this means that despite the value not changing, some inner params
            // have changed which means that the animation final styles need to be applied
            if (!objEquals(fromState.params, toState.params)) {
                var /** @type {?} */ errors = [];
                var /** @type {?} */ fromStyles_1 = trigger.matchStyles(fromState.value, fromState.params, errors);
                var /** @type {?} */ toStyles_1 = trigger.matchStyles(toState.value, toState.params, errors);
                if (errors.length) {
                    this._engine.reportError(errors);
                }
                else {
                    this._engine.afterFlush(function () {
                        eraseStyles(element, fromStyles_1);
                        setStyles(element, toStyles_1);
                    });
                }
            }
            return;
        }
        var /** @type {?} */ playersOnElement = getOrSetAsInMap(this._engine.playersByElement, element, []);
        playersOnElement.forEach(function (player) {
            // only remove the player if it is queued on the EXACT same trigger/namespace
            // we only also deal with queued players here because if the animation has
            // started then we want to keep the player alive until the flush happens
            // (which is where the previousPlayers are passed into the new palyer)
            if (player.namespaceId == _this.id && player.triggerName == triggerName && player.queued) {
                player.destroy();
            }
        });
        var /** @type {?} */ transition = trigger.matchTransition(fromState.value, toState.value);
        var /** @type {?} */ isFallbackTransition = false;
        if (!transition) {
            if (!defaultToFallback)
                return;
            transition = trigger.fallbackTransition;
            isFallbackTransition = true;
        }
        this._engine.totalQueuedPlayers++;
        this._queue.push({ element: element, triggerName: triggerName, transition: transition, fromState: fromState, toState: toState, player: player, isFallbackTransition: isFallbackTransition });
        if (!isFallbackTransition) {
            addClass(element, QUEUED_CLASSNAME);
            player.onStart(function () { removeClass(element, QUEUED_CLASSNAME); });
        }
        player.onDone(function () {
            var /** @type {?} */ index = _this.players.indexOf(player);
            if (index >= 0) {
                _this.players.splice(index, 1);
            }
            var /** @type {?} */ players = _this._engine.playersByElement.get(element);
            if (players) {
                var /** @type {?} */ index_1 = players.indexOf(player);
                if (index_1 >= 0) {
                    players.splice(index_1, 1);
                }
            }
        });
        this.players.push(player);
        playersOnElement.push(player);
        return player;
    };
    /**
     * @param {?} name
     * @return {?}
     */
    AnimationTransitionNamespace.prototype.deregister = /**
     * @param {?} name
     * @return {?}
     */
    function (name) {
        var _this = this;
        delete this._triggers[name];
        this._engine.statesByElement.forEach(function (stateMap, element) { delete stateMap[name]; });
        this._elementListeners.forEach(function (listeners, element) {
            _this._elementListeners.set(element, listeners.filter(function (entry) { return entry.name != name; }));
        });
    };
    /**
     * @param {?} element
     * @return {?}
     */
    AnimationTransitionNamespace.prototype.clearElementCache = /**
     * @param {?} element
     * @return {?}
     */
    function (element) {
        this._engine.statesByElement.delete(element);
        this._elementListeners.delete(element);
        var /** @type {?} */ elementPlayers = this._engine.playersByElement.get(element);
        if (elementPlayers) {
            elementPlayers.forEach(function (player) { return player.destroy(); });
            this._engine.playersByElement.delete(element);
        }
    };
    /**
     * @param {?} rootElement
     * @param {?} context
     * @param {?=} animate
     * @return {?}
     */
    AnimationTransitionNamespace.prototype._destroyInnerNodes = /**
     * @param {?} rootElement
     * @param {?} context
     * @param {?=} animate
     * @return {?}
     */
    function (rootElement, context, animate) {
        var _this = this;
        if (animate === void 0) { animate = false; }
        this._engine.driver.query(rootElement, NG_TRIGGER_SELECTOR, true).forEach(function (elm) {
            if (animate && containsClass(elm, _this._hostClassName)) {
                var /** @type {?} */ innerNs = _this._engine.namespacesByHostElement.get(elm);
                // special case for a host element with animations on the same element
                if (innerNs) {
                    innerNs.removeNode(elm, context, true);
                }
                _this.removeNode(elm, context, true);
            }
            else {
                _this.clearElementCache(elm);
            }
        });
    };
    /**
     * @param {?} element
     * @param {?} context
     * @param {?=} doNotRecurse
     * @return {?}
     */
    AnimationTransitionNamespace.prototype.removeNode = /**
     * @param {?} element
     * @param {?} context
     * @param {?=} doNotRecurse
     * @return {?}
     */
    function (element, context, doNotRecurse) {
        var _this = this;
        var /** @type {?} */ engine = this._engine;
        if (!doNotRecurse && element.childElementCount) {
            this._destroyInnerNodes(element, context, true);
        }
        var /** @type {?} */ triggerStates = engine.statesByElement.get(element);
        if (triggerStates) {
            var /** @type {?} */ players_1 = [];
            Object.keys(triggerStates).forEach(function (triggerName) {
                // this check is here in the event that an element is removed
                // twice (both on the host level and the component level)
                if (_this._triggers[triggerName]) {
                    var /** @type {?} */ player = _this.trigger(element, triggerName, VOID_VALUE, false);
                    if (player) {
                        players_1.push(player);
                    }
                }
            });
            if (players_1.length) {
                engine.markElementAsRemoved(this.id, element, true, context);
                optimizeGroupPlayer(players_1).onDone(function () { return engine.processLeaveNode(element); });
                return;
            }
        }
        // find the player that is animating and make sure that the
        // removal is delayed until that player has completed
        var /** @type {?} */ containsPotentialParentTransition = false;
        if (engine.totalAnimations) {
            var /** @type {?} */ currentPlayers = engine.players.length ? engine.playersByQueriedElement.get(element) : [];
            // when this `if statement` does not continue forward it means that
            // a previous animation query has selected the current element and
            // is animating it. In this situation want to continue fowards and
            // allow the element to be queued up for animation later.
            if (currentPlayers && currentPlayers.length) {
                containsPotentialParentTransition = true;
            }
            else {
                var /** @type {?} */ parent_1 = element;
                while (parent_1 = parent_1.parentNode) {
                    var /** @type {?} */ triggers = engine.statesByElement.get(parent_1);
                    if (triggers) {
                        containsPotentialParentTransition = true;
                        break;
                    }
                }
            }
        }
        // at this stage we know that the element will either get removed
        // during flush or will be picked up by a parent query. Either way
        // we need to fire the listeners for this element when it DOES get
        // removed (once the query parent animation is done or after flush)
        var /** @type {?} */ listeners = this._elementListeners.get(element);
        if (listeners) {
            var /** @type {?} */ visitedTriggers_1 = new Set();
            listeners.forEach(function (listener) {
                var /** @type {?} */ triggerName = listener.name;
                if (visitedTriggers_1.has(triggerName))
                    return;
                visitedTriggers_1.add(triggerName);
                var /** @type {?} */ trigger = _this._triggers[triggerName];
                var /** @type {?} */ transition = trigger.fallbackTransition;
                var /** @type {?} */ elementStates = /** @type {?} */ ((engine.statesByElement.get(element)));
                var /** @type {?} */ fromState = elementStates[triggerName] || DEFAULT_STATE_VALUE;
                var /** @type {?} */ toState = new StateValue(VOID_VALUE);
                var /** @type {?} */ player = new TransitionAnimationPlayer(_this.id, triggerName, element);
                _this._engine.totalQueuedPlayers++;
                _this._queue.push({
                    element: element,
                    triggerName: triggerName,
                    transition: transition,
                    fromState: fromState,
                    toState: toState,
                    player: player,
                    isFallbackTransition: true
                });
            });
        }
        // whether or not a parent has an animation we need to delay the deferral of the leave
        // operation until we have more information (which we do after flush() has been called)
        if (containsPotentialParentTransition) {
            engine.markElementAsRemoved(this.id, element, false, context);
        }
        else {
            // we do this after the flush has occurred such
            // that the callbacks can be fired
            engine.afterFlush(function () { return _this.clearElementCache(element); });
            engine.destroyInnerAnimations(element);
            engine._onRemovalComplete(element, context);
        }
    };
    /**
     * @param {?} element
     * @param {?} parent
     * @return {?}
     */
    AnimationTransitionNamespace.prototype.insertNode = /**
     * @param {?} element
     * @param {?} parent
     * @return {?}
     */
    function (element, parent) { addClass(element, this._hostClassName); };
    /**
     * @param {?} microtaskId
     * @return {?}
     */
    AnimationTransitionNamespace.prototype.drainQueuedTransitions = /**
     * @param {?} microtaskId
     * @return {?}
     */
    function (microtaskId) {
        var _this = this;
        var /** @type {?} */ instructions = [];
        this._queue.forEach(function (entry) {
            var /** @type {?} */ player = entry.player;
            if (player.destroyed)
                return;
            var /** @type {?} */ element = entry.element;
            var /** @type {?} */ listeners = _this._elementListeners.get(element);
            if (listeners) {
                listeners.forEach(function (listener) {
                    if (listener.name == entry.triggerName) {
                        var /** @type {?} */ baseEvent = makeAnimationEvent(element, entry.triggerName, entry.fromState.value, entry.toState.value);
                        (/** @type {?} */ (baseEvent))['_data'] = microtaskId;
                        listenOnPlayer(entry.player, listener.phase, baseEvent, listener.callback);
                    }
                });
            }
            if (player.markedForDestroy) {
                _this._engine.afterFlush(function () {
                    // now we can destroy the element properly since the event listeners have
                    // been bound to the player
                    player.destroy();
                });
            }
            else {
                instructions.push(entry);
            }
        });
        this._queue = [];
        return instructions.sort(function (a, b) {
            // if depCount == 0 them move to front
            // otherwise if a contains b then move back
            var /** @type {?} */ d0 = a.transition.ast.depCount;
            var /** @type {?} */ d1 = b.transition.ast.depCount;
            if (d0 == 0 || d1 == 0) {
                return d0 - d1;
            }
            return _this._engine.driver.containsElement(a.element, b.element) ? 1 : -1;
        });
    };
    /**
     * @param {?} context
     * @return {?}
     */
    AnimationTransitionNamespace.prototype.destroy = /**
     * @param {?} context
     * @return {?}
     */
    function (context) {
        this.players.forEach(function (p) { return p.destroy(); });
        this._destroyInnerNodes(this.hostElement, context);
    };
    /**
     * @param {?} element
     * @return {?}
     */
    AnimationTransitionNamespace.prototype.elementContainsData = /**
     * @param {?} element
     * @return {?}
     */
    function (element) {
        var /** @type {?} */ containsData = false;
        if (this._elementListeners.has(element))
            containsData = true;
        containsData =
            (this._queue.find(function (entry) { return entry.element === element; }) ? true : false) || containsData;
        return containsData;
    };
    return AnimationTransitionNamespace;
}());
/**
 * @record
 */

var TransitionAnimationEngine = (function () {
    function TransitionAnimationEngine(driver, _normalizer) {
        this.driver = driver;
        this._normalizer = _normalizer;
        this.players = [];
        this.newHostElements = new Map();
        this.playersByElement = new Map();
        this.playersByQueriedElement = new Map();
        this.statesByElement = new Map();
        this.disabledNodes = new Set();
        this.totalAnimations = 0;
        this.totalQueuedPlayers = 0;
        this._namespaceLookup = {};
        this._namespaceList = [];
        this._flushFns = [];
        this._whenQuietFns = [];
        this.namespacesByHostElement = new Map();
        this.collectedEnterElements = [];
        this.collectedLeaveElements = [];
        this.onRemovalComplete = function (element, context) { };
    }
    /** @internal */
    /**
     * \@internal
     * @param {?} element
     * @param {?} context
     * @return {?}
     */
    TransitionAnimationEngine.prototype._onRemovalComplete = /**
     * \@internal
     * @param {?} element
     * @param {?} context
     * @return {?}
     */
    function (element, context) { this.onRemovalComplete(element, context); };
    Object.defineProperty(TransitionAnimationEngine.prototype, "queuedPlayers", {
        get: /**
         * @return {?}
         */
        function () {
            var /** @type {?} */ players = [];
            this._namespaceList.forEach(function (ns) {
                ns.players.forEach(function (player) {
                    if (player.queued) {
                        players.push(player);
                    }
                });
            });
            return players;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} namespaceId
     * @param {?} hostElement
     * @return {?}
     */
    TransitionAnimationEngine.prototype.createNamespace = /**
     * @param {?} namespaceId
     * @param {?} hostElement
     * @return {?}
     */
    function (namespaceId, hostElement) {
        var /** @type {?} */ ns = new AnimationTransitionNamespace(namespaceId, hostElement, this);
        if (hostElement.parentNode) {
            this._balanceNamespaceList(ns, hostElement);
        }
        else {
            // defer this later until flush during when the host element has
            // been inserted so that we know exactly where to place it in
            // the namespace list
            this.newHostElements.set(hostElement, ns);
            // given that this host element is apart of the animation code, it
            // may or may not be inserted by a parent node that is an of an
            // animation renderer type. If this happens then we can still have
            // access to this item when we query for :enter nodes. If the parent
            // is a renderer then the set data-structure will normalize the entry
            this.collectEnterElement(hostElement);
        }
        return this._namespaceLookup[namespaceId] = ns;
    };
    /**
     * @param {?} ns
     * @param {?} hostElement
     * @return {?}
     */
    TransitionAnimationEngine.prototype._balanceNamespaceList = /**
     * @param {?} ns
     * @param {?} hostElement
     * @return {?}
     */
    function (ns, hostElement) {
        var /** @type {?} */ limit = this._namespaceList.length - 1;
        if (limit >= 0) {
            var /** @type {?} */ found = false;
            for (var /** @type {?} */ i = limit; i >= 0; i--) {
                var /** @type {?} */ nextNamespace = this._namespaceList[i];
                if (this.driver.containsElement(nextNamespace.hostElement, hostElement)) {
                    this._namespaceList.splice(i + 1, 0, ns);
                    found = true;
                    break;
                }
            }
            if (!found) {
                this._namespaceList.splice(0, 0, ns);
            }
        }
        else {
            this._namespaceList.push(ns);
        }
        this.namespacesByHostElement.set(hostElement, ns);
        return ns;
    };
    /**
     * @param {?} namespaceId
     * @param {?} hostElement
     * @return {?}
     */
    TransitionAnimationEngine.prototype.register = /**
     * @param {?} namespaceId
     * @param {?} hostElement
     * @return {?}
     */
    function (namespaceId, hostElement) {
        var /** @type {?} */ ns = this._namespaceLookup[namespaceId];
        if (!ns) {
            ns = this.createNamespace(namespaceId, hostElement);
        }
        return ns;
    };
    /**
     * @param {?} namespaceId
     * @param {?} name
     * @param {?} trigger
     * @return {?}
     */
    TransitionAnimationEngine.prototype.registerTrigger = /**
     * @param {?} namespaceId
     * @param {?} name
     * @param {?} trigger
     * @return {?}
     */
    function (namespaceId, name, trigger) {
        var /** @type {?} */ ns = this._namespaceLookup[namespaceId];
        if (ns && ns.register(name, trigger)) {
            this.totalAnimations++;
        }
    };
    /**
     * @param {?} namespaceId
     * @param {?} context
     * @return {?}
     */
    TransitionAnimationEngine.prototype.destroy = /**
     * @param {?} namespaceId
     * @param {?} context
     * @return {?}
     */
    function (namespaceId, context) {
        var _this = this;
        if (!namespaceId)
            return;
        var /** @type {?} */ ns = this._fetchNamespace(namespaceId);
        this.afterFlush(function () {
            _this.namespacesByHostElement.delete(ns.hostElement);
            delete _this._namespaceLookup[namespaceId];
            var /** @type {?} */ index = _this._namespaceList.indexOf(ns);
            if (index >= 0) {
                _this._namespaceList.splice(index, 1);
            }
        });
        this.afterFlushAnimationsDone(function () { return ns.destroy(context); });
    };
    /**
     * @param {?} id
     * @return {?}
     */
    TransitionAnimationEngine.prototype._fetchNamespace = /**
     * @param {?} id
     * @return {?}
     */
    function (id) { return this._namespaceLookup[id]; };
    /**
     * @param {?} namespaceId
     * @param {?} element
     * @param {?} name
     * @param {?} value
     * @return {?}
     */
    TransitionAnimationEngine.prototype.trigger = /**
     * @param {?} namespaceId
     * @param {?} element
     * @param {?} name
     * @param {?} value
     * @return {?}
     */
    function (namespaceId, element, name, value) {
        if (isElementNode(element)) {
            this._fetchNamespace(namespaceId).trigger(element, name, value);
            return true;
        }
        return false;
    };
    /**
     * @param {?} namespaceId
     * @param {?} element
     * @param {?} parent
     * @param {?} insertBefore
     * @return {?}
     */
    TransitionAnimationEngine.prototype.insertNode = /**
     * @param {?} namespaceId
     * @param {?} element
     * @param {?} parent
     * @param {?} insertBefore
     * @return {?}
     */
    function (namespaceId, element, parent, insertBefore) {
        if (!isElementNode(element))
            return;
        // special case for when an element is removed and reinserted (move operation)
        // when this occurs we do not want to use the element for deletion later
        var /** @type {?} */ details = /** @type {?} */ (element[REMOVAL_FLAG]);
        if (details && details.setForRemoval) {
            details.setForRemoval = false;
        }
        // in the event that the namespaceId is blank then the caller
        // code does not contain any animation code in it, but it is
        // just being called so that the node is marked as being inserted
        if (namespaceId) {
            this._fetchNamespace(namespaceId).insertNode(element, parent);
        }
        // only *directives and host elements are inserted before
        if (insertBefore) {
            this.collectEnterElement(element);
        }
    };
    /**
     * @param {?} element
     * @return {?}
     */
    TransitionAnimationEngine.prototype.collectEnterElement = /**
     * @param {?} element
     * @return {?}
     */
    function (element) { this.collectedEnterElements.push(element); };
    /**
     * @param {?} element
     * @param {?} value
     * @return {?}
     */
    TransitionAnimationEngine.prototype.markElementAsDisabled = /**
     * @param {?} element
     * @param {?} value
     * @return {?}
     */
    function (element, value) {
        if (value) {
            if (!this.disabledNodes.has(element)) {
                this.disabledNodes.add(element);
                addClass(element, DISABLED_CLASSNAME);
            }
        }
        else if (this.disabledNodes.has(element)) {
            this.disabledNodes.delete(element);
            removeClass(element, DISABLED_CLASSNAME);
        }
    };
    /**
     * @param {?} namespaceId
     * @param {?} element
     * @param {?} context
     * @param {?=} doNotRecurse
     * @return {?}
     */
    TransitionAnimationEngine.prototype.removeNode = /**
     * @param {?} namespaceId
     * @param {?} element
     * @param {?} context
     * @param {?=} doNotRecurse
     * @return {?}
     */
    function (namespaceId, element, context, doNotRecurse) {
        if (!isElementNode(element)) {
            this._onRemovalComplete(element, context);
            return;
        }
        var /** @type {?} */ ns = namespaceId ? this._fetchNamespace(namespaceId) : null;
        if (ns) {
            ns.removeNode(element, context, doNotRecurse);
        }
        else {
            this.markElementAsRemoved(namespaceId, element, false, context);
        }
    };
    /**
     * @param {?} namespaceId
     * @param {?} element
     * @param {?=} hasAnimation
     * @param {?=} context
     * @return {?}
     */
    TransitionAnimationEngine.prototype.markElementAsRemoved = /**
     * @param {?} namespaceId
     * @param {?} element
     * @param {?=} hasAnimation
     * @param {?=} context
     * @return {?}
     */
    function (namespaceId, element, hasAnimation, context) {
        this.collectedLeaveElements.push(element);
        element[REMOVAL_FLAG] = {
            namespaceId: namespaceId,
            setForRemoval: context, hasAnimation: hasAnimation,
            removedBeforeQueried: false
        };
    };
    /**
     * @param {?} namespaceId
     * @param {?} element
     * @param {?} name
     * @param {?} phase
     * @param {?} callback
     * @return {?}
     */
    TransitionAnimationEngine.prototype.listen = /**
     * @param {?} namespaceId
     * @param {?} element
     * @param {?} name
     * @param {?} phase
     * @param {?} callback
     * @return {?}
     */
    function (namespaceId, element, name, phase, callback) {
        if (isElementNode(element)) {
            return this._fetchNamespace(namespaceId).listen(element, name, phase, callback);
        }
        return function () { };
    };
    /**
     * @param {?} entry
     * @param {?} subTimelines
     * @return {?}
     */
    TransitionAnimationEngine.prototype._buildInstruction = /**
     * @param {?} entry
     * @param {?} subTimelines
     * @return {?}
     */
    function (entry, subTimelines) {
        return entry.transition.build(this.driver, entry.element, entry.fromState.value, entry.toState.value, entry.fromState.options, entry.toState.options, subTimelines);
    };
    /**
     * @param {?} containerElement
     * @return {?}
     */
    TransitionAnimationEngine.prototype.destroyInnerAnimations = /**
     * @param {?} containerElement
     * @return {?}
     */
    function (containerElement) {
        var _this = this;
        var /** @type {?} */ elements = this.driver.query(containerElement, NG_TRIGGER_SELECTOR, true);
        elements.forEach(function (element) {
            var /** @type {?} */ players = _this.playersByElement.get(element);
            if (players) {
                players.forEach(function (player) {
                    // special case for when an element is set for destruction, but hasn't started.
                    // in this situation we want to delay the destruction until the flush occurs
                    // so that any event listeners attached to the player are triggered.
                    if (player.queued) {
                        player.markedForDestroy = true;
                    }
                    else {
                        player.destroy();
                    }
                });
            }
            var /** @type {?} */ stateMap = _this.statesByElement.get(element);
            if (stateMap) {
                Object.keys(stateMap).forEach(function (triggerName) { return stateMap[triggerName] = DELETED_STATE_VALUE; });
            }
        });
        if (this.playersByQueriedElement.size == 0)
            return;
        elements = this.driver.query(containerElement, NG_ANIMATING_SELECTOR, true);
        if (elements.length) {
            elements.forEach(function (element) {
                var /** @type {?} */ players = _this.playersByQueriedElement.get(element);
                if (players) {
                    players.forEach(function (player) { return player.finish(); });
                }
            });
        }
    };
    /**
     * @return {?}
     */
    TransitionAnimationEngine.prototype.whenRenderingDone = /**
     * @return {?}
     */
    function () {
        var _this = this;
        return new Promise(function (resolve) {
            if (_this.players.length) {
                return optimizeGroupPlayer(_this.players).onDone(function () { return resolve(); });
            }
            else {
                resolve();
            }
        });
    };
    /**
     * @param {?} element
     * @return {?}
     */
    TransitionAnimationEngine.prototype.processLeaveNode = /**
     * @param {?} element
     * @return {?}
     */
    function (element) {
        var _this = this;
        var /** @type {?} */ details = /** @type {?} */ (element[REMOVAL_FLAG]);
        if (details && details.setForRemoval) {
            // this will prevent it from removing it twice
            element[REMOVAL_FLAG] = NULL_REMOVAL_STATE;
            if (details.namespaceId) {
                this.destroyInnerAnimations(element);
                var /** @type {?} */ ns = this._fetchNamespace(details.namespaceId);
                if (ns) {
                    ns.clearElementCache(element);
                }
            }
            this._onRemovalComplete(element, details.setForRemoval);
        }
        if (this.driver.matchesElement(element, DISABLED_SELECTOR)) {
            this.markElementAsDisabled(element, false);
        }
        this.driver.query(element, DISABLED_SELECTOR, true).forEach(function (node) {
            _this.markElementAsDisabled(element, false);
        });
    };
    /**
     * @param {?=} microtaskId
     * @return {?}
     */
    TransitionAnimationEngine.prototype.flush = /**
     * @param {?=} microtaskId
     * @return {?}
     */
    function (microtaskId) {
        var _this = this;
        if (microtaskId === void 0) { microtaskId = -1; }
        var /** @type {?} */ players = [];
        if (this.newHostElements.size) {
            this.newHostElements.forEach(function (ns, element) { return _this._balanceNamespaceList(ns, element); });
            this.newHostElements.clear();
        }
        if (this._namespaceList.length &&
            (this.totalQueuedPlayers || this.collectedLeaveElements.length)) {
            var /** @type {?} */ cleanupFns = [];
            try {
                players = this._flushAnimations(cleanupFns, microtaskId);
            }
            finally {
                for (var /** @type {?} */ i = 0; i < cleanupFns.length; i++) {
                    cleanupFns[i]();
                }
            }
        }
        else {
            for (var /** @type {?} */ i = 0; i < this.collectedLeaveElements.length; i++) {
                var /** @type {?} */ element = this.collectedLeaveElements[i];
                this.processLeaveNode(element);
            }
        }
        this.totalQueuedPlayers = 0;
        this.collectedEnterElements.length = 0;
        this.collectedLeaveElements.length = 0;
        this._flushFns.forEach(function (fn) { return fn(); });
        this._flushFns = [];
        if (this._whenQuietFns.length) {
            // we move these over to a variable so that
            // if any new callbacks are registered in another
            // flush they do not populate the existing set
            var /** @type {?} */ quietFns_1 = this._whenQuietFns;
            this._whenQuietFns = [];
            if (players.length) {
                optimizeGroupPlayer(players).onDone(function () { quietFns_1.forEach(function (fn) { return fn(); }); });
            }
            else {
                quietFns_1.forEach(function (fn) { return fn(); });
            }
        }
    };
    /**
     * @param {?} errors
     * @return {?}
     */
    TransitionAnimationEngine.prototype.reportError = /**
     * @param {?} errors
     * @return {?}
     */
    function (errors) {
        throw new Error("Unable to process animations due to the following failed trigger transitions\n " + errors.join("\n"));
    };
    /**
     * @param {?} cleanupFns
     * @param {?} microtaskId
     * @return {?}
     */
    TransitionAnimationEngine.prototype._flushAnimations = /**
     * @param {?} cleanupFns
     * @param {?} microtaskId
     * @return {?}
     */
    function (cleanupFns, microtaskId) {
        var _this = this;
        var /** @type {?} */ subTimelines = new ElementInstructionMap();
        var /** @type {?} */ skippedPlayers = [];
        var /** @type {?} */ skippedPlayersMap = new Map();
        var /** @type {?} */ queuedInstructions = [];
        var /** @type {?} */ queriedElements = new Map();
        var /** @type {?} */ allPreStyleElements = new Map();
        var /** @type {?} */ allPostStyleElements = new Map();
        var /** @type {?} */ disabledElementsSet = new Set();
        this.disabledNodes.forEach(function (node) {
            disabledElementsSet.add(node);
            var /** @type {?} */ nodesThatAreDisabled = _this.driver.query(node, QUEUED_SELECTOR, true);
            for (var /** @type {?} */ i = 0; i < nodesThatAreDisabled.length; i++) {
                disabledElementsSet.add(nodesThatAreDisabled[i]);
            }
        });
        var /** @type {?} */ bodyNode = getBodyNode();
        var /** @type {?} */ allEnterNodes = this.collectedEnterElements.length ?
            this.collectedEnterElements.filter(createIsRootFilterFn(this.collectedEnterElements)) :
            [];
        // this must occur before the instructions are built below such that
        // the :enter queries match the elements (since the timeline queries
        // are fired during instruction building).
        for (var /** @type {?} */ i = 0; i < allEnterNodes.length; i++) {
            addClass(allEnterNodes[i], ENTER_CLASSNAME);
        }
        var /** @type {?} */ allLeaveNodes = [];
        var /** @type {?} */ leaveNodesWithoutAnimations = new Set();
        for (var /** @type {?} */ i = 0; i < this.collectedLeaveElements.length; i++) {
            var /** @type {?} */ element = this.collectedLeaveElements[i];
            var /** @type {?} */ details = /** @type {?} */ (element[REMOVAL_FLAG]);
            if (details && details.setForRemoval) {
                addClass(element, LEAVE_CLASSNAME);
                allLeaveNodes.push(element);
                if (!details.hasAnimation) {
                    leaveNodesWithoutAnimations.add(element);
                }
            }
        }
        cleanupFns.push(function () {
            allEnterNodes.forEach(function (element) { return removeClass(element, ENTER_CLASSNAME); });
            allLeaveNodes.forEach(function (element) {
                removeClass(element, LEAVE_CLASSNAME);
                _this.processLeaveNode(element);
            });
        });
        var /** @type {?} */ allPlayers = [];
        var /** @type {?} */ erroneousTransitions = [];
        for (var /** @type {?} */ i = this._namespaceList.length - 1; i >= 0; i--) {
            var /** @type {?} */ ns = this._namespaceList[i];
            ns.drainQueuedTransitions(microtaskId).forEach(function (entry) {
                var /** @type {?} */ player = entry.player;
                allPlayers.push(player);
                var /** @type {?} */ element = entry.element;
                if (!bodyNode || !_this.driver.containsElement(bodyNode, element)) {
                    player.destroy();
                    return;
                }
                var /** @type {?} */ instruction = /** @type {?} */ ((_this._buildInstruction(entry, subTimelines)));
                if (instruction.errors && instruction.errors.length) {
                    erroneousTransitions.push(instruction);
                    return;
                }
                // if a unmatched transition is queued to go then it SHOULD NOT render
                // an animation and cancel the previously running animations.
                if (entry.isFallbackTransition) {
                    player.onStart(function () { return eraseStyles(element, instruction.fromStyles); });
                    player.onDestroy(function () { return setStyles(element, instruction.toStyles); });
                    skippedPlayers.push(player);
                    return;
                }
                // this means that if a parent animation uses this animation as a sub trigger
                // then it will instruct the timeline builder to not add a player delay, but
                // instead stretch the first keyframe gap up until the animation starts. The
                // reason this is important is to prevent extra initialization styles from being
                // required by the user in the animation.
                instruction.timelines.forEach(function (tl) { return tl.stretchStartingKeyframe = true; });
                subTimelines.append(element, instruction.timelines);
                var /** @type {?} */ tuple = { instruction: instruction, player: player, element: element };
                queuedInstructions.push(tuple);
                instruction.queriedElements.forEach(function (element) { return getOrSetAsInMap(queriedElements, element, []).push(player); });
                instruction.preStyleProps.forEach(function (stringMap, element) {
                    var /** @type {?} */ props = Object.keys(stringMap);
                    if (props.length) {
                        var /** @type {?} */ setVal_1 = /** @type {?} */ ((allPreStyleElements.get(element)));
                        if (!setVal_1) {
                            allPreStyleElements.set(element, setVal_1 = new Set());
                        }
                        props.forEach(function (prop) { return setVal_1.add(prop); });
                    }
                });
                instruction.postStyleProps.forEach(function (stringMap, element) {
                    var /** @type {?} */ props = Object.keys(stringMap);
                    var /** @type {?} */ setVal = /** @type {?} */ ((allPostStyleElements.get(element)));
                    if (!setVal) {
                        allPostStyleElements.set(element, setVal = new Set());
                    }
                    props.forEach(function (prop) { return setVal.add(prop); });
                });
            });
        }
        if (erroneousTransitions.length) {
            var /** @type {?} */ errors_1 = [];
            erroneousTransitions.forEach(function (instruction) {
                errors_1.push("@" + instruction.triggerName + " has failed due to:\n"); /** @type {?} */
                ((instruction.errors)).forEach(function (error) { return errors_1.push("- " + error + "\n"); });
            });
            allPlayers.forEach(function (player) { return player.destroy(); });
            this.reportError(errors_1);
        }
        // these can only be detected here since we have a map of all the elements
        // that have animations attached to them... We use a set here in the event
        // multiple enter captures on the same element were caught in different
        // renderer namespaces (e.g. when a @trigger was on a host binding that had *ngIf)
        var /** @type {?} */ enterNodesWithoutAnimations = new Set();
        for (var /** @type {?} */ i = 0; i < allEnterNodes.length; i++) {
            var /** @type {?} */ element = allEnterNodes[i];
            if (!subTimelines.has(element)) {
                enterNodesWithoutAnimations.add(element);
            }
        }
        var /** @type {?} */ allPreviousPlayersMap = new Map();
        var /** @type {?} */ sortedParentElements = [];
        queuedInstructions.forEach(function (entry) {
            var /** @type {?} */ element = entry.element;
            if (subTimelines.has(element)) {
                sortedParentElements.unshift(element);
                _this._beforeAnimationBuild(entry.player.namespaceId, entry.instruction, allPreviousPlayersMap);
            }
        });
        skippedPlayers.forEach(function (player) {
            var /** @type {?} */ element = player.element;
            var /** @type {?} */ previousPlayers = _this._getPreviousPlayers(element, false, player.namespaceId, player.triggerName, null);
            previousPlayers.forEach(function (prevPlayer) {
                getOrSetAsInMap(allPreviousPlayersMap, element, []).push(prevPlayer);
                prevPlayer.destroy();
            });
        });
        // this is a special case for nodes that will be removed (either by)
        // having their own leave animations or by being queried in a container
        // that will be removed once a parent animation is complete. The idea
        // here is that * styles must be identical to ! styles because of
        // backwards compatibility (* is also filled in by default in many places).
        // Otherwise * styles will return an empty value or auto since the element
        // that is being getComputedStyle'd will not be visible (since * = destination)
        var /** @type {?} */ replaceNodes = allLeaveNodes.filter(function (node) {
            return replacePostStylesAsPre(node, allPreStyleElements, allPostStyleElements);
        });
        // POST STAGE: fill the * styles
        var _a = cloakAndComputeStyles(this.driver, leaveNodesWithoutAnimations, allPostStyleElements, _angular_animations.AUTO_STYLE), postStylesMap = _a[0], allLeaveQueriedNodes = _a[1];
        allLeaveQueriedNodes.forEach(function (node) {
            if (replacePostStylesAsPre(node, allPreStyleElements, allPostStyleElements)) {
                replaceNodes.push(node);
            }
        });
        // PRE STAGE: fill the ! styles
        var preStylesMap = (allPreStyleElements.size ?
            cloakAndComputeStyles(this.driver, enterNodesWithoutAnimations, allPreStyleElements, _angular_animations.ɵPRE_STYLE) :
            [new Map()])[0];
        replaceNodes.forEach(function (node) {
            var /** @type {?} */ post = postStylesMap.get(node);
            var /** @type {?} */ pre = preStylesMap.get(node);
            postStylesMap.set(node, /** @type {?} */ (__assign({}, post, pre)));
        });
        var /** @type {?} */ rootPlayers = [];
        var /** @type {?} */ subPlayers = [];
        queuedInstructions.forEach(function (entry) {
            var element = entry.element, player = entry.player, instruction = entry.instruction;
            // this means that it was never consumed by a parent animation which
            // means that it is independent and therefore should be set for animation
            if (subTimelines.has(element)) {
                if (disabledElementsSet.has(element)) {
                    skippedPlayers.push(player);
                    return;
                }
                var /** @type {?} */ innerPlayer = _this._buildAnimation(player.namespaceId, instruction, allPreviousPlayersMap, skippedPlayersMap, preStylesMap, postStylesMap);
                player.setRealPlayer(innerPlayer);
                var /** @type {?} */ parentHasPriority = null;
                for (var /** @type {?} */ i = 0; i < sortedParentElements.length; i++) {
                    var /** @type {?} */ parent_2 = sortedParentElements[i];
                    if (parent_2 === element)
                        break;
                    if (_this.driver.containsElement(parent_2, element)) {
                        parentHasPriority = parent_2;
                        break;
                    }
                }
                if (parentHasPriority) {
                    var /** @type {?} */ parentPlayers = _this.playersByElement.get(parentHasPriority);
                    if (parentPlayers && parentPlayers.length) {
                        player.parentPlayer = optimizeGroupPlayer(parentPlayers);
                    }
                    skippedPlayers.push(player);
                }
                else {
                    rootPlayers.push(player);
                }
            }
            else {
                eraseStyles(element, instruction.fromStyles);
                player.onDestroy(function () { return setStyles(element, instruction.toStyles); });
                // there still might be a ancestor player animating this
                // element therefore we will still add it as a sub player
                // even if its animation may be disabled
                subPlayers.push(player);
                if (disabledElementsSet.has(element)) {
                    skippedPlayers.push(player);
                }
            }
        });
        // find all of the sub players' corresponding inner animation player
        subPlayers.forEach(function (player) {
            // even if any players are not found for a sub animation then it
            // will still complete itself after the next tick since it's Noop
            var /** @type {?} */ playersForElement = skippedPlayersMap.get(player.element);
            if (playersForElement && playersForElement.length) {
                var /** @type {?} */ innerPlayer = optimizeGroupPlayer(playersForElement);
                player.setRealPlayer(innerPlayer);
            }
        });
        // the reason why we don't actually play the animation is
        // because all that a skipped player is designed to do is to
        // fire the start/done transition callback events
        skippedPlayers.forEach(function (player) {
            if (player.parentPlayer) {
                player.parentPlayer.onDestroy(function () { return player.destroy(); });
            }
            else {
                player.destroy();
            }
        });
        // run through all of the queued removals and see if they
        // were picked up by a query. If not then perform the removal
        // operation right away unless a parent animation is ongoing.
        for (var /** @type {?} */ i = 0; i < allLeaveNodes.length; i++) {
            var /** @type {?} */ element = allLeaveNodes[i];
            var /** @type {?} */ details = /** @type {?} */ (element[REMOVAL_FLAG]);
            removeClass(element, LEAVE_CLASSNAME);
            // this means the element has a removal animation that is being
            // taken care of and therefore the inner elements will hang around
            // until that animation is over (or the parent queried animation)
            if (details && details.hasAnimation)
                continue;
            var /** @type {?} */ players = [];
            // if this element is queried or if it contains queried children
            // then we want for the element not to be removed from the page
            // until the queried animations have finished
            if (queriedElements.size) {
                var /** @type {?} */ queriedPlayerResults = queriedElements.get(element);
                if (queriedPlayerResults && queriedPlayerResults.length) {
                    players.push.apply(players, queriedPlayerResults);
                }
                var /** @type {?} */ queriedInnerElements = this.driver.query(element, NG_ANIMATING_SELECTOR, true);
                for (var /** @type {?} */ j = 0; j < queriedInnerElements.length; j++) {
                    var /** @type {?} */ queriedPlayers = queriedElements.get(queriedInnerElements[j]);
                    if (queriedPlayers && queriedPlayers.length) {
                        players.push.apply(players, queriedPlayers);
                    }
                }
            }
            var /** @type {?} */ activePlayers = players.filter(function (p) { return !p.destroyed; });
            if (activePlayers.length) {
                removeNodesAfterAnimationDone(this, element, activePlayers);
            }
            else {
                this.processLeaveNode(element);
            }
        }
        // this is required so the cleanup method doesn't remove them
        allLeaveNodes.length = 0;
        rootPlayers.forEach(function (player) {
            _this.players.push(player);
            player.onDone(function () {
                player.destroy();
                var /** @type {?} */ index = _this.players.indexOf(player);
                _this.players.splice(index, 1);
            });
            player.play();
        });
        return rootPlayers;
    };
    /**
     * @param {?} namespaceId
     * @param {?} element
     * @return {?}
     */
    TransitionAnimationEngine.prototype.elementContainsData = /**
     * @param {?} namespaceId
     * @param {?} element
     * @return {?}
     */
    function (namespaceId, element) {
        var /** @type {?} */ containsData = false;
        var /** @type {?} */ details = /** @type {?} */ (element[REMOVAL_FLAG]);
        if (details && details.setForRemoval)
            containsData = true;
        if (this.playersByElement.has(element))
            containsData = true;
        if (this.playersByQueriedElement.has(element))
            containsData = true;
        if (this.statesByElement.has(element))
            containsData = true;
        return this._fetchNamespace(namespaceId).elementContainsData(element) || containsData;
    };
    /**
     * @param {?} callback
     * @return {?}
     */
    TransitionAnimationEngine.prototype.afterFlush = /**
     * @param {?} callback
     * @return {?}
     */
    function (callback) { this._flushFns.push(callback); };
    /**
     * @param {?} callback
     * @return {?}
     */
    TransitionAnimationEngine.prototype.afterFlushAnimationsDone = /**
     * @param {?} callback
     * @return {?}
     */
    function (callback) { this._whenQuietFns.push(callback); };
    /**
     * @param {?} element
     * @param {?} isQueriedElement
     * @param {?=} namespaceId
     * @param {?=} triggerName
     * @param {?=} toStateValue
     * @return {?}
     */
    TransitionAnimationEngine.prototype._getPreviousPlayers = /**
     * @param {?} element
     * @param {?} isQueriedElement
     * @param {?=} namespaceId
     * @param {?=} triggerName
     * @param {?=} toStateValue
     * @return {?}
     */
    function (element, isQueriedElement, namespaceId, triggerName, toStateValue) {
        var /** @type {?} */ players = [];
        if (isQueriedElement) {
            var /** @type {?} */ queriedElementPlayers = this.playersByQueriedElement.get(element);
            if (queriedElementPlayers) {
                players = queriedElementPlayers;
            }
        }
        else {
            var /** @type {?} */ elementPlayers = this.playersByElement.get(element);
            if (elementPlayers) {
                var /** @type {?} */ isRemovalAnimation_1 = !toStateValue || toStateValue == VOID_VALUE;
                elementPlayers.forEach(function (player) {
                    if (player.queued)
                        return;
                    if (!isRemovalAnimation_1 && player.triggerName != triggerName)
                        return;
                    players.push(player);
                });
            }
        }
        if (namespaceId || triggerName) {
            players = players.filter(function (player) {
                if (namespaceId && namespaceId != player.namespaceId)
                    return false;
                if (triggerName && triggerName != player.triggerName)
                    return false;
                return true;
            });
        }
        return players;
    };
    /**
     * @param {?} namespaceId
     * @param {?} instruction
     * @param {?} allPreviousPlayersMap
     * @return {?}
     */
    TransitionAnimationEngine.prototype._beforeAnimationBuild = /**
     * @param {?} namespaceId
     * @param {?} instruction
     * @param {?} allPreviousPlayersMap
     * @return {?}
     */
    function (namespaceId, instruction, allPreviousPlayersMap) {
        var _this = this;
        var /** @type {?} */ triggerName = instruction.triggerName;
        var /** @type {?} */ rootElement = instruction.element;
        // when a removal animation occurs, ALL previous players are collected
        // and destroyed (even if they are outside of the current namespace)
        var /** @type {?} */ targetNameSpaceId = instruction.isRemovalTransition ? undefined : namespaceId;
        var /** @type {?} */ targetTriggerName = instruction.isRemovalTransition ? undefined : triggerName;
        instruction.timelines.map(function (timelineInstruction) {
            var /** @type {?} */ element = timelineInstruction.element;
            var /** @type {?} */ isQueriedElement = element !== rootElement;
            var /** @type {?} */ players = getOrSetAsInMap(allPreviousPlayersMap, element, []);
            var /** @type {?} */ previousPlayers = _this._getPreviousPlayers(element, isQueriedElement, targetNameSpaceId, targetTriggerName, instruction.toState);
            previousPlayers.forEach(function (player) {
                var /** @type {?} */ realPlayer = /** @type {?} */ (player.getRealPlayer());
                if (realPlayer.beforeDestroy) {
                    realPlayer.beforeDestroy();
                }
                player.destroy();
                players.push(player);
            });
        });
        // this needs to be done so that the PRE/POST styles can be
        // computed properly without interfering with the previous animation
        eraseStyles(rootElement, instruction.fromStyles);
    };
    /**
     * @param {?} namespaceId
     * @param {?} instruction
     * @param {?} allPreviousPlayersMap
     * @param {?} skippedPlayersMap
     * @param {?} preStylesMap
     * @param {?} postStylesMap
     * @return {?}
     */
    TransitionAnimationEngine.prototype._buildAnimation = /**
     * @param {?} namespaceId
     * @param {?} instruction
     * @param {?} allPreviousPlayersMap
     * @param {?} skippedPlayersMap
     * @param {?} preStylesMap
     * @param {?} postStylesMap
     * @return {?}
     */
    function (namespaceId, instruction, allPreviousPlayersMap, skippedPlayersMap, preStylesMap, postStylesMap) {
        var _this = this;
        var /** @type {?} */ triggerName = instruction.triggerName;
        var /** @type {?} */ rootElement = instruction.element;
        // we first run this so that the previous animation player
        // data can be passed into the successive animation players
        var /** @type {?} */ allQueriedPlayers = [];
        var /** @type {?} */ allConsumedElements = new Set();
        var /** @type {?} */ allSubElements = new Set();
        var /** @type {?} */ allNewPlayers = instruction.timelines.map(function (timelineInstruction) {
            var /** @type {?} */ element = timelineInstruction.element;
            allConsumedElements.add(element);
            // FIXME (matsko): make sure to-be-removed animations are removed properly
            var /** @type {?} */ details = element[REMOVAL_FLAG];
            if (details && details.removedBeforeQueried)
                return new _angular_animations.NoopAnimationPlayer();
            var /** @type {?} */ isQueriedElement = element !== rootElement;
            var /** @type {?} */ previousPlayers = flattenGroupPlayers((allPreviousPlayersMap.get(element) || EMPTY_PLAYER_ARRAY)
                .map(function (p) { return p.getRealPlayer(); }))
                .filter(function (p) {
                // the `element` is not apart of the AnimationPlayer definition, but
                // Mock/WebAnimations
                // use the element within their implementation. This will be added in Angular5 to
                // AnimationPlayer
                var /** @type {?} */ pp = /** @type {?} */ (p);
                return pp.element ? pp.element === element : false;
            });
            var /** @type {?} */ preStyles = preStylesMap.get(element);
            var /** @type {?} */ postStyles = postStylesMap.get(element);
            var /** @type {?} */ keyframes = normalizeKeyframes(_this.driver, _this._normalizer, element, timelineInstruction.keyframes, preStyles, postStyles);
            var /** @type {?} */ player = _this._buildPlayer(timelineInstruction, keyframes, previousPlayers);
            // this means that this particular player belongs to a sub trigger. It is
            // important that we match this player up with the corresponding (@trigger.listener)
            if (timelineInstruction.subTimeline && skippedPlayersMap) {
                allSubElements.add(element);
            }
            if (isQueriedElement) {
                var /** @type {?} */ wrappedPlayer = new TransitionAnimationPlayer(namespaceId, triggerName, element);
                wrappedPlayer.setRealPlayer(player);
                allQueriedPlayers.push(wrappedPlayer);
            }
            return player;
        });
        allQueriedPlayers.forEach(function (player) {
            getOrSetAsInMap(_this.playersByQueriedElement, player.element, []).push(player);
            player.onDone(function () { return deleteOrUnsetInMap(_this.playersByQueriedElement, player.element, player); });
        });
        allConsumedElements.forEach(function (element) { return addClass(element, NG_ANIMATING_CLASSNAME); });
        var /** @type {?} */ player = optimizeGroupPlayer(allNewPlayers);
        player.onDestroy(function () {
            allConsumedElements.forEach(function (element) { return removeClass(element, NG_ANIMATING_CLASSNAME); });
            setStyles(rootElement, instruction.toStyles);
        });
        // this basically makes all of the callbacks for sub element animations
        // be dependent on the upper players for when they finish
        allSubElements.forEach(function (element) { getOrSetAsInMap(skippedPlayersMap, element, []).push(player); });
        return player;
    };
    /**
     * @param {?} instruction
     * @param {?} keyframes
     * @param {?} previousPlayers
     * @return {?}
     */
    TransitionAnimationEngine.prototype._buildPlayer = /**
     * @param {?} instruction
     * @param {?} keyframes
     * @param {?} previousPlayers
     * @return {?}
     */
    function (instruction, keyframes, previousPlayers) {
        if (keyframes.length > 0) {
            return this.driver.animate(instruction.element, keyframes, instruction.duration, instruction.delay, instruction.easing, previousPlayers);
        }
        // special case for when an empty transition|definition is provided
        // ... there is no point in rendering an empty animation
        return new _angular_animations.NoopAnimationPlayer();
    };
    return TransitionAnimationEngine;
}());
var TransitionAnimationPlayer = (function () {
    function TransitionAnimationPlayer(namespaceId, triggerName, element) {
        this.namespaceId = namespaceId;
        this.triggerName = triggerName;
        this.element = element;
        this._player = new _angular_animations.NoopAnimationPlayer();
        this._containsRealPlayer = false;
        this._queuedCallbacks = {};
        this._destroyed = false;
        this.markedForDestroy = false;
    }
    Object.defineProperty(TransitionAnimationPlayer.prototype, "queued", {
        get: /**
         * @return {?}
         */
        function () { return this._containsRealPlayer == false; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TransitionAnimationPlayer.prototype, "destroyed", {
        get: /**
         * @return {?}
         */
        function () { return this._destroyed; },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} player
     * @return {?}
     */
    TransitionAnimationPlayer.prototype.setRealPlayer = /**
     * @param {?} player
     * @return {?}
     */
    function (player) {
        var _this = this;
        if (this._containsRealPlayer)
            return;
        this._player = player;
        Object.keys(this._queuedCallbacks).forEach(function (phase) {
            _this._queuedCallbacks[phase].forEach(function (callback) { return listenOnPlayer(player, phase, undefined, callback); });
        });
        this._queuedCallbacks = {};
        this._containsRealPlayer = true;
    };
    /**
     * @return {?}
     */
    TransitionAnimationPlayer.prototype.getRealPlayer = /**
     * @return {?}
     */
    function () { return this._player; };
    /**
     * @param {?} name
     * @param {?} callback
     * @return {?}
     */
    TransitionAnimationPlayer.prototype._queueEvent = /**
     * @param {?} name
     * @param {?} callback
     * @return {?}
     */
    function (name, callback) {
        getOrSetAsInMap(this._queuedCallbacks, name, []).push(callback);
    };
    /**
     * @param {?} fn
     * @return {?}
     */
    TransitionAnimationPlayer.prototype.onDone = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
        if (this.queued) {
            this._queueEvent('done', fn);
        }
        this._player.onDone(fn);
    };
    /**
     * @param {?} fn
     * @return {?}
     */
    TransitionAnimationPlayer.prototype.onStart = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
        if (this.queued) {
            this._queueEvent('start', fn);
        }
        this._player.onStart(fn);
    };
    /**
     * @param {?} fn
     * @return {?}
     */
    TransitionAnimationPlayer.prototype.onDestroy = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
        if (this.queued) {
            this._queueEvent('destroy', fn);
        }
        this._player.onDestroy(fn);
    };
    /**
     * @return {?}
     */
    TransitionAnimationPlayer.prototype.init = /**
     * @return {?}
     */
    function () { this._player.init(); };
    /**
     * @return {?}
     */
    TransitionAnimationPlayer.prototype.hasStarted = /**
     * @return {?}
     */
    function () { return this.queued ? false : this._player.hasStarted(); };
    /**
     * @return {?}
     */
    TransitionAnimationPlayer.prototype.play = /**
     * @return {?}
     */
    function () { !this.queued && this._player.play(); };
    /**
     * @return {?}
     */
    TransitionAnimationPlayer.prototype.pause = /**
     * @return {?}
     */
    function () { !this.queued && this._player.pause(); };
    /**
     * @return {?}
     */
    TransitionAnimationPlayer.prototype.restart = /**
     * @return {?}
     */
    function () { !this.queued && this._player.restart(); };
    /**
     * @return {?}
     */
    TransitionAnimationPlayer.prototype.finish = /**
     * @return {?}
     */
    function () { this._player.finish(); };
    /**
     * @return {?}
     */
    TransitionAnimationPlayer.prototype.destroy = /**
     * @return {?}
     */
    function () {
        this._destroyed = true;
        this._player.destroy();
    };
    /**
     * @return {?}
     */
    TransitionAnimationPlayer.prototype.reset = /**
     * @return {?}
     */
    function () { !this.queued && this._player.reset(); };
    /**
     * @param {?} p
     * @return {?}
     */
    TransitionAnimationPlayer.prototype.setPosition = /**
     * @param {?} p
     * @return {?}
     */
    function (p) {
        if (!this.queued) {
            this._player.setPosition(p);
        }
    };
    /**
     * @return {?}
     */
    TransitionAnimationPlayer.prototype.getPosition = /**
     * @return {?}
     */
    function () { return this.queued ? 0 : this._player.getPosition(); };
    Object.defineProperty(TransitionAnimationPlayer.prototype, "totalTime", {
        get: /**
         * @return {?}
         */
        function () { return this._player.totalTime; },
        enumerable: true,
        configurable: true
    });
    return TransitionAnimationPlayer;
}());
/**
 * @param {?} map
 * @param {?} key
 * @param {?} value
 * @return {?}
 */
function deleteOrUnsetInMap(map, key, value) {
    var /** @type {?} */ currentValues;
    if (map instanceof Map) {
        currentValues = map.get(key);
        if (currentValues) {
            if (currentValues.length) {
                var /** @type {?} */ index = currentValues.indexOf(value);
                currentValues.splice(index, 1);
            }
            if (currentValues.length == 0) {
                map.delete(key);
            }
        }
    }
    else {
        currentValues = map[key];
        if (currentValues) {
            if (currentValues.length) {
                var /** @type {?} */ index = currentValues.indexOf(value);
                currentValues.splice(index, 1);
            }
            if (currentValues.length == 0) {
                delete map[key];
            }
        }
    }
    return currentValues;
}
/**
 * @param {?} value
 * @return {?}
 */
function normalizeTriggerValue(value) {
    switch (typeof value) {
        case 'boolean':
            return value ? '1' : '0';
        default:
            return value != null ? value.toString() : null;
    }
}
/**
 * @param {?} node
 * @return {?}
 */
function isElementNode(node) {
    return node && node['nodeType'] === 1;
}
/**
 * @param {?} eventName
 * @return {?}
 */
function isTriggerEventValid(eventName) {
    return eventName == 'start' || eventName == 'done';
}
/**
 * @param {?} element
 * @param {?=} value
 * @return {?}
 */
function cloakElement(element, value) {
    var /** @type {?} */ oldValue = element.style.display;
    element.style.display = value != null ? value : 'none';
    return oldValue;
}
/**
 * @param {?} driver
 * @param {?} elements
 * @param {?} elementPropsMap
 * @param {?} defaultStyle
 * @return {?}
 */
function cloakAndComputeStyles(driver, elements, elementPropsMap, defaultStyle) {
    var /** @type {?} */ cloakVals = [];
    elements.forEach(function (element) { return cloakVals.push(cloakElement(element)); });
    var /** @type {?} */ valuesMap = new Map();
    var /** @type {?} */ failedElements = [];
    elementPropsMap.forEach(function (props, element) {
        var /** @type {?} */ styles = {};
        props.forEach(function (prop) {
            var /** @type {?} */ value = styles[prop] = driver.computeStyle(element, prop, defaultStyle);
            // there is no easy way to detect this because a sub element could be removed
            // by a parent animation element being detached.
            if (!value || value.length == 0) {
                element[REMOVAL_FLAG] = NULL_REMOVED_QUERIED_STATE;
                failedElements.push(element);
            }
        });
        valuesMap.set(element, styles);
    });
    // we use a index variable here since Set.forEach(a, i) does not return
    // an index value for the closure (but instead just the value)
    var /** @type {?} */ i = 0;
    elements.forEach(function (element) { return cloakElement(element, cloakVals[i++]); });
    return [valuesMap, failedElements];
}
/**
 * @param {?} nodes
 * @return {?}
 */
function createIsRootFilterFn(nodes) {
    var /** @type {?} */ nodeSet = new Set(nodes);
    var /** @type {?} */ knownRootContainer = new Set();
    var /** @type {?} */ isRoot;
    isRoot = function (node) {
        if (!node)
            return true;
        if (nodeSet.has(node.parentNode))
            return false;
        if (knownRootContainer.has(node.parentNode))
            return true;
        if (isRoot(node.parentNode)) {
            knownRootContainer.add(node);
            return true;
        }
        return false;
    };
    return isRoot;
}
var CLASSES_CACHE_KEY = '$$classes';
/**
 * @param {?} element
 * @param {?} className
 * @return {?}
 */
function containsClass(element, className) {
    if (element.classList) {
        return element.classList.contains(className);
    }
    else {
        var /** @type {?} */ classes = element[CLASSES_CACHE_KEY];
        return classes && classes[className];
    }
}
/**
 * @param {?} element
 * @param {?} className
 * @return {?}
 */
function addClass(element, className) {
    if (element.classList) {
        element.classList.add(className);
    }
    else {
        var /** @type {?} */ classes = element[CLASSES_CACHE_KEY];
        if (!classes) {
            classes = element[CLASSES_CACHE_KEY] = {};
        }
        classes[className] = true;
    }
}
/**
 * @param {?} element
 * @param {?} className
 * @return {?}
 */
function removeClass(element, className) {
    if (element.classList) {
        element.classList.remove(className);
    }
    else {
        var /** @type {?} */ classes = element[CLASSES_CACHE_KEY];
        if (classes) {
            delete classes[className];
        }
    }
}
/**
 * @param {?} engine
 * @param {?} element
 * @param {?} players
 * @return {?}
 */
function removeNodesAfterAnimationDone(engine, element, players) {
    optimizeGroupPlayer(players).onDone(function () { return engine.processLeaveNode(element); });
}
/**
 * @param {?} players
 * @return {?}
 */
function flattenGroupPlayers(players) {
    var /** @type {?} */ finalPlayers = [];
    _flattenGroupPlayersRecur(players, finalPlayers);
    return finalPlayers;
}
/**
 * @param {?} players
 * @param {?} finalPlayers
 * @return {?}
 */
function _flattenGroupPlayersRecur(players, finalPlayers) {
    for (var /** @type {?} */ i = 0; i < players.length; i++) {
        var /** @type {?} */ player = players[i];
        if (player instanceof _angular_animations.ɵAnimationGroupPlayer) {
            _flattenGroupPlayersRecur(player.players, finalPlayers);
        }
        else {
            finalPlayers.push(/** @type {?} */ (player));
        }
    }
}
/**
 * @param {?} a
 * @param {?} b
 * @return {?}
 */
function objEquals(a, b) {
    var /** @type {?} */ k1 = Object.keys(a);
    var /** @type {?} */ k2 = Object.keys(b);
    if (k1.length != k2.length)
        return false;
    for (var /** @type {?} */ i = 0; i < k1.length; i++) {
        var /** @type {?} */ prop = k1[i];
        if (!b.hasOwnProperty(prop) || a[prop] !== b[prop])
            return false;
    }
    return true;
}
/**
 * @param {?} element
 * @param {?} allPreStyleElements
 * @param {?} allPostStyleElements
 * @return {?}
 */
function replacePostStylesAsPre(element, allPreStyleElements, allPostStyleElements) {
    var /** @type {?} */ postEntry = allPostStyleElements.get(element);
    if (!postEntry)
        return false;
    var /** @type {?} */ preEntry = allPreStyleElements.get(element);
    if (preEntry) {
        postEntry.forEach(function (data) { return /** @type {?} */ ((preEntry)).add(data); });
    }
    else {
        allPreStyleElements.set(element, postEntry);
    }
    allPostStyleElements.delete(element);
    return true;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var AnimationEngine = (function () {
    function AnimationEngine(_driver, normalizer) {
        var _this = this;
        this._driver = _driver;
        this._triggerCache = {};
        this.onRemovalComplete = function (element, context) { };
        this._transitionEngine = new TransitionAnimationEngine(_driver, normalizer);
        this._timelineEngine = new TimelineAnimationEngine(_driver, normalizer);
        this._transitionEngine.onRemovalComplete = function (element, context) {
            return _this.onRemovalComplete(element, context);
        };
    }
    /**
     * @param {?} componentId
     * @param {?} namespaceId
     * @param {?} hostElement
     * @param {?} name
     * @param {?} metadata
     * @return {?}
     */
    AnimationEngine.prototype.registerTrigger = /**
     * @param {?} componentId
     * @param {?} namespaceId
     * @param {?} hostElement
     * @param {?} name
     * @param {?} metadata
     * @return {?}
     */
    function (componentId, namespaceId, hostElement, name, metadata) {
        var /** @type {?} */ cacheKey = componentId + '-' + name;
        var /** @type {?} */ trigger = this._triggerCache[cacheKey];
        if (!trigger) {
            var /** @type {?} */ errors = [];
            var /** @type {?} */ ast = /** @type {?} */ (buildAnimationAst(this._driver, /** @type {?} */ (metadata), errors));
            if (errors.length) {
                throw new Error("The animation trigger \"" + name + "\" has failed to build due to the following errors:\n - " + errors.join("\n - "));
            }
            trigger = buildTrigger(name, ast);
            this._triggerCache[cacheKey] = trigger;
        }
        this._transitionEngine.registerTrigger(namespaceId, name, trigger);
    };
    /**
     * @param {?} namespaceId
     * @param {?} hostElement
     * @return {?}
     */
    AnimationEngine.prototype.register = /**
     * @param {?} namespaceId
     * @param {?} hostElement
     * @return {?}
     */
    function (namespaceId, hostElement) {
        this._transitionEngine.register(namespaceId, hostElement);
    };
    /**
     * @param {?} namespaceId
     * @param {?} context
     * @return {?}
     */
    AnimationEngine.prototype.destroy = /**
     * @param {?} namespaceId
     * @param {?} context
     * @return {?}
     */
    function (namespaceId, context) {
        this._transitionEngine.destroy(namespaceId, context);
    };
    /**
     * @param {?} namespaceId
     * @param {?} element
     * @param {?} parent
     * @param {?} insertBefore
     * @return {?}
     */
    AnimationEngine.prototype.onInsert = /**
     * @param {?} namespaceId
     * @param {?} element
     * @param {?} parent
     * @param {?} insertBefore
     * @return {?}
     */
    function (namespaceId, element, parent, insertBefore) {
        this._transitionEngine.insertNode(namespaceId, element, parent, insertBefore);
    };
    /**
     * @param {?} namespaceId
     * @param {?} element
     * @param {?} context
     * @return {?}
     */
    AnimationEngine.prototype.onRemove = /**
     * @param {?} namespaceId
     * @param {?} element
     * @param {?} context
     * @return {?}
     */
    function (namespaceId, element, context) {
        this._transitionEngine.removeNode(namespaceId, element, context);
    };
    /**
     * @param {?} element
     * @param {?} disable
     * @return {?}
     */
    AnimationEngine.prototype.disableAnimations = /**
     * @param {?} element
     * @param {?} disable
     * @return {?}
     */
    function (element, disable) {
        this._transitionEngine.markElementAsDisabled(element, disable);
    };
    /**
     * @param {?} namespaceId
     * @param {?} element
     * @param {?} property
     * @param {?} value
     * @return {?}
     */
    AnimationEngine.prototype.process = /**
     * @param {?} namespaceId
     * @param {?} element
     * @param {?} property
     * @param {?} value
     * @return {?}
     */
    function (namespaceId, element, property, value) {
        if (property.charAt(0) == '@') {
            var _a = parseTimelineCommand(property), id = _a[0], action = _a[1];
            var /** @type {?} */ args = /** @type {?} */ (value);
            this._timelineEngine.command(id, element, action, args);
        }
        else {
            this._transitionEngine.trigger(namespaceId, element, property, value);
        }
    };
    /**
     * @param {?} namespaceId
     * @param {?} element
     * @param {?} eventName
     * @param {?} eventPhase
     * @param {?} callback
     * @return {?}
     */
    AnimationEngine.prototype.listen = /**
     * @param {?} namespaceId
     * @param {?} element
     * @param {?} eventName
     * @param {?} eventPhase
     * @param {?} callback
     * @return {?}
     */
    function (namespaceId, element, eventName, eventPhase, callback) {
        // @@listen
        if (eventName.charAt(0) == '@') {
            var _a = parseTimelineCommand(eventName), id = _a[0], action = _a[1];
            return this._timelineEngine.listen(id, element, action, callback);
        }
        return this._transitionEngine.listen(namespaceId, element, eventName, eventPhase, callback);
    };
    /**
     * @param {?=} microtaskId
     * @return {?}
     */
    AnimationEngine.prototype.flush = /**
     * @param {?=} microtaskId
     * @return {?}
     */
    function (microtaskId) {
        if (microtaskId === void 0) { microtaskId = -1; }
        this._transitionEngine.flush(microtaskId);
    };
    Object.defineProperty(AnimationEngine.prototype, "players", {
        get: /**
         * @return {?}
         */
        function () {
            return (/** @type {?} */ (this._transitionEngine.players))
                .concat(/** @type {?} */ (this._timelineEngine.players));
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    AnimationEngine.prototype.whenRenderingDone = /**
     * @return {?}
     */
    function () { return this._transitionEngine.whenRenderingDone(); };
    return AnimationEngine;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var WebAnimationsPlayer = (function () {
    function WebAnimationsPlayer(element, keyframes, options, previousPlayers) {
        if (previousPlayers === void 0) { previousPlayers = []; }
        var _this = this;
        this.element = element;
        this.keyframes = keyframes;
        this.options = options;
        this.previousPlayers = previousPlayers;
        this._onDoneFns = [];
        this._onStartFns = [];
        this._onDestroyFns = [];
        this._initialized = false;
        this._finished = false;
        this._started = false;
        this._destroyed = false;
        this.time = 0;
        this.parentPlayer = null;
        this.previousStyles = {};
        this.currentSnapshot = {};
        this._duration = /** @type {?} */ (options['duration']);
        this._delay = /** @type {?} */ (options['delay']) || 0;
        this.time = this._duration + this._delay;
        if (allowPreviousPlayerStylesMerge(this._duration, this._delay)) {
            previousPlayers.forEach(function (player) {
                var /** @type {?} */ styles = player.currentSnapshot;
                Object.keys(styles).forEach(function (prop) { return _this.previousStyles[prop] = styles[prop]; });
            });
        }
    }
    /**
     * @return {?}
     */
    WebAnimationsPlayer.prototype._onFinish = /**
     * @return {?}
     */
    function () {
        if (!this._finished) {
            this._finished = true;
            this._onDoneFns.forEach(function (fn) { return fn(); });
            this._onDoneFns = [];
        }
    };
    /**
     * @return {?}
     */
    WebAnimationsPlayer.prototype.init = /**
     * @return {?}
     */
    function () {
        this._buildPlayer();
        this._preparePlayerBeforeStart();
    };
    /**
     * @return {?}
     */
    WebAnimationsPlayer.prototype._buildPlayer = /**
     * @return {?}
     */
    function () {
        var _this = this;
        if (this._initialized)
            return;
        this._initialized = true;
        var /** @type {?} */ keyframes = this.keyframes.map(function (styles) { return copyStyles(styles, false); });
        var /** @type {?} */ previousStyleProps = Object.keys(this.previousStyles);
        if (previousStyleProps.length) {
            var /** @type {?} */ startingKeyframe_1 = keyframes[0];
            var /** @type {?} */ missingStyleProps_1 = [];
            previousStyleProps.forEach(function (prop) {
                if (!startingKeyframe_1.hasOwnProperty(prop)) {
                    missingStyleProps_1.push(prop);
                }
                startingKeyframe_1[prop] = _this.previousStyles[prop];
            });
            if (missingStyleProps_1.length) {
                var /** @type {?} */ self_1 = this;
                var _loop_1 = function () {
                    var /** @type {?} */ kf = keyframes[i];
                    missingStyleProps_1.forEach(function (prop) {
                        kf[prop] = _computeStyle(self_1.element, prop);
                    });
                };
                // tslint:disable-next-line
                for (var /** @type {?} */ i = 1; i < keyframes.length; i++) {
                    _loop_1();
                }
            }
        }
        this._player = this._triggerWebAnimation(this.element, keyframes, this.options);
        this._finalKeyframe = keyframes.length ? keyframes[keyframes.length - 1] : {};
        this._player.addEventListener('finish', function () { return _this._onFinish(); });
    };
    /**
     * @return {?}
     */
    WebAnimationsPlayer.prototype._preparePlayerBeforeStart = /**
     * @return {?}
     */
    function () {
        // this is required so that the player doesn't start to animate right away
        if (this._delay) {
            this._resetDomPlayerState();
        }
        else {
            this._player.pause();
        }
    };
    /** @internal */
    /**
     * \@internal
     * @param {?} element
     * @param {?} keyframes
     * @param {?} options
     * @return {?}
     */
    WebAnimationsPlayer.prototype._triggerWebAnimation = /**
     * \@internal
     * @param {?} element
     * @param {?} keyframes
     * @param {?} options
     * @return {?}
     */
    function (element, keyframes, options) {
        // jscompiler doesn't seem to know animate is a native property because it's not fully
        // supported yet across common browsers (we polyfill it for Edge/Safari) [CL #143630929]
        return /** @type {?} */ (element['animate'](keyframes, options));
    };
    Object.defineProperty(WebAnimationsPlayer.prototype, "domPlayer", {
        get: /**
         * @return {?}
         */
        function () { return this._player; },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} fn
     * @return {?}
     */
    WebAnimationsPlayer.prototype.onStart = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) { this._onStartFns.push(fn); };
    /**
     * @param {?} fn
     * @return {?}
     */
    WebAnimationsPlayer.prototype.onDone = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) { this._onDoneFns.push(fn); };
    /**
     * @param {?} fn
     * @return {?}
     */
    WebAnimationsPlayer.prototype.onDestroy = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) { this._onDestroyFns.push(fn); };
    /**
     * @return {?}
     */
    WebAnimationsPlayer.prototype.play = /**
     * @return {?}
     */
    function () {
        this._buildPlayer();
        if (!this.hasStarted()) {
            this._onStartFns.forEach(function (fn) { return fn(); });
            this._onStartFns = [];
            this._started = true;
        }
        this._player.play();
    };
    /**
     * @return {?}
     */
    WebAnimationsPlayer.prototype.pause = /**
     * @return {?}
     */
    function () {
        this.init();
        this._player.pause();
    };
    /**
     * @return {?}
     */
    WebAnimationsPlayer.prototype.finish = /**
     * @return {?}
     */
    function () {
        this.init();
        this._onFinish();
        this._player.finish();
    };
    /**
     * @return {?}
     */
    WebAnimationsPlayer.prototype.reset = /**
     * @return {?}
     */
    function () {
        this._resetDomPlayerState();
        this._destroyed = false;
        this._finished = false;
        this._started = false;
    };
    /**
     * @return {?}
     */
    WebAnimationsPlayer.prototype._resetDomPlayerState = /**
     * @return {?}
     */
    function () {
        if (this._player) {
            this._player.cancel();
        }
    };
    /**
     * @return {?}
     */
    WebAnimationsPlayer.prototype.restart = /**
     * @return {?}
     */
    function () {
        this.reset();
        this.play();
    };
    /**
     * @return {?}
     */
    WebAnimationsPlayer.prototype.hasStarted = /**
     * @return {?}
     */
    function () { return this._started; };
    /**
     * @return {?}
     */
    WebAnimationsPlayer.prototype.destroy = /**
     * @return {?}
     */
    function () {
        if (!this._destroyed) {
            this._destroyed = true;
            this._resetDomPlayerState();
            this._onFinish();
            this._onDestroyFns.forEach(function (fn) { return fn(); });
            this._onDestroyFns = [];
        }
    };
    /**
     * @param {?} p
     * @return {?}
     */
    WebAnimationsPlayer.prototype.setPosition = /**
     * @param {?} p
     * @return {?}
     */
    function (p) { this._player.currentTime = p * this.time; };
    /**
     * @return {?}
     */
    WebAnimationsPlayer.prototype.getPosition = /**
     * @return {?}
     */
    function () { return this._player.currentTime / this.time; };
    Object.defineProperty(WebAnimationsPlayer.prototype, "totalTime", {
        get: /**
         * @return {?}
         */
        function () { return this._delay + this._duration; },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    WebAnimationsPlayer.prototype.beforeDestroy = /**
     * @return {?}
     */
    function () {
        var _this = this;
        var /** @type {?} */ styles = {};
        if (this.hasStarted()) {
            Object.keys(this._finalKeyframe).forEach(function (prop) {
                if (prop != 'offset') {
                    styles[prop] =
                        _this._finished ? _this._finalKeyframe[prop] : _computeStyle(_this.element, prop);
                }
            });
        }
        this.currentSnapshot = styles;
    };
    return WebAnimationsPlayer;
}());
/**
 * @param {?} element
 * @param {?} prop
 * @return {?}
 */
function _computeStyle(element, prop) {
    return (/** @type {?} */ (window.getComputedStyle(element)))[prop];
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var WebAnimationsDriver = (function () {
    function WebAnimationsDriver() {
    }
    /**
     * @param {?} prop
     * @return {?}
     */
    WebAnimationsDriver.prototype.validateStyleProperty = /**
     * @param {?} prop
     * @return {?}
     */
    function (prop) { return validateStyleProperty(prop); };
    /**
     * @param {?} element
     * @param {?} selector
     * @return {?}
     */
    WebAnimationsDriver.prototype.matchesElement = /**
     * @param {?} element
     * @param {?} selector
     * @return {?}
     */
    function (element, selector) {
        return matchesElement(element, selector);
    };
    /**
     * @param {?} elm1
     * @param {?} elm2
     * @return {?}
     */
    WebAnimationsDriver.prototype.containsElement = /**
     * @param {?} elm1
     * @param {?} elm2
     * @return {?}
     */
    function (elm1, elm2) { return containsElement(elm1, elm2); };
    /**
     * @param {?} element
     * @param {?} selector
     * @param {?} multi
     * @return {?}
     */
    WebAnimationsDriver.prototype.query = /**
     * @param {?} element
     * @param {?} selector
     * @param {?} multi
     * @return {?}
     */
    function (element, selector, multi) {
        return invokeQuery(element, selector, multi);
    };
    /**
     * @param {?} element
     * @param {?} prop
     * @param {?=} defaultValue
     * @return {?}
     */
    WebAnimationsDriver.prototype.computeStyle = /**
     * @param {?} element
     * @param {?} prop
     * @param {?=} defaultValue
     * @return {?}
     */
    function (element, prop, defaultValue) {
        return /** @type {?} */ ((/** @type {?} */ (window.getComputedStyle(element)))[prop]);
    };
    /**
     * @param {?} element
     * @param {?} keyframes
     * @param {?} duration
     * @param {?} delay
     * @param {?} easing
     * @param {?=} previousPlayers
     * @return {?}
     */
    WebAnimationsDriver.prototype.animate = /**
     * @param {?} element
     * @param {?} keyframes
     * @param {?} duration
     * @param {?} delay
     * @param {?} easing
     * @param {?=} previousPlayers
     * @return {?}
     */
    function (element, keyframes, duration, delay, easing, previousPlayers) {
        if (previousPlayers === void 0) { previousPlayers = []; }
        var /** @type {?} */ fill = delay == 0 ? 'both' : 'forwards';
        var /** @type {?} */ playerOptions = { duration: duration, delay: delay, fill: fill };
        // we check for this to avoid having a null|undefined value be present
        // for the easing (which results in an error for certain browsers #9752)
        if (easing) {
            playerOptions['easing'] = easing;
        }
        var /** @type {?} */ previousWebAnimationPlayers = /** @type {?} */ (previousPlayers.filter(function (player) { return player instanceof WebAnimationsPlayer; }));
        return new WebAnimationsPlayer(element, keyframes, playerOptions, previousWebAnimationPlayers);
    };
    return WebAnimationsDriver;
}());
/**
 * @return {?}
 */
function supportsWebAnimations() {
    return typeof Element !== 'undefined' && typeof (/** @type {?} */ (Element)).prototype['animate'] === 'function';
}

exports.AnimationDriver = AnimationDriver;
exports.ɵAnimation = Animation;
exports.ɵAnimationStyleNormalizer = AnimationStyleNormalizer;
exports.ɵNoopAnimationStyleNormalizer = NoopAnimationStyleNormalizer;
exports.ɵWebAnimationsStyleNormalizer = WebAnimationsStyleNormalizer;
exports.ɵNoopAnimationDriver = NoopAnimationDriver;
exports.ɵAnimationEngine = AnimationEngine;
exports.ɵWebAnimationsDriver = WebAnimationsDriver;
exports.ɵsupportsWebAnimations = supportsWebAnimations;
exports.ɵWebAnimationsPlayer = WebAnimationsPlayer;

Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=animations-browser.umd.js.map


/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(2))(42);

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(2))(97);

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * @license Angular v5.0.0-beta.7
 * (c) 2010-2017 Google, Inc. https://angular.io/
 * License: MIT
 */
(function (global, factory) {
	 true ? factory(exports, __webpack_require__(0), __webpack_require__(6), __webpack_require__(19), __webpack_require__(35)) :
	typeof define === 'function' && define.amd ? define(['exports', '@angular/core', '@angular/platform-browser', '@angular/animations', '@angular/animations/browser'], factory) :
	(factory((global.ng = global.ng || {}, global.ng.platformBrowser = global.ng.platformBrowser || {}, global.ng.platformBrowser.animations = {}),global.ng.core,global.ng.platformBrowser,global.ng.animations,global.ng.animations.browser));
}(this, (function (exports,_angular_core,_angular_platformBrowser,_angular_animations,_angular_animations_browser) { 'use strict';

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = Object.setPrototypeOf ||
    ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
    function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

/**
 * @license Angular v5.0.0-beta.7
 * (c) 2010-2017 Google, Inc. https://angular.io/
 * License: MIT
 */
/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var BrowserAnimationBuilder = (function (_super) {
    __extends(BrowserAnimationBuilder, _super);
    function BrowserAnimationBuilder(rootRenderer, doc) {
        var _this = _super.call(this) || this;
        _this._nextAnimationId = 0;
        var /** @type {?} */ typeData = /** @type {?} */ ({
            id: '0',
            encapsulation: _angular_core.ViewEncapsulation.None,
            styles: [],
            data: { animation: [] }
        });
        _this._renderer = /** @type {?} */ (rootRenderer.createRenderer(doc.body, typeData));
        return _this;
    }
    /**
     * @param {?} animation
     * @return {?}
     */
    BrowserAnimationBuilder.prototype.build = /**
     * @param {?} animation
     * @return {?}
     */
    function (animation) {
        var /** @type {?} */ id = this._nextAnimationId.toString();
        this._nextAnimationId++;
        var /** @type {?} */ entry = Array.isArray(animation) ? _angular_animations.sequence(animation) : animation;
        issueAnimationCommand(this._renderer, null, id, 'register', [entry]);
        return new BrowserAnimationFactory(id, this._renderer);
    };
    BrowserAnimationBuilder.decorators = [
        { type: _angular_core.Injectable },
    ];
    /** @nocollapse */
    BrowserAnimationBuilder.ctorParameters = function () { return [
        { type: _angular_core.RendererFactory2, },
        { type: undefined, decorators: [{ type: _angular_core.Inject, args: [_angular_platformBrowser.DOCUMENT,] },] },
    ]; };
    return BrowserAnimationBuilder;
}(_angular_animations.AnimationBuilder));
var BrowserAnimationFactory = (function (_super) {
    __extends(BrowserAnimationFactory, _super);
    function BrowserAnimationFactory(_id, _renderer) {
        var _this = _super.call(this) || this;
        _this._id = _id;
        _this._renderer = _renderer;
        return _this;
    }
    /**
     * @param {?} element
     * @param {?=} options
     * @return {?}
     */
    BrowserAnimationFactory.prototype.create = /**
     * @param {?} element
     * @param {?=} options
     * @return {?}
     */
    function (element, options) {
        return new RendererAnimationPlayer(this._id, element, options || {}, this._renderer);
    };
    return BrowserAnimationFactory;
}(_angular_animations.AnimationFactory));
var RendererAnimationPlayer = (function () {
    function RendererAnimationPlayer(id, element, options, _renderer) {
        this.id = id;
        this.element = element;
        this._renderer = _renderer;
        this.parentPlayer = null;
        this._started = false;
        this.totalTime = 0;
        this._command('create', options);
    }
    /**
     * @param {?} eventName
     * @param {?} callback
     * @return {?}
     */
    RendererAnimationPlayer.prototype._listen = /**
     * @param {?} eventName
     * @param {?} callback
     * @return {?}
     */
    function (eventName, callback) {
        return this._renderer.listen(this.element, "@@" + this.id + ":" + eventName, callback);
    };
    /**
     * @param {?} command
     * @param {...?} args
     * @return {?}
     */
    RendererAnimationPlayer.prototype._command = /**
     * @param {?} command
     * @param {...?} args
     * @return {?}
     */
    function (command) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        return issueAnimationCommand(this._renderer, this.element, this.id, command, args);
    };
    /**
     * @param {?} fn
     * @return {?}
     */
    RendererAnimationPlayer.prototype.onDone = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) { this._listen('done', fn); };
    /**
     * @param {?} fn
     * @return {?}
     */
    RendererAnimationPlayer.prototype.onStart = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) { this._listen('start', fn); };
    /**
     * @param {?} fn
     * @return {?}
     */
    RendererAnimationPlayer.prototype.onDestroy = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) { this._listen('destroy', fn); };
    /**
     * @return {?}
     */
    RendererAnimationPlayer.prototype.init = /**
     * @return {?}
     */
    function () { this._command('init'); };
    /**
     * @return {?}
     */
    RendererAnimationPlayer.prototype.hasStarted = /**
     * @return {?}
     */
    function () { return this._started; };
    /**
     * @return {?}
     */
    RendererAnimationPlayer.prototype.play = /**
     * @return {?}
     */
    function () {
        this._command('play');
        this._started = true;
    };
    /**
     * @return {?}
     */
    RendererAnimationPlayer.prototype.pause = /**
     * @return {?}
     */
    function () { this._command('pause'); };
    /**
     * @return {?}
     */
    RendererAnimationPlayer.prototype.restart = /**
     * @return {?}
     */
    function () { this._command('restart'); };
    /**
     * @return {?}
     */
    RendererAnimationPlayer.prototype.finish = /**
     * @return {?}
     */
    function () { this._command('finish'); };
    /**
     * @return {?}
     */
    RendererAnimationPlayer.prototype.destroy = /**
     * @return {?}
     */
    function () { this._command('destroy'); };
    /**
     * @return {?}
     */
    RendererAnimationPlayer.prototype.reset = /**
     * @return {?}
     */
    function () { this._command('reset'); };
    /**
     * @param {?} p
     * @return {?}
     */
    RendererAnimationPlayer.prototype.setPosition = /**
     * @param {?} p
     * @return {?}
     */
    function (p) { this._command('setPosition', p); };
    /**
     * @return {?}
     */
    RendererAnimationPlayer.prototype.getPosition = /**
     * @return {?}
     */
    function () { return 0; };
    return RendererAnimationPlayer;
}());
/**
 * @param {?} renderer
 * @param {?} element
 * @param {?} id
 * @param {?} command
 * @param {?} args
 * @return {?}
 */
function issueAnimationCommand(renderer, element, id, command, args) {
    return renderer.setProperty(element, "@@" + id + ":" + command, args);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var ANIMATION_PREFIX = '@';
var DISABLE_ANIMATIONS_FLAG = '@.disabled';
var AnimationRendererFactory = (function () {
    function AnimationRendererFactory(delegate, engine, _zone) {
        this.delegate = delegate;
        this.engine = engine;
        this._zone = _zone;
        this._currentId = 0;
        this._microtaskId = 1;
        this._animationCallbacksBuffer = [];
        this._rendererCache = new Map();
        this._cdRecurDepth = 0;
        engine.onRemovalComplete = function (element, delegate) {
            // Note: if an component element has a leave animation, and the component
            // a host leave animation, the view engine will call `removeChild` for the parent
            // component renderer as well as for the child component renderer.
            // Therefore, we need to check if we already removed the element.
            if (delegate && delegate.parentNode(element)) {
                delegate.removeChild(element.parentNode, element);
            }
        };
    }
    /**
     * @param {?} hostElement
     * @param {?} type
     * @return {?}
     */
    AnimationRendererFactory.prototype.createRenderer = /**
     * @param {?} hostElement
     * @param {?} type
     * @return {?}
     */
    function (hostElement, type) {
        var _this = this;
        var /** @type {?} */ EMPTY_NAMESPACE_ID = '';
        // cache the delegates to find out which cached delegate can
        // be used by which cached renderer
        var /** @type {?} */ delegate = this.delegate.createRenderer(hostElement, type);
        if (!hostElement || !type || !type.data || !type.data['animation']) {
            var /** @type {?} */ renderer = this._rendererCache.get(delegate);
            if (!renderer) {
                renderer = new BaseAnimationRenderer(EMPTY_NAMESPACE_ID, delegate, this.engine);
                // only cache this result when the base renderer is used
                this._rendererCache.set(delegate, renderer);
            }
            return renderer;
        }
        var /** @type {?} */ componentId = type.id;
        var /** @type {?} */ namespaceId = type.id + '-' + this._currentId;
        this._currentId++;
        this.engine.register(namespaceId, hostElement);
        var /** @type {?} */ animationTriggers = /** @type {?} */ (type.data['animation']);
        animationTriggers.forEach(function (trigger) {
            return _this.engine.registerTrigger(componentId, namespaceId, hostElement, trigger.name, trigger);
        });
        return new AnimationRenderer(this, namespaceId, delegate, this.engine);
    };
    /**
     * @return {?}
     */
    AnimationRendererFactory.prototype.begin = /**
     * @return {?}
     */
    function () {
        this._cdRecurDepth++;
        if (this.delegate.begin) {
            this.delegate.begin();
        }
    };
    /**
     * @return {?}
     */
    AnimationRendererFactory.prototype._scheduleCountTask = /**
     * @return {?}
     */
    function () {
        var _this = this;
        Zone.current.scheduleMicroTask('incremenet the animation microtask', function () { return _this._microtaskId++; });
    };
    /* @internal */
    /**
     * @param {?} count
     * @param {?} fn
     * @param {?} data
     * @return {?}
     */
    AnimationRendererFactory.prototype.scheduleListenerCallback = /**
     * @param {?} count
     * @param {?} fn
     * @param {?} data
     * @return {?}
     */
    function (count, fn, data) {
        var _this = this;
        if (count >= 0 && count < this._microtaskId) {
            this._zone.run(function () { return fn(data); });
            return;
        }
        if (this._animationCallbacksBuffer.length == 0) {
            Promise.resolve(null).then(function () {
                _this._zone.run(function () {
                    _this._animationCallbacksBuffer.forEach(function (tuple) {
                        var fn = tuple[0], data = tuple[1];
                        fn(data);
                    });
                    _this._animationCallbacksBuffer = [];
                });
            });
        }
        this._animationCallbacksBuffer.push([fn, data]);
    };
    /**
     * @return {?}
     */
    AnimationRendererFactory.prototype.end = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this._cdRecurDepth--;
        // this is to prevent animations from running twice when an inner
        // component does CD when a parent component insted has inserted it
        if (this._cdRecurDepth == 0) {
            this._zone.runOutsideAngular(function () {
                _this._scheduleCountTask();
                _this.engine.flush(_this._microtaskId);
            });
        }
        if (this.delegate.end) {
            this.delegate.end();
        }
    };
    /**
     * @return {?}
     */
    AnimationRendererFactory.prototype.whenRenderingDone = /**
     * @return {?}
     */
    function () { return this.engine.whenRenderingDone(); };
    AnimationRendererFactory.decorators = [
        { type: _angular_core.Injectable },
    ];
    /** @nocollapse */
    AnimationRendererFactory.ctorParameters = function () { return [
        { type: _angular_core.RendererFactory2, },
        { type: _angular_animations_browser.ɵAnimationEngine, },
        { type: _angular_core.NgZone, },
    ]; };
    return AnimationRendererFactory;
}());
var BaseAnimationRenderer = (function () {
    function BaseAnimationRenderer(namespaceId, delegate, engine) {
        this.namespaceId = namespaceId;
        this.delegate = delegate;
        this.engine = engine;
        this.destroyNode = this.delegate.destroyNode ? function (n) { return /** @type {?} */ ((delegate.destroyNode))(n); } : null;
    }
    Object.defineProperty(BaseAnimationRenderer.prototype, "data", {
        get: /**
         * @return {?}
         */
        function () { return this.delegate.data; },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    BaseAnimationRenderer.prototype.destroy = /**
     * @return {?}
     */
    function () {
        this.engine.destroy(this.namespaceId, this.delegate);
        this.delegate.destroy();
    };
    /**
     * @param {?} name
     * @param {?=} namespace
     * @return {?}
     */
    BaseAnimationRenderer.prototype.createElement = /**
     * @param {?} name
     * @param {?=} namespace
     * @return {?}
     */
    function (name, namespace) {
        return this.delegate.createElement(name, namespace);
    };
    /**
     * @param {?} value
     * @return {?}
     */
    BaseAnimationRenderer.prototype.createComment = /**
     * @param {?} value
     * @return {?}
     */
    function (value) { return this.delegate.createComment(value); };
    /**
     * @param {?} value
     * @return {?}
     */
    BaseAnimationRenderer.prototype.createText = /**
     * @param {?} value
     * @return {?}
     */
    function (value) { return this.delegate.createText(value); };
    /**
     * @param {?} parent
     * @param {?} newChild
     * @return {?}
     */
    BaseAnimationRenderer.prototype.appendChild = /**
     * @param {?} parent
     * @param {?} newChild
     * @return {?}
     */
    function (parent, newChild) {
        this.delegate.appendChild(parent, newChild);
        this.engine.onInsert(this.namespaceId, newChild, parent, false);
    };
    /**
     * @param {?} parent
     * @param {?} newChild
     * @param {?} refChild
     * @return {?}
     */
    BaseAnimationRenderer.prototype.insertBefore = /**
     * @param {?} parent
     * @param {?} newChild
     * @param {?} refChild
     * @return {?}
     */
    function (parent, newChild, refChild) {
        this.delegate.insertBefore(parent, newChild, refChild);
        this.engine.onInsert(this.namespaceId, newChild, parent, true);
    };
    /**
     * @param {?} parent
     * @param {?} oldChild
     * @return {?}
     */
    BaseAnimationRenderer.prototype.removeChild = /**
     * @param {?} parent
     * @param {?} oldChild
     * @return {?}
     */
    function (parent, oldChild) {
        this.engine.onRemove(this.namespaceId, oldChild, this.delegate);
    };
    /**
     * @param {?} selectorOrNode
     * @return {?}
     */
    BaseAnimationRenderer.prototype.selectRootElement = /**
     * @param {?} selectorOrNode
     * @return {?}
     */
    function (selectorOrNode) { return this.delegate.selectRootElement(selectorOrNode); };
    /**
     * @param {?} node
     * @return {?}
     */
    BaseAnimationRenderer.prototype.parentNode = /**
     * @param {?} node
     * @return {?}
     */
    function (node) { return this.delegate.parentNode(node); };
    /**
     * @param {?} node
     * @return {?}
     */
    BaseAnimationRenderer.prototype.nextSibling = /**
     * @param {?} node
     * @return {?}
     */
    function (node) { return this.delegate.nextSibling(node); };
    /**
     * @param {?} el
     * @param {?} name
     * @param {?} value
     * @param {?=} namespace
     * @return {?}
     */
    BaseAnimationRenderer.prototype.setAttribute = /**
     * @param {?} el
     * @param {?} name
     * @param {?} value
     * @param {?=} namespace
     * @return {?}
     */
    function (el, name, value, namespace) {
        this.delegate.setAttribute(el, name, value, namespace);
    };
    /**
     * @param {?} el
     * @param {?} name
     * @param {?=} namespace
     * @return {?}
     */
    BaseAnimationRenderer.prototype.removeAttribute = /**
     * @param {?} el
     * @param {?} name
     * @param {?=} namespace
     * @return {?}
     */
    function (el, name, namespace) {
        this.delegate.removeAttribute(el, name, namespace);
    };
    /**
     * @param {?} el
     * @param {?} name
     * @return {?}
     */
    BaseAnimationRenderer.prototype.addClass = /**
     * @param {?} el
     * @param {?} name
     * @return {?}
     */
    function (el, name) { this.delegate.addClass(el, name); };
    /**
     * @param {?} el
     * @param {?} name
     * @return {?}
     */
    BaseAnimationRenderer.prototype.removeClass = /**
     * @param {?} el
     * @param {?} name
     * @return {?}
     */
    function (el, name) { this.delegate.removeClass(el, name); };
    /**
     * @param {?} el
     * @param {?} style
     * @param {?} value
     * @param {?=} flags
     * @return {?}
     */
    BaseAnimationRenderer.prototype.setStyle = /**
     * @param {?} el
     * @param {?} style
     * @param {?} value
     * @param {?=} flags
     * @return {?}
     */
    function (el, style, value, flags) {
        this.delegate.setStyle(el, style, value, flags);
    };
    /**
     * @param {?} el
     * @param {?} style
     * @param {?=} flags
     * @return {?}
     */
    BaseAnimationRenderer.prototype.removeStyle = /**
     * @param {?} el
     * @param {?} style
     * @param {?=} flags
     * @return {?}
     */
    function (el, style, flags) {
        this.delegate.removeStyle(el, style, flags);
    };
    /**
     * @param {?} el
     * @param {?} name
     * @param {?} value
     * @return {?}
     */
    BaseAnimationRenderer.prototype.setProperty = /**
     * @param {?} el
     * @param {?} name
     * @param {?} value
     * @return {?}
     */
    function (el, name, value) {
        if (name.charAt(0) == ANIMATION_PREFIX && name == DISABLE_ANIMATIONS_FLAG) {
            this.disableAnimations(el, !!value);
        }
        else {
            this.delegate.setProperty(el, name, value);
        }
    };
    /**
     * @param {?} node
     * @param {?} value
     * @return {?}
     */
    BaseAnimationRenderer.prototype.setValue = /**
     * @param {?} node
     * @param {?} value
     * @return {?}
     */
    function (node, value) { this.delegate.setValue(node, value); };
    /**
     * @param {?} target
     * @param {?} eventName
     * @param {?} callback
     * @return {?}
     */
    BaseAnimationRenderer.prototype.listen = /**
     * @param {?} target
     * @param {?} eventName
     * @param {?} callback
     * @return {?}
     */
    function (target, eventName, callback) {
        return this.delegate.listen(target, eventName, callback);
    };
    /**
     * @param {?} element
     * @param {?} value
     * @return {?}
     */
    BaseAnimationRenderer.prototype.disableAnimations = /**
     * @param {?} element
     * @param {?} value
     * @return {?}
     */
    function (element, value) {
        this.engine.disableAnimations(element, value);
    };
    return BaseAnimationRenderer;
}());
var AnimationRenderer = (function (_super) {
    __extends(AnimationRenderer, _super);
    function AnimationRenderer(factory, namespaceId, delegate, engine) {
        var _this = _super.call(this, namespaceId, delegate, engine) || this;
        _this.factory = factory;
        _this.namespaceId = namespaceId;
        return _this;
    }
    /**
     * @param {?} el
     * @param {?} name
     * @param {?} value
     * @return {?}
     */
    AnimationRenderer.prototype.setProperty = /**
     * @param {?} el
     * @param {?} name
     * @param {?} value
     * @return {?}
     */
    function (el, name, value) {
        if (name.charAt(0) == ANIMATION_PREFIX) {
            if (name.charAt(1) == '.' && name == DISABLE_ANIMATIONS_FLAG) {
                value = value === undefined ? true : !!value;
                this.disableAnimations(el, /** @type {?} */ (value));
            }
            else {
                this.engine.process(this.namespaceId, el, name.substr(1), value);
            }
        }
        else {
            this.delegate.setProperty(el, name, value);
        }
    };
    /**
     * @param {?} target
     * @param {?} eventName
     * @param {?} callback
     * @return {?}
     */
    AnimationRenderer.prototype.listen = /**
     * @param {?} target
     * @param {?} eventName
     * @param {?} callback
     * @return {?}
     */
    function (target, eventName, callback) {
        var _this = this;
        if (eventName.charAt(0) == ANIMATION_PREFIX) {
            var /** @type {?} */ element = resolveElementFromTarget(target);
            var /** @type {?} */ name_1 = eventName.substr(1);
            var /** @type {?} */ phase = '';
            // @listener.phase is for trigger animation callbacks
            // @@listener is for animation builder callbacks
            if (name_1.charAt(0) != ANIMATION_PREFIX) {
                _a = parseTriggerCallbackName(name_1), name_1 = _a[0], phase = _a[1];
            }
            return this.engine.listen(this.namespaceId, element, name_1, phase, function (event) {
                var /** @type {?} */ countId = (/** @type {?} */ (event))['_data'] || -1;
                _this.factory.scheduleListenerCallback(countId, callback, event);
            });
        }
        return this.delegate.listen(target, eventName, callback);
        var _a;
    };
    return AnimationRenderer;
}(BaseAnimationRenderer));
/**
 * @param {?} target
 * @return {?}
 */
function resolveElementFromTarget(target) {
    switch (target) {
        case 'body':
            return document.body;
        case 'document':
            return document;
        case 'window':
            return window;
        default:
            return target;
    }
}
/**
 * @param {?} triggerName
 * @return {?}
 */
function parseTriggerCallbackName(triggerName) {
    var /** @type {?} */ dotIndex = triggerName.indexOf('.');
    var /** @type {?} */ trigger = triggerName.substring(0, dotIndex);
    var /** @type {?} */ phase = triggerName.substr(dotIndex + 1);
    return [trigger, phase];
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var InjectableAnimationEngine = (function (_super) {
    __extends(InjectableAnimationEngine, _super);
    function InjectableAnimationEngine(driver, normalizer) {
        return _super.call(this, driver, normalizer) || this;
    }
    InjectableAnimationEngine.decorators = [
        { type: _angular_core.Injectable },
    ];
    /** @nocollapse */
    InjectableAnimationEngine.ctorParameters = function () { return [
        { type: _angular_animations_browser.AnimationDriver, },
        { type: _angular_animations_browser.ɵAnimationStyleNormalizer, },
    ]; };
    return InjectableAnimationEngine;
}(_angular_animations_browser.ɵAnimationEngine));
/**
 * @return {?}
 */
function instantiateSupportedAnimationDriver() {
    if (_angular_animations_browser.ɵsupportsWebAnimations()) {
        return new _angular_animations_browser.ɵWebAnimationsDriver();
    }
    return new _angular_animations_browser.ɵNoopAnimationDriver();
}
/**
 * @return {?}
 */
function instantiateDefaultStyleNormalizer() {
    return new _angular_animations_browser.ɵWebAnimationsStyleNormalizer();
}
/**
 * @param {?} renderer
 * @param {?} engine
 * @param {?} zone
 * @return {?}
 */
function instantiateRendererFactory(renderer, engine, zone) {
    return new AnimationRendererFactory(renderer, engine, zone);
}
var SHARED_ANIMATION_PROVIDERS = [
    { provide: _angular_animations.AnimationBuilder, useClass: BrowserAnimationBuilder },
    { provide: _angular_animations_browser.ɵAnimationStyleNormalizer, useFactory: instantiateDefaultStyleNormalizer },
    { provide: _angular_animations_browser.ɵAnimationEngine, useClass: InjectableAnimationEngine }, {
        provide: _angular_core.RendererFactory2,
        useFactory: instantiateRendererFactory,
        deps: [_angular_platformBrowser.ɵDomRendererFactory2, _angular_animations_browser.ɵAnimationEngine, _angular_core.NgZone]
    }
];
/**
 * Separate providers from the actual module so that we can do a local modification in Google3 to
 * include them in the BrowserModule.
 */
var BROWSER_ANIMATIONS_PROVIDERS = [
    { provide: _angular_animations_browser.AnimationDriver, useFactory: instantiateSupportedAnimationDriver }
].concat(SHARED_ANIMATION_PROVIDERS);
/**
 * Separate providers from the actual module so that we can do a local modification in Google3 to
 * include them in the BrowserTestingModule.
 */
var BROWSER_NOOP_ANIMATIONS_PROVIDERS = [{ provide: _angular_animations_browser.AnimationDriver, useClass: _angular_animations_browser.ɵNoopAnimationDriver }].concat(SHARED_ANIMATION_PROVIDERS);

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * \@experimental Animation support is experimental.
 */
var BrowserAnimationsModule = (function () {
    function BrowserAnimationsModule() {
    }
    BrowserAnimationsModule.decorators = [
        { type: _angular_core.NgModule, args: [{
                    exports: [_angular_platformBrowser.BrowserModule],
                    providers: BROWSER_ANIMATIONS_PROVIDERS,
                },] },
    ];
    /** @nocollapse */
    BrowserAnimationsModule.ctorParameters = function () { return []; };
    return BrowserAnimationsModule;
}());
/**
 * \@experimental Animation support is experimental.
 */
var NoopAnimationsModule = (function () {
    function NoopAnimationsModule() {
    }
    NoopAnimationsModule.decorators = [
        { type: _angular_core.NgModule, args: [{
                    exports: [_angular_platformBrowser.BrowserModule],
                    providers: BROWSER_NOOP_ANIMATIONS_PROVIDERS,
                },] },
    ];
    /** @nocollapse */
    NoopAnimationsModule.ctorParameters = function () { return []; };
    return NoopAnimationsModule;
}());

exports.BrowserAnimationsModule = BrowserAnimationsModule;
exports.NoopAnimationsModule = NoopAnimationsModule;
exports.ɵBrowserAnimationBuilder = BrowserAnimationBuilder;
exports.ɵBrowserAnimationFactory = BrowserAnimationFactory;
exports.ɵAnimationRenderer = AnimationRenderer;
exports.ɵAnimationRendererFactory = AnimationRendererFactory;
exports.ɵa = BaseAnimationRenderer;
exports.ɵf = BROWSER_ANIMATIONS_PROVIDERS;
exports.ɵg = BROWSER_NOOP_ANIMATIONS_PROVIDERS;
exports.ɵb = InjectableAnimationEngine;
exports.ɵd = instantiateDefaultStyleNormalizer;
exports.ɵe = instantiateRendererFactory;
exports.ɵc = instantiateSupportedAnimationDriver;

Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=platform-browser-animations.umd.js.map


/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(2))(4);

/***/ }),
/* 40 */
/***/ (function(module, exports) {

module.exports = require("url");

/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Event = __webpack_require__(8);
var MouseEvent = __webpack_require__(42);
var utils = __webpack_require__(3);

module.exports = EventTarget;

function EventTarget() {}

EventTarget.prototype = {
  // XXX
  // See WebIDL §4.8 for details on object event handlers
  // and how they should behave.  We actually have to accept
  // any object to addEventListener... Can't type check it.
  // on registration.

  // XXX:
  // Capturing event listeners are sort of rare.  I think I can optimize
  // them so that dispatchEvent can skip the capturing phase (or much of
  // it).  Each time a capturing listener is added, increment a flag on
  // the target node and each of its ancestors.  Decrement when removed.
  // And update the counter when nodes are added and removed from the
  // tree as well.  Then, in dispatch event, the capturing phase can
  // abort if it sees any node with a zero count.
  addEventListener: function addEventListener(type, listener, capture) {
    if (!listener) return;
    if (capture === undefined) capture = false;
    if (!this._listeners) this._listeners = Object.create(null);
    if (!this._listeners[type]) this._listeners[type] = [];
    var list = this._listeners[type];

    // If this listener has already been registered, just return
    for(var i = 0, n = list.length; i < n; i++) {
      var l = list[i];
      if (l.listener === listener && l.capture === capture)
        return;
    }

    // Add an object to the list of listeners
    var obj = { listener: listener, capture: capture };
    if (typeof listener === 'function') obj.f = listener;
    list.push(obj);
  },

  removeEventListener: function removeEventListener(type,
                            listener,
                            capture) {
    if (capture === undefined) capture = false;
    if (this._listeners) {
      var list = this._listeners[type];
      if (list) {
        // Find the listener in the list and remove it
        for(var i = 0, n = list.length; i < n; i++) {
          var l = list[i];
          if (l.listener === listener && l.capture === capture) {
            if (list.length === 1) {
              this._listeners[type] = undefined;
            }
            else {
              list.splice(i, 1);
            }
            return;
          }
        }
      }
    }
  },

  // This is the public API for dispatching untrusted public events.
  // See _dispatchEvent for the implementation
  dispatchEvent: function dispatchEvent(event) {
    // Dispatch an untrusted event
    return this._dispatchEvent(event, false);
  },

  //
  // See DOMCore §4.4
  // XXX: I'll probably need another version of this method for
  // internal use, one that does not set isTrusted to false.
  // XXX: see Document._dispatchEvent: perhaps that and this could
  // call a common internal function with different settings of
  // a trusted boolean argument
  //
  // XXX:
  // The spec has changed in how to deal with handlers registered
  // on idl or content attributes rather than with addEventListener.
  // Used to say that they always ran first.  That's how webkit does it
  // Spec now says that they run in a position determined by
  // when they were first set.  FF does it that way.  See:
  // http://www.whatwg.org/specs/web-apps/current-work/multipage/webappapis.html#event-handlers
  //
  _dispatchEvent: function _dispatchEvent(event, trusted) {
    if (typeof trusted !== 'boolean') trusted = false;
    function invoke(target, event) {
      var type = event.type, phase = event.eventPhase;
      event.currentTarget = target;

      // If there was an individual handler defined, invoke it first
      // XXX: see comment above: this shouldn't always be first.
      if (phase !== Event.CAPTURING_PHASE &&
        target._handlers && target._handlers[type])
      {
        var handler = target._handlers[type];
        var rv;
        if (typeof handler === 'function') {
          rv=handler.call(event.currentTarget, event);
        }
        else {
          var f = handler.handleEvent;
          if (typeof f !== 'function')
            throw new TypeError('handleEvent property of ' +
                                'event handler object is' +
                                'not a function.');
          rv=f.call(handler, event);
        }

        switch(event.type) {
        case 'mouseover':
          if (rv === true)  // Historical baggage
            event.preventDefault();
          break;
        case 'beforeunload':
          // XXX: eventually we need a special case here
          /* falls through */
        default:
          if (rv === false)
            event.preventDefault();
          break;
        }
      }

      // Now invoke list list of listeners for this target and type
      var list = target._listeners && target._listeners[type];
      if (!list) return;
      list = list.slice();
      for(var i = 0, n = list.length; i < n; i++) {
        if (event._immediatePropagationStopped) return;
        var l = list[i];
        if ((phase === Event.CAPTURING_PHASE && !l.capture) ||
          (phase === Event.BUBBLING_PHASE && l.capture))
          continue;
        if (l.f) {
          l.f.call(event.currentTarget, event);
        }
        else {
          var fn = l.listener.handleEvent;
          if (typeof fn !== 'function')
            throw new TypeError('handleEvent property of event listener object is not a function.');
          fn.call(l.listener, event);
        }
      }
    }

    if (!event._initialized || event._dispatching) utils.InvalidStateError();
    event.isTrusted = trusted;

    // Begin dispatching the event now
    event._dispatching = true;
    event.target = this;

    // Build the list of targets for the capturing and bubbling phases
    // XXX: we'll eventually have to add Window to this list.
    var ancestors = [];
    for(var n = this.parentNode; n; n = n.parentNode)
      ancestors.push(n);

    // Capturing phase
    event.eventPhase = Event.CAPTURING_PHASE;
    for(var i = ancestors.length-1; i >= 0; i--) {
      invoke(ancestors[i], event);
      if (event._propagationStopped) break;
    }

    // At target phase
    if (!event._propagationStopped) {
      event.eventPhase = Event.AT_TARGET;
      invoke(this, event);
    }

    // Bubbling phase
    if (event.bubbles && !event._propagationStopped) {
      event.eventPhase = Event.BUBBLING_PHASE;
      for(var ii = 0, nn = ancestors.length; ii < nn; ii++) {
        invoke(ancestors[ii], event);
        if (event._propagationStopped) break;
      }
    }

    event._dispatching = false;
    event.eventPhase = Event.AT_TARGET;
    event.currentTarget = null;

    // Deal with mouse events and figure out when
    // a click has happened
    if (trusted && !event.defaultPrevented && event instanceof MouseEvent) {
      switch(event.type) {
      case 'mousedown':
        this._armed = {
          x: event.clientX,
          y: event.clientY,
          t: event.timeStamp
        };
        break;
      case 'mouseout':
      case 'mouseover':
        this._armed = null;
        break;
      case 'mouseup':
        if (this._isClick(event)) this._doClick(event);
        this._armed = null;
        break;
      }
    }



    return !event.defaultPrevented;
  },

  // Determine whether a click occurred
  // XXX We don't support double clicks for now
  _isClick: function(event) {
    return (this._armed !== null &&
        event.type === 'mouseup' &&
        event.isTrusted &&
        event.button === 0 &&
        event.timeStamp - this._armed.t < 1000 &&
        Math.abs(event.clientX - this._armed.x) < 10 &&
        Math.abs(event.clientY - this._armed.Y) < 10);
  },

  // Clicks are handled like this:
  // http://www.whatwg.org/specs/web-apps/current-work/multipage/elements.html#interactive-content-0
  //
  // Note that this method is similar to the HTMLElement.click() method
  // The event argument must be the trusted mouseup event
  _doClick: function(event) {
    if (this._click_in_progress) return;
    this._click_in_progress = true;

    // Find the nearest enclosing element that is activatable
    // An element is activatable if it has a
    // _post_click_activation_steps hook
    var activated = this;
    while(activated && !activated._post_click_activation_steps)
      activated = activated.parentNode;

    if (activated && activated._pre_click_activation_steps) {
      activated._pre_click_activation_steps();
    }

    var click = this.ownerDocument.createEvent('MouseEvent');
    click.initMouseEvent('click', true, true,
      this.ownerDocument.defaultView, 1,
      event.screenX, event.screenY,
      event.clientX, event.clientY,
      event.ctrlKey, event.altKey,
      event.shiftKey, event.metaKey,
      event.button, null);

    var result = this._dispatchEvent(click, true);

    if (activated) {
      if (result) {
        // This is where hyperlinks get followed, for example.
        if (activated._post_click_activation_steps)
          activated._post_click_activation_steps(click);
      }
      else {
        if (activated._cancelled_activation_steps)
          activated._cancelled_activation_steps();
      }
    }
  },

  //
  // An event handler is like an event listener, but it registered
  // by setting an IDL or content attribute like onload or onclick.
  // There can only be one of these at a time for any event type.
  // This is an internal method for the attribute accessors and
  // content attribute handlers that need to register events handlers.
  // The type argument is the same as in addEventListener().
  // The handler argument is the same as listeners in addEventListener:
  // it can be a function or an object. Pass null to remove any existing
  // handler.  Handlers are always invoked before any listeners of
  // the same type.  They are not invoked during the capturing phase
  // of event dispatch.
  //
  _setEventHandler: function _setEventHandler(type, handler) {
    if (!this._handlers) this._handlers = Object.create(null);
    this._handlers[type] = handler;
  },

  _getEventHandler: function _getEventHandler(type) {
    return (this._handlers && this._handlers[type]) || null;
  }

};


/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var UIEvent = __webpack_require__(43);

module.exports = MouseEvent;

function MouseEvent() {
  // Just use the superclass constructor to initialize
  UIEvent.call(this);

  this.screenX = this.screenY = this.clientX = this.clientY = 0;
  this.ctrlKey = this.altKey = this.shiftKey = this.metaKey = false;
  this.button = 0;
  this.buttons = 1;
  this.relatedTarget = null;
}
MouseEvent.prototype = Object.create(UIEvent.prototype, {
  constructor: { value: MouseEvent },
  initMouseEvent: { value: function(type, bubbles, cancelable,
    view, detail,
    screenX, screenY, clientX, clientY,
    ctrlKey, altKey, shiftKey, metaKey,
    button, relatedTarget) {

    this.initEvent(type, bubbles, cancelable, view, detail);
    this.screenX = screenX;
    this.screenY = screenY;
    this.clientX = clientX;
    this.clientY = clientY;
    this.ctrlKey = ctrlKey;
    this.altKey = altKey;
    this.shiftKey = shiftKey;
    this.metaKey = metaKey;
    this.button = button;
    switch(button) {
    case 0: this.buttons = 1; break;
    case 1: this.buttons = 4; break;
    case 2: this.buttons = 2; break;
    default: this.buttons = 0; break;
    }
    this.relatedTarget = relatedTarget;
  }},

  getModifierState: { value: function(key) {
    switch(key) {
    case "Alt": return this.altKey;
    case "Control": return this.ctrlKey;
    case "Shift": return this.shiftKey;
    case "Meta": return this.metaKey;
    default: return false;
    }
  }}
});


/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Event = __webpack_require__(8);

module.exports = UIEvent;

function UIEvent() {
  // Just use the superclass constructor to initialize
  Event.call(this);
  this.view = null; // FF uses the current window
  this.detail = 0;
}
UIEvent.prototype = Object.create(Event.prototype, {
  constructor: { value: UIEvent },
  initUIEvent: { value: function(type, bubbles, cancelable, view, detail) {
    this.initEvent(type, bubbles, cancelable);
    this.view = view;
    this.detail = detail;
  }}
});


/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = DOMException;

var INDEX_SIZE_ERR = 1;
var HIERARCHY_REQUEST_ERR = 3;
var WRONG_DOCUMENT_ERR = 4;
var INVALID_CHARACTER_ERR = 5;
var NO_MODIFICATION_ALLOWED_ERR = 7;
var NOT_FOUND_ERR = 8;
var NOT_SUPPORTED_ERR = 9;
var INVALID_STATE_ERR = 11;
var SYNTAX_ERR = 12;
var INVALID_MODIFICATION_ERR = 13;
var NAMESPACE_ERR = 14;
var INVALID_ACCESS_ERR = 15;
var TYPE_MISMATCH_ERR = 17;
var SECURITY_ERR = 18;
var NETWORK_ERR = 19;
var ABORT_ERR = 20;
var URL_MISMATCH_ERR = 21;
var QUOTA_EXCEEDED_ERR = 22;
var TIMEOUT_ERR = 23;
var INVALID_NODE_TYPE_ERR = 24;
var DATA_CLONE_ERR = 25;

// Code to name
var names = [
  null,  // No error with code 0
  'INDEX_SIZE_ERR',
  null, // historical
  'HIERARCHY_REQUEST_ERR',
  'WRONG_DOCUMENT_ERR',
  'INVALID_CHARACTER_ERR',
  null, // historical
  'NO_MODIFICATION_ALLOWED_ERR',
  'NOT_FOUND_ERR',
  'NOT_SUPPORTED_ERR',
  null, // historical
  'INVALID_STATE_ERR',
  'SYNTAX_ERR',
  'INVALID_MODIFICATION_ERR',
  'NAMESPACE_ERR',
  'INVALID_ACCESS_ERR',
  null, // historical
  'TYPE_MISMATCH_ERR',
  'SECURITY_ERR',
  'NETWORK_ERR',
  'ABORT_ERR',
  'URL_MISMATCH_ERR',
  'QUOTA_EXCEEDED_ERR',
  'TIMEOUT_ERR',
  'INVALID_NODE_TYPE_ERR',
  'DATA_CLONE_ERR',
];

// Code to message
// These strings are from the 13 May 2011 Editor's Draft of DOM Core.
// http://dvcs.w3.org/hg/domcore/raw-file/tip/Overview.html
// Copyright © 2011 W3C® (MIT, ERCIM, Keio), All Rights Reserved.
// Used under the terms of the W3C Document License:
// http://www.w3.org/Consortium/Legal/2002/copyright-documents-20021231
var messages = [
  null,  // No error with code 0
  'INDEX_SIZE_ERR (1): the index is not in the allowed range',
  null,
  'HIERARCHY_REQUEST_ERR (3): the operation would yield an incorrect nodes model',
  'WRONG_DOCUMENT_ERR (4): the object is in the wrong Document, a call to importNode is required',
  'INVALID_CHARACTER_ERR (5): the string contains invalid characters',
  null,
  'NO_MODIFICATION_ALLOWED_ERR (7): the object can not be modified',
  'NOT_FOUND_ERR (8): the object can not be found here',
  'NOT_SUPPORTED_ERR (9): this operation is not supported',
  null,
  'INVALID_STATE_ERR (11): the object is in an invalid state',
  'SYNTAX_ERR (12): the string did not match the expected pattern',
  'INVALID_MODIFICATION_ERR (13): the object can not be modified in this way',
  'NAMESPACE_ERR (14): the operation is not allowed by Namespaces in XML',
  'INVALID_ACCESS_ERR (15): the object does not support the operation or argument',
  null,
  'TYPE_MISMATCH_ERR (17): the type of the object does not match the expected type',
  'SECURITY_ERR (18): the operation is insecure',
  'NETWORK_ERR (19): a network error occurred',
  'ABORT_ERR (20): the user aborted an operation',
  'URL_MISMATCH_ERR (21): the given URL does not match another URL',
  'QUOTA_EXCEEDED_ERR (22): the quota has been exceeded',
  'TIMEOUT_ERR (23): a timeout occurred',
  'INVALID_NODE_TYPE_ERR (24): the supplied node is invalid or has an invalid ancestor for this operation',
  'DATA_CLONE_ERR (25): the object can not be cloned.'
];

// Name to code
var constants = {
  INDEX_SIZE_ERR: INDEX_SIZE_ERR,
  DOMSTRING_SIZE_ERR: 2, // historical
  HIERARCHY_REQUEST_ERR: HIERARCHY_REQUEST_ERR,
  WRONG_DOCUMENT_ERR: WRONG_DOCUMENT_ERR,
  INVALID_CHARACTER_ERR: INVALID_CHARACTER_ERR,
  NO_DATA_ALLOWED_ERR: 6, // historical
  NO_MODIFICATION_ALLOWED_ERR: NO_MODIFICATION_ALLOWED_ERR,
  NOT_FOUND_ERR: NOT_FOUND_ERR,
  NOT_SUPPORTED_ERR: NOT_SUPPORTED_ERR,
  INUSE_ATTRIBUTE_ERR: 10, // historical
  INVALID_STATE_ERR: INVALID_STATE_ERR,
  SYNTAX_ERR: SYNTAX_ERR,
  INVALID_MODIFICATION_ERR: INVALID_MODIFICATION_ERR,
  NAMESPACE_ERR: NAMESPACE_ERR,
  INVALID_ACCESS_ERR: INVALID_ACCESS_ERR,
  VALIDATION_ERR: 16, // historical
  TYPE_MISMATCH_ERR: TYPE_MISMATCH_ERR,
  SECURITY_ERR: SECURITY_ERR,
  NETWORK_ERR: NETWORK_ERR,
  ABORT_ERR: ABORT_ERR,
  URL_MISMATCH_ERR: URL_MISMATCH_ERR,
  QUOTA_EXCEEDED_ERR: QUOTA_EXCEEDED_ERR,
  TIMEOUT_ERR: TIMEOUT_ERR,
  INVALID_NODE_TYPE_ERR: INVALID_NODE_TYPE_ERR,
  DATA_CLONE_ERR: DATA_CLONE_ERR
};

function DOMException(code) {
  Error.call(this);
  Error.captureStackTrace(this, this.constructor);
  this.code = code;
  this.message = messages[code];
  this.name = names[code];
}
DOMException.prototype.__proto__ = Error.prototype;

// Initialize the constants on DOMException and DOMException.prototype
for(var c in constants) {
  var v = { value: constants[c] };
  Object.defineProperty(DOMException, c, v);
  Object.defineProperty(DOMException.prototype, c, v);
}


/***/ }),
/* 45 */
/***/ (function(module, exports) {

/*
 * This file defines Domino behaviour that can be externally configured.
 * To change these settings, set the relevant global property *before*
 * you call `require("domino")`.
 */

exports.isApiWritable = !global.__domino_frozen__;


/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var utils = __webpack_require__(3);

exports.property = function(attr) {
  if (Array.isArray(attr.type)) {
    var valid = Object.create(null);
    attr.type.forEach(function(val) {
      valid[val.value || val] = val.alias || val;
    });
    var missingValueDefault = attr.missing;
    if (missingValueDefault===undefined) { missingValueDefault = null; }
    var invalidValueDefault = attr.invalid;
    if (invalidValueDefault===undefined) { invalidValueDefault = missingValueDefault; }
    return {
      get: function() {
        var v = this._getattr(attr.name);
        if (v === null) return missingValueDefault;

        v = valid[v.toLowerCase()];
        if (v !== undefined) return v;
        if (invalidValueDefault !== null) return invalidValueDefault;
        return v;
      },
      set: function(v) {
        this._setattr(attr.name, v);
      }
    };
  }
  else if (attr.type === Boolean) {
    return {
      get: function() {
        return this.hasAttribute(attr.name);
      },
      set: function(v) {
        if (v) {
          this._setattr(attr.name, '');
        }
        else {
          this.removeAttribute(attr.name);
        }
      }
    };
  }
  else if (attr.type === Number ||
           attr.type === "long" ||
           attr.type === "unsigned long" ||
           attr.type === "limited unsigned long with fallback") {
    return numberPropDesc(attr);
  }
  else if (!attr.type || attr.type === String) {
    return {
      get: function() { return this._getattr(attr.name) || ''; },
      set: function(v) {
        if (attr.treatNullAsEmptyString && v === null) { v = ''; }
        this._setattr(attr.name, v);
      }
    };
  }
  else if (typeof attr.type === 'function') {
    return attr.type(attr.name, attr);
  }
  throw new Error('Invalid attribute definition');
};

// See http://www.whatwg.org/specs/web-apps/current-work/#reflect
//
// defval is the default value. If it is a function, then that function
// will be invoked as a method of the element to obtain the default.
// If no default is specified for a given attribute, then the default
// depends on the type of the attribute, but since this function handles
// 4 integer cases, you must specify the default value in each call
//
// min and max define a valid range for getting the attribute.
//
// setmin defines a minimum value when setting.  If the value is less
// than that, then throw INDEX_SIZE_ERR.
//
// Conveniently, JavaScript's parseInt function appears to be
// compatible with HTML's 'rules for parsing integers'
function numberPropDesc(a) {
  var def;
  if(typeof a.default === 'function') {
    def = a.default;
  }
  else if(typeof a.default === 'number') {
    def = function() { return a.default; };
  }
  else {
    def = function() { utils.assert(false, typeof a.default); };
  }
  var unsigned_long = (a.type === 'unsigned long');
  var signed_long = (a.type === 'long');
  var unsigned_fallback = (a.type === 'limited unsigned long with fallback');
  var min = a.min, max = a.max, setmin = a.setmin;
  if (min === undefined) {
    if (unsigned_long) min = 0;
    if (signed_long) min = -0x80000000;
    if (unsigned_fallback) min = 1;
  }
  if (max === undefined) {
    if (unsigned_long || signed_long || unsigned_fallback) max = 0x7FFFFFFF;
  }

  return {
    get: function() {
      var v = this._getattr(a.name);
      var n = a.float ? parseFloat(v) : parseInt(v, 10);
      if (v === null || !isFinite(n) || (min !== undefined && n < min) || (max !== undefined && n > max)) {
        return def.call(this);
      }
      if (unsigned_long || signed_long || unsigned_fallback) {
        if (!/^[ \t\n\f\r]*[-+]?[0-9]/.test(v)) { return def.call(this); }
        n = n|0; // jshint ignore:line
      }
      return n;
    },
    set: function(v) {
      if (!a.float) { v = Math.floor(v); }
      if (setmin !== undefined && v < setmin) {
        utils.IndexSizeError(a.name + ' set to ' + v);
      }
      if (unsigned_long) {
        v = (v < 0 || v > 0x7FFFFFFF) ? def.call(this) :
          (v|0);  // jshint ignore:line
      } else if (unsigned_fallback) {
        v = (v < 1 || v > 0x7FFFFFFF) ? def.call(this) :
          (v|0); // jshint ignore:line
      } else if (signed_long) {
        v = (v < -0x80000000 || v > 0x7FFFFFFF) ? def.call(this) :
          (v|0); // jshint ignore:line
      }
      this._setattr(a.name, String(v));
    }
  };
}

// This is a utility function for setting up change handler functions
// for attributes like 'id' that require special handling when they change.
exports.registerChangeHandler = function(c, name, handler) {
  var p = c.prototype;

  // If p does not already have its own _attributeChangeHandlers
  // then create one for it, inheriting from the inherited
  // _attributeChangeHandlers. At the top (for the Element class) the
  // _attributeChangeHandlers object will be created with a null prototype.
  if (!Object.prototype.hasOwnProperty.call(p, '_attributeChangeHandlers')) {
    p._attributeChangeHandlers =
      Object.create(p._attributeChangeHandlers || null);
  }

  p._attributeChangeHandlers[name] = handler;
};


/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// DOMTokenList implementation based on https://github.com/Raynos/DOM-shim
var utils = __webpack_require__(3);

module.exports = DOMTokenList;

function DOMTokenList(getter, setter) {
  this._getString = getter;
  this._setString = setter;
  fixIndex(this, getList(this));
}

DOMTokenList.prototype = {
  item: function(index) {
    if (index >= this.length) {
      return null;
    }
    return this._getString().split(" ")[index];
  },

  contains: function(token) {
    token = String(token);
    handleErrors(token);
    var list = getList(this);
    return list.indexOf(token) > -1;
  },

  add: function(token) {
    handleErrors(token);
    var list = getList(this);
    if (list.indexOf(token) > -1) {
      return;
    }
    list.push(token);
    this._setString(list.join(" ").trim());
    fixIndex(this, list);
  },

  remove: function(token) {
    handleErrors(token);
    var list = getList(this);
    var index = list.indexOf(token);
    if (index > -1) {
      list.splice(index, 1);
      this._setString(list.join(" ").trim());
    }
    fixIndex(this, list);
  },

  toggle: function toggle(token) {
    if (this.contains(token)) {
      this.remove(token);
      return false;
    }
    else {
      this.add(token);
      return true;
    }
  },

  toString: function() {
    return this._getString();
  }
};

function fixIndex(clist, list) {
  clist.length = list.length;
  for (var i = 0; i < list.length; i++) {
    clist[i] = list[i];
  }
}

function handleErrors(token) {
  if (token === "" || token === undefined) {
    utils.SyntaxError();
  }
  if (token.indexOf(" ") > -1) {
    utils.InvalidCharacterError();
  }
}

function getList(clist) {
  var str = clist._getString();
  if (str === "") {
    return [];
  }
  else {
    return str.split(" ");
  }
}


/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Node = __webpack_require__(4);

var NonDocumentTypeChildNode = {

  nextElementSibling: { get: function() {
    if (this.parentNode) {
      var sibs = this.parentNode.childNodes;
      for(var i = this.index+1, n = sibs.length; i < n; i++) {
        if (sibs[i].nodeType === Node.ELEMENT_NODE) return sibs[i];
      }
    }
    return null;
  }},

  previousElementSibling: { get: function() {
    if (this.parentNode) {
      var sibs = this.parentNode.childNodes;
      for(var i = this.index-1; i >= 0; i--) {
        if (sibs[i].nodeType === Node.ELEMENT_NODE) return sibs[i];
      }
    }
    return null;
  }}

};

module.exports = NonDocumentTypeChildNode;


/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = Text;

var utils = __webpack_require__(3);
var Node = __webpack_require__(4);
var CharacterData = __webpack_require__(14);

function Text(doc, data) {
  this.nodeType = Node.TEXT_NODE;
  this.ownerDocument = doc;
  this._data = data;
  this._index = undefined;
}

var nodeValue = {
  get: function() { return this._data; },
  set: function(v) {
    if (v === this._data) return;
    this._data = v;
    if (this.rooted)
      this.ownerDocument.mutateValue(this);
    if (this.parentNode &&
      this.parentNode._textchangehook)
      this.parentNode._textchangehook(this);
  }
};

Text.prototype = Object.create(CharacterData.prototype, {
  nodeName: { value: "#text" },
  // These three attributes are all the same.
  // The data attribute has a [TreatNullAs=EmptyString] but we'll
  // implement that at the interface level
  nodeValue: nodeValue,
  textContent: nodeValue,
  data: nodeValue,

  splitText: { value: function splitText(offset) {
    if (offset > this._data.length || offset < 0) utils.IndexSizeError();

    var newdata = this._data.substring(offset),
      newnode = this.ownerDocument.createTextNode(newdata);
    this.data = this.data.substring(0, offset);

    var parent = this.parentNode;
    if (parent !== null)
      parent.insertBefore(newnode, this.nextSibling);

    return newnode;
  }},

  // XXX
  // wholeText and replaceWholeText() are not implemented yet because
  // the DOMCore specification is considering removing or altering them.
  wholeText: {get: utils.nyi },
  replaceWholeText: { value: utils.nyi },

  // Utility methods
  clone: { value: function clone() {
    return new Text(this.ownerDocument, this._data);
  }},

});


/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = Leaf;

var Node = __webpack_require__(4);
var utils = __webpack_require__(3);
var HierarchyRequestError = utils.HierarchyRequestError;
var NotFoundError = utils.NotFoundError;

// This class defines common functionality for node subtypes that
// can never have children
function Leaf() {
}

Leaf.prototype = Object.create(Node.prototype, {
  hasChildNodes: { value: function() { return false; }},
  firstChild: { value: null },
  lastChild: { value: null },
  insertBefore: { value: function(node, child) {
    if (!node.nodeType) throw new TypeError('not a node');
    HierarchyRequestError();
  }},
  replaceChild: { value: function(node, child) {
    if (!node.nodeType) throw new TypeError('not a node');
    HierarchyRequestError();
  }},
  removeChild: { value: function(node) {
    if (!node.nodeType) throw new TypeError('not a node');
    NotFoundError();
  }},
  childNodes: { get: function() {
    if (!this._childNodes) this._childNodes = [];
    return this._childNodes;
  }}
});


/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = Comment;

var Node = __webpack_require__(4);
var CharacterData = __webpack_require__(14);

function Comment(doc, data) {
  this.nodeType = Node.COMMENT_NODE;
  this.ownerDocument = doc;
  this._data = data;
  this._index = undefined;
}

var nodeValue = {
  get: function() { return this._data; },
  set: function(v) {
    this._data = v;
    if (this.rooted)
      this.ownerDocument.mutateValue(this);
  }
};

Comment.prototype = Object.create(CharacterData.prototype, {
  nodeName: { value: '#comment' },
  nodeValue: nodeValue,
  textContent: nodeValue,
  data: nodeValue,

  // Utility methods
  clone: { value: function clone() {
    return new Comment(this.ownerDocument, this._data);
  }},
});


/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports =  DocumentFragment;

var Node = __webpack_require__(4);
var NodeList = __webpack_require__(13);
var Element = __webpack_require__(9);
var select = __webpack_require__(22);
var utils = __webpack_require__(3);

function DocumentFragment(doc) {
  this.nodeType = Node.DOCUMENT_FRAGMENT_NODE;
  this.ownerDocument = doc;
  this.childNodes = [];
}

DocumentFragment.prototype = Object.create(Node.prototype, {
  nodeName: { value: '#document-fragment' },
  nodeValue: { 
    get: function() { 
      return null;
    },
    set: function() {}
  },
  // Copy the text content getter/setter from Element
  textContent: Object.getOwnPropertyDescriptor(Element.prototype, 'textContent'),

  querySelector: { value: function(selector) {
    // implement in terms of querySelectorAll
    var nodes = this.querySelectorAll(selector);
    return nodes.length ? nodes[0] : null;
  }},
  querySelectorAll: { value: function(selector) {
    // create a context
    var context = Object.create(this);
    // add some methods to the context for zest implementation, without
    // adding them to the public DocumentFragment API
    context.isHTML = true; // in HTML namespace (case-insensitive match)
    context.getElementsByTagName = Element.prototype.getElementsByTagName;
    context.nextElement =
      Object.getOwnPropertyDescriptor(Element.prototype, 'firstElementChild').
      get;
    // invoke zest
    var nodes = select(selector, context);
    return nodes.item ? nodes : new NodeList(nodes);
  }},

  // Utility methods
  clone: { value: function clone() {
      return new DocumentFragment(this.ownerDocument);
  }},
  isEqual: { value: function isEqual(n) {
      // Any two document fragments are shallowly equal.
      // Node.isEqualNode() will test their children for equality
      return true;
  }},

  // Non-standard, but useful (github issue #73)
  innerHTML: {
    get: function() { return this.serialize(); },
    set: utils.nyi
  },
  outerHTML: {
    get: function() { return this.serialize(); },
    set: utils.nyi
  },

});


/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = ProcessingInstruction;

var Node = __webpack_require__(4);
var CharacterData = __webpack_require__(14);

function ProcessingInstruction(doc, target, data) {
  this.nodeType = Node.PROCESSING_INSTRUCTION_NODE;
  this.ownerDocument = doc;
  this.target = target;
  this._data = data;
}

var nodeValue = {
  get: function() { return this._data; },
  set: function(v) {
    this._data = v;
    if (this.rooted) this.ownerDocument.mutateValue(this);
  }
};

ProcessingInstruction.prototype = Object.create(CharacterData.prototype, {
  nodeName: { get: function() { return this.target; }},
  nodeValue: nodeValue,
  textContent: nodeValue,
  data: nodeValue,

  // Utility methods
  clone: { value: function clone() {
      return new ProcessingInstruction(this.ownerDocument, this.target, this._data);
  }},
  isEqual: { value: function isEqual(n) {
      return this.target === n.target && this._data === n._data;
  }}

});


/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/* exported NodeTraversal */
var NodeTraversal = module.exports = {
  nextSkippingChildren: nextSkippingChildren,
  nextAncestorSibling: nextAncestorSibling,
  next: next,
  previous: previous,
  deepLastChild: deepLastChild
};

/**
 * @based on WebKit's NodeTraversal::nextSkippingChildren
 * https://trac.webkit.org/browser/trunk/Source/WebCore/dom/NodeTraversal.h?rev=179143#L109
 */
function nextSkippingChildren(node, stayWithin) {
  if (node === stayWithin) {
    return null;
  }
  if (node.nextSibling !== null) {
    return node.nextSibling;
  }
  return nextAncestorSibling(node, stayWithin);
}

/**
 * @based on WebKit's NodeTraversal::nextAncestorSibling
 * https://trac.webkit.org/browser/trunk/Source/WebCore/dom/NodeTraversal.cpp?rev=179143#L93
 */
function nextAncestorSibling(node, stayWithin) {
  for (node = node.parentNode; node !== null; node = node.parentNode) {
    if (node === stayWithin) {
      return null;
    }
    if (node.nextSibling !== null) {
      return node.nextSibling;
    }
  }
  return null;
}

/**
 * @based on WebKit's NodeTraversal::next
 * https://trac.webkit.org/browser/trunk/Source/WebCore/dom/NodeTraversal.h?rev=179143#L99
 */
function next(node, stayWithin) {
  var n;
  n = node.firstChild;
  if (n !== null) {
    return n;
  }
  if (node === stayWithin) {
    return null;
  }
  n = node.nextSibling;
  if (n !== null) {
    return n;
  }
  return nextAncestorSibling(node, stayWithin);
}

/**
 * @based on WebKit's NodeTraversal::deepLastChild
 * https://trac.webkit.org/browser/trunk/Source/WebCore/dom/NodeTraversal.cpp?rev=179143#L116
 */
function deepLastChild(node) {
  while (node.lastChild) {
    node = node.lastChild;
  }
  return node;
}

/**
 * @based on WebKit's NodeTraversal::previous
 * https://trac.webkit.org/browser/trunk/Source/WebCore/dom/NodeTraversal.h?rev=179143#L121
 */
function previous(node, stayWithin) {
  var p;
  p = node.previousSibling;
  if (p !== null) {
    return deepLastChild(p);
  }
  p = node.parentNode;
  if (p === stayWithin) {
    return null;
  }
  return p;
}


/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = {
  Event: __webpack_require__(8),
  UIEvent: __webpack_require__(43),
  MouseEvent: __webpack_require__(42),
  CustomEvent: __webpack_require__(81)
};


/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var URL = __webpack_require__(24);

module.exports = URLUtils;

// This is an abstract superclass for Location, HTMLAnchorElement and
// other types that have the standard complement of "URL decomposition
// IDL attributes".  This is now standardized as URLUtils, see:
// https://url.spec.whatwg.org/#urlutils
// Subclasses must define a getter/setter on href.
// The getter and setter methods parse and rebuild the URL on each
// invocation; there is no attempt to cache the value and be more efficient
function URLUtils() {}
URLUtils.prototype = {
  constructor: URLUtils,

  get protocol() {
    var url = new URL(this.href);
    if (url.isAbsolute()) return url.scheme + ":";
    else return "";
  },

  get host() {
    var url = new URL(this.href);
    if (url.isAbsolute() && url.isAuthorityBased())
      return url.host + (url.port ? (":" + url.port) : "");
    else
      return "";
  },

  get hostname() {
    var url = new URL(this.href);
    if (url.isAbsolute() && url.isAuthorityBased())
      return url.host;
    else
      return "";
  },

  get port() {
    var url = new URL(this.href);
    if (url.isAbsolute() && url.isAuthorityBased() && url.port!==undefined)
      return url.port;
    else
      return "";
  },

  get pathname() {
    var url = new URL(this.href);
    if (url.isAbsolute() && url.isHierarchical())
      return url.path;
    else
      return "";
  },

  get search() {
    var url = new URL(this.href);
    if (url.isAbsolute() && url.isHierarchical() && url.query!==undefined)
      return "?" + url.query;
    else
      return "";
  },

  get hash() {
    var url = new URL(this.href);
    if (url.isAbsolute() && url.fragment !== undefined)
      return "#" + url.fragment;
    else
      return "";
  },

  get username() {
    var url = new URL(this.href);
    return url.username || '';
  },

  get password() {
    var url = new URL(this.href);
    return url.password || '';
  },

  get origin() {
    var url = new URL(this.href);
    var originForPort = function(defaultPort) {
      var origin = [url.scheme, url.host, +url.port || defaultPort];
      // XXX should be "unicode serialization"
      return origin[0] + '://' + origin[1] +
        (origin[2] === defaultPort ? '' : (':' + origin[2]));
    };
    switch (url.scheme) {
    case 'ftp':
      return originForPort(21);
    case 'gopher':
      return originForPort(70);
    case 'http':
    case 'ws':
      return originForPort(80);
    case 'https':
    case 'wss':
      return originForPort(443);
    default:
      // this is what chrome does
      return url.scheme + '://';
    }
  },

  /*
  get searchParams() {
    var url = new URL(this.href);
    // XXX
  },
  */

  set protocol(v) {
    var output = this.href;
    var url = new URL(output);
    if (url.isAbsolute()) {
      v = v.replace(/:+$/, "");
      v = v.replace(/[^-+\.a-zA-z0-9]/g, URL.percentEncode);
      if (v.length > 0) {
        url.scheme = v;
        output = url.toString();
      }
    }
    this.href = output;
  },

  set host(v) {
    var output = this.href;
    var url = new URL(output);
    if (url.isAbsolute() && url.isAuthorityBased()) {
      v = v.replace(/[^-+\._~!$&'()*,;:=a-zA-z0-9]/g, URL.percentEncode);
      if (v.length > 0) {
        url.host = v;
        delete url.port;
        output = url.toString();
      }
    }
    this.href = output;
  },

  set hostname(v) {
    var output = this.href;
    var url = new URL(output);
    if (url.isAbsolute() && url.isAuthorityBased()) {
      v = v.replace(/^\/+/, "");
      v = v.replace(/[^-+\._~!$&'()*,;:=a-zA-z0-9]/g, URL.percentEncode);
      if (v.length > 0) {
        url.host = v;
        output = url.toString();
      }
    }
    this.href = output;
  },

  set port(v) {
    var output = this.href;
    var url = new URL(output);
    if (url.isAbsolute() && url.isAuthorityBased()) {
      v = '' + v;
      v = v.replace(/[^0-9].*$/, "");
      v = v.replace(/^0+/, "");
      if (v.length === 0) v = "0";
      if (parseInt(v, 10) <= 65535) {
        url.port = v;
        output = url.toString();
      }
    }
    this.href = output;
  },

  set pathname(v) {
    var output = this.href;
    var url = new URL(output);
    if (url.isAbsolute() && url.isHierarchical()) {
      if (v.charAt(0) !== "/")
        v = "/" + v;
      v = v.replace(/[^-+\._~!$&'()*,;:=@\/a-zA-z0-9]/g, URL.percentEncode);
      url.path = v;
      output = url.toString();
    }
    this.href = output;
  },

  set search(v) {
    var output = this.href;
    var url = new URL(output);
    if (url.isAbsolute() && url.isHierarchical()) {
      if (v.charAt(0) === "?") v = v.substring(1);
      v = v.replace(/[^-+\._~!$&'()*,;:=@\/?a-zA-z0-9]/g, URL.percentEncode);
      url.query = v;
      output = url.toString();
    }
    this.href = output;
  },

  set hash(v) {
    var output = this.href;
    var url = new URL(output);
    if (url.isAbsolute()) {
      if (v.charAt(0) === "#") v = v.substring(1);
      v = v.replace(/[^-+\._~!$&'()*,;:=@\/?a-zA-z0-9]/g, URL.percentEncode);
      url.fragment = v;
      output = url.toString();
    }
    this.href = output;
  },

  set username(v) {
    var output = this.href;
    var url = new URL(output);
    if (url.isAbsolute()) {
      v = v.replace(/[\x00-\x1F\x7F-\uFFFF "#<>?`\/@\\:]/g, URL.percentEncode);
      url.username = v;
      output = url.toString();
    }
    this.href = output;
  },

  set password(v) {
    var output = this.href;
    var url = new URL(output);
    if (url.isAbsolute()) {
      if (v==='') {
        url.password = null;
      } else {
        v = v.replace(/[\x00-\x1F\x7F-\uFFFF "#<>?`\/@\\]/g, URL.percentEncode);
        url.password = v;
      }
      output = url.toString();
    }
    this.href = output;
  }/*,

  set searchParams(v) {
    var output = this.href;
    var url = new URL(output);
    // XXX
    this.href = output;
  }
  */
};

URLUtils._inherit = function(proto) {
  // copy getters/setters from URLUtils to o.
  Object.getOwnPropertyNames(URLUtils.prototype).forEach(function(p) {
    if (p==='constructor' || p==='href') { return; }
    var desc = Object.getOwnPropertyDescriptor(URLUtils.prototype, p);
    Object.defineProperty(proto, p, desc);
  });
};


/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var attributes = __webpack_require__(46);
var sloppy = __webpack_require__(58);

module.exports = function(spec, defaultConstructor, tagList, tagNameToImpl) {
  var c = spec.ctor;
  if (c) {
    var props = spec.props || {};

    if (spec.attributes) {
      for (var n in spec.attributes) {
        var attr = spec.attributes[n];
        if (typeof attr !== 'object' || Array.isArray(attr)) attr = {type: attr};
        if (!attr.name) attr.name = n.toLowerCase();
        props[n] = attributes.property(attr);
      }
    }

    props.constructor = { value : c };
    c.prototype = Object.create((spec.superclass || defaultConstructor).prototype, props);
    if (spec.events) {
      addEventHandlers(c, spec.events);
    }
    tagList[c.name] = c;
  }
  else {
    c = defaultConstructor;
  }

  (spec.tags || spec.tag && [spec.tag] || []).forEach(function(tag) {
    tagNameToImpl[tag] = c;
  });

  return c;
};

function EventHandlerBuilder(body, document, form, element) {
  this.body = body;
  this.document = document;
  this.form = form;
  this.element = element;
}

EventHandlerBuilder.prototype.build = sloppy.EventHandlerBuilder_build;

function EventHandlerChangeHandler(elt, name, oldval, newval) {
  var doc = elt.ownerDocument || Object.create(null);
  var form = elt.form || Object.create(null);
  elt[name] = new EventHandlerBuilder(newval, doc, form, elt).build();
}

function addEventHandlers(c, eventHandlerTypes) {
  var p = c.prototype;
  eventHandlerTypes.forEach(function(type) {
    // Define the event handler registration IDL attribute for this type
    Object.defineProperty(p, "on" + type, {
      get: function() {
        return this._getEventHandler(type);
      },
      set: function(v) {
        this._setEventHandler(type, v);
      },
    });

    // Define special behavior for the content attribute as well
    attributes.registerChangeHandler(c, "on" + type, EventHandlerChangeHandler);
  });
}


/***/ }),
/* 58 */
/***/ (function(module, exports) {

/* Domino uses sloppy-mode features (in particular, `with`) for a few
 * minor things.  This file encapsulates all the sloppiness; every
 * other module should be strict. */
/* jshint strict: false */
/* jshint evil: true */
/* jshint -W085 */
module.exports = {
  Window_run: function _run(code, file) {
    if (file) code += '\n//@ sourceURL=' + file;
    with(this) eval(code);
  },
  EventHandlerBuilder_build: function build() {
    try {
      with(this.document.defaultView || Object.create(null))
        with(this.document)
          with(this.form)
            with(this.element)
              return eval("(function(event){" + this.body + "})");
    }
    catch (err) {
      return function() { throw err; };
    }
  }
};


/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var utils = __webpack_require__(3);

exports = module.exports = {
  CSSStyleDeclaration: __webpack_require__(26),
  CharacterData: __webpack_require__(14),
  Comment: __webpack_require__(51),
  DOMException: __webpack_require__(44),
  DOMImplementation: __webpack_require__(12),
  DOMTokenList: __webpack_require__(47),
  Document: __webpack_require__(20),
  DocumentFragment: __webpack_require__(52),
  DocumentType: __webpack_require__(28),
  Element: __webpack_require__(9),
  HTMLParser: __webpack_require__(29),
  Node: __webpack_require__(4),
  NodeList: __webpack_require__(13),
  NodeFilter: __webpack_require__(15),
  ProcessingInstruction: __webpack_require__(53),
  Text: __webpack_require__(49),
  Window: __webpack_require__(27)
};

utils.merge(exports, __webpack_require__(55));
utils.merge(exports, __webpack_require__(25).elements);
utils.merge(exports, __webpack_require__(60).elements);


/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Element = __webpack_require__(9);
var defineElement = __webpack_require__(57);
var utils = __webpack_require__(3);
var CSSStyleDeclaration = __webpack_require__(26);

var svgElements = exports.elements = {};
var svgNameToImpl = Object.create(null);

exports.createElement = function(doc, localName, prefix) {
  var impl = svgNameToImpl[localName] || SVGElement;
  return new impl(doc, localName, prefix);
};

function define(spec) {
  return defineElement(spec, SVGElement, svgElements, svgNameToImpl);
}

var SVGElement = define({
  superclass: Element,
  ctor: function SVGElement(doc, localName, prefix) {
    Element.call(this, doc, localName, utils.NAMESPACE.SVG, prefix);
  },
  props: {
    style: { get: function() {
      if (!this._style)
        this._style = new CSSStyleDeclaration(this);
      return this._style;
    }}
  }
});

define({
  ctor: function SVGSVGElement(doc, localName, prefix) {
    SVGElement.call(this, doc, localName, prefix);
  },
  tag: 'svg',
  props: {
    createSVGRect: { value: function () {
      return exports.createElement(this.ownerDocument, 'rect', null);
    } }
  }
});

define({
  tags: [
    'a', 'altGlyph', 'altGlyphDef', 'altGlyphItem', 'animate', 'animateColor', 'animateMotion', 'animateTransform',
    'circle', 'clipPath', 'color-profile', 'cursor', 'defs', 'desc', 'ellipse', 'feBlend', 'feColorMatrix',
    'feComponentTransfer', 'feComposite', 'feConvolveMatrix', 'feDiffuseLighting', 'feDisplacementMap', 'feDistantLight',
    'feFlood', 'feFuncA', 'feFuncB', 'feFuncG', 'feFuncR', 'feGaussianBlur', 'feImage', 'feMerge', 'feMergeNode',
    'feMorphology', 'feOffset', 'fePointLight', 'feSpecularLighting', 'feSpotLight', 'feTile', 'feTurbulence', 'filter',
    'font', 'font-face', 'font-face-format', 'font-face-name', 'font-face-src', 'font-face-uri', 'foreignObject', 'g',
    'glyph', 'glyphRef', 'hkern', 'image', 'line', 'linearGradient', 'marker', 'mask', 'metadata', 'missing-glyph',
    'mpath', 'path', 'pattern', 'polygon', 'polyline', 'radialGradient', 'rect', 'script', 'set', 'stop',  'style',
    'switch', 'symbol', 'text', 'textPath', 'title', 'tref', 'tspan', 'use', 'view', 'vkern'
  ]
});


/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(1);
var core_1 = __webpack_require__(0);
var forms_1 = __webpack_require__(16);
var validation_service_1 = __webpack_require__(62);
var FormControlService = /** @class */ (function () {
    function FormControlService() {
    }
    FormControlService.prototype.toControlGroup = function (controls) {
        var group = {};
        controls.forEach(function (control) {
            var validators = [];
            // Required
            if (control.required) {
                validators.push(forms_1.Validators.required);
            }
            // Minlength
            if (control.minlength) {
                validators.push(forms_1.Validators.minLength(control.minlength));
            }
            // Maxlength
            if (control.maxlength) {
                validators.push(forms_1.Validators.maxLength(control.maxlength));
            }
            // Email
            if (control.type === 'email') {
                validators.push(validation_service_1.ValidationService.emailValidator);
            }
            // Password
            if (control.type === 'password') {
                validators.push(validation_service_1.ValidationService.passwordValidator);
            }
            group[control.key] = new forms_1.FormControl(control.value || '', validators);
        });
        return new forms_1.FormGroup(group);
    };
    FormControlService = tslib_1.__decorate([
        core_1.Injectable()
    ], FormControlService);
    return FormControlService;
}());
exports.FormControlService = FormControlService;


/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var ValidationService = /** @class */ (function () {
    function ValidationService() {
    }
    ValidationService.getValidatorErrorMessage = function (code, fieldLength) {
        var config = {
            required: 'This is a required field',
            minlength: 'Minimum length is ' + fieldLength,
            maxlength: 'Maximum length is ' + fieldLength,
            invalidCreditCard: 'Invalid credit card number',
            invalidEmailAddress: 'Invalid email address',
            invalidPassword: 'Password must be at least 6 characters long, and contain a number and special character.'
        };
        return config[code];
    };
    ValidationService.creditCardValidator = function (control) {
        // Visa, MasterCard, American Express, Diners Club, Discover, JCB
        if (control.value.match(/^(?:4[0-9]{12}(?:[0-9]{3})?|5[1-5][0-9]{14}|6(?:011|5[0-9][0-9])[0-9]{12}|3[47][0-9]{13}|3(?:0[0-5]|[68][0-9])[0-9]{11}|(?:2131|1800|35\d{3})\d{11})$/)) {
            return undefined;
        }
        else {
            return { invalidCreditCard: true };
        }
    };
    ValidationService.emailValidator = function (control) {
        // RFC 2822 compliant regex
        if (control.value.match(/[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?/)) {
            return undefined;
        }
        else {
            return { invalidEmailAddress: true };
        }
    };
    ValidationService.passwordValidator = function (control) {
        // {6,100}           - Assert password is between 6 and 100 characters
        // (?=.*[0-9])       - Assert a string has at least one number
        if (control.value.match(/^(?=.*[0-9])[a-zA-Z0-9!"@#$%^&*]{6,100}$/)) {
            return undefined;
        }
        else {
            return { invalidPassword: true };
        }
    };
    return ValidationService;
}());
exports.ValidationService = ValidationService;


/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(1);
var core_1 = __webpack_require__(0);
var data_service_1 = __webpack_require__(31);
var ContentService = /** @class */ (function () {
    function ContentService(dataService) {
        this.dataService = dataService;
    }
    ContentService.prototype.get = function (lang) {
        return this.dataService.get('api/content?lang=' + (lang || 'en'));
    };
    ContentService = tslib_1.__decorate([
        core_1.Injectable(),
        tslib_1.__metadata("design:paramtypes", [data_service_1.DataService])
    ], ContentService);
    return ContentService;
}());
exports.ContentService = ContentService;


/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(1);
var core_1 = __webpack_require__(0);
var HomeComponent = /** @class */ (function () {
    function HomeComponent() {
    }
    HomeComponent = tslib_1.__decorate([
        core_1.Component({
            selector: 'appc-home',
            styles: [__webpack_require__(117)],
            template: __webpack_require__(119)
        })
    ], HomeComponent);
    return HomeComponent;
}());
exports.HomeComponent = HomeComponent;


/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(1);
var core_1 = __webpack_require__(0);
var common_1 = __webpack_require__(5);
var forms_1 = __webpack_require__(16);
var router_1 = __webpack_require__(10);
var http_1 = __webpack_require__(11);
var core_2 = __webpack_require__(30);
var page_heading_directive_1 = __webpack_require__(94);
var dynamic_form_component_1 = __webpack_require__(95);
var dynamic_form_control_component_1 = __webpack_require__(97);
var error_message_component_1 = __webpack_require__(99);
var error_summary_component_1 = __webpack_require__(100);
var form_control_service_1 = __webpack_require__(61);
var header_component_1 = __webpack_require__(102);
var footer_component_1 = __webpack_require__(108);
var uppercase_pipe_1 = __webpack_require__(112);
// Services
var content_service_1 = __webpack_require__(63);
var api_translation_loader_service_1 = __webpack_require__(114);
var SharedModule = /** @class */ (function () {
    function SharedModule() {
    }
    SharedModule_1 = SharedModule;
    SharedModule.forRoot = function () {
        return {
            ngModule: SharedModule_1,
            providers: [
                form_control_service_1.FormControlService,
                content_service_1.ContentService
            ]
        };
    };
    SharedModule = SharedModule_1 = tslib_1.__decorate([
        core_1.NgModule({
            imports: [
                common_1.CommonModule,
                forms_1.FormsModule,
                forms_1.ReactiveFormsModule,
                router_1.RouterModule,
                core_2.TranslateModule,
                // NgbModule.forRoot(),
                // No need to export as these modules don't expose any components/directive etc'
                http_1.HttpClientModule,
                core_2.TranslateModule.forRoot({
                    loader: {
                        provide: core_2.TranslateLoader,
                        useClass: api_translation_loader_service_1.ApiTranslationLoader
                    }
                })
            ],
            declarations: [
                dynamic_form_component_1.DynamicFormComponent,
                dynamic_form_control_component_1.DynamicFormControlComponent,
                error_message_component_1.ErrorMessageComponent,
                error_summary_component_1.ErrorSummaryComponent,
                footer_component_1.FooterComponent,
                header_component_1.HeaderComponent,
                page_heading_directive_1.PageHeadingComponent,
                uppercase_pipe_1.UppercasePipe
            ],
            exports: [
                // Modules
                common_1.CommonModule,
                forms_1.FormsModule,
                forms_1.ReactiveFormsModule,
                router_1.RouterModule,
                // NgbModule,
                core_2.TranslateModule,
                // Providers, Components, directive, pipes
                dynamic_form_component_1.DynamicFormComponent,
                dynamic_form_control_component_1.DynamicFormControlComponent,
                error_summary_component_1.ErrorSummaryComponent,
                error_message_component_1.ErrorMessageComponent,
                footer_component_1.FooterComponent,
                header_component_1.HeaderComponent,
                page_heading_directive_1.PageHeadingComponent,
                uppercase_pipe_1.UppercasePipe
            ]
        })
    ], SharedModule);
    return SharedModule;
    var SharedModule_1;
}());
exports.SharedModule = SharedModule;


/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
__webpack_require__(67);
__webpack_require__(68);
__webpack_require__(69);
var common_1 = __webpack_require__(5);
var core_1 = __webpack_require__(0);
var platform_server_1 = __webpack_require__(34);
var aspnet_prerendering_1 = __webpack_require__(91);
var app_module_server_1 = __webpack_require__(92);
core_1.enableProdMode();
exports.default = aspnet_prerendering_1.createServerRenderer(function (params) {
    var providers = [
        { provide: platform_server_1.INITIAL_CONFIG, useValue: { document: '<appc-root></appc-root>', url: params.url } },
        { provide: common_1.APP_BASE_HREF, useValue: params.baseUrl },
        { provide: 'BASE_URL', useValue: params.origin + params.baseUrl },
    ];
    return platform_server_1.platformDynamicServer(providers).bootstrapModule(app_module_server_1.AppModule).then(function (moduleRef) {
        var appRef = moduleRef.injector.get(core_1.ApplicationRef);
        var state = moduleRef.injector.get(platform_server_1.PlatformState);
        var zone = moduleRef.injector.get(core_1.NgZone);
        return new Promise(function (resolve, reject) {
            zone.onError.subscribe(function (errorInfo) { return reject(errorInfo); });
            appRef.isStable.first(function (isStable) { return isStable; }).subscribe(function () {
                // Because 'onStable' fires before 'onError', we have to delay slightly before
                // completing the request in case there's an error to report
                setImmediate(function () {
                    resolve({
                        html: state.renderToString()
                    });
                    moduleRef.destroy();
                });
            });
        });
    });
});


/***/ }),
/* 67 */
/***/ (function(module, exports) {

/*! *****************************************************************************
Copyright (C) Microsoft. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
var Reflect;
(function (Reflect) {
    "use strict";
    var hasOwn = Object.prototype.hasOwnProperty;
    // feature test for Symbol support
    var supportsSymbol = typeof Symbol === "function";
    var toPrimitiveSymbol = supportsSymbol && typeof Symbol.toPrimitive !== "undefined" ? Symbol.toPrimitive : "@@toPrimitive";
    var iteratorSymbol = supportsSymbol && typeof Symbol.iterator !== "undefined" ? Symbol.iterator : "@@iterator";
    var HashMap;
    (function (HashMap) {
        var supportsCreate = typeof Object.create === "function"; // feature test for Object.create support
        var supportsProto = { __proto__: [] } instanceof Array; // feature test for __proto__ support
        var downLevel = !supportsCreate && !supportsProto;
        // create an object in dictionary mode (a.k.a. "slow" mode in v8)
        HashMap.create = supportsCreate
            ? function () { return MakeDictionary(Object.create(null)); }
            : supportsProto
                ? function () { return MakeDictionary({ __proto__: null }); }
                : function () { return MakeDictionary({}); };
        HashMap.has = downLevel
            ? function (map, key) { return hasOwn.call(map, key); }
            : function (map, key) { return key in map; };
        HashMap.get = downLevel
            ? function (map, key) { return hasOwn.call(map, key) ? map[key] : undefined; }
            : function (map, key) { return map[key]; };
    })(HashMap || (HashMap = {}));
    // Load global or shim versions of Map, Set, and WeakMap
    var functionPrototype = Object.getPrototypeOf(Function);
    var usePolyfill = typeof process === "object" && process.env && process.env["REFLECT_METADATA_USE_MAP_POLYFILL"] === "true";
    var _Map = !usePolyfill && typeof Map === "function" && typeof Map.prototype.entries === "function" ? Map : CreateMapPolyfill();
    var _Set = !usePolyfill && typeof Set === "function" && typeof Set.prototype.entries === "function" ? Set : CreateSetPolyfill();
    var _WeakMap = !usePolyfill && typeof WeakMap === "function" ? WeakMap : CreateWeakMapPolyfill();
    // [[Metadata]] internal slot
    // https://rbuckton.github.io/reflect-metadata/#ordinary-object-internal-methods-and-internal-slots
    var Metadata = new _WeakMap();
    /**
      * Applies a set of decorators to a property of a target object.
      * @param decorators An array of decorators.
      * @param target The target object.
      * @param propertyKey (Optional) The property key to decorate.
      * @param attributes (Optional) The property descriptor for the target key.
      * @remarks Decorators are applied in reverse order.
      * @example
      *
      *     class Example {
      *         // property declarations are not part of ES6, though they are valid in TypeScript:
      *         // static staticProperty;
      *         // property;
      *
      *         constructor(p) { }
      *         static staticMethod(p) { }
      *         method(p) { }
      *     }
      *
      *     // constructor
      *     Example = Reflect.decorate(decoratorsArray, Example);
      *
      *     // property (on constructor)
      *     Reflect.decorate(decoratorsArray, Example, "staticProperty");
      *
      *     // property (on prototype)
      *     Reflect.decorate(decoratorsArray, Example.prototype, "property");
      *
      *     // method (on constructor)
      *     Object.defineProperty(Example, "staticMethod",
      *         Reflect.decorate(decoratorsArray, Example, "staticMethod",
      *             Object.getOwnPropertyDescriptor(Example, "staticMethod")));
      *
      *     // method (on prototype)
      *     Object.defineProperty(Example.prototype, "method",
      *         Reflect.decorate(decoratorsArray, Example.prototype, "method",
      *             Object.getOwnPropertyDescriptor(Example.prototype, "method")));
      *
      */
    function decorate(decorators, target, propertyKey, attributes) {
        if (!IsUndefined(propertyKey)) {
            if (!IsArray(decorators))
                throw new TypeError();
            if (!IsObject(target))
                throw new TypeError();
            if (!IsObject(attributes) && !IsUndefined(attributes) && !IsNull(attributes))
                throw new TypeError();
            if (IsNull(attributes))
                attributes = undefined;
            propertyKey = ToPropertyKey(propertyKey);
            return DecorateProperty(decorators, target, propertyKey, attributes);
        }
        else {
            if (!IsArray(decorators))
                throw new TypeError();
            if (!IsConstructor(target))
                throw new TypeError();
            return DecorateConstructor(decorators, target);
        }
    }
    Reflect.decorate = decorate;
    // 4.1.2 Reflect.metadata(metadataKey, metadataValue)
    // https://rbuckton.github.io/reflect-metadata/#reflect.metadata
    /**
      * A default metadata decorator factory that can be used on a class, class member, or parameter.
      * @param metadataKey The key for the metadata entry.
      * @param metadataValue The value for the metadata entry.
      * @returns A decorator function.
      * @remarks
      * If `metadataKey` is already defined for the target and target key, the
      * metadataValue for that key will be overwritten.
      * @example
      *
      *     // constructor
      *     @Reflect.metadata(key, value)
      *     class Example {
      *     }
      *
      *     // property (on constructor, TypeScript only)
      *     class Example {
      *         @Reflect.metadata(key, value)
      *         static staticProperty;
      *     }
      *
      *     // property (on prototype, TypeScript only)
      *     class Example {
      *         @Reflect.metadata(key, value)
      *         property;
      *     }
      *
      *     // method (on constructor)
      *     class Example {
      *         @Reflect.metadata(key, value)
      *         static staticMethod() { }
      *     }
      *
      *     // method (on prototype)
      *     class Example {
      *         @Reflect.metadata(key, value)
      *         method() { }
      *     }
      *
      */
    function metadata(metadataKey, metadataValue) {
        function decorator(target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey) && !IsPropertyKey(propertyKey))
                throw new TypeError();
            OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
        }
        return decorator;
    }
    Reflect.metadata = metadata;
    /**
      * Define a unique metadata entry on the target.
      * @param metadataKey A key used to store and retrieve metadata.
      * @param metadataValue A value that contains attached metadata.
      * @param target The target object on which to define metadata.
      * @param propertyKey (Optional) The property key for the target.
      * @example
      *
      *     class Example {
      *         // property declarations are not part of ES6, though they are valid in TypeScript:
      *         // static staticProperty;
      *         // property;
      *
      *         constructor(p) { }
      *         static staticMethod(p) { }
      *         method(p) { }
      *     }
      *
      *     // constructor
      *     Reflect.defineMetadata("custom:annotation", options, Example);
      *
      *     // property (on constructor)
      *     Reflect.defineMetadata("custom:annotation", options, Example, "staticProperty");
      *
      *     // property (on prototype)
      *     Reflect.defineMetadata("custom:annotation", options, Example.prototype, "property");
      *
      *     // method (on constructor)
      *     Reflect.defineMetadata("custom:annotation", options, Example, "staticMethod");
      *
      *     // method (on prototype)
      *     Reflect.defineMetadata("custom:annotation", options, Example.prototype, "method");
      *
      *     // decorator factory as metadata-producing annotation.
      *     function MyAnnotation(options): Decorator {
      *         return (target, key?) => Reflect.defineMetadata("custom:annotation", options, target, key);
      *     }
      *
      */
    function defineMetadata(metadataKey, metadataValue, target, propertyKey) {
        if (!IsObject(target))
            throw new TypeError();
        if (!IsUndefined(propertyKey))
            propertyKey = ToPropertyKey(propertyKey);
        return OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
    }
    Reflect.defineMetadata = defineMetadata;
    /**
      * Gets a value indicating whether the target object or its prototype chain has the provided metadata key defined.
      * @param metadataKey A key used to store and retrieve metadata.
      * @param target The target object on which the metadata is defined.
      * @param propertyKey (Optional) The property key for the target.
      * @returns `true` if the metadata key was defined on the target object or its prototype chain; otherwise, `false`.
      * @example
      *
      *     class Example {
      *         // property declarations are not part of ES6, though they are valid in TypeScript:
      *         // static staticProperty;
      *         // property;
      *
      *         constructor(p) { }
      *         static staticMethod(p) { }
      *         method(p) { }
      *     }
      *
      *     // constructor
      *     result = Reflect.hasMetadata("custom:annotation", Example);
      *
      *     // property (on constructor)
      *     result = Reflect.hasMetadata("custom:annotation", Example, "staticProperty");
      *
      *     // property (on prototype)
      *     result = Reflect.hasMetadata("custom:annotation", Example.prototype, "property");
      *
      *     // method (on constructor)
      *     result = Reflect.hasMetadata("custom:annotation", Example, "staticMethod");
      *
      *     // method (on prototype)
      *     result = Reflect.hasMetadata("custom:annotation", Example.prototype, "method");
      *
      */
    function hasMetadata(metadataKey, target, propertyKey) {
        if (!IsObject(target))
            throw new TypeError();
        if (!IsUndefined(propertyKey))
            propertyKey = ToPropertyKey(propertyKey);
        return OrdinaryHasMetadata(metadataKey, target, propertyKey);
    }
    Reflect.hasMetadata = hasMetadata;
    /**
      * Gets a value indicating whether the target object has the provided metadata key defined.
      * @param metadataKey A key used to store and retrieve metadata.
      * @param target The target object on which the metadata is defined.
      * @param propertyKey (Optional) The property key for the target.
      * @returns `true` if the metadata key was defined on the target object; otherwise, `false`.
      * @example
      *
      *     class Example {
      *         // property declarations are not part of ES6, though they are valid in TypeScript:
      *         // static staticProperty;
      *         // property;
      *
      *         constructor(p) { }
      *         static staticMethod(p) { }
      *         method(p) { }
      *     }
      *
      *     // constructor
      *     result = Reflect.hasOwnMetadata("custom:annotation", Example);
      *
      *     // property (on constructor)
      *     result = Reflect.hasOwnMetadata("custom:annotation", Example, "staticProperty");
      *
      *     // property (on prototype)
      *     result = Reflect.hasOwnMetadata("custom:annotation", Example.prototype, "property");
      *
      *     // method (on constructor)
      *     result = Reflect.hasOwnMetadata("custom:annotation", Example, "staticMethod");
      *
      *     // method (on prototype)
      *     result = Reflect.hasOwnMetadata("custom:annotation", Example.prototype, "method");
      *
      */
    function hasOwnMetadata(metadataKey, target, propertyKey) {
        if (!IsObject(target))
            throw new TypeError();
        if (!IsUndefined(propertyKey))
            propertyKey = ToPropertyKey(propertyKey);
        return OrdinaryHasOwnMetadata(metadataKey, target, propertyKey);
    }
    Reflect.hasOwnMetadata = hasOwnMetadata;
    /**
      * Gets the metadata value for the provided metadata key on the target object or its prototype chain.
      * @param metadataKey A key used to store and retrieve metadata.
      * @param target The target object on which the metadata is defined.
      * @param propertyKey (Optional) The property key for the target.
      * @returns The metadata value for the metadata key if found; otherwise, `undefined`.
      * @example
      *
      *     class Example {
      *         // property declarations are not part of ES6, though they are valid in TypeScript:
      *         // static staticProperty;
      *         // property;
      *
      *         constructor(p) { }
      *         static staticMethod(p) { }
      *         method(p) { }
      *     }
      *
      *     // constructor
      *     result = Reflect.getMetadata("custom:annotation", Example);
      *
      *     // property (on constructor)
      *     result = Reflect.getMetadata("custom:annotation", Example, "staticProperty");
      *
      *     // property (on prototype)
      *     result = Reflect.getMetadata("custom:annotation", Example.prototype, "property");
      *
      *     // method (on constructor)
      *     result = Reflect.getMetadata("custom:annotation", Example, "staticMethod");
      *
      *     // method (on prototype)
      *     result = Reflect.getMetadata("custom:annotation", Example.prototype, "method");
      *
      */
    function getMetadata(metadataKey, target, propertyKey) {
        if (!IsObject(target))
            throw new TypeError();
        if (!IsUndefined(propertyKey))
            propertyKey = ToPropertyKey(propertyKey);
        return OrdinaryGetMetadata(metadataKey, target, propertyKey);
    }
    Reflect.getMetadata = getMetadata;
    /**
      * Gets the metadata value for the provided metadata key on the target object.
      * @param metadataKey A key used to store and retrieve metadata.
      * @param target The target object on which the metadata is defined.
      * @param propertyKey (Optional) The property key for the target.
      * @returns The metadata value for the metadata key if found; otherwise, `undefined`.
      * @example
      *
      *     class Example {
      *         // property declarations are not part of ES6, though they are valid in TypeScript:
      *         // static staticProperty;
      *         // property;
      *
      *         constructor(p) { }
      *         static staticMethod(p) { }
      *         method(p) { }
      *     }
      *
      *     // constructor
      *     result = Reflect.getOwnMetadata("custom:annotation", Example);
      *
      *     // property (on constructor)
      *     result = Reflect.getOwnMetadata("custom:annotation", Example, "staticProperty");
      *
      *     // property (on prototype)
      *     result = Reflect.getOwnMetadata("custom:annotation", Example.prototype, "property");
      *
      *     // method (on constructor)
      *     result = Reflect.getOwnMetadata("custom:annotation", Example, "staticMethod");
      *
      *     // method (on prototype)
      *     result = Reflect.getOwnMetadata("custom:annotation", Example.prototype, "method");
      *
      */
    function getOwnMetadata(metadataKey, target, propertyKey) {
        if (!IsObject(target))
            throw new TypeError();
        if (!IsUndefined(propertyKey))
            propertyKey = ToPropertyKey(propertyKey);
        return OrdinaryGetOwnMetadata(metadataKey, target, propertyKey);
    }
    Reflect.getOwnMetadata = getOwnMetadata;
    /**
      * Gets the metadata keys defined on the target object or its prototype chain.
      * @param target The target object on which the metadata is defined.
      * @param propertyKey (Optional) The property key for the target.
      * @returns An array of unique metadata keys.
      * @example
      *
      *     class Example {
      *         // property declarations are not part of ES6, though they are valid in TypeScript:
      *         // static staticProperty;
      *         // property;
      *
      *         constructor(p) { }
      *         static staticMethod(p) { }
      *         method(p) { }
      *     }
      *
      *     // constructor
      *     result = Reflect.getMetadataKeys(Example);
      *
      *     // property (on constructor)
      *     result = Reflect.getMetadataKeys(Example, "staticProperty");
      *
      *     // property (on prototype)
      *     result = Reflect.getMetadataKeys(Example.prototype, "property");
      *
      *     // method (on constructor)
      *     result = Reflect.getMetadataKeys(Example, "staticMethod");
      *
      *     // method (on prototype)
      *     result = Reflect.getMetadataKeys(Example.prototype, "method");
      *
      */
    function getMetadataKeys(target, propertyKey) {
        if (!IsObject(target))
            throw new TypeError();
        if (!IsUndefined(propertyKey))
            propertyKey = ToPropertyKey(propertyKey);
        return OrdinaryMetadataKeys(target, propertyKey);
    }
    Reflect.getMetadataKeys = getMetadataKeys;
    /**
      * Gets the unique metadata keys defined on the target object.
      * @param target The target object on which the metadata is defined.
      * @param propertyKey (Optional) The property key for the target.
      * @returns An array of unique metadata keys.
      * @example
      *
      *     class Example {
      *         // property declarations are not part of ES6, though they are valid in TypeScript:
      *         // static staticProperty;
      *         // property;
      *
      *         constructor(p) { }
      *         static staticMethod(p) { }
      *         method(p) { }
      *     }
      *
      *     // constructor
      *     result = Reflect.getOwnMetadataKeys(Example);
      *
      *     // property (on constructor)
      *     result = Reflect.getOwnMetadataKeys(Example, "staticProperty");
      *
      *     // property (on prototype)
      *     result = Reflect.getOwnMetadataKeys(Example.prototype, "property");
      *
      *     // method (on constructor)
      *     result = Reflect.getOwnMetadataKeys(Example, "staticMethod");
      *
      *     // method (on prototype)
      *     result = Reflect.getOwnMetadataKeys(Example.prototype, "method");
      *
      */
    function getOwnMetadataKeys(target, propertyKey) {
        if (!IsObject(target))
            throw new TypeError();
        if (!IsUndefined(propertyKey))
            propertyKey = ToPropertyKey(propertyKey);
        return OrdinaryOwnMetadataKeys(target, propertyKey);
    }
    Reflect.getOwnMetadataKeys = getOwnMetadataKeys;
    /**
      * Deletes the metadata entry from the target object with the provided key.
      * @param metadataKey A key used to store and retrieve metadata.
      * @param target The target object on which the metadata is defined.
      * @param propertyKey (Optional) The property key for the target.
      * @returns `true` if the metadata entry was found and deleted; otherwise, false.
      * @example
      *
      *     class Example {
      *         // property declarations are not part of ES6, though they are valid in TypeScript:
      *         // static staticProperty;
      *         // property;
      *
      *         constructor(p) { }
      *         static staticMethod(p) { }
      *         method(p) { }
      *     }
      *
      *     // constructor
      *     result = Reflect.deleteMetadata("custom:annotation", Example);
      *
      *     // property (on constructor)
      *     result = Reflect.deleteMetadata("custom:annotation", Example, "staticProperty");
      *
      *     // property (on prototype)
      *     result = Reflect.deleteMetadata("custom:annotation", Example.prototype, "property");
      *
      *     // method (on constructor)
      *     result = Reflect.deleteMetadata("custom:annotation", Example, "staticMethod");
      *
      *     // method (on prototype)
      *     result = Reflect.deleteMetadata("custom:annotation", Example.prototype, "method");
      *
      */
    function deleteMetadata(metadataKey, target, propertyKey) {
        if (!IsObject(target))
            throw new TypeError();
        if (!IsUndefined(propertyKey))
            propertyKey = ToPropertyKey(propertyKey);
        var metadataMap = GetOrCreateMetadataMap(target, propertyKey, /*Create*/ false);
        if (IsUndefined(metadataMap))
            return false;
        if (!metadataMap.delete(metadataKey))
            return false;
        if (metadataMap.size > 0)
            return true;
        var targetMetadata = Metadata.get(target);
        targetMetadata.delete(propertyKey);
        if (targetMetadata.size > 0)
            return true;
        Metadata.delete(target);
        return true;
    }
    Reflect.deleteMetadata = deleteMetadata;
    function DecorateConstructor(decorators, target) {
        for (var i = decorators.length - 1; i >= 0; --i) {
            var decorator = decorators[i];
            var decorated = decorator(target);
            if (!IsUndefined(decorated) && !IsNull(decorated)) {
                if (!IsConstructor(decorated))
                    throw new TypeError();
                target = decorated;
            }
        }
        return target;
    }
    function DecorateProperty(decorators, target, propertyKey, descriptor) {
        for (var i = decorators.length - 1; i >= 0; --i) {
            var decorator = decorators[i];
            var decorated = decorator(target, propertyKey, descriptor);
            if (!IsUndefined(decorated) && !IsNull(decorated)) {
                if (!IsObject(decorated))
                    throw new TypeError();
                descriptor = decorated;
            }
        }
        return descriptor;
    }
    function GetOrCreateMetadataMap(O, P, Create) {
        var targetMetadata = Metadata.get(O);
        if (IsUndefined(targetMetadata)) {
            if (!Create)
                return undefined;
            targetMetadata = new _Map();
            Metadata.set(O, targetMetadata);
        }
        var metadataMap = targetMetadata.get(P);
        if (IsUndefined(metadataMap)) {
            if (!Create)
                return undefined;
            metadataMap = new _Map();
            targetMetadata.set(P, metadataMap);
        }
        return metadataMap;
    }
    // 3.1.1.1 OrdinaryHasMetadata(MetadataKey, O, P)
    // https://rbuckton.github.io/reflect-metadata/#ordinaryhasmetadata
    function OrdinaryHasMetadata(MetadataKey, O, P) {
        var hasOwn = OrdinaryHasOwnMetadata(MetadataKey, O, P);
        if (hasOwn)
            return true;
        var parent = OrdinaryGetPrototypeOf(O);
        if (!IsNull(parent))
            return OrdinaryHasMetadata(MetadataKey, parent, P);
        return false;
    }
    // 3.1.2.1 OrdinaryHasOwnMetadata(MetadataKey, O, P)
    // https://rbuckton.github.io/reflect-metadata/#ordinaryhasownmetadata
    function OrdinaryHasOwnMetadata(MetadataKey, O, P) {
        var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ false);
        if (IsUndefined(metadataMap))
            return false;
        return ToBoolean(metadataMap.has(MetadataKey));
    }
    // 3.1.3.1 OrdinaryGetMetadata(MetadataKey, O, P)
    // https://rbuckton.github.io/reflect-metadata/#ordinarygetmetadata
    function OrdinaryGetMetadata(MetadataKey, O, P) {
        var hasOwn = OrdinaryHasOwnMetadata(MetadataKey, O, P);
        if (hasOwn)
            return OrdinaryGetOwnMetadata(MetadataKey, O, P);
        var parent = OrdinaryGetPrototypeOf(O);
        if (!IsNull(parent))
            return OrdinaryGetMetadata(MetadataKey, parent, P);
        return undefined;
    }
    // 3.1.4.1 OrdinaryGetOwnMetadata(MetadataKey, O, P)
    // https://rbuckton.github.io/reflect-metadata/#ordinarygetownmetadata
    function OrdinaryGetOwnMetadata(MetadataKey, O, P) {
        var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ false);
        if (IsUndefined(metadataMap))
            return undefined;
        return metadataMap.get(MetadataKey);
    }
    // 3.1.5.1 OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P)
    // https://rbuckton.github.io/reflect-metadata/#ordinarydefineownmetadata
    function OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P) {
        var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ true);
        metadataMap.set(MetadataKey, MetadataValue);
    }
    // 3.1.6.1 OrdinaryMetadataKeys(O, P)
    // https://rbuckton.github.io/reflect-metadata/#ordinarymetadatakeys
    function OrdinaryMetadataKeys(O, P) {
        var ownKeys = OrdinaryOwnMetadataKeys(O, P);
        var parent = OrdinaryGetPrototypeOf(O);
        if (parent === null)
            return ownKeys;
        var parentKeys = OrdinaryMetadataKeys(parent, P);
        if (parentKeys.length <= 0)
            return ownKeys;
        if (ownKeys.length <= 0)
            return parentKeys;
        var set = new _Set();
        var keys = [];
        for (var _i = 0, ownKeys_1 = ownKeys; _i < ownKeys_1.length; _i++) {
            var key = ownKeys_1[_i];
            var hasKey = set.has(key);
            if (!hasKey) {
                set.add(key);
                keys.push(key);
            }
        }
        for (var _a = 0, parentKeys_1 = parentKeys; _a < parentKeys_1.length; _a++) {
            var key = parentKeys_1[_a];
            var hasKey = set.has(key);
            if (!hasKey) {
                set.add(key);
                keys.push(key);
            }
        }
        return keys;
    }
    // 3.1.7.1 OrdinaryOwnMetadataKeys(O, P)
    // https://rbuckton.github.io/reflect-metadata/#ordinaryownmetadatakeys
    function OrdinaryOwnMetadataKeys(O, P) {
        var keys = [];
        var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ false);
        if (IsUndefined(metadataMap))
            return keys;
        var keysObj = metadataMap.keys();
        var iterator = GetIterator(keysObj);
        var k = 0;
        while (true) {
            var next = IteratorStep(iterator);
            if (!next) {
                keys.length = k;
                return keys;
            }
            var nextValue = IteratorValue(next);
            try {
                keys[k] = nextValue;
            }
            catch (e) {
                try {
                    IteratorClose(iterator);
                }
                finally {
                    throw e;
                }
            }
            k++;
        }
    }
    // 6 ECMAScript Data Typ0es and Values
    // https://tc39.github.io/ecma262/#sec-ecmascript-data-types-and-values
    function Type(x) {
        if (x === null)
            return 1 /* Null */;
        switch (typeof x) {
            case "undefined": return 0 /* Undefined */;
            case "boolean": return 2 /* Boolean */;
            case "string": return 3 /* String */;
            case "symbol": return 4 /* Symbol */;
            case "number": return 5 /* Number */;
            case "object": return x === null ? 1 /* Null */ : 6 /* Object */;
            default: return 6 /* Object */;
        }
    }
    // 6.1.1 The Undefined Type
    // https://tc39.github.io/ecma262/#sec-ecmascript-language-types-undefined-type
    function IsUndefined(x) {
        return x === undefined;
    }
    // 6.1.2 The Null Type
    // https://tc39.github.io/ecma262/#sec-ecmascript-language-types-null-type
    function IsNull(x) {
        return x === null;
    }
    // 6.1.5 The Symbol Type
    // https://tc39.github.io/ecma262/#sec-ecmascript-language-types-symbol-type
    function IsSymbol(x) {
        return typeof x === "symbol";
    }
    // 6.1.7 The Object Type
    // https://tc39.github.io/ecma262/#sec-object-type
    function IsObject(x) {
        return typeof x === "object" ? x !== null : typeof x === "function";
    }
    // 7.1 Type Conversion
    // https://tc39.github.io/ecma262/#sec-type-conversion
    // 7.1.1 ToPrimitive(input [, PreferredType])
    // https://tc39.github.io/ecma262/#sec-toprimitive
    function ToPrimitive(input, PreferredType) {
        switch (Type(input)) {
            case 0 /* Undefined */: return input;
            case 1 /* Null */: return input;
            case 2 /* Boolean */: return input;
            case 3 /* String */: return input;
            case 4 /* Symbol */: return input;
            case 5 /* Number */: return input;
        }
        var hint = PreferredType === 3 /* String */ ? "string" : PreferredType === 5 /* Number */ ? "number" : "default";
        var exoticToPrim = GetMethod(input, toPrimitiveSymbol);
        if (exoticToPrim !== undefined) {
            var result = exoticToPrim.call(input, hint);
            if (IsObject(result))
                throw new TypeError();
            return result;
        }
        return OrdinaryToPrimitive(input, hint === "default" ? "number" : hint);
    }
    // 7.1.1.1 OrdinaryToPrimitive(O, hint)
    // https://tc39.github.io/ecma262/#sec-ordinarytoprimitive
    function OrdinaryToPrimitive(O, hint) {
        if (hint === "string") {
            var toString_1 = O.toString;
            if (IsCallable(toString_1)) {
                var result = toString_1.call(O);
                if (!IsObject(result))
                    return result;
            }
            var valueOf = O.valueOf;
            if (IsCallable(valueOf)) {
                var result = valueOf.call(O);
                if (!IsObject(result))
                    return result;
            }
        }
        else {
            var valueOf = O.valueOf;
            if (IsCallable(valueOf)) {
                var result = valueOf.call(O);
                if (!IsObject(result))
                    return result;
            }
            var toString_2 = O.toString;
            if (IsCallable(toString_2)) {
                var result = toString_2.call(O);
                if (!IsObject(result))
                    return result;
            }
        }
        throw new TypeError();
    }
    // 7.1.2 ToBoolean(argument)
    // https://tc39.github.io/ecma262/2016/#sec-toboolean
    function ToBoolean(argument) {
        return !!argument;
    }
    // 7.1.12 ToString(argument)
    // https://tc39.github.io/ecma262/#sec-tostring
    function ToString(argument) {
        return "" + argument;
    }
    // 7.1.14 ToPropertyKey(argument)
    // https://tc39.github.io/ecma262/#sec-topropertykey
    function ToPropertyKey(argument) {
        var key = ToPrimitive(argument, 3 /* String */);
        if (IsSymbol(key))
            return key;
        return ToString(key);
    }
    // 7.2 Testing and Comparison Operations
    // https://tc39.github.io/ecma262/#sec-testing-and-comparison-operations
    // 7.2.2 IsArray(argument)
    // https://tc39.github.io/ecma262/#sec-isarray
    function IsArray(argument) {
        return Array.isArray
            ? Array.isArray(argument)
            : argument instanceof Object
                ? argument instanceof Array
                : Object.prototype.toString.call(argument) === "[object Array]";
    }
    // 7.2.3 IsCallable(argument)
    // https://tc39.github.io/ecma262/#sec-iscallable
    function IsCallable(argument) {
        // NOTE: This is an approximation as we cannot check for [[Call]] internal method.
        return typeof argument === "function";
    }
    // 7.2.4 IsConstructor(argument)
    // https://tc39.github.io/ecma262/#sec-isconstructor
    function IsConstructor(argument) {
        // NOTE: This is an approximation as we cannot check for [[Construct]] internal method.
        return typeof argument === "function";
    }
    // 7.2.7 IsPropertyKey(argument)
    // https://tc39.github.io/ecma262/#sec-ispropertykey
    function IsPropertyKey(argument) {
        switch (Type(argument)) {
            case 3 /* String */: return true;
            case 4 /* Symbol */: return true;
            default: return false;
        }
    }
    // 7.3 Operations on Objects
    // https://tc39.github.io/ecma262/#sec-operations-on-objects
    // 7.3.9 GetMethod(V, P)
    // https://tc39.github.io/ecma262/#sec-getmethod
    function GetMethod(V, P) {
        var func = V[P];
        if (func === undefined || func === null)
            return undefined;
        if (!IsCallable(func))
            throw new TypeError();
        return func;
    }
    // 7.4 Operations on Iterator Objects
    // https://tc39.github.io/ecma262/#sec-operations-on-iterator-objects
    function GetIterator(obj) {
        var method = GetMethod(obj, iteratorSymbol);
        if (!IsCallable(method))
            throw new TypeError(); // from Call
        var iterator = method.call(obj);
        if (!IsObject(iterator))
            throw new TypeError();
        return iterator;
    }
    // 7.4.4 IteratorValue(iterResult)
    // https://tc39.github.io/ecma262/2016/#sec-iteratorvalue
    function IteratorValue(iterResult) {
        return iterResult.value;
    }
    // 7.4.5 IteratorStep(iterator)
    // https://tc39.github.io/ecma262/#sec-iteratorstep
    function IteratorStep(iterator) {
        var result = iterator.next();
        return result.done ? false : result;
    }
    // 7.4.6 IteratorClose(iterator, completion)
    // https://tc39.github.io/ecma262/#sec-iteratorclose
    function IteratorClose(iterator) {
        var f = iterator["return"];
        if (f)
            f.call(iterator);
    }
    // 9.1 Ordinary Object Internal Methods and Internal Slots
    // https://tc39.github.io/ecma262/#sec-ordinary-object-internal-methods-and-internal-slots
    // 9.1.1.1 OrdinaryGetPrototypeOf(O)
    // https://tc39.github.io/ecma262/#sec-ordinarygetprototypeof
    function OrdinaryGetPrototypeOf(O) {
        var proto = Object.getPrototypeOf(O);
        if (typeof O !== "function" || O === functionPrototype)
            return proto;
        // TypeScript doesn't set __proto__ in ES5, as it's non-standard.
        // Try to determine the superclass constructor. Compatible implementations
        // must either set __proto__ on a subclass constructor to the superclass constructor,
        // or ensure each class has a valid `constructor` property on its prototype that
        // points back to the constructor.
        // If this is not the same as Function.[[Prototype]], then this is definately inherited.
        // This is the case when in ES6 or when using __proto__ in a compatible browser.
        if (proto !== functionPrototype)
            return proto;
        // If the super prototype is Object.prototype, null, or undefined, then we cannot determine the heritage.
        var prototype = O.prototype;
        var prototypeProto = prototype && Object.getPrototypeOf(prototype);
        if (prototypeProto == null || prototypeProto === Object.prototype)
            return proto;
        // If the constructor was not a function, then we cannot determine the heritage.
        var constructor = prototypeProto.constructor;
        if (typeof constructor !== "function")
            return proto;
        // If we have some kind of self-reference, then we cannot determine the heritage.
        if (constructor === O)
            return proto;
        // we have a pretty good guess at the heritage.
        return constructor;
    }
    // naive Map shim
    function CreateMapPolyfill() {
        var cacheSentinel = {};
        var arraySentinel = [];
        var MapIterator = (function () {
            function MapIterator(keys, values, selector) {
                this._index = 0;
                this._keys = keys;
                this._values = values;
                this._selector = selector;
            }
            MapIterator.prototype["@@iterator"] = function () { return this; };
            MapIterator.prototype[iteratorSymbol] = function () { return this; };
            MapIterator.prototype.next = function () {
                var index = this._index;
                if (index >= 0 && index < this._keys.length) {
                    var result = this._selector(this._keys[index], this._values[index]);
                    if (index + 1 >= this._keys.length) {
                        this._index = -1;
                        this._keys = arraySentinel;
                        this._values = arraySentinel;
                    }
                    else {
                        this._index++;
                    }
                    return { value: result, done: false };
                }
                return { value: undefined, done: true };
            };
            MapIterator.prototype.throw = function (error) {
                if (this._index >= 0) {
                    this._index = -1;
                    this._keys = arraySentinel;
                    this._values = arraySentinel;
                }
                throw error;
            };
            MapIterator.prototype.return = function (value) {
                if (this._index >= 0) {
                    this._index = -1;
                    this._keys = arraySentinel;
                    this._values = arraySentinel;
                }
                return { value: value, done: true };
            };
            return MapIterator;
        }());
        return (function () {
            function Map() {
                this._keys = [];
                this._values = [];
                this._cacheKey = cacheSentinel;
                this._cacheIndex = -2;
            }
            Object.defineProperty(Map.prototype, "size", {
                get: function () { return this._keys.length; },
                enumerable: true,
                configurable: true
            });
            Map.prototype.has = function (key) { return this._find(key, /*insert*/ false) >= 0; };
            Map.prototype.get = function (key) {
                var index = this._find(key, /*insert*/ false);
                return index >= 0 ? this._values[index] : undefined;
            };
            Map.prototype.set = function (key, value) {
                var index = this._find(key, /*insert*/ true);
                this._values[index] = value;
                return this;
            };
            Map.prototype.delete = function (key) {
                var index = this._find(key, /*insert*/ false);
                if (index >= 0) {
                    var size = this._keys.length;
                    for (var i = index + 1; i < size; i++) {
                        this._keys[i - 1] = this._keys[i];
                        this._values[i - 1] = this._values[i];
                    }
                    this._keys.length--;
                    this._values.length--;
                    if (key === this._cacheKey) {
                        this._cacheKey = cacheSentinel;
                        this._cacheIndex = -2;
                    }
                    return true;
                }
                return false;
            };
            Map.prototype.clear = function () {
                this._keys.length = 0;
                this._values.length = 0;
                this._cacheKey = cacheSentinel;
                this._cacheIndex = -2;
            };
            Map.prototype.keys = function () { return new MapIterator(this._keys, this._values, getKey); };
            Map.prototype.values = function () { return new MapIterator(this._keys, this._values, getValue); };
            Map.prototype.entries = function () { return new MapIterator(this._keys, this._values, getEntry); };
            Map.prototype["@@iterator"] = function () { return this.entries(); };
            Map.prototype[iteratorSymbol] = function () { return this.entries(); };
            Map.prototype._find = function (key, insert) {
                if (this._cacheKey !== key) {
                    this._cacheIndex = this._keys.indexOf(this._cacheKey = key);
                }
                if (this._cacheIndex < 0 && insert) {
                    this._cacheIndex = this._keys.length;
                    this._keys.push(key);
                    this._values.push(undefined);
                }
                return this._cacheIndex;
            };
            return Map;
        }());
        function getKey(key, _) {
            return key;
        }
        function getValue(_, value) {
            return value;
        }
        function getEntry(key, value) {
            return [key, value];
        }
    }
    // naive Set shim
    function CreateSetPolyfill() {
        return (function () {
            function Set() {
                this._map = new _Map();
            }
            Object.defineProperty(Set.prototype, "size", {
                get: function () { return this._map.size; },
                enumerable: true,
                configurable: true
            });
            Set.prototype.has = function (value) { return this._map.has(value); };
            Set.prototype.add = function (value) { return this._map.set(value, value), this; };
            Set.prototype.delete = function (value) { return this._map.delete(value); };
            Set.prototype.clear = function () { this._map.clear(); };
            Set.prototype.keys = function () { return this._map.keys(); };
            Set.prototype.values = function () { return this._map.values(); };
            Set.prototype.entries = function () { return this._map.entries(); };
            Set.prototype["@@iterator"] = function () { return this.keys(); };
            Set.prototype[iteratorSymbol] = function () { return this.keys(); };
            return Set;
        }());
    }
    // naive WeakMap shim
    function CreateWeakMapPolyfill() {
        var UUID_SIZE = 16;
        var keys = HashMap.create();
        var rootKey = CreateUniqueKey();
        return (function () {
            function WeakMap() {
                this._key = CreateUniqueKey();
            }
            WeakMap.prototype.has = function (target) {
                var table = GetOrCreateWeakMapTable(target, /*create*/ false);
                return table !== undefined ? HashMap.has(table, this._key) : false;
            };
            WeakMap.prototype.get = function (target) {
                var table = GetOrCreateWeakMapTable(target, /*create*/ false);
                return table !== undefined ? HashMap.get(table, this._key) : undefined;
            };
            WeakMap.prototype.set = function (target, value) {
                var table = GetOrCreateWeakMapTable(target, /*create*/ true);
                table[this._key] = value;
                return this;
            };
            WeakMap.prototype.delete = function (target) {
                var table = GetOrCreateWeakMapTable(target, /*create*/ false);
                return table !== undefined ? delete table[this._key] : false;
            };
            WeakMap.prototype.clear = function () {
                // NOTE: not a real clear, just makes the previous data unreachable
                this._key = CreateUniqueKey();
            };
            return WeakMap;
        }());
        function CreateUniqueKey() {
            var key;
            do
                key = "@@WeakMap@@" + CreateUUID();
            while (HashMap.has(keys, key));
            keys[key] = true;
            return key;
        }
        function GetOrCreateWeakMapTable(target, create) {
            if (!hasOwn.call(target, rootKey)) {
                if (!create)
                    return undefined;
                Object.defineProperty(target, rootKey, { value: HashMap.create() });
            }
            return target[rootKey];
        }
        function FillRandomBytes(buffer, size) {
            for (var i = 0; i < size; ++i)
                buffer[i] = Math.random() * 0xff | 0;
            return buffer;
        }
        function GenRandomBytes(size) {
            if (typeof Uint8Array === "function") {
                if (typeof crypto !== "undefined")
                    return crypto.getRandomValues(new Uint8Array(size));
                if (typeof msCrypto !== "undefined")
                    return msCrypto.getRandomValues(new Uint8Array(size));
                return FillRandomBytes(new Uint8Array(size), size);
            }
            return FillRandomBytes(new Array(size), size);
        }
        function CreateUUID() {
            var data = GenRandomBytes(UUID_SIZE);
            // mark as random - RFC 4122 § 4.4
            data[6] = data[6] & 0x4f | 0x40;
            data[8] = data[8] & 0xbf | 0x80;
            var result = "";
            for (var offset = 0; offset < UUID_SIZE; ++offset) {
                var byte = data[offset];
                if (offset === 4 || offset === 6 || offset === 8)
                    result += "-";
                if (byte < 16)
                    result += "0";
                result += byte.toString(16).toLowerCase();
            }
            return result;
        }
    }
    // uses a heuristic used by v8 and chakra to force an object into dictionary mode.
    function MakeDictionary(obj) {
        obj.__ = undefined;
        delete obj.__;
        return obj;
    }
    // patch global Reflect
    (function (__global) {
        if (typeof __global.Reflect !== "undefined") {
            if (__global.Reflect !== Reflect) {
                for (var p in Reflect) {
                    if (hasOwn.call(Reflect, p)) {
                        __global.Reflect[p] = Reflect[p];
                    }
                }
            }
        }
        else {
            __global.Reflect = Reflect;
        }
    })(typeof global !== "undefined" ? global :
        typeof self !== "undefined" ? self :
            Function("return this;")());
})(Reflect || (Reflect = {}));
//# sourceMappingURL=Reflect.js.map

/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(2))(357);

/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(2))(225);

/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(2))(66);

/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(2))(73);

/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(2))(21);

/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(2))(378);

/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(2))(56);

/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(2))(77);

/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(2))(334);

/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var DOMImplementation = __webpack_require__(12);
var HTMLParser = __webpack_require__(29);
var Window = __webpack_require__(27);

exports.createDOMImplementation = function() {
  return new DOMImplementation();
};

exports.createDocument = function(html, force) {
  // Previous API couldn't let you pass '' as a document, and that
  // yields a slightly different document than createHTMLDocument('')
  // does.  The new `force` parameter lets you pass '' if you want to.
  if (html || force) {
    var parser = new HTMLParser();
    parser.parse(html || '', true);
    return parser.document();
  }
  return new DOMImplementation().createHTMLDocument("");
};

exports.createWindow = function(html, address) {
  var document = exports.createDocument(html);
  if (address !== undefined) { document._address = address; }
  return new Window(document);
};

exports.impl = __webpack_require__(59);


/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = FilteredElementList;

var Node = __webpack_require__(4);

//
// This file defines node list implementation that lazily traverses
// the document tree (or a subtree rooted at any element) and includes
// only those elements for which a specified filter function returns true.
// It is used to implement the
// {Document,Element}.getElementsBy{TagName,ClassName}{,NS} methods.
//

function FilteredElementList(root, filter) {
  this.root = root;
  this.filter = filter;
  this.lastModTime = root.lastModTime;
  this.done = false;
  this.cache = [];
  this.traverse();
}

FilteredElementList.prototype = {
  get length() {
    this.checkcache();
    if (!this.done) this.traverse();
    return this.cache.length;
  },

  item: function(n) {
    this.checkcache();
    if (!this.done && n >= this.cache.length) this.traverse(n);
    return this.cache[n];
  },

  checkcache: function() {
    if (this.lastModTime !== this.root.lastModTime) {
      // subtree has changed, so invalidate cache
      for (var i = this.cache.length-1; i>=0; i--) {
        this[i] = undefined;
      }
      this.cache.length = 0;
      this.done = false;
      this.lastModTime = this.root.lastModTime;
    }
  },

  // If n is specified, then traverse the tree until we've found the nth
  // item (or until we've found all items).  If n is not specified,
  // traverse until we've found all items.
  traverse: function(n) {
    // increment n so we can compare to length, and so it is never falsy
    if (n !== undefined) n++;

    var elt;
    while ((elt = this.next()) !== null) {
      this[this.cache.length] = elt; //XXX Use proxy instead
      this.cache.push(elt);
      if (n && this.cache.length === n) return;
    }

    // no next element, so we've found everything
    this.done = true;
  },

  // Return the next element under root that matches filter
  next: function() {
    var start = (this.cache.length === 0) ? this.root // Start at the root or at
      : this.cache[this.cache.length-1]; // the last element we found

    var elt;
    if (start.nodeType === Node.DOCUMENT_NODE)
      elt = start.documentElement;
    else
      elt = start.nextElement(this.root);

    while(elt) {
      if (this.filter(elt)) {
        return elt;
      }

      elt = elt.nextElement(this.root);
    }
    return null;
  }
};


/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = TreeWalker;

var NodeFilter = __webpack_require__(15);
var NodeTraversal = __webpack_require__(54);

var mapChild = {
  first: 'firstChild',
  last: 'lastChild',
  next: 'firstChild',
  previous: 'lastChild'
};

var mapSibling = {
  first: 'nextSibling',
  last: 'previousSibling',
  next: 'nextSibling',
  previous: 'previousSibling'
};

/* Private methods and helpers */

/**
 * @spec http://www.w3.org/TR/dom/#concept-traverse-children
 * @method
 * @access private
 * @param {TreeWalker} tw
 * @param {string} type One of 'first' or 'last'.
 * @return {Node|null}
 */
function traverseChildren(tw, type) {
  var child, node, parent, result, sibling;
  node = tw.currentNode[mapChild[type]];
  while (node !== null) {
    result = tw.filter.acceptNode(node);
    if (result === NodeFilter.FILTER_ACCEPT) {
      tw.currentNode = node;
      return node;
    }
    if (result === NodeFilter.FILTER_SKIP) {
      child = node[mapChild[type]];
      if (child !== null) {
        node = child;
        continue;
      }
    }
    while (node !== null) {
      sibling = node[mapSibling[type]];
      if (sibling !== null) {
        node = sibling;
        break;
      }
      parent = node.parentNode;
      if (parent === null || parent === tw.root || parent === tw.currentNode) {
        return null;
      }
      else {
        node = parent;
      }
    }
  }
  return null;
}

/**
 * @spec http://www.w3.org/TR/dom/#concept-traverse-siblings
 * @method
 * @access private
 * @param {TreeWalker} tw
 * @param {TreeWalker} type One of 'next' or 'previous'.
 * @return {Node|nul}
 */
function traverseSiblings(tw, type) {
  var node, result, sibling;
  node = tw.currentNode;
  if (node === tw.root) {
    return null;
  }
  while (true) {
    sibling = node[mapSibling[type]];
    while (sibling !== null) {
      node = sibling;
      result = tw.filter.acceptNode(node);
      if (result === NodeFilter.FILTER_ACCEPT) {
        tw.currentNode = node;
        return node;
      }
      sibling = node[mapChild[type]];
      if (result === NodeFilter.FILTER_REJECT || sibling === null) {
        sibling = node[mapSibling[type]];
      }
    }
    node = node.parentNode;
    if (node === null || node === tw.root) {
      return null;
    }
    if (tw.filter.acceptNode(node) === NodeFilter.FILTER_ACCEPT) {
      return null;
    }
  }
}


/* Public API */

/**
 * Implemented version: http://www.w3.org/TR/2015/WD-dom-20150618/#interface-treewalker
 * Latest version: http://www.w3.org/TR/dom/#interface-treewalker
 *
 * @constructor
 * @param {Node} root
 * @param {number} whatToShow [optional]
 * @param {Function|NodeFilter} filter [optional]
 * @throws Error
 */
function TreeWalker(root, whatToShow, filter) {
  var tw = this, active = false;

  if (!root || !root.nodeType) {
    throw new Error('DOMException: NOT_SUPPORTED_ERR');
  }

  tw.root = root;
  tw.whatToShow = Number(whatToShow) || 0;

  tw.currentNode = root;

  if (typeof filter !== 'function') {
    filter = null;
  }

  tw.filter = Object.create(NodeFilter.prototype);

  /**
   * @method
   * @param {Node} node
   * @return {Number} Constant NodeFilter.FILTER_ACCEPT,
   *  NodeFilter.FILTER_REJECT or NodeFilter.FILTER_SKIP.
   */
  tw.filter.acceptNode = function (node) {
    /* jshint bitwise: false */
    var result;
    if (active) {
      throw new Error('DOMException: INVALID_STATE_ERR');
    }

    // Maps nodeType to whatToShow
    if (!(((1 << (node.nodeType - 1)) & tw.whatToShow))) {
      return NodeFilter.FILTER_SKIP;
    }

    if (filter === null) {
      return NodeFilter.FILTER_ACCEPT;
    }

    active = true;
    result = filter(node);
    active = false;

    return result;
  };
}

TreeWalker.prototype = {

  constructor: TreeWalker,

  /**
   * @spec http://www.w3.org/TR/dom/#dom-treewalker-parentnode
   * @method
   * @return {Node|null}
   */
  parentNode: function () {
    var node = this.currentNode;
    while (node !== null && node !== this.root) {
      node = node.parentNode;
      if (node !== null && this.filter.acceptNode(node) === NodeFilter.FILTER_ACCEPT) {
        this.currentNode = node;
        return node;
      }
    }
    return null;
  },

  /**
   * @spec http://www.w3.org/TR/dom/#dom-treewalker-firstchild
   * @method
   * @return {Node|null}
   */
  firstChild: function () {
    return traverseChildren(this, 'first');
  },

  /**
   * @spec http://www.w3.org/TR/dom/#dom-treewalker-lastchild
   * @method
   * @return {Node|null}
   */
  lastChild: function () {
    return traverseChildren(this, 'last');
  },

  /**
   * @spec http://www.w3.org/TR/dom/#dom-treewalker-previoussibling
   * @method
   * @return {Node|null}
   */
  previousSibling: function () {
    return traverseSiblings(this, 'previous');
  },

  /**
   * @spec http://www.w3.org/TR/dom/#dom-treewalker-nextsibling
   * @method
   * @return {Node|null}
   */
  nextSibling: function () {
    return traverseSiblings(this, 'next');
  },

  /**
   * @spec http://www.w3.org/TR/dom/#dom-treewalker-previousnode
   * @method
   * @return {Node|null}
   */
  previousNode: function () {
    var node, result, sibling;
    node = this.currentNode;
    while (node !== this.root) {
      sibling = node.previousSibling;
      while (sibling !== null) {
        node = sibling;
        result = this.filter.acceptNode(node);
        while (result !== NodeFilter.FILTER_REJECT && node.lastChild !== null) {
          node = node.lastChild;
          result = this.filter.acceptNode(node);
        }
        if (result === NodeFilter.FILTER_ACCEPT) {
          this.currentNode = node;
          return node;
        }
        sibling = node.previousSibling;
      }
      if (node === this.root || node.parentNode === null) {
        return null;
      }
      node = node.parentNode;
      if (this.filter.acceptNode(node) === NodeFilter.FILTER_ACCEPT) {
        this.currentNode = node;
        return node;
      }
    }
    return null;
  },

  /**
   * @spec http://www.w3.org/TR/dom/#dom-treewalker-nextnode
   * @based on WebKit's TreeWalker::nextNode
   * https://trac.webkit.org/browser/trunk/Source/WebCore/dom/TreeWalker.cpp?rev=179143#L252
   * @method
   * @return {Node|null}
   */
  nextNode: function () {
    var node, result, following;
    node = this.currentNode;
    result = NodeFilter.FILTER_ACCEPT;

    while (true) {
      while (result !== NodeFilter.FILTER_REJECT && node.firstChild !== null) {
        node = node.firstChild;
        result = this.filter.acceptNode(node);
        if (result === NodeFilter.FILTER_ACCEPT) {
          this.currentNode = node;
          return node;
        }
      }
      following = NodeTraversal.nextSkippingChildren(node, this.root);
      if (following !== null) {
        node = following;
      }
      else {
        return null;
      }
      result = this.filter.acceptNode(node);
      if (result === NodeFilter.FILTER_ACCEPT) {
        this.currentNode = node;
        return node;
      }
    }
  }
};


/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = NodeIterator;

var NodeFilter = __webpack_require__(15);
var NodeTraversal = __webpack_require__(54);

/* Private methods and helpers */

/**
 * @based on WebKit's NodeIterator::moveToNext and NodeIterator::moveToPrevious
 * https://trac.webkit.org/browser/trunk/Source/WebCore/dom/NodeIterator.cpp?rev=186279#L51
 */
function move(node, stayWithin, directionIsNext) {
  if (directionIsNext) {
    return NodeTraversal.next(node, stayWithin);
  } else {
    if (node === stayWithin) {
      return null;
    }
    return NodeTraversal.previous(node, null);
  }
}

/**
 * @spec http://www.w3.org/TR/dom/#concept-nodeiterator-traverse
 * @method
 * @access private
 * @param {NodeIterator} ni
 * @param {string} direction One of 'next' or 'previous'.
 * @return {Node|null}
 */
function traverse(ni, directionIsNext) {
  var node, beforeNode;
  node = ni.referenceNode;
  beforeNode = ni.pointerBeforeReferenceNode;
  while (true) {
    if (beforeNode === directionIsNext) {
      beforeNode = !beforeNode;
    } else {
      node = move(node, ni.root, directionIsNext);
      if (node === null) {
        return null;
      }
    }
    var result = ni.filter.acceptNode(node);
    if (result === NodeFilter.FILTER_ACCEPT) {
      break;
    }
  }
  ni.referenceNode = node;
  ni.pointerBeforeReferenceNode = beforeNode;
  return node;
}

/* Public API */

/**
 * Implemented version: http://www.w3.org/TR/2015/WD-dom-20150618/#nodeiterator
 * Latest version: http://www.w3.org/TR/dom/#nodeiterator
 *
 * @constructor
 * @param {Node} root
 * @param {number} whatToShow [optional]
 * @param {Function|NodeFilter} filter [optional]
 * @throws Error
 */
function NodeIterator(root, whatToShow, filter) {
  var ni = this, active = false;

  if (!root || !root.nodeType) {
    throw new Error('DOMException: NOT_SUPPORTED_ERR');
  }

  ni.root = ni.referenceNode = root;
  ni.pointerBeforeReferenceNode = true;
  ni.whatToShow = Number(whatToShow) || 0;

  if (typeof filter !== 'function') {
    filter = null;
  }

  ni.filter = Object.create(NodeFilter.prototype);

  /**
   * @method
   * @param {Node} node
   * @return {Number} Constant NodeFilter.FILTER_ACCEPT,
   *  NodeFilter.FILTER_REJECT or NodeFilter.FILTER_SKIP.
   */
  ni.filter.acceptNode = function (node) {
    /* jshint bitwise: false */
    var result;
    if (active) {
      throw new Error('DOMException: INVALID_STATE_ERR');
    }

    // Maps nodeType to whatToShow
    if (!(((1 << (node.nodeType - 1)) & ni.whatToShow))) {
      return NodeFilter.FILTER_SKIP;
    }

    if (filter === null) {
      return NodeFilter.FILTER_ACCEPT;
    }

    active = true;
    result = filter(node);
    active = false;

    return result;
  };
}

NodeIterator.prototype = {
  constructor: NodeIterator,

  /**
   * @spec http://www.w3.org/TR/dom/#dom-nodeiterator-nextnode
   * @method
   * @return {Node|null}
   */
  nextNode: function () {
    return traverse(this, true);
  },

  /**
   * @spec http://www.w3.org/TR/dom/#dom-nodeiterator-previousnode
   * @method
   * @return {Node|null}
   */
  previousNode: function () {
    return traverse(this, false);
  },

  /**
   * @spec http://www.w3.org/TR/dom/#dom-nodeiterator-detach
   * @method
   * @return void
   */
  detach: function() {
    /* "The detach() method must do nothing.
     * Its functionality (disabling a NodeIterator object) was removed,
     * but the method itself is preserved for compatibility.
     */
  }
};


/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = CustomEvent;

var Event = __webpack_require__(8);

function CustomEvent(type, dictionary) {
  // Just use the superclass constructor to initialize
  Event.call(this, type, dictionary);
}
CustomEvent.prototype = Object.create(Event.prototype, {
  constructor: { value: CustomEvent }
});


/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* jshint node:true, latedef:false */
 // jshint ignore:line
/*!
Parser-Lib
Copyright (c) 2009-2011 Nicholas C. Zakas. All rights reserved.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

*/
/* Version v0.2.5+domino1, Build time: 30-January-2016 05:13:03 */
var parserlib = Object.create(null);
(function(){

/**
 * A generic base to inherit from for any object
 * that needs event handling.
 * @class EventTarget
 * @constructor
 */
function EventTarget(){

    /**
     * The array of listeners for various events.
     * @type Object
     * @property _listeners
     * @private
     */
    this._listeners = Object.create(null);
}

EventTarget.prototype = {

    //restore constructor
    constructor: EventTarget,

    /**
     * Adds a listener for a given event type.
     * @param {String} type The type of event to add a listener for.
     * @param {Function} listener The function to call when the event occurs.
     * @return {void}
     * @method addListener
     */
    addListener: function(type, listener){
        if (!this._listeners[type]){
            this._listeners[type] = [];
        }

        this._listeners[type].push(listener);
    },

    /**
     * Fires an event based on the passed-in object.
     * @param {Object|String} event An object with at least a 'type' attribute
     *      or a string indicating the event name.
     * @return {void}
     * @method fire
     */
    fire: function(event){
        if (typeof event === "string"){
            event = { type: event };
        }
        if (typeof event.target !== "undefined"){
            event.target = this;
        }

        if (typeof event.type === "undefined"){
            throw new Error("Event object missing 'type' property.");
        }

        if (this._listeners[event.type]){

            //create a copy of the array and use that so listeners can't chane
            var listeners = this._listeners[event.type].concat();
            for (var i=0, len=listeners.length; i < len; i++){
                listeners[i].call(this, event);
            }
        }
    },

    /**
     * Removes a listener for a given event type.
     * @param {String} type The type of event to remove a listener from.
     * @param {Function} listener The function to remove from the event.
     * @return {void}
     * @method removeListener
     */
    removeListener: function(type, listener){
        if (this._listeners[type]){
            var listeners = this._listeners[type];
            for (var i=0, len=listeners.length; i < len; i++){
                if (listeners[i] === listener){
                    listeners.splice(i, 1);
                    break;
                }
            }


        }
    }
};
/**
 * Convenient way to read through strings.
 * @namespace parserlib.util
 * @class StringReader
 * @constructor
 * @param {String} text The text to read.
 */
function StringReader(text){

    /**
     * The input text with line endings normalized.
     * @property _input
     * @type String
     * @private
     */
    this._input = text.replace(/(\r|\n){1,2}/g, "\n");


    /**
     * The row for the character to be read next.
     * @property _line
     * @type int
     * @private
     */
    this._line = 1;


    /**
     * The column for the character to be read next.
     * @property _col
     * @type int
     * @private
     */
    this._col = 1;

    /**
     * The index of the character in the input to be read next.
     * @property _cursor
     * @type int
     * @private
     */
    this._cursor = 0;
}

StringReader.prototype = {

    //restore constructor
    constructor: StringReader,

    //-------------------------------------------------------------------------
    // Position info
    //-------------------------------------------------------------------------

    /**
     * Returns the column of the character to be read next.
     * @return {int} The column of the character to be read next.
     * @method getCol
     */
    getCol: function(){
        return this._col;
    },

    /**
     * Returns the row of the character to be read next.
     * @return {int} The row of the character to be read next.
     * @method getLine
     */
    getLine: function(){
        return this._line ;
    },

    /**
     * Determines if you're at the end of the input.
     * @return {Boolean} True if there's no more input, false otherwise.
     * @method eof
     */
    eof: function(){
        return (this._cursor === this._input.length);
    },

    //-------------------------------------------------------------------------
    // Basic reading
    //-------------------------------------------------------------------------

    /**
     * Reads the next character without advancing the cursor.
     * @param {int} count How many characters to look ahead (default is 1).
     * @return {String} The next character or null if there is no next character.
     * @method peek
     */
    peek: function(count){
        var c = null;
        count = (typeof count === "undefined" ? 1 : count);

        //if we're not at the end of the input...
        if (this._cursor < this._input.length){

            //get character and increment cursor and column
            c = this._input.charAt(this._cursor + count - 1);
        }

        return c;
    },

    /**
     * Reads the next character from the input and adjusts the row and column
     * accordingly.
     * @return {String} The next character or null if there is no next character.
     * @method read
     */
    read: function(){
        var c = null;

        //if we're not at the end of the input...
        if (this._cursor < this._input.length){

            //if the last character was a newline, increment row count
            //and reset column count
            if (this._input.charAt(this._cursor) === "\n"){
                this._line++;
                this._col=1;
            } else {
                this._col++;
            }

            //get character and increment cursor and column
            c = this._input.charAt(this._cursor++);
        }

        return c;
    },

    //-------------------------------------------------------------------------
    // Misc
    //-------------------------------------------------------------------------

    /**
     * Saves the current location so it can be returned to later.
     * @method mark
     * @return {void}
     */
    mark: function(){
        this._bookmark = {
            cursor: this._cursor,
            line:   this._line,
            col:    this._col
        };
    },

    reset: function(){
        if (this._bookmark){
            this._cursor = this._bookmark.cursor;
            this._line = this._bookmark.line;
            this._col = this._bookmark.col;
            delete this._bookmark;
        }
    },

    //-------------------------------------------------------------------------
    // Advanced reading
    //-------------------------------------------------------------------------

    /**
     * Reads up to and including the given string. Throws an error if that
     * string is not found.
     * @param {String} pattern The string to read.
     * @return {String} The string when it is found.
     * @throws Error when the string pattern is not found.
     * @method readTo
     */
    readTo: function(pattern){

        var buffer = "",
            c;

        /*
         * First, buffer must be the same length as the pattern.
         * Then, buffer must end with the pattern or else reach the
         * end of the input.
         */
        while (buffer.length < pattern.length || buffer.lastIndexOf(pattern) !== buffer.length - pattern.length){
            c = this.read();
            if (c){
                buffer += c;
            } else {
                throw new Error("Expected \"" + pattern + "\" at line " + this._line  + ", col " + this._col + ".");
            }
        }

        return buffer;

    },

    /**
     * Reads characters while each character causes the given
     * filter function to return true. The function is passed
     * in each character and either returns true to continue
     * reading or false to stop.
     * @param {Function} filter The function to read on each character.
     * @return {String} The string made up of all characters that passed the
     *      filter check.
     * @method readWhile
     */
    readWhile: function(filter){

        var buffer = "",
            c = this.read();

        while(c !== null && filter(c)){
            buffer += c;
            c = this.read();
        }

        return buffer;

    },

    /**
     * Reads characters that match either text or a regular expression and
     * returns those characters. If a match is found, the row and column
     * are adjusted; if no match is found, the reader's state is unchanged.
     * reading or false to stop.
     * @param {String|RegExp} matchter If a string, then the literal string
     *      value is searched for. If a regular expression, then any string
     *      matching the pattern is search for.
     * @return {String} The string made up of all characters that matched or
     *      null if there was no match.
     * @method readMatch
     */
    readMatch: function(matcher){

        var source = this._input.substring(this._cursor),
            value = null;

        //if it's a string, just do a straight match
        if (typeof matcher === "string"){
            if (source.indexOf(matcher) === 0){
                value = this.readCount(matcher.length);
            }
        } else if (matcher instanceof RegExp){
            if (matcher.test(source)){
                value = this.readCount(RegExp.lastMatch.length);
            }
        }

        return value;
    },


    /**
     * Reads a given number of characters. If the end of the input is reached,
     * it reads only the remaining characters and does not throw an error.
     * @param {int} count The number of characters to read.
     * @return {String} The string made up the read characters.
     * @method readCount
     */
    readCount: function(count){
        var buffer = "";

        while(count--){
            buffer += this.read();
        }

        return buffer;
    }

};
/**
 * Type to use when a syntax error occurs.
 * @class SyntaxError
 * @namespace parserlib.util
 * @constructor
 * @param {String} message The error message.
 * @param {int} line The line at which the error occurred.
 * @param {int} col The column at which the error occurred.
 */
function SyntaxError(message, line, col){
    Error.call(this);
    this.name = this.constructor.name;

    /**
     * The column at which the error occurred.
     * @type int
     * @property col
     */
    this.col = col;

    /**
     * The line at which the error occurred.
     * @type int
     * @property line
     */
    this.line = line;

    /**
     * The text representation of the unit.
     * @type String
     * @property text
     */
    this.message = message;

}

//inherit from Error
SyntaxError.prototype = Object.create(Error.prototype); // jshint ignore:line
SyntaxError.prototype.constructor = SyntaxError; // jshint ignore:line
/**
 * Base type to represent a single syntactic unit.
 * @class SyntaxUnit
 * @namespace parserlib.util
 * @constructor
 * @param {String} text The text of the unit.
 * @param {int} line The line of text on which the unit resides.
 * @param {int} col The column of text on which the unit resides.
 */
function SyntaxUnit(text, line, col, type){


    /**
     * The column of text on which the unit resides.
     * @type int
     * @property col
     */
    this.col = col;

    /**
     * The line of text on which the unit resides.
     * @type int
     * @property line
     */
    this.line = line;

    /**
     * The text representation of the unit.
     * @type String
     * @property text
     */
    this.text = text;

    /**
     * The type of syntax unit.
     * @type int
     * @property type
     */
    this.type = type;
}

/**
 * Create a new syntax unit based solely on the given token.
 * Convenience method for creating a new syntax unit when
 * it represents a single token instead of multiple.
 * @param {Object} token The token object to represent.
 * @return {parserlib.util.SyntaxUnit} The object representing the token.
 * @static
 * @method fromToken
 */
SyntaxUnit.fromToken = function(token){
    return new SyntaxUnit(token.value, token.startLine, token.startCol);
};

SyntaxUnit.prototype = {

    //restore constructor
    constructor: SyntaxUnit,

    /**
     * Returns the text representation of the unit.
     * @return {String} The text representation of the unit.
     * @method valueOf
     */
    valueOf: function(){
        return this.toString();
    },

    /**
     * Returns the text representation of the unit.
     * @return {String} The text representation of the unit.
     * @method toString
     */
    toString: function(){
        return this.text;
    }

};

/**
 * Generic TokenStream providing base functionality.
 * @class TokenStreamBase
 * @namespace parserlib.util
 * @constructor
 * @param {String|StringReader} input The text to tokenize or a reader from
 *      which to read the input.
 */
function TokenStreamBase(input, tokenData){

    /**
     * The string reader for easy access to the text.
     * @type StringReader
     * @property _reader
     * @private
     */
    this._reader = input ? new StringReader(input.toString()) : null;

    /**
     * Token object for the last consumed token.
     * @type Token
     * @property _token
     * @private
     */
    this._token = null;

    /**
     * The array of token information.
     * @type Array
     * @property _tokenData
     * @private
     */
    this._tokenData = tokenData;

    /**
     * Lookahead token buffer.
     * @type Array
     * @property _lt
     * @private
     */
    this._lt = [];

    /**
     * Lookahead token buffer index.
     * @type int
     * @property _ltIndex
     * @private
     */
    this._ltIndex = 0;

    this._ltIndexCache = [];
}

/**
 * Accepts an array of token information and outputs
 * an array of token data containing key-value mappings
 * and matching functions that the TokenStream needs.
 * @param {Array} tokens An array of token descriptors.
 * @return {Array} An array of processed token data.
 * @method createTokenData
 * @static
 */
TokenStreamBase.createTokenData = function(tokens){

    var nameMap     = [],
        typeMap     = Object.create(null),
        tokenData     = tokens.concat([]),
        i            = 0,
        len            = tokenData.length+1;

    tokenData.UNKNOWN = -1;
    tokenData.unshift({name:"EOF"});

    for (; i < len; i++){
        nameMap.push(tokenData[i].name);
        tokenData[tokenData[i].name] = i;
        if (tokenData[i].text){
            typeMap[tokenData[i].text] = i;
        }
    }

    tokenData.name = function(tt){
        return nameMap[tt];
    };

    tokenData.type = function(c){
        return typeMap[c];
    };

    return tokenData;
};

TokenStreamBase.prototype = {

    //restore constructor
    constructor: TokenStreamBase,

    //-------------------------------------------------------------------------
    // Matching methods
    //-------------------------------------------------------------------------

    /**
     * Determines if the next token matches the given token type.
     * If so, that token is consumed; if not, the token is placed
     * back onto the token stream. You can pass in any number of
     * token types and this will return true if any of the token
     * types is found.
     * @param {int|int[]} tokenTypes Either a single token type or an array of
     *      token types that the next token might be. If an array is passed,
     *      it's assumed that the token can be any of these.
     * @param {variant} channel (Optional) The channel to read from. If not
     *      provided, reads from the default (unnamed) channel.
     * @return {Boolean} True if the token type matches, false if not.
     * @method match
     */
    match: function(tokenTypes, channel){

        //always convert to an array, makes things easier
        if (!(tokenTypes instanceof Array)){
            tokenTypes = [tokenTypes];
        }

        var tt  = this.get(channel),
            i   = 0,
            len = tokenTypes.length;

        while(i < len){
            if (tt === tokenTypes[i++]){
                return true;
            }
        }

        //no match found, put the token back
        this.unget();
        return false;
    },

    /**
     * Determines if the next token matches the given token type.
     * If so, that token is consumed; if not, an error is thrown.
     * @param {int|int[]} tokenTypes Either a single token type or an array of
     *      token types that the next token should be. If an array is passed,
     *      it's assumed that the token must be one of these.
     * @param {variant} channel (Optional) The channel to read from. If not
     *      provided, reads from the default (unnamed) channel.
     * @return {void}
     * @method mustMatch
     */
    mustMatch: function(tokenTypes, channel){

        var token;

        //always convert to an array, makes things easier
        if (!(tokenTypes instanceof Array)){
            tokenTypes = [tokenTypes];
        }

        if (!this.match.apply(this, arguments)){
            token = this.LT(1);
            throw new SyntaxError("Expected " + this._tokenData[tokenTypes[0]].name +
                " at line " + token.startLine + ", col " + token.startCol + ".", token.startLine, token.startCol);
        }
    },

    //-------------------------------------------------------------------------
    // Consuming methods
    //-------------------------------------------------------------------------

    /**
     * Keeps reading from the token stream until either one of the specified
     * token types is found or until the end of the input is reached.
     * @param {int|int[]} tokenTypes Either a single token type or an array of
     *      token types that the next token should be. If an array is passed,
     *      it's assumed that the token must be one of these.
     * @param {variant} channel (Optional) The channel to read from. If not
     *      provided, reads from the default (unnamed) channel.
     * @return {void}
     * @method advance
     */
    advance: function(tokenTypes, channel){

        while(this.LA(0) !== 0 && !this.match(tokenTypes, channel)){
            this.get();
        }

        return this.LA(0);
    },

    /**
     * Consumes the next token from the token stream.
     * @return {int} The token type of the token that was just consumed.
     * @method get
     */
    get: function(channel){

        var tokenInfo   = this._tokenData,
            i           =0,
            token,
            info;

        //check the lookahead buffer first
        if (this._lt.length && this._ltIndex >= 0 && this._ltIndex < this._lt.length){

            i++;
            this._token = this._lt[this._ltIndex++];
            info = tokenInfo[this._token.type];

            //obey channels logic
            while((info.channel !== undefined && channel !== info.channel) &&
                    this._ltIndex < this._lt.length){
                this._token = this._lt[this._ltIndex++];
                info = tokenInfo[this._token.type];
                i++;
            }

            //here be dragons
            if ((info.channel === undefined || channel === info.channel) &&
                    this._ltIndex <= this._lt.length){
                this._ltIndexCache.push(i);
                return this._token.type;
            }
        }

        //call token retriever method
        token = this._getToken();

        //if it should be hidden, don't save a token
        if (token.type > -1 && !tokenInfo[token.type].hide){

            //apply token channel
            token.channel = tokenInfo[token.type].channel;

            //save for later
            this._token = token;
            this._lt.push(token);

            //save space that will be moved (must be done before array is truncated)
            this._ltIndexCache.push(this._lt.length - this._ltIndex + i);

            //keep the buffer under 5 items
            if (this._lt.length > 5){
                this._lt.shift();
            }

            //also keep the shift buffer under 5 items
            if (this._ltIndexCache.length > 5){
                this._ltIndexCache.shift();
            }

            //update lookahead index
            this._ltIndex = this._lt.length;
        }

        /*
         * Skip to the next token if:
         * 1. The token type is marked as hidden.
         * 2. The token type has a channel specified and it isn't the current channel.
         */
        info = tokenInfo[token.type];
        if (info &&
                (info.hide ||
                (info.channel !== undefined && channel !== info.channel))){
            return this.get(channel);
        } else {
            //return just the type
            return token.type;
        }
    },

    /**
     * Looks ahead a certain number of tokens and returns the token type at
     * that position. This will throw an error if you lookahead past the
     * end of input, past the size of the lookahead buffer, or back past
     * the first token in the lookahead buffer.
     * @param {int} The index of the token type to retrieve. 0 for the
     *      current token, 1 for the next, -1 for the previous, etc.
     * @return {int} The token type of the token in the given position.
     * @method LA
     */
    LA: function(index){
        var total = index,
            tt;
        if (index > 0){
            //TODO: Store 5 somewhere
            if (index > 5){
                throw new Error("Too much lookahead.");
            }

            //get all those tokens
            while(total){
                tt = this.get();
                total--;
            }

            //unget all those tokens
            while(total < index){
                this.unget();
                total++;
            }
        } else if (index < 0){

            if(this._lt[this._ltIndex+index]){
                tt = this._lt[this._ltIndex+index].type;
            } else {
                throw new Error("Too much lookbehind.");
            }

        } else {
            tt = this._token.type;
        }

        return tt;

    },

    /**
     * Looks ahead a certain number of tokens and returns the token at
     * that position. This will throw an error if you lookahead past the
     * end of input, past the size of the lookahead buffer, or back past
     * the first token in the lookahead buffer.
     * @param {int} The index of the token type to retrieve. 0 for the
     *      current token, 1 for the next, -1 for the previous, etc.
     * @return {Object} The token of the token in the given position.
     * @method LA
     */
    LT: function(index){

        //lookahead first to prime the token buffer
        this.LA(index);

        //now find the token, subtract one because _ltIndex is already at the next index
        return this._lt[this._ltIndex+index-1];
    },

    /**
     * Returns the token type for the next token in the stream without
     * consuming it.
     * @return {int} The token type of the next token in the stream.
     * @method peek
     */
    peek: function(){
        return this.LA(1);
    },

    /**
     * Returns the actual token object for the last consumed token.
     * @return {Token} The token object for the last consumed token.
     * @method token
     */
    token: function(){
        return this._token;
    },

    /**
     * Returns the name of the token for the given token type.
     * @param {int} tokenType The type of token to get the name of.
     * @return {String} The name of the token or "UNKNOWN_TOKEN" for any
     *      invalid token type.
     * @method tokenName
     */
    tokenName: function(tokenType){
        if (tokenType < 0 || tokenType > this._tokenData.length){
            return "UNKNOWN_TOKEN";
        } else {
            return this._tokenData[tokenType].name;
        }
    },

    /**
     * Returns the token type value for the given token name.
     * @param {String} tokenName The name of the token whose value should be returned.
     * @return {int} The token type value for the given token name or -1
     *      for an unknown token.
     * @method tokenName
     */
    tokenType: function(tokenName){
        return this._tokenData[tokenName] || -1;
    },

    /**
     * Returns the last consumed token to the token stream.
     * @method unget
     */
    unget: function(){
        //if (this._ltIndex > -1){
        if (this._ltIndexCache.length){
            this._ltIndex -= this._ltIndexCache.pop();//--;
            this._token = this._lt[this._ltIndex - 1];
        } else {
            throw new Error("Too much lookahead.");
        }
    }

};


parserlib.util = {
__proto__   : null,
StringReader: StringReader,
SyntaxError : SyntaxError,
SyntaxUnit  : SyntaxUnit,
EventTarget : EventTarget,
TokenStreamBase : TokenStreamBase
};
})();
/*
Parser-Lib
Copyright (c) 2009-2011 Nicholas C. Zakas. All rights reserved.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

*/
/* Version v0.2.5+domino1, Build time: 30-January-2016 05:13:03 */
(function(){
var EventTarget = parserlib.util.EventTarget,
TokenStreamBase = parserlib.util.TokenStreamBase,
StringReader = parserlib.util.StringReader, // jshint ignore:line
SyntaxError = parserlib.util.SyntaxError,
SyntaxUnit  = parserlib.util.SyntaxUnit;

var Colors = {
    __proto__       :null,
    aliceblue       :"#f0f8ff",
    antiquewhite    :"#faebd7",
    aqua            :"#00ffff",
    aquamarine      :"#7fffd4",
    azure           :"#f0ffff",
    beige           :"#f5f5dc",
    bisque          :"#ffe4c4",
    black           :"#000000",
    blanchedalmond  :"#ffebcd",
    blue            :"#0000ff",
    blueviolet      :"#8a2be2",
    brown           :"#a52a2a",
    burlywood       :"#deb887",
    cadetblue       :"#5f9ea0",
    chartreuse      :"#7fff00",
    chocolate       :"#d2691e",
    coral           :"#ff7f50",
    cornflowerblue  :"#6495ed",
    cornsilk        :"#fff8dc",
    crimson         :"#dc143c",
    cyan            :"#00ffff",
    darkblue        :"#00008b",
    darkcyan        :"#008b8b",
    darkgoldenrod   :"#b8860b",
    darkgray        :"#a9a9a9",
    darkgrey        :"#a9a9a9",
    darkgreen       :"#006400",
    darkkhaki       :"#bdb76b",
    darkmagenta     :"#8b008b",
    darkolivegreen  :"#556b2f",
    darkorange      :"#ff8c00",
    darkorchid      :"#9932cc",
    darkred         :"#8b0000",
    darksalmon      :"#e9967a",
    darkseagreen    :"#8fbc8f",
    darkslateblue   :"#483d8b",
    darkslategray   :"#2f4f4f",
    darkslategrey   :"#2f4f4f",
    darkturquoise   :"#00ced1",
    darkviolet      :"#9400d3",
    deeppink        :"#ff1493",
    deepskyblue     :"#00bfff",
    dimgray         :"#696969",
    dimgrey         :"#696969",
    dodgerblue      :"#1e90ff",
    firebrick       :"#b22222",
    floralwhite     :"#fffaf0",
    forestgreen     :"#228b22",
    fuchsia         :"#ff00ff",
    gainsboro       :"#dcdcdc",
    ghostwhite      :"#f8f8ff",
    gold            :"#ffd700",
    goldenrod       :"#daa520",
    gray            :"#808080",
    grey            :"#808080",
    green           :"#008000",
    greenyellow     :"#adff2f",
    honeydew        :"#f0fff0",
    hotpink         :"#ff69b4",
    indianred       :"#cd5c5c",
    indigo          :"#4b0082",
    ivory           :"#fffff0",
    khaki           :"#f0e68c",
    lavender        :"#e6e6fa",
    lavenderblush   :"#fff0f5",
    lawngreen       :"#7cfc00",
    lemonchiffon    :"#fffacd",
    lightblue       :"#add8e6",
    lightcoral      :"#f08080",
    lightcyan       :"#e0ffff",
    lightgoldenrodyellow  :"#fafad2",
    lightgray       :"#d3d3d3",
    lightgrey       :"#d3d3d3",
    lightgreen      :"#90ee90",
    lightpink       :"#ffb6c1",
    lightsalmon     :"#ffa07a",
    lightseagreen   :"#20b2aa",
    lightskyblue    :"#87cefa",
    lightslategray  :"#778899",
    lightslategrey  :"#778899",
    lightsteelblue  :"#b0c4de",
    lightyellow     :"#ffffe0",
    lime            :"#00ff00",
    limegreen       :"#32cd32",
    linen           :"#faf0e6",
    magenta         :"#ff00ff",
    maroon          :"#800000",
    mediumaquamarine:"#66cdaa",
    mediumblue      :"#0000cd",
    mediumorchid    :"#ba55d3",
    mediumpurple    :"#9370d8",
    mediumseagreen  :"#3cb371",
    mediumslateblue :"#7b68ee",
    mediumspringgreen   :"#00fa9a",
    mediumturquoise :"#48d1cc",
    mediumvioletred :"#c71585",
    midnightblue    :"#191970",
    mintcream       :"#f5fffa",
    mistyrose       :"#ffe4e1",
    moccasin        :"#ffe4b5",
    navajowhite     :"#ffdead",
    navy            :"#000080",
    oldlace         :"#fdf5e6",
    olive           :"#808000",
    olivedrab       :"#6b8e23",
    orange          :"#ffa500",
    orangered       :"#ff4500",
    orchid          :"#da70d6",
    palegoldenrod   :"#eee8aa",
    palegreen       :"#98fb98",
    paleturquoise   :"#afeeee",
    palevioletred   :"#d87093",
    papayawhip      :"#ffefd5",
    peachpuff       :"#ffdab9",
    peru            :"#cd853f",
    pink            :"#ffc0cb",
    plum            :"#dda0dd",
    powderblue      :"#b0e0e6",
    purple          :"#800080",
    red             :"#ff0000",
    rosybrown       :"#bc8f8f",
    royalblue       :"#4169e1",
    saddlebrown     :"#8b4513",
    salmon          :"#fa8072",
    sandybrown      :"#f4a460",
    seagreen        :"#2e8b57",
    seashell        :"#fff5ee",
    sienna          :"#a0522d",
    silver          :"#c0c0c0",
    skyblue         :"#87ceeb",
    slateblue       :"#6a5acd",
    slategray       :"#708090",
    slategrey       :"#708090",
    snow            :"#fffafa",
    springgreen     :"#00ff7f",
    steelblue       :"#4682b4",
    tan             :"#d2b48c",
    teal            :"#008080",
    thistle         :"#d8bfd8",
    tomato          :"#ff6347",
    turquoise       :"#40e0d0",
    violet          :"#ee82ee",
    wheat           :"#f5deb3",
    white           :"#ffffff",
    whitesmoke      :"#f5f5f5",
    yellow          :"#ffff00",
    yellowgreen     :"#9acd32",
    //'currentColor' color keyword http://www.w3.org/TR/css3-color/#currentcolor
    currentColor        :"The value of the 'color' property.",
    //CSS2 system colors http://www.w3.org/TR/css3-color/#css2-system
    activeBorder        :"Active window border.",
    activecaption       :"Active window caption.",
    appworkspace        :"Background color of multiple document interface.",
    background          :"Desktop background.",
    buttonface          :"The face background color for 3-D elements that appear 3-D due to one layer of surrounding border.",
    buttonhighlight     :"The color of the border facing the light source for 3-D elements that appear 3-D due to one layer of surrounding border.",
    buttonshadow        :"The color of the border away from the light source for 3-D elements that appear 3-D due to one layer of surrounding border.",
    buttontext          :"Text on push buttons.",
    captiontext         :"Text in caption, size box, and scrollbar arrow box.",
    graytext            :"Grayed (disabled) text. This color is set to #000 if the current display driver does not support a solid gray color.",
    greytext            :"Greyed (disabled) text. This color is set to #000 if the current display driver does not support a solid grey color.",
    highlight           :"Item(s) selected in a control.",
    highlighttext       :"Text of item(s) selected in a control.",
    inactiveborder      :"Inactive window border.",
    inactivecaption     :"Inactive window caption.",
    inactivecaptiontext :"Color of text in an inactive caption.",
    infobackground      :"Background color for tooltip controls.",
    infotext            :"Text color for tooltip controls.",
    menu                :"Menu background.",
    menutext            :"Text in menus.",
    scrollbar           :"Scroll bar gray area.",
    threeddarkshadow    :"The color of the darker (generally outer) of the two borders away from the light source for 3-D elements that appear 3-D due to two concentric layers of surrounding border.",
    threedface          :"The face background color for 3-D elements that appear 3-D due to two concentric layers of surrounding border.",
    threedhighlight     :"The color of the lighter (generally outer) of the two borders facing the light source for 3-D elements that appear 3-D due to two concentric layers of surrounding border.",
    threedlightshadow   :"The color of the darker (generally inner) of the two borders facing the light source for 3-D elements that appear 3-D due to two concentric layers of surrounding border.",
    threedshadow        :"The color of the lighter (generally inner) of the two borders away from the light source for 3-D elements that appear 3-D due to two concentric layers of surrounding border.",
    window              :"Window background.",
    windowframe         :"Window frame.",
    windowtext          :"Text in windows."
};
/**
 * Represents a selector combinator (whitespace, +, >).
 * @namespace parserlib.css
 * @class Combinator
 * @extends parserlib.util.SyntaxUnit
 * @constructor
 * @param {String} text The text representation of the unit.
 * @param {int} line The line of text on which the unit resides.
 * @param {int} col The column of text on which the unit resides.
 */
function Combinator(text, line, col){

    SyntaxUnit.call(this, text, line, col, Parser.COMBINATOR_TYPE);

    /**
     * The type of modifier.
     * @type String
     * @property type
     */
    this.type = "unknown";

    //pretty simple
    if (/^\s+$/.test(text)){
        this.type = "descendant";
    } else if (text === ">"){
        this.type = "child";
    } else if (text === "+"){
        this.type = "adjacent-sibling";
    } else if (text === "~"){
        this.type = "sibling";
    }

}

Combinator.prototype = new SyntaxUnit();
Combinator.prototype.constructor = Combinator;

/**
 * Represents a media feature, such as max-width:500.
 * @namespace parserlib.css
 * @class MediaFeature
 * @extends parserlib.util.SyntaxUnit
 * @constructor
 * @param {SyntaxUnit} name The name of the feature.
 * @param {SyntaxUnit} value The value of the feature or null if none.
 */
function MediaFeature(name, value){

    SyntaxUnit.call(this, "(" + name + (value !== null ? ":" + value : "") + ")", name.startLine, name.startCol, Parser.MEDIA_FEATURE_TYPE);

    /**
     * The name of the media feature
     * @type String
     * @property name
     */
    this.name = name;

    /**
     * The value for the feature or null if there is none.
     * @type SyntaxUnit
     * @property value
     */
    this.value = value;
}

MediaFeature.prototype = new SyntaxUnit();
MediaFeature.prototype.constructor = MediaFeature;

/**
 * Represents an individual media query.
 * @namespace parserlib.css
 * @class MediaQuery
 * @extends parserlib.util.SyntaxUnit
 * @constructor
 * @param {String} modifier The modifier "not" or "only" (or null).
 * @param {String} mediaType The type of media (i.e., "print").
 * @param {Array} parts Array of selectors parts making up this selector.
 * @param {int} line The line of text on which the unit resides.
 * @param {int} col The column of text on which the unit resides.
 */
function MediaQuery(modifier, mediaType, features, line, col){

    SyntaxUnit.call(this, (modifier ? modifier + " ": "") + (mediaType ? mediaType : "") + (mediaType && features.length > 0 ? " and " : "") + features.join(" and "), line, col, Parser.MEDIA_QUERY_TYPE);

    /**
     * The media modifier ("not" or "only")
     * @type String
     * @property modifier
     */
    this.modifier = modifier;

    /**
     * The mediaType (i.e., "print")
     * @type String
     * @property mediaType
     */
    this.mediaType = mediaType;

    /**
     * The parts that make up the selector.
     * @type Array
     * @property features
     */
    this.features = features;

}

MediaQuery.prototype = new SyntaxUnit();
MediaQuery.prototype.constructor = MediaQuery;


/**
 * A CSS3 parser.
 * @namespace parserlib.css
 * @class Parser
 * @constructor
 * @param {Object} options (Optional) Various options for the parser:
 *      starHack (true|false) to allow IE6 star hack as valid,
 *      underscoreHack (true|false) to interpret leading underscores
 *      as IE6-7 targeting for known properties, ieFilters (true|false)
 *      to indicate that IE < 8 filters should be accepted and not throw
 *      syntax errors.
 */
function Parser(options){

    //inherit event functionality
    EventTarget.call(this);


    this.options = options || {};

    this._tokenStream = null;
}

//Static constants
Parser.DEFAULT_TYPE = 0;
Parser.COMBINATOR_TYPE = 1;
Parser.MEDIA_FEATURE_TYPE = 2;
Parser.MEDIA_QUERY_TYPE = 3;
Parser.PROPERTY_NAME_TYPE = 4;
Parser.PROPERTY_VALUE_TYPE = 5;
Parser.PROPERTY_VALUE_PART_TYPE = 6;
Parser.SELECTOR_TYPE = 7;
Parser.SELECTOR_PART_TYPE = 8;
Parser.SELECTOR_SUB_PART_TYPE = 9;

Parser.prototype = function(){

    var proto = new EventTarget(),  //new prototype
        prop,
        additions =  {
            __proto__: null,

            //restore constructor
            constructor: Parser,

            //instance constants - yuck
            DEFAULT_TYPE : 0,
            COMBINATOR_TYPE : 1,
            MEDIA_FEATURE_TYPE : 2,
            MEDIA_QUERY_TYPE : 3,
            PROPERTY_NAME_TYPE : 4,
            PROPERTY_VALUE_TYPE : 5,
            PROPERTY_VALUE_PART_TYPE : 6,
            SELECTOR_TYPE : 7,
            SELECTOR_PART_TYPE : 8,
            SELECTOR_SUB_PART_TYPE : 9,

            //-----------------------------------------------------------------
            // Grammar
            //-----------------------------------------------------------------

            _stylesheet: function(){

                /*
                 * stylesheet
                 *  : [ CHARSET_SYM S* STRING S* ';' ]?
                 *    [S|CDO|CDC]* [ import [S|CDO|CDC]* ]*
                 *    [ namespace [S|CDO|CDC]* ]*
                 *    [ [ ruleset | media | page | font_face | keyframes ] [S|CDO|CDC]* ]*
                 *  ;
                 */

                var tokenStream = this._tokenStream,
                    count,
                    token,
                    tt;

                this.fire("startstylesheet");

                //try to read character set
                this._charset();

                this._skipCruft();

                //try to read imports - may be more than one
                while (tokenStream.peek() === Tokens.IMPORT_SYM){
                    this._import();
                    this._skipCruft();
                }

                //try to read namespaces - may be more than one
                while (tokenStream.peek() === Tokens.NAMESPACE_SYM){
                    this._namespace();
                    this._skipCruft();
                }

                //get the next token
                tt = tokenStream.peek();

                //try to read the rest
                while(tt > Tokens.EOF){

                    try {

                        switch(tt){
                            case Tokens.MEDIA_SYM:
                                this._media();
                                this._skipCruft();
                                break;
                            case Tokens.PAGE_SYM:
                                this._page();
                                this._skipCruft();
                                break;
                            case Tokens.FONT_FACE_SYM:
                                this._font_face();
                                this._skipCruft();
                                break;
                            case Tokens.KEYFRAMES_SYM:
                                this._keyframes();
                                this._skipCruft();
                                break;
                            case Tokens.VIEWPORT_SYM:
                                this._viewport();
                                this._skipCruft();
                                break;
                            case Tokens.DOCUMENT_SYM:
                                this._document();
                                this._skipCruft();
                                break;
                            case Tokens.UNKNOWN_SYM:  //unknown @ rule
                                tokenStream.get();
                                if (!this.options.strict){

                                    //fire error event
                                    this.fire({
                                        type:       "error",
                                        error:      null,
                                        message:    "Unknown @ rule: " + tokenStream.LT(0).value + ".",
                                        line:       tokenStream.LT(0).startLine,
                                        col:        tokenStream.LT(0).startCol
                                    });

                                    //skip braces
                                    count=0;
                                    while (tokenStream.advance([Tokens.LBRACE, Tokens.RBRACE]) === Tokens.LBRACE){
                                        count++;    //keep track of nesting depth
                                    }

                                    while(count){
                                        tokenStream.advance([Tokens.RBRACE]);
                                        count--;
                                    }

                                } else {
                                    //not a syntax error, rethrow it
                                    throw new SyntaxError("Unknown @ rule.", tokenStream.LT(0).startLine, tokenStream.LT(0).startCol);
                                }
                                break;
                            case Tokens.S:
                                this._readWhitespace();
                                break;
                            default:
                                if(!this._ruleset()){

                                    //error handling for known issues
                                    switch(tt){
                                        case Tokens.CHARSET_SYM:
                                            token = tokenStream.LT(1);
                                            this._charset(false);
                                            throw new SyntaxError("@charset not allowed here.", token.startLine, token.startCol);
                                        case Tokens.IMPORT_SYM:
                                            token = tokenStream.LT(1);
                                            this._import(false);
                                            throw new SyntaxError("@import not allowed here.", token.startLine, token.startCol);
                                        case Tokens.NAMESPACE_SYM:
                                            token = tokenStream.LT(1);
                                            this._namespace(false);
                                            throw new SyntaxError("@namespace not allowed here.", token.startLine, token.startCol);
                                        default:
                                            tokenStream.get();  //get the last token
                                            this._unexpectedToken(tokenStream.token());
                                    }

                                }
                        }
                    } catch(ex) {
                        if (ex instanceof SyntaxError && !this.options.strict){
                            this.fire({
                                type:       "error",
                                error:      ex,
                                message:    ex.message,
                                line:       ex.line,
                                col:        ex.col
                            });
                        } else {
                            throw ex;
                        }
                    }

                    tt = tokenStream.peek();
                }

                if (tt !== Tokens.EOF){
                    this._unexpectedToken(tokenStream.token());
                }

                this.fire("endstylesheet");
            },

            _charset: function(emit){
                var tokenStream = this._tokenStream,
                    charset,
                    token,
                    line,
                    col;

                if (tokenStream.match(Tokens.CHARSET_SYM)){
                    line = tokenStream.token().startLine;
                    col = tokenStream.token().startCol;

                    this._readWhitespace();
                    tokenStream.mustMatch(Tokens.STRING);

                    token = tokenStream.token();
                    charset = token.value;

                    this._readWhitespace();
                    tokenStream.mustMatch(Tokens.SEMICOLON);

                    if (emit !== false){
                        this.fire({
                            type:   "charset",
                            charset:charset,
                            line:   line,
                            col:    col
                        });
                    }
                }
            },

            _import: function(emit){
                /*
                 * import
                 *   : IMPORT_SYM S*
                 *    [STRING|URI] S* media_query_list? ';' S*
                 */

                var tokenStream = this._tokenStream,
                    uri,
                    importToken,
                    mediaList   = [];

                //read import symbol
                tokenStream.mustMatch(Tokens.IMPORT_SYM);
                importToken = tokenStream.token();
                this._readWhitespace();

                tokenStream.mustMatch([Tokens.STRING, Tokens.URI]);

                //grab the URI value
                uri = tokenStream.token().value.replace(/^(?:url\()?["']?([^"']+?)["']?\)?$/, "$1");

                this._readWhitespace();

                mediaList = this._media_query_list();

                //must end with a semicolon
                tokenStream.mustMatch(Tokens.SEMICOLON);
                this._readWhitespace();

                if (emit !== false){
                    this.fire({
                        type:   "import",
                        uri:    uri,
                        media:  mediaList,
                        line:   importToken.startLine,
                        col:    importToken.startCol
                    });
                }

            },

            _namespace: function(emit){
                /*
                 * namespace
                 *   : NAMESPACE_SYM S* [namespace_prefix S*]? [STRING|URI] S* ';' S*
                 */

                var tokenStream = this._tokenStream,
                    line,
                    col,
                    prefix,
                    uri;

                //read import symbol
                tokenStream.mustMatch(Tokens.NAMESPACE_SYM);
                line = tokenStream.token().startLine;
                col = tokenStream.token().startCol;
                this._readWhitespace();

                //it's a namespace prefix - no _namespace_prefix() method because it's just an IDENT
                if (tokenStream.match(Tokens.IDENT)){
                    prefix = tokenStream.token().value;
                    this._readWhitespace();
                }

                tokenStream.mustMatch([Tokens.STRING, Tokens.URI]);
                /*if (!tokenStream.match(Tokens.STRING)){
                    tokenStream.mustMatch(Tokens.URI);
                }*/

                //grab the URI value
                uri = tokenStream.token().value.replace(/(?:url\()?["']([^"']+)["']\)?/, "$1");

                this._readWhitespace();

                //must end with a semicolon
                tokenStream.mustMatch(Tokens.SEMICOLON);
                this._readWhitespace();

                if (emit !== false){
                    this.fire({
                        type:   "namespace",
                        prefix: prefix,
                        uri:    uri,
                        line:   line,
                        col:    col
                    });
                }

            },

            _media: function(){
                /*
                 * media
                 *   : MEDIA_SYM S* media_query_list S* '{' S* ruleset* '}' S*
                 *   ;
                 */
                var tokenStream     = this._tokenStream,
                    line,
                    col,
                    mediaList;//       = [];

                //look for @media
                tokenStream.mustMatch(Tokens.MEDIA_SYM);
                line = tokenStream.token().startLine;
                col = tokenStream.token().startCol;

                this._readWhitespace();

                mediaList = this._media_query_list();

                tokenStream.mustMatch(Tokens.LBRACE);
                this._readWhitespace();

                this.fire({
                    type:   "startmedia",
                    media:  mediaList,
                    line:   line,
                    col:    col
                });

                while(true) {
                    if (tokenStream.peek() === Tokens.PAGE_SYM){
                        this._page();
                    } else if (tokenStream.peek() === Tokens.FONT_FACE_SYM){
                        this._font_face();
                    } else if (tokenStream.peek() === Tokens.VIEWPORT_SYM){
                        this._viewport();
                    } else if (tokenStream.peek() === Tokens.DOCUMENT_SYM){
                        this._document();
                    } else if (!this._ruleset()){
                        break;
                    }
                }

                tokenStream.mustMatch(Tokens.RBRACE);
                this._readWhitespace();

                this.fire({
                    type:   "endmedia",
                    media:  mediaList,
                    line:   line,
                    col:    col
                });
            },


            //CSS3 Media Queries
            _media_query_list: function(){
                /*
                 * media_query_list
                 *   : S* [media_query [ ',' S* media_query ]* ]?
                 *   ;
                 */
                var tokenStream = this._tokenStream,
                    mediaList   = [];


                this._readWhitespace();

                if (tokenStream.peek() === Tokens.IDENT || tokenStream.peek() === Tokens.LPAREN){
                    mediaList.push(this._media_query());
                }

                while(tokenStream.match(Tokens.COMMA)){
                    this._readWhitespace();
                    mediaList.push(this._media_query());
                }

                return mediaList;
            },

            /*
             * Note: "expression" in the grammar maps to the _media_expression
             * method.

             */
            _media_query: function(){
                /*
                 * media_query
                 *   : [ONLY | NOT]? S* media_type S* [ AND S* expression ]*
                 *   | expression [ AND S* expression ]*
                 *   ;
                 */
                var tokenStream = this._tokenStream,
                    type        = null,
                    ident       = null,
                    token       = null,
                    expressions = [];

                if (tokenStream.match(Tokens.IDENT)){
                    ident = tokenStream.token().value.toLowerCase();

                    //since there's no custom tokens for these, need to manually check
                    if (ident !== "only" && ident !== "not"){
                        tokenStream.unget();
                        ident = null;
                    } else {
                        token = tokenStream.token();
                    }
                }

                this._readWhitespace();

                if (tokenStream.peek() === Tokens.IDENT){
                    type = this._media_type();
                    if (token === null){
                        token = tokenStream.token();
                    }
                } else if (tokenStream.peek() === Tokens.LPAREN){
                    if (token === null){
                        token = tokenStream.LT(1);
                    }
                    expressions.push(this._media_expression());
                }

                if (type === null && expressions.length === 0){
                    return null;
                } else {
                    this._readWhitespace();
                    while (tokenStream.match(Tokens.IDENT)){
                        if (tokenStream.token().value.toLowerCase() !== "and"){
                            this._unexpectedToken(tokenStream.token());
                        }

                        this._readWhitespace();
                        expressions.push(this._media_expression());
                    }
                }

                return new MediaQuery(ident, type, expressions, token.startLine, token.startCol);
            },

            //CSS3 Media Queries
            _media_type: function(){
                /*
                 * media_type
                 *   : IDENT
                 *   ;
                 */
                return this._media_feature();
            },

            /**
             * Note: in CSS3 Media Queries, this is called "expression".
             * Renamed here to avoid conflict with CSS3 Selectors
             * definition of "expression". Also note that "expr" in the
             * grammar now maps to "expression" from CSS3 selectors.
             * @method _media_expression
             * @private
             */
            _media_expression: function(){
                /*
                 * expression
                 *  : '(' S* media_feature S* [ ':' S* expr ]? ')' S*
                 *  ;
                 */
                var tokenStream = this._tokenStream,
                    feature     = null,
                    token,
                    expression  = null;

                tokenStream.mustMatch(Tokens.LPAREN);

                feature = this._media_feature();
                this._readWhitespace();

                if (tokenStream.match(Tokens.COLON)){
                    this._readWhitespace();
                    token = tokenStream.LT(1);
                    expression = this._expression();
                }

                tokenStream.mustMatch(Tokens.RPAREN);
                this._readWhitespace();

                return new MediaFeature(feature, (expression ? new SyntaxUnit(expression, token.startLine, token.startCol) : null));
            },

            //CSS3 Media Queries
            _media_feature: function(){
                /*
                 * media_feature
                 *   : IDENT
                 *   ;
                 */
                var tokenStream = this._tokenStream;

                this._readWhitespace();

                tokenStream.mustMatch(Tokens.IDENT);

                return SyntaxUnit.fromToken(tokenStream.token());
            },

            //CSS3 Paged Media
            _page: function(){
                /*
                 * page:
                 *    PAGE_SYM S* IDENT? pseudo_page? S*
                 *    '{' S* [ declaration | margin ]? [ ';' S* [ declaration | margin ]? ]* '}' S*
                 *    ;
                 */
                var tokenStream = this._tokenStream,
                    line,
                    col,
                    identifier  = null,
                    pseudoPage  = null;

                //look for @page
                tokenStream.mustMatch(Tokens.PAGE_SYM);
                line = tokenStream.token().startLine;
                col = tokenStream.token().startCol;

                this._readWhitespace();

                if (tokenStream.match(Tokens.IDENT)){
                    identifier = tokenStream.token().value;

                    //The value 'auto' may not be used as a page name and MUST be treated as a syntax error.
                    if (identifier.toLowerCase() === "auto"){
                        this._unexpectedToken(tokenStream.token());
                    }
                }

                //see if there's a colon upcoming
                if (tokenStream.peek() === Tokens.COLON){
                    pseudoPage = this._pseudo_page();
                }

                this._readWhitespace();

                this.fire({
                    type:   "startpage",
                    id:     identifier,
                    pseudo: pseudoPage,
                    line:   line,
                    col:    col
                });

                this._readDeclarations(true, true);

                this.fire({
                    type:   "endpage",
                    id:     identifier,
                    pseudo: pseudoPage,
                    line:   line,
                    col:    col
                });

            },

            //CSS3 Paged Media
            _margin: function(){
                /*
                 * margin :
                 *    margin_sym S* '{' declaration [ ';' S* declaration? ]* '}' S*
                 *    ;
                 */
                var tokenStream = this._tokenStream,
                    line,
                    col,
                    marginSym   = this._margin_sym();

                if (marginSym){
                    line = tokenStream.token().startLine;
                    col = tokenStream.token().startCol;

                    this.fire({
                        type: "startpagemargin",
                        margin: marginSym,
                        line:   line,
                        col:    col
                    });

                    this._readDeclarations(true);

                    this.fire({
                        type: "endpagemargin",
                        margin: marginSym,
                        line:   line,
                        col:    col
                    });
                    return true;
                } else {
                    return false;
                }
            },

            //CSS3 Paged Media
            _margin_sym: function(){

                /*
                 * margin_sym :
                 *    TOPLEFTCORNER_SYM |
                 *    TOPLEFT_SYM |
                 *    TOPCENTER_SYM |
                 *    TOPRIGHT_SYM |
                 *    TOPRIGHTCORNER_SYM |
                 *    BOTTOMLEFTCORNER_SYM |
                 *    BOTTOMLEFT_SYM |
                 *    BOTTOMCENTER_SYM |
                 *    BOTTOMRIGHT_SYM |
                 *    BOTTOMRIGHTCORNER_SYM |
                 *    LEFTTOP_SYM |
                 *    LEFTMIDDLE_SYM |
                 *    LEFTBOTTOM_SYM |
                 *    RIGHTTOP_SYM |
                 *    RIGHTMIDDLE_SYM |
                 *    RIGHTBOTTOM_SYM
                 *    ;
                 */

                var tokenStream = this._tokenStream;

                if(tokenStream.match([Tokens.TOPLEFTCORNER_SYM, Tokens.TOPLEFT_SYM,
                        Tokens.TOPCENTER_SYM, Tokens.TOPRIGHT_SYM, Tokens.TOPRIGHTCORNER_SYM,
                        Tokens.BOTTOMLEFTCORNER_SYM, Tokens.BOTTOMLEFT_SYM,
                        Tokens.BOTTOMCENTER_SYM, Tokens.BOTTOMRIGHT_SYM,
                        Tokens.BOTTOMRIGHTCORNER_SYM, Tokens.LEFTTOP_SYM,
                        Tokens.LEFTMIDDLE_SYM, Tokens.LEFTBOTTOM_SYM, Tokens.RIGHTTOP_SYM,
                        Tokens.RIGHTMIDDLE_SYM, Tokens.RIGHTBOTTOM_SYM]))
                {
                    return SyntaxUnit.fromToken(tokenStream.token());
                } else {
                    return null;
                }

            },

            _pseudo_page: function(){
                /*
                 * pseudo_page
                 *   : ':' IDENT
                 *   ;
                 */

                var tokenStream = this._tokenStream;

                tokenStream.mustMatch(Tokens.COLON);
                tokenStream.mustMatch(Tokens.IDENT);

                //TODO: CSS3 Paged Media says only "left", "center", and "right" are allowed

                return tokenStream.token().value;
            },

            _font_face: function(){
                /*
                 * font_face
                 *   : FONT_FACE_SYM S*
                 *     '{' S* declaration [ ';' S* declaration ]* '}' S*
                 *   ;
                 */
                var tokenStream = this._tokenStream,
                    line,
                    col;

                //look for @page
                tokenStream.mustMatch(Tokens.FONT_FACE_SYM);
                line = tokenStream.token().startLine;
                col = tokenStream.token().startCol;

                this._readWhitespace();

                this.fire({
                    type:   "startfontface",
                    line:   line,
                    col:    col
                });

                this._readDeclarations(true);

                this.fire({
                    type:   "endfontface",
                    line:   line,
                    col:    col
                });
            },

            _viewport: function(){
                /*
                 * viewport
                 *   : VIEWPORT_SYM S*
                 *     '{' S* declaration? [ ';' S* declaration? ]* '}' S*
                 *   ;
                 */
                 var tokenStream = this._tokenStream,
                    line,
                    col;

                    tokenStream.mustMatch(Tokens.VIEWPORT_SYM);
                    line = tokenStream.token().startLine;
                    col = tokenStream.token().startCol;

                    this._readWhitespace();

                    this.fire({
                        type:   "startviewport",
                        line:   line,
                        col:    col
                    });

                    this._readDeclarations(true);

                    this.fire({
                        type:   "endviewport",
                        line:   line,
                        col:    col
                    });

            },

            _document: function(){
                /*
                 * document
                 *   : DOCUMENT_SYM S*
                 *     _document_function [ ',' S* _document_function ]* S*
                 *     '{' S* ruleset* '}'
                 *   ;
                 */

                var tokenStream = this._tokenStream,
                    token,
                    functions = [],
                    prefix = "";

                tokenStream.mustMatch(Tokens.DOCUMENT_SYM);
                token = tokenStream.token();
                if (/^@\-([^\-]+)\-/.test(token.value)) {
                    prefix = RegExp.$1;
                }

                this._readWhitespace();
                functions.push(this._document_function());

                while(tokenStream.match(Tokens.COMMA)) {
                    this._readWhitespace();
                    functions.push(this._document_function());
                }

                tokenStream.mustMatch(Tokens.LBRACE);
                this._readWhitespace();

                this.fire({
                    type:      "startdocument",
                    functions: functions,
                    prefix:    prefix,
                    line:      token.startLine,
                    col:       token.startCol
                });

                while(true) {
                    if (tokenStream.peek() === Tokens.PAGE_SYM){
                        this._page();
                    } else if (tokenStream.peek() === Tokens.FONT_FACE_SYM){
                        this._font_face();
                    } else if (tokenStream.peek() === Tokens.VIEWPORT_SYM){
                        this._viewport();
                    } else if (tokenStream.peek() === Tokens.MEDIA_SYM){
                        this._media();
                    } else if (!this._ruleset()){
                        break;
                    }
                }

                tokenStream.mustMatch(Tokens.RBRACE);
                this._readWhitespace();

                this.fire({
                    type:      "enddocument",
                    functions: functions,
                    prefix:    prefix,
                    line:      token.startLine,
                    col:       token.startCol
                });
            },

            _document_function: function(){
                /*
                 * document_function
                 *   : function | URI S*
                 *   ;
                 */

                var tokenStream = this._tokenStream,
                    value;

                if (tokenStream.match(Tokens.URI)) {
                    value = tokenStream.token().value;
                    this._readWhitespace();
                } else {
                    value = this._function();
                }

                return value;
            },

            _operator: function(inFunction){

                /*
                 * operator (outside function)
                 *  : '/' S* | ',' S* | /( empty )/
                 * operator (inside function)
                 *  : '/' S* | '+' S* | '*' S* | '-' S* /( empty )/
                 *  ;
                 */

                var tokenStream = this._tokenStream,
                    token       = null;

                if (tokenStream.match([Tokens.SLASH, Tokens.COMMA]) ||
                    (inFunction && tokenStream.match([Tokens.PLUS, Tokens.STAR, Tokens.MINUS]))){
                    token =  tokenStream.token();
                    this._readWhitespace();
                }
                return token ? PropertyValuePart.fromToken(token) : null;

            },

            _combinator: function(){

                /*
                 * combinator
                 *  : PLUS S* | GREATER S* | TILDE S* | S+
                 *  ;
                 */

                var tokenStream = this._tokenStream,
                    value       = null,
                    token;

                if(tokenStream.match([Tokens.PLUS, Tokens.GREATER, Tokens.TILDE])){
                    token = tokenStream.token();
                    value = new Combinator(token.value, token.startLine, token.startCol);
                    this._readWhitespace();
                }

                return value;
            },

            _unary_operator: function(){

                /*
                 * unary_operator
                 *  : '-' | '+'
                 *  ;
                 */

                var tokenStream = this._tokenStream;

                if (tokenStream.match([Tokens.MINUS, Tokens.PLUS])){
                    return tokenStream.token().value;
                } else {
                    return null;
                }
            },

            _property: function(){

                /*
                 * property
                 *   : IDENT S*
                 *   ;
                 */

                var tokenStream = this._tokenStream,
                    value       = null,
                    hack        = null,
                    tokenValue,
                    token,
                    line,
                    col;

                //check for star hack - throws error if not allowed
                if (tokenStream.peek() === Tokens.STAR && this.options.starHack){
                    tokenStream.get();
                    token = tokenStream.token();
                    hack = token.value;
                    line = token.startLine;
                    col = token.startCol;
                }

                if(tokenStream.match(Tokens.IDENT)){
                    token = tokenStream.token();
                    tokenValue = token.value;

                    //check for underscore hack - no error if not allowed because it's valid CSS syntax
                    if (tokenValue.charAt(0) === "_" && this.options.underscoreHack){
                        hack = "_";
                        tokenValue = tokenValue.substring(1);
                    }

                    value = new PropertyName(tokenValue, hack, (line||token.startLine), (col||token.startCol));
                    this._readWhitespace();
                }

                return value;
            },

            //Augmented with CSS3 Selectors
            _ruleset: function(){
                /*
                 * ruleset
                 *   : selectors_group
                 *     '{' S* declaration? [ ';' S* declaration? ]* '}' S*
                 *   ;
                 */

                var tokenStream = this._tokenStream,
                    tt,
                    selectors;


                /*
                 * Error Recovery: If even a single selector fails to parse,
                 * then the entire ruleset should be thrown away.
                 */
                try {
                    selectors = this._selectors_group();
                } catch (ex){
                    if (ex instanceof SyntaxError && !this.options.strict){

                        //fire error event
                        this.fire({
                            type:       "error",
                            error:      ex,
                            message:    ex.message,
                            line:       ex.line,
                            col:        ex.col
                        });

                        //skip over everything until closing brace
                        tt = tokenStream.advance([Tokens.RBRACE]);
                        if (tt === Tokens.RBRACE){
                            //if there's a right brace, the rule is finished so don't do anything
                        } else {
                            //otherwise, rethrow the error because it wasn't handled properly
                            throw ex;
                        }

                    } else {
                        //not a syntax error, rethrow it
                        throw ex;
                    }

                    //trigger parser to continue
                    return true;
                }

                //if it got here, all selectors parsed
                if (selectors){

                    this.fire({
                        type:       "startrule",
                        selectors:  selectors,
                        line:       selectors[0].line,
                        col:        selectors[0].col
                    });

                    this._readDeclarations(true);

                    this.fire({
                        type:       "endrule",
                        selectors:  selectors,
                        line:       selectors[0].line,
                        col:        selectors[0].col
                    });

                }

                return selectors;

            },

            //CSS3 Selectors
            _selectors_group: function(){

                /*
                 * selectors_group
                 *   : selector [ COMMA S* selector ]*
                 *   ;
                 */
                var tokenStream = this._tokenStream,
                    selectors   = [],
                    selector;

                selector = this._selector();
                if (selector !== null){

                    selectors.push(selector);
                    while(tokenStream.match(Tokens.COMMA)){
                        this._readWhitespace();
                        selector = this._selector();
                        if (selector !== null){
                            selectors.push(selector);
                        } else {
                            this._unexpectedToken(tokenStream.LT(1));
                        }
                    }
                }

                return selectors.length ? selectors : null;
            },

            //CSS3 Selectors
            _selector: function(){
                /*
                 * selector
                 *   : simple_selector_sequence [ combinator simple_selector_sequence ]*
                 *   ;
                 */

                var tokenStream = this._tokenStream,
                    selector    = [],
                    nextSelector = null,
                    combinator  = null,
                    ws          = null;

                //if there's no simple selector, then there's no selector
                nextSelector = this._simple_selector_sequence();
                if (nextSelector === null){
                    return null;
                }

                selector.push(nextSelector);

                do {

                    //look for a combinator
                    combinator = this._combinator();

                    if (combinator !== null){
                        selector.push(combinator);
                        nextSelector = this._simple_selector_sequence();

                        //there must be a next selector
                        if (nextSelector === null){
                            this._unexpectedToken(tokenStream.LT(1));
                        } else {

                            //nextSelector is an instance of SelectorPart
                            selector.push(nextSelector);
                        }
                    } else {

                        //if there's not whitespace, we're done
                        if (this._readWhitespace()){

                            //add whitespace separator
                            ws = new Combinator(tokenStream.token().value, tokenStream.token().startLine, tokenStream.token().startCol);

                            //combinator is not required
                            combinator = this._combinator();

                            //selector is required if there's a combinator
                            nextSelector = this._simple_selector_sequence();
                            if (nextSelector === null){
                                if (combinator !== null){
                                    this._unexpectedToken(tokenStream.LT(1));
                                }
                            } else {

                                if (combinator !== null){
                                    selector.push(combinator);
                                } else {
                                    selector.push(ws);
                                }

                                selector.push(nextSelector);
                            }
                        } else {
                            break;
                        }

                    }
                } while(true);

                return new Selector(selector, selector[0].line, selector[0].col);
            },

            //CSS3 Selectors
            _simple_selector_sequence: function(){
                /*
                 * simple_selector_sequence
                 *   : [ type_selector | universal ]
                 *     [ HASH | class | attrib | pseudo | negation ]*
                 *   | [ HASH | class | attrib | pseudo | negation ]+
                 *   ;
                 */

                var tokenStream = this._tokenStream,

                    //parts of a simple selector
                    elementName = null,
                    modifiers   = [],

                    //complete selector text
                    selectorText= "",

                    //the different parts after the element name to search for
                    components  = [
                        //HASH
                        function(){
                            return tokenStream.match(Tokens.HASH) ?
                                    new SelectorSubPart(tokenStream.token().value, "id", tokenStream.token().startLine, tokenStream.token().startCol) :
                                    null;
                        },
                        this._class,
                        this._attrib,
                        this._pseudo,
                        this._negation
                    ],
                    i           = 0,
                    len         = components.length,
                    component   = null,
                    line,
                    col;


                //get starting line and column for the selector
                line = tokenStream.LT(1).startLine;
                col = tokenStream.LT(1).startCol;

                elementName = this._type_selector();
                if (!elementName){
                    elementName = this._universal();
                }

                if (elementName !== null){
                    selectorText += elementName;
                }

                while(true){

                    //whitespace means we're done
                    if (tokenStream.peek() === Tokens.S){
                        break;
                    }

                    //check for each component
                    while(i < len && component === null){
                        component = components[i++].call(this);
                    }

                    if (component === null){

                        //we don't have a selector
                        if (selectorText === ""){
                            return null;
                        } else {
                            break;
                        }
                    } else {
                        i = 0;
                        modifiers.push(component);
                        selectorText += component.toString();
                        component = null;
                    }
                }


                return selectorText !== "" ?
                        new SelectorPart(elementName, modifiers, selectorText, line, col) :
                        null;
            },

            //CSS3 Selectors
            _type_selector: function(){
                /*
                 * type_selector
                 *   : [ namespace_prefix ]? element_name
                 *   ;
                 */

                var tokenStream = this._tokenStream,
                    ns          = this._namespace_prefix(),
                    elementName = this._element_name();

                if (!elementName){
                    /*
                     * Need to back out the namespace that was read due to both
                     * type_selector and universal reading namespace_prefix
                     * first. Kind of hacky, but only way I can figure out
                     * right now how to not change the grammar.
                     */
                    if (ns){
                        tokenStream.unget();
                        if (ns.length > 1){
                            tokenStream.unget();
                        }
                    }

                    return null;
                } else {
                    if (ns){
                        elementName.text = ns + elementName.text;
                        elementName.col -= ns.length;
                    }
                    return elementName;
                }
            },

            //CSS3 Selectors
            _class: function(){
                /*
                 * class
                 *   : '.' IDENT
                 *   ;
                 */

                var tokenStream = this._tokenStream,
                    token;

                if (tokenStream.match(Tokens.DOT)){
                    tokenStream.mustMatch(Tokens.IDENT);
                    token = tokenStream.token();
                    return new SelectorSubPart("." + token.value, "class", token.startLine, token.startCol - 1);
                } else {
                    return null;
                }

            },

            //CSS3 Selectors
            _element_name: function(){
                /*
                 * element_name
                 *   : IDENT
                 *   ;
                 */

                var tokenStream = this._tokenStream,
                    token;

                if (tokenStream.match(Tokens.IDENT)){
                    token = tokenStream.token();
                    return new SelectorSubPart(token.value, "elementName", token.startLine, token.startCol);

                } else {
                    return null;
                }
            },

            //CSS3 Selectors
            _namespace_prefix: function(){
                /*
                 * namespace_prefix
                 *   : [ IDENT | '*' ]? '|'
                 *   ;
                 */
                var tokenStream = this._tokenStream,
                    value       = "";

                //verify that this is a namespace prefix
                if (tokenStream.LA(1) === Tokens.PIPE || tokenStream.LA(2) === Tokens.PIPE){

                    if(tokenStream.match([Tokens.IDENT, Tokens.STAR])){
                        value += tokenStream.token().value;
                    }

                    tokenStream.mustMatch(Tokens.PIPE);
                    value += "|";

                }

                return value.length ? value : null;
            },

            //CSS3 Selectors
            _universal: function(){
                /*
                 * universal
                 *   : [ namespace_prefix ]? '*'
                 *   ;
                 */
                var tokenStream = this._tokenStream,
                    value       = "",
                    ns;

                ns = this._namespace_prefix();
                if(ns){
                    value += ns;
                }

                if(tokenStream.match(Tokens.STAR)){
                    value += "*";
                }

                return value.length ? value : null;

           },

            //CSS3 Selectors
            _attrib: function(){
                /*
                 * attrib
                 *   : '[' S* [ namespace_prefix ]? IDENT S*
                 *         [ [ PREFIXMATCH |
                 *             SUFFIXMATCH |
                 *             SUBSTRINGMATCH |
                 *             '=' |
                 *             INCLUDES |
                 *             DASHMATCH ] S* [ IDENT | STRING ] S*
                 *         ]? ']'
                 *   ;
                 */

                var tokenStream = this._tokenStream,
                    value       = null,
                    ns,
                    token;

                if (tokenStream.match(Tokens.LBRACKET)){
                    token = tokenStream.token();
                    value = token.value;
                    value += this._readWhitespace();

                    ns = this._namespace_prefix();

                    if (ns){
                        value += ns;
                    }

                    tokenStream.mustMatch(Tokens.IDENT);
                    value += tokenStream.token().value;
                    value += this._readWhitespace();

                    if(tokenStream.match([Tokens.PREFIXMATCH, Tokens.SUFFIXMATCH, Tokens.SUBSTRINGMATCH,
                            Tokens.EQUALS, Tokens.INCLUDES, Tokens.DASHMATCH])){

                        value += tokenStream.token().value;
                        value += this._readWhitespace();

                        tokenStream.mustMatch([Tokens.IDENT, Tokens.STRING]);
                        value += tokenStream.token().value;
                        value += this._readWhitespace();
                    }

                    tokenStream.mustMatch(Tokens.RBRACKET);

                    return new SelectorSubPart(value + "]", "attribute", token.startLine, token.startCol);
                } else {
                    return null;
                }
            },

            //CSS3 Selectors
            _pseudo: function(){

                /*
                 * pseudo
                 *   : ':' ':'? [ IDENT | functional_pseudo ]
                 *   ;
                 */

                var tokenStream = this._tokenStream,
                    pseudo      = null,
                    colons      = ":",
                    line,
                    col;

                if (tokenStream.match(Tokens.COLON)){

                    if (tokenStream.match(Tokens.COLON)){
                        colons += ":";
                    }

                    if (tokenStream.match(Tokens.IDENT)){
                        pseudo = tokenStream.token().value;
                        line = tokenStream.token().startLine;
                        col = tokenStream.token().startCol - colons.length;
                    } else if (tokenStream.peek() === Tokens.FUNCTION){
                        line = tokenStream.LT(1).startLine;
                        col = tokenStream.LT(1).startCol - colons.length;
                        pseudo = this._functional_pseudo();
                    }

                    if (pseudo){
                        pseudo = new SelectorSubPart(colons + pseudo, "pseudo", line, col);
                    }
                }

                return pseudo;
            },

            //CSS3 Selectors
            _functional_pseudo: function(){
                /*
                 * functional_pseudo
                 *   : FUNCTION S* expression ')'
                 *   ;
                */

                var tokenStream = this._tokenStream,
                    value = null;

                if(tokenStream.match(Tokens.FUNCTION)){
                    value = tokenStream.token().value;
                    value += this._readWhitespace();
                    value += this._expression();
                    tokenStream.mustMatch(Tokens.RPAREN);
                    value += ")";
                }

                return value;
            },

            //CSS3 Selectors
            _expression: function(){
                /*
                 * expression
                 *   : [ [ PLUS | '-' | DIMENSION | NUMBER | STRING | IDENT ] S* ]+
                 *   ;
                 */

                var tokenStream = this._tokenStream,
                    value       = "";

                while(tokenStream.match([Tokens.PLUS, Tokens.MINUS, Tokens.DIMENSION,
                        Tokens.NUMBER, Tokens.STRING, Tokens.IDENT, Tokens.LENGTH,
                        Tokens.FREQ, Tokens.ANGLE, Tokens.TIME,
                        Tokens.RESOLUTION, Tokens.SLASH])){

                    value += tokenStream.token().value;
                    value += this._readWhitespace();
                }

                return value.length ? value : null;

            },

            //CSS3 Selectors
            _negation: function(){
                /*
                 * negation
                 *   : NOT S* negation_arg S* ')'
                 *   ;
                 */

                var tokenStream = this._tokenStream,
                    line,
                    col,
                    value       = "",
                    arg,
                    subpart     = null;

                if (tokenStream.match(Tokens.NOT)){
                    value = tokenStream.token().value;
                    line = tokenStream.token().startLine;
                    col = tokenStream.token().startCol;
                    value += this._readWhitespace();
                    arg = this._negation_arg();
                    value += arg;
                    value += this._readWhitespace();
                    tokenStream.match(Tokens.RPAREN);
                    value += tokenStream.token().value;

                    subpart = new SelectorSubPart(value, "not", line, col);
                    subpart.args.push(arg);
                }

                return subpart;
            },

            //CSS3 Selectors
            _negation_arg: function(){
                /*
                 * negation_arg
                 *   : type_selector | universal | HASH | class | attrib | pseudo
                 *   ;
                 */

                var tokenStream = this._tokenStream,
                    args        = [
                        this._type_selector,
                        this._universal,
                        function(){
                            return tokenStream.match(Tokens.HASH) ?
                                    new SelectorSubPart(tokenStream.token().value, "id", tokenStream.token().startLine, tokenStream.token().startCol) :
                                    null;
                        },
                        this._class,
                        this._attrib,
                        this._pseudo
                    ],
                    arg         = null,
                    i           = 0,
                    len         = args.length,
                    line,
                    col,
                    part;

                line = tokenStream.LT(1).startLine;
                col = tokenStream.LT(1).startCol;

                while(i < len && arg === null){

                    arg = args[i].call(this);
                    i++;
                }

                //must be a negation arg
                if (arg === null){
                    this._unexpectedToken(tokenStream.LT(1));
                }

                //it's an element name
                if (arg.type === "elementName"){
                    part = new SelectorPart(arg, [], arg.toString(), line, col);
                } else {
                    part = new SelectorPart(null, [arg], arg.toString(), line, col);
                }

                return part;
            },

            _declaration: function(){

                /*
                 * declaration
                 *   : property ':' S* expr prio?
                 *   | /( empty )/
                 *   ;
                 */

                var tokenStream = this._tokenStream,
                    property    = null,
                    expr        = null,
                    prio        = null,
                    invalid     = null,
                    propertyName= "";

                property = this._property();
                if (property !== null){

                    tokenStream.mustMatch(Tokens.COLON);
                    this._readWhitespace();

                    expr = this._expr();

                    //if there's no parts for the value, it's an error
                    if (!expr || expr.length === 0){
                        this._unexpectedToken(tokenStream.LT(1));
                    }

                    prio = this._prio();

                    /*
                     * If hacks should be allowed, then only check the root
                     * property. If hacks should not be allowed, treat
                     * _property or *property as invalid properties.
                     */
                    propertyName = property.toString();
                    if (this.options.starHack && property.hack === "*" ||
                            this.options.underscoreHack && property.hack === "_") {

                        propertyName = property.text;
                    }

                    try {
                        this._validateProperty(propertyName, expr);
                    } catch (ex) {
                        invalid = ex;
                    }

                    this.fire({
                        type:       "property",
                        property:   property,
                        value:      expr,
                        important:  prio,
                        line:       property.line,
                        col:        property.col,
                        invalid:    invalid
                    });

                    return true;
                } else {
                    return false;
                }
            },

            _prio: function(){
                /*
                 * prio
                 *   : IMPORTANT_SYM S*
                 *   ;
                 */

                var tokenStream = this._tokenStream,
                    result      = tokenStream.match(Tokens.IMPORTANT_SYM);

                this._readWhitespace();
                return result;
            },

            _expr: function(inFunction){
                /*
                 * expr
                 *   : term [ operator term ]*
                 *   ;
                 */

                var values      = [],
					//valueParts	= [],
                    value       = null,
                    operator    = null;

                value = this._term(inFunction);
                if (value !== null){

                    values.push(value);

                    do {
                        operator = this._operator(inFunction);

                        //if there's an operator, keep building up the value parts
                        if (operator){
                            values.push(operator);
                        } /*else {
                            //if there's not an operator, you have a full value
							values.push(new PropertyValue(valueParts, valueParts[0].line, valueParts[0].col));
							valueParts = [];
						}*/

                        value = this._term(inFunction);

                        if (value === null){
                            break;
                        } else {
                            values.push(value);
                        }
                    } while(true);
                }

				//cleanup
                /*if (valueParts.length){
                    values.push(new PropertyValue(valueParts, valueParts[0].line, valueParts[0].col));
                }*/

                return values.length > 0 ? new PropertyValue(values, values[0].line, values[0].col) : null;
            },

            _term: function(inFunction){

                /*
                 * term
                 *   : unary_operator?
                 *     [ NUMBER S* | PERCENTAGE S* | LENGTH S* | ANGLE S* |
                 *       TIME S* | FREQ S* | function | ie_function ]
                 *   | STRING S* | IDENT S* | URI S* | UNICODERANGE S* | hexcolor
                 *   ;
                 */

                var tokenStream = this._tokenStream,
                    unary       = null,
                    value       = null,
                    endChar     = null,
                    token,
                    line,
                    col;

                //returns the operator or null
                unary = this._unary_operator();
                if (unary !== null){
                    line = tokenStream.token().startLine;
                    col = tokenStream.token().startCol;
                }

                //exception for IE filters
                if (tokenStream.peek() === Tokens.IE_FUNCTION && this.options.ieFilters){

                    value = this._ie_function();
                    if (unary === null){
                        line = tokenStream.token().startLine;
                        col = tokenStream.token().startCol;
                    }

                //see if it's a simple block
                } else if (inFunction && tokenStream.match([Tokens.LPAREN, Tokens.LBRACE, Tokens.LBRACKET])){

                    token = tokenStream.token();
                    endChar = token.endChar;
                    value = token.value + this._expr(inFunction).text;
                    if (unary === null){
                        line = tokenStream.token().startLine;
                        col = tokenStream.token().startCol;
                    }
                    tokenStream.mustMatch(Tokens.type(endChar));
                    value += endChar;
                    this._readWhitespace();

                //see if there's a simple match
                } else if (tokenStream.match([Tokens.NUMBER, Tokens.PERCENTAGE, Tokens.LENGTH,
                        Tokens.ANGLE, Tokens.TIME,
                        Tokens.FREQ, Tokens.STRING, Tokens.IDENT, Tokens.URI, Tokens.UNICODE_RANGE])){

                    value = tokenStream.token().value;
                    if (unary === null){
                        line = tokenStream.token().startLine;
                        col = tokenStream.token().startCol;
                    }
                    this._readWhitespace();
                } else {

                    //see if it's a color
                    token = this._hexcolor();
                    if (token === null){

                        //if there's no unary, get the start of the next token for line/col info
                        if (unary === null){
                            line = tokenStream.LT(1).startLine;
                            col = tokenStream.LT(1).startCol;
                        }

                        //has to be a function
                        if (value === null){

                            /*
                             * This checks for alpha(opacity=0) style of IE
                             * functions. IE_FUNCTION only presents progid: style.
                             */
                            if (tokenStream.LA(3) === Tokens.EQUALS && this.options.ieFilters){
                                value = this._ie_function();
                            } else {
                                value = this._function();
                            }
                        }

                        /*if (value === null){
                            return null;
                            //throw new Error("Expected identifier at line " + tokenStream.token().startLine + ", character " +  tokenStream.token().startCol + ".");
                        }*/

                    } else {
                        value = token.value;
                        if (unary === null){
                            line = token.startLine;
                            col = token.startCol;
                        }
                    }

                }

                return value !== null ?
                        new PropertyValuePart(unary !== null ? unary + value : value, line, col) :
                        null;

            },

            _function: function(){

                /*
                 * function
                 *   : FUNCTION S* expr ')' S*
                 *   ;
                 */

                var tokenStream = this._tokenStream,
                    functionText = null,
                    expr        = null,
                    lt;

                if (tokenStream.match(Tokens.FUNCTION)){
                    functionText = tokenStream.token().value;
                    this._readWhitespace();
                    expr = this._expr(true);
                    functionText += expr;

                    //START: Horrible hack in case it's an IE filter
                    if (this.options.ieFilters && tokenStream.peek() === Tokens.EQUALS){
                        do {

                            if (this._readWhitespace()){
                                functionText += tokenStream.token().value;
                            }

                            //might be second time in the loop
                            if (tokenStream.LA(0) === Tokens.COMMA){
                                functionText += tokenStream.token().value;
                            }

                            tokenStream.match(Tokens.IDENT);
                            functionText += tokenStream.token().value;

                            tokenStream.match(Tokens.EQUALS);
                            functionText += tokenStream.token().value;

                            //functionText += this._term();
                            lt = tokenStream.peek();
                            while(lt !== Tokens.COMMA && lt !== Tokens.S && lt !== Tokens.RPAREN){
                                tokenStream.get();
                                functionText += tokenStream.token().value;
                                lt = tokenStream.peek();
                            }
                        } while(tokenStream.match([Tokens.COMMA, Tokens.S]));
                    }

                    //END: Horrible Hack

                    tokenStream.match(Tokens.RPAREN);
                    functionText += ")";
                    this._readWhitespace();
                }

                return functionText;
            },

            _ie_function: function(){

                /* (My own extension)
                 * ie_function
                 *   : IE_FUNCTION S* IDENT '=' term [S* ','? IDENT '=' term]+ ')' S*
                 *   ;
                 */

                var tokenStream = this._tokenStream,
                    functionText = null,
                    lt;

                //IE function can begin like a regular function, too
                if (tokenStream.match([Tokens.IE_FUNCTION, Tokens.FUNCTION])){
                    functionText = tokenStream.token().value;

                    do {

                        if (this._readWhitespace()){
                            functionText += tokenStream.token().value;
                        }

                        //might be second time in the loop
                        if (tokenStream.LA(0) === Tokens.COMMA){
                            functionText += tokenStream.token().value;
                        }

                        tokenStream.match(Tokens.IDENT);
                        functionText += tokenStream.token().value;

                        tokenStream.match(Tokens.EQUALS);
                        functionText += tokenStream.token().value;

                        //functionText += this._term();
                        lt = tokenStream.peek();
                        while(lt !== Tokens.COMMA && lt !== Tokens.S && lt !== Tokens.RPAREN){
                            tokenStream.get();
                            functionText += tokenStream.token().value;
                            lt = tokenStream.peek();
                        }
                    } while(tokenStream.match([Tokens.COMMA, Tokens.S]));

                    tokenStream.match(Tokens.RPAREN);
                    functionText += ")";
                    this._readWhitespace();
                }

                return functionText;
            },

            _hexcolor: function(){
                /*
                 * There is a constraint on the color that it must
                 * have either 3 or 6 hex-digits (i.e., [0-9a-fA-F])
                 * after the "#"; e.g., "#000" is OK, but "#abcd" is not.
                 *
                 * hexcolor
                 *   : HASH S*
                 *   ;
                 */

                var tokenStream = this._tokenStream,
                    token = null,
                    color;

                if(tokenStream.match(Tokens.HASH)){

                    //need to do some validation here

                    token = tokenStream.token();
                    color = token.value;
                    if (!/#[a-f0-9]{3,6}/i.test(color)){
                        throw new SyntaxError("Expected a hex color but found '" + color + "' at line " + token.startLine + ", col " + token.startCol + ".", token.startLine, token.startCol);
                    }
                    this._readWhitespace();
                }

                return token;
            },

            //-----------------------------------------------------------------
            // Animations methods
            //-----------------------------------------------------------------

            _keyframes: function(){

                /*
                 * keyframes:
                 *   : KEYFRAMES_SYM S* keyframe_name S* '{' S* keyframe_rule* '}' {
                 *   ;
                 */
                var tokenStream = this._tokenStream,
                    token,
                    tt,
                    name,
                    prefix = "";

                tokenStream.mustMatch(Tokens.KEYFRAMES_SYM);
                token = tokenStream.token();
                if (/^@\-([^\-]+)\-/.test(token.value)) {
                    prefix = RegExp.$1;
                }

                this._readWhitespace();
                name = this._keyframe_name();

                this._readWhitespace();
                tokenStream.mustMatch(Tokens.LBRACE);

                this.fire({
                    type:   "startkeyframes",
                    name:   name,
                    prefix: prefix,
                    line:   token.startLine,
                    col:    token.startCol
                });

                this._readWhitespace();
                tt = tokenStream.peek();

                //check for key
                while(tt === Tokens.IDENT || tt === Tokens.PERCENTAGE) {
                    this._keyframe_rule();
                    this._readWhitespace();
                    tt = tokenStream.peek();
                }

                this.fire({
                    type:   "endkeyframes",
                    name:   name,
                    prefix: prefix,
                    line:   token.startLine,
                    col:    token.startCol
                });

                this._readWhitespace();
                tokenStream.mustMatch(Tokens.RBRACE);

            },

            _keyframe_name: function(){

                /*
                 * keyframe_name:
                 *   : IDENT
                 *   | STRING
                 *   ;
                 */
                var tokenStream = this._tokenStream;

                tokenStream.mustMatch([Tokens.IDENT, Tokens.STRING]);
                return SyntaxUnit.fromToken(tokenStream.token());
            },

            _keyframe_rule: function(){

                /*
                 * keyframe_rule:
                 *   : key_list S*
                 *     '{' S* declaration [ ';' S* declaration ]* '}' S*
                 *   ;
                 */
                var keyList = this._key_list();

                this.fire({
                    type:   "startkeyframerule",
                    keys:   keyList,
                    line:   keyList[0].line,
                    col:    keyList[0].col
                });

                this._readDeclarations(true);

                this.fire({
                    type:   "endkeyframerule",
                    keys:   keyList,
                    line:   keyList[0].line,
                    col:    keyList[0].col
                });

            },

            _key_list: function(){

                /*
                 * key_list:
                 *   : key [ S* ',' S* key]*
                 *   ;
                 */
                var tokenStream = this._tokenStream,
                    keyList = [];

                //must be least one key
                keyList.push(this._key());

                this._readWhitespace();

                while(tokenStream.match(Tokens.COMMA)){
                    this._readWhitespace();
                    keyList.push(this._key());
                    this._readWhitespace();
                }

                return keyList;
            },

            _key: function(){
                /*
                 * There is a restriction that IDENT can be only "from" or "to".
                 *
                 * key
                 *   : PERCENTAGE
                 *   | IDENT
                 *   ;
                 */

                var tokenStream = this._tokenStream,
                    token;

                if (tokenStream.match(Tokens.PERCENTAGE)){
                    return SyntaxUnit.fromToken(tokenStream.token());
                } else if (tokenStream.match(Tokens.IDENT)){
                    token = tokenStream.token();

                    if (/from|to/i.test(token.value)){
                        return SyntaxUnit.fromToken(token);
                    }

                    tokenStream.unget();
                }

                //if it gets here, there wasn't a valid token, so time to explode
                this._unexpectedToken(tokenStream.LT(1));
            },

            //-----------------------------------------------------------------
            // Helper methods
            //-----------------------------------------------------------------

            /**
             * Not part of CSS grammar, but useful for skipping over
             * combination of white space and HTML-style comments.
             * @return {void}
             * @method _skipCruft
             * @private
             */
            _skipCruft: function(){
                while(this._tokenStream.match([Tokens.S, Tokens.CDO, Tokens.CDC])){
                    //noop
                }
            },

            /**
             * Not part of CSS grammar, but this pattern occurs frequently
             * in the official CSS grammar. Split out here to eliminate
             * duplicate code.
             * @param {Boolean} checkStart Indicates if the rule should check
             *      for the left brace at the beginning.
             * @param {Boolean} readMargins Indicates if the rule should check
             *      for margin patterns.
             * @return {void}
             * @method _readDeclarations
             * @private
             */
            _readDeclarations: function(checkStart, readMargins){
                /*
                 * Reads the pattern
                 * S* '{' S* declaration [ ';' S* declaration ]* '}' S*
                 * or
                 * S* '{' S* [ declaration | margin ]? [ ';' S* [ declaration | margin ]? ]* '}' S*
                 * Note that this is how it is described in CSS3 Paged Media, but is actually incorrect.
                 * A semicolon is only necessary following a declaration if there's another declaration
                 * or margin afterwards.
                 */
                var tokenStream = this._tokenStream,
                    tt;


                this._readWhitespace();

                if (checkStart){
                    tokenStream.mustMatch(Tokens.LBRACE);
                }

                this._readWhitespace();

                try {

                    while(true){

                        if (tokenStream.match(Tokens.SEMICOLON) || (readMargins && this._margin())){
                            //noop
                        } else if (this._declaration()){
                            if (!tokenStream.match(Tokens.SEMICOLON)){
                                break;
                            }
                        } else {
                            break;
                        }

                        //if ((!this._margin() && !this._declaration()) || !tokenStream.match(Tokens.SEMICOLON)){
                        //    break;
                        //}
                        this._readWhitespace();
                    }

                    tokenStream.mustMatch(Tokens.RBRACE);
                    this._readWhitespace();

                } catch (ex) {
                    if (ex instanceof SyntaxError && !this.options.strict){

                        //fire error event
                        this.fire({
                            type:       "error",
                            error:      ex,
                            message:    ex.message,
                            line:       ex.line,
                            col:        ex.col
                        });

                        //see if there's another declaration
                        tt = tokenStream.advance([Tokens.SEMICOLON, Tokens.RBRACE]);
                        if (tt === Tokens.SEMICOLON){
                            //if there's a semicolon, then there might be another declaration
                            this._readDeclarations(false, readMargins);
                        } else if (tt !== Tokens.RBRACE){
                            //if there's a right brace, the rule is finished so don't do anything
                            //otherwise, rethrow the error because it wasn't handled properly
                            throw ex;
                        }

                    } else {
                        //not a syntax error, rethrow it
                        throw ex;
                    }
                }

            },

            /**
             * In some cases, you can end up with two white space tokens in a
             * row. Instead of making a change in every function that looks for
             * white space, this function is used to match as much white space
             * as necessary.
             * @method _readWhitespace
             * @return {String} The white space if found, empty string if not.
             * @private
             */
            _readWhitespace: function(){

                var tokenStream = this._tokenStream,
                    ws = "";

                while(tokenStream.match(Tokens.S)){
                    ws += tokenStream.token().value;
                }

                return ws;
            },


            /**
             * Throws an error when an unexpected token is found.
             * @param {Object} token The token that was found.
             * @method _unexpectedToken
             * @return {void}
             * @private
             */
            _unexpectedToken: function(token){
                throw new SyntaxError("Unexpected token '" + token.value + "' at line " + token.startLine + ", col " + token.startCol + ".", token.startLine, token.startCol);
            },

            /**
             * Helper method used for parsing subparts of a style sheet.
             * @return {void}
             * @method _verifyEnd
             * @private
             */
            _verifyEnd: function(){
                if (this._tokenStream.LA(1) !== Tokens.EOF){
                    this._unexpectedToken(this._tokenStream.LT(1));
                }
            },

            //-----------------------------------------------------------------
            // Validation methods
            //-----------------------------------------------------------------
            _validateProperty: function(property, value){
                Validation.validate(property, value);
            },

            //-----------------------------------------------------------------
            // Parsing methods
            //-----------------------------------------------------------------

            parse: function(input){
                this._tokenStream = new TokenStream(input, Tokens);
                this._stylesheet();
            },

            parseStyleSheet: function(input){
                //just passthrough
                return this.parse(input);
            },

            parseMediaQuery: function(input){
                this._tokenStream = new TokenStream(input, Tokens);
                var result = this._media_query();

                //if there's anything more, then it's an invalid selector
                this._verifyEnd();

                //otherwise return result
                return result;
            },

            /**
             * Parses a property value (everything after the semicolon).
             * @return {parserlib.css.PropertyValue} The property value.
             * @throws parserlib.util.SyntaxError If an unexpected token is found.
             * @method parserPropertyValue
             */
            parsePropertyValue: function(input){

                this._tokenStream = new TokenStream(input, Tokens);
                this._readWhitespace();

                var result = this._expr();

                //okay to have a trailing white space
                this._readWhitespace();

                //if there's anything more, then it's an invalid selector
                this._verifyEnd();

                //otherwise return result
                return result;
            },

            /**
             * Parses a complete CSS rule, including selectors and
             * properties.
             * @param {String} input The text to parser.
             * @return {Boolean} True if the parse completed successfully, false if not.
             * @method parseRule
             */
            parseRule: function(input){
                this._tokenStream = new TokenStream(input, Tokens);

                //skip any leading white space
                this._readWhitespace();

                var result = this._ruleset();

                //skip any trailing white space
                this._readWhitespace();

                //if there's anything more, then it's an invalid selector
                this._verifyEnd();

                //otherwise return result
                return result;
            },

            /**
             * Parses a single CSS selector (no comma)
             * @param {String} input The text to parse as a CSS selector.
             * @return {Selector} An object representing the selector.
             * @throws parserlib.util.SyntaxError If an unexpected token is found.
             * @method parseSelector
             */
            parseSelector: function(input){

                this._tokenStream = new TokenStream(input, Tokens);

                //skip any leading white space
                this._readWhitespace();

                var result = this._selector();

                //skip any trailing white space
                this._readWhitespace();

                //if there's anything more, then it's an invalid selector
                this._verifyEnd();

                //otherwise return result
                return result;
            },

            /**
             * Parses an HTML style attribute: a set of CSS declarations
             * separated by semicolons.
             * @param {String} input The text to parse as a style attribute
             * @return {void}
             * @method parseStyleAttribute
             */
            parseStyleAttribute: function(input){
                input += "}"; // for error recovery in _readDeclarations()
                this._tokenStream = new TokenStream(input, Tokens);
                this._readDeclarations();
            }
        };

    //copy over onto prototype
    for (prop in additions){
        if (Object.prototype.hasOwnProperty.call(additions, prop)){
            proto[prop] = additions[prop];
        }
    }

    return proto;
}();


/*
nth
  : S* [ ['-'|'+']? INTEGER? {N} [ S* ['-'|'+'] S* INTEGER ]? |
         ['-'|'+']? INTEGER | {O}{D}{D} | {E}{V}{E}{N} ] S*
  ;
*/
var Properties = {
    __proto__: null,

    //A
    "align-items"                   : "flex-start | flex-end | center | baseline | stretch",
    "align-content"                 : "flex-start | flex-end | center | space-between | space-around | stretch",
    "align-self"                    : "auto | flex-start | flex-end | center | baseline | stretch",
    "-webkit-align-items"           : "flex-start | flex-end | center | baseline | stretch",
    "-webkit-align-content"         : "flex-start | flex-end | center | space-between | space-around | stretch",
    "-webkit-align-self"            : "auto | flex-start | flex-end | center | baseline | stretch",
    "alignment-adjust"              : "auto | baseline | before-edge | text-before-edge | middle | central | after-edge | text-after-edge | ideographic | alphabetic | hanging | mathematical | <percentage> | <length>",
    "alignment-baseline"            : "baseline | use-script | before-edge | text-before-edge | after-edge | text-after-edge | central | middle | ideographic | alphabetic | hanging | mathematical",
    "animation"                     : 1,
    "animation-delay"               : { multi: "<time>", comma: true },
    "animation-direction"           : { multi: "normal | alternate", comma: true },
    "animation-duration"            : { multi: "<time>", comma: true },
    "animation-fill-mode"           : { multi: "none | forwards | backwards | both", comma: true },
    "animation-iteration-count"     : { multi: "<number> | infinite", comma: true },
    "animation-name"                : { multi: "none | <ident>", comma: true },
    "animation-play-state"          : { multi: "running | paused", comma: true },
    "animation-timing-function"     : 1,

    //vendor prefixed
    "-moz-animation-delay"               : { multi: "<time>", comma: true },
    "-moz-animation-direction"           : { multi: "normal | alternate", comma: true },
    "-moz-animation-duration"            : { multi: "<time>", comma: true },
    "-moz-animation-iteration-count"     : { multi: "<number> | infinite", comma: true },
    "-moz-animation-name"                : { multi: "none | <ident>", comma: true },
    "-moz-animation-play-state"          : { multi: "running | paused", comma: true },

    "-ms-animation-delay"               : { multi: "<time>", comma: true },
    "-ms-animation-direction"           : { multi: "normal | alternate", comma: true },
    "-ms-animation-duration"            : { multi: "<time>", comma: true },
    "-ms-animation-iteration-count"     : { multi: "<number> | infinite", comma: true },
    "-ms-animation-name"                : { multi: "none | <ident>", comma: true },
    "-ms-animation-play-state"          : { multi: "running | paused", comma: true },

    "-webkit-animation-delay"               : { multi: "<time>", comma: true },
    "-webkit-animation-direction"           : { multi: "normal | alternate", comma: true },
    "-webkit-animation-duration"            : { multi: "<time>", comma: true },
    "-webkit-animation-fill-mode"           : { multi: "none | forwards | backwards | both", comma: true },
    "-webkit-animation-iteration-count"     : { multi: "<number> | infinite", comma: true },
    "-webkit-animation-name"                : { multi: "none | <ident>", comma: true },
    "-webkit-animation-play-state"          : { multi: "running | paused", comma: true },

    "-o-animation-delay"               : { multi: "<time>", comma: true },
    "-o-animation-direction"           : { multi: "normal | alternate", comma: true },
    "-o-animation-duration"            : { multi: "<time>", comma: true },
    "-o-animation-iteration-count"     : { multi: "<number> | infinite", comma: true },
    "-o-animation-name"                : { multi: "none | <ident>", comma: true },
    "-o-animation-play-state"          : { multi: "running | paused", comma: true },

    "appearance"                    : "icon | window | desktop | workspace | document | tooltip | dialog | button | push-button | hyperlink | radio | radio-button | checkbox | menu-item | tab | menu | menubar | pull-down-menu | pop-up-menu | list-menu | radio-group | checkbox-group | outline-tree | range | field | combo-box | signature | password | normal | none | inherit",
    "azimuth"                       : function (expression) {
        var simple      = "<angle> | leftwards | rightwards | inherit",
            direction   = "left-side | far-left | left | center-left | center | center-right | right | far-right | right-side",
            behind      = false,
            valid       = false,
            part;

        if (!ValidationTypes.isAny(expression, simple)) {
            if (ValidationTypes.isAny(expression, "behind")) {
                behind = true;
                valid = true;
            }

            if (ValidationTypes.isAny(expression, direction)) {
                valid = true;
                if (!behind) {
                    ValidationTypes.isAny(expression, "behind");
                }
            }
        }

        if (expression.hasNext()) {
            part = expression.next();
            if (valid) {
                throw new ValidationError("Expected end of value but found '" + part + "'.", part.line, part.col);
            } else {
                throw new ValidationError("Expected (<'azimuth'>) but found '" + part + "'.", part.line, part.col);
            }
        }
    },

    //B
    "backface-visibility"           : "visible | hidden",
    "background"                    : 1,
    "background-attachment"         : { multi: "<attachment>", comma: true },
    "background-clip"               : { multi: "<box>", comma: true },
    "background-color"              : "<color> | inherit",
    "background-image"              : { multi: "<bg-image>", comma: true },
    "background-origin"             : { multi: "<box>", comma: true },
    "background-position"           : { multi: "<bg-position>", comma: true },
    "background-repeat"             : { multi: "<repeat-style>" },
    "background-size"               : { multi: "<bg-size>", comma: true },
    "baseline-shift"                : "baseline | sub | super | <percentage> | <length>",
    "behavior"                      : 1,
    "binding"                       : 1,
    "bleed"                         : "<length>",
    "bookmark-label"                : "<content> | <attr> | <string>",
    "bookmark-level"                : "none | <integer>",
    "bookmark-state"                : "open | closed",
    "bookmark-target"               : "none | <uri> | <attr>",
    "border"                        : "<border-width> || <border-style> || <color>",
    "border-bottom"                 : "<border-width> || <border-style> || <color>",
    "border-bottom-color"           : "<color> | inherit",
    "border-bottom-left-radius"     :  "<x-one-radius>",
    "border-bottom-right-radius"    :  "<x-one-radius>",
    "border-bottom-style"           : "<border-style>",
    "border-bottom-width"           : "<border-width>",
    "border-collapse"               : "collapse | separate | inherit",
    "border-color"                  : { multi: "<color> | inherit", max: 4 },
    "border-image"                  : 1,
    "border-image-outset"           : { multi: "<length> | <number>", max: 4 },
    "border-image-repeat"           : { multi: "stretch | repeat | round", max: 2 },
    "border-image-slice"            : function(expression) {

        var valid   = false,
            numeric = "<number> | <percentage>",
            fill    = false,
            count   = 0,
            max     = 4,
            part;

        if (ValidationTypes.isAny(expression, "fill")) {
            fill = true;
            valid = true;
        }

        while (expression.hasNext() && count < max) {
            valid = ValidationTypes.isAny(expression, numeric);
            if (!valid) {
                break;
            }
            count++;
        }


        if (!fill) {
            ValidationTypes.isAny(expression, "fill");
        } else {
            valid = true;
        }

        if (expression.hasNext()) {
            part = expression.next();
            if (valid) {
                throw new ValidationError("Expected end of value but found '" + part + "'.", part.line, part.col);
            } else {
                throw new ValidationError("Expected ([<number> | <percentage>]{1,4} && fill?) but found '" + part + "'.", part.line, part.col);
            }
        }
    },
    "border-image-source"           : "<image> | none",
    "border-image-width"            : { multi: "<length> | <percentage> | <number> | auto", max: 4 },
    "border-left"                   : "<border-width> || <border-style> || <color>",
    "border-left-color"             : "<color> | inherit",
    "border-left-style"             : "<border-style>",
    "border-left-width"             : "<border-width>",
    "border-radius"                 : function(expression) {

        var valid   = false,
            simple = "<length> | <percentage> | inherit",
            slash   = false,
            count   = 0,
            max     = 8,
            part;

        while (expression.hasNext() && count < max) {
            valid = ValidationTypes.isAny(expression, simple);
            if (!valid) {

                if (String(expression.peek()) === "/" && count > 0 && !slash) {
                    slash = true;
                    max = count + 5;
                    expression.next();
                } else {
                    break;
                }
            }
            count++;
        }

        if (expression.hasNext()) {
            part = expression.next();
            if (valid) {
                throw new ValidationError("Expected end of value but found '" + part + "'.", part.line, part.col);
            } else {
                throw new ValidationError("Expected (<'border-radius'>) but found '" + part + "'.", part.line, part.col);
            }
        }
    },
    "border-right"                  : "<border-width> || <border-style> || <color>",
    "border-right-color"            : "<color> | inherit",
    "border-right-style"            : "<border-style>",
    "border-right-width"            : "<border-width>",
    "border-spacing"                : { multi: "<length> | inherit", max: 2 },
    "border-style"                  : { multi: "<border-style>", max: 4 },
    "border-top"                    : "<border-width> || <border-style> || <color>",
    "border-top-color"              : "<color> | inherit",
    "border-top-left-radius"        : "<x-one-radius>",
    "border-top-right-radius"       : "<x-one-radius>",
    "border-top-style"              : "<border-style>",
    "border-top-width"              : "<border-width>",
    "border-width"                  : { multi: "<border-width>", max: 4 },
    "bottom"                        : "<margin-width> | inherit",
    "-moz-box-align"                : "start | end | center | baseline | stretch",
    "-moz-box-decoration-break"     : "slice |clone",
    "-moz-box-direction"            : "normal | reverse | inherit",
    "-moz-box-flex"                 : "<number>",
    "-moz-box-flex-group"           : "<integer>",
    "-moz-box-lines"                : "single | multiple",
    "-moz-box-ordinal-group"        : "<integer>",
    "-moz-box-orient"               : "horizontal | vertical | inline-axis | block-axis | inherit",
    "-moz-box-pack"                 : "start | end | center | justify",
    "-o-box-decoration-break"       : "slice | clone",
    "-webkit-box-align"             : "start | end | center | baseline | stretch",
    "-webkit-box-decoration-break"  : "slice |clone",
    "-webkit-box-direction"         : "normal | reverse | inherit",
    "-webkit-box-flex"              : "<number>",
    "-webkit-box-flex-group"        : "<integer>",
    "-webkit-box-lines"             : "single | multiple",
    "-webkit-box-ordinal-group"     : "<integer>",
    "-webkit-box-orient"            : "horizontal | vertical | inline-axis | block-axis | inherit",
    "-webkit-box-pack"              : "start | end | center | justify",
    "box-decoration-break"          : "slice | clone",
    "box-shadow"                    : function (expression) {
        var part;

        if (!ValidationTypes.isAny(expression, "none")) {
            Validation.multiProperty("<shadow>", expression, true, Infinity);
        } else {
            if (expression.hasNext()) {
                part = expression.next();
                throw new ValidationError("Expected end of value but found '" + part + "'.", part.line, part.col);
            }
        }
    },
    "box-sizing"                    : "content-box | border-box | inherit",
    "break-after"                   : "auto | always | avoid | left | right | page | column | avoid-page | avoid-column",
    "break-before"                  : "auto | always | avoid | left | right | page | column | avoid-page | avoid-column",
    "break-inside"                  : "auto | avoid | avoid-page | avoid-column",

    //C
    "caption-side"                  : "top | bottom | inherit",
    "clear"                         : "none | right | left | both | inherit",
    "clip"                          : 1,
    "color"                         : "<color> | inherit",
    "color-profile"                 : 1,
    "column-count"                  : "<integer> | auto",                      //http://www.w3.org/TR/css3-multicol/
    "column-fill"                   : "auto | balance",
    "column-gap"                    : "<length> | normal",
    "column-rule"                   : "<border-width> || <border-style> || <color>",
    "column-rule-color"             : "<color>",
    "column-rule-style"             : "<border-style>",
    "column-rule-width"             : "<border-width>",
    "column-span"                   : "none | all",
    "column-width"                  : "<length> | auto",
    "columns"                       : 1,
    "content"                       : 1,
    "counter-increment"             : 1,
    "counter-reset"                 : 1,
    "crop"                          : "<shape> | auto",
    "cue"                           : "cue-after | cue-before | inherit",
    "cue-after"                     : 1,
    "cue-before"                    : 1,
    "cursor"                        : 1,

    //D
    "direction"                     : "ltr | rtl | inherit",
    "display"                       : "inline | block | list-item | inline-block | table | inline-table | table-row-group | table-header-group | table-footer-group | table-row | table-column-group | table-column | table-cell | table-caption | grid | inline-grid | run-in | ruby | ruby-base | ruby-text | ruby-base-container | ruby-text-container | contents | none | inherit | -moz-box | -moz-inline-block | -moz-inline-box | -moz-inline-grid | -moz-inline-stack | -moz-inline-table | -moz-grid | -moz-grid-group | -moz-grid-line | -moz-groupbox | -moz-deck | -moz-popup | -moz-stack | -moz-marker | -webkit-box | -webkit-inline-box | -ms-flexbox | -ms-inline-flexbox | flex | -webkit-flex | inline-flex | -webkit-inline-flex",
    "dominant-baseline"             : 1,
    "drop-initial-after-adjust"     : "central | middle | after-edge | text-after-edge | ideographic | alphabetic | mathematical | <percentage> | <length>",
    "drop-initial-after-align"      : "baseline | use-script | before-edge | text-before-edge | after-edge | text-after-edge | central | middle | ideographic | alphabetic | hanging | mathematical",
    "drop-initial-before-adjust"    : "before-edge | text-before-edge | central | middle | hanging | mathematical | <percentage> | <length>",
    "drop-initial-before-align"     : "caps-height | baseline | use-script | before-edge | text-before-edge | after-edge | text-after-edge | central | middle | ideographic | alphabetic | hanging | mathematical",
    "drop-initial-size"             : "auto | line | <length> | <percentage>",
    "drop-initial-value"            : "initial | <integer>",

    //E
    "elevation"                     : "<angle> | below | level | above | higher | lower | inherit",
    "empty-cells"                   : "show | hide | inherit",

    //F
    "filter"                        : 1,
    "fit"                           : "fill | hidden | meet | slice",
    "fit-position"                  : 1,
    "flex"                          : "<flex>",
    "flex-basis"                    : "<width>",
    "flex-direction"                : "row | row-reverse | column | column-reverse",
    "flex-flow"                     : "<flex-direction> || <flex-wrap>",
    "flex-grow"                     : "<number>",
    "flex-shrink"                   : "<number>",
    "flex-wrap"                     : "nowrap | wrap | wrap-reverse",
    "-webkit-flex"                  : "<flex>",
    "-webkit-flex-basis"            : "<width>",
    "-webkit-flex-direction"        : "row | row-reverse | column | column-reverse",
    "-webkit-flex-flow"             : "<flex-direction> || <flex-wrap>",
    "-webkit-flex-grow"             : "<number>",
    "-webkit-flex-shrink"           : "<number>",
    "-webkit-flex-wrap"             : "nowrap | wrap | wrap-reverse",
    "-ms-flex"                      : "<flex>",
    "-ms-flex-align"                : "start | end | center | stretch | baseline",
    "-ms-flex-direction"            : "row | row-reverse | column | column-reverse | inherit",
    "-ms-flex-order"                : "<number>",
    "-ms-flex-pack"                 : "start | end | center | justify",
    "-ms-flex-wrap"                 : "nowrap | wrap | wrap-reverse",
    "float"                         : "left | right | none | inherit",
    "float-offset"                  : 1,
    "font"                          : 1,
    "font-family"                   : 1,
    "font-feature-settings"         : "<feature-tag-value> | normal | inherit",
    "font-kerning"                  : "auto | normal | none | initial | inherit | unset",
    "font-size"                     : "<absolute-size> | <relative-size> | <length> | <percentage> | inherit",
    "font-size-adjust"              : "<number> | none | inherit",
    "font-stretch"                  : "normal | ultra-condensed | extra-condensed | condensed | semi-condensed | semi-expanded | expanded | extra-expanded | ultra-expanded | inherit",
    "font-style"                    : "normal | italic | oblique | inherit",
    "font-variant"                  : "normal | small-caps | inherit",
    "font-variant-caps"             : "normal | small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps",
    "font-variant-position"         : "normal | sub | super | inherit | initial | unset",
    "font-weight"                   : "normal | bold | bolder | lighter | 100 | 200 | 300 | 400 | 500 | 600 | 700 | 800 | 900 | inherit",

    //G
    "grid"                          : 1,
    "grid-area"                     : 1,
    "grid-auto-columns"             : 1,
    "grid-auto-flow"                : 1,
    "grid-auto-position"            : 1,
    "grid-auto-rows"                : 1,
    "grid-cell-stacking"            : "columns | rows | layer",
    "grid-column"                   : 1,
    "grid-columns"                  : 1,
    "grid-column-align"             : "start | end | center | stretch",
    "grid-column-sizing"            : 1,
    "grid-column-start"             : 1,
    "grid-column-end"               : 1,
    "grid-column-span"              : "<integer>",
    "grid-flow"                     : "none | rows | columns",
    "grid-layer"                    : "<integer>",
    "grid-row"                      : 1,
    "grid-rows"                     : 1,
    "grid-row-align"                : "start | end | center | stretch",
    "grid-row-start"                : 1,
    "grid-row-end"                  : 1,
    "grid-row-span"                 : "<integer>",
    "grid-row-sizing"               : 1,
    "grid-template"                 : 1,
    "grid-template-areas"           : 1,
    "grid-template-columns"         : 1,
    "grid-template-rows"            : 1,

    //H
    "hanging-punctuation"           : 1,
    "height"                        : "<margin-width> | <content-sizing> | inherit",
    "hyphenate-after"               : "<integer> | auto",
    "hyphenate-before"              : "<integer> | auto",
    "hyphenate-character"           : "<string> | auto",
    "hyphenate-lines"               : "no-limit | <integer>",
    "hyphenate-resource"            : 1,
    "hyphens"                       : "none | manual | auto",

    //I
    "icon"                          : 1,
    "image-orientation"             : "angle | auto",
    "image-rendering"               : 1,
    "image-resolution"              : 1,
    "ime-mode"                      : "auto | normal | active | inactive | disabled | inherit",
    "inline-box-align"              : "initial | last | <integer>",

    //J
    "justify-content"               : "flex-start | flex-end | center | space-between | space-around",
    "-webkit-justify-content"       : "flex-start | flex-end | center | space-between | space-around",

    //L
    "left"                          : "<margin-width> | inherit",
    "letter-spacing"                : "<length> | normal | inherit",
    "line-height"                   : "<number> | <length> | <percentage> | normal | inherit",
    "line-break"                    : "auto | loose | normal | strict",
    "line-stacking"                 : 1,
    "line-stacking-ruby"            : "exclude-ruby | include-ruby",
    "line-stacking-shift"           : "consider-shifts | disregard-shifts",
    "line-stacking-strategy"        : "inline-line-height | block-line-height | max-height | grid-height",
    "list-style"                    : 1,
    "list-style-image"              : "<uri> | none | inherit",
    "list-style-position"           : "inside | outside | inherit",
    "list-style-type"               : "disc | circle | square | decimal | decimal-leading-zero | lower-roman | upper-roman | lower-greek | lower-latin | upper-latin | armenian | georgian | lower-alpha | upper-alpha | none | inherit",

    //M
    "margin"                        : { multi: "<margin-width> | inherit", max: 4 },
    "margin-bottom"                 : "<margin-width> | inherit",
    "margin-left"                   : "<margin-width> | inherit",
    "margin-right"                  : "<margin-width> | inherit",
    "margin-top"                    : "<margin-width> | inherit",
    "mark"                          : 1,
    "mark-after"                    : 1,
    "mark-before"                   : 1,
    "marks"                         : 1,
    "marquee-direction"             : 1,
    "marquee-play-count"            : 1,
    "marquee-speed"                 : 1,
    "marquee-style"                 : 1,
    "max-height"                    : "<length> | <percentage> | <content-sizing> | none | inherit",
    "max-width"                     : "<length> | <percentage> | <content-sizing> | none | inherit",
    "min-height"                    : "<length> | <percentage> | <content-sizing> | contain-floats | -moz-contain-floats | -webkit-contain-floats | inherit",
    "min-width"                     : "<length> | <percentage> | <content-sizing> | contain-floats | -moz-contain-floats | -webkit-contain-floats | inherit",
    "move-to"                       : 1,

    //N
    "nav-down"                      : 1,
    "nav-index"                     : 1,
    "nav-left"                      : 1,
    "nav-right"                     : 1,
    "nav-up"                        : 1,

    //O
    "object-fit"                    : "fill | contain | cover | none | scale-down",
    "object-position"               : "<bg-position>",
    "opacity"                       : "<number> | inherit",
    "order"                         : "<integer>",
    "-webkit-order"                 : "<integer>",
    "orphans"                       : "<integer> | inherit",
    "outline"                       : 1,
    "outline-color"                 : "<color> | invert | inherit",
    "outline-offset"                : 1,
    "outline-style"                 : "<border-style> | inherit",
    "outline-width"                 : "<border-width> | inherit",
    "overflow"                      : "visible | hidden | scroll | auto | inherit",
    "overflow-style"                : 1,
    "overflow-wrap"                 : "normal | break-word",
    "overflow-x"                    : 1,
    "overflow-y"                    : 1,

    //P
    "padding"                       : { multi: "<padding-width> | inherit", max: 4 },
    "padding-bottom"                : "<padding-width> | inherit",
    "padding-left"                  : "<padding-width> | inherit",
    "padding-right"                 : "<padding-width> | inherit",
    "padding-top"                   : "<padding-width> | inherit",
    "page"                          : 1,
    "page-break-after"              : "auto | always | avoid | left | right | inherit",
    "page-break-before"             : "auto | always | avoid | left | right | inherit",
    "page-break-inside"             : "auto | avoid | inherit",
    "page-policy"                   : 1,
    "pause"                         : 1,
    "pause-after"                   : 1,
    "pause-before"                  : 1,
    "perspective"                   : 1,
    "perspective-origin"            : 1,
    "phonemes"                      : 1,
    "pitch"                         : 1,
    "pitch-range"                   : 1,
    "play-during"                   : 1,
    "pointer-events"                : "auto | none | visiblePainted | visibleFill | visibleStroke | visible | painted | fill | stroke | all | inherit",
    "position"                      : "static | relative | absolute | fixed | inherit",
    "presentation-level"            : 1,
    "punctuation-trim"              : 1,

    //Q
    "quotes"                        : 1,

    //R
    "rendering-intent"              : 1,
    "resize"                        : 1,
    "rest"                          : 1,
    "rest-after"                    : 1,
    "rest-before"                   : 1,
    "richness"                      : 1,
    "right"                         : "<margin-width> | inherit",
    "rotation"                      : 1,
    "rotation-point"                : 1,
    "ruby-align"                    : 1,
    "ruby-overhang"                 : 1,
    "ruby-position"                 : 1,
    "ruby-span"                     : 1,

    //S
    "size"                          : 1,
    "speak"                         : "normal | none | spell-out | inherit",
    "speak-header"                  : "once | always | inherit",
    "speak-numeral"                 : "digits | continuous | inherit",
    "speak-punctuation"             : "code | none | inherit",
    "speech-rate"                   : 1,
    "src"                           : 1,
    "stress"                        : 1,
    "string-set"                    : 1,

    "table-layout"                  : "auto | fixed | inherit",
    "tab-size"                      : "<integer> | <length>",
    "target"                        : 1,
    "target-name"                   : 1,
    "target-new"                    : 1,
    "target-position"               : 1,
    "text-align"                    : "left | right | center | justify | match-parent | start | end | inherit" ,
    "text-align-last"               : 1,
    "text-decoration"               : 1,
    "text-emphasis"                 : 1,
    "text-height"                   : 1,
    "text-indent"                   : "<length> | <percentage> | inherit",
    "text-justify"                  : "auto | none | inter-word | inter-ideograph | inter-cluster | distribute | kashida",
    "text-outline"                  : 1,
    "text-overflow"                 : 1,
    "text-rendering"                : "auto | optimizeSpeed | optimizeLegibility | geometricPrecision | inherit",
    "text-shadow"                   : 1,
    "text-transform"                : "capitalize | uppercase | lowercase | none | inherit",
    "text-wrap"                     : "normal | none | avoid",
    "top"                           : "<margin-width> | inherit",
    "-ms-touch-action"              : "auto | none | pan-x | pan-y | pan-left | pan-right | pan-up | pan-down | manipulation",
    "touch-action"                  : "auto | none | pan-x | pan-y | pan-left | pan-right | pan-up | pan-down | manipulation",
    "transform"                     : 1,
    "transform-origin"              : 1,
    "transform-style"               : 1,
    "transition"                    : 1,
    "transition-delay"              : 1,
    "transition-duration"           : 1,
    "transition-property"           : 1,
    "transition-timing-function"    : 1,

    //U
    "unicode-bidi"                  : "normal | embed | isolate | bidi-override | isolate-override | plaintext | inherit",
    "user-modify"                   : "read-only | read-write | write-only | inherit",
    "user-select"                   : "none | text | toggle | element | elements | all | inherit",

    //V
    "vertical-align"                : "auto | use-script | baseline | sub | super | top | text-top | central | middle | bottom | text-bottom | <percentage> | <length> | inherit",
    "visibility"                    : "visible | hidden | collapse | inherit",
    "voice-balance"                 : 1,
    "voice-duration"                : 1,
    "voice-family"                  : 1,
    "voice-pitch"                   : 1,
    "voice-pitch-range"             : 1,
    "voice-rate"                    : 1,
    "voice-stress"                  : 1,
    "voice-volume"                  : 1,
    "volume"                        : 1,

    //W
    "white-space"                   : "normal | pre | nowrap | pre-wrap | pre-line | inherit | -pre-wrap | -o-pre-wrap | -moz-pre-wrap | -hp-pre-wrap", //http://perishablepress.com/wrapping-content/
    "white-space-collapse"          : 1,
    "widows"                        : "<integer> | inherit",
    "width"                         : "<length> | <percentage> | <content-sizing> | auto | inherit",
    "will-change"                   : { multi: "<ident>", comma: true },
    "word-break"                    : "normal | keep-all | break-all",
    "word-spacing"                  : "<length> | normal | inherit",
    "word-wrap"                     : "normal | break-word",
    "writing-mode"                  : "horizontal-tb | vertical-rl | vertical-lr | lr-tb | rl-tb | tb-rl | bt-rl | tb-lr | bt-lr | lr-bt | rl-bt | lr | rl | tb | inherit",

    //Z
    "z-index"                       : "<integer> | auto | inherit",
    "zoom"                          : "<number> | <percentage> | normal"
};
/**
 * Represents a selector combinator (whitespace, +, >).
 * @namespace parserlib.css
 * @class PropertyName
 * @extends parserlib.util.SyntaxUnit
 * @constructor
 * @param {String} text The text representation of the unit.
 * @param {String} hack The type of IE hack applied ("*", "_", or null).
 * @param {int} line The line of text on which the unit resides.
 * @param {int} col The column of text on which the unit resides.
 */
function PropertyName(text, hack, line, col){

    SyntaxUnit.call(this, text, line, col, Parser.PROPERTY_NAME_TYPE);

    /**
     * The type of IE hack applied ("*", "_", or null).
     * @type String
     * @property hack
     */
    this.hack = hack;

}

PropertyName.prototype = new SyntaxUnit();
PropertyName.prototype.constructor = PropertyName;
PropertyName.prototype.toString = function(){
    return (this.hack ? this.hack : "") + this.text;
};
/**
 * Represents a single part of a CSS property value, meaning that it represents
 * just everything single part between ":" and ";". If there are multiple values
 * separated by commas, this type represents just one of the values.
 * @param {String[]} parts An array of value parts making up this value.
 * @param {int} line The line of text on which the unit resides.
 * @param {int} col The column of text on which the unit resides.
 * @namespace parserlib.css
 * @class PropertyValue
 * @extends parserlib.util.SyntaxUnit
 * @constructor
 */
function PropertyValue(parts, line, col){

    SyntaxUnit.call(this, parts.join(" "), line, col, Parser.PROPERTY_VALUE_TYPE);

    /**
     * The parts that make up the selector.
     * @type Array
     * @property parts
     */
    this.parts = parts;

}

PropertyValue.prototype = new SyntaxUnit();
PropertyValue.prototype.constructor = PropertyValue;

/**
 * A utility class that allows for easy iteration over the various parts of a
 * property value.
 * @param {parserlib.css.PropertyValue} value The property value to iterate over.
 * @namespace parserlib.css
 * @class PropertyValueIterator
 * @constructor
 */
function PropertyValueIterator(value){

    /**
     * Iterator value
     * @type int
     * @property _i
     * @private
     */
    this._i = 0;

    /**
     * The parts that make up the value.
     * @type Array
     * @property _parts
     * @private
     */
    this._parts = value.parts;

    /**
     * Keeps track of bookmarks along the way.
     * @type Array
     * @property _marks
     * @private
     */
    this._marks = [];

    /**
     * Holds the original property value.
     * @type parserlib.css.PropertyValue
     * @property value
     */
    this.value = value;

}

/**
 * Returns the total number of parts in the value.
 * @return {int} The total number of parts in the value.
 * @method count
 */
PropertyValueIterator.prototype.count = function(){
    return this._parts.length;
};

/**
 * Indicates if the iterator is positioned at the first item.
 * @return {Boolean} True if positioned at first item, false if not.
 * @method isFirst
 */
PropertyValueIterator.prototype.isFirst = function(){
    return this._i === 0;
};

/**
 * Indicates if there are more parts of the property value.
 * @return {Boolean} True if there are more parts, false if not.
 * @method hasNext
 */
PropertyValueIterator.prototype.hasNext = function(){
    return (this._i < this._parts.length);
};

/**
 * Marks the current spot in the iteration so it can be restored to
 * later on.
 * @return {void}
 * @method mark
 */
PropertyValueIterator.prototype.mark = function(){
    this._marks.push(this._i);
};

/**
 * Returns the next part of the property value or null if there is no next
 * part. Does not move the internal counter forward.
 * @return {parserlib.css.PropertyValuePart} The next part of the property value or null if there is no next
 * part.
 * @method peek
 */
PropertyValueIterator.prototype.peek = function(count){
    return this.hasNext() ? this._parts[this._i + (count || 0)] : null;
};

/**
 * Returns the next part of the property value or null if there is no next
 * part.
 * @return {parserlib.css.PropertyValuePart} The next part of the property value or null if there is no next
 * part.
 * @method next
 */
PropertyValueIterator.prototype.next = function(){
    return this.hasNext() ? this._parts[this._i++] : null;
};

/**
 * Returns the previous part of the property value or null if there is no
 * previous part.
 * @return {parserlib.css.PropertyValuePart} The previous part of the
 * property value or null if there is no previous part.
 * @method previous
 */
PropertyValueIterator.prototype.previous = function(){
    return this._i > 0 ? this._parts[--this._i] : null;
};

/**
 * Restores the last saved bookmark.
 * @return {void}
 * @method restore
 */
PropertyValueIterator.prototype.restore = function(){
    if (this._marks.length){
        this._i = this._marks.pop();
    }
};

/**
 * Represents a single part of a CSS property value, meaning that it represents
 * just one part of the data between ":" and ";".
 * @param {String} text The text representation of the unit.
 * @param {int} line The line of text on which the unit resides.
 * @param {int} col The column of text on which the unit resides.
 * @namespace parserlib.css
 * @class PropertyValuePart
 * @extends parserlib.util.SyntaxUnit
 * @constructor
 */
function PropertyValuePart(text, line, col){

    SyntaxUnit.call(this, text, line, col, Parser.PROPERTY_VALUE_PART_TYPE);

    /**
     * Indicates the type of value unit.
     * @type String
     * @property type
     */
    this.type = "unknown";

    //figure out what type of data it is

    var temp;

    //it is a measurement?
    if (/^([+\-]?[\d\.]+)([a-z]+)$/i.test(text)){  //dimension
        this.type = "dimension";
        this.value = +RegExp.$1;
        this.units = RegExp.$2;

        //try to narrow down
        switch(this.units.toLowerCase()){

            case "em":
            case "rem":
            case "ex":
            case "px":
            case "cm":
            case "mm":
            case "in":
            case "pt":
            case "pc":
            case "ch":
            case "vh":
            case "vw":
            case "vmax":
            case "vmin":
                this.type = "length";
                break;
                
            case "fr":
                this.type = "grid";
                break;

            case "deg":
            case "rad":
            case "grad":
                this.type = "angle";
                break;

            case "ms":
            case "s":
                this.type = "time";
                break;

            case "hz":
            case "khz":
                this.type = "frequency";
                break;

            case "dpi":
            case "dpcm":
                this.type = "resolution";
                break;

            //default

        }

    } else if (/^([+\-]?[\d\.]+)%$/i.test(text)){  //percentage
        this.type = "percentage";
        this.value = +RegExp.$1;
    } else if (/^([+\-]?\d+)$/i.test(text)){  //integer
        this.type = "integer";
        this.value = +RegExp.$1;
    } else if (/^([+\-]?[\d\.]+)$/i.test(text)){  //number
        this.type = "number";
        this.value = +RegExp.$1;

    } else if (/^#([a-f0-9]{3,6})/i.test(text)){  //hexcolor
        this.type = "color";
        temp = RegExp.$1;
        if (temp.length === 3){
            this.red    = parseInt(temp.charAt(0)+temp.charAt(0),16);
            this.green  = parseInt(temp.charAt(1)+temp.charAt(1),16);
            this.blue   = parseInt(temp.charAt(2)+temp.charAt(2),16);
        } else {
            this.red    = parseInt(temp.substring(0,2),16);
            this.green  = parseInt(temp.substring(2,4),16);
            this.blue   = parseInt(temp.substring(4,6),16);
        }
    } else if (/^rgb\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)/i.test(text)){ //rgb() color with absolute numbers
        this.type   = "color";
        this.red    = +RegExp.$1;
        this.green  = +RegExp.$2;
        this.blue   = +RegExp.$3;
    } else if (/^rgb\(\s*(\d+)%\s*,\s*(\d+)%\s*,\s*(\d+)%\s*\)/i.test(text)){ //rgb() color with percentages
        this.type   = "color";
        this.red    = +RegExp.$1 * 255 / 100;
        this.green  = +RegExp.$2 * 255 / 100;
        this.blue   = +RegExp.$3 * 255 / 100;
    } else if (/^rgba\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*([\d\.]+)\s*\)/i.test(text)){ //rgba() color with absolute numbers
        this.type   = "color";
        this.red    = +RegExp.$1;
        this.green  = +RegExp.$2;
        this.blue   = +RegExp.$3;
        this.alpha  = +RegExp.$4;
    } else if (/^rgba\(\s*(\d+)%\s*,\s*(\d+)%\s*,\s*(\d+)%\s*,\s*([\d\.]+)\s*\)/i.test(text)){ //rgba() color with percentages
        this.type   = "color";
        this.red    = +RegExp.$1 * 255 / 100;
        this.green  = +RegExp.$2 * 255 / 100;
        this.blue   = +RegExp.$3 * 255 / 100;
        this.alpha  = +RegExp.$4;
    } else if (/^hsl\(\s*(\d+)\s*,\s*(\d+)%\s*,\s*(\d+)%\s*\)/i.test(text)){ //hsl()
        this.type   = "color";
        this.hue    = +RegExp.$1;
        this.saturation = +RegExp.$2 / 100;
        this.lightness  = +RegExp.$3 / 100;
    } else if (/^hsla\(\s*(\d+)\s*,\s*(\d+)%\s*,\s*(\d+)%\s*,\s*([\d\.]+)\s*\)/i.test(text)){ //hsla() color with percentages
        this.type   = "color";
        this.hue    = +RegExp.$1;
        this.saturation = +RegExp.$2 / 100;
        this.lightness  = +RegExp.$3 / 100;
        this.alpha  = +RegExp.$4;
    } else if (/^url\(["']?([^\)"']+)["']?\)/i.test(text)){ //URI
        this.type   = "uri";
        this.uri    = RegExp.$1;
    } else if (/^([^\(]+)\(/i.test(text)){
        this.type   = "function";
        this.name   = RegExp.$1;
        this.value  = text;
    } else if (/^"([^\n\r\f\\"]|\\\r\n|\\[^\r0-9a-f]|\\[0-9a-f]{1,6}(\r\n|[ \n\r\t\f])?)*"/i.test(text)){    //double-quoted string
        this.type   = "string";
        this.value  = PropertyValuePart.parseString(text);
    } else if (/^'([^\n\r\f\\']|\\\r\n|\\[^\r0-9a-f]|\\[0-9a-f]{1,6}(\r\n|[ \n\r\t\f])?)*'/i.test(text)){    //single-quoted string
        this.type   = "string";
        this.value  = PropertyValuePart.parseString(text);
    } else if (Colors[text.toLowerCase()]){  //named color
        this.type   = "color";
        temp        = Colors[text.toLowerCase()].substring(1);
        this.red    = parseInt(temp.substring(0,2),16);
        this.green  = parseInt(temp.substring(2,4),16);
        this.blue   = parseInt(temp.substring(4,6),16);
    } else if (/^[\,\/]$/.test(text)){
        this.type   = "operator";
        this.value  = text;
    } else if (/^[a-z\-_\u0080-\uFFFF][a-z0-9\-_\u0080-\uFFFF]*$/i.test(text)){
        this.type   = "identifier";
        this.value  = text;
    }

}

PropertyValuePart.prototype = new SyntaxUnit();
PropertyValuePart.prototype.constructor = PropertyValuePart;

/**
 * Helper method to parse a CSS string.
 */
PropertyValuePart.parseString = function(str) {
    str = str.slice(1, -1); // Strip surrounding single/double quotes
    var replacer = function(match, esc) {
        if (/^(\n|\r\n|\r|\f)$/.test(esc)) { return ''; }
        var m = /^[0-9a-f]{1,6}/i.exec(esc);
        if (m) {
            var codePoint = parseInt(m[0], 16);
            if (String.fromCodePoint) {
                return String.fromCodePoint(codePoint);
            } else {
                // XXX No support for surrogates on old JavaScript engines.
                return String.fromCharCode(codePoint);
            }
        }
        return esc;
    };
    return str.replace(/\\(\r\n|[^\r0-9a-f]|[0-9a-f]{1,6}(\r\n|[ \n\r\t\f])?)/ig,
                       replacer);
};

/**
 * Helper method to serialize a CSS string.
 */
PropertyValuePart.serializeString = function(value) {
    var replacer = function(match, c) {
        if (c === '"') {
            return "\\" + c;
        }
        var cp = String.codePointAt ? String.codePointAt(0) :
            // We only escape non-surrogate chars, so using charCodeAt
            // is harmless here.
            String.charCodeAt(0);
        return "\\" + cp.toString(16) + " ";
    };
    return '"' + value.replace(/["\r\n\f]/g, replacer) + '"';
};

/**
 * Create a new syntax unit based solely on the given token.
 * Convenience method for creating a new syntax unit when
 * it represents a single token instead of multiple.
 * @param {Object} token The token object to represent.
 * @return {parserlib.css.PropertyValuePart} The object representing the token.
 * @static
 * @method fromToken
 */
PropertyValuePart.fromToken = function(token){
    return new PropertyValuePart(token.value, token.startLine, token.startCol);
};
var Pseudos = {
    __proto__:       null,
    ":first-letter": 1,
    ":first-line":   1,
    ":before":       1,
    ":after":        1
};

Pseudos.ELEMENT = 1;
Pseudos.CLASS = 2;

Pseudos.isElement = function(pseudo){
    return pseudo.indexOf("::") === 0 || Pseudos[pseudo.toLowerCase()] === Pseudos.ELEMENT;
};
/**
 * Represents an entire single selector, including all parts but not
 * including multiple selectors (those separated by commas).
 * @namespace parserlib.css
 * @class Selector
 * @extends parserlib.util.SyntaxUnit
 * @constructor
 * @param {Array} parts Array of selectors parts making up this selector.
 * @param {int} line The line of text on which the unit resides.
 * @param {int} col The column of text on which the unit resides.
 */
function Selector(parts, line, col){

    SyntaxUnit.call(this, parts.join(" "), line, col, Parser.SELECTOR_TYPE);

    /**
     * The parts that make up the selector.
     * @type Array
     * @property parts
     */
    this.parts = parts;

    /**
     * The specificity of the selector.
     * @type parserlib.css.Specificity
     * @property specificity
     */
    this.specificity = Specificity.calculate(this);

}

Selector.prototype = new SyntaxUnit();
Selector.prototype.constructor = Selector;

/**
 * Represents a single part of a selector string, meaning a single set of
 * element name and modifiers. This does not include combinators such as
 * spaces, +, >, etc.
 * @namespace parserlib.css
 * @class SelectorPart
 * @extends parserlib.util.SyntaxUnit
 * @constructor
 * @param {String} elementName The element name in the selector or null
 *      if there is no element name.
 * @param {Array} modifiers Array of individual modifiers for the element.
 *      May be empty if there are none.
 * @param {String} text The text representation of the unit.
 * @param {int} line The line of text on which the unit resides.
 * @param {int} col The column of text on which the unit resides.
 */
function SelectorPart(elementName, modifiers, text, line, col){

    SyntaxUnit.call(this, text, line, col, Parser.SELECTOR_PART_TYPE);

    /**
     * The tag name of the element to which this part
     * of the selector affects.
     * @type String
     * @property elementName
     */
    this.elementName = elementName;

    /**
     * The parts that come after the element name, such as class names, IDs,
     * pseudo classes/elements, etc.
     * @type Array
     * @property modifiers
     */
    this.modifiers = modifiers;

}

SelectorPart.prototype = new SyntaxUnit();
SelectorPart.prototype.constructor = SelectorPart;

/**
 * Represents a selector modifier string, meaning a class name, element name,
 * element ID, pseudo rule, etc.
 * @namespace parserlib.css
 * @class SelectorSubPart
 * @extends parserlib.util.SyntaxUnit
 * @constructor
 * @param {String} text The text representation of the unit.
 * @param {String} type The type of selector modifier.
 * @param {int} line The line of text on which the unit resides.
 * @param {int} col The column of text on which the unit resides.
 */
function SelectorSubPart(text, type, line, col){

    SyntaxUnit.call(this, text, line, col, Parser.SELECTOR_SUB_PART_TYPE);

    /**
     * The type of modifier.
     * @type String
     * @property type
     */
    this.type = type;

    /**
     * Some subparts have arguments, this represents them.
     * @type Array
     * @property args
     */
    this.args = [];

}

SelectorSubPart.prototype = new SyntaxUnit();
SelectorSubPart.prototype.constructor = SelectorSubPart;

/**
 * Represents a selector's specificity.
 * @namespace parserlib.css
 * @class Specificity
 * @constructor
 * @param {int} a Should be 1 for inline styles, zero for stylesheet styles
 * @param {int} b Number of ID selectors
 * @param {int} c Number of classes and pseudo classes
 * @param {int} d Number of element names and pseudo elements
 */
function Specificity(a, b, c, d){
    this.a = a;
    this.b = b;
    this.c = c;
    this.d = d;
}

Specificity.prototype = {
    constructor: Specificity,

    /**
     * Compare this specificity to another.
     * @param {Specificity} other The other specificity to compare to.
     * @return {int} -1 if the other specificity is larger, 1 if smaller, 0 if equal.
     * @method compare
     */
    compare: function(other){
        var comps = ["a", "b", "c", "d"],
            i, len;

        for (i=0, len=comps.length; i < len; i++){
            if (this[comps[i]] < other[comps[i]]){
                return -1;
            } else if (this[comps[i]] > other[comps[i]]){
                return 1;
            }
        }

        return 0;
    },

    /**
     * Creates a numeric value for the specificity.
     * @return {int} The numeric value for the specificity.
     * @method valueOf
     */
    valueOf: function(){
        return (this.a * 1000) + (this.b * 100) + (this.c * 10) + this.d;
    },

    /**
     * Returns a string representation for specificity.
     * @return {String} The string representation of specificity.
     * @method toString
     */
    toString: function(){
        return this.a + "," + this.b + "," + this.c + "," + this.d;
    }

};

/**
 * Calculates the specificity of the given selector.
 * @param {parserlib.css.Selector} The selector to calculate specificity for.
 * @return {parserlib.css.Specificity} The specificity of the selector.
 * @static
 * @method calculate
 */
Specificity.calculate = function(selector){

    var i, len,
        part,
        b=0, c=0, d=0;

    function updateValues(part){

        var i, j, len, num,
            elementName = part.elementName ? part.elementName.text : "",
            modifier;

        if (elementName && elementName.charAt(elementName.length-1) !== "*") {
            d++;
        }

        for (i=0, len=part.modifiers.length; i < len; i++){
            modifier = part.modifiers[i];
            switch(modifier.type){
                case "class":
                case "attribute":
                    c++;
                    break;

                case "id":
                    b++;
                    break;

                case "pseudo":
                    if (Pseudos.isElement(modifier.text)){
                        d++;
                    } else {
                        c++;
                    }
                    break;

                case "not":
                    for (j=0, num=modifier.args.length; j < num; j++){
                        updateValues(modifier.args[j]);
                    }
            }
         }
    }

    for (i=0, len=selector.parts.length; i < len; i++){
        part = selector.parts[i];

        if (part instanceof SelectorPart){
            updateValues(part);
        }
    }

    return new Specificity(0, b, c, d);
};

var h = /^[0-9a-fA-F]$/,
    //nonascii = /^[\u0080-\uFFFF]$/,
    nl = /\n|\r\n|\r|\f/;

//-----------------------------------------------------------------------------
// Helper functions
//-----------------------------------------------------------------------------


function isHexDigit(c){
    return c !== null && h.test(c);
}

function isDigit(c){
    return c !== null && /\d/.test(c);
}

function isWhitespace(c){
    return c !== null && /\s/.test(c);
}

function isNewLine(c){
    return c !== null && nl.test(c);
}

function isNameStart(c){
    return c !== null && (/[a-z_\u0080-\uFFFF\\]/i.test(c));
}

function isNameChar(c){
    return c !== null && (isNameStart(c) || /[0-9\-\\]/.test(c));
}

function isIdentStart(c){
    return c !== null && (isNameStart(c) || /\-\\/.test(c));
}

function mix(receiver, supplier){
	for (var prop in supplier){
		if (Object.prototype.hasOwnProperty.call(supplier, prop)){
			receiver[prop] = supplier[prop];
		}
	}
	return receiver;
}

//-----------------------------------------------------------------------------
// CSS Token Stream
//-----------------------------------------------------------------------------


/**
 * A token stream that produces CSS tokens.
 * @param {String|Reader} input The source of text to tokenize.
 * @constructor
 * @class TokenStream
 * @namespace parserlib.css
 */
function TokenStream(input){
	TokenStreamBase.call(this, input, Tokens);
}

TokenStream.prototype = mix(new TokenStreamBase(), {

    /**
     * Overrides the TokenStreamBase method of the same name
     * to produce CSS tokens.
     * @param {variant} channel The name of the channel to use
     *      for the next token.
     * @return {Object} A token object representing the next token.
     * @method _getToken
     * @private
     */
    _getToken: function(channel){

        var c,
            reader = this._reader,
            token   = null,
            startLine   = reader.getLine(),
            startCol    = reader.getCol();

        c = reader.read();


        while(c){
            switch(c){

                /*
                 * Potential tokens:
                 * - COMMENT
                 * - SLASH
                 * - CHAR
                 */
                case "/":

                    if(reader.peek() === "*"){
                        token = this.commentToken(c, startLine, startCol);
                    } else {
                        token = this.charToken(c, startLine, startCol);
                    }
                    break;

                /*
                 * Potential tokens:
                 * - DASHMATCH
                 * - INCLUDES
                 * - PREFIXMATCH
                 * - SUFFIXMATCH
                 * - SUBSTRINGMATCH
                 * - CHAR
                 */
                case "|":
                case "~":
                case "^":
                case "$":
                case "*":
                    if(reader.peek() === "="){
                        token = this.comparisonToken(c, startLine, startCol);
                    } else {
                        token = this.charToken(c, startLine, startCol);
                    }
                    break;

                /*
                 * Potential tokens:
                 * - STRING
                 * - INVALID
                 */
                case "\"":
                case "'":
                    token = this.stringToken(c, startLine, startCol);
                    break;

                /*
                 * Potential tokens:
                 * - HASH
                 * - CHAR
                 */
                case "#":
                    if (isNameChar(reader.peek())){
                        token = this.hashToken(c, startLine, startCol);
                    } else {
                        token = this.charToken(c, startLine, startCol);
                    }
                    break;

                /*
                 * Potential tokens:
                 * - DOT
                 * - NUMBER
                 * - DIMENSION
                 * - PERCENTAGE
                 */
                case ".":
                    if (isDigit(reader.peek())){
                        token = this.numberToken(c, startLine, startCol);
                    } else {
                        token = this.charToken(c, startLine, startCol);
                    }
                    break;

                /*
                 * Potential tokens:
                 * - CDC
                 * - MINUS
                 * - NUMBER
                 * - DIMENSION
                 * - PERCENTAGE
                 */
                case "-":
                    if (reader.peek() === "-"){  //could be closing HTML-style comment
                        token = this.htmlCommentEndToken(c, startLine, startCol);
                    } else if (isNameStart(reader.peek())){
                        token = this.identOrFunctionToken(c, startLine, startCol);
                    } else {
                        token = this.charToken(c, startLine, startCol);
                    }
                    break;

                /*
                 * Potential tokens:
                 * - IMPORTANT_SYM
                 * - CHAR
                 */
                case "!":
                    token = this.importantToken(c, startLine, startCol);
                    break;

                /*
                 * Any at-keyword or CHAR
                 */
                case "@":
                    token = this.atRuleToken(c, startLine, startCol);
                    break;

                /*
                 * Potential tokens:
                 * - NOT
                 * - CHAR
                 */
                case ":":
                    token = this.notToken(c, startLine, startCol);
                    break;

                /*
                 * Potential tokens:
                 * - CDO
                 * - CHAR
                 */
                case "<":
                    token = this.htmlCommentStartToken(c, startLine, startCol);
                    break;

                /*
                 * Potential tokens:
                 * - UNICODE_RANGE
                 * - URL
                 * - CHAR
                 */
                case "U":
                case "u":
                    if (reader.peek() === "+"){
                        token = this.unicodeRangeToken(c, startLine, startCol);
                        break;
                    }
                    /* falls through */
                default:

                    /*
                     * Potential tokens:
                     * - NUMBER
                     * - DIMENSION
                     * - LENGTH
                     * - FREQ
                     * - TIME
                     * - EMS
                     * - EXS
                     * - ANGLE
                     */
                    if (isDigit(c)){
                        token = this.numberToken(c, startLine, startCol);
                    } else

                    /*
                     * Potential tokens:
                     * - S
                     */
                    if (isWhitespace(c)){
                        token = this.whitespaceToken(c, startLine, startCol);
                    } else

                    /*
                     * Potential tokens:
                     * - IDENT
                     */
                    if (isIdentStart(c)){
                        token = this.identOrFunctionToken(c, startLine, startCol);
                    } else

                    /*
                     * Potential tokens:
                     * - CHAR
                     * - PLUS
                     */
                    {
                        token = this.charToken(c, startLine, startCol);
                    }






            }

            //make sure this token is wanted
            //TODO: check channel
            break;
        }

        if (!token && c === null){
            token = this.createToken(Tokens.EOF,null,startLine,startCol);
        }

        return token;
    },

    //-------------------------------------------------------------------------
    // Methods to create tokens
    //-------------------------------------------------------------------------

    /**
     * Produces a token based on available data and the current
     * reader position information. This method is called by other
     * private methods to create tokens and is never called directly.
     * @param {int} tt The token type.
     * @param {String} value The text value of the token.
     * @param {int} startLine The beginning line for the character.
     * @param {int} startCol The beginning column for the character.
     * @param {Object} options (Optional) Specifies a channel property
     *      to indicate that a different channel should be scanned
     *      and/or a hide property indicating that the token should
     *      be hidden.
     * @return {Object} A token object.
     * @method createToken
     */
    createToken: function(tt, value, startLine, startCol, options){
        var reader = this._reader;
        options = options || {};

        return {
            value:      value,
            type:       tt,
            channel:    options.channel,
            endChar:    options.endChar,
            hide:       options.hide || false,
            startLine:  startLine,
            startCol:   startCol,
            endLine:    reader.getLine(),
            endCol:     reader.getCol()
        };
    },

    //-------------------------------------------------------------------------
    // Methods to create specific tokens
    //-------------------------------------------------------------------------

    /**
     * Produces a token for any at-rule. If the at-rule is unknown, then
     * the token is for a single "@" character.
     * @param {String} first The first character for the token.
     * @param {int} startLine The beginning line for the character.
     * @param {int} startCol The beginning column for the character.
     * @return {Object} A token object.
     * @method atRuleToken
     */
    atRuleToken: function(first, startLine, startCol){
        var rule    = first,
            reader  = this._reader,
            tt      = Tokens.CHAR,
            ident;

        /*
         * First, mark where we are. There are only four @ rules,
         * so anything else is really just an invalid token.
         * Basically, if this doesn't match one of the known @
         * rules, just return '@' as an unknown token and allow
         * parsing to continue after that point.
         */
        reader.mark();

        //try to find the at-keyword
        ident = this.readName();
        rule = first + ident;
        tt = Tokens.type(rule.toLowerCase());

        //if it's not valid, use the first character only and reset the reader
        if (tt === Tokens.CHAR || tt === Tokens.UNKNOWN){
            if (rule.length > 1){
                tt = Tokens.UNKNOWN_SYM;
            } else {
                tt = Tokens.CHAR;
                rule = first;
                reader.reset();
            }
        }

        return this.createToken(tt, rule, startLine, startCol);
    },

    /**
     * Produces a character token based on the given character
     * and location in the stream. If there's a special (non-standard)
     * token name, this is used; otherwise CHAR is used.
     * @param {String} c The character for the token.
     * @param {int} startLine The beginning line for the character.
     * @param {int} startCol The beginning column for the character.
     * @return {Object} A token object.
     * @method charToken
     */
    charToken: function(c, startLine, startCol){
        var tt = Tokens.type(c);
        var opts = {};

        if (tt === -1){
            tt = Tokens.CHAR;
        } else {
            opts.endChar = Tokens[tt].endChar;
        }

        return this.createToken(tt, c, startLine, startCol, opts);
    },

    /**
     * Produces a character token based on the given character
     * and location in the stream. If there's a special (non-standard)
     * token name, this is used; otherwise CHAR is used.
     * @param {String} first The first character for the token.
     * @param {int} startLine The beginning line for the character.
     * @param {int} startCol The beginning column for the character.
     * @return {Object} A token object.
     * @method commentToken
     */
    commentToken: function(first, startLine, startCol){
        var comment = this.readComment(first);

        return this.createToken(Tokens.COMMENT, comment, startLine, startCol);
    },

    /**
     * Produces a comparison token based on the given character
     * and location in the stream. The next character must be
     * read and is already known to be an equals sign.
     * @param {String} c The character for the token.
     * @param {int} startLine The beginning line for the character.
     * @param {int} startCol The beginning column for the character.
     * @return {Object} A token object.
     * @method comparisonToken
     */
    comparisonToken: function(c, startLine, startCol){
        var reader  = this._reader,
            comparison  = c + reader.read(),
            tt      = Tokens.type(comparison) || Tokens.CHAR;

        return this.createToken(tt, comparison, startLine, startCol);
    },

    /**
     * Produces a hash token based on the specified information. The
     * first character provided is the pound sign (#) and then this
     * method reads a name afterward.
     * @param {String} first The first character (#) in the hash name.
     * @param {int} startLine The beginning line for the character.
     * @param {int} startCol The beginning column for the character.
     * @return {Object} A token object.
     * @method hashToken
     */
    hashToken: function(first, startLine, startCol){
        var name    = this.readName(first);

        return this.createToken(Tokens.HASH, name, startLine, startCol);
    },

    /**
     * Produces a CDO or CHAR token based on the specified information. The
     * first character is provided and the rest is read by the function to determine
     * the correct token to create.
     * @param {String} first The first character in the token.
     * @param {int} startLine The beginning line for the character.
     * @param {int} startCol The beginning column for the character.
     * @return {Object} A token object.
     * @method htmlCommentStartToken
     */
    htmlCommentStartToken: function(first, startLine, startCol){
        var reader      = this._reader,
            text        = first;

        reader.mark();
        text += reader.readCount(3);

        if (text === "<!--"){
            return this.createToken(Tokens.CDO, text, startLine, startCol);
        } else {
            reader.reset();
            return this.charToken(first, startLine, startCol);
        }
    },

    /**
     * Produces a CDC or CHAR token based on the specified information. The
     * first character is provided and the rest is read by the function to determine
     * the correct token to create.
     * @param {String} first The first character in the token.
     * @param {int} startLine The beginning line for the character.
     * @param {int} startCol The beginning column for the character.
     * @return {Object} A token object.
     * @method htmlCommentEndToken
     */
    htmlCommentEndToken: function(first, startLine, startCol){
        var reader      = this._reader,
            text        = first;

        reader.mark();
        text += reader.readCount(2);

        if (text === "-->"){
            return this.createToken(Tokens.CDC, text, startLine, startCol);
        } else {
            reader.reset();
            return this.charToken(first, startLine, startCol);
        }
    },

    /**
     * Produces an IDENT or FUNCTION token based on the specified information. The
     * first character is provided and the rest is read by the function to determine
     * the correct token to create.
     * @param {String} first The first character in the identifier.
     * @param {int} startLine The beginning line for the character.
     * @param {int} startCol The beginning column for the character.
     * @return {Object} A token object.
     * @method identOrFunctionToken
     */
    identOrFunctionToken: function(first, startLine, startCol){
        var reader  = this._reader,
            ident   = this.readName(first),
            tt      = Tokens.IDENT,
            uriFns  = ["url(", "url-prefix(", "domain("];

        //if there's a left paren immediately after, it's a URI or function
        if (reader.peek() === "("){
            ident += reader.read();
            if (uriFns.indexOf(ident.toLowerCase()) > -1){
                tt = Tokens.URI;
                ident = this.readURI(ident);

                //didn't find a valid URL or there's no closing paren
                if (uriFns.indexOf(ident.toLowerCase()) > -1){
                    tt = Tokens.FUNCTION;
                }
            } else {
                tt = Tokens.FUNCTION;
            }
        } else if (reader.peek() === ":"){  //might be an IE function

            //IE-specific functions always being with progid:
            if (ident.toLowerCase() === "progid"){
                ident += reader.readTo("(");
                tt = Tokens.IE_FUNCTION;
            }
        }

        return this.createToken(tt, ident, startLine, startCol);
    },

    /**
     * Produces an IMPORTANT_SYM or CHAR token based on the specified information. The
     * first character is provided and the rest is read by the function to determine
     * the correct token to create.
     * @param {String} first The first character in the token.
     * @param {int} startLine The beginning line for the character.
     * @param {int} startCol The beginning column for the character.
     * @return {Object} A token object.
     * @method importantToken
     */
    importantToken: function(first, startLine, startCol){
        var reader      = this._reader,
            important   = first,
            tt          = Tokens.CHAR,
            temp,
            c;

        reader.mark();
        c = reader.read();

        while(c){

            //there can be a comment in here
            if (c === "/"){

                //if the next character isn't a star, then this isn't a valid !important token
                if (reader.peek() !== "*"){
                    break;
                } else {
                    temp = this.readComment(c);
                    if (temp === ""){    //broken!
                        break;
                    }
                }
            } else if (isWhitespace(c)){
                important += c + this.readWhitespace();
            } else if (/i/i.test(c)){
                temp = reader.readCount(8);
                if (/mportant/i.test(temp)){
                    important += c + temp;
                    tt = Tokens.IMPORTANT_SYM;

                }
                break;  //we're done
            } else {
                break;
            }

            c = reader.read();
        }

        if (tt === Tokens.CHAR){
            reader.reset();
            return this.charToken(first, startLine, startCol);
        } else {
            return this.createToken(tt, important, startLine, startCol);
        }


    },

    /**
     * Produces a NOT or CHAR token based on the specified information. The
     * first character is provided and the rest is read by the function to determine
     * the correct token to create.
     * @param {String} first The first character in the token.
     * @param {int} startLine The beginning line for the character.
     * @param {int} startCol The beginning column for the character.
     * @return {Object} A token object.
     * @method notToken
     */
    notToken: function(first, startLine, startCol){
        var reader      = this._reader,
            text        = first;

        reader.mark();
        text += reader.readCount(4);

        if (text.toLowerCase() === ":not("){
            return this.createToken(Tokens.NOT, text, startLine, startCol);
        } else {
            reader.reset();
            return this.charToken(first, startLine, startCol);
        }
    },

    /**
     * Produces a number token based on the given character
     * and location in the stream. This may return a token of
     * NUMBER, EMS, EXS, LENGTH, ANGLE, TIME, FREQ, DIMENSION,
     * or PERCENTAGE.
     * @param {String} first The first character for the token.
     * @param {int} startLine The beginning line for the character.
     * @param {int} startCol The beginning column for the character.
     * @return {Object} A token object.
     * @method numberToken
     */
    numberToken: function(first, startLine, startCol){
        var reader  = this._reader,
            value   = this.readNumber(first),
            ident,
            tt      = Tokens.NUMBER,
            c       = reader.peek();

        if (isIdentStart(c)){
            ident = this.readName(reader.read());
            value += ident;

            if (/^em$|^ex$|^px$|^gd$|^rem$|^vw$|^vh$|^vmax$|^vmin$|^ch$|^cm$|^mm$|^in$|^pt$|^pc$/i.test(ident)){
                tt = Tokens.LENGTH;
            } else if (/^deg|^rad$|^grad$/i.test(ident)){
                tt = Tokens.ANGLE;
            } else if (/^ms$|^s$/i.test(ident)){
                tt = Tokens.TIME;
            } else if (/^hz$|^khz$/i.test(ident)){
                tt = Tokens.FREQ;
            } else if (/^dpi$|^dpcm$/i.test(ident)){
                tt = Tokens.RESOLUTION;
            } else {
                tt = Tokens.DIMENSION;
            }

        } else if (c === "%"){
            value += reader.read();
            tt = Tokens.PERCENTAGE;
        }

        return this.createToken(tt, value, startLine, startCol);
    },

    /**
     * Produces a string token based on the given character
     * and location in the stream. Since strings may be indicated
     * by single or double quotes, a failure to match starting
     * and ending quotes results in an INVALID token being generated.
     * The first character in the string is passed in and then
     * the rest are read up to and including the final quotation mark.
     * @param {String} first The first character in the string.
     * @param {int} startLine The beginning line for the character.
     * @param {int} startCol The beginning column for the character.
     * @return {Object} A token object.
     * @method stringToken
     */
    stringToken: function(first, startLine, startCol){
        var delim   = first,
            string  = first,
            reader  = this._reader,
            prev    = first,
            tt      = Tokens.STRING,
            c       = reader.read();

        while(c){
            string += c;

            //if the delimiter is found with an escapement, we're done.
            if (c === delim && prev !== "\\"){
                break;
            }

            //if there's a newline without an escapement, it's an invalid string
            if (isNewLine(reader.peek()) && c !== "\\"){
                tt = Tokens.INVALID;
                break;
            }

            //save previous and get next
            prev = c;
            c = reader.read();
        }

        //if c is null, that means we're out of input and the string was never closed
        if (c === null){
            tt = Tokens.INVALID;
        }

        return this.createToken(tt, string, startLine, startCol);
    },

    unicodeRangeToken: function(first, startLine, startCol){
        var reader  = this._reader,
            value   = first,
            temp,
            tt      = Tokens.CHAR;

        //then it should be a unicode range
        if (reader.peek() === "+"){
            reader.mark();
            value += reader.read();
            value += this.readUnicodeRangePart(true);

            //ensure there's an actual unicode range here
            if (value.length === 2){
                reader.reset();
            } else {

                tt = Tokens.UNICODE_RANGE;

                //if there's a ? in the first part, there can't be a second part
                if (value.indexOf("?") === -1){

                    if (reader.peek() === "-"){
                        reader.mark();
                        temp = reader.read();
                        temp += this.readUnicodeRangePart(false);

                        //if there's not another value, back up and just take the first
                        if (temp.length === 1){
                            reader.reset();
                        } else {
                            value += temp;
                        }
                    }

                }
            }
        }

        return this.createToken(tt, value, startLine, startCol);
    },

    /**
     * Produces a S token based on the specified information. Since whitespace
     * may have multiple characters, this consumes all whitespace characters
     * into a single token.
     * @param {String} first The first character in the token.
     * @param {int} startLine The beginning line for the character.
     * @param {int} startCol The beginning column for the character.
     * @return {Object} A token object.
     * @method whitespaceToken
     */
    whitespaceToken: function(first, startLine, startCol){
        var value   = first + this.readWhitespace();
        return this.createToken(Tokens.S, value, startLine, startCol);
    },




    //-------------------------------------------------------------------------
    // Methods to read values from the string stream
    //-------------------------------------------------------------------------

    readUnicodeRangePart: function(allowQuestionMark){
        var reader  = this._reader,
            part = "",
            c       = reader.peek();

        //first read hex digits
        while(isHexDigit(c) && part.length < 6){
            reader.read();
            part += c;
            c = reader.peek();
        }

        //then read question marks if allowed
        if (allowQuestionMark){
            while(c === "?" && part.length < 6){
                reader.read();
                part += c;
                c = reader.peek();
            }
        }

        //there can't be any other characters after this point

        return part;
    },

    readWhitespace: function(){
        var reader  = this._reader,
            whitespace = "",
            c       = reader.peek();

        while(isWhitespace(c)){
            reader.read();
            whitespace += c;
            c = reader.peek();
        }

        return whitespace;
    },
    readNumber: function(first){
        var reader  = this._reader,
            number  = first,
            hasDot  = (first === "."),
            c       = reader.peek();


        while(c){
            if (isDigit(c)){
                number += reader.read();
            } else if (c === "."){
                if (hasDot){
                    break;
                } else {
                    hasDot = true;
                    number += reader.read();
                }
            } else {
                break;
            }

            c = reader.peek();
        }

        return number;
    },
    readString: function(){
        var reader  = this._reader,
            delim   = reader.read(),
            string  = delim,
            prev    = delim,
            c       = reader.peek();

        while(c){
            c = reader.read();
            string += c;

            //if the delimiter is found with an escapement, we're done.
            if (c === delim && prev !== "\\"){
                break;
            }

            //if there's a newline without an escapement, it's an invalid string
            if (isNewLine(reader.peek()) && c !== "\\"){
                string = "";
                break;
            }

            //save previous and get next
            prev = c;
            c = reader.peek();
        }

        //if c is null, that means we're out of input and the string was never closed
        if (c === null){
            string = "";
        }

        return string;
    },
    readURI: function(first){
        var reader  = this._reader,
            uri     = first,
            inner   = "",
            c       = reader.peek();

        reader.mark();

        //skip whitespace before
        while(c && isWhitespace(c)){
            reader.read();
            c = reader.peek();
        }

        //it's a string
        if (c === "'" || c === "\""){
            inner = this.readString();
        } else {
            inner = this.readURL();
        }

        c = reader.peek();

        //skip whitespace after
        while(c && isWhitespace(c)){
            reader.read();
            c = reader.peek();
        }

        //if there was no inner value or the next character isn't closing paren, it's not a URI
        if (inner === "" || c !== ")"){
            uri = first;
            reader.reset();
        } else {
            uri += inner + reader.read();
        }

        return uri;
    },
    readURL: function(){
        var reader  = this._reader,
            url     = "",
            c       = reader.peek();

        //TODO: Check for escape and nonascii
        while (/^[!#$%&\\*-~]$/.test(c)){
            url += reader.read();
            c = reader.peek();
        }

        return url;

    },
    readName: function(first){
        var reader  = this._reader,
            ident   = first || "",
            c       = reader.peek();

        while(true){
            if (c === "\\"){
                ident += this.readEscape(reader.read());
                c = reader.peek();
            } else if(c && isNameChar(c)){
                ident += reader.read();
                c = reader.peek();
            } else {
                break;
            }
        }

        return ident;
    },

    readEscape: function(first){
        var reader  = this._reader,
            cssEscape = first || "",
            i       = 0,
            c       = reader.peek();

        if (isHexDigit(c)){
            do {
                cssEscape += reader.read();
                c = reader.peek();
            } while(c && isHexDigit(c) && ++i < 6);
        }

        if (cssEscape.length === 3 && /\s/.test(c) ||
            cssEscape.length === 7 || cssEscape.length === 1){
                reader.read();
        } else {
            c = "";
        }

        return cssEscape + c;
    },

    readComment: function(first){
        var reader  = this._reader,
            comment = first || "",
            c       = reader.read();

        if (c === "*"){
            while(c){
                comment += c;

                //look for end of comment
                if (comment.length > 2 && c === "*" && reader.peek() === "/"){
                    comment += reader.read();
                    break;
                }

                c = reader.read();
            }

            return comment;
        } else {
            return "";
        }

    }
});

var Tokens  = [

    /*
     * The following token names are defined in CSS3 Grammar: http://www.w3.org/TR/css3-syntax/#lexical
     */

    //HTML-style comments
    { name: "CDO"},
    { name: "CDC"},

    //ignorables
    { name: "S", whitespace: true/*, channel: "ws"*/},
    { name: "COMMENT", comment: true, hide: true, channel: "comment" },

    //attribute equality
    { name: "INCLUDES", text: "~="},
    { name: "DASHMATCH", text: "|="},
    { name: "PREFIXMATCH", text: "^="},
    { name: "SUFFIXMATCH", text: "$="},
    { name: "SUBSTRINGMATCH", text: "*="},

    //identifier types
    { name: "STRING"},
    { name: "IDENT"},
    { name: "HASH"},

    //at-keywords
    { name: "IMPORT_SYM", text: "@import"},
    { name: "PAGE_SYM", text: "@page"},
    { name: "MEDIA_SYM", text: "@media"},
    { name: "FONT_FACE_SYM", text: "@font-face"},
    { name: "CHARSET_SYM", text: "@charset"},
    { name: "NAMESPACE_SYM", text: "@namespace"},
    { name: "VIEWPORT_SYM", text: ["@viewport", "@-ms-viewport", "@-o-viewport"]},
    { name: "DOCUMENT_SYM", text: ["@document", "@-moz-document"]},
    { name: "UNKNOWN_SYM" },
    //{ name: "ATKEYWORD"},

    //CSS3 animations
    { name: "KEYFRAMES_SYM", text: [ "@keyframes", "@-webkit-keyframes", "@-moz-keyframes", "@-o-keyframes" ] },

    //important symbol
    { name: "IMPORTANT_SYM"},

    //measurements
    { name: "LENGTH"},
    { name: "ANGLE"},
    { name: "TIME"},
    { name: "FREQ"},
    { name: "DIMENSION"},
    { name: "PERCENTAGE"},
    { name: "NUMBER"},

    //functions
    { name: "URI"},
    { name: "FUNCTION"},

    //Unicode ranges
    { name: "UNICODE_RANGE"},

    /*
     * The following token names are defined in CSS3 Selectors: http://www.w3.org/TR/css3-selectors/#selector-syntax
     */

    //invalid string
    { name: "INVALID"},

    //combinators
    { name: "PLUS", text: "+" },
    { name: "GREATER", text: ">"},
    { name: "COMMA", text: ","},
    { name: "TILDE", text: "~"},

    //modifier
    { name: "NOT"},

    /*
     * Defined in CSS3 Paged Media
     */
    { name: "TOPLEFTCORNER_SYM", text: "@top-left-corner"},
    { name: "TOPLEFT_SYM", text: "@top-left"},
    { name: "TOPCENTER_SYM", text: "@top-center"},
    { name: "TOPRIGHT_SYM", text: "@top-right"},
    { name: "TOPRIGHTCORNER_SYM", text: "@top-right-corner"},
    { name: "BOTTOMLEFTCORNER_SYM", text: "@bottom-left-corner"},
    { name: "BOTTOMLEFT_SYM", text: "@bottom-left"},
    { name: "BOTTOMCENTER_SYM", text: "@bottom-center"},
    { name: "BOTTOMRIGHT_SYM", text: "@bottom-right"},
    { name: "BOTTOMRIGHTCORNER_SYM", text: "@bottom-right-corner"},
    { name: "LEFTTOP_SYM", text: "@left-top"},
    { name: "LEFTMIDDLE_SYM", text: "@left-middle"},
    { name: "LEFTBOTTOM_SYM", text: "@left-bottom"},
    { name: "RIGHTTOP_SYM", text: "@right-top"},
    { name: "RIGHTMIDDLE_SYM", text: "@right-middle"},
    { name: "RIGHTBOTTOM_SYM", text: "@right-bottom"},

    /*
     * The following token names are defined in CSS3 Media Queries: http://www.w3.org/TR/css3-mediaqueries/#syntax
     */
    /*{ name: "MEDIA_ONLY", state: "media"},
    { name: "MEDIA_NOT", state: "media"},
    { name: "MEDIA_AND", state: "media"},*/
    { name: "RESOLUTION", state: "media"},

    /*
     * The following token names are not defined in any CSS specification but are used by the lexer.
     */

    //not a real token, but useful for stupid IE filters
    { name: "IE_FUNCTION" },

    //part of CSS3 grammar but not the Flex code
    { name: "CHAR" },

    //TODO: Needed?
    //Not defined as tokens, but might as well be
    {
        name: "PIPE",
        text: "|"
    },
    {
        name: "SLASH",
        text: "/"
    },
    {
        name: "MINUS",
        text: "-"
    },
    {
        name: "STAR",
        text: "*"
    },

    {
        name: "LBRACE",
        endChar: "}",
        text: "{"
    },
    {
        name: "RBRACE",
        text: "}"
    },
    {
        name: "LBRACKET",
        endChar: "]",
        text: "["
    },
    {
        name: "RBRACKET",
        text: "]"
    },
    {
        name: "EQUALS",
        text: "="
    },
    {
        name: "COLON",
        text: ":"
    },
    {
        name: "SEMICOLON",
        text: ";"
    },

    {
        name: "LPAREN",
        endChar: ")",
        text: "("
    },
    {
        name: "RPAREN",
        text: ")"
    },
    {
        name: "DOT",
        text: "."
    }
];

(function(){

    var nameMap = [],
        typeMap = Object.create(null);

    Tokens.UNKNOWN = -1;
    Tokens.unshift({name:"EOF"});
    for (var i=0, len = Tokens.length; i < len; i++){
        nameMap.push(Tokens[i].name);
        Tokens[Tokens[i].name] = i;
        if (Tokens[i].text){
            if (Tokens[i].text instanceof Array){
                for (var j=0; j < Tokens[i].text.length; j++){
                    typeMap[Tokens[i].text[j]] = i;
                }
            } else {
                typeMap[Tokens[i].text] = i;
            }
        }
    }

    Tokens.name = function(tt){
        return nameMap[tt];
    };

    Tokens.type = function(c){
        return typeMap[c] || -1;
    };

})();



//This file will likely change a lot! Very experimental!
var Validation = {

    validate: function(property, value){

        //normalize name
        var name        = property.toString().toLowerCase(),
            expression  = new PropertyValueIterator(value),
            spec        = Properties[name];

        if (!spec) {
            if (name.indexOf("-") !== 0){    //vendor prefixed are ok
                throw new ValidationError("Unknown property '" + property + "'.", property.line, property.col);
            }
        } else if (typeof spec !== "number"){

            //initialization
            if (typeof spec === "string"){
                if (spec.indexOf("||") > -1) {
                    this.groupProperty(spec, expression);
                } else {
                    this.singleProperty(spec, expression, 1);
                }

            } else if (spec.multi) {
                this.multiProperty(spec.multi, expression, spec.comma, spec.max || Infinity);
            } else if (typeof spec === "function") {
                spec(expression);
            }

        }

    },

    singleProperty: function(types, expression, max, partial) {

        var result      = false,
            value       = expression.value,
            count       = 0,
            part;

        while (expression.hasNext() && count < max) {
            result = ValidationTypes.isAny(expression, types);
            if (!result) {
                break;
            }
            count++;
        }

        if (!result) {
            if (expression.hasNext() && !expression.isFirst()) {
                part = expression.peek();
                throw new ValidationError("Expected end of value but found '" + part + "'.", part.line, part.col);
            } else {
                 throw new ValidationError("Expected (" + types + ") but found '" + value + "'.", value.line, value.col);
            }
        } else if (expression.hasNext()) {
            part = expression.next();
            throw new ValidationError("Expected end of value but found '" + part + "'.", part.line, part.col);
        }

    },

    multiProperty: function (types, expression, comma, max) {

        var result      = false,
            value       = expression.value,
            count       = 0,
            part;

        while(expression.hasNext() && !result && count < max) {
            if (ValidationTypes.isAny(expression, types)) {
                count++;
                if (!expression.hasNext()) {
                    result = true;

                } else if (comma) {
                    if (String(expression.peek()) === ",") {
                        part = expression.next();
                    } else {
                        break;
                    }
                }
            } else {
                break;

            }
        }

        if (!result) {
            if (expression.hasNext() && !expression.isFirst()) {
                part = expression.peek();
                throw new ValidationError("Expected end of value but found '" + part + "'.", part.line, part.col);
            } else {
                part = expression.previous();
                if (comma && String(part) === ",") {
                    throw new ValidationError("Expected end of value but found '" + part + "'.", part.line, part.col);
                } else {
                    throw new ValidationError("Expected (" + types + ") but found '" + value + "'.", value.line, value.col);
                }
            }

        } else if (expression.hasNext()) {
            part = expression.next();
            throw new ValidationError("Expected end of value but found '" + part + "'.", part.line, part.col);
        }

    },

    groupProperty: function (types, expression, comma) {

        var result      = false,
            value       = expression.value,
            typeCount   = types.split("||").length,
            groups      = { count: 0 },
            partial     = false,
            name,
            part;

        while(expression.hasNext() && !result) {
            name = ValidationTypes.isAnyOfGroup(expression, types);
            if (name) {

                //no dupes
                if (groups[name]) {
                    break;
                } else {
                    groups[name] = 1;
                    groups.count++;
                    partial = true;

                    if (groups.count === typeCount || !expression.hasNext()) {
                        result = true;
                    }
                }
            } else {
                break;
            }
        }

        if (!result) {
            if (partial && expression.hasNext()) {
                    part = expression.peek();
                    throw new ValidationError("Expected end of value but found '" + part + "'.", part.line, part.col);
            } else {
                throw new ValidationError("Expected (" + types + ") but found '" + value + "'.", value.line, value.col);
            }
        } else if (expression.hasNext()) {
            part = expression.next();
            throw new ValidationError("Expected end of value but found '" + part + "'.", part.line, part.col);
        }
    }



};
/**
 * Type to use when a validation error occurs.
 * @class ValidationError
 * @namespace parserlib.util
 * @constructor
 * @param {String} message The error message.
 * @param {int} line The line at which the error occurred.
 * @param {int} col The column at which the error occurred.
 */
function ValidationError(message, line, col){

    /**
     * The column at which the error occurred.
     * @type int
     * @property col
     */
    this.col = col;

    /**
     * The line at which the error occurred.
     * @type int
     * @property line
     */
    this.line = line;

    /**
     * The text representation of the unit.
     * @type String
     * @property text
     */
    this.message = message;

}

//inherit from Error
ValidationError.prototype = new Error();
//This file will likely change a lot! Very experimental!
var ValidationTypes = {

    isLiteral: function (part, literals) {
        var text = part.text.toString().toLowerCase(),
            args = literals.split(" | "),
            i, len, found = false;

        for (i=0,len=args.length; i < len && !found; i++){
            if (text === args[i].toLowerCase()){
                found = true;
            }
        }

        return found;
    },

    isSimple: function(type) {
        return !!this.simple[type];
    },

    isComplex: function(type) {
        return !!this.complex[type];
    },

    /**
     * Determines if the next part(s) of the given expression
     * are any of the given types.
     */
    isAny: function (expression, types) {
        var args = types.split(" | "),
            i, len, found = false;

        for (i=0,len=args.length; i < len && !found && expression.hasNext(); i++){
            found = this.isType(expression, args[i]);
        }

        return found;
    },

    /**
     * Determines if the next part(s) of the given expression
     * are one of a group.
     */
    isAnyOfGroup: function(expression, types) {
        var args = types.split(" || "),
            i, len, found = false;

        for (i=0,len=args.length; i < len && !found; i++){
            found = this.isType(expression, args[i]);
        }

        return found ? args[i-1] : false;
    },

    /**
     * Determines if the next part(s) of the given expression
     * are of a given type.
     */
    isType: function (expression, type) {
        var part = expression.peek(),
            result = false;

        if (type.charAt(0) !== "<") {
            result = this.isLiteral(part, type);
            if (result) {
                expression.next();
            }
        } else if (this.simple[type]) {
            result = this.simple[type](part);
            if (result) {
                expression.next();
            }
        } else {
            result = this.complex[type](expression);
        }

        return result;
    },



    simple: {
        __proto__: null,

        "<absolute-size>": function(part){
            return ValidationTypes.isLiteral(part, "xx-small | x-small | small | medium | large | x-large | xx-large");
        },

        "<attachment>": function(part){
            return ValidationTypes.isLiteral(part, "scroll | fixed | local");
        },

        "<attr>": function(part){
            return part.type === "function" && part.name === "attr";
        },

        "<bg-image>": function(part){
            return this["<image>"](part) || this["<gradient>"](part) ||  String(part) === "none";
        },

        "<gradient>": function(part) {
            return part.type === "function" && /^(?:\-(?:ms|moz|o|webkit)\-)?(?:repeating\-)?(?:radial\-|linear\-)?gradient/i.test(part);
        },

        "<box>": function(part){
            return ValidationTypes.isLiteral(part, "padding-box | border-box | content-box");
        },

        "<content>": function(part){
            return part.type === "function" && part.name === "content";
        },

        "<relative-size>": function(part){
            return ValidationTypes.isLiteral(part, "smaller | larger");
        },

        //any identifier
        "<ident>": function(part){
            return part.type === "identifier";
        },

        "<length>": function(part){
            if (part.type === "function" && /^(?:\-(?:ms|moz|o|webkit)\-)?calc/i.test(part)){
                return true;
            }else{
                return part.type === "length" || part.type === "number" || part.type === "integer" || String(part) === "0";
            }
        },

        "<color>": function(part){
            return part.type === "color" || String(part) === "transparent" || String(part) === "currentColor";
        },

        "<number>": function(part){
            return part.type === "number" || this["<integer>"](part);
        },

        "<integer>": function(part){
            return part.type === "integer";
        },

        "<line>": function(part){
            return part.type === "integer";
        },

        "<angle>": function(part){
            return part.type === "angle";
        },

        "<uri>": function(part){
            return part.type === "uri";
        },

        "<image>": function(part){
            return this["<uri>"](part);
        },

        "<percentage>": function(part){
            return part.type === "percentage" || String(part) === "0";
        },

        "<border-width>": function(part){
            return this["<length>"](part) || ValidationTypes.isLiteral(part, "thin | medium | thick");
        },

        "<border-style>": function(part){
            return ValidationTypes.isLiteral(part, "none | hidden | dotted | dashed | solid | double | groove | ridge | inset | outset");
        },

        "<content-sizing>": function(part){ // http://www.w3.org/TR/css3-sizing/#width-height-keywords
            return ValidationTypes.isLiteral(part, "fill-available | -moz-available | -webkit-fill-available | max-content | -moz-max-content | -webkit-max-content | min-content | -moz-min-content | -webkit-min-content | fit-content | -moz-fit-content | -webkit-fit-content");
        },

        "<margin-width>": function(part){
            return this["<length>"](part) || this["<percentage>"](part) || ValidationTypes.isLiteral(part, "auto");
        },

        "<padding-width>": function(part){
            return this["<length>"](part) || this["<percentage>"](part);
        },

        "<shape>": function(part){
            return part.type === "function" && (part.name === "rect" || part.name === "inset-rect");
        },

        "<time>": function(part) {
            return part.type === "time";
        },

        "<flex-grow>": function(part){
            return this["<number>"](part);
        },

        "<flex-shrink>": function(part){
            return this["<number>"](part);
        },

        "<width>": function(part){
            return this["<margin-width>"](part);
        },

        "<flex-basis>": function(part){
            return this["<width>"](part);
        },

        "<flex-direction>": function(part){
            return ValidationTypes.isLiteral(part, "row | row-reverse | column | column-reverse");
        },

        "<flex-wrap>": function(part){
            return ValidationTypes.isLiteral(part, "nowrap | wrap | wrap-reverse");
        },

        "<feature-tag-value>": function(part){
            return (part.type === "function" && /^[A-Z0-9]{4}$/i.test(part));
        }
    },

    complex: {
        __proto__: null,

        "<bg-position>": function(expression){
            var result  = false,
                numeric = "<percentage> | <length>",
                xDir    = "left | right",
                yDir    = "top | bottom",
                count = 0;

            while (expression.peek(count) && expression.peek(count).text !== ",") {
                count++;
            }

/*
<position> = [
  [ left | center | right | top | bottom | <percentage> | <length> ]
|
  [ left | center | right | <percentage> | <length> ]
  [ top | center | bottom | <percentage> | <length> ]
|
  [ center | [ left | right ] [ <percentage> | <length> ]? ] &&
  [ center | [ top | bottom ] [ <percentage> | <length> ]? ]
]
*/

            if (count < 3) {
                if (ValidationTypes.isAny(expression, xDir + " | center | " + numeric)) {
                        result = true;
                        ValidationTypes.isAny(expression, yDir + " | center | " + numeric);
                } else if (ValidationTypes.isAny(expression, yDir)) {
                        result = true;
                        ValidationTypes.isAny(expression, xDir + " | center");
                }
            } else {
                if (ValidationTypes.isAny(expression, xDir)) {
                    if (ValidationTypes.isAny(expression, yDir)) {
                        result = true;
                        ValidationTypes.isAny(expression, numeric);
                    } else if (ValidationTypes.isAny(expression, numeric)) {
                        if (ValidationTypes.isAny(expression, yDir)) {
                            result = true;
                            ValidationTypes.isAny(expression, numeric);
                        } else if (ValidationTypes.isAny(expression, "center")) {
                            result = true;
                        }
                    }
                } else if (ValidationTypes.isAny(expression, yDir)) {
                    if (ValidationTypes.isAny(expression, xDir)) {
                        result = true;
                        ValidationTypes.isAny(expression, numeric);
                    } else if (ValidationTypes.isAny(expression, numeric)) {
                        if (ValidationTypes.isAny(expression, xDir)) {
                                result = true;
                                ValidationTypes.isAny(expression, numeric);
                        } else if (ValidationTypes.isAny(expression, "center")) {
                            result = true;
                        }
                    }
                } else if (ValidationTypes.isAny(expression, "center")) {
                    if (ValidationTypes.isAny(expression, xDir + " | " + yDir)) {
                        result = true;
                        ValidationTypes.isAny(expression, numeric);
                    }
                }
            }

            return result;
        },

        "<bg-size>": function(expression){
            //<bg-size> = [ <length> | <percentage> | auto ]{1,2} | cover | contain
            var result  = false,
                numeric = "<percentage> | <length> | auto";

            if (ValidationTypes.isAny(expression, "cover | contain")) {
                result = true;
            } else if (ValidationTypes.isAny(expression, numeric)) {
                result = true;
                ValidationTypes.isAny(expression, numeric);
            }

            return result;
        },

        "<repeat-style>": function(expression){
            //repeat-x | repeat-y | [repeat | space | round | no-repeat]{1,2}
            var result  = false,
                values  = "repeat | space | round | no-repeat",
                part;

            if (expression.hasNext()){
                part = expression.next();

                if (ValidationTypes.isLiteral(part, "repeat-x | repeat-y")) {
                    result = true;
                } else if (ValidationTypes.isLiteral(part, values)) {
                    result = true;

                    if (expression.hasNext() && ValidationTypes.isLiteral(expression.peek(), values)) {
                        expression.next();
                    }
                }
            }

            return result;

        },

        "<shadow>": function(expression) {
            //inset? && [ <length>{2,4} && <color>? ]
            var result  = false,
                count   = 0,
                inset   = false,
                color   = false;

            if (expression.hasNext()) {

                if (ValidationTypes.isAny(expression, "inset")){
                    inset = true;
                }

                if (ValidationTypes.isAny(expression, "<color>")) {
                    color = true;
                }

                while (ValidationTypes.isAny(expression, "<length>") && count < 4) {
                    count++;
                }


                if (expression.hasNext()) {
                    if (!color) {
                        ValidationTypes.isAny(expression, "<color>");
                    }

                    if (!inset) {
                        ValidationTypes.isAny(expression, "inset");
                    }

                }

                result = (count >= 2 && count <= 4);

            }

            return result;
        },

        "<x-one-radius>": function(expression) {
            //[ <length> | <percentage> ] [ <length> | <percentage> ]?
            var result  = false,
                simple = "<length> | <percentage> | inherit";

            if (ValidationTypes.isAny(expression, simple)){
                result = true;
                ValidationTypes.isAny(expression, simple);
            }

            return result;
        },

        "<flex>": function(expression) {
            // http://www.w3.org/TR/2014/WD-css-flexbox-1-20140325/#flex-property
            // none | [ <flex-grow> <flex-shrink>? || <flex-basis> ]
            // Valid syntaxes, according to https://developer.mozilla.org/en-US/docs/Web/CSS/flex#Syntax
            // * none
            // * <flex-grow>
            // * <flex-basis>
            // * <flex-grow> <flex-basis>
            // * <flex-grow> <flex-shrink>
            // * <flex-grow> <flex-shrink> <flex-basis>
            // * inherit
            var part,
                result = false;
            if (ValidationTypes.isAny(expression, "none | inherit")) {
                result = true;
            } else {
                if (ValidationTypes.isType(expression, "<flex-grow>")) {
                    if (expression.peek()) {
                        if (ValidationTypes.isType(expression, "<flex-shrink>")) {
                            if (expression.peek()) {
                                result = ValidationTypes.isType(expression, "<flex-basis>");
                            } else {
                                result = true;
                            }
                        } else if (ValidationTypes.isType(expression, "<flex-basis>")) {
                            result = expression.peek() === null;
                        }
                    } else {
                        result = true;
                    }
                } else if (ValidationTypes.isType(expression, "<flex-basis>")) {
                    result = true;
                }
            }

            if (!result) {
                // Generate a more verbose error than "Expected <flex>..."
                part = expression.peek();
                throw new ValidationError("Expected (none | [ <flex-grow> <flex-shrink>? || <flex-basis> ]) but found '" + expression.value.text + "'.", part.line, part.col);
            }

            return result;
        }
    }
};

parserlib.css = {
__proto__           :null,
Colors              :Colors,
Combinator          :Combinator,
Parser              :Parser,
PropertyName        :PropertyName,
PropertyValue       :PropertyValue,
PropertyValuePart   :PropertyValuePart,
MediaFeature        :MediaFeature,
MediaQuery          :MediaQuery,
Selector            :Selector,
SelectorPart        :SelectorPart,
SelectorSubPart     :SelectorSubPart,
Specificity         :Specificity,
TokenStream         :TokenStream,
Tokens              :Tokens,
ValidationError     :ValidationError
};
})();

(function(){
/* jshint forin:false */
for(var prop in parserlib){
exports[prop] = parserlib[prop];
}
})();


/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var URL = __webpack_require__(24);
var URLUtils = __webpack_require__(56);

module.exports = Location;

function Location(window, href) {
  this._window = window;
  this._href = href;
}

Location.prototype = Object.create(URLUtils.prototype, {
  constructor: { value: Location },

  // Special behavior when href is set
  href: {
    get: function() { return this._href; },
    set: function(v) { this.assign(v); }
  },

  assign: { value: function(url) {
    // Resolve the new url against the current one
    // XXX:
    // This is not actually correct. It should be resolved against
    // the URL of the document of the script. For now, though, I only
    // support a single window and there is only one base url.
    // So this is good enough for now.
    var current = new URL(this._href);
    var newurl = current.resolve(url);

    // Save the new url
    this._href = newurl;

    // Start loading the new document!
    // XXX
    // This is just something hacked together.
    // The real algorithm is: http://www.whatwg.org/specs/web-apps/current-work/multipage/history.html#navigate
  }},

  replace: { value: function(url) {
    // XXX
    // Since we aren't tracking history yet, replace is the same as assign
    this.assign(url);
  }},

  reload: { value: function() {
    // XXX:
    // Actually, the spec is a lot more complicated than this
    this.assign(this.href);
  }},

  toString: { value: function() {
    return this.href;
  }}

});


/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// https://html.spec.whatwg.org/multipage/webappapis.html#navigatorid
var NavigatorID = Object.create(null, {
  appCodeName: { value: "Mozilla" },
  appName: { value: "Netscape" },
  appVersion: { value: "4.0" },
  platform: { value: "" },
  product: { value: "Gecko" },
  productSub: { value: "20100101" },
  userAgent: { value: "" },
  vendor: { value: "" },
  vendorSub: { value: "" },
  taintEnabled: { value: function() { return false; } }
});

module.exports = NavigatorID;


/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// https://html.spec.whatwg.org/multipage/webappapis.html#windowtimers
var WindowTimers = {
  setTimeout: setTimeout,
  clearTimeout: clearTimeout,
  setInterval: setInterval,
  clearInterval: clearInterval
};

module.exports = WindowTimers;


/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = {
  VALUE: 1, // The value of a Text, Comment or PI node changed
  ATTR: 2, // A new attribute was added or an attribute value and/or prefix changed
  REMOVE_ATTR: 3, // An attribute was removed
  REMOVE: 4, // A node was removed
  MOVE: 5, // A node was moved
  INSERT: 6 // A node (or a subtree of nodes) was inserted
};

/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.12.2
(function() {
  var InvalidStateError, NetworkError, ProgressEvent, SecurityError, SyntaxError, XMLHttpRequest, XMLHttpRequestEventTarget, XMLHttpRequestUpload, http, https, os, url,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  XMLHttpRequestEventTarget = (function() {
    function XMLHttpRequestEventTarget() {
      this.onloadstart = null;
      this.onprogress = null;
      this.onabort = null;
      this.onerror = null;
      this.onload = null;
      this.ontimeout = null;
      this.onloadend = null;
      this._listeners = {};
    }

    XMLHttpRequestEventTarget.prototype.onloadstart = null;

    XMLHttpRequestEventTarget.prototype.onprogress = null;

    XMLHttpRequestEventTarget.prototype.onabort = null;

    XMLHttpRequestEventTarget.prototype.onerror = null;

    XMLHttpRequestEventTarget.prototype.onload = null;

    XMLHttpRequestEventTarget.prototype.ontimeout = null;

    XMLHttpRequestEventTarget.prototype.onloadend = null;

    XMLHttpRequestEventTarget.prototype.addEventListener = function(eventType, listener) {
      var base;
      eventType = eventType.toLowerCase();
      (base = this._listeners)[eventType] || (base[eventType] = []);
      this._listeners[eventType].push(listener);
      return void 0;
    };

    XMLHttpRequestEventTarget.prototype.removeEventListener = function(eventType, listener) {
      var index;
      eventType = eventType.toLowerCase();
      if (this._listeners[eventType]) {
        index = this._listeners[eventType].indexOf(listener);
        if (index !== -1) {
          this._listeners[eventType].splice(index, 1);
        }
      }
      return void 0;
    };

    XMLHttpRequestEventTarget.prototype.dispatchEvent = function(event) {
      var eventType, j, len, listener, listeners;
      event.currentTarget = event.target = this;
      eventType = event.type;
      if (listeners = this._listeners[eventType]) {
        for (j = 0, len = listeners.length; j < len; j++) {
          listener = listeners[j];
          listener.call(this, event);
        }
      }
      if (listener = this["on" + eventType]) {
        listener.call(this, event);
      }
      return void 0;
    };

    return XMLHttpRequestEventTarget;

  })();

  http = __webpack_require__(88);

  https = __webpack_require__(89);

  os = __webpack_require__(90);

  url = __webpack_require__(40);

  XMLHttpRequest = (function(superClass) {
    extend(XMLHttpRequest, superClass);

    function XMLHttpRequest(options) {
      XMLHttpRequest.__super__.constructor.call(this);
      this.onreadystatechange = null;
      this._anonymous = options && options.anon;
      this.readyState = XMLHttpRequest.UNSENT;
      this.response = null;
      this.responseText = '';
      this.responseType = '';
      this.responseURL = '';
      this.status = 0;
      this.statusText = '';
      this.timeout = 0;
      this.upload = new XMLHttpRequestUpload(this);
      this._method = null;
      this._url = null;
      this._sync = false;
      this._headers = null;
      this._loweredHeaders = null;
      this._mimeOverride = null;
      this._request = null;
      this._response = null;
      this._responseParts = null;
      this._responseHeaders = null;
      this._aborting = null;
      this._error = null;
      this._loadedBytes = 0;
      this._totalBytes = 0;
      this._lengthComputable = false;
    }

    XMLHttpRequest.prototype.onreadystatechange = null;

    XMLHttpRequest.prototype.readyState = null;

    XMLHttpRequest.prototype.response = null;

    XMLHttpRequest.prototype.responseText = null;

    XMLHttpRequest.prototype.responseType = null;

    XMLHttpRequest.prototype.status = null;

    XMLHttpRequest.prototype.timeout = null;

    XMLHttpRequest.prototype.upload = null;

    XMLHttpRequest.prototype.open = function(method, url, async, user, password) {
      var xhrUrl;
      method = method.toUpperCase();
      if (method in this._restrictedMethods) {
        throw new SecurityError("HTTP method " + method + " is not allowed in XHR");
      }
      xhrUrl = this._parseUrl(url);
      if (async === void 0) {
        async = true;
      }
      switch (this.readyState) {
        case XMLHttpRequest.UNSENT:
        case XMLHttpRequest.OPENED:
        case XMLHttpRequest.DONE:
          null;
          break;
        case XMLHttpRequest.HEADERS_RECEIVED:
        case XMLHttpRequest.LOADING:
          null;
      }
      this._method = method;
      this._url = xhrUrl;
      this._sync = !async;
      this._headers = {};
      this._loweredHeaders = {};
      this._mimeOverride = null;
      this._setReadyState(XMLHttpRequest.OPENED);
      this._request = null;
      this._response = null;
      this.status = 0;
      this.statusText = '';
      this._responseParts = [];
      this._responseHeaders = null;
      this._loadedBytes = 0;
      this._totalBytes = 0;
      this._lengthComputable = false;
      return void 0;
    };

    XMLHttpRequest.prototype.setRequestHeader = function(name, value) {
      var loweredName;
      if (this.readyState !== XMLHttpRequest.OPENED) {
        throw new InvalidStateError("XHR readyState must be OPENED");
      }
      loweredName = name.toLowerCase();
      if (this._restrictedHeaders[loweredName] || /^sec\-/.test(loweredName) || /^proxy-/.test(loweredName)) {
        console.warn("Refused to set unsafe header \"" + name + "\"");
        return void 0;
      }
      value = value.toString();
      if (loweredName in this._loweredHeaders) {
        name = this._loweredHeaders[loweredName];
        this._headers[name] = this._headers[name] + ', ' + value;
      } else {
        this._loweredHeaders[loweredName] = name;
        this._headers[name] = value;
      }
      return void 0;
    };

    XMLHttpRequest.prototype.send = function(data) {
      if (this.readyState !== XMLHttpRequest.OPENED) {
        throw new InvalidStateError("XHR readyState must be OPENED");
      }
      if (this._request) {
        throw new InvalidStateError("send() already called");
      }
      switch (this._url.protocol) {
        case 'file:':
          this._sendFile(data);
          break;
        case 'http:':
        case 'https:':
          this._sendHttp(data);
          break;
        default:
          throw new NetworkError("Unsupported protocol " + this._url.protocol);
      }
      return void 0;
    };

    XMLHttpRequest.prototype.abort = function() {
      if (!this._request) {
        return;
      }
      this._request.abort();
      this._setError();
      this._dispatchProgress('abort');
      this._dispatchProgress('loadend');
      return void 0;
    };

    XMLHttpRequest.prototype.getResponseHeader = function(name) {
      var loweredName;
      if (!this._responseHeaders) {
        return null;
      }
      loweredName = name.toLowerCase();
      if (loweredName in this._responseHeaders) {
        return this._responseHeaders[loweredName];
      } else {
        return null;
      }
    };

    XMLHttpRequest.prototype.getAllResponseHeaders = function() {
      var lines, name, value;
      if (!this._responseHeaders) {
        return '';
      }
      lines = (function() {
        var ref, results;
        ref = this._responseHeaders;
        results = [];
        for (name in ref) {
          value = ref[name];
          results.push(name + ": " + value);
        }
        return results;
      }).call(this);
      return lines.join("\r\n");
    };

    XMLHttpRequest.prototype.overrideMimeType = function(newMimeType) {
      if (this.readyState === XMLHttpRequest.LOADING || this.readyState === XMLHttpRequest.DONE) {
        throw new InvalidStateError("overrideMimeType() not allowed in LOADING or DONE");
      }
      this._mimeOverride = newMimeType.toLowerCase();
      return void 0;
    };

    XMLHttpRequest.prototype.nodejsSet = function(options) {
      var baseUrl, parsedUrl;
      if ('httpAgent' in options) {
        this.nodejsHttpAgent = options.httpAgent;
      }
      if ('httpsAgent' in options) {
        this.nodejsHttpsAgent = options.httpsAgent;
      }
      if ('baseUrl' in options) {
        baseUrl = options.baseUrl;
        if (baseUrl !== null) {
          parsedUrl = url.parse(baseUrl, false, true);
          if (!parsedUrl.protocol) {
            throw new SyntaxError("baseUrl must be an absolute URL");
          }
        }
        this.nodejsBaseUrl = baseUrl;
      }
      return void 0;
    };

    XMLHttpRequest.nodejsSet = function(options) {
      XMLHttpRequest.prototype.nodejsSet(options);
      return void 0;
    };

    XMLHttpRequest.prototype.UNSENT = 0;

    XMLHttpRequest.UNSENT = 0;

    XMLHttpRequest.prototype.OPENED = 1;

    XMLHttpRequest.OPENED = 1;

    XMLHttpRequest.prototype.HEADERS_RECEIVED = 2;

    XMLHttpRequest.HEADERS_RECEIVED = 2;

    XMLHttpRequest.prototype.LOADING = 3;

    XMLHttpRequest.LOADING = 3;

    XMLHttpRequest.prototype.DONE = 4;

    XMLHttpRequest.DONE = 4;

    XMLHttpRequest.prototype.nodejsHttpAgent = http.globalAgent;

    XMLHttpRequest.prototype.nodejsHttpsAgent = https.globalAgent;

    XMLHttpRequest.prototype.nodejsBaseUrl = null;

    XMLHttpRequest.prototype._restrictedMethods = {
      CONNECT: true,
      TRACE: true,
      TRACK: true
    };

    XMLHttpRequest.prototype._restrictedHeaders = {
      'accept-charset': true,
      'accept-encoding': true,
      'access-control-request-headers': true,
      'access-control-request-method': true,
      connection: true,
      'content-length': true,
      cookie: true,
      cookie2: true,
      date: true,
      dnt: true,
      expect: true,
      host: true,
      'keep-alive': true,
      origin: true,
      referer: true,
      te: true,
      trailer: true,
      'transfer-encoding': true,
      upgrade: true,
      'user-agent': true,
      via: true
    };

    XMLHttpRequest.prototype._privateHeaders = {
      'set-cookie': true,
      'set-cookie2': true
    };

    XMLHttpRequest.prototype._userAgent = ("Mozilla/5.0 (" + (os.type()) + " " + (os.arch()) + ") ") + ("node.js/" + process.versions.node + " v8/" + process.versions.v8);

    XMLHttpRequest.prototype._setReadyState = function(newReadyState) {
      var event;
      this.readyState = newReadyState;
      event = new ProgressEvent('readystatechange');
      this.dispatchEvent(event);
      return void 0;
    };

    XMLHttpRequest.prototype._sendFile = function() {
      if (this._url.method !== 'GET') {
        throw new NetworkError('The file protocol only supports GET');
      }
      throw new Error("Protocol file: not implemented");
    };

    XMLHttpRequest.prototype._sendHttp = function(data) {
      if (this._sync) {
        throw new Error("Synchronous XHR processing not implemented");
      }
      if ((data != null) && (this._method === 'GET' || this._method === 'HEAD')) {
        console.warn("Discarding entity body for " + this._method + " requests");
        data = null;
      } else {
        data || (data = '');
      }
      this.upload._setData(data);
      this._finalizeHeaders();
      this._sendHxxpRequest();
      return void 0;
    };

    XMLHttpRequest.prototype._sendHxxpRequest = function() {
      var agent, hxxp, request;
      if (this._url.protocol === 'http:') {
        hxxp = http;
        agent = this.nodejsHttpAgent;
      } else {
        hxxp = https;
        agent = this.nodejsHttpsAgent;
      }
      request = hxxp.request({
        hostname: this._url.hostname,
        port: this._url.port,
        path: this._url.path,
        auth: this._url.auth,
        method: this._method,
        headers: this._headers,
        agent: agent
      });
      this._request = request;
      if (this.timeout) {
        request.setTimeout(this.timeout, (function(_this) {
          return function() {
            return _this._onHttpTimeout(request);
          };
        })(this));
      }
      request.on('response', (function(_this) {
        return function(response) {
          return _this._onHttpResponse(request, response);
        };
      })(this));
      request.on('error', (function(_this) {
        return function(error) {
          return _this._onHttpRequestError(request, error);
        };
      })(this));
      this.upload._startUpload(request);
      if (this._request === request) {
        this._dispatchProgress('loadstart');
      }
      return void 0;
    };

    XMLHttpRequest.prototype._finalizeHeaders = function() {
      this._headers['Connection'] = 'keep-alive';
      this._headers['Host'] = this._url.host;
      if (this._anonymous) {
        this._headers['Referer'] = 'about:blank';
      }
      this._headers['User-Agent'] = this._userAgent;
      this.upload._finalizeHeaders(this._headers, this._loweredHeaders);
      return void 0;
    };

    XMLHttpRequest.prototype._onHttpResponse = function(request, response) {
      var lengthString;
      if (this._request !== request) {
        return;
      }
      switch (response.statusCode) {
        case 301:
        case 302:
        case 303:
        case 307:
        case 308:
          this._url = this._parseUrl(response.headers['location']);
          this._method = 'GET';
          if ('content-type' in this._loweredHeaders) {
            delete this._headers[this._loweredHeaders['content-type']];
            delete this._loweredHeaders['content-type'];
          }
          if ('Content-Type' in this._headers) {
            delete this._headers['Content-Type'];
          }
          delete this._headers['Content-Length'];
          this.upload._reset();
          this._finalizeHeaders();
          this._sendHxxpRequest();
          return;
      }
      this._response = response;
      this._response.on('data', (function(_this) {
        return function(data) {
          return _this._onHttpResponseData(response, data);
        };
      })(this));
      this._response.on('end', (function(_this) {
        return function() {
          return _this._onHttpResponseEnd(response);
        };
      })(this));
      this._response.on('close', (function(_this) {
        return function() {
          return _this._onHttpResponseClose(response);
        };
      })(this));
      this.responseURL = this._url.href.split('#')[0];
      this.status = this._response.statusCode;
      this.statusText = http.STATUS_CODES[this.status];
      this._parseResponseHeaders(response);
      if (lengthString = this._responseHeaders['content-length']) {
        this._totalBytes = parseInt(lengthString);
        this._lengthComputable = true;
      } else {
        this._lengthComputable = false;
      }
      return this._setReadyState(XMLHttpRequest.HEADERS_RECEIVED);
    };

    XMLHttpRequest.prototype._onHttpResponseData = function(response, data) {
      if (this._response !== response) {
        return;
      }
      this._responseParts.push(data);
      this._loadedBytes += data.length;
      if (this.readyState !== XMLHttpRequest.LOADING) {
        this._setReadyState(XMLHttpRequest.LOADING);
      }
      return this._dispatchProgress('progress');
    };

    XMLHttpRequest.prototype._onHttpResponseEnd = function(response) {
      if (this._response !== response) {
        return;
      }
      this._parseResponse();
      this._request = null;
      this._response = null;
      this._setReadyState(XMLHttpRequest.DONE);
      this._dispatchProgress('load');
      return this._dispatchProgress('loadend');
    };

    XMLHttpRequest.prototype._onHttpResponseClose = function(response) {
      var request;
      if (this._response !== response) {
        return;
      }
      request = this._request;
      this._setError();
      request.abort();
      this._setReadyState(XMLHttpRequest.DONE);
      this._dispatchProgress('error');
      return this._dispatchProgress('loadend');
    };

    XMLHttpRequest.prototype._onHttpTimeout = function(request) {
      if (this._request !== request) {
        return;
      }
      this._setError();
      request.abort();
      this._setReadyState(XMLHttpRequest.DONE);
      this._dispatchProgress('timeout');
      return this._dispatchProgress('loadend');
    };

    XMLHttpRequest.prototype._onHttpRequestError = function(request, error) {
      if (this._request !== request) {
        return;
      }
      this._setError();
      request.abort();
      this._setReadyState(XMLHttpRequest.DONE);
      this._dispatchProgress('error');
      return this._dispatchProgress('loadend');
    };

    XMLHttpRequest.prototype._dispatchProgress = function(eventType) {
      var event;
      event = new ProgressEvent(eventType);
      event.lengthComputable = this._lengthComputable;
      event.loaded = this._loadedBytes;
      event.total = this._totalBytes;
      this.dispatchEvent(event);
      return void 0;
    };

    XMLHttpRequest.prototype._setError = function() {
      this._request = null;
      this._response = null;
      this._responseHeaders = null;
      this._responseParts = null;
      return void 0;
    };

    XMLHttpRequest.prototype._parseUrl = function(urlString) {
      var absoluteUrlString, index, password, user, xhrUrl;
      if (this.nodejsBaseUrl === null) {
        absoluteUrlString = urlString;
      } else {
        absoluteUrlString = url.resolve(this.nodejsBaseUrl, urlString);
      }
      xhrUrl = url.parse(absoluteUrlString, false, true);
      xhrUrl.hash = null;
      if (xhrUrl.auth && ((typeof user !== "undefined" && user !== null) || (typeof password !== "undefined" && password !== null))) {
        index = xhrUrl.auth.indexOf(':');
        if (index === -1) {
          if (!user) {
            user = xhrUrl.auth;
          }
        } else {
          if (!user) {
            user = xhrUrl.substring(0, index);
          }
          if (!password) {
            password = xhrUrl.substring(index + 1);
          }
        }
      }
      if (user || password) {
        xhrUrl.auth = user + ":" + password;
      }
      return xhrUrl;
    };

    XMLHttpRequest.prototype._parseResponseHeaders = function(response) {
      var loweredName, name, ref, value;
      this._responseHeaders = {};
      ref = response.headers;
      for (name in ref) {
        value = ref[name];
        loweredName = name.toLowerCase();
        if (this._privateHeaders[loweredName]) {
          continue;
        }
        if (this._mimeOverride !== null && loweredName === 'content-type') {
          value = this._mimeOverride;
        }
        this._responseHeaders[loweredName] = value;
      }
      if (this._mimeOverride !== null && !('content-type' in this._responseHeaders)) {
        this._responseHeaders['content-type'] = this._mimeOverride;
      }
      return void 0;
    };

    XMLHttpRequest.prototype._parseResponse = function() {
      var arrayBuffer, buffer, i, j, jsonError, ref, view;
      if (Buffer.concat) {
        buffer = Buffer.concat(this._responseParts);
      } else {
        buffer = this._concatBuffers(this._responseParts);
      }
      this._responseParts = null;
      switch (this.responseType) {
        case 'text':
          this._parseTextResponse(buffer);
          break;
        case 'json':
          this.responseText = null;
          try {
            this.response = JSON.parse(buffer.toString('utf-8'));
          } catch (error1) {
            jsonError = error1;
            this.response = null;
          }
          break;
        case 'buffer':
          this.responseText = null;
          this.response = buffer;
          break;
        case 'arraybuffer':
          this.responseText = null;
          arrayBuffer = new ArrayBuffer(buffer.length);
          view = new Uint8Array(arrayBuffer);
          for (i = j = 0, ref = buffer.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
            view[i] = buffer[i];
          }
          this.response = arrayBuffer;
          break;
        default:
          this._parseTextResponse(buffer);
      }
      return void 0;
    };

    XMLHttpRequest.prototype._parseTextResponse = function(buffer) {
      var e;
      try {
        this.responseText = buffer.toString(this._parseResponseEncoding());
      } catch (error1) {
        e = error1;
        this.responseText = buffer.toString('binary');
      }
      this.response = this.responseText;
      return void 0;
    };

    XMLHttpRequest.prototype._parseResponseEncoding = function() {
      var contentType, encoding, match;
      encoding = null;
      if (contentType = this._responseHeaders['content-type']) {
        if (match = /\;\s*charset\=(.*)$/.exec(contentType)) {
          return match[1];
        }
      }
      return 'utf-8';
    };

    XMLHttpRequest.prototype._concatBuffers = function(buffers) {
      var buffer, j, k, len, len1, length, target;
      if (buffers.length === 0) {
        return new Buffer(0);
      }
      if (buffers.length === 1) {
        return buffers[0];
      }
      length = 0;
      for (j = 0, len = buffers.length; j < len; j++) {
        buffer = buffers[j];
        length += buffer.length;
      }
      target = new Buffer(length);
      length = 0;
      for (k = 0, len1 = buffers.length; k < len1; k++) {
        buffer = buffers[k];
        buffer.copy(target, length);
        length += buffer.length;
      }
      return target;
    };

    return XMLHttpRequest;

  })(XMLHttpRequestEventTarget);

  module.exports = XMLHttpRequest;

  XMLHttpRequest.XMLHttpRequest = XMLHttpRequest;

  SecurityError = (function(superClass) {
    extend(SecurityError, superClass);

    function SecurityError() {
      SecurityError.__super__.constructor.apply(this, arguments);
    }

    return SecurityError;

  })(Error);

  XMLHttpRequest.SecurityError = SecurityError;

  InvalidStateError = (function(superClass) {
    extend(InvalidStateError, superClass);

    function InvalidStateError() {
      InvalidStateError.__super__.constructor.apply(this, arguments);
    }

    return InvalidStateError;

  })(Error);

  InvalidStateError = (function(superClass) {
    extend(InvalidStateError, superClass);

    function InvalidStateError() {
      return InvalidStateError.__super__.constructor.apply(this, arguments);
    }

    return InvalidStateError;

  })(Error);

  XMLHttpRequest.InvalidStateError = InvalidStateError;

  NetworkError = (function(superClass) {
    extend(NetworkError, superClass);

    function NetworkError() {
      NetworkError.__super__.constructor.apply(this, arguments);
    }

    return NetworkError;

  })(Error);

  XMLHttpRequest.SyntaxError = SyntaxError;

  SyntaxError = (function(superClass) {
    extend(SyntaxError, superClass);

    function SyntaxError() {
      SyntaxError.__super__.constructor.apply(this, arguments);
    }

    return SyntaxError;

  })(Error);

  ProgressEvent = (function() {
    function ProgressEvent(type) {
      this.type = type;
      this.target = null;
      this.currentTarget = null;
      this.lengthComputable = false;
      this.loaded = 0;
      this.total = 0;
    }

    ProgressEvent.prototype.bubbles = false;

    ProgressEvent.prototype.cancelable = false;

    ProgressEvent.prototype.target = null;

    ProgressEvent.prototype.loaded = null;

    ProgressEvent.prototype.lengthComputable = null;

    ProgressEvent.prototype.total = null;

    return ProgressEvent;

  })();

  XMLHttpRequest.ProgressEvent = ProgressEvent;

  XMLHttpRequestUpload = (function(superClass) {
    extend(XMLHttpRequestUpload, superClass);

    function XMLHttpRequestUpload(request) {
      XMLHttpRequestUpload.__super__.constructor.call(this);
      this._request = request;
      this._reset();
    }

    XMLHttpRequestUpload.prototype._reset = function() {
      this._contentType = null;
      this._body = null;
      return void 0;
    };

    XMLHttpRequestUpload.prototype._setData = function(data) {
      var body, i, j, k, offset, ref, ref1, view;
      if (typeof data === 'undefined' || data === null) {
        return;
      }
      if (typeof data === 'string') {
        if (data.length !== 0) {
          this._contentType = 'text/plain;charset=UTF-8';
        }
        this._body = new Buffer(data, 'utf8');
      } else if (Buffer.isBuffer(data)) {
        this._body = data;
      } else if (data instanceof ArrayBuffer) {
        body = new Buffer(data.byteLength);
        view = new Uint8Array(data);
        for (i = j = 0, ref = data.byteLength; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
          body[i] = view[i];
        }
        this._body = body;
      } else if (data.buffer && data.buffer instanceof ArrayBuffer) {
        body = new Buffer(data.byteLength);
        offset = data.byteOffset;
        view = new Uint8Array(data.buffer);
        for (i = k = 0, ref1 = data.byteLength; 0 <= ref1 ? k < ref1 : k > ref1; i = 0 <= ref1 ? ++k : --k) {
          body[i] = view[i + offset];
        }
        this._body = body;
      } else {
        throw new Error("Unsupported send() data " + data);
      }
      return void 0;
    };

    XMLHttpRequestUpload.prototype._finalizeHeaders = function(headers, loweredHeaders) {
      if (this._contentType) {
        if (!('content-type' in loweredHeaders)) {
          headers['Content-Type'] = this._contentType;
        }
      }
      if (this._body) {
        headers['Content-Length'] = this._body.length.toString();
      }
      return void 0;
    };

    XMLHttpRequestUpload.prototype._startUpload = function(request) {
      if (this._body) {
        request.write(this._body);
      }
      request.end();
      return void 0;
    };

    return XMLHttpRequestUpload;

  })(XMLHttpRequestEventTarget);

  XMLHttpRequest.XMLHttpRequestUpload = XMLHttpRequestUpload;

}).call(this);


/***/ }),
/* 88 */
/***/ (function(module, exports) {

module.exports = require("http");

/***/ }),
/* 89 */
/***/ (function(module, exports) {

module.exports = require("https");

/***/ }),
/* 90 */
/***/ (function(module, exports) {

module.exports = require("os");

/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(2))(372);

/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(1);
var core_1 = __webpack_require__(0);
var platform_server_1 = __webpack_require__(34);
var animations_1 = __webpack_require__(38);
var app_module_shared_1 = __webpack_require__(93);
var app_component_1 = __webpack_require__(123);
var AppModule = /** @class */ (function () {
    function AppModule() {
    }
    AppModule = tslib_1.__decorate([
        core_1.NgModule({
            bootstrap: [app_component_1.AppComponent],
            declarations: [app_component_1.AppComponent],
            imports: [
                platform_server_1.ServerModule,
                // As explained here, animations module used document hence we need Noop animations module on server
                // https://github.com/angular/angular/issues/14784
                animations_1.NoopAnimationsModule,
                app_module_shared_1.AppModuleShared,
            ]
        })
    ], AppModule);
    return AppModule;
}());
exports.AppModule = AppModule;


/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(1);
var core_1 = __webpack_require__(0);
var platform_browser_1 = __webpack_require__(6);
var shared_module_1 = __webpack_require__(65);
var core_module_1 = __webpack_require__(115);
var home_module_1 = __webpack_require__(116);
var app_routes_1 = __webpack_require__(121);
var app_service_1 = __webpack_require__(122);
var AppModuleShared = /** @class */ (function () {
    function AppModuleShared() {
    }
    AppModuleShared = tslib_1.__decorate([
        core_1.NgModule({
            imports: [
                platform_browser_1.BrowserModule,
                app_routes_1.routing,
                core_module_1.CoreModule.forRoot(),
                shared_module_1.SharedModule.forRoot(),
                home_module_1.HomeModule,
            ],
            providers: [
                app_service_1.AppService
            ],
            exports: [
                shared_module_1.SharedModule
            ]
        })
    ], AppModuleShared);
    return AppModuleShared;
}());
exports.AppModuleShared = AppModuleShared;


/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(1);
var core_1 = __webpack_require__(0);
var PageHeadingComponent = /** @class */ (function () {
    function PageHeadingComponent() {
    }
    tslib_1.__decorate([
        core_1.Input(),
        tslib_1.__metadata("design:type", String)
    ], PageHeadingComponent.prototype, "text", void 0);
    PageHeadingComponent = tslib_1.__decorate([
        core_1.Component({
            selector: 'appc-page-heading',
            template: "<h4>{{text}}</h4>"
        })
    ], PageHeadingComponent);
    return PageHeadingComponent;
}());
exports.PageHeadingComponent = PageHeadingComponent;


/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(1);
var core_1 = __webpack_require__(0);
var form_control_service_1 = __webpack_require__(61);
var DynamicFormComponent = /** @class */ (function () {
    function DynamicFormComponent(_controlService) {
        this._controlService = _controlService;
        this.controls = [];
        this.btnText = 'Submit'; // Default value at least
        this.formClass = 'form-horizontal';
        // Note: don't keep name of output events as same as native events such as submit etc.
        this.formsubmit = new core_1.EventEmitter();
    }
    DynamicFormComponent.prototype.ngOnInit = function () {
        var sortedControls = this.controls.sort(function (a, b) { return a.order - b.order; });
        this.form = this._controlService.toControlGroup(sortedControls);
    };
    DynamicFormComponent.prototype.onSubmit = function () {
        this.formsubmit.emit(this.form.value);
    };
    tslib_1.__decorate([
        core_1.Input(),
        tslib_1.__metadata("design:type", Array)
    ], DynamicFormComponent.prototype, "controls", void 0);
    tslib_1.__decorate([
        core_1.Input(),
        tslib_1.__metadata("design:type", Object)
    ], DynamicFormComponent.prototype, "btnText", void 0);
    tslib_1.__decorate([
        core_1.Input(),
        tslib_1.__metadata("design:type", Object)
    ], DynamicFormComponent.prototype, "formClass", void 0);
    tslib_1.__decorate([
        core_1.Output(),
        tslib_1.__metadata("design:type", core_1.EventEmitter)
    ], DynamicFormComponent.prototype, "formsubmit", void 0);
    DynamicFormComponent = tslib_1.__decorate([
        core_1.Component({
            selector: 'appc-dynamic-form',
            template: __webpack_require__(96)
        }),
        tslib_1.__metadata("design:paramtypes", [form_control_service_1.FormControlService])
    ], DynamicFormComponent);
    return DynamicFormComponent;
}());
exports.DynamicFormComponent = DynamicFormComponent;


/***/ }),
/* 96 */
/***/ (function(module, exports) {

module.exports = "<form class=\"{{formClass}}\" (ngSubmit)=\"onSubmit()\" [formGroup]=\"form\" role=\"form\" #f>\r\n    <appc-dynamic-control *ngFor=\"let ctrl of controls\" [control]=\"ctrl\" [form]=\"form\"></appc-dynamic-control>\r\n\r\n    <button type=\"submit\" class=\"btn btn-primary pull-right\" [disabled]=\"!form.valid\">{{btnText}}</button>\r\n</form>";

/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(1);
// tslint:disable
var core_1 = __webpack_require__(0);
var forms_1 = __webpack_require__(16);
var control_base_1 = __webpack_require__(32);
var DynamicFormControlComponent = /** @class */ (function () {
    function DynamicFormControlComponent() {
    }
    Object.defineProperty(DynamicFormControlComponent.prototype, "valid", {
        get: function () {
            return this.form.controls[this.control.key].valid;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DynamicFormControlComponent.prototype, "invalid", {
        get: function () {
            return !this.form.controls[this.control.key].valid && this.form.controls[this.control.key].touched;
        },
        enumerable: true,
        configurable: true
    });
    tslib_1.__decorate([
        core_1.Input(),
        tslib_1.__metadata("design:type", control_base_1.ControlBase)
    ], DynamicFormControlComponent.prototype, "control", void 0);
    tslib_1.__decorate([
        core_1.Input(),
        tslib_1.__metadata("design:type", forms_1.FormGroup)
    ], DynamicFormControlComponent.prototype, "form", void 0);
    DynamicFormControlComponent = tslib_1.__decorate([
        core_1.Component({
            selector: 'appc-dynamic-control',
            template: __webpack_require__(98)
        }),
        tslib_1.__metadata("design:paramtypes", [])
    ], DynamicFormControlComponent);
    return DynamicFormControlComponent;
}());
exports.DynamicFormControlComponent = DynamicFormControlComponent;


/***/ }),
/* 98 */
/***/ (function(module, exports) {

module.exports = "<!--tslint:disable-->\r\n<div #f=\"ngForm\" [formGroup]=\"form\" [ngSwitch]=\"control.type\" class=\"form-group {{control.class}}\" [class.has-danger]=\"invalid\"\r\n    [class.has-success]=\"valid\" [class.form-check]=\"control.type === 'checkbox'\">\r\n\r\n    <label *ngSwitchCase=\"'dropdown'\" [attr.for]=\"control.key\" class=\"col-form-label\">{{control.label}}</label>\r\n    <select *ngSwitchCase=\"'dropdown'\" [id]=\"control.key\" [formControlName]=\"control.key\" [class.form-control-success]=\"valid\"\r\n        [class.form-control-danger]=\"invalid\" class=\"form-control\">\r\n<option *ngFor=\"let opt of control.options\" [value]=\"opt.key\">{{opt.value}}</option>\r\n</select>\r\n    <label *ngSwitchCase=\"'checkbox'\" [attr.for]=\"control.key\" class=\"form-check-label\">\r\n    <input #ck *ngSwitchCase=\"'checkbox'\" (change)=\"control.value = ck.checked\" [id]=\"control.key\" [formControlName]=\"control.key\"\r\n        [type]=\"control.type\" class=\"form-check-input\">\r\n        {{control.label}}\r\n    </label>\r\n\r\n    <!--This is not the switch case because of multiple control types-->\r\n    <label *ngIf=\"control.type === 'textbox' || control.type === 'email' || control.type === 'password'\" [attr.for]=\"control.key\"\r\n        class=\"col-form-label\">{{control.label}}</label>\r\n    <input *ngIf=\"control.type === 'textbox' || control.type === 'email' || control.type === 'password'\" [id]=\"control.key\" [formControlName]=\"control.key\"\r\n        [type]=\"control.type\" [placeholder]=\"control.placeholder\" [class.form-control-success]=\"valid\" [class.form-control-danger]=\"invalid\"\r\n        class=\"form-control\">\r\n\r\n    <!--Textarea-->\r\n    <label *ngIf=\"control.type === 'textarea'\" [for]=\"control.key\">{{control.label}}</label>\r\n    <textarea *ngIf=\"control.type === 'textarea'\" class=\" form-control\" [id]=\"control.key\" rows=\"3\" [formControlName]=\"control.key\"\r\n        [class.form-control-success]=\"valid\" [class.form-control-danger]=\"invalid\"></textarea>\r\n\r\n    <!--Checkbox-->\r\n    <label *ngSwitchCase=\"'checkbox'\" [attr.for]=\"control.key\" class=\"custom-control custom-checkbox\">\r\n    <input *ngSwitchCase=\"'checkbox'\" [id]=\"control.key\" [formControlName]=\"control.key\" \r\n        type=\"checkbox\" class=\"custom-control-input\" >\r\n        <span class=\"custom-control-indicator\"></span>\r\n        <span class=\"custom-control-description\">{{control.label}}</span>\r\n</label>\r\n\r\n\r\n    <appc-control-error-message [form]=\"f\" [control]=\"control\"></appc-control-error-message>\r\n\r\n</div>";

/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(1);
var core_1 = __webpack_require__(0);
var forms_1 = __webpack_require__(16);
var control_base_1 = __webpack_require__(32);
var validation_service_1 = __webpack_require__(62);
var ErrorMessageComponent = /** @class */ (function () {
    function ErrorMessageComponent() {
    }
    Object.defineProperty(ErrorMessageComponent.prototype, "errorMessage", {
        get: function () {
            var c = this.form.form.get(this.control.key);
            for (var propertyName in c.errors) {
                if (c.errors.hasOwnProperty(propertyName) && c.touched) {
                    return validation_service_1.ValidationService.getValidatorErrorMessage(propertyName, this.control.minlength || this.control.maxlength);
                }
            }
            return undefined;
        },
        enumerable: true,
        configurable: true
    });
    tslib_1.__decorate([
        core_1.Input(),
        tslib_1.__metadata("design:type", control_base_1.ControlBase)
    ], ErrorMessageComponent.prototype, "control", void 0);
    tslib_1.__decorate([
        core_1.Input(),
        tslib_1.__metadata("design:type", forms_1.FormGroupDirective)
    ], ErrorMessageComponent.prototype, "form", void 0);
    ErrorMessageComponent = tslib_1.__decorate([
        core_1.Component({
            selector: 'appc-control-error-message',
            template: "<div *ngIf=\"errorMessage\" class=\"form-control-feedback\"> {{errorMessage}} </div>"
        })
    ], ErrorMessageComponent);
    return ErrorMessageComponent;
}());
exports.ErrorMessageComponent = ErrorMessageComponent;


/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(1);
var core_1 = __webpack_require__(0);
var ErrorSummaryComponent = /** @class */ (function () {
    function ErrorSummaryComponent() {
    }
    tslib_1.__decorate([
        core_1.Input(),
        tslib_1.__metadata("design:type", Array)
    ], ErrorSummaryComponent.prototype, "errors", void 0);
    ErrorSummaryComponent = tslib_1.__decorate([
        core_1.Component({
            selector: 'appc-error-summary',
            template: __webpack_require__(101)
        })
    ], ErrorSummaryComponent);
    return ErrorSummaryComponent;
}());
exports.ErrorSummaryComponent = ErrorSummaryComponent;


/***/ }),
/* 101 */
/***/ (function(module, exports) {

module.exports = "<div class=\"alert alert-danger\" *ngIf=\"errors?.length > 0\">\r\n    <div *ngFor=\"let error of errors\">\r\n        {{error}}\r\n    </div>\r\n</div>";

/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(1);
var core_1 = __webpack_require__(0);
var core_2 = __webpack_require__(30);
var account_service_1 = __webpack_require__(33);
var HeaderComponent = /** @class */ (function () {
    function HeaderComponent(accountService, translation) {
        this.accountService = accountService;
        this.translation = translation;
        this.isCollapsed = true;
        this.languages = [
            { locale: 'en', description: 'English' },
            { locale: 'fr', description: 'French' }
        ];
        this.currentLanguage = this.languages[0];
    }
    Object.defineProperty(HeaderComponent.prototype, "isLoggedIn", {
        get: function () {
            return this.accountService.isLoggedIn;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HeaderComponent.prototype, "user", {
        get: function () {
            return this.accountService.user;
        },
        enumerable: true,
        configurable: true
    });
    HeaderComponent.prototype.ngOnInit = function () { };
    HeaderComponent.prototype.toggleNav = function () {
        this.isCollapsed = !this.isCollapsed;
    };
    HeaderComponent.prototype.setLang = function (lang) {
        this.currentLanguage = lang;
        this.translation.use(lang.locale);
    };
    HeaderComponent = tslib_1.__decorate([
        core_1.Component({
            selector: 'appc-header',
            template: __webpack_require__(105),
            styles: [__webpack_require__(106)]
        }),
        tslib_1.__metadata("design:paramtypes", [account_service_1.AccountService,
            core_2.TranslateService])
    ], HeaderComponent);
    return HeaderComponent;
}());
exports.HeaderComponent = HeaderComponent;


/***/ }),
/* 103 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(2))(101);

/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(2))(380);

/***/ }),
/* 105 */
/***/ (function(module, exports) {

module.exports = "<nav class=\"navbar navbar-expand-md navbar-light bg-faded\">\r\n    <button class=\"navbar-toggler navbar-toggler-right\" [class.collapsed]=\"isCollapsed\" type=\"button\" data-toggle=\"collapse\"\r\n        data-target=\"#navbarNav\" aria-controls=\"navbarNav\" (click)=\"toggleNav()\" aria-expanded=\"false\" aria-label=\"Toggle navigation\">\r\n        <span class=\"navbar-toggler-icon\"></span>\r\n    </button>\r\n    <a class=\"navbar-brand\" routerLink=\"home\">AspNetCoreSpa</a>\r\n\r\n    <div class=\"collapse navbar-collapse\" id=\"navbarNav\" [class.show]=\"!isCollapsed\">\r\n        <!--Left nav-->\r\n        <ul class=\"navbar-nav\">\r\n            <li class=\"nav-item\">\r\n                <a class=\"nav-link\" routerLinkActive=\"active\" routerLink=\"home\">{{'APP_NAV_HOME' | translate}}</a>\r\n            </li>\r\n            <li class=\"nav-item dropdown\">\r\n                <div ngbDropdown class=\"d-inline-block\">\r\n                    <a class=\"nav-link\" id=\"languages\" ngbDropdownToggle>{{currentLanguage.description}}</a>\r\n                    <div class=\"dropdown-menu dropdown-menu-right\" aria-labelledby=\"languages\">\r\n                        <button *ngFor=\"let lang of languages\" (click)=\"setLang(lang)\" class=\"dropdown-item\">\r\n                            {{lang.description}}\r\n                        </button>\r\n                    </div>\r\n                </div>\r\n            </li>\r\n        </ul>\r\n\r\n        <!--Right nav-->\r\n        <div class=\"navbar-collapse justify-content-md-end\">\r\n            <ul class=\"navbar-nav\">\r\n\r\n                <li class=\"nav-item\" *ngIf=\"isLoggedIn\">\r\n                    <a class=\"nav-link\" routerLinkActive=\"active\" routerLink=\"profile\">\r\n                                <i class=\"fa fa-user\"></i> {{user?.name}}\r\n                            </a>\r\n                </li>\r\n\r\n                <li class=\"nav-item\" *ngIf=\"!isLoggedIn\">\r\n                    <a class=\"nav-link\" routerLinkActive=\"active\" routerLink=\"register\">\r\n                                <i class=\"fa fa-user\"></i> {{'APP_NAV_REGISTER' | translate}}\r\n                            </a>\r\n                </li>\r\n\r\n                <li class=\"nav-item\" *ngIf=\"!isLoggedIn\">\r\n                    <a class=\"nav-link\" routerLinkActive=\"active\" routerLink=\"login\">\r\n                                <i class=\"fa fa-sign-in\"></i>{{'APP_NAV_LOGIN' | translate}}\r\n                            </a>\r\n                </li>\r\n                <li class=\"nav-item\" *ngIf=\"isLoggedIn && user?.role?.indexOf('Admin') > -1\">\r\n                    <a class=\"nav-link\" routerLinkActive=\"active\" routerLink=\"admin\">\r\n                                <i class=\"fa fa-gear\"></i> {{'APP_NAV_ADMIN' | translate}}\r\n                            </a>\r\n                </li>\r\n                <li class=\"nav-item\" *ngIf=\"isLoggedIn\">\r\n                    <a class=\"nav-link\" (click)=\"accountService.logout()\" routerLinkActive=\"active\" href=\"javascript:void(null);\">\r\n                                <i class=\"fa fa-sign-out\"></i> {{'APP_NAV_LOGOUT' | translate}}\r\n                            </a>\r\n                </li>\r\n            </ul>\r\n        </div>\r\n\r\n    </div>\r\n\r\n</nav>";

/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {


        var result = __webpack_require__(107);

        if (typeof result === "string") {
            module.exports = result;
        } else {
            module.exports = result.toString();
        }
    

/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(17)(undefined);
// imports


// module
exports.push([module.i, "header {\n  padding-right: 0rem;\n  padding-left: 0rem; }\n", ""]);

// exports


/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(1);
var core_1 = __webpack_require__(0);
var FooterComponent = /** @class */ (function () {
    function FooterComponent() {
    }
    FooterComponent = tslib_1.__decorate([
        core_1.Component({
            selector: 'appc-footer',
            styles: [__webpack_require__(109)],
            template: __webpack_require__(111)
        })
    ], FooterComponent);
    return FooterComponent;
}());
exports.FooterComponent = FooterComponent;


/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {


        var result = __webpack_require__(110);

        if (typeof result === "string") {
            module.exports = result;
        } else {
            module.exports = result.toString();
        }
    

/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(17)(undefined);
// imports


// module
exports.push([module.i, ".footer {\n  bottom: 0; }\n", ""]);

// exports


/***/ }),
/* 111 */
/***/ (function(module, exports) {

module.exports = "<footer class=\"footer text-muted\">\r\n    <p class=\"text-muted\">\r\n        &copy; 2015-2016 {{'TITLE' | translate}}\r\n    </p>\r\n</footer>\r\n";

/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(1);
var core_1 = __webpack_require__(0);
// tslint:disable-next-line:use-pipe-transform-interface
var UppercasePipe = /** @class */ (function () {
    function UppercasePipe() {
    }
    UppercasePipe.prototype.transform = function (value) {
        return value.toUpperCase();
    };
    UppercasePipe = tslib_1.__decorate([
        core_1.Pipe({
            name: 'appfUppercase'
        })
    ], UppercasePipe);
    return UppercasePipe;
}());
exports.UppercasePipe = UppercasePipe;


/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var DataServiceOptions = /** @class */ (function () {
    function DataServiceOptions() {
        this.headers = {};
        this.params = {};
        this.data = {};
    }
    return DataServiceOptions;
}());
exports.DataServiceOptions = DataServiceOptions;


/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(1);
var core_1 = __webpack_require__(0);
var Observable_1 = __webpack_require__(7);
var content_service_1 = __webpack_require__(63);
var common_1 = __webpack_require__(5);
var ApiTranslationLoader = /** @class */ (function () {
    function ApiTranslationLoader(contentService, platformId) {
        this.contentService = contentService;
        this.platformId = platformId;
    }
    ApiTranslationLoader.prototype.getTranslation = function (lang) {
        if (common_1.isPlatformBrowser(this.platformId)) {
            return this.contentService.get(lang);
        }
        return Observable_1.Observable.of({});
    };
    ApiTranslationLoader = tslib_1.__decorate([
        core_1.Injectable(),
        tslib_1.__param(1, core_1.Inject(core_1.PLATFORM_ID)),
        tslib_1.__metadata("design:paramtypes", [content_service_1.ContentService, Object])
    ], ApiTranslationLoader);
    return ApiTranslationLoader;
}());
exports.ApiTranslationLoader = ApiTranslationLoader;
// tslint:disable-next-line:max-classes-per-file
var CustomMissingTranslationHandler = /** @class */ (function () {
    function CustomMissingTranslationHandler() {
    }
    CustomMissingTranslationHandler.prototype.handle = function (params) {
        return params.key;
    };
    CustomMissingTranslationHandler = tslib_1.__decorate([
        core_1.Injectable()
    ], CustomMissingTranslationHandler);
    return CustomMissingTranslationHandler;
}());
exports.CustomMissingTranslationHandler = CustomMissingTranslationHandler;


/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(1);
var core_1 = __webpack_require__(0);
var platform_browser_1 = __webpack_require__(6);
// Services
var account_service_1 = __webpack_require__(33);
var data_service_1 = __webpack_require__(31);
var utility_service_1 = __webpack_require__(18);
var CoreModule = /** @class */ (function () {
    function CoreModule(parentModule) {
        if (parentModule) {
            throw new Error('CoreModule is already loaded. Import it in the AppModule only');
        }
    }
    CoreModule_1 = CoreModule;
    // forRoot allows to override providers
    // https://angular.io/docs/ts/latest/guide/ngmodule.html#!#core-for-root
    CoreModule.forRoot = function () {
        return {
            ngModule: CoreModule_1,
            providers: [
                // Providers
                platform_browser_1.Title,
                account_service_1.AccountService,
                data_service_1.DataService,
                utility_service_1.UtilityService
            ]
        };
    };
    CoreModule = CoreModule_1 = tslib_1.__decorate([
        core_1.NgModule({
            imports: [],
            exports: [],
            providers: []
        }),
        tslib_1.__param(0, core_1.Optional()), tslib_1.__param(0, core_1.SkipSelf()),
        tslib_1.__metadata("design:paramtypes", [CoreModule])
    ], CoreModule);
    return CoreModule;
    var CoreModule_1;
}());
exports.CoreModule = CoreModule;


/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(1);
var core_1 = __webpack_require__(0);
var home_component_1 = __webpack_require__(64);
var home_routes_1 = __webpack_require__(120);
var HomeModule = /** @class */ (function () {
    function HomeModule() {
    }
    HomeModule = tslib_1.__decorate([
        core_1.NgModule({
            imports: [home_routes_1.routing],
            declarations: [home_component_1.HomeComponent]
        })
    ], HomeModule);
    return HomeModule;
}());
exports.HomeModule = HomeModule;


/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {


        var result = __webpack_require__(118);

        if (typeof result === "string") {
            module.exports = result;
        } else {
            module.exports = result.toString();
        }
    

/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(17)(undefined);
// imports


// module
exports.push([module.i, "", ""]);

// exports


/***/ }),
/* 119 */
/***/ (function(module, exports) {

module.exports = "<div class=\"jumbotron\">\r\n    <div class=\"container\">\r\n        <h2>Asp.Net Core &hearts; Angular 2 &hearts; Bootstrap 4 &hearts; Webpack</h2>\r\n    </div>\r\n</div>\r\n\r\n<div class=\"row\">\r\n    <div class=\"col-md-4\">\r\n        <h4>\r\n            Asp.Net Core\r\n        </h4>\r\n        <p>\r\n            ASP.NET is an open source web framework for building modern web applications and services.\r\n        </p>\r\n        <p>\r\n            <a class=\"btn btn-outline-info\" target=\"_blank\" href=\"http://www.asp.net/\">More info »</a>\r\n        </p>\r\n    </div>\r\n    <div class=\"col-md-4\">\r\n        <h4>\r\n            Angular 2\r\n        </h4>\r\n        <p>\r\n            One Framework Mobile and desktop\r\n        </p>\r\n        <p>\r\n            <a class=\"btn btn-outline-info\" target=\"_blank\" href=\"https://angular.io/\">More info »</a>\r\n        </p>\r\n    </div>\r\n\r\n    <div class=\"col-md-4\">\r\n        <h4>\r\n            ng-bootstrap\r\n        </h4>\r\n        <p>\r\n            Angular 2, powered by Bootstrap 4 written by the angular-ui Team.\r\n        </p>\r\n        <p>\r\n            <a class=\"btn btn-outline-info\" target=\"_blank\" href=\"https://ng-bootstrap.github.io/#/home\">More info »</a>\r\n        </p>\r\n    </div>\r\n    <div class=\"col-md-4\">\r\n        <h4>\r\n            Bootstrap 4\r\n        </h4>\r\n        <p>\r\n            Bootstrap is the most popular HTML, CSS, and JS framework for developing responsive, mobile first projects on the web.\r\n        </p>\r\n        <p>\r\n            <a class=\"btn btn-outline-info\" target=\"_blank\" href=\"http://v4-alpha.getbootstrap.com/\">More info »</a>\r\n        </p>\r\n    </div>\r\n    <div class=\"col-md-4\">\r\n        <h4>\r\n            Webpack 2\r\n        </h4>\r\n        <p>\r\n            Module bundler\r\n        </p>\r\n        <p>\r\n            <a class=\"btn btn-outline-info\" target=\"_blank\" href=\"https://webpack.js.org/\">More info »</a>\r\n        </p>\r\n    </div>\r\n    <div class=\"col-md-4\">\r\n        <h4>\r\n            @ngx-translate\r\n        </h4>\r\n        <p>\r\n            The internationalization (i18n) library for Angular 2+\r\n        </p>\r\n        <p>\r\n            <a class=\"btn btn-outline-info\" target=\"_blank\" href=\"http://www.ngx-translate.com/\">More info »</a>\r\n        </p>\r\n    </div>\r\n</div>";

/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var router_1 = __webpack_require__(10);
var home_component_1 = __webpack_require__(64);
var routes = [
    { path: 'home', component: home_component_1.HomeComponent, data: { state: 'home' } }
];
exports.routing = router_1.RouterModule.forChild(routes);


/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var router_1 = __webpack_require__(10);
var routes = [
    { path: '', redirectTo: 'home', pathMatch: 'full' },
    // Lazy async modules
    {
        path: 'login', loadChildren: function() { return __webpack_require__.e/* import() */(0).then(__webpack_require__.bind(null, 126))  .then( function(module) { return module['LoginModule']; } ); }
    },
    {
        path: 'register', loadChildren: function() { return __webpack_require__.e/* import() */(1).then(__webpack_require__.bind(null, 127))  .then( function(module) { return module['RegisterModule']; } ); }
    },
    {
        path: 'profile', loadChildren: function() { return __webpack_require__.e/* import() */(2).then(__webpack_require__.bind(null, 128))  .then( function(module) { return module['ProfileModule']; } ); }
    },
    {
        path: 'admin', loadChildren: function() { return __webpack_require__.e/* import() */(3).then(__webpack_require__.bind(null, 129))  .then( function(module) { return module['AdminModule']; } ); }
    }
];
exports.routing = router_1.RouterModule.forRoot(routes, { preloadingStrategy: router_1.PreloadAllModules });


/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(1);
var core_1 = __webpack_require__(0);
var AppService = /** @class */ (function () {
    function AppService() {
    }
    AppService = tslib_1.__decorate([
        core_1.Injectable()
    ], AppService);
    return AppService;
}());
exports.AppService = AppService;


/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(1);
var core_1 = __webpack_require__(0);
var platform_browser_1 = __webpack_require__(6);
var core_2 = __webpack_require__(30);
var router_animations_1 = __webpack_require__(124);
var AppComponent = /** @class */ (function () {
    function AppComponent(translate, titleService) {
        this.translate = translate;
        this.titleService = titleService;
        // this language will be used as a fallback when a translation isn't found in the current language
        translate.setDefaultLang('en');
        // the lang to use, if the lang isn't available, it will use the current loader to get them
        translate.use('en');
    }
    AppComponent.prototype.ngOnInit = function () {
        var _this = this;
        this.translate.onLangChange.subscribe(function (lan) {
            _this.translate.get('TITLE')
                .subscribe(function (title) { return _this.setTitle(title); });
        });
    };
    AppComponent.prototype.setTitle = function (newTitle) {
        this.titleService.setTitle(newTitle);
    };
    AppComponent.prototype.getState = function (outlet) {
        return outlet.activatedRouteData.state;
    };
    AppComponent = tslib_1.__decorate([
        core_1.Component({
            selector: 'appc-root',
            animations: [router_animations_1.routerTransition],
            template: __webpack_require__(125)
        }),
        tslib_1.__metadata("design:paramtypes", [core_2.TranslateService,
            platform_browser_1.Title])
    ], AppComponent);
    return AppComponent;
}());
exports.AppComponent = AppComponent;


/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// import { trigger, animate, style, transition } from '@angular/animations';
Object.defineProperty(exports, "__esModule", { value: true });
// export function routerTransition() {
//     return trigger('routerTransition', [
//         transition('void => *', [
//             style({ transform: 'translateX(-10%)' }),
//             animate(400)
//         ])
//     ]);
// }
// export function hostStyle() {
//     return {
//         '[@routerTransition]': '',
//         '[style.display]': '"block"',
//         // '[style.position]': '"absolute"'
//     };
// }
var animations_1 = __webpack_require__(19);
exports.routerTransition = animations_1.trigger('routerTransition', [
    animations_1.transition('* <=> *', [
        animations_1.query(':enter, :leave', animations_1.style({ position: 'fixed', width: '100%' }), { optional: true }),
        animations_1.query('.block', animations_1.style({ opacity: 0 }), { optional: true }),
        animations_1.group([
            animations_1.query(':enter', [
                animations_1.style({ transform: 'translateX(100%)' }),
                animations_1.animate('0.5s ease-in-out', animations_1.style({ transform: 'translateX(0%)' }))
            ], { optional: true }),
            animations_1.query(':leave', [
                animations_1.style({ transform: 'translateX(0%)' }),
                animations_1.animate('0.5s ease-in-out', animations_1.style({ transform: 'translateX(-100%)' }))
            ], { optional: true }),
        ]),
        animations_1.query(':enter .block', animations_1.stagger(400, [
            animations_1.style({ transform: 'translateY(100px)' }),
            animations_1.animate('1s ease-in-out', animations_1.style({ transform: 'translateY(0px)', opacity: 1 })),
        ]), { optional: true }),
    ])
]);


/***/ }),
/* 125 */
/***/ (function(module, exports) {

module.exports = "<!-- header component -->\r\n<appc-header></appc-header>\r\n\r\n<!-- component routing placeholder -->\r\n<main [@routerTransition]=\"getState(o)\">\r\n    <router-outlet #o=\"outlet\"></router-outlet>\r\n</main>\r\n\r\n<!-- footer component -->\r\n<appc-footer></appc-footer>";

/***/ })
/******/ ])));
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgODM4YWVhZjI0MThmODE1NzExZGYiLCJ3ZWJwYWNrOi8vL2RlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9AYW5ndWxhci9jb3JlL2J1bmRsZXMvY29yZS51bWQuanMgZnJvbSBkbGwtcmVmZXJlbmNlIC4vdmVuZG9yIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90c2xpYi90c2xpYi5qcyIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCIuL3ZlbmRvclwiIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kb21pbm8vbGliL3V0aWxzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kb21pbm8vbGliL05vZGUuanMiLCJ3ZWJwYWNrOi8vL2RlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9AYW5ndWxhci9jb21tb24vYnVuZGxlcy9jb21tb24udW1kLmpzIGZyb20gZGxsLXJlZmVyZW5jZSAuL3ZlbmRvciIsIndlYnBhY2s6Ly8vZGVsZWdhdGVkIC4vbm9kZV9tb2R1bGVzL0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXIvYnVuZGxlcy9wbGF0Zm9ybS1icm93c2VyLnVtZC5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgLi92ZW5kb3IiLCJ3ZWJwYWNrOi8vL2RlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9yeGpzL09ic2VydmFibGUuanMgZnJvbSBkbGwtcmVmZXJlbmNlIC4vdmVuZG9yIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kb21pbm8vbGliL0V2ZW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kb21pbm8vbGliL0VsZW1lbnQuanMiLCJ3ZWJwYWNrOi8vL2RlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9AYW5ndWxhci9yb3V0ZXIvYnVuZGxlcy9yb3V0ZXIudW1kLmpzIGZyb20gZGxsLXJlZmVyZW5jZSAuL3ZlbmRvciIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvY29tbW9uL2J1bmRsZXMvY29tbW9uLWh0dHAudW1kLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kb21pbm8vbGliL0RPTUltcGxlbWVudGF0aW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kb21pbm8vbGliL05vZGVMaXN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kb21pbm8vbGliL0NoYXJhY3RlckRhdGEuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RvbWluby9saWIvTm9kZUZpbHRlci5qcyIsIndlYnBhY2s6Ly8vZGVsZWdhdGVkIC4vbm9kZV9tb2R1bGVzL0Bhbmd1bGFyL2Zvcm1zL2J1bmRsZXMvZm9ybXMudW1kLmpzIGZyb20gZGxsLXJlZmVyZW5jZSAuL3ZlbmRvciIsIndlYnBhY2s6Ly8vZGVsZWdhdGVkIC4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzIGZyb20gZGxsLXJlZmVyZW5jZSAuL3ZlbmRvciIsIndlYnBhY2s6Ly8vLi9DbGllbnRBcHAvYXBwL2NvcmUvc2VydmljZXMvdXRpbGl0eS5zZXJ2aWNlLnRzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYW5ndWxhci9hbmltYXRpb25zL2J1bmRsZXMvYW5pbWF0aW9ucy51bWQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RvbWluby9saWIvRG9jdW1lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RvbWluby9saWIveG1sbmFtZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RvbWluby9saWIvc2VsZWN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kb21pbm8vbGliL0NoaWxkTm9kZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZG9taW5vL2xpYi9VUkwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RvbWluby9saWIvaHRtbGVsdHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RvbWluby9saWIvQ1NTU3R5bGVEZWNsYXJhdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZG9taW5vL2xpYi9XaW5kb3cuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RvbWluby9saWIvRG9jdW1lbnRUeXBlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kb21pbm8vbGliL0hUTUxQYXJzZXIuanMiLCJ3ZWJwYWNrOi8vL2RlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9Abmd4LXRyYW5zbGF0ZS9jb3JlL2J1bmRsZXMvY29yZS51bWQuanMgZnJvbSBkbGwtcmVmZXJlbmNlIC4vdmVuZG9yIiwid2VicGFjazovLy8uL0NsaWVudEFwcC9hcHAvY29yZS9zZXJ2aWNlcy9kYXRhLnNlcnZpY2UudHMiLCJ3ZWJwYWNrOi8vLy4vQ2xpZW50QXBwL2FwcC9zaGFyZWQvZm9ybXMvY29udHJvbC1iYXNlLnRzIiwid2VicGFjazovLy8uL0NsaWVudEFwcC9hcHAvY29yZS9zZXJ2aWNlcy9hY2NvdW50LnNlcnZpY2UudHMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bhbmd1bGFyL3BsYXRmb3JtLXNlcnZlci9idW5kbGVzL3BsYXRmb3JtLXNlcnZlci51bWQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bhbmd1bGFyL2FuaW1hdGlvbnMvYnVuZGxlcy9hbmltYXRpb25zLWJyb3dzZXIudW1kLmpzIiwid2VicGFjazovLy9kZWxlZ2F0ZWQgLi9ub2RlX21vZHVsZXMvcnhqcy9vcGVyYXRvci9maWx0ZXIuanMgZnJvbSBkbGwtcmVmZXJlbmNlIC4vdmVuZG9yIiwid2VicGFjazovLy9kZWxlZ2F0ZWQgLi9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvaHR0cC9idW5kbGVzL2h0dHAudW1kLmpzIGZyb20gZGxsLXJlZmVyZW5jZSAuL3ZlbmRvciIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvcGxhdGZvcm0tYnJvd3Nlci9idW5kbGVzL3BsYXRmb3JtLWJyb3dzZXItYW5pbWF0aW9ucy51bWQuanMiLCJ3ZWJwYWNrOi8vL2RlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9yeGpzL1N1YmplY3QuanMgZnJvbSBkbGwtcmVmZXJlbmNlIC4vdmVuZG9yIiwid2VicGFjazovLy9leHRlcm5hbCBcInVybFwiIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kb21pbm8vbGliL0V2ZW50VGFyZ2V0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kb21pbm8vbGliL01vdXNlRXZlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RvbWluby9saWIvVUlFdmVudC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZG9taW5vL2xpYi9ET01FeGNlcHRpb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RvbWluby9saWIvY29uZmlnLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kb21pbm8vbGliL2F0dHJpYnV0ZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RvbWluby9saWIvRE9NVG9rZW5MaXN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kb21pbm8vbGliL05vbkRvY3VtZW50VHlwZUNoaWxkTm9kZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZG9taW5vL2xpYi9UZXh0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kb21pbm8vbGliL0xlYWYuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RvbWluby9saWIvQ29tbWVudC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZG9taW5vL2xpYi9Eb2N1bWVudEZyYWdtZW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kb21pbm8vbGliL1Byb2Nlc3NpbmdJbnN0cnVjdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZG9taW5vL2xpYi9Ob2RlVHJhdmVyc2FsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kb21pbm8vbGliL2V2ZW50cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZG9taW5vL2xpYi9VUkxVdGlscy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZG9taW5vL2xpYi9kZWZpbmVFbGVtZW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kb21pbm8vbGliL3Nsb3BweS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZG9taW5vL2xpYi9pbXBsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kb21pbm8vbGliL3N2Zy5qcyIsIndlYnBhY2s6Ly8vLi9DbGllbnRBcHAvYXBwL3NoYXJlZC9mb3Jtcy9mb3JtLWNvbnRyb2wuc2VydmljZS50cyIsIndlYnBhY2s6Ly8vLi9DbGllbnRBcHAvYXBwL3NoYXJlZC9mb3Jtcy92YWxpZGF0aW9uLnNlcnZpY2UudHMiLCJ3ZWJwYWNrOi8vLy4vQ2xpZW50QXBwL2FwcC9zaGFyZWQvc2VydmljZXMvY29udGVudC5zZXJ2aWNlLnRzIiwid2VicGFjazovLy8uL0NsaWVudEFwcC9hcHAvaG9tZS9ob21lLmNvbXBvbmVudC50cyIsIndlYnBhY2s6Ly8vLi9DbGllbnRBcHAvYXBwL3NoYXJlZC9zaGFyZWQubW9kdWxlLnRzIiwid2VicGFjazovLy8uL0NsaWVudEFwcC9ib290LnNlcnZlci50cyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVmbGVjdC1tZXRhZGF0YS9SZWZsZWN0LmpzIiwid2VicGFjazovLy9kZWxlZ2F0ZWQgLi9ub2RlX21vZHVsZXMvem9uZS5qcy9kaXN0L3pvbmUtbm9kZS5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgLi92ZW5kb3IiLCJ3ZWJwYWNrOi8vL2RlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9yeGpzL2FkZC9vcGVyYXRvci9maXJzdC5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgLi92ZW5kb3IiLCJ3ZWJwYWNrOi8vL2RlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9yeGpzL29ic2VydmFibGUvb2YuanMgZnJvbSBkbGwtcmVmZXJlbmNlIC4vdmVuZG9yIiwid2VicGFjazovLy9kZWxlZ2F0ZWQgLi9ub2RlX21vZHVsZXMvcnhqcy9vcGVyYXRvci9jb25jYXRNYXAuanMgZnJvbSBkbGwtcmVmZXJlbmNlIC4vdmVuZG9yIiwid2VicGFjazovLy9kZWxlZ2F0ZWQgLi9ub2RlX21vZHVsZXMvcnhqcy9vcGVyYXRvci9tYXAuanMgZnJvbSBkbGwtcmVmZXJlbmNlIC4vdmVuZG9yIiwid2VicGFjazovLy9kZWxlZ2F0ZWQgLi9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvcGxhdGZvcm0tYnJvd3Nlci1keW5hbWljL2J1bmRsZXMvcGxhdGZvcm0tYnJvd3Nlci1keW5hbWljLnVtZC5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgLi92ZW5kb3IiLCJ3ZWJwYWNrOi8vL2RlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9AYW5ndWxhci9jb21waWxlci9idW5kbGVzL2NvbXBpbGVyLnVtZC5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgLi92ZW5kb3IiLCJ3ZWJwYWNrOi8vL2RlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9yeGpzL29wZXJhdG9yL2ZpcnN0LmpzIGZyb20gZGxsLXJlZmVyZW5jZSAuL3ZlbmRvciIsIndlYnBhY2s6Ly8vZGVsZWdhdGVkIC4vbm9kZV9tb2R1bGVzL3J4anMvb3BlcmF0b3IvdG9Qcm9taXNlLmpzIGZyb20gZGxsLXJlZmVyZW5jZSAuL3ZlbmRvciIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZG9taW5vL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZG9taW5vL2xpYi9GaWx0ZXJlZEVsZW1lbnRMaXN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kb21pbm8vbGliL1RyZWVXYWxrZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RvbWluby9saWIvTm9kZUl0ZXJhdG9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kb21pbm8vbGliL0N1c3RvbUV2ZW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kb21pbm8vbGliL2Nzc3BhcnNlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZG9taW5vL2xpYi9Mb2NhdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZG9taW5vL2xpYi9OYXZpZ2F0b3JJRC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZG9taW5vL2xpYi9XaW5kb3dUaW1lcnMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RvbWluby9saWIvTXV0YXRpb25Db25zdGFudHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3hocjIvbGliL3hocjIuanMiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwiaHR0cFwiIiwid2VicGFjazovLy9leHRlcm5hbCBcImh0dHBzXCIiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwib3NcIiIsIndlYnBhY2s6Ly8vZGVsZWdhdGVkIC4vbm9kZV9tb2R1bGVzL2FzcG5ldC1wcmVyZW5kZXJpbmcvaW5kZXguanMgZnJvbSBkbGwtcmVmZXJlbmNlIC4vdmVuZG9yIiwid2VicGFjazovLy8uL0NsaWVudEFwcC9hcHAvYXBwLm1vZHVsZS5zZXJ2ZXIudHMiLCJ3ZWJwYWNrOi8vLy4vQ2xpZW50QXBwL2FwcC9hcHAubW9kdWxlLnNoYXJlZC50cyIsIndlYnBhY2s6Ly8vLi9DbGllbnRBcHAvYXBwL3NoYXJlZC9kaXJlY3RpdmVzL3BhZ2UtaGVhZGluZy5kaXJlY3RpdmUudHMiLCJ3ZWJwYWNrOi8vLy4vQ2xpZW50QXBwL2FwcC9zaGFyZWQvZm9ybXMvZHluYW1pYy1mb3JtLmNvbXBvbmVudC50cyIsIndlYnBhY2s6Ly8vLi9DbGllbnRBcHAvYXBwL3NoYXJlZC9mb3Jtcy9keW5hbWljLWZvcm0uY29tcG9uZW50Lmh0bWwiLCJ3ZWJwYWNrOi8vLy4vQ2xpZW50QXBwL2FwcC9zaGFyZWQvZm9ybXMvZHluYW1pYy1mb3JtLWNvbnRyb2wuY29tcG9uZW50LnRzIiwid2VicGFjazovLy8uL0NsaWVudEFwcC9hcHAvc2hhcmVkL2Zvcm1zL2R5bmFtaWMtZm9ybS1jb250cm9sLmNvbXBvbmVudC5odG1sIiwid2VicGFjazovLy8uL0NsaWVudEFwcC9hcHAvc2hhcmVkL2Zvcm1zL2Vycm9yLW1lc3NhZ2UuY29tcG9uZW50LnRzIiwid2VicGFjazovLy8uL0NsaWVudEFwcC9hcHAvc2hhcmVkL2Zvcm1zL2Vycm9yLXN1bW1hcnkuY29tcG9uZW50LnRzIiwid2VicGFjazovLy8uL0NsaWVudEFwcC9hcHAvc2hhcmVkL2Zvcm1zL2Vycm9yLXN1bW1hcnkuY29tcG9uZW50Lmh0bWwiLCJ3ZWJwYWNrOi8vLy4vQ2xpZW50QXBwL2FwcC9zaGFyZWQvbGF5b3V0L2hlYWRlci5jb21wb25lbnQudHMiLCJ3ZWJwYWNrOi8vL2RlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9yeGpzL1J4LmpzIGZyb20gZGxsLXJlZmVyZW5jZSAuL3ZlbmRvciIsIndlYnBhY2s6Ly8vZGVsZWdhdGVkIC4vbm9kZV9tb2R1bGVzL2FuZ3VsYXIyLWp3dC9hbmd1bGFyMi1qd3QuanMgZnJvbSBkbGwtcmVmZXJlbmNlIC4vdmVuZG9yIiwid2VicGFjazovLy8uL0NsaWVudEFwcC9hcHAvc2hhcmVkL2xheW91dC9oZWFkZXIuY29tcG9uZW50Lmh0bWwiLCJ3ZWJwYWNrOi8vLy4vQ2xpZW50QXBwL2FwcC9zaGFyZWQvbGF5b3V0L2hlYWRlci5jb21wb25lbnQuc2Nzcz8zYTg3Iiwid2VicGFjazovLy8uL0NsaWVudEFwcC9hcHAvc2hhcmVkL2xheW91dC9oZWFkZXIuY29tcG9uZW50LnNjc3MiLCJ3ZWJwYWNrOi8vLy4vQ2xpZW50QXBwL2FwcC9zaGFyZWQvbGF5b3V0L2Zvb3Rlci5jb21wb25lbnQudHMiLCJ3ZWJwYWNrOi8vLy4vQ2xpZW50QXBwL2FwcC9zaGFyZWQvbGF5b3V0L2Zvb3Rlci5jb21wb25lbnQuc2Nzcz9kOTkyIiwid2VicGFjazovLy8uL0NsaWVudEFwcC9hcHAvc2hhcmVkL2xheW91dC9mb290ZXIuY29tcG9uZW50LnNjc3MiLCJ3ZWJwYWNrOi8vLy4vQ2xpZW50QXBwL2FwcC9zaGFyZWQvbGF5b3V0L2Zvb3Rlci5jb21wb25lbnQuaHRtbCIsIndlYnBhY2s6Ly8vLi9DbGllbnRBcHAvYXBwL3NoYXJlZC9waXBlcy91cHBlcmNhc2UucGlwZS50cyIsIndlYnBhY2s6Ly8vLi9DbGllbnRBcHAvYXBwL2NvcmUvc2VydmljZXMvZGF0YS1zZXJ2aWNlLW9wdGlvbnMudHMiLCJ3ZWJwYWNrOi8vLy4vQ2xpZW50QXBwL2FwcC9zaGFyZWQvc2VydmljZXMvYXBpLXRyYW5zbGF0aW9uLWxvYWRlci5zZXJ2aWNlLnRzIiwid2VicGFjazovLy8uL0NsaWVudEFwcC9hcHAvY29yZS9jb3JlLm1vZHVsZS50cyIsIndlYnBhY2s6Ly8vLi9DbGllbnRBcHAvYXBwL2hvbWUvaG9tZS5tb2R1bGUudHMiLCJ3ZWJwYWNrOi8vLy4vQ2xpZW50QXBwL2FwcC9ob21lL2hvbWUuY29tcG9uZW50LnNjc3M/MGY4YyIsIndlYnBhY2s6Ly8vLi9DbGllbnRBcHAvYXBwL2hvbWUvaG9tZS5jb21wb25lbnQuc2NzcyIsIndlYnBhY2s6Ly8vLi9DbGllbnRBcHAvYXBwL2hvbWUvaG9tZS5jb21wb25lbnQuaHRtbCIsIndlYnBhY2s6Ly8vLi9DbGllbnRBcHAvYXBwL2hvbWUvaG9tZS5yb3V0ZXMudHMiLCJ3ZWJwYWNrOi8vLy4vQ2xpZW50QXBwL2FwcC9hcHAucm91dGVzLnRzIiwid2VicGFjazovLy8uL0NsaWVudEFwcC9hcHAvYXBwLnNlcnZpY2UudHMiLCJ3ZWJwYWNrOi8vLy4vQ2xpZW50QXBwL2FwcC9hcHAuY29tcG9uZW50LnRzIiwid2VicGFjazovLy8uL0NsaWVudEFwcC9hcHAvcm91dGVyLmFuaW1hdGlvbnMudHMiLCJ3ZWJwYWNrOi8vLy4vQ2xpZW50QXBwL2FwcC9hcHAuY29tcG9uZW50Lmh0bWwiXSwibmFtZXMiOltd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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2Q0FBNkMsSUFBSTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUEsMkJBQTJCLDBDQUEwQztBQUNyRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxVQUFVLDBDQUEwQztBQUNwRDtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sV0FBVyxzQkFBc0I7QUFDakMsWUFBWTtBQUNaLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFD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LGdCQUFnQixJQUFJLGNBQWMsUUFBUSxXQUFXLE9BQU8sV0FBVyxPQUFPLE1BQU0sVUFBVSxRQUFRLE1BQU0sZ0JBQWdCLFFBQVEsTUFBTSxXQUFXLEtBQUssVUFBVSxJQUFJLFFBQVEsSUFBSSxPQUFPLE9BQU8sa0JBQWtCLFNBQVMsS0FBSyxlQUFlLFNBQVMsTUFBTSxXQUFXLElBQUksZUFBZSxLQUFLLFdBQVcsWUFBWSxhQUFhLFFBQVEsT0FBTyxRQUFRLFdBQVcsaUJBQWlCLFlBQVksUUFBUSxLQUFLLFFBQVEsS0FBSyxPQUFPLEtBQUssWUFBWSxLQUFLLElBQUksU0FBUyxHQUFHLFFBQVEsU0FBUyxNQUFNLFlBQVksTUFBTSxXQUFXLE9BQU8sY0FBYyxNQUFNLEtBQUssS0FBSyxPQUFPLFdBQVcsTUFBTSxJQUFJLEtBQUssS0FBSyxTQUFTLEdBQUcsS0FBSyxLQUFLLFVBQVUsS0FBSyxLQUFLLE9BQU8sVUFBVSxHQUFHLEtBQUssS0FBSyxLQUFLLEtBQUssVUFBVSxPQUFPLFVBQVUsR0FBRyxNQUFNLGtCQUFrQixJQUFJLEtBQUssS0FBSyxLQUFLLFlBQVksUUFBUSxNQUFNLEdBQUcsR0FBRyxLQUFLLE1BQU0sSUFBSSxPQUFPLE9BQU8sR0FBRyxRQUFRLGVBQWUsSUFBSSxNQUFNLGFBQWEsSUFBSSxJQUFJLFlBQVksS0FBSyxHQUFHLE9BQU8sR0FBRyxPQUFPLEdBQUcsSUFBSSxRQUFRLE9BQU8sR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxTQUFTLE9BQU8sR0FBRyxVQUFVLEdBQUcsT0FBTyxXQUFXLElBQUksT0FBTyxHQUFHLE1BQU0sR0FBRyxJQUFJLElBQUksU0FBUyxJQUFJLFFBQVEsU0FBUyxHQUFHLFFBQVEsSUFBSSxTQUFTLE1BQU0sYUFBYSxLQUFLLFdBQVcsZUFBZSxTQUFTLE9BQU8sUUFBUSxJQUFJLFdBQVcsUUFBUSxJQUFJLFdBQVcsTUFBTSxVQUFVLEdBQUcsT0FBTyxhQUFhLEdBQUcsUUFBUSxLQUFLLE1BQU0sT0FBTyxHQUFHLE1BQU0sTUFBTSxhQUFhLEtBQUssSUFBSSxVQUFVLE1BQU0sT0FBTyxXQUFXLEtBQUssa0JBQWtCLElBQUksUUFBUSxLQUFLLE9BQU8sUUFBUSxzQkFBc0IsUUFBUSxhQUFhLE1BQU0sTUFBTSxPQUFPLE1BQU0sWUFBWSxHQUFHLEtBQUssTUFBTSxXQUFXLE1BQU0sS0FBSyxTQUFTLE1BQU0sS0FBSyxPQUFPLFdBQVcsR0FBRyxHQUFHLEdBQUcsT0FBTyxHQUFHLEdBQUcsR0FBRyxHQUFHLFFBQVEsR0FBRyxHQUFHLEdBQUcsT0FBTyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxNQUFNLE9BQU8sR0FBRyxHQUFHLEdBQUcsT0FBTyxHQUFHLEdBQUcsR0FBRyxHQUFHLFFBQVEsTUFBTSxPQUFPLE9BQU8sR0FBRyxHQUFHLEdBQUcsT0FBTyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxVQUFVLFNBQVMsTUFBTSxVQUFVLEtBQUssT0FBTyxHQUFHLFFBQVEsR0FBRyxNQUFNLGFBQWEsSUFBSSxRQUFRLEdBQUcsTUFBTSxHQUFHLGtCQUFrQixNQUFNLEtBQUssT0FBTyxRQUFRLElBQUksTUFBTSxHQUFHLFNBQVMsSUFBSSxjQUFjLEtBQUssT0FBTyxNQUFNLFFBQVEsSUFBSSxPQUFPLFNBQVMsUUFBUSxPQUFPLE9BQU8sT0FBTyxRQUFRLFFBQVEsTUFBTSxJQUFJLFFBQVEsR0FBRyxNQUFNLElBQUksbUJBQW1CLE9BQU8sUUFBUSxHQUFHLEtBQUssTUFBTSxNQUFNLE1BQU0sT0FBTyxLQUFLLE1BQU0sVUFBVSxLQUFLLGFBQWEsTUFBTSxHQUFHLGFBQWEsR0FBRyxPQUFPLElBQUksV0FBVyxLQUFLLGFBQWEsS0FBSyxNQUFNLFFBQVEsS0FBSyxNQUFNLElBQUksYUFBYSxLQUFLLFNBQVMsVUFBVSxHQUFHLE9BQU8sR0FBRyxTQUFTLGNBQWMsR0FBRyxTQUFTLElBQUksVUFBVSxHQUFHLE9BQU8sT0FBTyxRQUFRLElBQUksTUFBTSxJQUFJLEdBQUcsYUFBYSxHQUFHLGlCQUFpQixNQUFNLE1BQU0sT0FBTyxNQUFNLGlCQUFpQixPQUFPLE9BQU8sS0FBSyxhQUFhLEtBQUssUUFBUSxVQUFVLEtBQUssVUFBVSxNQUFNLElBQUksT0FBTyxHQUFHLGFBQWEsS0FBSyxXQUFXLEdBQUcsT0FBTyxVQUFVLElBQUksUUFBUSxRQUFRLE1BQU0sT0FBTyxXQUFXLEdBQUcsVUFBVSxHQUFHLFlBQVksUUFBUSxNQUFNLElBQUksSUFBSSxPQUFPLEtBQUssTUFBTSxRQUFRLFNBQVMsT0FBTyxPQUFPLFVBQVUsS0FBSyxXQUFXLElBQUksTUFBTSxPQUFPLEtBQUssUUFBUSxNQUFNLFFBQVEsZUFBZSxZQUFZLFlBQVksZ0JBQWdCLE9BQU8sZUFBZSxTQUFTLEtBQUssYUFBYSxHQUFHLEtBQUssTUFBTSxVQUFVLE9BQU8sR0FBRyxXQUFXLEtBQUssU0FBUyxRQUFRLFFBQVEsZUFBZSxJQUFJLFdBQVcsT0FBTyxXQUFXLE9BQU8sR0FBRyxRQUFRLEdBQUcsTUFBTSxHQUFHLFNBQVMsR0FBRyxPQUFPLE1BQU0sT0FBTyxLQUFLLFFBQVEsUUFBUSxHQUFHLE1BQU0sS0FBSyxXQUFXLFFBQVEsS0FBSyxHQUFHLGFBQWEsR0FBRyxHQUFHLFNBQVMsSUFBSSxVQUFVLElBQUksWUFBWSxJQUFJLE1BQU0sT0FBTyxLQUFLLEdBQUcsZUFBZSxNQUFNLFNBQVMsWUFBWSxNQUFNLFdBQVcsS0FBSyxPQUFPLElBQUksVUFBVSxVQUFVLEtBQUssU0FBUyxLQUFLLElBQUksUUFBUSxHQUFHLFVBQVUsS0FBSyxTQUFTLEtBQUssY0FBYyxXQUFXLHFCQUFxQixJQUFJLE9BQU8sVUFBVSxRQUFRLEtBQUssSUFBSSxPQUFPLE1BQU0sUUFBUSxLQUFLLEtBQUssTUFBTSxRQUFRLFNBQVMsTUFBTSxHQUFHLFlBQVksbUJBQW1CLElBQUksR0FBRyxJQUFJLEdBQUcsR0FBRyxRQUFRLEdBQUcsUUFBUSxJQUFJLEdBQUcsS0FBSyxPQUFPLEdBQUcsS0FBSyxLQUFLLE1BQU0sTUFBTSxXQUFXLEdBQUcsV0FBVyxRQUFRLEdBQUcsSUFBSSxRQUFRLFNBQVMsR0FBRyxNQUFNLE1BQU0sR0FBRyxNQUFNLEdBQUcsT0FBTyxPQUFPLElBQUksUUFBUSxNQUFNLEdBQUcsUUFBUSxJQUFJLE9BQU8sTUFBTSxHQUFHLE9BQU8sS0FBSyxNQUFNLEdBQUcsR0FBRyxHQUFHLFFBQVEsT0FBTyxNQUFNLE9BQU8sTUFBTSxHQUFHLE9BQU8sTUFBTSxNQUFNLFFBQVEsT0FBTyxHQUFHLEdBQUcsUUFBUSxPQUFPLElBQUksTUFBTSxNQUFNLE9BQU8sZUFBZSxJQUFJLE1BQU0sV0FBVyxPQUFPLE9BQU8sS0FBSyxnQkFBZ0IsSUFBSSxXQUFXLFVBQVUsSUFBSSxNQUFNLFNBQVMsTUFBTSxLQUFLLEdBQUcsUUFBUSxNQUFNLGFBQWEsS0FBSyxPQUFPLE1BQU0sS0FBSyxZQUFZLE9BQU8sVUFBVSxNQUFNLGdCQUFnQixZQUFZLEtBQUssTUFBTSxTQUFTLE1BQU0sTUFBTSxXQUFXLE1BQU0sYUFBYSxPQUFPLEtBQUssSUFBSSxTQUFTLEtBQUssU0FBUyxHQUFHLFFBQVEsT0FBTyxTQUFTLElBQUksT0FBTyxLQUFLLE9BQU8sWUFBWSxPQUFPLE1BQU0sTUFBTSxLQUFLLEtBQUssS0FBSyxPQUFPLE1BQU0sUUFBUSxLQUFLLE9BQU8sTUFBTSxLQUFLLFVBQVUsTUFBTSxRQUFRLE1BQU0sVUFBVSxLQUFLLElBQUksSUFBSSxPQUFPLE9BQU8sU0FBUyxPQUFPLEdBQUcsS0FBSyxNQUFNLEdBQUcsSUFBSSxRQUFRLE1BQU0sVUFBVSxJQUFJLGdCQUFnQixHQUFHLEtBQUssTUFBTSxLQUFLLFFBQVEsTUFBTSxPQUFPLGNBQWMsR0FBRyxXQUFXLEdBQUcsS0FBSyxPQUFPLEtBQUssS0FBSyxLQUFLLEtBQUssY0FBYyxJQUFJLE1BQU0sT0FBTyxNQUFNLEdBQUcsTUFBTSxVQUFVLFFBQVEsTUFBTSxNQUFNLE9BQU8sR0FBRyxJQUFJLElBQUksS0FBSyxRQUFRLE1BQU0sSUFBSSxLQUFLLElBQUksSUFBSSxJQUFJLEtBQUssSUFBSSxPQUFPLEtBQUssTUFBTSxHQUFHLFlBQVksS0FBSyxZQUFZLEdBQUcsUUFBUSxRQUFRLEdBQUcsY0FBYyxTQUFTLElBQUksS0FBSyxHQUFHLFNBQVMsUUFBUSxHQUFHLFdBQVcsT0FBTyxLQUFLLE9BQU8sZUFBZSxNQUFNLGlCQUFpQixJQUFJLGFBQWEsa0JBQWtCLEdBQUcsV0FBVyxZQUFZLGFBQWEsSUFBSSxNQUFNLEdBQUcsT0FBTyxPQUFPLElBQUksUUFBUSxNQUFNLEdBQUcsUUFBUSxJQUFJLGFBQWEsS0FBSyxVQUFVLE1BQU0sTUFBTSxLQUFLLGFBQWEsTUFBTSxHQUFHLE9BQU8sR0FBRyxhQUFhLE1BQU0sR0FBRyxPQUFPLE1BQU0sTUFBTSxLQUFLLFFBQVEsTUFBTSxLQUFLLFdBQVcsU0FBUyxNQUFNLFNBQVMsT0FBTyxNQUFNLE9BQU8sTUFBTSxHQUFHLE9BQU8sYUFBYSxJQUFJLE1BQU0sbUJBQW1CLFlBQVksU0FBUyxZQUFZLGlCQUFpQixPQUFPLFNBQVMsR0FBRyxLQUFLLFFBQVEsU0FBUyxLQUFLLE9BQU8sTUFBTSxHQUFHLFVBQVUsSUFBSSxVQUFVLFFBQVEsUUFBUSxHQUFHLElBQUksS0FBSyxXQUFXLElBQUksR0FBRyxPQUFPLEdBQUcsR0FBRyxRQUFRLE9BQU8sR0FBRyxRQUFRLE9BQU8sT0FBTyxJQUFJLE1BQU0sTUFBTSxNQUFNLE1BQU0sT0FBTyxTQUFTLE1BQU0sR0FBRyxHQUFHLGdCQUFnQixNQUFNLGNBQWMsSUFBSSxZQUFZLFFBQVEsUUFBUSxNQUFNLEtBQUssUUFBUSxRQUFRLE1BQU0sTUFBTSxJQUFJLFFBQVEsV0FBVyxHQUFHLE9BQU8sY0FBYyxJQUFJLElBQUksU0FBUyxPQUFPLEtBQUssS0FBSyxLQUFLLFVBQVUsR0FBRyxNQUFNLEdBQUcsV0FBVyxJQUFJLFFBQVEsVUFBVSxJQUFJLElBQUksUUFBUSxNQUFNLE9BQU8sUUFBUSxLQUFLLGFBQWEsTUFBTSxHQUFHLG1CQUFtQixZQUFZLElBQUksTUFBTSxHQUFHLGNBQWMsVUFBVSxNQUFNLFVBQVUsTUFBTSxJQUFJLE1BQU0sR0FBRyxJQUFJLElBQUksTUFBTSxTQUFTLE9BQU8sR0FBRyxXQUFXLFNBQVMsR0FBRyxhQUFhLEtBQUssT0FBTyxRQUFRLEtBQUssS0FBSyxHQUFHLE9BQU8sTUFBTSxLQUFLLFNBQVMsTUFBTSxJQUFJLE9BQU8sTUFBTSxTQUFTLElBQUksVUFBVSxHQUFHLE1BQU0sT0FBTyxNQUFNLE1BQU0sR0FBRyxPQUFPLElBQUksTUFBTSxNQUFNLEdBQUcsV0FBVyxLQUFLLEtBQUssT0FBTyxNQUFNLEdBQUcsSUFBSSxNQUFNLFNBQVMsR0FBRyxLQUFLLElBQUksTUFBTSxZQUFZLFlBQVksT0FBTyxHQUFHLE9BQU8sT0FBTyxHQUFHLE9BQU8sTUFBTSxPQUFPLEdBQUcsUUFBUSxRQUFRLE1BQU0sT0FBTyxHQUFHLEtBQUssT0FBTyxHQUFHLEdBQUcsU0FBUyxPQUFPLEdBQUcsR0FBRyxnQkFBZ0IsT0FBTyxJQUFJLEdBQUcsUUFBUSxNQUFNLEtBQUssTUFBTSxNQUFNLElBQUksYUFBYSxRQUFRLEdBQUcsR0FBRyxZQUFZLFFBQVEsR0FBRyxZQUFZLEtBQUssR0FBRyxHQUFHLGFBQWEsVUFBVSxRQUFRLE1BQU0sR0FBRyxPQUFPLEtBQUssVUFBVSxJQUFJLFdBQVcsR0FBRyxHQUFHLFFBQVEsT0FBTyxHQUFHLFVBQVUsSUFBSSxPQUFPLEdBQUcsR0FBRyxRQUFRLE9BQU8sR0FBRyxhQUFhLE1BQU0sS0FBSyxtQkFBbUIsSUFBSSxXQUFXLElBQUksU0FBUyxNQUFNLEtBQUssSUFBSSxZQUFZLE1BQU0sSUFBSSxNQUFNLE9BQU8sR0FBRyxRQUFRLFNBQVMsR0FBRyxNQUFNLEtBQUssV0FBVyxNQUFNLE1BQU0sVUFBVSxTQUFTLE1BQU0sSUFBSSxRQUFRLFNBQVMsVUFBVSxLQUFLLFlBQVksR0FBRyxLQUFLLFVBQVUsTUFBTSxJQUFJLElBQUksTUFBTSxPQUFPLFNBQVMsR0FBRyxTQUFTLE1BQU0sSUFBSSxVQUFVLEdBQUcsTUFBTSxTQUFTLFFBQVEsTUFBTSxNQUFNLEdBQUcsVUFBVSxLQUFLLFVBQVUsR0FBRyxLQUFLLE9BQU8sUUFBUSxLQUFLLEtBQUssT0FBTyxLQUFLLE1BQU0sT0FBTyxJQUFJLElBQUksSUFBSSxRQUFRLElBQUksT0FBTyxHQUFHLFNBQVMsTUFBTSxLQUFLLFdBQVcsU0FBUyxJQUFJLE9BQU8sT0FBTyxZQUFZLE1BQU0sTUFBTSxVQUFVLEdBQUcsSUFBSSxLQUFLLFVBQVUsS0FBSyxLQUFLLEdBQUcsTUFBTSxLQUFLLFVBQVUsR0FBRyxPQUFPLEtBQUssT0FBTyxTQUFTLEdBQUcsaUJBQWlCLEdBQUcsS0FBSyxRQUFRLE1BQU0sR0FBRyxLQUFLLE9BQU8sR0FBRyxJQUFJLElBQUksTUFBTSxLQUFLLEtBQUssWUFBWSxJQUFJLEtBQUssUUFBUSxHQUFHLElBQUksS0FBSyxNQUFNLE1BQU0sUUFBUSxTQUFTLElBQUksWUFBWSxLQUFLLEtBQUssTUFBTSxVQUFVLEdBQUcsUUFBUSxJQUFJLEtBQUssUUFBUSxVQUFVLE1BQU0sTUFBTSxPQUFPLElBQUksT0FBTyxNQUFNLFNBQVMsR0FBRyxRQUFRLFNBQVMsS0FBSyxLQUFLLE9BQU8sS0FBSyxrQkFBa0IsS0FBSyxTQUFTLElBQUksS0FBSyxnQkFBZ0IsSUFBSSxNQUFNLE9BQU8sS0FBSyxXQUFXLEtBQUssTUFBTSxRQUFRLE9BQU8sR0FBRyxHQUFHLElBQUksTUFBTSxRQUFRLElBQUksTUFBTSxJQUFJLElBQUksSUFBSSxJQUFJLElBQUksSUFBSSxLQUFLLElBQUksR0FBRyxVQUFVLE9BQU8sTUFBTSxZQUFZLEtBQUssWUFBWSxHQUFHLFFBQVEsUUFBUSxHQUFHLGNBQWMsU0FBUyxJQUFJLEtBQUssR0FBRyxTQUFTLE9BQU8sUUFBUSxHQUFHLEtBQUssWUFBWSxLQUFLLE1BQU0sR0FBRyxLQUFLLEdBQUcsWUFBWSxNQUFNLEdBQUcsYUFBYSxNQUFNLEdBQUcsUUFBUSxHQUFHLHNCQUFzQixNQUFNLGlCQUFpQixJQUFJLGdCQUFnQixVQUFVLGNBQWMsWUFBWSxZQUFZLEtBQUssWUFBWSxVQUFVLEtBQUssR0FBRyxXQUFXLE1BQU0sT0FBTyxZQUFZLElBQUksTUFBTSxRQUFRLEdBQUcsS0FBSyxRQUFRLFlBQVksSUFBSSxTQUFTLE9BQU8sVUFBVSxJQUFJLEdBQUcsT0FBTyxPQUFPLEdBQUcsYUFBYSxNQUFNLE9BQU8sR0FBRyxHQUFHLE1BQU0sVUFBVSxHQUFHLFlBQVksTUFBTSxNQUFNLEdBQUcsT0FBTyxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sT0FBTyxJQUFJLEtBQUssU0FBUyxLQUFLLEdBQUcsU0FBUyxHQUFHLEdBQUcsVUFBVSxTQUFTLE1BQU0sSUFBSSxNQUFNLEtBQUssTUFBTSxXQUFXLEdBQUcsS0FBSyxRQUFRLEtBQUssVUFBVSxTQUFTLEdBQUcsWUFBWSxVQUFVLElBQUksY0FBYyxHQUFHLEdBQUcsT0FBTyxLQUFLLE1BQU0sR0FBRyxPQUFPLEdBQUcsT0FBTyxHQUFHLEtBQUssTUFBTSxNQUFNLFFBQVEsb0JBQW9CLEtBQUssU0FBUyxPQUFPLElBQUksT0FBTyxNQUFNLEdBQUcsYUFBYSxNQUFNLE1BQU0sSUFBSSxNQUFNLGNBQWMsS0FBSyxJQUFJLGdCQUFnQixHQUFHLFFBQVEsR0FBRyxhQUFhLEdBQUcsUUFBUSxJQUFJLFFBQVEsR0FBRyxRQUFRLElBQUksU0FBUyxRQUFRLEdBQUcsSUFBSSxRQUFRLFFBQVEsTUFBTSxNQUFNLE1BQU0sWUFBWSxHQUFHLHNCQUFzQixLQUFLLEtBQUssWUFBWSxHQUFHLEtBQUssTUFBTSxLQUFLLE9BQU8sT0FBTyxHQUFHLE9BQU8sTUFBTSxXQUFXLE9BQU8sR0FBRyxTQUFTLEdBQUcsTUFBTSxPQUFPLEdBQUcsVUFBVSxRQUFRLFNBQVMsSUFBSSxZQUFZLEtBQUssS0FBSyxNQUFNLElBQUksSUFBSSxPQUFPLElBQUksSUFBSSxHQUFHLEdBQUcsUUFBUSxLQUFLLE9BQU8sS0FBSyxVQUFVLElBQUksT0FBTyxNQUFNLE9BQU8sR0FBRyxPQUFPLFdBQVcsT0FBTyxHQUFHLFNBQVMsR0FBRyxNQUFNLE9BQU8sR0FBRyxhQUFhLFNBQVMsTUFBTSxJQUFJLFFBQVEsT0FBTyxnQkFBZ0IsR0FBRyxNQUFNLFVBQVUsTUFBTSxHQUFHLE1BQU0sT0FBTyxJQUFJ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O0FBRTVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQ0FBZ0MsWUFBWTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQix1QkFBdUI7QUFDekM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLHVCQUF1QjtBQUN6QztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkIsb0JBQW9CO0FBQy9DLDRCQUE0QixrQkFBa0I7QUFDOUMsNkJBQTZCLG1CQUFtQjtBQUNoRCwyQkFBMkIsdUJBQXVCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsdUJBQXVCO0FBQzFELG1DQUFtQyx1QkFBdUI7QUFDMUQsMEJBQTBCLHFCQUFxQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEIscUJBQXFCO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLGdDQUFnQyxFQUFFO0FBQ3BFLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyw4QkFBOEIsRUFBRTtBQUNsRSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNDQUFzQyxPQUFPO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsT0FBTztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSx3Q0FBd0MsUUFBUTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLDRDQUE0Qzs7QUFFNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0Esd0NBQXdDLFFBQVE7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtDQUFrQyxRQUFRO0FBQzFDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixxQkFBcUI7QUFDckMsZ0RBQWdELDZCQUE2QixFQUFFO0FBQy9FO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjs7QUFFbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCOztBQUVBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiwyQkFBMkI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsaUJBQWlCLEVBQUU7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4QkFBOEI7O0FBRTlCO0FBQ0E7QUFDQTtBQUNBLDREQUE0RDtBQUM1RDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0IsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6Qix5QkFBeUI7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0IsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6Qix5QkFBeUI7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0IsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0IsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlCQUF5QjtBQUN6Qix5QkFBeUI7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxJQUFJO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDLHFDQUFxQztBQUNyQyxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQyxxQ0FBcUM7QUFDckMsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQyxxQ0FBcUM7QUFDckMsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBLHdDQUF3QztBQUN4QyxpQ0FBaUM7QUFDakM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1Q0FBdUM7QUFDdkMsaUNBQWlDO0FBQ2pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckMsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3Q0FBd0MsUUFBUTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxRQUFRO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7O0FBRWQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCLGNBQWM7O0FBRWQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBOztBQUVBO0FBQ0Esc0NBQXNDLFFBQVE7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNDQUFzQyxPQUFPO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZOztBQUVaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxPQUFPO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUEsMENBQTBDO0FBQzFDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixpQkFBaUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtB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Q2hCO0FBQ0E7QUFDQSxlQUFlLEVBQUU7QUFDakIsZUFBZSxFQUFFO0FBQ2pCLGVBQWUsRUFBRTtBQUNqQixlQUFlLEVBQUU7QUFDakIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEVBQUU7QUFDakIsZUFBZSxFQUFFO0FBQ2pCLGVBQWUsRUFBRTtBQUNqQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLGVBQWUsRUFBRTtBQUNqQixlQUFlLEVBQUU7QUFDakIsZUFBZSxFQUFFO0FBQ2pCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxFQUFFO0FBQ2pCLGVBQWUsRUFBRTtBQUNqQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLGVBQWUsRUFBRTtBQUNqQixlQUFlLEVBQUU7QUFDakIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEVBQUU7QUFDakIsZUFBZSxFQUFFO0FBQ2pCLGVBQWUsRUFBRTtBQUNqQixlQUFlLEVBQUU7QUFDakIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxlQUFlLEVBQUU7QUFDakIsZUFBZSxFQUFFO0FBQ2pCLGVBQWUsRUFBRTtBQUNqQixlQUFlLEVBQUU7QUFDakIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLEVBQUUsc0JBQXNCLEVBQUU7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEVBQUU7QUFDakIsZUFBZSxFQUFFO0FBQ2pCLGVBQWUsRUFBRTtBQUNqQixlQUFlLEVBQUU7QUFDakIsZUFBZSxFQUFFO0FBQ2pCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0EsZUFBZSxFQUFFO0FBQ2pCLGVBQWUsRUFBRTtBQUNqQixlQUFlLEVBQUU7QUFDakIsZUFBZSxFQUFFO0FBQ2pCLGVBQWUsRUFBRTtBQUNqQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEdBQUc7QUFDbEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxlQUFlLEdBQUc7QUFDbEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxxQ0FBcUMsa0JBQWtCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQSwrQkFBK0IsRUFBRTtBQUNqQyxtQ0FBbUMsRUFBRTtBQUNyQyxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0EsaUJBQWlCLG1EQUFtRDtBQUNwRTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLGNBQWMsV0FBVztBQUN6QjtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsc0JBQXNCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLEVBQUU7QUFDdEMsaUNBQWlDLEVBQUU7QUFDbkM7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLEVBQUU7QUFDakMsNkRBQTZELGtEQUFrRCxFQUFFO0FBQ2pILGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxhQUFhLEVBQUU7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsRUFBRSxzREFBc0Qsa0NBQWtDLEVBQUU7QUFDbkgsdUJBQXVCLEVBQUU7QUFDekI7QUFDQSwyQkFBMkIsRUFBRTtBQUM3QiwyQkFBMkIsRUFBRTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsK0JBQStCLEVBQUU7QUFDakM7QUFDQSxtQ0FBbUMsRUFBRTtBQUNyQztBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxvQ0FBb0MsRUFBRSxVQUFVLHNCQUFzQjtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsMEJBQTBCLEVBQUU7QUFDekY7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxFQUFFO0FBQ2pCLGVBQWUsRUFBRTtBQUNqQixlQUFlLEVBQUU7QUFDakIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLGVBQWUsRUFBRTtBQUNqQixlQUFlLEVBQUU7QUFDakIsZUFBZSxFQUFFO0FBQ2pCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixFQUFFO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBLHFCQUFxQixxQkFBcUIsRUFBRTtBQUM1QztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZUFBZSxFQUFFO0FBQ2pCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0EsZUFBZSxFQUFFO0FBQ2pCLGdCQUFnQjtBQUNoQjtBQUNBLG1CQUFtQiwyQkFBMkI7QUFDOUM7QUFDQSxlQUFlLEVBQUU7QUFDakIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxlQUFlLEVBQUU7QUFDakIsZ0JBQWdCO0FBQ2hCO0FBQ0EsbUJBQW1CLDBCQUEwQjtBQUM3QztBQUNBLGVBQWUsRUFBRTtBQUNqQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLGVBQWUsRUFBRTtBQUNqQixnQkFBZ0I7QUFDaEI7QUFDQSxtQkFBbUIsNkJBQTZCO0FBQ2hEO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsYUFBYSxFQUFFO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQSxpQkFBaUIsc0JBQXNCO0FBQ3ZDO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELGFBQWEsRUFBRTtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsRUFBRTtBQUNqQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLGVBQWUsRUFBRTtBQUNqQixnQkFBZ0I7QUFDaEI7QUFDQSxrQkFBa0IsMENBQTBDO0FBQzVEO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQSxpQkFBaUIsNkNBQTZDO0FBQzlEO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQSxxQkFBcUIscUNBQXFDLEVBQUU7QUFDNUQ7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixFQUFFO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLFdBQVcsRUFBRTtBQUNiLFdBQVcsRUFBRTtBQUNiLFlBQVk7QUFDWjtBQUNBO0FBQ0EsdUJBQXVCLEVBQUU7QUFDekI7O0FBRUE7QUFDQTtBQUNBLGNBQWMsV0FBVztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxFQUFFO0FBQ2pCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0EsZUFBZSxFQUFFO0FBQ2pCLGdCQUFnQjtBQUNoQjtBQUNBLHFCQUFxQixvQ0FBb0M7QUFDekQ7QUFDQSxlQUFlLEVBQUU7QUFDakIsZUFBZSxFQUFFO0FBQ2pCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0EsZUFBZSxFQUFFO0FBQ2pCLGVBQWUsRUFBRTtBQUNqQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsRUFBRTtBQUNqQixlQUFlLEVBQUU7QUFDakIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxlQUFlLEVBQUU7QUFDakIsZUFBZSxFQUFFO0FBQ2pCLGdCQUFnQjtBQUNoQjtBQUNBLDJCQUEyQixvQ0FBb0M7QUFDL0Q7QUFDQSxlQUFlLEVBQUU7QUFDakIsZUFBZSxFQUFFO0FBQ2pCLGVBQWUsRUFBRTtBQUNqQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLGVBQWUsRUFBRTtBQUNqQixlQUFlLEVBQUU7QUFDakIsZUFBZSxFQUFFO0FBQ2pCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxFQUFFO0FBQ2pCLGVBQWUsRUFBRTtBQUNqQixlQUFlLEdBQUc7QUFDbEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxlQUFlLEVBQUU7QUFDakIsZUFBZSxFQUFFO0FBQ2pCLGVBQWUsR0FBRztBQUNsQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLDBCQUEwQixFQUFFLGlCQUFpQixFQUFFO0FBQy9DO0FBQ0E7QUFDQSxlQUFlLEVBQUU7QUFDakIsZUFBZSxFQUFFO0FBQ2pCLGVBQWUsRUFBRTtBQUNqQixlQUFlLEVBQUU7QUFDakIsZUFBZSxFQUFFO0FBQ2pCLGVBQWUsR0FBRztBQUNsQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLGVBQWUsRUFBRTtBQUNqQixlQUFlLEVBQUU7QUFDakIsZUFBZSxFQUFFO0FBQ2pCLGVBQWUsRUFBRTtBQUNqQixlQUFlLEVBQUU7QUFDakIsZUFBZSxHQUFHO0FBQ2xCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0EseUNBQXlDLHNCQUFzQjtBQUMvRCx1QkFBdUIsRUFBRTtBQUN6Qix1QkFBdUIsRUFBRSxxQkFBcUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixFQUFFLDZDQUE2QyxFQUFFLCtDQUErQyw4Q0FBOEMsRUFBRTtBQUN2SztBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLGdFQUFnRSxFQUFFO0FBQ2xFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhDQUE4QyxjQUFjOztBQUU1RCxDQUFDO0FBQ0Q7Ozs7Ozs7QUN2cE1BLDhDOzs7Ozs7QUNBQSw4Qzs7Ozs7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyw2REFBNkQsMkNBQTJDO0FBQzlJLENBQUMsbUhBQW1IOztBQUVwSDtBQUNBO0FBQ0EsK0RBQStEO0FBQy9EO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNLGdCQUFnQixzQ0FBc0MsaUJBQWlCLEVBQUU7QUFDL0UscUJBQXFCLHVEQUF1RDs7QUFFNUU7QUFDQTtBQUNBLG1CQUFtQixzQkFBc0I7QUFDekM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsV0FBVztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixFQUFFLDBCQUEwQixFQUFFO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQixTQUFTO0FBQ1QscUNBQXFDLEVBQUU7QUFDdkM7QUFDQTtBQUNBO0FBQ0EsZUFBZSxFQUFFO0FBQ2pCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0EsZUFBZSxFQUFFO0FBQ2pCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0EsdUJBQXVCLEVBQUU7QUFDekI7QUFDQSx1QkFBdUIsRUFBRTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsaUNBQWlDO0FBQzFDO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQsU0FBUyx3Q0FBd0M7QUFDakQsU0FBUyxnQ0FBZ0MseUVBQXlFLElBQUk7QUFDdEgsTUFBTTtBQUNOO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsRUFBRTtBQUNqQixlQUFlLEdBQUc7QUFDbEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxlQUFlLEVBQUU7QUFDakIsZUFBZSxHQUFHO0FBQ2xCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0EsMkVBQTJFO0FBQzNFO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsRUFBRTtBQUNqQixlQUFlLEVBQUU7QUFDakIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxlQUFlLEVBQUU7QUFDakIsZUFBZSxFQUFFO0FBQ2pCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxFQUFFO0FBQ2pCLGVBQWUsS0FBSztBQUNwQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLGVBQWUsRUFBRTtBQUNqQixlQUFlLEtBQUs7QUFDcEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix1QkFBdUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsRUFBRTtBQUNqQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLGVBQWUsRUFBRTtBQUNqQixnQkFBZ0I7QUFDaEI7QUFDQSxtQkFBbUIsMEJBQTBCO0FBQzdDO0FBQ0EsZUFBZSxFQUFFO0FBQ2pCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0EsZUFBZSxFQUFFO0FBQ2pCLGdCQUFnQjtBQUNoQjtBQUNBLG1CQUFtQiwyQkFBMkI7QUFDOUM7QUFDQSxlQUFlLEVBQUU7QUFDakIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxlQUFlLEVBQUU7QUFDakIsZ0JBQWdCO0FBQ2hCO0FBQ0EsbUJBQW1CLDZCQUE2QjtBQUNoRDtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0EsaUJBQWlCLHVCQUF1QjtBQUN4QztBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0EsaUJBQWlCLHNCQUFzQjtBQUN2QztBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0EsaUJBQWlCLHdCQUF3QjtBQUN6QztBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0EsaUJBQWlCLDBCQUEwQjtBQUMzQztBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0EsaUJBQWlCLHlCQUF5QjtBQUMxQztBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0EsaUJBQWlCLDBCQUEwQjtBQUMzQztBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0EsaUJBQWlCLHdCQUF3QjtBQUN6QztBQUNBLGVBQWUsRUFBRTtBQUNqQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLGVBQWUsRUFBRTtBQUNqQixnQkFBZ0I7QUFDaEI7QUFDQSxrQkFBa0IsaUNBQWlDO0FBQ25EO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQSxpQkFBaUIsVUFBVTtBQUMzQjtBQUNBLENBQUM7QUFDRDtBQUNBLFdBQVcsRUFBRTtBQUNiLFdBQVcsRUFBRTtBQUNiLFdBQVcsRUFBRTtBQUNiLFdBQVcsRUFBRTtBQUNiLFdBQVcsRUFBRTtBQUNiLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxXQUFXO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsRUFBRTtBQUNqQixlQUFlLEVBQUU7QUFDakIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxlQUFlLEVBQUU7QUFDakIsZUFBZSxFQUFFO0FBQ2pCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsRUFBRTtBQUN6QjtBQUNBO0FBQ0EsdUJBQXVCLEVBQUU7QUFDekI7QUFDQSwyQkFBMkIsRUFBRTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixFQUFFO0FBQ3pCLHVCQUF1QixFQUFFO0FBQ3pCO0FBQ0E7QUFDQSx1QkFBdUIsRUFBRSxtQ0FBbUMsRUFBRTtBQUM5RDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSwwRkFBMEYsNkJBQTZCLEVBQUU7QUFDekg7QUFDQTtBQUNBO0FBQ0EsZUFBZSxFQUFFO0FBQ2pCLGVBQWUsRUFBRTtBQUNqQixlQUFlLEVBQUU7QUFDakIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxlQUFlLEVBQUU7QUFDakIsZUFBZSxFQUFFO0FBQ2pCLGVBQWUsRUFBRTtBQUNqQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsaUJBQWlCLEVBQUU7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBLGlCQUFpQix3Q0FBd0M7QUFDekQ7QUFDQSxTQUFTLGlDQUFpQztBQUMxQztBQUNBO0FBQ0EsMkRBQTJEO0FBQzNELFNBQVMsd0NBQXdDO0FBQ2pELFNBQVMsc0RBQXNEO0FBQy9ELFNBQVMsOEJBQThCO0FBQ3ZDLE1BQU07QUFDTjtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFLG1CQUFtQixFQUFFLGdDQUFnQyxFQUFFO0FBQzVIO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBLHFCQUFxQiwyQkFBMkIsRUFBRTtBQUNsRDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxFQUFFO0FBQ2pCLGVBQWUsR0FBRztBQUNsQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLGVBQWUsRUFBRTtBQUNqQixlQUFlLEdBQUc7QUFDbEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEVBQUU7QUFDakIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxlQUFlLEVBQUU7QUFDakIsZ0JBQWdCO0FBQ2hCO0FBQ0Esc0JBQXNCLDJDQUEyQztBQUNqRTtBQUNBLGVBQWUsRUFBRTtBQUNqQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLGVBQWUsRUFBRTtBQUNqQixnQkFBZ0I7QUFDaEI7QUFDQSxzQkFBc0Isd0NBQXdDO0FBQzlEO0FBQ0EsZUFBZSxFQUFFO0FBQ2pCLGVBQWUsRUFBRTtBQUNqQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLGVBQWUsRUFBRTtBQUNqQixlQUFlLEVBQUU7QUFDakIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsRUFBRTtBQUNqQixlQUFlLEVBQUU7QUFDakIsZUFBZSxFQUFFO0FBQ2pCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0EsZUFBZSxFQUFFO0FBQ2pCLGVBQWUsRUFBRTtBQUNqQixlQUFlLEVBQUU7QUFDakIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsRUFBRTtBQUNqQixlQUFlLEVBQUU7QUFDakIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxlQUFlLEVBQUU7QUFDakIsZUFBZSxFQUFFO0FBQ2pCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxFQUFFO0FBQ2pCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0EsZUFBZSxFQUFFO0FBQ2pCLGdCQUFnQjtBQUNoQjtBQUNBLCtCQUErQix3REFBd0Q7QUFDdkY7QUFDQSxlQUFlLEVBQUU7QUFDakIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxlQUFlLEVBQUU7QUFDakIsZ0JBQWdCO0FBQ2hCO0FBQ0EscUJBQXFCLHVDQUF1QztBQUM1RDtBQUNBLGVBQWUsRUFBRTtBQUNqQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLGVBQWUsRUFBRTtBQUNqQixnQkFBZ0I7QUFDaEI7QUFDQSxxQkFBcUIsd0NBQXdDO0FBQzdEO0FBQ0EsZUFBZSxFQUFFO0FBQ2pCLGVBQWUsRUFBRTtBQUNqQixlQUFlLEVBQUU7QUFDakIsZUFBZSxHQUFHO0FBQ2xCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0EsZUFBZSxFQUFFO0FBQ2pCLGVBQWUsRUFBRTtBQUNqQixlQUFlLEVBQUU7QUFDakIsZUFBZSxHQUFHO0FBQ2xCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxFQUFFO0FBQ2pCLGVBQWUsRUFBRTtBQUNqQixlQUFlLEdBQUc7QUFDbEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxlQUFlLEVBQUU7QUFDakIsZUFBZSxFQUFFO0FBQ2pCLGVBQWUsR0FBRztBQUNsQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsRUFBRTtBQUNqQixlQUFlLEVBQUU7QUFDakIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxlQUFlLEVBQUU7QUFDakIsZUFBZSxFQUFFO0FBQ2pCLGdCQUFnQjtBQUNoQjtBQUNBLHlCQUF5QixrQ0FBa0M7QUFDM0Q7QUFDQSxlQUFlLEVBQUU7QUFDakIsZUFBZSxFQUFFO0FBQ2pCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0EsZUFBZSxFQUFFO0FBQ2pCLGVBQWUsRUFBRTtBQUNqQixnQkFBZ0I7QUFDaEI7QUFDQSx5QkFBeUIscUNBQXFDO0FBQzlEO0FBQ0EsZUFBZSxFQUFFO0FBQ2pCLGVBQWUsRUFBRTtBQUNqQixlQUFlLEVBQUU7QUFDakIsZUFBZSxHQUFHO0FBQ2xCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0EsZUFBZSxFQUFFO0FBQ2pCLGVBQWUsRUFBRTtBQUNqQixlQUFlLEVBQUU7QUFDakIsZUFBZSxHQUFHO0FBQ2xCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxFQUFFO0FBQ2pCLGVBQWUsRUFBRTtBQUNqQixlQUFlLEdBQUc7QUFDbEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxlQUFlLEVBQUU7QUFDakIsZUFBZSxFQUFFO0FBQ2pCLGVBQWUsR0FBRztBQUNsQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsRUFBRTtBQUNqQixlQUFlLEVBQUU7QUFDakIsZUFBZSxFQUFFO0FBQ2pCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0EsZUFBZSxFQUFFO0FBQ2pCLGVBQWUsRUFBRTtBQUNqQixlQUFlLEVBQUU7QUFDakIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxFQUFFO0FBQ2pCLGVBQWUsRUFBRTtBQUNqQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLGVBQWUsRUFBRTtBQUNqQixlQUFlLEVBQUU7QUFDakIsZ0JBQWdCO0FBQ2hCO0FBQ0EsNEJBQTRCLHFDQUFxQztBQUNqRTtBQUNBLGVBQWUsRUFBRTtBQUNqQixlQUFlLEVBQUU7QUFDakIsZUFBZSxFQUFFO0FBQ2pCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0EsZUFBZSxFQUFFO0FBQ2pCLGVBQWUsRUFBRTtBQUNqQixlQUFlLEVBQUU7QUFDakIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEVBQUU7QUFDakIsZUFBZSxFQUFFO0FBQ2pCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0EsZUFBZSxFQUFFO0FBQ2pCLGVBQWUsRUFBRTtBQUNqQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEVBQUU7QUFDakIsZUFBZSxFQUFFO0FBQ2pCLGVBQWUsRUFBRTtBQUNqQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLGVBQWUsRUFBRTtBQUNqQixlQUFlLEVBQUU7QUFDakIsZUFBZSxFQUFFO0FBQ2pCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELEVBQUU7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEVBQUU7QUFDakIsZUFBZSxFQUFFO0FBQ2pCLGVBQWUsRUFBRTtBQUNqQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLGVBQWUsRUFBRTtBQUNqQixlQUFlLEVBQUU7QUFDakIsZUFBZSxFQUFFO0FBQ2pCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixFQUFFO0FBQzdCLDJCQUEyQixFQUFFO0FBQzdCLDJCQUEyQixFQUFFO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixFQUFFLDBCQUEwQixFQUFFO0FBQzdEO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxXQUFXLEVBQUU7QUFDYixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsRUFBRTtBQUNiLFlBQVk7QUFDWjtBQUNBO0FBQ0EsbUJBQW1CLEVBQUU7QUFDckIsbUJBQW1CLEVBQUU7QUFDckIsbUJBQW1CLEVBQUU7QUFDckI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxXQUFXO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLGlDQUFpQztBQUMxQztBQUNBO0FBQ0EsNERBQTREO0FBQzVELFNBQVMscURBQXFEO0FBQzlELFNBQVMsK0RBQStEO0FBQ3hFLE1BQU07QUFDTjtBQUNBLENBQUM7QUFDRDtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEVBQUU7QUFDYixXQUFXLEVBQUU7QUFDYixXQUFXLEVBQUU7QUFDYixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssbUZBQW1GO0FBQ3hGLEtBQUssZ0hBQWdIO0FBQ3JILEtBQUssNkZBQTZGO0FBQ2xHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsbUhBQW1IOztBQUU3SjtBQUNBO0FBQ0EsY0FBYyxXQUFXO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsaUJBQWlCLElBQUk7QUFDckI7QUFDQTtBQUNBLDBEQUEwRCxXQUFXO0FBQ3JFO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxpQkFBaUIsSUFBSTtBQUNyQjtBQUNBO0FBQ0EsdURBQXVELFdBQVc7QUFDbEU7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhDQUE4QyxjQUFjOztBQUU1RCxDQUFDO0FBQ0Q7Ozs7Ozs7QUM3NUJBLDZDOzs7Ozs7QUNBQSxnQzs7Ozs7OztBQ0FBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUNBQW1DLE9BQU87QUFDMUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxPQUFPO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsT0FBTztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsR0FBRztBQUNuQzs7QUFFQTtBQUNBO0FBQ0EsbUNBQW1DLFFBQVE7QUFDM0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFNBQVM7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7QUN6U0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isb0JBQW9CO0FBQ3BDLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCLDZCQUE2QjtBQUM3Qiw2QkFBNkI7QUFDN0IsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQSxJQUFJOztBQUVKLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7Ozs7QUNuREQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGlCQUFpQjtBQUNqQyxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7Ozs7OztBQ2xCRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7Ozs7Ozs7QUNySUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7QUNOQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSwwQ0FBMEMsNEJBQTRCO0FBQ3RFO0FBQ0EsMENBQTBDLDJDQUEyQztBQUNyRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHVDQUF1QyxFQUFFO0FBQ2hFO0FBQ0Esd0RBQXdELFFBQVE7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FB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QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsZUFBZTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDdEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ05BO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsUUFBUTtBQUNsRDtBQUNBO0FBQ0EsR0FBRztBQUNIOzs7Ozs7OztBQ3pQQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEMsd0NBQXdDO0FBQ3hDLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDLHdDQUF3QztBQUN4QywyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0U7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEMsd0NBQXdDO0FBQ3hDLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsUUFBUTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFFBQVE7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsdUJBQXVCO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELDBCQUEwQjtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxJQUFJO0FBQ2YsV0FBVyxJQUFJO0FBQ2Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFdBQVc7QUFDdEIsV0FBVyxXQUFXO0FBQ3RCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE1BQU07QUFDakIsV0FBVyxJQUFJO0FBQ2YsV0FBVyxJQUFJO0FBQ2Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNB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QkFBcUI7QUFDckI7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQSxhQUFhOztBQUViOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGFBQWE7O0FBRWI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWE7O0FBRWI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxhQUFhOztBQUViOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsc0JBQXNCLHVCQUF1QjtBQUN0RTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCOztBQUV6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCOztBQUVyQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCOztBQUVyQjs7QUFFQTs7QUFFQSxhQUFhOztBQUViO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qjs7QUFFekI7QUFDQTtBQUNBO0FBQ0EscUJBQXFCOztBQUVyQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7O0FBRTdCO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTs7QUFFQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLFlBQVk7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTs7QUFFQTtBQUNBLGFBQWE7O0FBRWI7O0FBRUE7QUFDQTtB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1Q0FBdUMsNENBQTRDO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1Q0FBdUMsNkNBQTZDO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCOztBQUVyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7O0FBRXJCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjs7QUFFckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQU9BOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FB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QTtBQUNBOztBQUVBLGlDQUFpQyxtQkFBbUI7QUFDcEQ7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7OztBQUlMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLFNBQVM7O0FBRVQsMkNBQTJDO0FBQzNDO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBLDJEQUEy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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsOEJBQThCO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsU0FBUztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLFVBQVU7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7O0FB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QUUsSUFBSSxFQUFFLENBQUM7S0FDMUIsQ0FBQztDQUNMLENBQUM7Ozs7Ozs7QUM1Q0Ysd1MiLCJmaWxlIjoibWFpbi1zZXJ2ZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBvYmplY3QgdG8gc3RvcmUgbG9hZGVkIGNodW5rc1xuIFx0Ly8gXCIwXCIgbWVhbnMgXCJhbHJlYWR5IGxvYWRlZFwiXG4gXHR2YXIgaW5zdGFsbGVkQ2h1bmtzID0ge1xuIFx0XHQ0OiAwXG4gXHR9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuIFx0XHR9XG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cbiBcdC8vIFRoaXMgZmlsZSBjb250YWlucyBvbmx5IHRoZSBlbnRyeSBjaHVuay5cbiBcdC8vIFRoZSBjaHVuayBsb2FkaW5nIGZ1bmN0aW9uIGZvciBhZGRpdGlvbmFsIGNodW5rc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5lID0gZnVuY3Rpb24gcmVxdWlyZUVuc3VyZShjaHVua0lkKSB7XG4gXHRcdC8vIFwiMFwiIGlzIHRoZSBzaWduYWwgZm9yIFwiYWxyZWFkeSBsb2FkZWRcIlxuIFx0XHRpZihpbnN0YWxsZWRDaHVua3NbY2h1bmtJZF0gIT09IDApIHtcbiBcdFx0XHR2YXIgY2h1bmsgPSByZXF1aXJlKFwiLi9cIiArIGNodW5rSWQgKyBcIi5qc1wiKTtcbiBcdFx0XHR2YXIgbW9yZU1vZHVsZXMgPSBjaHVuay5tb2R1bGVzLCBjaHVua0lkcyA9IGNodW5rLmlkcztcbiBcdFx0XHRmb3IodmFyIG1vZHVsZUlkIGluIG1vcmVNb2R1bGVzKSB7XG4gXHRcdFx0XHRtb2R1bGVzW21vZHVsZUlkXSA9IG1vcmVNb2R1bGVzW21vZHVsZUlkXTtcbiBcdFx0XHR9XG4gXHRcdFx0Zm9yKHZhciBpID0gMDsgaSA8IGNodW5rSWRzLmxlbmd0aDsgaSsrKVxuIFx0XHRcdFx0aW5zdGFsbGVkQ2h1bmtzW2NodW5rSWRzW2ldXSA9IDA7XG4gXHRcdH1cbiBcdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuIFx0fTtcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHtcbiBcdFx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuIFx0XHRcdFx0Z2V0OiBnZXR0ZXJcbiBcdFx0XHR9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJkaXN0L1wiO1xuXG4gXHQvLyB1bmNhdGNoZWQgZXJyb3IgaGFuZGxlciBmb3Igd2VicGFjayBydW50aW1lXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm9lID0gZnVuY3Rpb24oZXJyKSB7XG4gXHRcdHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gXHRcdFx0dGhyb3cgZXJyOyAvLyBjYXRjaCB0aGlzIGVycm9yIGJ5IHVzaW5nIFN5c3RlbS5pbXBvcnQoKS5jYXRjaCgpXG4gXHRcdH0pO1xuIFx0fTtcblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSA2Nik7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjay9ib290c3RyYXAgODM4YWVhZjI0MThmODE1NzExZGYiLCJtb2R1bGUuZXhwb3J0cyA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKDIpKSgxMCk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZGVsZWdhdGVkIC4vbm9kZV9tb2R1bGVzL0Bhbmd1bGFyL2NvcmUvYnVuZGxlcy9jb3JlLnVtZC5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgLi92ZW5kb3Jcbi8vIG1vZHVsZSBpZCA9IDBcbi8vIG1vZHVsZSBjaHVua3MgPSA0IiwiLyohICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2VcclxudGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGVcclxuTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuXHJcblRISVMgQ09ERSBJUyBQUk9WSURFRCBPTiBBTiAqQVMgSVMqIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuS0lORCwgRUlUSEVSIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIFdJVEhPVVQgTElNSVRBVElPTiBBTlkgSU1QTElFRFxyXG5XQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgVElUTEUsIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLFxyXG5NRVJDSEFOVEFCTElUWSBPUiBOT04tSU5GUklOR0VNRU5ULlxyXG5cclxuU2VlIHRoZSBBcGFjaGUgVmVyc2lvbiAyLjAgTGljZW5zZSBmb3Igc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zXHJcbmFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuLyogZ2xvYmFsIGdsb2JhbCwgZGVmaW5lLCBTeXN0ZW0sIFJlZmxlY3QsIFByb21pc2UgKi9cclxudmFyIF9fZXh0ZW5kcztcclxudmFyIF9fYXNzaWduO1xyXG52YXIgX19yZXN0O1xyXG52YXIgX19kZWNvcmF0ZTtcclxudmFyIF9fcGFyYW07XHJcbnZhciBfX21ldGFkYXRhO1xyXG52YXIgX19hd2FpdGVyO1xyXG52YXIgX19nZW5lcmF0b3I7XHJcbnZhciBfX2V4cG9ydFN0YXI7XHJcbnZhciBfX3ZhbHVlcztcclxudmFyIF9fcmVhZDtcclxudmFyIF9fc3ByZWFkO1xyXG52YXIgX19hd2FpdDtcclxudmFyIF9fYXN5bmNHZW5lcmF0b3I7XHJcbnZhciBfX2FzeW5jRGVsZWdhdG9yO1xyXG52YXIgX19hc3luY1ZhbHVlcztcclxuKGZ1bmN0aW9uIChmYWN0b3J5KSB7XHJcbiAgICB2YXIgcm9vdCA9IHR5cGVvZiBnbG9iYWwgPT09IFwib2JqZWN0XCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiA9PT0gXCJvYmplY3RcIiA/IHNlbGYgOiB0eXBlb2YgdGhpcyA9PT0gXCJvYmplY3RcIiA/IHRoaXMgOiB7fTtcclxuICAgIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xyXG4gICAgICAgIGRlZmluZShcInRzbGliXCIsIFtcImV4cG9ydHNcIl0sIGZ1bmN0aW9uIChleHBvcnRzKSB7IGZhY3RvcnkoY3JlYXRlRXhwb3J0ZXIocm9vdCwgY3JlYXRlRXhwb3J0ZXIoZXhwb3J0cykpKTsgfSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xyXG4gICAgICAgIGZhY3RvcnkoY3JlYXRlRXhwb3J0ZXIocm9vdCwgY3JlYXRlRXhwb3J0ZXIobW9kdWxlLmV4cG9ydHMpKSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBmYWN0b3J5KGNyZWF0ZUV4cG9ydGVyKHJvb3QpKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGNyZWF0ZUV4cG9ydGVyKGV4cG9ydHMsIHByZXZpb3VzKSB7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChpZCwgdikgeyByZXR1cm4gZXhwb3J0c1tpZF0gPSBwcmV2aW91cyA/IHByZXZpb3VzKGlkLCB2KSA6IHY7IH07XHJcbiAgICB9XHJcbn0pXHJcbihmdW5jdGlvbiAoZXhwb3J0ZXIpIHtcclxuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xyXG5cclxuICAgIF9fZXh0ZW5kcyA9IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbiAgICB9O1xyXG5cclxuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodCkge1xyXG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpIHRbcF0gPSBzW3BdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdDtcclxuICAgIH07XHJcblxyXG4gICAgX19yZXN0ID0gZnVuY3Rpb24gKHMsIGUpIHtcclxuICAgICAgICB2YXIgdCA9IHt9O1xyXG4gICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSAmJiBlLmluZGV4T2YocCkgPCAwKVxyXG4gICAgICAgICAgICB0W3BdID0gc1twXTtcclxuICAgICAgICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpXHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBwID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTsgaSA8IHAubGVuZ3RoOyBpKyspIGlmIChlLmluZGV4T2YocFtpXSkgPCAwKVxyXG4gICAgICAgICAgICAgICAgdFtwW2ldXSA9IHNbcFtpXV07XHJcbiAgICAgICAgcmV0dXJuIHQ7XHJcbiAgICB9O1xyXG5cclxuICAgIF9fZGVjb3JhdGUgPSBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcclxuICAgICAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xyXG4gICAgICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XHJcbiAgICAgICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcclxuICAgICAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xyXG4gICAgfTtcclxuXHJcbiAgICBfX3BhcmFtID0gZnVuY3Rpb24gKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHsgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTsgfVxyXG4gICAgfTtcclxuXHJcbiAgICBfX21ldGFkYXRhID0gZnVuY3Rpb24gKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlKTtcclxuICAgIH07XHJcblxyXG4gICAgX19hd2FpdGVyID0gZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xyXG4gICAgICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUocmVzdWx0LnZhbHVlKTsgfSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxyXG4gICAgICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIF9fZ2VuZXJhdG9yID0gZnVuY3Rpb24gKHRoaXNBcmcsIGJvZHkpIHtcclxuICAgICAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xyXG4gICAgICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xyXG4gICAgICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxyXG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcclxuICAgICAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xyXG4gICAgICAgICAgICB3aGlsZSAoXykgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IHlbb3BbMF0gJiAyID8gXCJyZXR1cm5cIiA6IG9wWzBdID8gXCJ0aHJvd1wiIDogXCJuZXh0XCJdKSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcclxuICAgICAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbMCwgdC52YWx1ZV07XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcclxuICAgICAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxyXG4gICAgICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIF9fZXhwb3J0U3RhciA9IGZ1bmN0aW9uIChtLCBleHBvcnRzKSB7XHJcbiAgICAgICAgZm9yICh2YXIgcCBpbiBtKSBpZiAoIWV4cG9ydHMuaGFzT3duUHJvcGVydHkocCkpIGV4cG9ydHNbcF0gPSBtW3BdO1xyXG4gICAgfTtcclxuXHJcbiAgICBfX3ZhbHVlcyA9IGZ1bmN0aW9uIChvKSB7XHJcbiAgICAgICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdLCBpID0gMDtcclxuICAgICAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcblxyXG4gICAgX19yZWFkID0gZnVuY3Rpb24gKG8sIG4pIHtcclxuICAgICAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XHJcbiAgICAgICAgaWYgKCFtKSByZXR1cm4gbztcclxuICAgICAgICB2YXIgaSA9IG0uY2FsbChvKSwgciwgYXIgPSBbXSwgZTtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSkgYXIucHVzaChyLnZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7IGUgPSB7IGVycm9yOiBlcnJvciB9OyB9XHJcbiAgICAgICAgZmluYWxseSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpIG0uY2FsbChpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGUpIHRocm93IGUuZXJyb3I7IH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGFyO1xyXG4gICAgfTtcclxuXHJcbiAgICBfX3NwcmVhZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmb3IgKHZhciBhciA9IFtdLCBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgYXIgPSBhci5jb25jYXQoX19yZWFkKGFyZ3VtZW50c1tpXSkpO1xyXG4gICAgICAgIHJldHVybiBhcjtcclxuICAgIH07XHJcblxyXG4gICAgX19hd2FpdCA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMgaW5zdGFuY2VvZiBfX2F3YWl0ID8gKHRoaXMudiA9IHYsIHRoaXMpIDogbmV3IF9fYXdhaXQodik7XHJcbiAgICB9O1xyXG5cclxuICAgIF9fYXN5bmNHZW5lcmF0b3IgPSBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgZ2VuZXJhdG9yKSB7XHJcbiAgICAgICAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxuICAgICAgICB2YXIgZyA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSwgaSwgcSA9IFtdO1xyXG4gICAgICAgIHJldHVybiBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcclxuICAgICAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgaWYgKGdbbl0pIGlbbl0gPSBmdW5jdGlvbiAodikgeyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKGEsIGIpIHsgcS5wdXNoKFtuLCB2LCBhLCBiXSkgPiAxIHx8IHJlc3VtZShuLCB2KTsgfSk7IH07IH1cclxuICAgICAgICBmdW5jdGlvbiByZXN1bWUobiwgdikgeyB0cnkgeyBzdGVwKGdbbl0odikpOyB9IGNhdGNoIChlKSB7IHNldHRsZShxWzBdWzNdLCBlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gc3RlcChyKSB7IHIudmFsdWUgaW5zdGFuY2VvZiBfX2F3YWl0ID8gUHJvbWlzZS5yZXNvbHZlKHIudmFsdWUudikudGhlbihmdWxmaWxsLCByZWplY3QpIDogc2V0dGxlKHFbMF1bMl0sIHIpOyAgfVxyXG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGwodmFsdWUpIHsgcmVzdW1lKFwibmV4dFwiLCB2YWx1ZSk7IH1cclxuICAgICAgICBmdW5jdGlvbiByZWplY3QodmFsdWUpIHsgcmVzdW1lKFwidGhyb3dcIiwgdmFsdWUpOyB9XHJcbiAgICAgICAgZnVuY3Rpb24gc2V0dGxlKGYsIHYpIHsgaWYgKGYodiksIHEuc2hpZnQoKSwgcS5sZW5ndGgpIHJlc3VtZShxWzBdWzBdLCBxWzBdWzFdKTsgfVxyXG4gICAgfTtcclxuXHJcbiAgICBfX2FzeW5jRGVsZWdhdG9yID0gZnVuY3Rpb24gKG8pIHtcclxuICAgICAgICB2YXIgaSwgcDtcclxuICAgICAgICByZXR1cm4gaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIsIGZ1bmN0aW9uIChlKSB7IHRocm93IGU7IH0pLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpO1xyXG4gICAgICAgIGZ1bmN0aW9uIHZlcmIobiwgZikgeyBpZiAob1tuXSkgaVtuXSA9IGZ1bmN0aW9uICh2KSB7IHJldHVybiAocCA9ICFwKSA/IHsgdmFsdWU6IF9fYXdhaXQob1tuXSh2KSksIGRvbmU6IG4gPT09IFwicmV0dXJuXCIgfSA6IGYgPyBmKHYpIDogdjsgfTsgfVxyXG4gICAgfTtcclxuXHJcbiAgICBfX2FzeW5jVmFsdWVzID0gZnVuY3Rpb24gKG8pIHtcclxuICAgICAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG4gICAgICAgIHZhciBtID0gb1tTeW1ib2wuYXN5bmNJdGVyYXRvcl07XHJcbiAgICAgICAgcmV0dXJuIG0gPyBtLmNhbGwobykgOiB0eXBlb2YgX192YWx1ZXMgPT09IFwiZnVuY3Rpb25cIiA/IF9fdmFsdWVzKG8pIDogb1tTeW1ib2wuaXRlcmF0b3JdKCk7XHJcbiAgICB9O1xyXG5cclxuICAgIGV4cG9ydGVyKFwiX19leHRlbmRzXCIsIF9fZXh0ZW5kcyk7XHJcbiAgICBleHBvcnRlcihcIl9fYXNzaWduXCIsIF9fYXNzaWduKTtcclxuICAgIGV4cG9ydGVyKFwiX19yZXN0XCIsIF9fcmVzdCk7XHJcbiAgICBleHBvcnRlcihcIl9fZGVjb3JhdGVcIiwgX19kZWNvcmF0ZSk7XHJcbiAgICBleHBvcnRlcihcIl9fcGFyYW1cIiwgX19wYXJhbSk7XHJcbiAgICBleHBvcnRlcihcIl9fbWV0YWRhdGFcIiwgX19tZXRhZGF0YSk7XHJcbiAgICBleHBvcnRlcihcIl9fYXdhaXRlclwiLCBfX2F3YWl0ZXIpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX2dlbmVyYXRvclwiLCBfX2dlbmVyYXRvcik7XHJcbiAgICBleHBvcnRlcihcIl9fZXhwb3J0U3RhclwiLCBfX2V4cG9ydFN0YXIpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX3ZhbHVlc1wiLCBfX3ZhbHVlcyk7XHJcbiAgICBleHBvcnRlcihcIl9fcmVhZFwiLCBfX3JlYWQpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX3NwcmVhZFwiLCBfX3NwcmVhZCk7XHJcbiAgICBleHBvcnRlcihcIl9fYXdhaXRcIiwgX19hd2FpdCk7XHJcbiAgICBleHBvcnRlcihcIl9fYXN5bmNHZW5lcmF0b3JcIiwgX19hc3luY0dlbmVyYXRvcik7XHJcbiAgICBleHBvcnRlcihcIl9fYXN5bmNEZWxlZ2F0b3JcIiwgX19hc3luY0RlbGVnYXRvcik7XHJcbiAgICBleHBvcnRlcihcIl9fYXN5bmNWYWx1ZXNcIiwgX19hc3luY1ZhbHVlcyk7XHJcbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3RzbGliL3RzbGliLmpzXG4vLyBtb2R1bGUgaWQgPSAxXG4vLyBtb2R1bGUgY2h1bmtzID0gNCIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vdmVuZG9yXCIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwiLi92ZW5kb3JcIlxuLy8gbW9kdWxlIGlkID0gMlxuLy8gbW9kdWxlIGNodW5rcyA9IDQiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBET01FeGNlcHRpb24gPSByZXF1aXJlKCcuL0RPTUV4Y2VwdGlvbicpO1xudmFyIEVSUiA9IERPTUV4Y2VwdGlvbjtcbnZhciBpc0FwaVdyaXRhYmxlID0gcmVxdWlyZShcIi4vY29uZmlnXCIpLmlzQXBpV3JpdGFibGU7XG5cbmV4cG9ydHMuTkFNRVNQQUNFID0ge1xuICBIVE1MOiAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCcsXG4gIFhNTDogJ2h0dHA6Ly93d3cudzMub3JnL1hNTC8xOTk4L25hbWVzcGFjZScsXG4gIFhNTE5TOiAnaHR0cDovL3d3dy53My5vcmcvMjAwMC94bWxucy8nLFxuICBNQVRITUw6ICdodHRwOi8vd3d3LnczLm9yZy8xOTk4L01hdGgvTWF0aE1MJyxcbiAgU1ZHOiAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLFxuICBYTElOSzogJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnXG59O1xuXG4vL1xuLy8gU2hvcnRjdXQgZnVuY3Rpb25zIGZvciB0aHJvd2luZyBlcnJvcnMgb2YgdmFyaW91cyB0eXBlcy5cbi8vXG5leHBvcnRzLkluZGV4U2l6ZUVycm9yID0gZnVuY3Rpb24oKSB7IHRocm93IG5ldyBET01FeGNlcHRpb24oRVJSLklOREVYX1NJWkVfRVJSKTsgfTtcbmV4cG9ydHMuSGllcmFyY2h5UmVxdWVzdEVycm9yID0gZnVuY3Rpb24oKSB7IHRocm93IG5ldyBET01FeGNlcHRpb24oRVJSLkhJRVJBUkNIWV9SRVFVRVNUX0VSUik7IH07XG5leHBvcnRzLldyb25nRG9jdW1lbnRFcnJvciA9IGZ1bmN0aW9uKCkgeyB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKEVSUi5XUk9OR19ET0NVTUVOVF9FUlIpOyB9O1xuZXhwb3J0cy5JbnZhbGlkQ2hhcmFjdGVyRXJyb3IgPSBmdW5jdGlvbigpIHsgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbihFUlIuSU5WQUxJRF9DSEFSQUNURVJfRVJSKTsgfTtcbmV4cG9ydHMuTm9Nb2RpZmljYXRpb25BbGxvd2VkRXJyb3IgPSBmdW5jdGlvbigpIHsgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbihFUlIuTk9fTU9ESUZJQ0FUSU9OX0FMTE9XRURfRVJSKTsgfTtcbmV4cG9ydHMuTm90Rm91bmRFcnJvciA9IGZ1bmN0aW9uKCkgeyB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKEVSUi5OT1RfRk9VTkRfRVJSKTsgfTtcbmV4cG9ydHMuTm90U3VwcG9ydGVkRXJyb3IgPSBmdW5jdGlvbigpIHsgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbihFUlIuTk9UX1NVUFBPUlRFRF9FUlIpOyB9O1xuZXhwb3J0cy5JbnZhbGlkU3RhdGVFcnJvciA9IGZ1bmN0aW9uKCkgeyB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKEVSUi5JTlZBTElEX1NUQVRFX0VSUik7IH07XG5leHBvcnRzLlN5bnRheEVycm9yID0gZnVuY3Rpb24oKSB7IHRocm93IG5ldyBET01FeGNlcHRpb24oRVJSLlNZTlRBWF9FUlIpOyB9O1xuZXhwb3J0cy5JbnZhbGlkTW9kaWZpY2F0aW9uRXJyb3IgPSBmdW5jdGlvbigpIHsgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbihFUlIuSU5WQUxJRF9NT0RJRklDQVRJT05fRVJSKTsgfTtcbmV4cG9ydHMuTmFtZXNwYWNlRXJyb3IgPSBmdW5jdGlvbigpIHsgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbihFUlIuTkFNRVNQQUNFX0VSUik7IH07XG5leHBvcnRzLkludmFsaWRBY2Nlc3NFcnJvciA9IGZ1bmN0aW9uKCkgeyB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKEVSUi5JTlZBTElEX0FDQ0VTU19FUlIpOyB9O1xuZXhwb3J0cy5UeXBlTWlzbWF0Y2hFcnJvciA9IGZ1bmN0aW9uKCkgeyB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKEVSUi5UWVBFX01JU01BVENIX0VSUik7IH07XG5leHBvcnRzLlNlY3VyaXR5RXJyb3IgPSBmdW5jdGlvbigpIHsgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbihFUlIuU0VDVVJJVFlfRVJSKTsgfTtcbmV4cG9ydHMuTmV0d29ya0Vycm9yID0gZnVuY3Rpb24oKSB7IHRocm93IG5ldyBET01FeGNlcHRpb24oRVJSLk5FVFdPUktfRVJSKTsgfTtcbmV4cG9ydHMuQWJvcnRFcnJvciA9IGZ1bmN0aW9uKCkgeyB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKEVSUi5BQk9SVF9FUlIpOyB9O1xuZXhwb3J0cy5VcmxNaXNtYXRjaEVycm9yID0gZnVuY3Rpb24oKSB7IHRocm93IG5ldyBET01FeGNlcHRpb24oRVJSLlVSTF9NSVNNQVRDSF9FUlIpOyB9O1xuZXhwb3J0cy5RdW90YUV4Y2VlZGVkRXJyb3IgPSBmdW5jdGlvbigpIHsgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbihFUlIuUVVPVEFfRVhDRUVERURfRVJSKTsgfTtcbmV4cG9ydHMuVGltZW91dEVycm9yID0gZnVuY3Rpb24oKSB7IHRocm93IG5ldyBET01FeGNlcHRpb24oRVJSLlRJTUVPVVRfRVJSKTsgfTtcbmV4cG9ydHMuSW52YWxpZE5vZGVUeXBlRXJyb3IgPSBmdW5jdGlvbigpIHsgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbihFUlIuSU5WQUxJRF9OT0RFX1RZUEVfRVJSKTsgfTtcbmV4cG9ydHMuRGF0YUNsb25lRXJyb3IgPSBmdW5jdGlvbigpIHsgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbihFUlIuREFUQV9DTE9ORV9FUlIpOyB9O1xuXG5leHBvcnRzLm55aSA9IGZ1bmN0aW9uKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoXCJOb3RZZXRJbXBsZW1lbnRlZFwiKTtcbn07XG5cbmV4cG9ydHMuYXNzZXJ0ID0gZnVuY3Rpb24oZXhwciwgbXNnKSB7XG4gIGlmICghZXhwcikge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkFzc2VydGlvbiBmYWlsZWQ6IFwiICsgKG1zZyB8fCBcIlwiKSArIFwiXFxuXCIgKyBuZXcgRXJyb3IoKS5zdGFjayk7XG4gIH1cbn07XG5cbmV4cG9ydHMuZXhwb3NlID0gZnVuY3Rpb24oc3JjLCBjKSB7XG4gIGZvciAodmFyIG4gaW4gc3JjKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGMucHJvdG90eXBlLCBuLCB7IHZhbHVlOiBzcmNbbl0sIHdyaXRhYmxlOiBpc0FwaVdyaXRhYmxlIH0pO1xuICB9XG59O1xuXG5leHBvcnRzLm1lcmdlID0gZnVuY3Rpb24oYSwgYikge1xuICBmb3IgKHZhciBuIGluIGIpIHtcbiAgICBhW25dID0gYltuXTtcbiAgfVxufTtcblxuLy8gQ29tcGFyZSB0d28gbm9kZXMgYmFzZWQgb24gdGhlaXIgZG9jdW1lbnQgb3JkZXIuIFRoaXMgZnVuY3Rpb24gaXMgaW50ZW5kZWRcbi8vIHRvIGJlIHBhc3NlZCB0byBzb3J0KCkuIEFzc3VtZXMgdGhhdCB0aGUgYXJyYXkgYmVpbmcgc29ydGVkIGRvZXMgbm90XG4vLyBjb250YWluIGR1cGxpY2F0ZXMuICBBbmQgdGhhdCBhbGwgbm9kZXMgYXJlIGNvbm5lY3RlZCBhbmQgY29tcGFyYWJsZS5cbi8vIENsZXZlciBjb2RlIGJ5IHBwayB2aWEgamVyZXNpZy5cbmV4cG9ydHMuZG9jdW1lbnRPcmRlciA9IGZ1bmN0aW9uKG4sbSkge1xuICAvKiBqc2hpbnQgYml0d2lzZTogZmFsc2UgKi9cbiAgcmV0dXJuIDMgLSAobi5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihtKSAmIDYpO1xufTtcblxuZXhwb3J0cy50b0FTQ0lJTG93ZXJDYXNlID0gZnVuY3Rpb24ocykge1xuICByZXR1cm4gcy5yZXBsYWNlKC9bQS1aXSsvZywgZnVuY3Rpb24odCkgeyByZXR1cm4gdC50b0xvd2VyQ2FzZSgpOyB9KTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9kb21pbm8vbGliL3V0aWxzLmpzXG4vLyBtb2R1bGUgaWQgPSAzXG4vLyBtb2R1bGUgY2h1bmtzID0gNCIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBOb2RlO1xuXG52YXIgRXZlbnRUYXJnZXQgPSByZXF1aXJlKCcuL0V2ZW50VGFyZ2V0Jyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG52YXIgTkFNRVNQQUNFID0gdXRpbHMuTkFNRVNQQUNFO1xuXG4vLyBBbGwgbm9kZXMgaGF2ZSBhIG5vZGVUeXBlIGFuZCBhbiBvd25lckRvY3VtZW50LlxuLy8gT25jZSBpbnNlcnRlZCwgdGhleSBhbHNvIGhhdmUgYSBwYXJlbnROb2RlLlxuLy8gVGhpcyBpcyBhbiBhYnN0cmFjdCBjbGFzczsgYWxsIG5vZGVzIGluIGEgZG9jdW1lbnQgYXJlIGluc3RhbmNlc1xuLy8gb2YgYSBzdWJ0eXBlLCBzbyBhbGwgdGhlIHByb3BlcnRpZXMgYXJlIGRlZmluZWQgYnkgbW9yZSBzcGVjaWZpY1xuLy8gY29uc3RydWN0b3JzLlxuZnVuY3Rpb24gTm9kZSgpIHtcbn1cblxudmFyIEVMRU1FTlRfTk9ERSAgICAgICAgICAgICAgICA9IE5vZGUuRUxFTUVOVF9OT0RFID0gMTtcbnZhciBBVFRSSUJVVEVfTk9ERSAgICAgICAgICAgICAgPSBOb2RlLkFUVFJJQlVURV9OT0RFID0gMjtcbnZhciBURVhUX05PREUgICAgICAgICAgICAgICAgICAgPSBOb2RlLlRFWFRfTk9ERSA9IDM7XG52YXIgQ0RBVEFfU0VDVElPTl9OT0RFICAgICAgICAgID0gTm9kZS5DREFUQV9TRUNUSU9OX05PREUgPSA0O1xudmFyIEVOVElUWV9SRUZFUkVOQ0VfTk9ERSAgICAgICA9IE5vZGUuRU5USVRZX1JFRkVSRU5DRV9OT0RFID0gNTtcbnZhciBFTlRJVFlfTk9ERSAgICAgICAgICAgICAgICAgPSBOb2RlLkVOVElUWV9OT0RFID0gNjtcbnZhciBQUk9DRVNTSU5HX0lOU1RSVUNUSU9OX05PREUgPSBOb2RlLlBST0NFU1NJTkdfSU5TVFJVQ1RJT05fTk9ERSA9IDc7XG52YXIgQ09NTUVOVF9OT0RFICAgICAgICAgICAgICAgID0gTm9kZS5DT01NRU5UX05PREUgPSA4O1xudmFyIERPQ1VNRU5UX05PREUgICAgICAgICAgICAgICA9IE5vZGUuRE9DVU1FTlRfTk9ERSA9IDk7XG52YXIgRE9DVU1FTlRfVFlQRV9OT0RFICAgICAgICAgID0gTm9kZS5ET0NVTUVOVF9UWVBFX05PREUgPSAxMDtcbnZhciBET0NVTUVOVF9GUkFHTUVOVF9OT0RFICAgICAgPSBOb2RlLkRPQ1VNRU5UX0ZSQUdNRU5UX05PREUgPSAxMTtcbnZhciBOT1RBVElPTl9OT0RFICAgICAgICAgICAgICAgPSBOb2RlLk5PVEFUSU9OX05PREUgPSAxMjtcblxudmFyIERPQ1VNRU5UX1BPU0lUSU9OX0RJU0NPTk5FQ1RFRCAgICAgICAgICAgID0gTm9kZS5ET0NVTUVOVF9QT1NJVElPTl9ESVNDT05ORUNURUQgPSAweDAxO1xudmFyIERPQ1VNRU5UX1BPU0lUSU9OX1BSRUNFRElORyAgICAgICAgICAgICAgID0gTm9kZS5ET0NVTUVOVF9QT1NJVElPTl9QUkVDRURJTkcgPSAweDAyO1xudmFyIERPQ1VNRU5UX1BPU0lUSU9OX0ZPTExPV0lORyAgICAgICAgICAgICAgID0gTm9kZS5ET0NVTUVOVF9QT1NJVElPTl9GT0xMT1dJTkcgPSAweDA0O1xudmFyIERPQ1VNRU5UX1BPU0lUSU9OX0NPTlRBSU5TICAgICAgICAgICAgICAgID0gTm9kZS5ET0NVTUVOVF9QT1NJVElPTl9DT05UQUlOUyA9IDB4MDg7XG52YXIgRE9DVU1FTlRfUE9TSVRJT05fQ09OVEFJTkVEX0JZICAgICAgICAgICAgPSBOb2RlLkRPQ1VNRU5UX1BPU0lUSU9OX0NPTlRBSU5FRF9CWSA9IDB4MTA7XG52YXIgRE9DVU1FTlRfUE9TSVRJT05fSU1QTEVNRU5UQVRJT05fU1BFQ0lGSUMgPSBOb2RlLkRPQ1VNRU5UX1BPU0lUSU9OX0lNUExFTUVOVEFUSU9OX1NQRUNJRklDID0gMHgyMDtcblxudmFyIGhhc1Jhd0NvbnRlbnQgPSB7XG4gIFNUWUxFOiB0cnVlLFxuICBTQ1JJUFQ6IHRydWUsXG4gIFhNUDogdHJ1ZSxcbiAgSUZSQU1FOiB0cnVlLFxuICBOT0VNQkVEOiB0cnVlLFxuICBOT0ZSQU1FUzogdHJ1ZSxcbiAgUExBSU5URVhUOiB0cnVlXG59O1xuXG52YXIgZW1wdHlFbGVtZW50cyA9IHtcbiAgYXJlYTogdHJ1ZSxcbiAgYmFzZTogdHJ1ZSxcbiAgYmFzZWZvbnQ6IHRydWUsXG4gIGJnc291bmQ6IHRydWUsXG4gIGJyOiB0cnVlLFxuICBjb2w6IHRydWUsXG4gIGVtYmVkOiB0cnVlLFxuICBmcmFtZTogdHJ1ZSxcbiAgaHI6IHRydWUsXG4gIGltZzogdHJ1ZSxcbiAgaW5wdXQ6IHRydWUsXG4gIGtleWdlbjogdHJ1ZSxcbiAgbGluazogdHJ1ZSxcbiAgbWV0YTogdHJ1ZSxcbiAgcGFyYW06IHRydWUsXG4gIHNvdXJjZTogdHJ1ZSxcbiAgdHJhY2s6IHRydWUsXG4gIHdicjogdHJ1ZVxufTtcblxudmFyIGV4dHJhTmV3TGluZSA9IHtcbiAgLyogUmVtb3ZlZCBpbiBodHRwczovL2dpdGh1Yi5jb20vd2hhdHdnL2h0bWwvaXNzdWVzLzk0NFxuICBwcmU6IHRydWUsXG4gIHRleHRhcmVhOiB0cnVlLFxuICBsaXN0aW5nOiB0cnVlXG4gICovXG59O1xuXG5Ob2RlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXZlbnRUYXJnZXQucHJvdG90eXBlLCB7XG5cbiAgLy8gTm9kZSB0aGF0IGFyZSBub3QgaW5zZXJ0ZWQgaW50byB0aGUgdHJlZSBpbmhlcml0IGEgbnVsbCBwYXJlbnRcbiAgcGFyZW50Tm9kZTogeyB2YWx1ZTogbnVsbCwgd3JpdGFibGU6IHRydWUgfSxcblxuICAvLyBYWFg6IHRoZSBiYXNlVVJJIGF0dHJpYnV0ZSBpcyBkZWZpbmVkIGJ5IGRvbSBjb3JlLCBidXRcbiAgLy8gYSBjb3JyZWN0IGltcGxlbWVudGF0aW9uIG9mIGl0IHJlcXVpcmVzIEhUTUwgZmVhdHVyZXMsIHNvXG4gIC8vIHdlJ2xsIGNvbWUgYmFjayB0byB0aGlzIGxhdGVyLlxuICBiYXNlVVJJOiB7IGdldDogdXRpbHMubnlpIH0sXG5cbiAgcGFyZW50RWxlbWVudDogeyBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAodGhpcy5wYXJlbnROb2RlICYmIHRoaXMucGFyZW50Tm9kZS5ub2RlVHlwZT09PUVMRU1FTlRfTk9ERSkgPyB0aGlzLnBhcmVudE5vZGUgOiBudWxsO1xuICB9fSxcblxuICBoYXNDaGlsZE5vZGVzOiB7IHZhbHVlOiBmdW5jdGlvbigpIHsgIC8vIE92ZXJyaWRkZW4gaW4gbGVhZi5qc1xuICAgIHJldHVybiB0aGlzLmNoaWxkTm9kZXMubGVuZ3RoID4gMDtcbiAgfX0sXG5cbiAgZmlyc3RDaGlsZDogeyBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmNoaWxkTm9kZXMubGVuZ3RoID09PSAwID8gbnVsbCA6IHRoaXMuY2hpbGROb2Rlc1swXTtcbiAgfX0sXG5cbiAgbGFzdENoaWxkOiB7IGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hpbGROb2Rlcy5sZW5ndGggPT09IDAgPyBudWxsIDogdGhpcy5jaGlsZE5vZGVzW3RoaXMuY2hpbGROb2Rlcy5sZW5ndGgtMV07XG4gIH19LFxuXG4gIHByZXZpb3VzU2libGluZzogeyBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIGlmICghdGhpcy5wYXJlbnROb2RlKSByZXR1cm4gbnVsbDtcbiAgICB2YXIgc2licyA9IHRoaXMucGFyZW50Tm9kZS5jaGlsZE5vZGVzLCBpID0gdGhpcy5pbmRleDtcbiAgICByZXR1cm4gaSA9PT0gMCA/IG51bGwgOiBzaWJzW2ktMV07XG4gIH19LFxuXG4gIG5leHRTaWJsaW5nOiB7IGdldDogZnVuY3Rpb24oKSB7XG4gICAgaWYgKCF0aGlzLnBhcmVudE5vZGUpIHJldHVybiBudWxsO1xuICAgIHZhciBzaWJzID0gdGhpcy5wYXJlbnROb2RlLmNoaWxkTm9kZXMsIGkgPSB0aGlzLmluZGV4O1xuICAgIHJldHVybiBpKzEgPT09IHNpYnMubGVuZ3RoID8gbnVsbCA6IHNpYnNbaSsxXTtcbiAgfX0sXG5cblxuICBfY291bnRDaGlsZHJlbk9mVHlwZTogeyB2YWx1ZTogZnVuY3Rpb24odHlwZSkge1xuICAgIHZhciBzdW0gPSAwLCBub2RlcyA9IHRoaXMuY2hpbGROb2RlcywgbGVuZ3RoID0gbm9kZXMubGVuZ3RoLCBpO1xuICAgIGZvciAoaT0wOyBpPGxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAobm9kZXNbaV0ubm9kZVR5cGUgPT09IHR5cGUpIHN1bSsrO1xuICAgIH1cbiAgICByZXR1cm4gc3VtO1xuICB9fSxcblxuICBfZW5zdXJlSW5zZXJ0VmFsaWQ6IHsgdmFsdWU6IGZ1bmN0aW9uIF9lbnN1cmVJbnNlcnRWYWxpZChub2RlLCBjaGlsZCwgaXNQcmVpbnNlcnQpIHtcbiAgICB2YXIgcGFyZW50ID0gdGhpcywgaTtcbiAgICBpZiAoIW5vZGUubm9kZVR5cGUpIHRocm93IG5ldyBUeXBlRXJyb3IoJ25vdCBhIG5vZGUnKTtcbiAgICAvLyAxLiBJZiBwYXJlbnQgaXMgbm90IGEgRG9jdW1lbnQsIERvY3VtZW50RnJhZ21lbnQsIG9yIEVsZW1lbnRcbiAgICAvLyBub2RlLCB0aHJvdyBhIEhpZXJhcmNoeVJlcXVlc3RFcnJvci5cbiAgICBzd2l0Y2ggKHBhcmVudC5ub2RlVHlwZSkge1xuICAgIGNhc2UgRE9DVU1FTlRfTk9ERTpcbiAgICBjYXNlIERPQ1VNRU5UX0ZSQUdNRU5UX05PREU6XG4gICAgY2FzZSBFTEVNRU5UX05PREU6XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OiB1dGlscy5IaWVyYXJjaHlSZXF1ZXN0RXJyb3IoKTtcbiAgICB9XG4gICAgLy8gMi4gSWYgbm9kZSBpcyBhIGhvc3QtaW5jbHVkaW5nIGluY2x1c2l2ZSBhbmNlc3RvciBvZiBwYXJlbnQsXG4gICAgLy8gdGhyb3cgYSBIaWVyYXJjaHlSZXF1ZXN0RXJyb3IuXG4gICAgaWYgKG5vZGUuaXNBbmNlc3RvcihwYXJlbnQpKSB1dGlscy5IaWVyYXJjaHlSZXF1ZXN0RXJyb3IoKTtcbiAgICAvLyAzLiBJZiBjaGlsZCBpcyBub3QgbnVsbCBhbmQgaXRzIHBhcmVudCBpcyBub3QgcGFyZW50LCB0aGVuXG4gICAgLy8gdGhyb3cgYSBOb3RGb3VuZEVycm9yLiAocmVwbGFjZUNoaWxkIG9taXRzIHRoZSAnY2hpbGQgaXMgbm90IG51bGwnXG4gICAgLy8gYW5kIHRocm93cyBhIFR5cGVFcnJvciBoZXJlIGlmIGNoaWxkIGlzIG51bGwuKVxuICAgIGlmIChjaGlsZCAhPT0gbnVsbCB8fCAhaXNQcmVpbnNlcnQpIHtcbiAgICAgIGlmIChjaGlsZC5wYXJlbnROb2RlICE9PSBwYXJlbnQpIHV0aWxzLk5vdEZvdW5kRXJyb3IoKTtcbiAgICB9XG4gICAgLy8gNC4gSWYgbm9kZSBpcyBub3QgYSBEb2N1bWVudEZyYWdtZW50LCBEb2N1bWVudFR5cGUsIEVsZW1lbnQsXG4gICAgLy8gVGV4dCwgUHJvY2Vzc2luZ0luc3RydWN0aW9uLCBvciBDb21tZW50IG5vZGUsIHRocm93IGFcbiAgICAvLyBIaWVyYXJjaHlSZXF1ZXN0RXJyb3IuXG4gICAgc3dpdGNoIChub2RlLm5vZGVUeXBlKSB7XG4gICAgY2FzZSBET0NVTUVOVF9GUkFHTUVOVF9OT0RFOlxuICAgIGNhc2UgRE9DVU1FTlRfVFlQRV9OT0RFOlxuICAgIGNhc2UgRUxFTUVOVF9OT0RFOlxuICAgIGNhc2UgVEVYVF9OT0RFOlxuICAgIGNhc2UgUFJPQ0VTU0lOR19JTlNUUlVDVElPTl9OT0RFOlxuICAgIGNhc2UgQ09NTUVOVF9OT0RFOlxuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDogdXRpbHMuSGllcmFyY2h5UmVxdWVzdEVycm9yKCk7XG4gICAgfVxuICAgIC8vIDUuIElmIGVpdGhlciBub2RlIGlzIGEgVGV4dCBub2RlIGFuZCBwYXJlbnQgaXMgYSBkb2N1bWVudCwgb3JcbiAgICAvLyBub2RlIGlzIGEgZG9jdHlwZSBhbmQgcGFyZW50IGlzIG5vdCBhIGRvY3VtZW50LCB0aHJvdyBhXG4gICAgLy8gSGllcmFyY2h5UmVxdWVzdEVycm9yLlxuICAgIC8vIDYuIElmIHBhcmVudCBpcyBhIGRvY3VtZW50LCBhbmQgYW55IG9mIHRoZSBzdGF0ZW1lbnRzIGJlbG93LCBzd2l0Y2hlZFxuICAgIC8vIG9uIG5vZGUsIGFyZSB0cnVlLCB0aHJvdyBhIEhpZXJhcmNoeVJlcXVlc3RFcnJvci5cbiAgICBpZiAocGFyZW50Lm5vZGVUeXBlID09PSBET0NVTUVOVF9OT0RFKSB7XG4gICAgICBzd2l0Y2ggKG5vZGUubm9kZVR5cGUpIHtcbiAgICAgIGNhc2UgVEVYVF9OT0RFOlxuICAgICAgICB1dGlscy5IaWVyYXJjaHlSZXF1ZXN0RXJyb3IoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIERPQ1VNRU5UX0ZSQUdNRU5UX05PREU6XG4gICAgICAgIC8vIDZhMS4gSWYgbm9kZSBoYXMgbW9yZSB0aGFuIG9uZSBlbGVtZW50IGNoaWxkIG9yIGhhcyBhIFRleHRcbiAgICAgICAgLy8gbm9kZSBjaGlsZC5cbiAgICAgICAgaWYgKG5vZGUuX2NvdW50Q2hpbGRyZW5PZlR5cGUoVEVYVF9OT0RFKSA+IDApXG4gICAgICAgICAgdXRpbHMuSGllcmFyY2h5UmVxdWVzdEVycm9yKCk7XG4gICAgICAgIHN3aXRjaCAobm9kZS5fY291bnRDaGlsZHJlbk9mVHlwZShFTEVNRU5UX05PREUpKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIC8vIDZhMi4gT3RoZXJ3aXNlLCBpZiBub2RlIGhhcyBvbmUgZWxlbWVudCBjaGlsZCBhbmQgZWl0aGVyXG4gICAgICAgICAgLy8gcGFyZW50IGhhcyBhbiBlbGVtZW50IGNoaWxkLCBjaGlsZCBpcyBhIGRvY3R5cGUsIG9yIGNoaWxkXG4gICAgICAgICAgLy8gaXMgbm90IG51bGwgYW5kIGEgZG9jdHlwZSBpcyBmb2xsb3dpbmcgY2hpbGQuIFtwcmVpbnNlcnRdXG4gICAgICAgICAgLy8gNmEyLiBPdGhlcndpc2UsIGlmIG5vZGUgaGFzIG9uZSBlbGVtZW50IGNoaWxkIGFuZCBlaXRoZXJcbiAgICAgICAgICAvLyBwYXJlbnQgaGFzIGFuIGVsZW1lbnQgY2hpbGQgdGhhdCBpcyBub3QgY2hpbGQgb3IgYVxuICAgICAgICAgIC8vIGRvY3R5cGUgaXMgZm9sbG93aW5nIGNoaWxkLiBbcmVwbGFjZVdpdGhdXG4gICAgICAgICAgaWYgKGNoaWxkICE9PSBudWxsIC8qIGFsd2F5cyB0cnVlIGhlcmUgZm9yIHJlcGxhY2VXaXRoICovKSB7XG4gICAgICAgICAgICBpZiAoaXNQcmVpbnNlcnQgJiYgY2hpbGQubm9kZVR5cGUgPT09IERPQ1VNRU5UX1RZUEVfTk9ERSlcbiAgICAgICAgICAgICAgdXRpbHMuSGllcmFyY2h5UmVxdWVzdEVycm9yKCk7XG4gICAgICAgICAgICBmb3IgKGk9cGFyZW50LmNoaWxkTm9kZXMubGVuZ3RoLTE7IGk+PTA7IGktLSkge1xuICAgICAgICAgICAgICBpZiAocGFyZW50LmNoaWxkTm9kZXNbaV0gPT09IGNoaWxkKSBicmVhaztcbiAgICAgICAgICAgICAgaWYgKHBhcmVudC5jaGlsZE5vZGVzW2ldLm5vZGVUeXBlID09PSBET0NVTUVOVF9UWVBFX05PREUpXG4gICAgICAgICAgICAgICAgdXRpbHMuSGllcmFyY2h5UmVxdWVzdEVycm9yKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGkgPSBwYXJlbnQuX2NvdW50Q2hpbGRyZW5PZlR5cGUoRUxFTUVOVF9OT0RFKTtcbiAgICAgICAgICBpZiAoaXNQcmVpbnNlcnQpIHtcbiAgICAgICAgICAgIC8vIFwicGFyZW50IGhhcyBhbiBlbGVtZW50IGNoaWxkXCJcbiAgICAgICAgICAgIGlmIChpID4gMClcbiAgICAgICAgICAgICAgdXRpbHMuSGllcmFyY2h5UmVxdWVzdEVycm9yKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFwicGFyZW50IGhhcyBhbiBlbGVtZW50IGNoaWxkIHRoYXQgaXMgbm90IGNoaWxkXCJcbiAgICAgICAgICAgIGlmIChpID4gMSB8fCAoaSA9PT0gMSAmJiBjaGlsZC5ub2RlVHlwZSAhPT0gRUxFTUVOVF9OT0RFKSlcbiAgICAgICAgICAgICAgdXRpbHMuSGllcmFyY2h5UmVxdWVzdEVycm9yKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OiAvLyA2YTEsIGNvbnRpbnVlZC4gKG1vcmUgdGhhbiBvbmUgRWxlbWVudCBjaGlsZClcbiAgICAgICAgICB1dGlscy5IaWVyYXJjaHlSZXF1ZXN0RXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRUxFTUVOVF9OT0RFOlxuICAgICAgICAvLyA2Yi4gcGFyZW50IGhhcyBhbiBlbGVtZW50IGNoaWxkLCBjaGlsZCBpcyBhIGRvY3R5cGUsIG9yXG4gICAgICAgIC8vIGNoaWxkIGlzIG5vdCBudWxsIGFuZCBhIGRvY3R5cGUgaXMgZm9sbG93aW5nIGNoaWxkLiBbcHJlaW5zZXJ0XVxuICAgICAgICAvLyA2Yi4gcGFyZW50IGhhcyBhbiBlbGVtZW50IGNoaWxkIHRoYXQgaXMgbm90IGNoaWxkIG9yIGFcbiAgICAgICAgLy8gZG9jdHlwZSBpcyBmb2xsb3dpbmcgY2hpbGQuIFtyZXBsYWNlV2l0aF1cbiAgICAgICAgaWYgKGNoaWxkICE9PSBudWxsIC8qIGFsd2F5cyB0cnVlIGhlcmUgZm9yIHJlcGxhY2VXaXRoICovKSB7XG4gICAgICAgICAgaWYgKGlzUHJlaW5zZXJ0ICYmIGNoaWxkLm5vZGVUeXBlID09PSBET0NVTUVOVF9UWVBFX05PREUpXG4gICAgICAgICAgICB1dGlscy5IaWVyYXJjaHlSZXF1ZXN0RXJyb3IoKTtcbiAgICAgICAgICBmb3IgKGk9cGFyZW50LmNoaWxkTm9kZXMubGVuZ3RoLTE7IGk+PTA7IGktLSkge1xuICAgICAgICAgICAgaWYgKHBhcmVudC5jaGlsZE5vZGVzW2ldID09PSBjaGlsZCkgYnJlYWs7XG4gICAgICAgICAgICBpZiAocGFyZW50LmNoaWxkTm9kZXNbaV0ubm9kZVR5cGUgPT09IERPQ1VNRU5UX1RZUEVfTk9ERSlcbiAgICAgICAgICAgICAgdXRpbHMuSGllcmFyY2h5UmVxdWVzdEVycm9yKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGkgPSBwYXJlbnQuX2NvdW50Q2hpbGRyZW5PZlR5cGUoRUxFTUVOVF9OT0RFKTtcbiAgICAgICAgaWYgKGlzUHJlaW5zZXJ0KSB7XG4gICAgICAgICAgLy8gXCJwYXJlbnQgaGFzIGFuIGVsZW1lbnQgY2hpbGRcIlxuICAgICAgICAgIGlmIChpID4gMClcbiAgICAgICAgICAgIHV0aWxzLkhpZXJhcmNoeVJlcXVlc3RFcnJvcigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFwicGFyZW50IGhhcyBhbiBlbGVtZW50IGNoaWxkIHRoYXQgaXMgbm90IGNoaWxkXCJcbiAgICAgICAgICBpZiAoaSA+IDEgfHwgKGkgPT09IDEgJiYgY2hpbGQubm9kZVR5cGUgIT09IEVMRU1FTlRfTk9ERSkpXG4gICAgICAgICAgICB1dGlscy5IaWVyYXJjaHlSZXF1ZXN0RXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRE9DVU1FTlRfVFlQRV9OT0RFOlxuICAgICAgICAvLyA2Yy4gcGFyZW50IGhhcyBhIGRvY3R5cGUgY2hpbGQsIGNoaWxkIGlzIG5vbi1udWxsIGFuZCBhblxuICAgICAgICAvLyBlbGVtZW50IGlzIHByZWNlZGluZyBjaGlsZCwgb3IgY2hpbGQgaXMgbnVsbCBhbmQgcGFyZW50IGhhc1xuICAgICAgICAvLyBhbiBlbGVtZW50IGNoaWxkLiBbcHJlaW5zZXJ0XVxuICAgICAgICAvLyA2Yy4gcGFyZW50IGhhcyBhIGRvY3R5cGUgY2hpbGQgdGhhdCBpcyBub3QgY2hpbGQsIG9yIGFuXG4gICAgICAgIC8vIGVsZW1lbnQgaXMgcHJlY2VkaW5nIGNoaWxkLiBbcmVwbGFjZVdpdGhdXG4gICAgICAgIGlmIChjaGlsZCA9PT0gbnVsbCkge1xuICAgICAgICAgIGlmIChwYXJlbnQuX2NvdW50Q2hpbGRyZW5PZlR5cGUoRUxFTUVOVF9OT0RFKSlcbiAgICAgICAgICAgIHV0aWxzLkhpZXJhcmNoeVJlcXVlc3RFcnJvcigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGNoaWxkIGlzIGFsd2F5cyBub24tbnVsbCBmb3IgW3JlcGxhY2VXaXRoXSBjYXNlXG4gICAgICAgICAgZm9yIChpPTA7IGk8cGFyZW50LmNoaWxkTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChwYXJlbnQuY2hpbGROb2Rlc1tpXSA9PT0gY2hpbGQpIGJyZWFrO1xuICAgICAgICAgICAgaWYgKHBhcmVudC5jaGlsZE5vZGVzW2ldLm5vZGVUeXBlID09PSBFTEVNRU5UX05PREUpXG4gICAgICAgICAgICAgIHV0aWxzLkhpZXJhcmNoeVJlcXVlc3RFcnJvcigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpID0gcGFyZW50Ll9jb3VudENoaWxkcmVuT2ZUeXBlKERPQ1VNRU5UX1RZUEVfTk9ERSk7XG4gICAgICAgIGlmIChpc1ByZWluc2VydCkge1xuICAgICAgICAgIC8vIFwicGFyZW50IGhhcyBhbiBkb2N0eXBlIGNoaWxkXCJcbiAgICAgICAgICBpZiAoaSA+IDApXG4gICAgICAgICAgICB1dGlscy5IaWVyYXJjaHlSZXF1ZXN0RXJyb3IoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBcInBhcmVudCBoYXMgYW4gZG9jdHlwZSBjaGlsZCB0aGF0IGlzIG5vdCBjaGlsZFwiXG4gICAgICAgICAgaWYgKGkgPiAxIHx8IChpID09PSAxICYmIGNoaWxkLm5vZGVUeXBlICE9PSBET0NVTUVOVF9UWVBFX05PREUpKVxuICAgICAgICAgICAgdXRpbHMuSGllcmFyY2h5UmVxdWVzdEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIDUsIGNvbnRpbnVlZDogKHBhcmVudCBpcyBub3QgYSBkb2N1bWVudClcbiAgICAgIGlmIChub2RlLm5vZGVUeXBlID09PSBET0NVTUVOVF9UWVBFX05PREUpIHV0aWxzLkhpZXJhcmNoeVJlcXVlc3RFcnJvcigpO1xuICAgIH1cbiAgfX0sXG5cbiAgaW5zZXJ0QmVmb3JlOiB7IHZhbHVlOiBmdW5jdGlvbiBpbnNlcnRCZWZvcmUobm9kZSwgY2hpbGQpIHtcbiAgICB2YXIgcGFyZW50ID0gdGhpcztcbiAgICAvLyAxLiBFbnN1cmUgcHJlLWluc2VydGlvbiB2YWxpZGl0eVxuICAgIHBhcmVudC5fZW5zdXJlSW5zZXJ0VmFsaWQobm9kZSwgY2hpbGQsIHRydWUpO1xuICAgIC8vIDIuIExldCByZWZlcmVuY2UgY2hpbGQgYmUgY2hpbGQuXG4gICAgdmFyIHJlZkNoaWxkID0gY2hpbGQ7XG4gICAgLy8gMy4gSWYgcmVmZXJlbmNlIGNoaWxkIGlzIG5vZGUsIHNldCBpdCB0byBub2RlJ3MgbmV4dCBzaWJsaW5nXG4gICAgaWYgKHJlZkNoaWxkID09PSBub2RlKSB7IHJlZkNoaWxkID0gbm9kZS5uZXh0U2libGluZzsgfVxuICAgIC8vIDQuIEFkb3B0IG5vZGUgaW50byBwYXJlbnQncyBub2RlIGRvY3VtZW50LlxuICAgIHBhcmVudC5kb2MuYWRvcHROb2RlKG5vZGUpO1xuICAgIC8vIDUuIEluc2VydCBub2RlIGludG8gcGFyZW50IGJlZm9yZSByZWZlcmVuY2UgY2hpbGQuXG4gICAgaWYgKHJlZkNoaWxkID09PSBudWxsKSB7XG4gICAgICBwYXJlbnQuX2FwcGVuZENoaWxkKG5vZGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBub2RlLmluc2VydChwYXJlbnQsIHJlZkNoaWxkLmluZGV4KTtcbiAgICB9XG4gICAgLy8gNi4gUmV0dXJuIG5vZGVcbiAgICByZXR1cm4gbm9kZTtcbiAgfX0sXG5cblxuICBhcHBlbmRDaGlsZDogeyB2YWx1ZTogZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAvLyBUaGlzIGludm9rZXMgX2FwcGVuZENoaWxkIGFmdGVyIGRvaW5nIHZhbGlkaXR5IGNoZWNrcy5cbiAgICByZXR1cm4gdGhpcy5pbnNlcnRCZWZvcmUoY2hpbGQsIG51bGwpO1xuICB9fSxcblxuICBfYXBwZW5kQ2hpbGQ6IHsgdmFsdWU6IGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgY2hpbGQuaW5zZXJ0KHRoaXMsIHRoaXMuY2hpbGROb2Rlcy5sZW5ndGgpO1xuICAgIHJldHVybiBjaGlsZDtcbiAgfX0sXG5cbiAgcmVtb3ZlQ2hpbGQ6IHsgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZUNoaWxkKGNoaWxkKSB7XG4gICAgdmFyIHBhcmVudCA9IHRoaXM7XG4gICAgaWYgKCFjaGlsZC5ub2RlVHlwZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignbm90IGEgbm9kZScpO1xuICAgIGlmIChjaGlsZC5wYXJlbnROb2RlICE9PSBwYXJlbnQpIHV0aWxzLk5vdEZvdW5kRXJyb3IoKTtcbiAgICBjaGlsZC5yZW1vdmUoKTtcbiAgICByZXR1cm4gY2hpbGQ7XG4gIH19LFxuXG4gIC8vIFRvIHJlcGxhY2UgYSBgY2hpbGRgIHdpdGggYG5vZGVgIHdpdGhpbiBhIGBwYXJlbnRgICh0aGlzKVxuICByZXBsYWNlQ2hpbGQ6IHsgdmFsdWU6IGZ1bmN0aW9uIHJlcGxhY2VDaGlsZChub2RlLCBjaGlsZCkge1xuICAgIHZhciBwYXJlbnQgPSB0aGlzO1xuICAgIC8vIEVuc3VyZSB2YWxpZGl0eSAoc2xpZ2h0IGRpZmZlcmVuY2VzIGZyb20gcHJlLWluc2VydGlvbiBjaGVjaylcbiAgICBwYXJlbnQuX2Vuc3VyZUluc2VydFZhbGlkKG5vZGUsIGNoaWxkLCBmYWxzZSk7XG4gICAgLy8gQWRvcHQgbm9kZSBpbnRvIHBhcmVudCdzIG5vZGUgZG9jdW1lbnQuXG4gICAgaWYgKG5vZGUuZG9jICE9PSBwYXJlbnQuZG9jKSB7XG4gICAgICAvLyBYWFggYWRvcHROb2RlIGhhcyBzaWRlLWVmZmVjdCBvZiByZW1vdmluZyBub2RlIGZyb20gaXRzIHBhcmVudFxuICAgICAgLy8gYW5kIGdlbmVyYXRpbmcgYSBtdXRhdGlvbiBldmVudCwgdGh1cyBjYXVzaW5nIHRoZSBfaW5zZXJ0T3JSZXBsYWNlXG4gICAgICAvLyB0byBnZW5lcmF0ZSB0d28gZGVsZXRlcyBhbmQgYW4gaW5zZXJ0IGluc3RlYWQgb2YgYSAnbW92ZSdcbiAgICAgIC8vIGV2ZW50LiAgSXQgbG9va3MgbGlrZSB0aGUgbmV3IE11dGF0aW9uT2JzZXJ2ZXIgc3R1ZmYgYXZvaWRzXG4gICAgICAvLyB0aGlzIHByb2JsZW0sIGJ1dCBmb3Igbm93IGxldCdzIG9ubHkgYWRvcHQgKGllLCByZW1vdmUgYG5vZGVgXG4gICAgICAvLyBmcm9tIGl0cyBwYXJlbnQpIGhlcmUgaWYgd2UgbmVlZCB0by5cbiAgICAgIHBhcmVudC5kb2MuYWRvcHROb2RlKG5vZGUpO1xuICAgIH1cbiAgICAvLyBEbyB0aGUgcmVwbGFjZS5cbiAgICBub2RlLl9pbnNlcnRPclJlcGxhY2UocGFyZW50LCBjaGlsZC5pbmRleCwgdHJ1ZSk7XG4gICAgcmV0dXJuIGNoaWxkO1xuICB9fSxcblxuICAvLyBTZWU6IGh0dHA6Ly9lam9obi5vcmcvYmxvZy9jb21wYXJpbmctZG9jdW1lbnQtcG9zaXRpb24vXG4gIGNvbnRhaW5zOiB7IHZhbHVlOiBmdW5jdGlvbiBjb250YWlucyhub2RlKSB7XG4gICAgaWYgKG5vZGUgPT09IG51bGwpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgaWYgKHRoaXMgPT09IG5vZGUpIHsgcmV0dXJuIHRydWU7IC8qIGluY2x1c2l2ZSBkZXNjZW5kYW50ICovIH1cbiAgICAvKiBqc2hpbnQgYml0d2lzZTogZmFsc2UgKi9cbiAgICByZXR1cm4gKHRoaXMuY29tcGFyZURvY3VtZW50UG9zaXRpb24obm9kZSkgJlxuICAgICAgICAgICAgRE9DVU1FTlRfUE9TSVRJT05fQ09OVEFJTkVEX0JZKSAhPT0gMDtcbiAgfX0sXG5cbiAgY29tcGFyZURvY3VtZW50UG9zaXRpb246IHsgdmFsdWU6IGZ1bmN0aW9uIGNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKHRoYXQpe1xuICAgIC8vIEJhc2ljIGFsZ29yaXRobSBmb3IgZmluZGluZyB0aGUgcmVsYXRpdmUgcG9zaXRpb24gb2YgdHdvIG5vZGVzLlxuICAgIC8vIE1ha2UgYSBsaXN0IHRoZSBhbmNlc3RvcnMgb2YgZWFjaCBub2RlLCBzdGFydGluZyB3aXRoIHRoZVxuICAgIC8vIGRvY3VtZW50IGVsZW1lbnQgYW5kIHByb2NlZWRpbmcgZG93biB0byB0aGUgbm9kZXMgdGhlbXNlbHZlcy5cbiAgICAvLyBUaGVuLCBsb29wIHRocm91Z2ggdGhlIGxpc3RzLCBsb29raW5nIGZvciB0aGUgZmlyc3QgZWxlbWVudFxuICAgIC8vIHRoYXQgZGlmZmVycy4gIFRoZSBvcmRlciBvZiB0aG9zZSB0d28gZWxlbWVudHMgZ2l2ZSB0aGVcbiAgICAvLyBvcmRlciBvZiB0aGVpciBkZXNjZW5kYW50IG5vZGVzLiAgT3IsIGlmIG9uZSBsaXN0IGlzIGEgcHJlZml4XG4gICAgLy8gb2YgdGhlIG90aGVyIG9uZSwgdGhlbiB0aGF0IG5vZGUgY29udGFpbnMgdGhlIG90aGVyLlxuXG4gICAgaWYgKHRoaXMgPT09IHRoYXQpIHJldHVybiAwO1xuXG4gICAgLy8gSWYgdGhleSdyZSBub3Qgb3duZWQgYnkgdGhlIHNhbWUgZG9jdW1lbnQgb3IgaWYgb25lIGlzIHJvb3RlZFxuICAgIC8vIGFuZCBvbmUgaXMgbm90LCB0aGVuIHRoZXkncmUgZGlzY29ubmVjdGVkLlxuICAgIGlmICh0aGlzLmRvYyAhPT0gdGhhdC5kb2MgfHxcbiAgICAgIHRoaXMucm9vdGVkICE9PSB0aGF0LnJvb3RlZClcbiAgICAgIHJldHVybiAoRE9DVU1FTlRfUE9TSVRJT05fRElTQ09OTkVDVEVEICtcbiAgICAgICAgICBET0NVTUVOVF9QT1NJVElPTl9JTVBMRU1FTlRBVElPTl9TUEVDSUZJQyk7XG5cbiAgICAvLyBHZXQgYXJyYXlzIG9mIGFuY2VzdG9ycyBmb3IgdGhpcyBhbmQgdGhhdFxuICAgIHZhciB0aGVzZSA9IFtdLCB0aG9zZSA9IFtdO1xuICAgIGZvcih2YXIgbiA9IHRoaXM7IG4gIT09IG51bGw7IG4gPSBuLnBhcmVudE5vZGUpIHRoZXNlLnB1c2gobik7XG4gICAgZm9yKG4gPSB0aGF0OyBuICE9PSBudWxsOyBuID0gbi5wYXJlbnROb2RlKSB0aG9zZS5wdXNoKG4pO1xuICAgIHRoZXNlLnJldmVyc2UoKTsgIC8vIFNvIHdlIHN0YXJ0IHdpdGggdGhlIG91dGVybW9zdFxuICAgIHRob3NlLnJldmVyc2UoKTtcblxuICAgIGlmICh0aGVzZVswXSAhPT0gdGhvc2VbMF0pIC8vIE5vIGNvbW1vbiBhbmNlc3RvclxuICAgICAgcmV0dXJuIChET0NVTUVOVF9QT1NJVElPTl9ESVNDT05ORUNURUQgK1xuICAgICAgICAgIERPQ1VNRU5UX1BPU0lUSU9OX0lNUExFTUVOVEFUSU9OX1NQRUNJRklDKTtcblxuICAgIG4gPSBNYXRoLm1pbih0aGVzZS5sZW5ndGgsIHRob3NlLmxlbmd0aCk7XG4gICAgZm9yKHZhciBpID0gMTsgaSA8IG47IGkrKykge1xuICAgICAgaWYgKHRoZXNlW2ldICE9PSB0aG9zZVtpXSkge1xuICAgICAgICAvLyBXZSBmb3VuZCB0d28gZGlmZmVyZW50IGFuY2VzdG9ycywgc28gY29tcGFyZVxuICAgICAgICAvLyB0aGVpciBwb3NpdGlvbnNcbiAgICAgICAgaWYgKHRoZXNlW2ldLmluZGV4IDwgdGhvc2VbaV0uaW5kZXgpXG4gICAgICAgICAgcmV0dXJuIERPQ1VNRU5UX1BPU0lUSU9OX0ZPTExPV0lORztcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHJldHVybiBET0NVTUVOVF9QT1NJVElPTl9QUkVDRURJTkc7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSWYgd2UgZ2V0IHRvIGhlcmUsIHRoZW4gb25lIG9mIHRoZSBub2RlcyAodGhlIG9uZSB3aXRoIHRoZVxuICAgIC8vIHNob3J0ZXIgbGlzdCBvZiBhbmNlc3RvcnMpIGNvbnRhaW5zIHRoZSBvdGhlciBvbmUuXG4gICAgaWYgKHRoZXNlLmxlbmd0aCA8IHRob3NlLmxlbmd0aClcbiAgICAgIHJldHVybiAoRE9DVU1FTlRfUE9TSVRJT05fRk9MTE9XSU5HICtcbiAgICAgICAgICBET0NVTUVOVF9QT1NJVElPTl9DT05UQUlORURfQlkpO1xuICAgIGVsc2VcbiAgICAgIHJldHVybiAoRE9DVU1FTlRfUE9TSVRJT05fUFJFQ0VESU5HICtcbiAgICAgICAgICBET0NVTUVOVF9QT1NJVElPTl9DT05UQUlOUyk7XG4gIH19LFxuXG4gIGlzU2FtZU5vZGU6IHt2YWx1ZSA6IGZ1bmN0aW9uIGlzU2FtZU5vZGUobm9kZSkge1xuICAgIHJldHVybiB0aGlzID09PSBub2RlO1xuICB9fSxcblxuXG4gIC8vIFRoaXMgbWV0aG9kIGltcGxlbWVudHMgdGhlIGdlbmVyaWMgcGFydHMgb2Ygbm9kZSBlcXVhbGl0eSB0ZXN0aW5nXG4gIC8vIGFuZCBkZWZlcnMgdG8gdGhlIChub24tcmVjdXJzaXZlKSB0eXBlLXNwZWNpZmljIGlzRXF1YWwoKSBtZXRob2RcbiAgLy8gZGVmaW5lZCBieSBzdWJjbGFzc2VzXG4gIGlzRXF1YWxOb2RlOiB7IHZhbHVlOiBmdW5jdGlvbiBpc0VxdWFsTm9kZShub2RlKSB7XG4gICAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKG5vZGUubm9kZVR5cGUgIT09IHRoaXMubm9kZVR5cGUpIHJldHVybiBmYWxzZTtcblxuICAgIC8vIENoZWNrIGZvciBzYW1lIG51bWJlciBvZiBjaGlsZHJlblxuICAgIC8vIENoZWNrIGZvciBjaGlsZHJlbiB0aGlzIHdheSBiZWNhdXNlIGl0IGlzIG1vcmUgZWZmaWNpZW50XG4gICAgLy8gZm9yIGNoaWxkbGVzcyBsZWFmIG5vZGVzLlxuICAgIHZhciBuOyAvLyBudW1iZXIgb2YgY2hpbGQgbm9kZXNcbiAgICBpZiAoIXRoaXMuZmlyc3RDaGlsZCkge1xuICAgICAgbiA9IDA7XG4gICAgICBpZiAobm9kZS5maXJzdENoaWxkKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgbiA9IHRoaXMuY2hpbGROb2Rlcy5sZW5ndGg7XG4gICAgICBpZiAobm9kZS5jaGlsZE5vZGVzLmxlbmd0aCAhPT0gbikgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIENoZWNrIHR5cGUtc3BlY2lmaWMgcHJvcGVydGllcyBmb3IgZXF1YWxpdHlcbiAgICBpZiAoIXRoaXMuaXNFcXVhbChub2RlKSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgLy8gTm93IGNoZWNrIGNoaWxkcmVuIGZvciBlcXVhbGl0eVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgIHZhciBjMSA9IHRoaXMuY2hpbGROb2Rlc1tpXSwgYzIgPSBub2RlLmNoaWxkTm9kZXNbaV07XG4gICAgICBpZiAoIWMxLmlzRXF1YWxOb2RlKGMyKSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9fSxcblxuICAvLyBUaGlzIG1ldGhvZCBkZWxlZ2F0ZXMgc2hhbGxvdyBjbG9uaW5nIHRvIGEgY2xvbmUoKSBtZXRob2RcbiAgLy8gdGhhdCBlYWNoIGNvbmNyZXRlIHN1YmNsYXNzIG11c3QgaW1wbGVtZW50XG4gIGNsb25lTm9kZTogeyB2YWx1ZTogZnVuY3Rpb24oZGVlcCkge1xuICAgIC8vIENsb25lIHRoaXMgbm9kZVxuICAgIHZhciBjbG9uZSA9IHRoaXMuY2xvbmUoKTtcblxuICAgIC8vIEhhbmRsZSB0aGUgcmVjdXJzaXZlIGNhc2UgaWYgbmVjZXNzYXJ5XG4gICAgaWYgKGRlZXAgJiYgdGhpcy5maXJzdENoaWxkKSB7XG4gICAgICBmb3IodmFyIGkgPSAwLCBuID0gdGhpcy5jaGlsZE5vZGVzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICBjbG9uZS5fYXBwZW5kQ2hpbGQodGhpcy5jaGlsZE5vZGVzW2ldLmNsb25lTm9kZSh0cnVlKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNsb25lO1xuICB9fSxcblxuICBsb29rdXBQcmVmaXg6IHsgdmFsdWU6IGZ1bmN0aW9uIGxvb2t1cFByZWZpeChucykge1xuICAgIHZhciBlO1xuICAgIGlmIChucyA9PT0gJycpIHJldHVybiBudWxsO1xuICAgIHN3aXRjaCh0aGlzLm5vZGVUeXBlKSB7XG4gICAgY2FzZSBFTEVNRU5UX05PREU6XG4gICAgICByZXR1cm4gdGhpcy5sb2NhdGVOYW1lc3BhY2VQcmVmaXgobnMpO1xuICAgIGNhc2UgRE9DVU1FTlRfTk9ERTpcbiAgICAgIGUgPSB0aGlzLmRvY3VtZW50RWxlbWVudDtcbiAgICAgIHJldHVybiBlID8gZS5sb2NhdGVOYW1lc3BhY2VQcmVmaXgobnMpIDogbnVsbDtcbiAgICBjYXNlIERPQ1VNRU5UX1RZUEVfTk9ERTpcbiAgICBjYXNlIERPQ1VNRU5UX0ZSQUdNRU5UX05PREU6XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBkZWZhdWx0OlxuICAgICAgZSA9IHRoaXMucGFyZW50RWxlbWVudDtcbiAgICAgIHJldHVybiBlID8gZS5sb2NhdGVOYW1lc3BhY2VQcmVmaXgobnMpIDogbnVsbDtcbiAgICB9XG4gIH19LFxuXG5cbiAgbG9va3VwTmFtZXNwYWNlVVJJOiB7dmFsdWU6IGZ1bmN0aW9uIGxvb2t1cE5hbWVzcGFjZVVSSShwcmVmaXgpIHtcbiAgICB2YXIgZTtcbiAgICBzd2l0Y2godGhpcy5ub2RlVHlwZSkge1xuICAgIGNhc2UgRUxFTUVOVF9OT0RFOlxuICAgICAgcmV0dXJuIHRoaXMubG9jYXRlTmFtZXNwYWNlKHByZWZpeCk7XG4gICAgY2FzZSBET0NVTUVOVF9OT0RFOlxuICAgICAgZSA9IHRoaXMuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgcmV0dXJuIGUgPyBlLmxvY2F0ZU5hbWVzcGFjZShwcmVmaXgpIDogbnVsbDtcbiAgICBjYXNlIERPQ1VNRU5UX1RZUEVfTk9ERTpcbiAgICBjYXNlIERPQ1VNRU5UX0ZSQUdNRU5UX05PREU6XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBkZWZhdWx0OlxuICAgICAgZSA9IHRoaXMucGFyZW50RWxlbWVudDtcbiAgICAgIHJldHVybiBlID8gZS5sb2NhdGVOYW1lc3BhY2UocHJlZml4KSA6IG51bGw7XG4gICAgfVxuICB9fSxcblxuICBpc0RlZmF1bHROYW1lc3BhY2U6IHsgdmFsdWU6IGZ1bmN0aW9uIGlzRGVmYXVsdE5hbWVzcGFjZShucykge1xuICAgIHZhciBkZWZhdWx0bnMgPSB0aGlzLmxvb2t1cE5hbWVzcGFjZVVSSShudWxsKTtcbiAgICBpZiAoZGVmYXVsdG5zID09PSBudWxsKSBkZWZhdWx0bnMgPSAnJztcbiAgICByZXR1cm4gbnMgPT09IGRlZmF1bHRucztcbiAgfX0sXG5cbiAgLy8gVXRpbGl0eSBtZXRob2RzIGZvciBub2Rlcy4gIE5vdCBwYXJ0IG9mIHRoZSBET01cblxuICAvLyBSZXR1cm4gdGhlIGluZGV4IG9mIHRoaXMgbm9kZSBpbiBpdHMgcGFyZW50LlxuICAvLyBUaHJvdyBpZiBubyBwYXJlbnQsIG9yIGlmIHRoaXMgbm9kZSBpcyBub3QgYSBjaGlsZCBvZiBpdHMgcGFyZW50XG4gIGluZGV4OiB7IGdldDogZnVuY3Rpb24oKSB7XG4gICAgdXRpbHMuYXNzZXJ0KHRoaXMucGFyZW50Tm9kZSk7XG4gICAgdmFyIGtpZHMgPSB0aGlzLnBhcmVudE5vZGUuY2hpbGROb2RlcztcbiAgICBpZiAodGhpcy5faW5kZXggPT09IHVuZGVmaW5lZCB8fCBraWRzW3RoaXMuX2luZGV4XSAhPT0gdGhpcykge1xuICAgICAgdGhpcy5faW5kZXggPSBraWRzLmluZGV4T2YodGhpcyk7XG4gICAgICB1dGlscy5hc3NlcnQodGhpcy5faW5kZXggIT09IC0xKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2luZGV4O1xuICB9fSxcblxuICAvLyBSZXR1cm4gdHJ1ZSBpZiB0aGlzIG5vZGUgaXMgZXF1YWwgdG8gb3IgaXMgYW4gYW5jZXN0b3Igb2YgdGhhdCBub2RlXG4gIC8vIE5vdGUgdGhhdCBub2RlcyBhcmUgY29uc2lkZXJlZCB0byBiZSBhbmNlc3RvcnMgb2YgdGhlbXNlbHZlc1xuICBpc0FuY2VzdG9yOiB7IHZhbHVlOiBmdW5jdGlvbih0aGF0KSB7XG4gICAgLy8gSWYgdGhleSBiZWxvbmcgdG8gZGlmZmVyZW50IGRvY3VtZW50cywgdGhlbiB0aGV5J3JlIHVucmVsYXRlZC5cbiAgICBpZiAodGhpcy5kb2MgIT09IHRoYXQuZG9jKSByZXR1cm4gZmFsc2U7XG4gICAgLy8gSWYgb25lIGlzIHJvb3RlZCBhbmQgb25lIGlzbid0IHRoZW4gdGhleSdyZSBub3QgcmVsYXRlZFxuICAgIGlmICh0aGlzLnJvb3RlZCAhPT0gdGhhdC5yb290ZWQpIHJldHVybiBmYWxzZTtcblxuICAgIC8vIE90aGVyd2lzZSBjaGVjayBieSB0cmF2ZXJzaW5nIHRoZSBwYXJlbnROb2RlIGNoYWluXG4gICAgZm9yKHZhciBlID0gdGhhdDsgZTsgZSA9IGUucGFyZW50Tm9kZSkge1xuICAgICAgaWYgKGUgPT09IHRoaXMpIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH19LFxuXG4gIC8vIERPTUlOTyBDaGFuZ2VkIHRoZSBiZWhhdmlvciB0byBjb25mb3JtIHdpdGggdGhlIHNwZWNzLiBTZWU6XG4gIC8vIGh0dHBzOi8vZ3JvdXBzLmdvb2dsZS5jb20vZC90b3BpYy9tb3ppbGxhLmRldi5wbGF0Zm9ybS83N3NJWWNwZERtYy9kaXNjdXNzaW9uXG4gIGVuc3VyZVNhbWVEb2M6IHsgdmFsdWU6IGZ1bmN0aW9uKHRoYXQpIHtcbiAgICBpZiAodGhhdC5vd25lckRvY3VtZW50ID09PSBudWxsKSB7XG4gICAgICB0aGF0Lm93bmVyRG9jdW1lbnQgPSB0aGlzLmRvYztcbiAgICB9XG4gICAgZWxzZSBpZih0aGF0Lm93bmVyRG9jdW1lbnQgIT09IHRoaXMuZG9jKSB7XG4gICAgICB1dGlscy5Xcm9uZ0RvY3VtZW50RXJyb3IoKTtcbiAgICB9XG4gIH19LFxuXG4gIC8vIFJlbW92ZSBhbGwgb2YgdGhpcyBub2RlJ3MgY2hpbGRyZW4uICBUaGlzIGlzIGEgbWlub3JcbiAgLy8gb3B0aW1pemF0aW9uIHRoYXQgb25seSBjYWxscyBtb2RpZnkoKSBvbmNlLlxuICByZW1vdmVDaGlsZHJlbjogeyB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlQ2hpbGRyZW4oKSB7XG4gICAgdmFyIG4gPSB0aGlzLmNoaWxkTm9kZXMubGVuZ3RoO1xuICAgIGlmIChuKSB7XG4gICAgICB2YXIgcm9vdCA9IHRoaXMucm9vdGVkID8gdGhpcy5vd25lckRvY3VtZW50IDogbnVsbDtcbiAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgaWYgKHJvb3QpIHJvb3QubXV0YXRlUmVtb3ZlKHRoaXMuY2hpbGROb2Rlc1tpXSk7XG4gICAgICAgIHRoaXMuY2hpbGROb2Rlc1tpXS5wYXJlbnROb2RlID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHRoaXMuY2hpbGROb2Rlcy5sZW5ndGggPSAwOyAvLyBGb3JnZXQgYWxsIGNoaWxkcmVuXG4gICAgICB0aGlzLm1vZGlmeSgpOyAgICAgICAgICAgICAgLy8gVXBkYXRlIGxhc3QgbW9kaWZpZWQgdHlwZSBvbmNlIG9ubHlcbiAgICB9XG4gIH19LFxuXG4gIC8vIEluc2VydCB0aGlzIG5vZGUgYXMgYSBjaGlsZCBvZiBwYXJlbnQgYXQgdGhlIHNwZWNpZmllZCBpbmRleCxcbiAgLy8gZmlyaW5nIG11dGF0aW9uIGV2ZW50cyBhcyBuZWNlc3NhcnlcbiAgaW5zZXJ0OiB7IHZhbHVlOiBmdW5jdGlvbiBpbnNlcnQocGFyZW50LCBpbmRleCkge1xuICAgIHRoaXMuX2luc2VydE9yUmVwbGFjZShwYXJlbnQsIGluZGV4LCBmYWxzZSk7XG4gIH19LFxuXG4gIC8vIEluc2VydCB0aGlzIG5vZGUgYXMgYSBjaGlsZCBvZiBwYXJlbnQgYXQgdGhlIHNwZWNpZmllZCBpbmRleCxcbiAgLy8gb3IgcmVwbGFjZSB0aGUgc3BlY2lmaWVkIGNoaWxkIHdpdGggdGhpcyBub2RlLCBmaXJpbmcgbXV0YXRpb24gZXZlbnRzIGFzXG4gIC8vIG5lY2Vzc2FyeVxuICBfaW5zZXJ0T3JSZXBsYWNlOiB7IHZhbHVlOiBmdW5jdGlvbiBfaW5zZXJ0T3JSZXBsYWNlKHBhcmVudCwgaW5kZXgsIGlzUmVwbGFjZSkge1xuICAgIHZhciBjaGlsZCA9IHRoaXM7XG4gICAgdmFyIGtpZHMgPSBwYXJlbnQuY2hpbGROb2RlcztcblxuICAgIGlmIChjaGlsZC5ub2RlVHlwZSA9PT0gRE9DVU1FTlRfRlJBR01FTlRfTk9ERSAmJiBjaGlsZC5yb290ZWQpIHtcbiAgICAgIHV0aWxzLkhpZXJhcmNoeVJlcXVlc3RFcnJvcigpO1xuICAgIH1cblxuICAgIC8vIElmIHdlIGFyZSBhbHJlYWR5IGEgY2hpbGQgb2YgdGhlIHNwZWNpZmllZCBwYXJlbnQsIHRoZW5cbiAgICAvLyB0aGUgaW5kZXggbWF5IGhhdmUgdG8gYmUgYWRqdXN0ZWQuXG4gICAgaWYgKGNoaWxkLnBhcmVudE5vZGUgPT09IHBhcmVudCkge1xuICAgICAgdmFyIGN1cnJlbnRJbmRleCA9IGNoaWxkLmluZGV4O1xuICAgICAgLy8gSWYgd2UncmUgbm90IG1vdmluZyB0aGUgbm9kZSwgd2UncmUgZG9uZSBub3dcbiAgICAgIC8vIFhYWDogb3IgZG8gRE9NIG11dGF0aW9uIGV2ZW50cyBzdGlsbCBoYXZlIHRvIGJlIGZpcmVkP1xuICAgICAgaWYgKGN1cnJlbnRJbmRleCA9PT0gaW5kZXgpIHJldHVybjtcblxuICAgICAgLy8gSWYgdGhlIGNoaWxkIGlzIGJlZm9yZSB0aGUgc3BvdCBpdCBpcyB0byBiZSBpbnNlcnRlZCBhdCxcbiAgICAgIC8vIHRoZW4gd2hlbiBpdCBpcyByZW1vdmVkLCB0aGUgaW5kZXggb2YgdGhhdCBzcG90IHdpbGwgYmVcbiAgICAgIC8vIHJlZHVjZWQuXG4gICAgICBpZiAoY3VycmVudEluZGV4IDwgaW5kZXgpIGluZGV4LS07XG4gICAgfVxuXG4gICAgLy8gRGVsZXRlIHRoZSBvbGQgY2hpbGRcbiAgICBpZiAoaXNSZXBsYWNlKSB7XG4gICAgICB2YXIgb2xkQ2hpbGQgPSBwYXJlbnQuY2hpbGROb2Rlc1tpbmRleF07XG4gICAgICBpZiAob2xkQ2hpbGQucm9vdGVkKSBvbGRDaGlsZC5kb2MubXV0YXRlUmVtb3ZlKG9sZENoaWxkKTtcbiAgICAgIG9sZENoaWxkLnBhcmVudE5vZGUgPSBudWxsO1xuICAgIH1cblxuICAgIC8vIElmIGJvdGggdGhlIGNoaWxkIGFuZCB0aGUgcGFyZW50IGFyZSByb290ZWQsIHRoZW4gd2Ugd2FudCB0b1xuICAgIC8vIHRyYW5zcGxhbnQgdGhlIGNoaWxkIHdpdGhvdXQgdXByb290aW5nIGFuZCByZXJvb3RpbmcgaXQuXG4gICAgaWYgKGNoaWxkLnJvb3RlZCAmJiBwYXJlbnQucm9vdGVkKSB7XG4gICAgICAvLyBSZW1vdmUgdGhlIGNoaWxkIGZyb20gaXRzIGN1cnJlbnQgcG9zaXRpb24gaW4gdGhlIHRyZWVcbiAgICAgIC8vIHdpdGhvdXQgY2FsbGluZyByZW1vdmUoKSwgc2luY2Ugd2UgZG9uJ3Qgd2FudCB0byB1cHJvb3QgaXQuXG4gICAgICB2YXIgY3VycGFyID0gY2hpbGQucGFyZW50Tm9kZTtcbiAgICAgIGN1cnBhci5jaGlsZE5vZGVzLnNwbGljZShjaGlsZC5pbmRleCwgMSk7XG4gICAgICBjdXJwYXIubW9kaWZ5KCk7XG5cbiAgICAgIC8vIEFuZCBpbnNlcnQgaXQgYXMgYSBjaGlsZCBvZiBpdHMgbmV3IHBhcmVudFxuICAgICAgY2hpbGQucGFyZW50Tm9kZSA9IHBhcmVudDtcbiAgICAgIGlmIChpc1JlcGxhY2UpIHtcbiAgICAgICAga2lkc1tpbmRleF0gPSBjaGlsZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGtpZHMuc3BsaWNlKGluZGV4LCAwLCBjaGlsZCk7XG4gICAgICB9XG4gICAgICBjaGlsZC5faW5kZXggPSBpbmRleDtcbiAgICAgIHBhcmVudC5tb2RpZnkoKTtcblxuICAgICAgLy8gR2VuZXJhdGUgYSBtb3ZlIG11dGF0aW9uIGV2ZW50XG4gICAgICBwYXJlbnQuZG9jLm11dGF0ZU1vdmUoY2hpbGQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGlmIChjaGlsZC5ub2RlVHlwZSA9PT0gRE9DVU1FTlRfRlJBR01FTlRfTk9ERSkge1xuICAgICAgICB2YXIgc3BsaWNlQXJncyA9IFtpbmRleCwgaXNSZXBsYWNlID8gMSA6IDBdO1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGNoaWxkLmNoaWxkTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgZnJhZ0NoaWxkID0gY2hpbGQuY2hpbGROb2Rlc1tpXTtcbiAgICAgICAgICBzcGxpY2VBcmdzLnB1c2goZnJhZ0NoaWxkKTtcbiAgICAgICAgICBmcmFnQ2hpbGQucGFyZW50Tm9kZSA9IHBhcmVudDtcbiAgICAgICAgICBmcmFnQ2hpbGQuX2luZGV4ID0gaW5kZXggKyBpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlbW92ZSBhbGwgbm9kZXMgZnJvbSB0aGUgZG9jdW1lbnQgZnJhZ21lbnRcbiAgICAgICAgY2hpbGQuY2hpbGROb2Rlcy5sZW5ndGggPSAwO1xuICAgICAgICAvLyBBZGQgYWxsIG5vZGVzIHRvIHRoZSBuZXcgcGFyZW50LCBvdmVyd3JpdGluZyB0aGUgb2xkIGNoaWxkXG4gICAgICAgIGtpZHMuc3BsaWNlLmFwcGx5KGtpZHMsIHNwbGljZUFyZ3MpO1xuICAgICAgICAvLyBDYWxsIHRoZSBtdXRhdGlvbiBoYW5kbGVyc1xuICAgICAgICAvLyBVc2Ugc3BsaWNlQXJncyBzaW5jZSB0aGUgb3JpZ2luYWwgYXJyYXkgaGFzIGJlZW4gZGVzdHJveWVkLiBUaGVcbiAgICAgICAgLy8gbGl2ZW5lc3MgZ3VhcmFudGVlIHJlcXVpcmVzIHVzIHRvIGNsb25lIHRoZSBhcnJheSBzbyB0aGF0XG4gICAgICAgIC8vIHJlZmVyZW5jZXMgdG8gdGhlIGNoaWxkTm9kZXMgb2YgdGhlIERvY3VtZW50RnJhZ21lbnQgd2lsbCBiZSBlbXB0eVxuICAgICAgICAvLyB3aGVuIHRoZSBpbnNlcnRpb24gaGFuZGxlcnMgYXJlIGNhbGxlZC5cbiAgICAgICAgaWYgKHBhcmVudC5yb290ZWQpIHtcbiAgICAgICAgICBwYXJlbnQubW9kaWZ5KCk7XG4gICAgICAgICAgZm9yIChpID0gMjsgaSA8IHNwbGljZUFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHBhcmVudC5kb2MubXV0YXRlSW5zZXJ0KHNwbGljZUFyZ3NbaV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIC8vIElmIHRoZSBjaGlsZCBhbHJlYWR5IGhhcyBhIHBhcmVudCwgaXQgbmVlZHMgdG8gYmVcbiAgICAgICAgLy8gcmVtb3ZlZCBmcm9tIHRoYXQgcGFyZW50LCB3aGljaCBtYXkgYWxzbyB1cHJvb3QgaXRcbiAgICAgICAgaWYgKGNoaWxkLnBhcmVudE5vZGUpIGNoaWxkLnJlbW92ZSgpO1xuXG4gICAgICAgIC8vIE5vdyBpbnNlcnQgdGhlIGNoaWxkIGludG8gdGhlIHBhcmVudCdzIGFycmF5IG9mIGNoaWxkcmVuXG4gICAgICAgIGNoaWxkLnBhcmVudE5vZGUgPSBwYXJlbnQ7XG4gICAgICAgIGlmIChpc1JlcGxhY2UpIHtcbiAgICAgICAgICBraWRzW2luZGV4XSA9IGNoaWxkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGtpZHMuc3BsaWNlKGluZGV4LCAwLCBjaGlsZCk7XG4gICAgICAgIH1cbiAgICAgICAgY2hpbGQuX2luZGV4ID0gaW5kZXg7XG5cbiAgICAgICAgLy8gQW5kIHJvb3QgdGhlIGNoaWxkIGlmIG5lY2Vzc2FyeVxuICAgICAgICBpZiAocGFyZW50LnJvb3RlZCkge1xuICAgICAgICAgIHBhcmVudC5tb2RpZnkoKTtcbiAgICAgICAgICBwYXJlbnQuZG9jLm11dGF0ZUluc2VydChjaGlsZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH19LFxuXG5cbiAgLy8gUmV0dXJuIHRoZSBsYXN0TW9kVGltZSB2YWx1ZSBmb3IgdGhpcyBub2RlLiAoRm9yIHVzZSBhcyBhXG4gIC8vIGNhY2hlIGludmFsaWRhdGlvbiBtZWNoYW5pc20uIElmIHRoZSBub2RlIGRvZXMgbm90IGFscmVhZHlcbiAgLy8gaGF2ZSBvbmUsIGluaXRpYWxpemUgaXQgZnJvbSB0aGUgb3duZXIgZG9jdW1lbnQncyBtb2RjbG9ja1xuICAvLyBwcm9wZXJ0eS4gKE5vdGUgdGhhdCBtb2RjbG9jayBkb2VzIG5vdCByZXR1cm4gdGhlIGFjdHVhbFxuICAvLyB0aW1lOyBpdCBpcyBzaW1wbHkgYSBjb3VudGVyIGluY3JlbWVudGVkIG9uIGVhY2ggZG9jdW1lbnRcbiAgLy8gbW9kaWZpY2F0aW9uKVxuICBsYXN0TW9kVGltZTogeyBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIGlmICghdGhpcy5fbGFzdE1vZFRpbWUpIHtcbiAgICAgIHRoaXMuX2xhc3RNb2RUaW1lID0gdGhpcy5kb2MubW9kY2xvY2s7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9sYXN0TW9kVGltZTtcbiAgfX0sXG5cbiAgLy8gSW5jcmVtZW50IHRoZSBvd25lciBkb2N1bWVudCdzIG1vZGNsb2NrIGFuZCB1c2UgdGhlIG5ld1xuICAvLyB2YWx1ZSB0byB1cGRhdGUgdGhlIGxhc3RNb2RUaW1lIHZhbHVlIGZvciB0aGlzIG5vZGUgYW5kXG4gIC8vIGFsbCBvZiBpdHMgYW5jZXN0b3JzLiBOb2RlcyB0aGF0IGhhdmUgbmV2ZXIgaGFkIHRoZWlyXG4gIC8vIGxhc3RNb2RUaW1lIHZhbHVlIHF1ZXJpZWQgZG8gbm90IG5lZWQgdG8gaGF2ZSBhXG4gIC8vIGxhc3RNb2RUaW1lIHByb3BlcnR5IHNldCBvbiB0aGVtIHNpbmNlIHRoZXJlIGlzIG5vXG4gIC8vIHByZXZpb3VzbHkgcXVlcmllZCB2YWx1ZSB0byBldmVyIGNvbXBhcmUgdGhlIG5ldyB2YWx1ZVxuICAvLyBhZ2FpbnN0LCBzbyBvbmx5IHVwZGF0ZSBub2RlcyB0aGF0IGFscmVhZHkgaGF2ZSBhXG4gIC8vIF9sYXN0TW9kVGltZSBwcm9wZXJ0eS5cbiAgbW9kaWZ5OiB7IHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5kb2MubW9kY2xvY2spIHsgLy8gU2tpcCB3aGlsZSBkb2MubW9kY2xvY2sgPT0gMFxuICAgICAgdmFyIHRpbWUgPSArK3RoaXMuZG9jLm1vZGNsb2NrO1xuICAgICAgZm9yKHZhciBuID0gdGhpczsgbjsgbiA9IG4ucGFyZW50RWxlbWVudCkge1xuICAgICAgICBpZiAobi5fbGFzdE1vZFRpbWUpIHtcbiAgICAgICAgICBuLl9sYXN0TW9kVGltZSA9IHRpbWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH19LFxuXG4gIC8vIFRoaXMgYXR0cmlidXRlIGlzIG5vdCBwYXJ0IG9mIHRoZSBET00gYnV0IGlzIHF1aXRlIGhlbHBmdWwuXG4gIC8vIEl0IHJldHVybnMgdGhlIGRvY3VtZW50IHdpdGggd2hpY2ggYSBub2RlIGlzIGFzc29jaWF0ZWQuICBVc3VhbGx5XG4gIC8vIHRoaXMgaXMgdGhlIG93bmVyRG9jdW1lbnQuIEJ1dCBvd25lckRvY3VtZW50IGlzIG51bGwgZm9yIHRoZVxuICAvLyBkb2N1bWVudCBvYmplY3QgaXRzZWxmLCBzbyB0aGlzIGlzIGEgaGFuZHkgd2F5IHRvIGdldCB0aGUgZG9jdW1lbnRcbiAgLy8gcmVnYXJkbGVzcyBvZiB0aGUgbm9kZSB0eXBlXG4gIGRvYzogeyBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLm93bmVyRG9jdW1lbnQgfHwgdGhpcztcbiAgfX0sXG5cblxuICAvLyBJZiB0aGUgbm9kZSBoYXMgYSBuaWQgKG5vZGUgaWQpLCB0aGVuIGl0IGlzIHJvb3RlZCBpbiBhIGRvY3VtZW50XG4gIHJvb3RlZDogeyBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAhIXRoaXMuX25pZDtcbiAgfX0sXG5cbiAgbm9ybWFsaXplOiB7IHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICBmb3IgKHZhciBpPTA7IGkgPCB0aGlzLmNoaWxkTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjaGlsZCA9IHRoaXMuY2hpbGROb2Rlc1tpXTtcblxuICAgICAgaWYgKGNoaWxkLm5vcm1hbGl6ZSkge1xuICAgICAgICBjaGlsZC5ub3JtYWxpemUoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNoaWxkLm5vZGVUeXBlICE9PSBOb2RlLlRFWFRfTk9ERSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNoaWxkLm5vZGVWYWx1ZSA9PT0gXCJcIikge1xuICAgICAgICB0aGlzLnJlbW92ZUNoaWxkKGNoaWxkKTtcbiAgICAgICAgaS0tO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGkpIHtcbiAgICAgICAgdmFyIHByZXZDaGlsZCA9IHRoaXMuY2hpbGROb2Rlc1tpLTFdO1xuXG4gICAgICAgIGlmIChwcmV2Q2hpbGQubm9kZVR5cGUgPT09IE5vZGUuVEVYVF9OT0RFKSB7XG4gICAgICAgICAgLy8gcmVtb3ZlIHRoZSBjaGlsZCBhbmQgZGVjcmVtZW50IGlcbiAgICAgICAgICBwcmV2Q2hpbGQuYXBwZW5kRGF0YShjaGlsZC5ub2RlVmFsdWUpO1xuXG4gICAgICAgICAgdGhpcy5yZW1vdmVDaGlsZChjaGlsZCk7XG4gICAgICAgICAgaS0tO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9fSxcblxuICAvLyBDb252ZXJ0IHRoZSBjaGlsZHJlbiBvZiBhIG5vZGUgdG8gYW4gSFRNTCBzdHJpbmcuXG4gIC8vIFRoaXMgaXMgdXNlZCBieSB0aGUgaW5uZXJIVE1MIGdldHRlclxuICAvLyBUaGUgc2VyaWFsaXphdGlvbiBzcGVjIGlzIGF0OlxuICAvLyBodHRwOi8vd3d3LndoYXR3Zy5vcmcvc3BlY3Mvd2ViLWFwcHMvY3VycmVudC13b3JrL211bHRpcGFnZS90aGUtZW5kLmh0bWwjc2VyaWFsaXppbmctaHRtbC1mcmFnbWVudHNcbiAgc2VyaWFsaXplOiB7IHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgcyA9ICcnO1xuICAgIGZvcih2YXIgaSA9IDAsIG4gPSB0aGlzLmNoaWxkTm9kZXMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICB2YXIga2lkID0gdGhpcy5jaGlsZE5vZGVzW2ldO1xuICAgICAgc3dpdGNoKGtpZC5ub2RlVHlwZSkge1xuICAgICAgY2FzZSAxOiAvL0VMRU1FTlRfTk9ERVxuICAgICAgICB2YXIgbnMgPSBraWQubmFtZXNwYWNlVVJJO1xuICAgICAgICB2YXIgaHRtbCA9IG5zID09PSBOQU1FU1BBQ0UuSFRNTDtcbiAgICAgICAgdmFyIHRhZ25hbWUgPSAoaHRtbCB8fCBucyA9PT0gTkFNRVNQQUNFLlNWRyB8fCBucyA9PT0gTkFNRVNQQUNFLk1BVEhNTCkgPyBraWQubG9jYWxOYW1lIDoga2lkLnRhZ05hbWU7XG5cbiAgICAgICAgcyArPSAnPCcgKyB0YWduYW1lO1xuXG4gICAgICAgIGZvcih2YXIgaiA9IDAsIGsgPSBraWQuX251bWF0dHJzOyBqIDwgazsgaisrKSB7XG4gICAgICAgICAgdmFyIGEgPSBraWQuX2F0dHIoaik7XG4gICAgICAgICAgcyArPSAnICcgKyBhdHRybmFtZShhKTtcbiAgICAgICAgICBpZiAoYS52YWx1ZSAhPT0gdW5kZWZpbmVkKSBzICs9ICc9XCInICsgZXNjYXBlQXR0cihhLnZhbHVlKSArICdcIic7XG4gICAgICAgIH1cbiAgICAgICAgcyArPSAnPic7XG5cbiAgICAgICAgaWYgKCEoaHRtbCAmJiBlbXB0eUVsZW1lbnRzW3RhZ25hbWVdKSkge1xuICAgICAgICAgIHZhciBzcyA9IGtpZC5zZXJpYWxpemUoKTtcbiAgICAgICAgICBpZiAoaHRtbCAmJiBleHRyYU5ld0xpbmVbdGFnbmFtZV0gJiYgc3MuY2hhckF0KDApPT09J1xcbicpIHMgKz0gJ1xcbic7XG4gICAgICAgICAgLy8gU2VyaWFsaXplIGNoaWxkcmVuIGFuZCBhZGQgZW5kIHRhZyBmb3IgYWxsIG90aGVyc1xuICAgICAgICAgIHMgKz0gc3M7XG4gICAgICAgICAgcyArPSAnPC8nICsgdGFnbmFtZSArICc+JztcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMzogLy9URVhUX05PREVcbiAgICAgIGNhc2UgNDogLy9DREFUQV9TRUNUSU9OX05PREVcbiAgICAgICAgdmFyIHBhcmVudHRhZztcbiAgICAgICAgaWYgKHRoaXMubm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERSAmJlxuICAgICAgICAgIHRoaXMubmFtZXNwYWNlVVJJID09PSBOQU1FU1BBQ0UuSFRNTClcbiAgICAgICAgICBwYXJlbnR0YWcgPSB0aGlzLnRhZ05hbWU7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBwYXJlbnR0YWcgPSAnJztcblxuICAgICAgICBpZiAoaGFzUmF3Q29udGVudFtwYXJlbnR0YWddIHx8XG4gICAgICAgICAgICAocGFyZW50dGFnPT09J05PU0NSSVBUJyAmJiB0aGlzLm93bmVyRG9jdW1lbnQuX3NjcmlwdGluZ19lbmFibGVkKSkge1xuICAgICAgICAgIHMgKz0ga2lkLmRhdGE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcyArPSBlc2NhcGUoa2lkLmRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSA4OiAvL0NPTU1FTlRfTk9ERVxuICAgICAgICBzICs9ICc8IS0tJyArIGtpZC5kYXRhICsgJy0tPic7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSA3OiAvL1BST0NFU1NJTkdfSU5TVFJVQ1RJT05fTk9ERVxuICAgICAgICBzICs9ICc8PycgKyBraWQudGFyZ2V0ICsgJyAnICsga2lkLmRhdGEgKyAnPz4nO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTA6IC8vRE9DVU1FTlRfVFlQRV9OT0RFXG4gICAgICAgIHMgKz0gJzwhRE9DVFlQRSAnICsga2lkLm5hbWU7XG5cbiAgICAgICAgaWYgKGZhbHNlKSB7XG4gICAgICAgICAgLy8gTGF0ZXN0IEhUTUwgc2VyaWFsaXphdGlvbiBzcGVjIG9taXRzIHRoZSBwdWJsaWMvc3lzdGVtIElEXG4gICAgICAgICAgaWYgKGtpZC5wdWJsaWNJRCkge1xuICAgICAgICAgICAgcyArPSAnIFBVQkxJQyBcIicgKyBraWQucHVibGljSWQgKyAnXCInO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChraWQuc3lzdGVtSWQpIHtcbiAgICAgICAgICAgIHMgKz0gJyBcIicgKyBraWQuc3lzdGVtSWQgKyAnXCInO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHMgKz0gJz4nO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHV0aWxzLkludmFsaWRTdGF0ZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzO1xuICB9fSxcblxuICAvLyBtaXJyb3Igbm9kZSB0eXBlIHByb3BlcnRpZXMgaW4gdGhlIHByb3RvdHlwZSwgc28gdGhleSBhcmUgcHJlc2VudFxuICAvLyBpbiBpbnN0YW5jZXMgb2YgTm9kZSAoYW5kIHN1YmNsYXNzZXMpXG4gIEVMRU1FTlRfTk9ERTogICAgICAgICAgICAgICAgeyB2YWx1ZTogRUxFTUVOVF9OT0RFIH0sXG4gIEFUVFJJQlVURV9OT0RFOiAgICAgICAgICAgICAgeyB2YWx1ZTogQVRUUklCVVRFX05PREUgfSxcbiAgVEVYVF9OT0RFOiAgICAgICAgICAgICAgICAgICB7IHZhbHVlOiBURVhUX05PREUgfSxcbiAgQ0RBVEFfU0VDVElPTl9OT0RFOiAgICAgICAgICB7IHZhbHVlOiBDREFUQV9TRUNUSU9OX05PREUgfSxcbiAgRU5USVRZX1JFRkVSRU5DRV9OT0RFOiAgICAgICB7IHZhbHVlOiBFTlRJVFlfUkVGRVJFTkNFX05PREUgfSxcbiAgRU5USVRZX05PREU6ICAgICAgICAgICAgICAgICB7IHZhbHVlOiBFTlRJVFlfTk9ERSB9LFxuICBQUk9DRVNTSU5HX0lOU1RSVUNUSU9OX05PREU6IHsgdmFsdWU6IFBST0NFU1NJTkdfSU5TVFJVQ1RJT05fTk9ERSB9LFxuICBDT01NRU5UX05PREU6ICAgICAgICAgICAgICAgIHsgdmFsdWU6IENPTU1FTlRfTk9ERSB9LFxuICBET0NVTUVOVF9OT0RFOiAgICAgICAgICAgICAgIHsgdmFsdWU6IERPQ1VNRU5UX05PREUgfSxcbiAgRE9DVU1FTlRfVFlQRV9OT0RFOiAgICAgICAgICB7IHZhbHVlOiBET0NVTUVOVF9UWVBFX05PREUgfSxcbiAgRE9DVU1FTlRfRlJBR01FTlRfTk9ERTogICAgICB7IHZhbHVlOiBET0NVTUVOVF9GUkFHTUVOVF9OT0RFIH0sXG4gIE5PVEFUSU9OX05PREU6ICAgICAgICAgICAgICAgeyB2YWx1ZTogTk9UQVRJT05fTk9ERSB9XG59KTtcblxuZnVuY3Rpb24gZXNjYXBlKHMpIHtcbiAgcmV0dXJuIHMucmVwbGFjZSgvWyY8PlxcdTAwQTBdL2csIGZ1bmN0aW9uKGMpIHtcbiAgICBzd2l0Y2goYykge1xuICAgIGNhc2UgJyYnOiByZXR1cm4gJyZhbXA7JztcbiAgICBjYXNlICc8JzogcmV0dXJuICcmbHQ7JztcbiAgICBjYXNlICc+JzogcmV0dXJuICcmZ3Q7JztcbiAgICBjYXNlICdcXHUwMEEwJzogcmV0dXJuICcmbmJzcDsnO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGVzY2FwZUF0dHIocykge1xuICB2YXIgdG9Fc2NhcGUgPSAvWyZcIlxcdTAwQTBdL2c7XG4gIGlmICghdG9Fc2NhcGUudGVzdChzKSkge1xuICAgICAgLy8gbm90aGluZyB0byBkbywgZmFzdCBwYXRoXG4gICAgICByZXR1cm4gcztcbiAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBzLnJlcGxhY2UodG9Fc2NhcGUsIGZ1bmN0aW9uKGMpIHtcbiAgICAgICAgc3dpdGNoKGMpIHtcbiAgICAgICAgY2FzZSAnJic6IHJldHVybiAnJmFtcDsnO1xuICAgICAgICBjYXNlICdcIic6IHJldHVybiAnJnF1b3Q7JztcbiAgICAgICAgY2FzZSAnXFx1MDBBMCc6IHJldHVybiAnJm5ic3A7JztcbiAgICAgICAgfVxuICAgICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gYXR0cm5hbWUoYSkge1xuICB2YXIgbnMgPSBhLm5hbWVzcGFjZVVSSTtcbiAgaWYgKCFucylcbiAgICByZXR1cm4gYS5sb2NhbE5hbWU7XG4gIGlmIChucyA9PT0gTkFNRVNQQUNFLlhNTClcbiAgICByZXR1cm4gJ3htbDonICsgYS5sb2NhbE5hbWU7XG4gIGlmIChucyA9PT0gTkFNRVNQQUNFLlhMSU5LKVxuICAgIHJldHVybiAneGxpbms6JyArIGEubG9jYWxOYW1lO1xuXG4gIGlmIChucyA9PT0gTkFNRVNQQUNFLlhNTE5TKSB7XG4gICAgaWYgKGEubG9jYWxOYW1lID09PSAneG1sbnMnKSByZXR1cm4gJ3htbG5zJztcbiAgICBlbHNlIHJldHVybiAneG1sbnM6JyArIGEubG9jYWxOYW1lO1xuICB9XG4gIHJldHVybiBhLm5hbWU7XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9kb21pbm8vbGliL05vZGUuanNcbi8vIG1vZHVsZSBpZCA9IDRcbi8vIG1vZHVsZSBjaHVua3MgPSA0IiwibW9kdWxlLmV4cG9ydHMgPSAoX193ZWJwYWNrX3JlcXVpcmVfXygyKSkoMjUpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGRlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9AYW5ndWxhci9jb21tb24vYnVuZGxlcy9jb21tb24udW1kLmpzIGZyb20gZGxsLXJlZmVyZW5jZSAuL3ZlbmRvclxuLy8gbW9kdWxlIGlkID0gNVxuLy8gbW9kdWxlIGNodW5rcyA9IDQiLCJtb2R1bGUuZXhwb3J0cyA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKDIpKSgyNCk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZGVsZWdhdGVkIC4vbm9kZV9tb2R1bGVzL0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXIvYnVuZGxlcy9wbGF0Zm9ybS1icm93c2VyLnVtZC5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgLi92ZW5kb3Jcbi8vIG1vZHVsZSBpZCA9IDZcbi8vIG1vZHVsZSBjaHVua3MgPSA0IiwibW9kdWxlLmV4cG9ydHMgPSAoX193ZWJwYWNrX3JlcXVpcmVfXygyKSkoMCk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZGVsZWdhdGVkIC4vbm9kZV9tb2R1bGVzL3J4anMvT2JzZXJ2YWJsZS5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgLi92ZW5kb3Jcbi8vIG1vZHVsZSBpZCA9IDdcbi8vIG1vZHVsZSBjaHVua3MgPSA0IiwiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50O1xuXG5FdmVudC5DQVBUVVJJTkdfUEhBU0UgPSAxO1xuRXZlbnQuQVRfVEFSR0VUID0gMjtcbkV2ZW50LkJVQkJMSU5HX1BIQVNFID0gMztcblxuZnVuY3Rpb24gRXZlbnQodHlwZSwgZGljdGlvbmFyeSkge1xuICAvLyBJbml0aWFsaXplIGJhc2ljIGV2ZW50IHByb3BlcnRpZXNcbiAgdGhpcy50eXBlID0gJyc7XG4gIHRoaXMudGFyZ2V0ID0gbnVsbDtcbiAgdGhpcy5jdXJyZW50VGFyZ2V0ID0gbnVsbDtcbiAgdGhpcy5ldmVudFBoYXNlID0gRXZlbnQuQVRfVEFSR0VUO1xuICB0aGlzLmJ1YmJsZXMgPSBmYWxzZTtcbiAgdGhpcy5jYW5jZWxhYmxlID0gZmFsc2U7XG4gIHRoaXMuaXNUcnVzdGVkID0gZmFsc2U7XG4gIHRoaXMuZGVmYXVsdFByZXZlbnRlZCA9IGZhbHNlO1xuICB0aGlzLnRpbWVTdGFtcCA9IERhdGUubm93KCk7XG5cbiAgLy8gSW5pdGlhbGl6ZSBpbnRlcm5hbCBmbGFnc1xuICAvLyBYWFg6IFdvdWxkIGl0IGJlIGJldHRlciB0byBpbmhlcml0IHRoZXNlIGRlZmF1bHRzIGZyb20gdGhlIHByb3RvdHlwZT9cbiAgdGhpcy5fcHJvcGFnYXRpb25TdG9wcGVkID0gZmFsc2U7XG4gIHRoaXMuX2ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCA9IGZhbHNlO1xuICB0aGlzLl9pbml0aWFsaXplZCA9IHRydWU7XG4gIHRoaXMuX2Rpc3BhdGNoaW5nID0gZmFsc2U7XG5cbiAgLy8gTm93IGluaXRpYWxpemUgYmFzZWQgb24gdGhlIGNvbnN0cnVjdG9yIGFyZ3VtZW50cyAoaWYgYW55KVxuICBpZiAodHlwZSkgdGhpcy50eXBlID0gdHlwZTtcbiAgaWYgKGRpY3Rpb25hcnkpIHtcbiAgICBmb3IodmFyIHAgaW4gZGljdGlvbmFyeSkge1xuICAgICAgdGhpc1twXSA9IGRpY3Rpb25hcnlbcF07XG4gICAgfVxuICB9XG59XG5cbkV2ZW50LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoT2JqZWN0LnByb3RvdHlwZSwge1xuICBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogRXZlbnQgfSxcbiAgc3RvcFByb3BhZ2F0aW9uOiB7IHZhbHVlOiBmdW5jdGlvbiBzdG9wUHJvcGFnYXRpb24oKSB7XG4gICAgdGhpcy5fcHJvcGFnYXRpb25TdG9wcGVkID0gdHJ1ZTtcbiAgfX0sXG5cbiAgc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uOiB7IHZhbHVlOiBmdW5jdGlvbiBzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKSB7XG4gICAgdGhpcy5fcHJvcGFnYXRpb25TdG9wcGVkID0gdHJ1ZTtcbiAgICB0aGlzLl9pbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQgPSB0cnVlO1xuICB9fSxcblxuICBwcmV2ZW50RGVmYXVsdDogeyB2YWx1ZTogZnVuY3Rpb24gcHJldmVudERlZmF1bHQoKSB7XG4gICAgaWYgKHRoaXMuY2FuY2VsYWJsZSkgdGhpcy5kZWZhdWx0UHJldmVudGVkID0gdHJ1ZTtcbiAgfX0sXG5cbiAgaW5pdEV2ZW50OiB7IHZhbHVlOiBmdW5jdGlvbiBpbml0RXZlbnQodHlwZSwgYnViYmxlcywgY2FuY2VsYWJsZSkge1xuICAgIHRoaXMuX2luaXRpYWxpemVkID0gdHJ1ZTtcbiAgICBpZiAodGhpcy5fZGlzcGF0Y2hpbmcpIHJldHVybjtcblxuICAgIHRoaXMuX3Byb3BhZ2F0aW9uU3RvcHBlZCA9IGZhbHNlO1xuICAgIHRoaXMuX2ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCA9IGZhbHNlO1xuICAgIHRoaXMuZGVmYXVsdFByZXZlbnRlZCA9IGZhbHNlO1xuICAgIHRoaXMuaXNUcnVzdGVkID0gZmFsc2U7XG5cbiAgICB0aGlzLnRhcmdldCA9IG51bGw7XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB0aGlzLmJ1YmJsZXMgPSBidWJibGVzO1xuICAgIHRoaXMuY2FuY2VsYWJsZSA9IGNhbmNlbGFibGU7XG4gIH19LFxuXG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2RvbWluby9saWIvRXZlbnQuanNcbi8vIG1vZHVsZSBpZCA9IDhcbi8vIG1vZHVsZSBjaHVua3MgPSA0IiwiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IEVsZW1lbnQ7XG5cbnZhciB4bWwgPSByZXF1aXJlKCcuL3htbG5hbWVzJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG52YXIgTkFNRVNQQUNFID0gdXRpbHMuTkFNRVNQQUNFO1xudmFyIGF0dHJpYnV0ZXMgPSByZXF1aXJlKCcuL2F0dHJpYnV0ZXMnKTtcbnZhciBOb2RlID0gcmVxdWlyZSgnLi9Ob2RlJyk7XG52YXIgTm9kZUxpc3QgPSByZXF1aXJlKCcuL05vZGVMaXN0Jyk7XG52YXIgRmlsdGVyZWRFbGVtZW50TGlzdCA9IHJlcXVpcmUoJy4vRmlsdGVyZWRFbGVtZW50TGlzdCcpO1xudmFyIERPTVRva2VuTGlzdCA9IHJlcXVpcmUoJy4vRE9NVG9rZW5MaXN0Jyk7XG52YXIgc2VsZWN0ID0gcmVxdWlyZSgnLi9zZWxlY3QnKTtcbnZhciBDaGlsZE5vZGUgPSByZXF1aXJlKCcuL0NoaWxkTm9kZScpO1xudmFyIE5vbkRvY3VtZW50VHlwZUNoaWxkTm9kZSA9IHJlcXVpcmUoJy4vTm9uRG9jdW1lbnRUeXBlQ2hpbGROb2RlJyk7XG5cbmZ1bmN0aW9uIEVsZW1lbnQoZG9jLCBsb2NhbE5hbWUsIG5hbWVzcGFjZVVSSSwgcHJlZml4KSB7XG4gIHRoaXMubm9kZVR5cGUgPSBOb2RlLkVMRU1FTlRfTk9ERTtcbiAgdGhpcy5vd25lckRvY3VtZW50ID0gZG9jO1xuICB0aGlzLmxvY2FsTmFtZSA9IGxvY2FsTmFtZTtcbiAgdGhpcy5uYW1lc3BhY2VVUkkgPSBuYW1lc3BhY2VVUkk7XG4gIHRoaXMucHJlZml4ID0gcHJlZml4O1xuXG4gIHRoaXMudGFnTmFtZSA9IChwcmVmaXggIT09IG51bGwpID8gcHJlZml4ICsgJzonICsgbG9jYWxOYW1lIDogbG9jYWxOYW1lO1xuXG4gIGlmIChuYW1lc3BhY2VVUkkgIT09IE5BTUVTUEFDRS5IVE1MIHx8ICghbmFtZXNwYWNlVVJJICYmICFkb2MuaXNIVE1MKSkgdGhpcy5pc0hUTUwgPSBmYWxzZTtcblxuICBpZiAodGhpcy5pc0hUTUwpIHRoaXMudGFnTmFtZSA9IHRoaXMudGFnTmFtZS50b1VwcGVyQ2FzZSgpO1xuXG4gIHRoaXMuY2hpbGROb2RlcyA9IG5ldyBOb2RlTGlzdCgpO1xuXG4gIC8vIFRoZXNlIHByb3BlcnRpZXMgbWFpbnRhaW4gdGhlIHNldCBvZiBhdHRyaWJ1dGVzXG4gIHRoaXMuX2F0dHJzQnlRTmFtZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7IC8vIFRoZSBxbmFtZS0+QXR0ciBtYXBcbiAgdGhpcy5fYXR0cnNCeUxOYW1lID0gT2JqZWN0LmNyZWF0ZShudWxsKTsgLy8gVGhlIG5zfGxuYW1lLT5BdHRyIG1hcFxuICB0aGlzLl9hdHRyS2V5cyA9IFtdOyAgICAgLy8gYXR0ciBpbmRleCAtPiBuc3xsbmFtZVxuXG4gIHRoaXMuX2luZGV4ID0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiByZWN1cnNpdmVHZXRUZXh0KG5vZGUsIGEpIHtcbiAgaWYgKG5vZGUubm9kZVR5cGUgPT09IE5vZGUuVEVYVF9OT0RFKSB7XG4gICAgYS5wdXNoKG5vZGUuX2RhdGEpO1xuICB9XG4gIGVsc2Uge1xuICAgIGZvcih2YXIgaSA9IDAsIG4gPSBub2RlLmNoaWxkTm9kZXMubGVuZ3RoOyAgaSA8IG47IGkrKylcbiAgICAgIHJlY3Vyc2l2ZUdldFRleHQobm9kZS5jaGlsZE5vZGVzW2ldLCBhKTtcbiAgfVxufVxuXG5FbGVtZW50LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoTm9kZS5wcm90b3R5cGUsIHtcbiAgbm9kZU5hbWU6IHsgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMudGFnTmFtZTsgfX0sXG4gIG5vZGVWYWx1ZToge1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24oKSB7fVxuICB9LFxuICB0ZXh0Q29udGVudDoge1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc3RyaW5ncyA9IFtdO1xuICAgICAgcmVjdXJzaXZlR2V0VGV4dCh0aGlzLCBzdHJpbmdzKTtcbiAgICAgIHJldHVybiBzdHJpbmdzLmpvaW4oJycpO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbihuZXd0ZXh0KSB7XG4gICAgICB0aGlzLnJlbW92ZUNoaWxkcmVuKCk7XG4gICAgICBpZiAobmV3dGV4dCAhPT0gbnVsbCAmJiBuZXd0ZXh0ICE9PSAnJykge1xuICAgICAgICB0aGlzLl9hcHBlbmRDaGlsZCh0aGlzLm93bmVyRG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUobmV3dGV4dCkpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgaW5uZXJIVE1MOiB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnNlcmlhbGl6ZSgpO1xuICAgIH0sXG4gICAgc2V0OiB1dGlscy5ueWlcbiAgfSxcbiAgb3V0ZXJIVE1MOiB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIC8vIFwidGhlIGF0dHJpYnV0ZSBtdXN0IHJldHVybiB0aGUgcmVzdWx0IG9mIHJ1bm5pbmcgdGhlIEhUTUwgZnJhZ21lbnRcbiAgICAgIC8vIHNlcmlhbGl6YXRpb24gYWxnb3JpdGhtIG9uIGEgZmljdGlvbmFsIG5vZGUgd2hvc2Ugb25seSBjaGlsZCBpc1xuICAgICAgLy8gdGhlIGNvbnRleHQgb2JqZWN0XCJcbiAgICAgIHZhciBmaWN0aW9uYWwgPSB7XG4gICAgICAgIGNoaWxkTm9kZXM6IFsgdGhpcyBdLFxuICAgICAgICBub2RlVHlwZTogMFxuICAgICAgfTtcbiAgICAgIHJldHVybiBOb2RlLnByb3RvdHlwZS5zZXJpYWxpemUuY2FsbChmaWN0aW9uYWwpO1xuICAgIH0sXG4gICAgc2V0OiB1dGlscy5ueWlcbiAgfSxcblxuICBjaGlsZHJlbjogeyBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIGlmICghdGhpcy5fY2hpbGRyZW4pIHtcbiAgICAgIHRoaXMuX2NoaWxkcmVuID0gbmV3IENoaWxkcmVuQ29sbGVjdGlvbih0aGlzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2NoaWxkcmVuO1xuICB9fSxcblxuICBhdHRyaWJ1dGVzOiB7IGdldDogZnVuY3Rpb24oKSB7XG4gICAgaWYgKCF0aGlzLl9hdHRyaWJ1dGVzKSB7XG4gICAgICB0aGlzLl9hdHRyaWJ1dGVzID0gbmV3IEF0dHJpYnV0ZXNBcnJheSh0aGlzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2F0dHJpYnV0ZXM7XG4gIH19LFxuXG5cbiAgZmlyc3RFbGVtZW50Q2hpbGQ6IHsgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICB2YXIga2lkcyA9IHRoaXMuY2hpbGROb2RlcztcbiAgICBmb3IodmFyIGkgPSAwLCBuID0ga2lkcy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgIGlmIChraWRzW2ldLm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSkgcmV0dXJuIGtpZHNbaV07XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9fSxcblxuICBsYXN0RWxlbWVudENoaWxkOiB7IGdldDogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGtpZHMgPSB0aGlzLmNoaWxkTm9kZXM7XG4gICAgZm9yKHZhciBpID0ga2lkcy5sZW5ndGgtMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGlmIChraWRzW2ldLm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSkgcmV0dXJuIGtpZHNbaV07XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9fSxcblxuICBjaGlsZEVsZW1lbnRDb3VudDogeyBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmNoaWxkcmVuLmxlbmd0aDtcbiAgfX0sXG5cblxuICAvLyBSZXR1cm4gdGhlIG5leHQgZWxlbWVudCwgaW4gc291cmNlIG9yZGVyLCBhZnRlciB0aGlzIG9uZSBvclxuICAvLyBudWxsIGlmIHRoZXJlIGFyZSBubyBtb3JlLiAgSWYgcm9vdCBlbGVtZW50IGlzIHNwZWNpZmllZCxcbiAgLy8gdGhlbiBkb24ndCB0cmF2ZXJzZSBiZXlvbmQgaXRzIHN1YnRyZWUuXG4gIC8vXG4gIC8vIFRoaXMgaXMgbm90IGEgRE9NIG1ldGhvZCwgYnV0IGlzIGNvbnZlbmllbnQgZm9yXG4gIC8vIGxhenkgdHJhdmVyc2FscyBvZiB0aGUgdHJlZS5cbiAgbmV4dEVsZW1lbnQ6IHsgdmFsdWU6IGZ1bmN0aW9uKHJvb3QpIHtcbiAgICBpZiAoIXJvb3QpIHJvb3QgPSB0aGlzLm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgIHZhciBuZXh0ID0gdGhpcy5maXJzdEVsZW1lbnRDaGlsZDtcbiAgICBpZiAoIW5leHQpIHtcbiAgICAgIC8vIGRvbid0IHVzZSBzaWJsaW5nIGlmIHdlJ3JlIGF0IHJvb3RcbiAgICAgIGlmICh0aGlzPT09cm9vdCkgcmV0dXJuIG51bGw7XG4gICAgICBuZXh0ID0gdGhpcy5uZXh0RWxlbWVudFNpYmxpbmc7XG4gICAgfVxuICAgIGlmIChuZXh0KSByZXR1cm4gbmV4dDtcblxuICAgIC8vIElmIHdlIGNhbid0IGdvIGRvd24gb3IgYWNyb3NzLCB0aGVuIHdlIGhhdmUgdG8gZ28gdXBcbiAgICAvLyBhbmQgYWNyb3NzIHRvIHRoZSBwYXJlbnQgc2libGluZyBvciBhbm90aGVyIGFuY2VzdG9yJ3NcbiAgICAvLyBzaWJsaW5nLiAgQmUgY2FyZWZ1bCwgdGhvdWdoOiBpZiB3ZSByZWFjaCB0aGUgcm9vdFxuICAgIC8vIGVsZW1lbnQsIG9yIGlmIHdlIHJlYWNoIHRoZSBkb2N1bWVudEVsZW1lbnQsIHRoZW5cbiAgICAvLyB0aGUgdHJhdmVyc2FsIGVuZHMuXG4gICAgZm9yKHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudEVsZW1lbnQ7XG4gICAgICBwYXJlbnQgJiYgcGFyZW50ICE9PSByb290O1xuICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudEVsZW1lbnQpIHtcblxuICAgICAgbmV4dCA9IHBhcmVudC5uZXh0RWxlbWVudFNpYmxpbmc7XG4gICAgICBpZiAobmV4dCkgcmV0dXJuIG5leHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH19LFxuXG4gIC8vIFhYWDpcbiAgLy8gVGVzdHMgYXJlIGN1cnJlbnRseSBmYWlsaW5nIGZvciB0aGlzIGZ1bmN0aW9uLlxuICAvLyBBd2FpdGluZyByZXNvbHV0aW9uIG9mOlxuICAvLyBodHRwOi8vbGlzdHMudzMub3JnL0FyY2hpdmVzL1B1YmxpYy93d3ctZG9tLzIwMTFKdWxTZXAvMDAxNi5odG1sXG4gIGdldEVsZW1lbnRzQnlUYWdOYW1lOiB7IHZhbHVlOiBmdW5jdGlvbiBnZXRFbGVtZW50c0J5VGFnTmFtZShsbmFtZSkge1xuICAgIHZhciBmaWx0ZXI7XG4gICAgaWYgKCFsbmFtZSkgcmV0dXJuIG5ldyBOb2RlTGlzdCgpO1xuICAgIGlmIChsbmFtZSA9PT0gJyonKVxuICAgICAgZmlsdGVyID0gZnVuY3Rpb24oKSB7IHJldHVybiB0cnVlOyB9O1xuICAgIGVsc2UgaWYgKHRoaXMuaXNIVE1MKVxuICAgICAgZmlsdGVyID0gaHRtbExvY2FsTmFtZUVsZW1lbnRGaWx0ZXIobG5hbWUpO1xuICAgIGVsc2VcbiAgICAgIGZpbHRlciA9IGxvY2FsTmFtZUVsZW1lbnRGaWx0ZXIobG5hbWUpO1xuXG4gICAgcmV0dXJuIG5ldyBGaWx0ZXJlZEVsZW1lbnRMaXN0KHRoaXMsIGZpbHRlcik7XG4gIH19LFxuXG4gIGdldEVsZW1lbnRzQnlUYWdOYW1lTlM6IHsgdmFsdWU6IGZ1bmN0aW9uIGdldEVsZW1lbnRzQnlUYWdOYW1lTlMobnMsIGxuYW1lKXtcbiAgICB2YXIgZmlsdGVyO1xuICAgIGlmIChucyA9PT0gJyonICYmIGxuYW1lID09PSAnKicpXG4gICAgICBmaWx0ZXIgPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRydWU7IH07XG4gICAgZWxzZSBpZiAobnMgPT09ICcqJylcbiAgICAgIGZpbHRlciA9IGxvY2FsTmFtZUVsZW1lbnRGaWx0ZXIobG5hbWUpO1xuICAgIGVsc2UgaWYgKGxuYW1lID09PSAnKicpXG4gICAgICBmaWx0ZXIgPSBuYW1lc3BhY2VFbGVtZW50RmlsdGVyKG5zKTtcbiAgICBlbHNlXG4gICAgICBmaWx0ZXIgPSBuYW1lc3BhY2VMb2NhbE5hbWVFbGVtZW50RmlsdGVyKG5zLCBsbmFtZSk7XG5cbiAgICByZXR1cm4gbmV3IEZpbHRlcmVkRWxlbWVudExpc3QodGhpcywgZmlsdGVyKTtcbiAgfX0sXG5cbiAgZ2V0RWxlbWVudHNCeUNsYXNzTmFtZTogeyB2YWx1ZTogZnVuY3Rpb24gZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShuYW1lcyl7XG4gICAgbmFtZXMgPSBTdHJpbmcobmFtZXMpLnRyaW0oKTtcbiAgICBpZiAobmFtZXMgPT09ICcnKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gbmV3IE5vZGVMaXN0KCk7IC8vIEVtcHR5IG5vZGUgbGlzdFxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgbmFtZXMgPSBuYW1lcy5zcGxpdCgvXFxzKy8pOyAgLy8gU3BsaXQgb24gc3BhY2VzXG4gICAgcmV0dXJuIG5ldyBGaWx0ZXJlZEVsZW1lbnRMaXN0KHRoaXMsIGNsYXNzTmFtZXNFbGVtZW50RmlsdGVyKG5hbWVzKSk7XG4gIH19LFxuXG4gIGdldEVsZW1lbnRzQnlOYW1lOiB7IHZhbHVlOiBmdW5jdGlvbiBnZXRFbGVtZW50c0J5TmFtZShuYW1lKSB7XG4gICAgcmV0dXJuIG5ldyBGaWx0ZXJlZEVsZW1lbnRMaXN0KHRoaXMsIGVsZW1lbnROYW1lRmlsdGVyKFN0cmluZyhuYW1lKSkpO1xuICB9fSxcblxuICAvLyBPdmVyd3JpdHRlbiBpbiB0aGUgY29uc3RydWN0b3IgaWYgbm90IGluIHRoZSBIVE1MIG5hbWVzcGFjZVxuICBpc0hUTUw6IHsgdmFsdWU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0sXG5cbiAgLy8gVXRpbGl0eSBtZXRob2RzIHVzZWQgYnkgdGhlIHB1YmxpYyBBUEkgbWV0aG9kcyBhYm92ZVxuICBjbG9uZTogeyB2YWx1ZTogZnVuY3Rpb24gY2xvbmUoKSB7XG4gICAgdmFyIGU7XG5cbiAgICAvLyBYWFg6XG4gICAgLy8gTW9kaWZ5IHRoaXMgdG8gdXNlIHRoZSBjb25zdHJ1Y3RvciBkaXJlY3RseSBvclxuICAgIC8vIGF2b2lkIGVycm9yIGNoZWNraW5nIGluIHNvbWUgb3RoZXIgd2F5LiBJbiBjYXNlIHdlIHRyeVxuICAgIC8vIHRvIGNsb25lIGFuIGludmFsaWQgbm9kZSB0aGF0IHRoZSBwYXJzZXIgaW5zZXJ0ZWQuXG4gICAgLy9cbiAgICBpZiAodGhpcy5uYW1lc3BhY2VVUkkgIT09IE5BTUVTUEFDRS5IVE1MIHx8IHRoaXMucHJlZml4KVxuICAgICAgZSA9IHRoaXMub3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50TlModGhpcy5uYW1lc3BhY2VVUkksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRhZ05hbWUpO1xuICAgIGVsc2VcbiAgICAgIGUgPSB0aGlzLm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0aGlzLmxvY2FsTmFtZSk7XG5cbiAgICBmb3IodmFyIGkgPSAwLCBuID0gdGhpcy5fYXR0cktleXMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICB2YXIgbG5hbWUgPSB0aGlzLl9hdHRyS2V5c1tpXTtcbiAgICAgIHZhciBhID0gdGhpcy5fYXR0cnNCeUxOYW1lW2xuYW1lXTtcbiAgICAgIHZhciBiID0gbmV3IEF0dHIoZSwgYS5sb2NhbE5hbWUsIGEucHJlZml4LCBhLm5hbWVzcGFjZVVSSSk7XG4gICAgICBiLmRhdGEgPSBhLmRhdGE7XG4gICAgICBlLl9hdHRyc0J5TE5hbWVbbG5hbWVdID0gYjtcbiAgICAgIGUuX2FkZFFOYW1lKGIpO1xuICAgIH1cbiAgICBlLl9hdHRyS2V5cyA9IHRoaXMuX2F0dHJLZXlzLmNvbmNhdCgpO1xuXG4gICAgcmV0dXJuIGU7XG4gIH19LFxuXG4gIGlzRXF1YWw6IHsgdmFsdWU6IGZ1bmN0aW9uIGlzRXF1YWwodGhhdCkge1xuICAgIGlmICh0aGlzLmxvY2FsTmFtZSAhPT0gdGhhdC5sb2NhbE5hbWUgfHxcbiAgICAgIHRoaXMubmFtZXNwYWNlVVJJICE9PSB0aGF0Lm5hbWVzcGFjZVVSSSB8fFxuICAgICAgdGhpcy5wcmVmaXggIT09IHRoYXQucHJlZml4IHx8XG4gICAgICB0aGlzLl9udW1hdHRycyAhPT0gdGhhdC5fbnVtYXR0cnMpXG4gICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICAvLyBDb21wYXJlIHRoZSBzZXRzIG9mIGF0dHJpYnV0ZXMsIGlnbm9yaW5nIG9yZGVyXG4gICAgLy8gYW5kIGlnbm9yaW5nIGF0dHJpYnV0ZSBwcmVmaXhlcy5cbiAgICBmb3IodmFyIGkgPSAwLCBuID0gdGhpcy5fbnVtYXR0cnM7IGkgPCBuOyBpKyspIHtcbiAgICAgIHZhciBhID0gdGhpcy5fYXR0cihpKTtcbiAgICAgIGlmICghdGhhdC5oYXNBdHRyaWJ1dGVOUyhhLm5hbWVzcGFjZVVSSSwgYS5sb2NhbE5hbWUpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICBpZiAodGhhdC5nZXRBdHRyaWJ1dGVOUyhhLm5hbWVzcGFjZVVSSSxhLmxvY2FsTmFtZSkgIT09IGEudmFsdWUpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfX0sXG5cbiAgLy8gVGhpcyBpcyB0aGUgJ2xvY2F0ZSBhIG5hbWVzcGFjZSBwcmVmaXgnIGFsZ29yaXRobSBmcm9tIHRoZVxuICAvLyBET01Db3JlIHNwZWNpZmljYXRpb24uICBJdCBpcyB1c2VkIGJ5IE5vZGUubG9va3VwUHJlZml4KClcbiAgbG9jYXRlTmFtZXNwYWNlUHJlZml4OiB7IHZhbHVlOiBmdW5jdGlvbiBsb2NhdGVOYW1lc3BhY2VQcmVmaXgobnMpIHtcbiAgICBpZiAodGhpcy5uYW1lc3BhY2VVUkkgPT09IG5zICYmIHRoaXMucHJlZml4ICE9PSBudWxsKVxuICAgICAgcmV0dXJuIHRoaXMucHJlZml4O1xuXG4gICAgZm9yKHZhciBpID0gMCwgbiA9IHRoaXMuX251bWF0dHJzOyBpIDwgbjsgaSsrKSB7XG4gICAgICB2YXIgYSA9IHRoaXMuX2F0dHIoaSk7XG4gICAgICBpZiAoYS5wcmVmaXggPT09ICd4bWxucycgJiYgYS52YWx1ZSA9PT0gbnMpXG4gICAgICAgIHJldHVybiBhLmxvY2FsTmFtZTtcbiAgICB9XG5cbiAgICB2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnRFbGVtZW50O1xuICAgIHJldHVybiBwYXJlbnQgPyBwYXJlbnQubG9jYXRlTmFtZXNwYWNlUHJlZml4KG5zKSA6IG51bGw7XG4gIH19LFxuXG4gIC8vIFRoaXMgaXMgdGhlICdsb2NhdGUgYSBuYW1lc3BhY2UnIGFsZ29yaXRobSBmb3IgRWxlbWVudCBub2Rlc1xuICAvLyBmcm9tIHRoZSBET00gQ29yZSBzcGVjLiAgSXQgaXMgdXNlZCBieSBOb2RlLmxvb2t1cE5hbWVzcGFjZVVSSVxuICBsb2NhdGVOYW1lc3BhY2U6IHsgdmFsdWU6IGZ1bmN0aW9uIGxvY2F0ZU5hbWVzcGFjZShwcmVmaXgpIHtcbiAgICBpZiAodGhpcy5wcmVmaXggPT09IHByZWZpeCAmJiB0aGlzLm5hbWVzcGFjZVVSSSAhPT0gbnVsbClcbiAgICAgIHJldHVybiB0aGlzLm5hbWVzcGFjZVVSSTtcblxuICAgIGZvcih2YXIgaSA9IDAsIG4gPSB0aGlzLl9udW1hdHRyczsgaSA8IG47IGkrKykge1xuICAgICAgdmFyIGEgPSB0aGlzLl9hdHRyKGkpO1xuICAgICAgaWYgKChhLnByZWZpeCA9PT0gJ3htbG5zJyAmJiBhLmxvY2FsTmFtZSA9PT0gcHJlZml4KSB8fFxuICAgICAgICAoYS5wcmVmaXggPT09IG51bGwgJiYgYS5sb2NhbE5hbWUgPT09ICd4bWxucycpKSB7XG4gICAgICAgIHJldHVybiBhLnZhbHVlIHx8IG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHBhcmVudCA9IHRoaXMucGFyZW50RWxlbWVudDtcbiAgICByZXR1cm4gcGFyZW50ID8gcGFyZW50LmxvY2F0ZU5hbWVzcGFjZShwcmVmaXgpIDogbnVsbDtcbiAgfX0sXG5cbiAgLy9cbiAgLy8gQXR0cmlidXRlIGhhbmRsaW5nIG1ldGhvZHMgYW5kIHV0aWxpdGllc1xuICAvL1xuXG4gIC8qXG4gICAqIEF0dHJpYnV0ZXMgaW4gdGhlIERPTSBhcmUgdHJpY2t5OlxuICAgKlxuICAgKiAtIHRoZXJlIGFyZSB0aGUgOCBiYXNpYyBnZXQvc2V0L2hhcy9yZW1vdmVBdHRyaWJ1dGV7TlN9IG1ldGhvZHNcbiAgICpcbiAgICogLSBidXQgbWFueSBIVE1MIGF0dHJpYnV0ZXMgYXJlIGFsc28gJ3JlZmxlY3RlZCcgdGhyb3VnaCBJRExcbiAgICogICBhdHRyaWJ1dGVzIHdoaWNoIG1lYW5zIHRoYXQgdGhleSBjYW4gYmUgcXVlcmllZCBhbmQgc2V0IHRocm91Z2hcbiAgICogICByZWd1bGFyIHByb3BlcnRpZXMgb2YgdGhlIGVsZW1lbnQuICBUaGVyZSBpcyBqdXN0IG9uZSBhdHRyaWJ1dGVcbiAgICogICB2YWx1ZSwgYnV0IHR3byB3YXlzIHRvIGdldCBhbmQgc2V0IGl0LlxuICAgKlxuICAgKiAtIERpZmZlcmVudCBIVE1MIGVsZW1lbnQgdHlwZXMgaGF2ZSBkaWZmZXJlbnQgc2V0cyBvZiByZWZsZWN0ZWRcbiAgICAgYXR0cmlidXRlcy5cbiAgICpcbiAgICogLSBhdHRyaWJ1dGVzIGNhbiBhbHNvIGJlIHF1ZXJpZWQgYW5kIHNldCB0aHJvdWdoIHRoZSAuYXR0cmlidXRlc1xuICAgKiAgIHByb3BlcnR5IG9mIGFuIGVsZW1lbnQuICBUaGlzIHByb3BlcnR5IGJlaGF2ZXMgbGlrZSBhbiBhcnJheSBvZlxuICAgKiAgIEF0dHIgb2JqZWN0cy4gIFRoZSB2YWx1ZSBwcm9wZXJ0eSBvZiBlYWNoIEF0dHIgaXMgd3JpdGVhYmxlLCBzb1xuICAgKiAgIHRoaXMgaXMgYSB0aGlyZCB3YXkgdG8gcmVhZCBhbmQgd3JpdGUgYXR0cmlidXRlcy5cbiAgICpcbiAgICogLSBmb3IgZWZmaWNpZW5jeSwgd2UgcmVhbGx5IHdhbnQgdG8gc3RvcmUgYXR0cmlidXRlcyBpbiBzb21lIGtpbmRcbiAgICogICBvZiBuYW1lLT5hdHRyIG1hcC4gIEJ1dCB0aGUgYXR0cmlidXRlc1tdIGFycmF5IGlzIGFuIGFycmF5LCBub3QgYVxuICAgKiAgIG1hcCwgd2hpY2ggaXMga2luZCBvZiB1bm5hdHVyYWwuXG4gICAqXG4gICAqIC0gV2hlbiB1c2luZyBuYW1lc3BhY2VzIGFuZCBwcmVmaXhlcywgYW5kIG1peGluZyB0aGUgTlMgbWV0aG9kc1xuICAgKiAgIHdpdGggdGhlIG5vbi1OUyBtZXRob2RzLCBpdCBpcyBhcHBhcmVudGx5IGFjdHVhbGx5IHBvc3NpYmxlIGZvclxuICAgKiAgIGFuIGF0dHJpYnV0ZXNbXSBhcnJheSB0byBoYXZlIG1vcmUgdGhhbiBvbmUgYXR0cmlidXRlIHdpdGggdGhlXG4gICAqICAgc2FtZSBxdWFsaWZpZWQgbmFtZS4gIEFuZCBjZXJ0YWluIG1ldGhvZHMgbXVzdCBvcGVyYXRlIG9uIG9ubHlcbiAgICogICB0aGUgZmlyc3QgYXR0cmlidXRlIHdpdGggc3VjaCBhIG5hbWUuICBTbyBmb3IgdGhlc2UgbWV0aG9kcywgYW5cbiAgICogICBpbmVmZmljaWVudCBhcnJheS1saWtlIGRhdGEgc3RydWN0dXJlIHdvdWxkIGJlIGVhc2llciB0b1xuICAgKiAgIGltcGxlbWVudC5cbiAgICpcbiAgICogLSBUaGUgYXR0cmlidXRlc1tdIGFycmF5IGlzIGxpdmUsIG5vdCBhIHNuYXBzaG90LCBzbyBjaGFuZ2VzIHRvIHRoZVxuICAgKiAgIGF0dHJpYnV0ZXMgbXVzdCBiZSBpbW1lZGlhdGVseSB2aXNpYmxlIHRocm91Z2ggZXhpc3RpbmcgYXJyYXlzLlxuICAgKlxuICAgKiAtIFdoZW4gYXR0cmlidXRlcyBhcmUgcXVlcmllZCBhbmQgc2V0IHRocm91Z2ggSURMIHByb3BlcnRpZXNcbiAgICogICAoaW5zdGVhZCBvZiB0aGUgZ2V0L3NldEF0dHJpYnV0ZXMoKSBtZXRob2Qgb3IgdGhlIGF0dHJpYnV0ZXNbXVxuICAgKiAgIGFycmF5KSB0aGV5IG1heSBiZSBzdWJqZWN0IHRvIHR5cGUgY29udmVyc2lvbnMsIFVSTFxuICAgKiAgIG5vcm1hbGl6YXRpb24sIGV0Yy4sIHNvIHNvbWUgZXh0cmEgcHJvY2Vzc2luZyBpcyByZXF1aXJlZCBpbiB0aGF0XG4gICAqICAgY2FzZS5cbiAgICpcbiAgICogLSBCdXQgYWNjZXNzIHRocm91Z2ggSURMIHByb3BlcnRpZXMgaXMgcHJvYmFibHkgdGhlIG1vc3QgY29tbW9uXG4gICAqICAgY2FzZSwgc28gd2UnZCBsaWtlIHRoYXQgdG8gYmUgYXMgZmFzdCBhcyBwb3NzaWJsZS5cbiAgICpcbiAgICogLSBXZSBjYW4ndCBqdXN0IHN0b3JlIGF0dHJpYnV0ZSB2YWx1ZXMgaW4gdGhlaXIgcGFyc2VkIGlkbCBmb3JtLFxuICAgKiAgIGJlY2F1c2Ugc2V0QXR0cmlidXRlKCkgaGFzIHRvIHJldHVybiB3aGF0ZXZlciBzdHJpbmcgaXMgcGFzc2VkIHRvXG4gICAqICAgZ2V0QXR0cmlidXRlIGV2ZW4gaWYgaXQgaXMgbm90IGEgbGVnYWwsIHBhcnNlYWJsZSB2YWx1ZS4gU29cbiAgICogICBhdHRyaWJ1dGUgdmFsdWVzIG11c3QgYmUgc3RvcmVkIGluIHVucGFyc2VkIHN0cmluZyBmb3JtLlxuICAgKlxuICAgKiAtIFdlIG5lZWQgdG8gYmUgYWJsZSB0byBzZW5kIGNoYW5nZSBub3RpZmljYXRpb25zIG9yIG11dGF0aW9uXG4gICAqICAgZXZlbnRzIG9mIHNvbWUgc29ydCB0byB0aGUgcmVuZGVyZXIgd2hlbmV2ZXIgYW4gYXR0cmlidXRlIHZhbHVlXG4gICAqICAgY2hhbmdlcywgcmVnYXJkbGVzcyBvZiB0aGUgd2F5IGluIHdoaWNoIGl0IGNoYW5nZXMuXG4gICAqXG4gICAqIC0gU29tZSBhdHRyaWJ1dGVzLCBzdWNoIGFzIGlkIGFuZCBjbGFzcyBhZmZlY3Qgb3RoZXIgcGFydHMgb2YgdGhlXG4gICAqICAgRE9NIEFQSSwgbGlrZSBnZXRFbGVtZW50QnlJZCBhbmQgZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSBhbmQgc29cbiAgICogICBmb3IgZWZmaWNpZW5jeSwgd2UgbmVlZCB0byBzcGVjaWFsbHkgdHJhY2sgY2hhbmdlcyB0byB0aGVzZVxuICAgKiAgIHNwZWNpYWwgYXR0cmlidXRlcy5cbiAgICpcbiAgICogLSBTb21lIGF0dHJpYnV0ZXMgbGlrZSBjbGFzcyBoYXZlIGRpZmZlcmVudCBuYW1lcyAoY2xhc3NOYW1lKSB3aGVuXG4gICAqICAgcmVmbGVjdGVkLlxuICAgKlxuICAgKiAtIEF0dHJpYnV0ZXMgd2hvc2UgbmFtZXMgYmVnaW4gd2l0aCB0aGUgc3RyaW5nICdkYXRhLScgYXJlIHRyZWF0ZWRcbiAgICAgc3BlY2lhbGx5LlxuICAgKlxuICAgKiAtIFJlZmxlY3RlZCBhdHRyaWJ1dGVzIHRoYXQgaGF2ZSBhIGJvb2xlYW4gdHlwZSBpbiBJREwgaGF2ZSBzcGVjaWFsXG4gICAqICAgYmVoYXZpb3I6IHNldHRpbmcgdGhlbSB0byBmYWxzZSAoaW4gSURMKSBpcyB0aGUgc2FtZSBhcyByZW1vdmluZ1xuICAgKiAgIHRoZW0gd2l0aCByZW1vdmVBdHRyaWJ1dGUoKVxuICAgKlxuICAgKiAtIG51bWVyaWMgYXR0cmlidXRlcyAobGlrZSBIVE1MRWxlbWVudC50YWJJbmRleCkgY2FuIGhhdmUgZGVmYXVsdFxuICAgKiAgIHZhbHVlcyB0aGF0IG11c3QgYmUgcmV0dXJuZWQgYnkgdGhlIGlkbCBnZXR0ZXIgZXZlbiBpZiB0aGVcbiAgICogICBjb250ZW50IGF0dHJpYnV0ZSBkb2VzIG5vdCBleGlzdC4gKFRoZSBkZWZhdWx0IHRhYkluZGV4IHZhbHVlXG4gICAqICAgYWN0dWFsbHkgdmFyaWVzIGJhc2VkIG9uIHRoZSB0eXBlIG9mIHRoZSBlbGVtZW50LCBzbyB0aGF0IGlzIGFcbiAgICogICB0cmlja3kgb25lKS5cbiAgICpcbiAgICogU2VlXG4gICAqIGh0dHA6Ly93d3cud2hhdHdnLm9yZy9zcGVjcy93ZWItYXBwcy9jdXJyZW50LXdvcmsvbXVsdGlwYWdlL3VybHMuaHRtbCNyZWZsZWN0XG4gICAqIGZvciBydWxlcyBvbiBob3cgYXR0cmlidXRlcyBhcmUgcmVmbGVjdGVkLlxuICAgKlxuICAgKi9cblxuICBnZXRBdHRyaWJ1dGU6IHsgdmFsdWU6IGZ1bmN0aW9uIGdldEF0dHJpYnV0ZShxbmFtZSkge1xuICAgIGlmICh0aGlzLmlzSFRNTCkgcW5hbWUgPSB1dGlscy50b0FTQ0lJTG93ZXJDYXNlKHFuYW1lKTtcbiAgICB2YXIgYXR0ciA9IHRoaXMuX2F0dHJzQnlRTmFtZVtxbmFtZV07XG4gICAgaWYgKCFhdHRyKSByZXR1cm4gbnVsbDtcblxuICAgIGlmIChBcnJheS5pc0FycmF5KGF0dHIpKSAgLy8gSWYgdGhlcmUgaXMgbW9yZSB0aGFuIG9uZVxuICAgICAgYXR0ciA9IGF0dHJbMF07ICAgICAgICAgLy8gdXNlIHRoZSBmaXJzdFxuXG4gICAgcmV0dXJuIGF0dHIudmFsdWU7XG4gIH19LFxuXG4gIGdldEF0dHJpYnV0ZU5TOiB7IHZhbHVlOiBmdW5jdGlvbiBnZXRBdHRyaWJ1dGVOUyhucywgbG5hbWUpIHtcbiAgICB2YXIgYXR0ciA9IHRoaXMuX2F0dHJzQnlMTmFtZVsobnMgPT09IG51bGwgPyAnJyA6IG5zKSArICd8JyArIGxuYW1lXTtcbiAgICByZXR1cm4gYXR0ciA/IGF0dHIudmFsdWUgOiBudWxsO1xuICB9fSxcblxuICBoYXNBdHRyaWJ1dGU6IHsgdmFsdWU6IGZ1bmN0aW9uIGhhc0F0dHJpYnV0ZShxbmFtZSkge1xuICAgIGlmICh0aGlzLmlzSFRNTCkgcW5hbWUgPSB1dGlscy50b0FTQ0lJTG93ZXJDYXNlKHFuYW1lKTtcbiAgICByZXR1cm4gdGhpcy5fYXR0cnNCeVFOYW1lW3FuYW1lXSAhPT0gdW5kZWZpbmVkO1xuICB9fSxcblxuICBoYXNBdHRyaWJ1dGVOUzogeyB2YWx1ZTogZnVuY3Rpb24gaGFzQXR0cmlidXRlTlMobnMsIGxuYW1lKSB7XG4gICAgdmFyIGtleSA9IChucyA9PT0gbnVsbCA/ICcnIDogbnMpICsgJ3wnICsgbG5hbWU7XG4gICAgcmV0dXJuIHRoaXMuX2F0dHJzQnlMTmFtZVtrZXldICE9PSB1bmRlZmluZWQ7XG4gIH19LFxuXG4gIC8vIFNldCB0aGUgYXR0cmlidXRlIHdpdGhvdXQgZXJyb3IgY2hlY2tpbmcuIFRoZSBwYXJzZXIgdXNlcyB0aGlzLlxuICBfc2V0QXR0cmlidXRlOiB7IHZhbHVlOiBmdW5jdGlvbiBfc2V0QXR0cmlidXRlKHFuYW1lLCB2YWx1ZSkge1xuICAgIC8vIFhYWDogdGhlIHNwZWMgc2F5cyB0aGF0IHRoaXMgbmV4dCBzZWFyY2ggc2hvdWxkIGJlIGRvbmVcbiAgICAvLyBvbiB0aGUgbG9jYWwgbmFtZSwgYnV0IEkgdGhpbmsgdGhhdCBpcyBhbiBlcnJvci5cbiAgICAvLyBlbWFpbCBwZW5kaW5nIG9uIHd3dy1kb20gYWJvdXQgaXQuXG4gICAgdmFyIGF0dHIgPSB0aGlzLl9hdHRyc0J5UU5hbWVbcW5hbWVdO1xuICAgIHZhciBpc25ldztcbiAgICBpZiAoIWF0dHIpIHtcbiAgICAgIGF0dHIgPSB0aGlzLl9uZXdhdHRyKHFuYW1lKTtcbiAgICAgIGlzbmV3ID0gdHJ1ZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShhdHRyKSkgYXR0ciA9IGF0dHJbMF07XG4gICAgfVxuXG4gICAgLy8gTm93IHNldCB0aGUgYXR0cmlidXRlIHZhbHVlIG9uIHRoZSBuZXcgb3IgZXhpc3RpbmcgQXR0ciBvYmplY3QuXG4gICAgLy8gVGhlIEF0dHIudmFsdWUgc2V0dGVyIG1ldGhvZCBoYW5kbGVzIG11dGF0aW9uIGV2ZW50cywgZXRjLlxuICAgIGF0dHIudmFsdWUgPSB2YWx1ZTtcbiAgICBpZiAodGhpcy5fYXR0cmlidXRlcykgdGhpcy5fYXR0cmlidXRlc1txbmFtZV0gPSBhdHRyO1xuICAgIGlmIChpc25ldyAmJiB0aGlzLl9uZXdhdHRyaG9vaykgdGhpcy5fbmV3YXR0cmhvb2socW5hbWUsIHZhbHVlKTtcbiAgfX0sXG5cbiAgLy8gQ2hlY2sgZm9yIGVycm9ycywgYW5kIHRoZW4gc2V0IHRoZSBhdHRyaWJ1dGVcbiAgc2V0QXR0cmlidXRlOiB7IHZhbHVlOiBmdW5jdGlvbiBzZXRBdHRyaWJ1dGUocW5hbWUsIHZhbHVlKSB7XG4gICAgaWYgKCF4bWwuaXNWYWxpZE5hbWUocW5hbWUpKSB1dGlscy5JbnZhbGlkQ2hhcmFjdGVyRXJyb3IoKTtcbiAgICBpZiAodGhpcy5pc0hUTUwpIHFuYW1lID0gdXRpbHMudG9BU0NJSUxvd2VyQ2FzZShxbmFtZSk7XG4gICAgaWYgKHFuYW1lLnN1YnN0cmluZygwLCA1KSA9PT0gJ3htbG5zJykgdXRpbHMuTmFtZXNwYWNlRXJyb3IoKTtcbiAgICB0aGlzLl9zZXRBdHRyaWJ1dGUocW5hbWUsIFN0cmluZyh2YWx1ZSkpO1xuICB9fSxcblxuXG4gIC8vIFRoZSB2ZXJzaW9uIHdpdGggbm8gZXJyb3IgY2hlY2tpbmcgdXNlZCBieSB0aGUgcGFyc2VyXG4gIF9zZXRBdHRyaWJ1dGVOUzogeyB2YWx1ZTogZnVuY3Rpb24gX3NldEF0dHJpYnV0ZU5TKG5zLCBxbmFtZSwgdmFsdWUpIHtcbiAgICB2YXIgcG9zID0gcW5hbWUuaW5kZXhPZignOicpLCBwcmVmaXgsIGxuYW1lO1xuICAgIGlmIChwb3MgPT09IC0xKSB7XG4gICAgICBwcmVmaXggPSBudWxsO1xuICAgICAgbG5hbWUgPSBxbmFtZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBwcmVmaXggPSBxbmFtZS5zdWJzdHJpbmcoMCwgcG9zKTtcbiAgICAgIGxuYW1lID0gcW5hbWUuc3Vic3RyaW5nKHBvcysxKTtcbiAgICB9XG5cbiAgICB2YXIga2V5ID0gKG5zID09PSBudWxsID8gJycgOiBucykgKyAnfCcgKyBsbmFtZTtcbiAgICBpZiAobnMgPT09ICcnKSBucyA9IG51bGw7XG5cbiAgICB2YXIgYXR0ciA9IHRoaXMuX2F0dHJzQnlMTmFtZVtrZXldO1xuICAgIHZhciBpc25ldztcbiAgICBpZiAoIWF0dHIpIHtcbiAgICAgIGF0dHIgPSBuZXcgQXR0cih0aGlzLCBsbmFtZSwgcHJlZml4LCBucyk7XG4gICAgICBpc25ldyA9IHRydWU7XG4gICAgICB0aGlzLl9hdHRyc0J5TE5hbWVba2V5XSA9IGF0dHI7XG4gICAgICB0aGlzLl9hdHRyS2V5cy5wdXNoKGtleSk7XG5cbiAgICAgIC8vIFdlIGFsc28gaGF2ZSB0byBtYWtlIHRoZSBhdHRyIHNlYXJjaGFibGUgYnkgcW5hbWUuXG4gICAgICAvLyBCdXQgd2UgaGF2ZSB0byBiZSBjYXJlZnVsIGJlY2F1c2UgdGhlcmUgbWF5IGFscmVhZHlcbiAgICAgIC8vIGJlIGFuIGF0dHIgd2l0aCB0aGlzIHFuYW1lLlxuICAgICAgdGhpcy5fYWRkUU5hbWUoYXR0cik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgLy8gQ2FsbGluZyBzZXRBdHRyaWJ1dGVOUygpIGNhbiBjaGFuZ2UgdGhlIHByZWZpeCBvZiBhblxuICAgICAgLy8gZXhpc3RpbmcgYXR0cmlidXRlIVxuICAgICAgaWYgKGF0dHIucHJlZml4ICE9PSBwcmVmaXgpIHtcbiAgICAgICAgLy8gVW5iaW5kIHRoZSBvbGQgcW5hbWVcbiAgICAgICAgdGhpcy5fcmVtb3ZlUU5hbWUoYXR0cik7XG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgcHJlZml4XG4gICAgICAgIGF0dHIucHJlZml4ID0gcHJlZml4O1xuICAgICAgICAvLyBCaW5kIHRoZSBuZXcgcW5hbWVcbiAgICAgICAgdGhpcy5fYWRkUU5hbWUoYXR0cik7XG5cbiAgICAgIH1cblxuICAgIH1cbiAgICBhdHRyLnZhbHVlID0gdmFsdWU7IC8vIEF1dG9tYXRpY2FsbHkgc2VuZHMgbXV0YXRpb24gZXZlbnRcbiAgICBpZiAoaXNuZXcgJiYgdGhpcy5fbmV3YXR0cmhvb2spIHRoaXMuX25ld2F0dHJob29rKHFuYW1lLCB2YWx1ZSk7XG4gIH19LFxuXG4gIC8vIERvIGVycm9yIGNoZWNraW5nIHRoZW4gY2FsbCBfc2V0QXR0cmlidXRlTlNcbiAgc2V0QXR0cmlidXRlTlM6IHsgdmFsdWU6IGZ1bmN0aW9uIHNldEF0dHJpYnV0ZU5TKG5zLCBxbmFtZSwgdmFsdWUpIHtcbiAgICBpZiAoIXhtbC5pc1ZhbGlkTmFtZShxbmFtZSkpIHV0aWxzLkludmFsaWRDaGFyYWN0ZXJFcnJvcigpO1xuICAgIGlmICgheG1sLmlzVmFsaWRRTmFtZShxbmFtZSkpIHV0aWxzLk5hbWVzcGFjZUVycm9yKCk7XG5cbiAgICB2YXIgcG9zID0gcW5hbWUuaW5kZXhPZignOicpO1xuICAgIHZhciBwcmVmaXggPSAocG9zID09PSAtMSkgPyBudWxsIDogcW5hbWUuc3Vic3RyaW5nKDAsIHBvcyk7XG4gICAgaWYgKG5zID09PSAnJykgbnMgPSBudWxsO1xuXG4gICAgaWYgKChwcmVmaXggIT09IG51bGwgJiYgbnMgPT09IG51bGwpIHx8XG4gICAgICAocHJlZml4ID09PSAneG1sJyAmJiBucyAhPT0gTkFNRVNQQUNFLlhNTCkgfHxcbiAgICAgICgocW5hbWUgPT09ICd4bWxucycgfHwgcHJlZml4ID09PSAneG1sbnMnKSAmJlxuICAgICAgIChucyAhPT0gTkFNRVNQQUNFLlhNTE5TKSkgfHxcbiAgICAgIChucyA9PT0gTkFNRVNQQUNFLlhNTE5TICYmXG4gICAgICAgIShxbmFtZSA9PT0gJ3htbG5zJyB8fCBwcmVmaXggPT09ICd4bWxucycpKSlcbiAgICAgIHV0aWxzLk5hbWVzcGFjZUVycm9yKCk7XG5cbiAgICB0aGlzLl9zZXRBdHRyaWJ1dGVOUyhucywgcW5hbWUsIFN0cmluZyh2YWx1ZSkpO1xuICB9fSxcblxuICByZW1vdmVBdHRyaWJ1dGU6IHsgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZUF0dHJpYnV0ZShxbmFtZSkge1xuICAgIGlmICh0aGlzLmlzSFRNTCkgcW5hbWUgPSB1dGlscy50b0FTQ0lJTG93ZXJDYXNlKHFuYW1lKTtcblxuICAgIHZhciBhdHRyID0gdGhpcy5fYXR0cnNCeVFOYW1lW3FuYW1lXTtcbiAgICBpZiAoIWF0dHIpIHJldHVybjtcblxuICAgIC8vIElmIHRoZXJlIGlzIG1vcmUgdGhhbiBvbmUgbWF0Y2ggZm9yIHRoaXMgcW5hbWVcbiAgICAvLyBzbyBkb24ndCBkZWxldGUgdGhlIHFuYW1lIG1hcHBpbmcsIGp1c3QgcmVtb3ZlIHRoZSBmaXJzdFxuICAgIC8vIGVsZW1lbnQgZnJvbSBpdC5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShhdHRyKSkge1xuICAgICAgaWYgKGF0dHIubGVuZ3RoID4gMikge1xuICAgICAgICBhdHRyID0gYXR0ci5zaGlmdCgpOyAgLy8gcmVtb3ZlIGl0IGZyb20gdGhlIGFycmF5XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhpcy5fYXR0cnNCeVFOYW1lW3FuYW1lXSA9IGF0dHJbMV07XG4gICAgICAgIGF0dHIgPSBhdHRyWzBdO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIC8vIG9ubHkgYSBzaW5nbGUgbWF0Y2gsIHNvIHJlbW92ZSB0aGUgcW5hbWUgbWFwcGluZ1xuICAgICAgdGhpcy5fYXR0cnNCeVFOYW1lW3FuYW1lXSA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICB2YXIgbnMgPSBhdHRyLm5hbWVzcGFjZVVSSTtcbiAgICAvLyBOb3cgYXR0ciBpcyB0aGUgcmVtb3ZlZCBhdHRyaWJ1dGUuICBGaWd1cmUgb3V0IGl0c1xuICAgIC8vIG5zK2xuYW1lIGtleSBhbmQgcmVtb3ZlIGl0IGZyb20gdGhlIG90aGVyIG1hcHBpbmcgYXMgd2VsbC5cbiAgICB2YXIga2V5ID0gKG5zID09PSBudWxsID8gJycgOiBucykgKyAnfCcgKyBhdHRyLmxvY2FsTmFtZTtcbiAgICB0aGlzLl9hdHRyc0J5TE5hbWVba2V5XSA9IHVuZGVmaW5lZDtcblxuICAgIHZhciBpID0gdGhpcy5fYXR0cktleXMuaW5kZXhPZihrZXkpO1xuICAgIHRoaXMuX2F0dHJLZXlzLnNwbGljZShpLCAxKTtcblxuICAgIGlmICh0aGlzLl9hdHRyaWJ1dGVzKVxuICAgICAgdGhpcy5fYXR0cmlidXRlc1txbmFtZV0gPSB1bmRlZmluZWQ7XG5cbiAgICAvLyBPbmNoYW5nZSBoYW5kbGVyIGZvciB0aGUgYXR0cmlidXRlXG4gICAgaWYgKGF0dHIub25jaGFuZ2UpXG4gICAgICBhdHRyLm9uY2hhbmdlKHRoaXMsIGF0dHIubG9jYWxOYW1lLCBhdHRyLnZhbHVlLCBudWxsKTtcblxuICAgIC8vIE11dGF0aW9uIGV2ZW50XG4gICAgaWYgKHRoaXMucm9vdGVkKSB0aGlzLm93bmVyRG9jdW1lbnQubXV0YXRlUmVtb3ZlQXR0cihhdHRyKTtcbiAgfX0sXG5cbiAgcmVtb3ZlQXR0cmlidXRlTlM6IHsgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZUF0dHJpYnV0ZU5TKG5zLCBsbmFtZSkge1xuICAgIHZhciBrZXkgPSAobnMgPT09IG51bGwgPyAnJyA6IG5zKSArICd8JyArIGxuYW1lO1xuICAgIHZhciBhdHRyID0gdGhpcy5fYXR0cnNCeUxOYW1lW2tleV07XG4gICAgaWYgKCFhdHRyKSByZXR1cm47XG5cbiAgICB0aGlzLl9hdHRyc0J5TE5hbWVba2V5XSA9IHVuZGVmaW5lZDtcblxuICAgIHZhciBpID0gdGhpcy5fYXR0cktleXMuaW5kZXhPZihrZXkpO1xuICAgIHRoaXMuX2F0dHJLZXlzLnNwbGljZShpLCAxKTtcblxuICAgIC8vIE5vdyBmaW5kIHRoZSBzYW1lIEF0dHIgb2JqZWN0IGluIHRoZSBxbmFtZSBtYXBwaW5nIGFuZCByZW1vdmUgaXRcbiAgICAvLyBCdXQgYmUgY2FyZWZ1bCBiZWNhdXNlIHRoZXJlIG1heSBiZSBtb3JlIHRoYW4gb25lIG1hdGNoLlxuICAgIHRoaXMuX3JlbW92ZVFOYW1lKGF0dHIpO1xuXG4gICAgLy8gT25jaGFuZ2UgaGFuZGxlciBmb3IgdGhlIGF0dHJpYnV0ZVxuICAgIGlmIChhdHRyLm9uY2hhbmdlKVxuICAgICAgYXR0ci5vbmNoYW5nZSh0aGlzLCBhdHRyLmxvY2FsTmFtZSwgYXR0ci52YWx1ZSwgbnVsbCk7XG4gICAgLy8gTXV0YXRpb24gZXZlbnRcbiAgICBpZiAodGhpcy5yb290ZWQpIHRoaXMub3duZXJEb2N1bWVudC5tdXRhdGVSZW1vdmVBdHRyKGF0dHIpO1xuICB9fSxcblxuICAvLyBUaGlzICdyYXcnIHZlcnNpb24gb2YgZ2V0QXR0cmlidXRlIGlzIHVzZWQgYnkgdGhlIGdldHRlciBmdW5jdGlvbnNcbiAgLy8gb2YgcmVmbGVjdGVkIGF0dHJpYnV0ZXMuIEl0IHNraXBzIHNvbWUgZXJyb3IgY2hlY2tpbmcgYW5kXG4gIC8vIG5hbWVzcGFjZSBzdGVwc1xuICBfZ2V0YXR0cjogeyB2YWx1ZTogZnVuY3Rpb24gX2dldGF0dHIocW5hbWUpIHtcbiAgICAvLyBBc3N1bWUgdGhhdCBxbmFtZSBpcyBhbHJlYWR5IGxvd2VyY2FzZWQsIHNvIGRvbid0IGRvIGl0IGhlcmUuXG4gICAgLy8gQWxzbyBkb24ndCBjaGVjayB3aGV0aGVyIGF0dHIgaXMgYW4gYXJyYXk6IGEgcW5hbWUgd2l0aCBub1xuICAgIC8vIHByZWZpeCB3aWxsIG5ldmVyIGhhdmUgdHdvIG1hdGNoaW5nIEF0dHIgb2JqZWN0cyAoYmVjYXVzZVxuICAgIC8vIHNldEF0dHJpYnV0ZU5TIGRvZXNuJ3QgYWxsb3cgYSBub24tbnVsbCBuYW1lc3BhY2Ugd2l0aCBhXG4gICAgLy8gbnVsbCBwcmVmaXguXG4gICAgdmFyIGF0dHIgPSB0aGlzLl9hdHRyc0J5UU5hbWVbcW5hbWVdO1xuICAgIHJldHVybiBhdHRyID8gYXR0ci52YWx1ZSA6IG51bGw7XG4gIH19LFxuXG4gIC8vIFRoZSByYXcgdmVyc2lvbiBvZiBzZXRBdHRyaWJ1dGUgZm9yIHJlZmxlY3RlZCBpZGwgYXR0cmlidXRlcy5cbiAgX3NldGF0dHI6IHsgdmFsdWU6IGZ1bmN0aW9uIF9zZXRhdHRyKHFuYW1lLCB2YWx1ZSkge1xuICAgIHZhciBhdHRyID0gdGhpcy5fYXR0cnNCeVFOYW1lW3FuYW1lXTtcbiAgICB2YXIgaXNuZXc7XG4gICAgaWYgKCFhdHRyKSB7XG4gICAgICBhdHRyID0gdGhpcy5fbmV3YXR0cihxbmFtZSk7XG4gICAgICBpc25ldyA9IHRydWU7XG4gICAgfVxuICAgIGF0dHIudmFsdWUgPSBTdHJpbmcodmFsdWUpO1xuICAgIGlmICh0aGlzLl9hdHRyaWJ1dGVzKSB0aGlzLl9hdHRyaWJ1dGVzW3FuYW1lXSA9IGF0dHI7XG4gICAgaWYgKGlzbmV3ICYmIHRoaXMuX25ld2F0dHJob29rKSB0aGlzLl9uZXdhdHRyaG9vayhxbmFtZSwgdmFsdWUpO1xuICB9fSxcblxuICAvLyBDcmVhdGUgYSBuZXcgQXR0ciBvYmplY3QsIGluc2VydCBpdCwgYW5kIHJldHVybiBpdC5cbiAgLy8gVXNlZCBieSBzZXRBdHRyaWJ1dGUoKSBhbmQgYnkgc2V0KClcbiAgX25ld2F0dHI6IHsgdmFsdWU6IGZ1bmN0aW9uIF9uZXdhdHRyKHFuYW1lKSB7XG4gICAgdmFyIGF0dHIgPSBuZXcgQXR0cih0aGlzLCBxbmFtZSwgbnVsbCwgbnVsbCk7XG4gICAgdmFyIGtleSA9ICd8JyArIHFuYW1lO1xuICAgIHRoaXMuX2F0dHJzQnlRTmFtZVtxbmFtZV0gPSBhdHRyO1xuICAgIHRoaXMuX2F0dHJzQnlMTmFtZVtrZXldID0gYXR0cjtcbiAgICB0aGlzLl9hdHRyS2V5cy5wdXNoKGtleSk7XG4gICAgcmV0dXJuIGF0dHI7XG4gIH19LFxuXG4gIC8vIEFkZCBhIHFuYW1lLT5BdHRyIG1hcHBpbmcgdG8gdGhlIF9hdHRyc0J5UU5hbWUgb2JqZWN0LCB0YWtpbmcgaW50b1xuICAvLyBhY2NvdW50IHRoYXQgdGhlcmUgbWF5IGJlIG1vcmUgdGhhbiBvbmUgYXR0ciBvYmplY3Qgd2l0aCB0aGVcbiAgLy8gc2FtZSBxbmFtZVxuICBfYWRkUU5hbWU6IHsgdmFsdWU6IGZ1bmN0aW9uKGF0dHIpIHtcbiAgICB2YXIgcW5hbWUgPSBhdHRyLm5hbWU7XG4gICAgdmFyIGV4aXN0aW5nID0gdGhpcy5fYXR0cnNCeVFOYW1lW3FuYW1lXTtcbiAgICBpZiAoIWV4aXN0aW5nKSB7XG4gICAgICB0aGlzLl9hdHRyc0J5UU5hbWVbcW5hbWVdID0gYXR0cjtcbiAgICB9XG4gICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShleGlzdGluZykpIHtcbiAgICAgIGV4aXN0aW5nLnB1c2goYXR0cik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhpcy5fYXR0cnNCeVFOYW1lW3FuYW1lXSA9IFtleGlzdGluZywgYXR0cl07XG4gICAgfVxuICAgIGlmICh0aGlzLl9hdHRyaWJ1dGVzKSB0aGlzLl9hdHRyaWJ1dGVzW3FuYW1lXSA9IGF0dHI7XG4gIH19LFxuXG4gIC8vIFJlbW92ZSBhIHFuYW1lLT5BdHRyIG1hcHBpbmcgdG8gdGhlIF9hdHRyc0J5UU5hbWUgb2JqZWN0LCB0YWtpbmcgaW50b1xuICAvLyBhY2NvdW50IHRoYXQgdGhlcmUgbWF5IGJlIG1vcmUgdGhhbiBvbmUgYXR0ciBvYmplY3Qgd2l0aCB0aGVcbiAgLy8gc2FtZSBxbmFtZVxuICBfcmVtb3ZlUU5hbWU6IHsgdmFsdWU6IGZ1bmN0aW9uKGF0dHIpIHtcbiAgICB2YXIgcW5hbWUgPSBhdHRyLm5hbWU7XG4gICAgdmFyIHRhcmdldCA9IHRoaXMuX2F0dHJzQnlRTmFtZVtxbmFtZV07XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheSh0YXJnZXQpKSB7XG4gICAgICB2YXIgaWR4ID0gdGFyZ2V0LmluZGV4T2YoYXR0cik7XG4gICAgICB1dGlscy5hc3NlcnQoaWR4ICE9PSAtMSk7IC8vIEl0IG11c3QgYmUgaGVyZSBzb21ld2hlcmVcbiAgICAgIGlmICh0YXJnZXQubGVuZ3RoID09PSAyKSB7XG4gICAgICAgIHRoaXMuX2F0dHJzQnlRTmFtZVtxbmFtZV0gPSB0YXJnZXRbMS1pZHhdO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRhcmdldC5zcGxpY2UoaWR4LCAxKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB1dGlscy5hc3NlcnQodGFyZ2V0ID09PSBhdHRyKTsgIC8vIElmIG9ubHkgb25lLCBpdCBtdXN0IG1hdGNoXG4gICAgICB0aGlzLl9hdHRyc0J5UU5hbWVbcW5hbWVdID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfX0sXG5cbiAgLy8gUmV0dXJuIHRoZSBudW1iZXIgb2YgYXR0cmlidXRlc1xuICBfbnVtYXR0cnM6IHsgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuX2F0dHJLZXlzLmxlbmd0aDsgfX0sXG4gIC8vIFJldHVybiB0aGUgbnRoIEF0dHIgb2JqZWN0XG4gIF9hdHRyOiB7IHZhbHVlOiBmdW5jdGlvbihuKSB7XG4gICAgcmV0dXJuIHRoaXMuX2F0dHJzQnlMTmFtZVt0aGlzLl9hdHRyS2V5c1tuXV07XG4gIH19LFxuXG4gIC8vIERlZmluZSBnZXR0ZXJzIGFuZCBzZXR0ZXJzIGZvciBhbiAnaWQnIHByb3BlcnR5IHRoYXQgcmVmbGVjdHNcbiAgLy8gdGhlIGNvbnRlbnQgYXR0cmlidXRlICdpZCcuXG4gIGlkOiBhdHRyaWJ1dGVzLnByb3BlcnR5KHtuYW1lOiAnaWQnfSksXG5cbiAgLy8gRGVmaW5lIGdldHRlcnMgYW5kIHNldHRlcnMgZm9yIGEgJ2NsYXNzTmFtZScgcHJvcGVydHkgdGhhdCByZWZsZWN0c1xuICAvLyB0aGUgY29udGVudCBhdHRyaWJ1dGUgJ2NsYXNzJy5cbiAgY2xhc3NOYW1lOiBhdHRyaWJ1dGVzLnByb3BlcnR5KHtuYW1lOiAnY2xhc3MnfSksXG5cbiAgY2xhc3NMaXN0OiB7IGdldDogZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIGlmICh0aGlzLl9jbGFzc0xpc3QpIHtcbiAgICAgIHJldHVybiB0aGlzLl9jbGFzc0xpc3Q7XG4gICAgfVxuICAgIHZhciBkdGxpc3QgPSBuZXcgRE9NVG9rZW5MaXN0KFxuICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBzZWxmLmNsYXNzTmFtZSB8fCBcIlwiO1xuICAgICAgfSxcbiAgICAgIGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgc2VsZi5jbGFzc05hbWUgPSB2O1xuICAgICAgfVxuICAgICk7XG4gICAgdGhpcy5fY2xhc3NMaXN0ID0gZHRsaXN0O1xuICAgIHJldHVybiBkdGxpc3Q7XG4gIH19LFxuXG4gIG1hdGNoZXM6IHsgdmFsdWU6IGZ1bmN0aW9uKHNlbGVjdG9yKSB7XG4gICAgcmV0dXJuIHNlbGVjdC5tYXRjaGVzKHRoaXMsIHNlbGVjdG9yKTtcbiAgfX0sXG5cbiAgY2xvc2VzdDogeyB2YWx1ZTogZnVuY3Rpb24oc2VsZWN0b3IpIHtcbiAgICB2YXIgZWwgPSB0aGlzO1xuICAgIHdoaWxlIChlbC5tYXRjaGVzICYmICFlbC5tYXRjaGVzKHNlbGVjdG9yKSkgZWwgPSBlbC5wYXJlbnROb2RlO1xuICAgIHJldHVybiBlbC5tYXRjaGVzID8gZWwgOiBudWxsO1xuICB9fSxcblxuICBxdWVyeVNlbGVjdG9yOiB7IHZhbHVlOiBmdW5jdGlvbihzZWxlY3Rvcikge1xuICAgIHJldHVybiBzZWxlY3Qoc2VsZWN0b3IsIHRoaXMpWzBdO1xuICB9fSxcblxuICBxdWVyeVNlbGVjdG9yQWxsOiB7IHZhbHVlOiBmdW5jdGlvbihzZWxlY3Rvcikge1xuICAgIHZhciBub2RlcyA9IHNlbGVjdChzZWxlY3RvciwgdGhpcyk7XG4gICAgcmV0dXJuIG5vZGVzLml0ZW0gPyBub2RlcyA6IG5ldyBOb2RlTGlzdChub2Rlcyk7XG4gIH19XG5cbn0pO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhFbGVtZW50LnByb3RvdHlwZSwgQ2hpbGROb2RlKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKEVsZW1lbnQucHJvdG90eXBlLCBOb25Eb2N1bWVudFR5cGVDaGlsZE5vZGUpO1xuXG4vLyBSZWdpc3RlciBzcGVjaWFsIGhhbmRsaW5nIGZvciB0aGUgaWQgYXR0cmlidXRlXG5hdHRyaWJ1dGVzLnJlZ2lzdGVyQ2hhbmdlSGFuZGxlcihFbGVtZW50LCAnaWQnLFxuIGZ1bmN0aW9uKGVsZW1lbnQsIGxuYW1lLCBvbGR2YWwsIG5ld3ZhbCkge1xuICAgaWYgKGVsZW1lbnQucm9vdGVkKSB7XG4gICAgIGlmIChvbGR2YWwpIHtcbiAgICAgICBlbGVtZW50Lm93bmVyRG9jdW1lbnQuZGVsSWQob2xkdmFsLCBlbGVtZW50KTtcbiAgICAgfVxuICAgICBpZiAobmV3dmFsKSB7XG4gICAgICAgZWxlbWVudC5vd25lckRvY3VtZW50LmFkZElkKG5ld3ZhbCwgZWxlbWVudCk7XG4gICAgIH1cbiAgIH1cbiB9XG4pO1xuXG5cbi8vIFRoZSBBdHRyIGNsYXNzIHJlcHJlc2VudHMgYSBzaW5nbGUgYXR0cmlidXRlLiAgVGhlIHZhbHVlcyBpblxuLy8gX2F0dHJzQnlRTmFtZSBhbmQgX2F0dHJzQnlMTmFtZSBhcmUgaW5zdGFuY2VzIG9mIHRoaXMgY2xhc3MuXG5mdW5jdGlvbiBBdHRyKGVsdCwgbG5hbWUsIHByZWZpeCwgbmFtZXNwYWNlKSB7XG4gIC8vIEFsd2F5cyByZW1lbWJlciB3aGF0IGVsZW1lbnQgd2UncmUgYXNzb2NpYXRlZCB3aXRoLlxuICAvLyBXZSBuZWVkIHRoaXMgdG8gcHJvcGVydHkgaGFuZGxlIG11dGF0aW9uc1xuICB0aGlzLm93bmVyRWxlbWVudCA9IGVsdDtcblxuICBpZiAoIW5hbWVzcGFjZSAmJiAhcHJlZml4ICYmIGVsdC5fYXR0cmlidXRlQ2hhbmdlSGFuZGxlcnNbbG5hbWVdKVxuICAgIHRoaXMub25jaGFuZ2UgPSBlbHQuX2F0dHJpYnV0ZUNoYW5nZUhhbmRsZXJzW2xuYW1lXTtcblxuICAvLyBsb2NhbE5hbWUgYW5kIG5hbWVzcGFjZSBhcmUgY29uc3RhbnQgZm9yIGFueSBhdHRyIG9iamVjdC5cbiAgLy8gQnV0IHZhbHVlIG1heSBjaGFuZ2UuICBBbmQgc28gY2FuIHByZWZpeCwgYW5kIHNvLCB0aGVyZWZvcmUgY2FuIG5hbWUuXG4gIHRoaXMubG9jYWxOYW1lID0gbG5hbWU7XG4gIHRoaXMucHJlZml4ID0gKHByZWZpeD09PW51bGwgfHwgcHJlZml4PT09JycpID8gbnVsbCA6ICgnJyArIHByZWZpeCk7XG4gIHRoaXMubmFtZXNwYWNlVVJJID0gKG5hbWVzcGFjZT09PW51bGwgfHwgbmFtZXNwYWNlPT09JycpID8gbnVsbCA6ICgnJyArIG5hbWVzcGFjZSk7XG59XG5cbkF0dHIucHJvdG90eXBlID0ge1xuICBnZXQgbmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5wcmVmaXggPyB0aGlzLnByZWZpeCArICc6JyArIHRoaXMubG9jYWxOYW1lIDogdGhpcy5sb2NhbE5hbWU7XG4gIH0sXG5cbiAgZ2V0IHZhbHVlKCkge1xuICAgIHJldHVybiB0aGlzLmRhdGE7XG4gIH0sXG5cbiAgZ2V0IHNwZWNpZmllZCgpIHtcbiAgICAvLyBEZXByZWNhdGVkXG4gICAgcmV0dXJuIHRydWU7XG4gIH0sXG5cbiAgc2V0IHZhbHVlKHZhbHVlKSB7XG4gICAgdmFyIG9sZHZhbCA9IHRoaXMuZGF0YTtcbiAgICB2YWx1ZSA9ICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSA/ICcnIDogdmFsdWUgKyAnJztcbiAgICBpZiAodmFsdWUgPT09IG9sZHZhbCkgcmV0dXJuO1xuXG4gICAgdGhpcy5kYXRhID0gdmFsdWU7XG5cbiAgICAvLyBSdW4gdGhlIG9uY2hhbmdlIGhvb2sgZm9yIHRoZSBhdHRyaWJ1dGVcbiAgICAvLyBpZiB0aGVyZSBpcyBvbmUuXG4gICAgaWYgKHRoaXMub25jaGFuZ2UpXG4gICAgICB0aGlzLm9uY2hhbmdlKHRoaXMub3duZXJFbGVtZW50LHRoaXMubG9jYWxOYW1lLCBvbGR2YWwsIHZhbHVlKTtcblxuICAgIC8vIEdlbmVyYXRlIGEgbXV0YXRpb24gZXZlbnQgaWYgdGhlIGVsZW1lbnQgaXMgcm9vdGVkXG4gICAgaWYgKHRoaXMub3duZXJFbGVtZW50LnJvb3RlZClcbiAgICAgIHRoaXMub3duZXJFbGVtZW50Lm93bmVyRG9jdW1lbnQubXV0YXRlQXR0cih0aGlzLCBvbGR2YWwpO1xuICB9LFxuXG4gIC8vIExlZ2FjeSBhbGlhc2VzIChzZWUgZ2gjNzAgYW5kIGh0dHBzOi8vZG9tLnNwZWMud2hhdHdnLm9yZy8jaW50ZXJmYWNlLWF0dHIpXG4gIGdldCBub2RlTmFtZSgpIHsgcmV0dXJuIHRoaXMubmFtZTsgfSxcbiAgZ2V0IG5vZGVWYWx1ZSgpIHsgcmV0dXJuIHRoaXMudmFsdWU7IH0sXG4gIGdldCB0ZXh0Q29udGVudCgpIHsgcmV0dXJuIHRoaXMudmFsdWU7IH0sXG4gIHNldCBub2RlVmFsdWUodikgeyB0aGlzLnZhbHVlID0gdjsgfSxcbiAgc2V0IHRleHRDb250ZW50KHYpIHsgdGhpcy52YWx1ZSA9IHY7IH0sXG59O1xuXG5cbi8vIFRoZSBhdHRyaWJ1dGVzIHByb3BlcnR5IG9mIGFuIEVsZW1lbnQgd2lsbCBiZSBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxuLy8gVGhpcyBjbGFzcyBpcyByZWFsbHkganVzdCBhIGR1bW15LCB0aG91Z2guIEl0IG9ubHkgZGVmaW5lcyBhIGxlbmd0aFxuLy8gcHJvcGVydHkgYW5kIGFuIGl0ZW0oKSBtZXRob2QuIFRoZSBBdHRyQXJyYXlQcm94eSB0aGF0XG4vLyBkZWZpbmVzIHRoZSBwdWJsaWMgQVBJIGp1c3QgdXNlcyB0aGUgRWxlbWVudCBvYmplY3QgaXRzZWxmLlxuZnVuY3Rpb24gQXR0cmlidXRlc0FycmF5KGVsdCkge1xuICB0aGlzLmVsZW1lbnQgPSBlbHQ7XG4gIGZvciAodmFyIG5hbWUgaW4gZWx0Ll9hdHRyc0J5UU5hbWUpIHtcbiAgICB0aGlzW25hbWVdID0gZWx0Ll9hdHRyc0J5UU5hbWVbbmFtZV07XG4gIH1cbn1cbkF0dHJpYnV0ZXNBcnJheS5wcm90b3R5cGUgPSB7XG4gIGdldCBsZW5ndGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuZWxlbWVudC5fYXR0cktleXMubGVuZ3RoO1xuICB9LFxuICBpdGVtOiBmdW5jdGlvbihuKSB7XG4gICAgcmV0dXJuIHRoaXMuZWxlbWVudC5fYXR0cnNCeUxOYW1lW3RoaXMuZWxlbWVudC5fYXR0cktleXNbbl1dO1xuICB9XG59O1xuXG5cbi8vIFRoZSBjaGlsZHJlbiBwcm9wZXJ0eSBvZiBhbiBFbGVtZW50IHdpbGwgYmUgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcy5cbi8vIEl0IGRlZmluZXMgbGVuZ3RoLCBpdGVtKCkgYW5kIG5hbWVkSXRlbSgpIGFuZCB3aWxsIGJlIHdyYXBwZWQgYnkgYW5cbi8vIEhUTUxDb2xsZWN0aW9uIHdoZW4gZXhwb3NlZCB0aHJvdWdoIHRoZSBET00uXG5mdW5jdGlvbiBDaGlsZHJlbkNvbGxlY3Rpb24oZSkge1xuICB0aGlzLmVsZW1lbnQgPSBlO1xuICB0aGlzLnVwZGF0ZUNhY2hlKCk7XG59XG5cbkNoaWxkcmVuQ29sbGVjdGlvbi5wcm90b3R5cGUgPSB7XG4gIGdldCBsZW5ndGgoKSB7XG4gICAgdGhpcy51cGRhdGVDYWNoZSgpO1xuICAgIHJldHVybiB0aGlzLmNoaWxkcmVuQnlOdW1iZXIubGVuZ3RoO1xuICB9LFxuICBpdGVtOiBmdW5jdGlvbiBpdGVtKG4pIHtcbiAgICB0aGlzLnVwZGF0ZUNhY2hlKCk7XG4gICAgcmV0dXJuIHRoaXMuY2hpbGRyZW5CeU51bWJlcltuXSB8fCBudWxsO1xuICB9LFxuXG4gIG5hbWVkSXRlbTogZnVuY3Rpb24gbmFtZWRJdGVtKG5hbWUpIHtcbiAgICB0aGlzLnVwZGF0ZUNhY2hlKCk7XG4gICAgcmV0dXJuIHRoaXMuY2hpbGRyZW5CeU5hbWVbbmFtZV0gfHwgbnVsbDtcbiAgfSxcblxuICAvLyBUaGlzIGF0dHJpYnV0ZSByZXR1cm5zIHRoZSBlbnRpcmUgbmFtZS0+ZWxlbWVudCBtYXAuXG4gIC8vIEl0IGlzIG5vdCBwYXJ0IG9mIHRoZSBIVE1MQ29sbGVjdGlvbiBBUEksIGJ1dCB3ZSBuZWVkIGl0IGluXG4gIC8vIHNyYy9IVE1MQ29sbGVjdGlvblByb3h5XG4gIGdldCBuYW1lZEl0ZW1zKCkge1xuICAgIHRoaXMudXBkYXRlQ2FjaGUoKTtcbiAgICByZXR1cm4gdGhpcy5jaGlsZHJlbkJ5TmFtZTtcbiAgfSxcblxuICB1cGRhdGVDYWNoZTogZnVuY3Rpb24gdXBkYXRlQ2FjaGUoKSB7XG4gICAgdmFyIG5hbWVkRWx0cyA9IC9eKGF8YXBwbGV0fGFyZWF8ZW1iZWR8Zm9ybXxmcmFtZXxmcmFtZXNldHxpZnJhbWV8aW1nfG9iamVjdCkkLztcbiAgICBpZiAodGhpcy5sYXN0TW9kVGltZSAhPT0gdGhpcy5lbGVtZW50Lmxhc3RNb2RUaW1lKSB7XG4gICAgICB0aGlzLmxhc3RNb2RUaW1lID0gdGhpcy5lbGVtZW50Lmxhc3RNb2RUaW1lO1xuXG4gICAgICB2YXIgbiA9IHRoaXMuY2hpbGRyZW5CeU51bWJlciAmJiB0aGlzLmNoaWxkcmVuQnlOdW1iZXIubGVuZ3RoIHx8IDA7XG4gICAgICBmb3IodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgIHRoaXNbaV0gPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY2hpbGRyZW5CeU51bWJlciA9IFtdO1xuICAgICAgdGhpcy5jaGlsZHJlbkJ5TmFtZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgICAgIGZvcihpID0gMCwgbiA9IHRoaXMuZWxlbWVudC5jaGlsZE5vZGVzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICB2YXIgYyA9IHRoaXMuZWxlbWVudC5jaGlsZE5vZGVzW2ldO1xuICAgICAgICBpZiAoYy5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUpIHtcblxuICAgICAgICAgIHRoaXNbdGhpcy5jaGlsZHJlbkJ5TnVtYmVyLmxlbmd0aF0gPSBjO1xuICAgICAgICAgIHRoaXMuY2hpbGRyZW5CeU51bWJlci5wdXNoKGMpO1xuXG4gICAgICAgICAgLy8gWFhYIEFyZSB0aGVyZSBhbnkgcmVxdWlyZW1lbnRzIGFib3V0IHRoZSBuYW1lc3BhY2VcbiAgICAgICAgICAvLyBvZiB0aGUgaWQgcHJvcGVydHk/XG4gICAgICAgICAgdmFyIGlkID0gYy5nZXRBdHRyaWJ1dGUoJ2lkJyk7XG5cbiAgICAgICAgICAvLyBJZiB0aGVyZSBpcyBhbiBpZCB0aGF0IGlzIG5vdCBhbHJlYWR5IGluIHVzZS4uLlxuICAgICAgICAgIGlmIChpZCAmJiAhdGhpcy5jaGlsZHJlbkJ5TmFtZVtpZF0pXG4gICAgICAgICAgICB0aGlzLmNoaWxkcmVuQnlOYW1lW2lkXSA9IGM7XG5cbiAgICAgICAgICAvLyBGb3IgY2VydGFpbiBIVE1MIGVsZW1lbnRzIHdlIGNoZWNrIHRoZSBuYW1lIGF0dHJpYnV0ZVxuICAgICAgICAgIHZhciBuYW1lID0gYy5nZXRBdHRyaWJ1dGUoJ25hbWUnKTtcbiAgICAgICAgICBpZiAobmFtZSAmJlxuICAgICAgICAgICAgdGhpcy5lbGVtZW50Lm5hbWVzcGFjZVVSSSA9PT0gTkFNRVNQQUNFLkhUTUwgJiZcbiAgICAgICAgICAgIG5hbWVkRWx0cy50ZXN0KHRoaXMuZWxlbWVudC5sb2NhbE5hbWUpICYmXG4gICAgICAgICAgICAhdGhpcy5jaGlsZHJlbkJ5TmFtZVtuYW1lXSlcbiAgICAgICAgICAgIHRoaXMuY2hpbGRyZW5CeU5hbWVbaWRdID0gYztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLy8gVGhlc2UgZnVuY3Rpb25zIHJldHVybiBwcmVkaWNhdGVzIGZvciBmaWx0ZXJpbmcgZWxlbWVudHMuXG4vLyBUaGV5J3JlIHVzZWQgYnkgdGhlIERvY3VtZW50IGFuZCBFbGVtZW50IGNsYXNzZXMgZm9yIG1ldGhvZHMgbGlrZVxuLy8gZ2V0RWxlbWVudHNCeVRhZ05hbWUgYW5kIGdldEVsZW1lbnRzQnlDbGFzc05hbWVcblxuZnVuY3Rpb24gbG9jYWxOYW1lRWxlbWVudEZpbHRlcihsbmFtZSkge1xuICByZXR1cm4gZnVuY3Rpb24oZSkgeyByZXR1cm4gZS5sb2NhbE5hbWUgPT09IGxuYW1lOyB9O1xufVxuXG5mdW5jdGlvbiBodG1sTG9jYWxOYW1lRWxlbWVudEZpbHRlcihsbmFtZSkge1xuICB2YXIgbGNsbmFtZSA9IHV0aWxzLnRvQVNDSUlMb3dlckNhc2UobG5hbWUpO1xuICBpZiAobGNsbmFtZSA9PT0gbG5hbWUpXG4gICAgcmV0dXJuIGxvY2FsTmFtZUVsZW1lbnRGaWx0ZXIobG5hbWUpO1xuXG4gIHJldHVybiBmdW5jdGlvbihlKSB7XG4gICAgcmV0dXJuIGUuaXNIVE1MID8gZS5sb2NhbE5hbWUgPT09IGxjbG5hbWUgOiBlLmxvY2FsTmFtZSA9PT0gbG5hbWU7XG4gIH07XG59XG5cbmZ1bmN0aW9uIG5hbWVzcGFjZUVsZW1lbnRGaWx0ZXIobnMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGUpIHsgcmV0dXJuIGUubmFtZXNwYWNlVVJJID09PSBuczsgfTtcbn1cblxuZnVuY3Rpb24gbmFtZXNwYWNlTG9jYWxOYW1lRWxlbWVudEZpbHRlcihucywgbG5hbWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGUpIHtcbiAgICByZXR1cm4gZS5uYW1lc3BhY2VVUkkgPT09IG5zICYmIGUubG9jYWxOYW1lID09PSBsbmFtZTtcbiAgfTtcbn1cblxuLy8gWFhYXG4vLyBPcHRpbWl6ZSB0aGlzIHdoZW4gSSBpbXBsZW1lbnQgY2xhc3NMaXN0LlxuZnVuY3Rpb24gY2xhc3NOYW1lc0VsZW1lbnRGaWx0ZXIobmFtZXMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGUpIHtcbiAgICB2YXIgY2xhc3NBdHRyID0gZS5nZXRBdHRyaWJ1dGUoJ2NsYXNzJyk7XG4gICAgaWYgKCFjbGFzc0F0dHIpIHJldHVybiBmYWxzZTtcbiAgICB2YXIgY2xhc3NlcyA9IGNsYXNzQXR0ci50cmltKCkuc3BsaXQoL1xccysvKTtcbiAgICByZXR1cm4gbmFtZXMuZXZlcnkoZnVuY3Rpb24obikge1xuICAgICAgcmV0dXJuIGNsYXNzZXMuaW5kZXhPZihuKSAhPT0gLTE7XG4gICAgfSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGVsZW1lbnROYW1lRmlsdGVyKG5hbWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGUpIHtcbiAgICByZXR1cm4gZS5nZXRBdHRyaWJ1dGUoJ25hbWUnKSA9PT0gbmFtZTtcbiAgfTtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2RvbWluby9saWIvRWxlbWVudC5qc1xuLy8gbW9kdWxlIGlkID0gOVxuLy8gbW9kdWxlIGNodW5rcyA9IDQiLCJtb2R1bGUuZXhwb3J0cyA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKDIpKSgzNzkpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGRlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9AYW5ndWxhci9yb3V0ZXIvYnVuZGxlcy9yb3V0ZXIudW1kLmpzIGZyb20gZGxsLXJlZmVyZW5jZSAuL3ZlbmRvclxuLy8gbW9kdWxlIGlkID0gMTBcbi8vIG1vZHVsZSBjaHVua3MgPSA0IiwiLyoqXG4gKiBAbGljZW5zZSBBbmd1bGFyIHY1LjAuMC1iZXRhLjdcbiAqIChjKSAyMDEwLTIwMTcgR29vZ2xlLCBJbmMuIGh0dHBzOi8vYW5ndWxhci5pby9cbiAqIExpY2Vuc2U6IE1JVFxuICovXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuXHR0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMsIHJlcXVpcmUoJ0Bhbmd1bGFyL2NvcmUnKSwgcmVxdWlyZSgncnhqcy9vYnNlcnZhYmxlL29mJyksIHJlcXVpcmUoJ3J4anMvb3BlcmF0b3IvY29uY2F0TWFwJyksIHJlcXVpcmUoJ3J4anMvb3BlcmF0b3IvZmlsdGVyJyksIHJlcXVpcmUoJ3J4anMvb3BlcmF0b3IvbWFwJyksIHJlcXVpcmUoJ3RzbGliJyksIHJlcXVpcmUoJ0Bhbmd1bGFyL2NvbW1vbicpLCByZXF1aXJlKCdyeGpzL09ic2VydmFibGUnKSkgOlxuXHR0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJywgJ0Bhbmd1bGFyL2NvcmUnLCAncnhqcy9vYnNlcnZhYmxlL29mJywgJ3J4anMvb3BlcmF0b3IvY29uY2F0TWFwJywgJ3J4anMvb3BlcmF0b3IvZmlsdGVyJywgJ3J4anMvb3BlcmF0b3IvbWFwJywgJ3RzbGliJywgJ0Bhbmd1bGFyL2NvbW1vbicsICdyeGpzL09ic2VydmFibGUnXSwgZmFjdG9yeSkgOlxuXHQoZmFjdG9yeSgoZ2xvYmFsLm5nID0gZ2xvYmFsLm5nIHx8IHt9LCBnbG9iYWwubmcuY29tbW9uID0gZ2xvYmFsLm5nLmNvbW1vbiB8fCB7fSwgZ2xvYmFsLm5nLmNvbW1vbi5odHRwID0ge30pLGdsb2JhbC5uZy5jb3JlLGdsb2JhbC5SeC5PYnNlcnZhYmxlLnByb3RvdHlwZSxnbG9iYWwuUnguT2JzZXJ2YWJsZS5wcm90b3R5cGUsZ2xvYmFsLlJ4Lk9ic2VydmFibGUucHJvdG90eXBlLGdsb2JhbC5SeC5PYnNlcnZhYmxlLnByb3RvdHlwZSxnbG9iYWwudHNsaWIsZ2xvYmFsLm5nLmNvbW1vbixnbG9iYWwuUngpKTtcbn0odGhpcywgKGZ1bmN0aW9uIChleHBvcnRzLF9hbmd1bGFyX2NvcmUscnhqc19vYnNlcnZhYmxlX29mLHJ4anNfb3BlcmF0b3JfY29uY2F0TWFwLHJ4anNfb3BlcmF0b3JfZmlsdGVyLHJ4anNfb3BlcmF0b3JfbWFwLHRzbGliLF9hbmd1bGFyX2NvbW1vbixyeGpzX09ic2VydmFibGUpIHsgJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEBsaWNlbnNlIEFuZ3VsYXIgdjUuMC4wLWJldGEuN1xuICogKGMpIDIwMTAtMjAxNyBHb29nbGUsIEluYy4gaHR0cHM6Ly9hbmd1bGFyLmlvL1xuICogTGljZW5zZTogTUlUXG4gKi9cbi8qKlxuICogQGZpbGVvdmVydmlldyBhZGRlZCBieSB0c2lja2xlXG4gKiBAc3VwcHJlc3Mge2NoZWNrVHlwZXN9IGNoZWNrZWQgYnkgdHNjXG4gKi9cbi8qKlxuICogVHJhbnNmb3JtcyBhbiBgSHR0cFJlcXVlc3RgIGludG8gYSBzdHJlYW0gb2YgYEh0dHBFdmVudGBzLCBvbmUgb2Ygd2hpY2ggd2lsbCBsaWtlbHkgYmUgYVxuICogYEh0dHBSZXNwb25zZWAuXG4gKlxuICogYEh0dHBIYW5kbGVyYCBpcyBpbmplY3RhYmxlLiBXaGVuIGluamVjdGVkLCB0aGUgaGFuZGxlciBpbnN0YW5jZSBkaXNwYXRjaGVzIHJlcXVlc3RzIHRvIHRoZVxuICogZmlyc3QgaW50ZXJjZXB0b3IgaW4gdGhlIGNoYWluLCB3aGljaCBkaXNwYXRjaGVzIHRvIHRoZSBzZWNvbmQsIGV0YywgZXZlbnR1YWxseSByZWFjaGluZyB0aGVcbiAqIGBIdHRwQmFja2VuZGAuXG4gKlxuICogSW4gYW4gYEh0dHBJbnRlcmNlcHRvcmAsIHRoZSBgSHR0cEhhbmRsZXJgIHBhcmFtZXRlciBpcyB0aGUgbmV4dCBpbnRlcmNlcHRvciBpbiB0aGUgY2hhaW4uXG4gKlxuICogXFxAc3RhYmxlXG4gKiBAYWJzdHJhY3RcbiAqL1xudmFyIEh0dHBIYW5kbGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBIdHRwSGFuZGxlcigpIHtcbiAgICB9XG4gICAgcmV0dXJuIEh0dHBIYW5kbGVyO1xufSgpKTtcbi8qKlxuICogQSBmaW5hbCBgSHR0cEhhbmRsZXJgIHdoaWNoIHdpbGwgZGlzcGF0Y2ggdGhlIHJlcXVlc3QgdmlhIGJyb3dzZXIgSFRUUCBBUElzIHRvIGEgYmFja2VuZC5cbiAqXG4gKiBJbnRlcmNlcHRvcnMgc2l0IGJldHdlZW4gdGhlIGBIdHRwQ2xpZW50YCBpbnRlcmZhY2UgYW5kIHRoZSBgSHR0cEJhY2tlbmRgLlxuICpcbiAqIFdoZW4gaW5qZWN0ZWQsIGBIdHRwQmFja2VuZGAgZGlzcGF0Y2hlcyByZXF1ZXN0cyBkaXJlY3RseSB0byB0aGUgYmFja2VuZCwgd2l0aG91dCBnb2luZ1xuICogdGhyb3VnaCB0aGUgaW50ZXJjZXB0b3IgY2hhaW4uXG4gKlxuICogXFxAc3RhYmxlXG4gKiBAYWJzdHJhY3RcbiAqL1xudmFyIEh0dHBCYWNrZW5kID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBIdHRwQmFja2VuZCgpIHtcbiAgICB9XG4gICAgcmV0dXJuIEh0dHBCYWNrZW5kO1xufSgpKTtcblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IGFkZGVkIGJ5IHRzaWNrbGVcbiAqIEBzdXBwcmVzcyB7Y2hlY2tUeXBlc30gY2hlY2tlZCBieSB0c2NcbiAqL1xuLyoqXG4gKiBAcmVjb3JkXG4gKi9cbi8qKlxuICogSW1tdXRhYmxlIHNldCBvZiBIdHRwIGhlYWRlcnMsIHdpdGggbGF6eSBwYXJzaW5nLlxuICogXFxAc3RhYmxlXG4gKi9cbnZhciBIdHRwSGVhZGVycyA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSHR0cEhlYWRlcnMoaGVhZGVycykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvKipcbiAgICAgICAgICogSW50ZXJuYWwgbWFwIG9mIGxvd2VyY2FzZWQgaGVhZGVyIG5hbWVzIHRvIHRoZSBub3JtYWxpemVkXG4gICAgICAgICAqIGZvcm0gb2YgdGhlIG5hbWUgKHRoZSBmb3JtIHNlZW4gZmlyc3QpLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5ub3JtYWxpemVkTmFtZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBRdWV1ZWQgdXBkYXRlcyB0byBiZSBtYXRlcmlhbGl6ZWQgdGhlIG5leHQgaW5pdGlhbGl6YXRpb24uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmxhenlVcGRhdGUgPSBudWxsO1xuICAgICAgICBpZiAoIWhlYWRlcnMpIHtcbiAgICAgICAgICAgIHRoaXMuaGVhZGVycyA9IG5ldyBNYXAoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgaGVhZGVycyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRoaXMubGF6eUluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuaGVhZGVycyA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgICAgICBoZWFkZXJzLnNwbGl0KCdcXG4nKS5mb3JFYWNoKGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGluZGV4ID0gbGluZS5pbmRleE9mKCc6Jyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5hbWVfMSA9IGxpbmUuc2xpY2UoMCwgaW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8ga2V5ID0gbmFtZV8xLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2YWx1ZSA9IGxpbmUuc2xpY2UoaW5kZXggKyAxKS50cmltKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5tYXliZVNldE5vcm1hbGl6ZWROYW1lKG5hbWVfMSwga2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5oZWFkZXJzLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLyoqIEB0eXBlIHs/fSAqLyAoKF90aGlzLmhlYWRlcnMuZ2V0KGtleSkpKS5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmhlYWRlcnMuc2V0KGtleSwgW3ZhbHVlXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmxhenlJbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLmhlYWRlcnMgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmtleXMoaGVhZGVycykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2YWx1ZXMgPSBoZWFkZXJzW25hbWVdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBrZXkgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWVzID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzID0gW3ZhbHVlc107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5oZWFkZXJzLnNldChrZXksIHZhbHVlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5tYXliZVNldE5vcm1hbGl6ZWROYW1lKG5hbWUsIGtleSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGZvciBleGlzdGVuY2Ugb2YgaGVhZGVyIGJ5IGdpdmVuIG5hbWUuXG4gICAgICovXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGZvciBleGlzdGVuY2Ugb2YgaGVhZGVyIGJ5IGdpdmVuIG5hbWUuXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBIdHRwSGVhZGVycy5wcm90b3R5cGUuaGFzID0gLyoqXG4gICAgICogQ2hlY2tzIGZvciBleGlzdGVuY2Ugb2YgaGVhZGVyIGJ5IGdpdmVuIG5hbWUuXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICB0aGlzLmluaXQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGVhZGVycy5oYXMobmFtZS50b0xvd2VyQ2FzZSgpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgZmlyc3QgaGVhZGVyIHRoYXQgbWF0Y2hlcyBnaXZlbiBuYW1lLlxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgZmlyc3QgaGVhZGVyIHRoYXQgbWF0Y2hlcyBnaXZlbiBuYW1lLlxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgSHR0cEhlYWRlcnMucHJvdG90eXBlLmdldCA9IC8qKlxuICAgICAqIFJldHVybnMgZmlyc3QgaGVhZGVyIHRoYXQgbWF0Y2hlcyBnaXZlbiBuYW1lLlxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgdGhpcy5pbml0KCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHZhbHVlcyA9IHRoaXMuaGVhZGVycy5nZXQobmFtZS50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgcmV0dXJuIHZhbHVlcyAmJiB2YWx1ZXMubGVuZ3RoID4gMCA/IHZhbHVlc1swXSA6IG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBuYW1lcyBvZiB0aGUgaGVhZGVyc1xuICAgICAqL1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG5hbWVzIG9mIHRoZSBoZWFkZXJzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBIdHRwSGVhZGVycy5wcm90b3R5cGUua2V5cyA9IC8qKlxuICAgICAqIFJldHVybnMgdGhlIG5hbWVzIG9mIHRoZSBoZWFkZXJzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaW5pdCgpO1xuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLm5vcm1hbGl6ZWROYW1lcy52YWx1ZXMoKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGxpc3Qgb2YgaGVhZGVyIHZhbHVlcyBmb3IgYSBnaXZlbiBuYW1lLlxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgbGlzdCBvZiBoZWFkZXIgdmFsdWVzIGZvciBhIGdpdmVuIG5hbWUuXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBIdHRwSGVhZGVycy5wcm90b3R5cGUuZ2V0QWxsID0gLyoqXG4gICAgICogUmV0dXJucyBsaXN0IG9mIGhlYWRlciB2YWx1ZXMgZm9yIGEgZ2l2ZW4gbmFtZS5cbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHRoaXMuaW5pdCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5oZWFkZXJzLmdldChuYW1lLnRvTG93ZXJDYXNlKCkpIHx8IG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBIdHRwSGVhZGVycy5wcm90b3R5cGUuYXBwZW5kID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsb25lKHsgbmFtZTogbmFtZSwgdmFsdWU6IHZhbHVlLCBvcDogJ2EnIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgSHR0cEhlYWRlcnMucHJvdG90eXBlLnNldCA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jbG9uZSh7IG5hbWU6IG5hbWUsIHZhbHVlOiB2YWx1ZSwgb3A6ICdzJyB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEBwYXJhbSB7Pz19IHZhbHVlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBIdHRwSGVhZGVycy5wcm90b3R5cGUuZGVsZXRlID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHBhcmFtIHs/PX0gdmFsdWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jbG9uZSh7IG5hbWU6IG5hbWUsIHZhbHVlOiB2YWx1ZSwgb3A6ICdkJyB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEBwYXJhbSB7P30gbGNOYW1lXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBIdHRwSGVhZGVycy5wcm90b3R5cGUubWF5YmVTZXROb3JtYWxpemVkTmFtZSA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEBwYXJhbSB7P30gbGNOYW1lXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAobmFtZSwgbGNOYW1lKSB7XG4gICAgICAgIGlmICghdGhpcy5ub3JtYWxpemVkTmFtZXMuaGFzKGxjTmFtZSkpIHtcbiAgICAgICAgICAgIHRoaXMubm9ybWFsaXplZE5hbWVzLnNldChsY05hbWUsIG5hbWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEh0dHBIZWFkZXJzLnByb3RvdHlwZS5pbml0ID0gLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICghIXRoaXMubGF6eUluaXQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmxhenlJbml0IGluc3RhbmNlb2YgSHR0cEhlYWRlcnMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvcHlGcm9tKHRoaXMubGF6eUluaXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sYXp5SW5pdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5sYXp5SW5pdCA9IG51bGw7XG4gICAgICAgICAgICBpZiAoISF0aGlzLmxhenlVcGRhdGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxhenlVcGRhdGUuZm9yRWFjaChmdW5jdGlvbiAodXBkYXRlKSB7IHJldHVybiBfdGhpcy5hcHBseVVwZGF0ZSh1cGRhdGUpOyB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLmxhenlVcGRhdGUgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG90aGVyXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBIdHRwSGVhZGVycy5wcm90b3R5cGUuY29weUZyb20gPSAvKipcbiAgICAgKiBAcGFyYW0gez99IG90aGVyXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAob3RoZXIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgb3RoZXIuaW5pdCgpO1xuICAgICAgICBBcnJheS5mcm9tKG90aGVyLmhlYWRlcnMua2V5cygpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIF90aGlzLmhlYWRlcnMuc2V0KGtleSwgLyoqIEB0eXBlIHs/fSAqLyAoKG90aGVyLmhlYWRlcnMuZ2V0KGtleSkpKSk7XG4gICAgICAgICAgICBfdGhpcy5ub3JtYWxpemVkTmFtZXMuc2V0KGtleSwgLyoqIEB0eXBlIHs/fSAqLyAoKG90aGVyLm5vcm1hbGl6ZWROYW1lcy5nZXQoa2V5KSkpKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHVwZGF0ZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgSHR0cEhlYWRlcnMucHJvdG90eXBlLmNsb25lID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSB1cGRhdGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uICh1cGRhdGUpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY2xvbmUgPSBuZXcgSHR0cEhlYWRlcnMoKTtcbiAgICAgICAgY2xvbmUubGF6eUluaXQgPVxuICAgICAgICAgICAgKCEhdGhpcy5sYXp5SW5pdCAmJiB0aGlzLmxhenlJbml0IGluc3RhbmNlb2YgSHR0cEhlYWRlcnMpID8gdGhpcy5sYXp5SW5pdCA6IHRoaXM7XG4gICAgICAgIGNsb25lLmxhenlVcGRhdGUgPSAodGhpcy5sYXp5VXBkYXRlIHx8IFtdKS5jb25jYXQoW3VwZGF0ZV0pO1xuICAgICAgICByZXR1cm4gY2xvbmU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHVwZGF0ZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgSHR0cEhlYWRlcnMucHJvdG90eXBlLmFwcGx5VXBkYXRlID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSB1cGRhdGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uICh1cGRhdGUpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8ga2V5ID0gdXBkYXRlLm5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgc3dpdGNoICh1cGRhdGUub3ApIHtcbiAgICAgICAgICAgIGNhc2UgJ2EnOlxuICAgICAgICAgICAgY2FzZSAncyc6XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmFsdWUgPSAvKiogQHR5cGUgez99ICovICgodXBkYXRlLnZhbHVlKSk7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBbdmFsdWVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5tYXliZVNldE5vcm1hbGl6ZWROYW1lKHVwZGF0ZS5uYW1lLCBrZXkpO1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGJhc2UgPSAodXBkYXRlLm9wID09PSAnYScgPyB0aGlzLmhlYWRlcnMuZ2V0KGtleSkgOiB1bmRlZmluZWQpIHx8IFtdO1xuICAgICAgICAgICAgICAgIGJhc2UucHVzaC5hcHBseShiYXNlLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5oZWFkZXJzLnNldChrZXksIGJhc2UpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnZCc6XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdG9EZWxldGVfMSA9IC8qKiBAdHlwZSB7P30gKi8gKHVwZGF0ZS52YWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKCF0b0RlbGV0ZV8xKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGVhZGVycy5kZWxldGUoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ub3JtYWxpemVkTmFtZXMuZGVsZXRlKGtleSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBleGlzdGluZyA9IHRoaXMuaGVhZGVycy5nZXQoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFleGlzdGluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nID0gZXhpc3RpbmcuZmlsdGVyKGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gdG9EZWxldGVfMS5pbmRleE9mKHZhbHVlKSA9PT0gLTE7IH0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXhpc3RpbmcubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhlYWRlcnMuZGVsZXRlKGtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5vcm1hbGl6ZWROYW1lcy5kZWxldGUoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGVhZGVycy5zZXQoa2V5LCBleGlzdGluZyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIFxcQGludGVybmFsXG4gICAgICogQHBhcmFtIHs/fSBmblxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgSHR0cEhlYWRlcnMucHJvdG90eXBlLmZvckVhY2ggPSAvKipcbiAgICAgKiBcXEBpbnRlcm5hbFxuICAgICAqIEBwYXJhbSB7P30gZm5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChmbikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLmluaXQoKTtcbiAgICAgICAgQXJyYXkuZnJvbSh0aGlzLm5vcm1hbGl6ZWROYW1lcy5rZXlzKCkpXG4gICAgICAgICAgICAuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBmbigvKiogQHR5cGUgez99ICovICgoX3RoaXMubm9ybWFsaXplZE5hbWVzLmdldChrZXkpKSksIC8qKiBAdHlwZSB7P30gKi8gKChfdGhpcy5oZWFkZXJzLmdldChrZXkpKSkpOyB9KTtcbiAgICB9O1xuICAgIHJldHVybiBIdHRwSGVhZGVycztcbn0oKSk7XG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBhZGRlZCBieSB0c2lja2xlXG4gKiBAc3VwcHJlc3Mge2NoZWNrVHlwZXN9IGNoZWNrZWQgYnkgdHNjXG4gKi9cbi8qKlxuICogQSBjb2RlYyBmb3IgZW5jb2RpbmcgYW5kIGRlY29kaW5nIHBhcmFtZXRlcnMgaW4gVVJMcy5cbiAqXG4gKiBVc2VkIGJ5IGBIdHRwUGFyYW1zYC5cbiAqXG4gKiBcXEBzdGFibGVcbiAqXG4gKiBAcmVjb3JkXG4gKi9cblxuLyoqXG4gKiBBIGBIdHRwUGFyYW1ldGVyQ29kZWNgIHRoYXQgdXNlcyBgZW5jb2RlVVJJQ29tcG9uZW50YCBhbmQgYGRlY29kZVVSSUNvbXBvbmVudGAgdG9cbiAqIHNlcmlhbGl6ZSBhbmQgcGFyc2UgVVJMIHBhcmFtZXRlciBrZXlzIGFuZCB2YWx1ZXMuXG4gKlxuICogXFxAc3RhYmxlXG4gKi9cbnZhciBIdHRwVXJsRW5jb2RpbmdDb2RlYyA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSHR0cFVybEVuY29kaW5nQ29kZWMoKSB7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30ga1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgSHR0cFVybEVuY29kaW5nQ29kZWMucHJvdG90eXBlLmVuY29kZUtleSA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30ga1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKGspIHsgcmV0dXJuIHN0YW5kYXJkRW5jb2Rpbmcoayk7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBIdHRwVXJsRW5jb2RpbmdDb2RlYy5wcm90b3R5cGUuZW5jb2RlVmFsdWUgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IHZcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGFuZGFyZEVuY29kaW5nKHYpOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30ga1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgSHR0cFVybEVuY29kaW5nQ29kZWMucHJvdG90eXBlLmRlY29kZUtleSA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30ga1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKGspIHsgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChrKTsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEh0dHBVcmxFbmNvZGluZ0NvZGVjLnByb3RvdHlwZS5kZWNvZGVWYWx1ZSA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gdlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKHYpIHsgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudCh2KTsgfTtcbiAgICByZXR1cm4gSHR0cFVybEVuY29kaW5nQ29kZWM7XG59KCkpO1xuLyoqXG4gKiBAcGFyYW0gez99IHJhd1BhcmFtc1xuICogQHBhcmFtIHs/fSBjb2RlY1xuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gcGFyYW1QYXJzZXIocmF3UGFyYW1zLCBjb2RlYykge1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIG1hcCQkMSA9IG5ldyBNYXAoKTtcbiAgICBpZiAocmF3UGFyYW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGFyYW1zID0gcmF3UGFyYW1zLnNwbGl0KCcmJyk7XG4gICAgICAgIHBhcmFtcy5mb3JFYWNoKGZ1bmN0aW9uIChwYXJhbSkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZXFJZHggPSBwYXJhbS5pbmRleE9mKCc9Jyk7XG4gICAgICAgICAgICB2YXIgX2EgPSBlcUlkeCA9PSAtMSA/XG4gICAgICAgICAgICAgICAgW2NvZGVjLmRlY29kZUtleShwYXJhbSksICcnXSA6XG4gICAgICAgICAgICAgICAgW2NvZGVjLmRlY29kZUtleShwYXJhbS5zbGljZSgwLCBlcUlkeCkpLCBjb2RlYy5kZWNvZGVWYWx1ZShwYXJhbS5zbGljZShlcUlkeCArIDEpKV0sIGtleSA9IF9hWzBdLCB2YWwgPSBfYVsxXTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGxpc3QgPSBtYXAkJDEuZ2V0KGtleSkgfHwgW107XG4gICAgICAgICAgICBsaXN0LnB1c2godmFsKTtcbiAgICAgICAgICAgIG1hcCQkMS5zZXQoa2V5LCBsaXN0KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBtYXAkJDE7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gdlxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gc3RhbmRhcmRFbmNvZGluZyh2KSB7XG4gICAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudCh2KVxuICAgICAgICAucmVwbGFjZSgvJTQwL2dpLCAnQCcpXG4gICAgICAgIC5yZXBsYWNlKC8lM0EvZ2ksICc6JylcbiAgICAgICAgLnJlcGxhY2UoLyUyNC9naSwgJyQnKVxuICAgICAgICAucmVwbGFjZSgvJTJDL2dpLCAnLCcpXG4gICAgICAgIC5yZXBsYWNlKC8lM0IvZ2ksICc7JylcbiAgICAgICAgLnJlcGxhY2UoLyUyQi9naSwgJysnKVxuICAgICAgICAucmVwbGFjZSgvJTNEL2dpLCAnPScpXG4gICAgICAgIC5yZXBsYWNlKC8lM0YvZ2ksICc/JylcbiAgICAgICAgLnJlcGxhY2UoLyUyRi9naSwgJy8nKTtcbn1cbi8qKlxuICogQW4gSFRUUCByZXF1ZXN0L3Jlc3BvbnNlIGJvZHkgdGhhdCByZXByZXNlbnRzIHNlcmlhbGl6ZWQgcGFyYW1ldGVycyxcbiAqIHBlciB0aGUgTUlNRSB0eXBlIGBhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRgLlxuICpcbiAqIFRoaXMgY2xhc3MgaXMgaW1tdXRhYmxlIC0gYWxsIG11dGF0aW9uIG9wZXJhdGlvbnMgcmV0dXJuIGEgbmV3IGluc3RhbmNlLlxuICpcbiAqIFxcQHN0YWJsZVxuICovXG52YXIgSHR0cFBhcmFtcyA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSHR0cFBhcmFtcyhvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMudXBkYXRlcyA9IG51bGw7XG4gICAgICAgIHRoaXMuY2xvbmVGcm9tID0gbnVsbDtcbiAgICAgICAgdGhpcy5lbmNvZGVyID0gb3B0aW9ucy5lbmNvZGVyIHx8IG5ldyBIdHRwVXJsRW5jb2RpbmdDb2RlYygpO1xuICAgICAgICBpZiAoISFvcHRpb25zLmZyb21TdHJpbmcpIHtcbiAgICAgICAgICAgIGlmICghIW9wdGlvbnMuZnJvbU9iamVjdCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBzcGVjaWZ5IGJvdGggZnJvbVN0cmluZyBhbmQgZnJvbU9iamVjdC5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm1hcCA9IHBhcmFtUGFyc2VyKG9wdGlvbnMuZnJvbVN0cmluZywgdGhpcy5lbmNvZGVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghIW9wdGlvbnMuZnJvbU9iamVjdCkge1xuICAgICAgICAgICAgdGhpcy5tYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhvcHRpb25zLmZyb21PYmplY3QpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHZhbHVlID0gKC8qKiBAdHlwZSB7P30gKi8gKG9wdGlvbnMuZnJvbU9iamVjdCkpW2tleV07IC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgICAgICAgICAoKF90aGlzLm1hcCkpLnNldChrZXksIEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWUgOiBbdmFsdWVdKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5tYXAgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrIHdoZXRoZXIgdGhlIGJvZHkgaGFzIG9uZSBvciBtb3JlIHZhbHVlcyBmb3IgdGhlIGdpdmVuIHBhcmFtZXRlciBuYW1lLlxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIENoZWNrIHdoZXRoZXIgdGhlIGJvZHkgaGFzIG9uZSBvciBtb3JlIHZhbHVlcyBmb3IgdGhlIGdpdmVuIHBhcmFtZXRlciBuYW1lLlxuICAgICAqIEBwYXJhbSB7P30gcGFyYW1cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEh0dHBQYXJhbXMucHJvdG90eXBlLmhhcyA9IC8qKlxuICAgICAqIENoZWNrIHdoZXRoZXIgdGhlIGJvZHkgaGFzIG9uZSBvciBtb3JlIHZhbHVlcyBmb3IgdGhlIGdpdmVuIHBhcmFtZXRlciBuYW1lLlxuICAgICAqIEBwYXJhbSB7P30gcGFyYW1cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChwYXJhbSkge1xuICAgICAgICB0aGlzLmluaXQoKTtcbiAgICAgICAgcmV0dXJuIC8qKiBAdHlwZSB7P30gKi8gKCh0aGlzLm1hcCkpLmhhcyhwYXJhbSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGZpcnN0IHZhbHVlIGZvciB0aGUgZ2l2ZW4gcGFyYW1ldGVyIG5hbWUsIG9yIGBudWxsYCBpZiBpdCdzIG5vdCBwcmVzZW50LlxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIEdldCB0aGUgZmlyc3QgdmFsdWUgZm9yIHRoZSBnaXZlbiBwYXJhbWV0ZXIgbmFtZSwgb3IgYG51bGxgIGlmIGl0J3Mgbm90IHByZXNlbnQuXG4gICAgICogQHBhcmFtIHs/fSBwYXJhbVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgSHR0cFBhcmFtcy5wcm90b3R5cGUuZ2V0ID0gLyoqXG4gICAgICogR2V0IHRoZSBmaXJzdCB2YWx1ZSBmb3IgdGhlIGdpdmVuIHBhcmFtZXRlciBuYW1lLCBvciBgbnVsbGAgaWYgaXQncyBub3QgcHJlc2VudC5cbiAgICAgKiBAcGFyYW0gez99IHBhcmFtXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAocGFyYW0pIHtcbiAgICAgICAgdGhpcy5pbml0KCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlcyA9IC8qKiBAdHlwZSB7P30gKi8gKCh0aGlzLm1hcCkpLmdldChwYXJhbSk7XG4gICAgICAgIHJldHVybiAhIXJlcyA/IHJlc1swXSA6IG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgYWxsIHZhbHVlcyBmb3IgdGhlIGdpdmVuIHBhcmFtZXRlciBuYW1lLCBvciBgbnVsbGAgaWYgaXQncyBub3QgcHJlc2VudC5cbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBHZXQgYWxsIHZhbHVlcyBmb3IgdGhlIGdpdmVuIHBhcmFtZXRlciBuYW1lLCBvciBgbnVsbGAgaWYgaXQncyBub3QgcHJlc2VudC5cbiAgICAgKiBAcGFyYW0gez99IHBhcmFtXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBIdHRwUGFyYW1zLnByb3RvdHlwZS5nZXRBbGwgPSAvKipcbiAgICAgKiBHZXQgYWxsIHZhbHVlcyBmb3IgdGhlIGdpdmVuIHBhcmFtZXRlciBuYW1lLCBvciBgbnVsbGAgaWYgaXQncyBub3QgcHJlc2VudC5cbiAgICAgKiBAcGFyYW0gez99IHBhcmFtXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAocGFyYW0pIHtcbiAgICAgICAgdGhpcy5pbml0KCk7XG4gICAgICAgIHJldHVybiAvKiogQHR5cGUgez99ICovICgodGhpcy5tYXApKS5nZXQocGFyYW0pIHx8IG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgYWxsIHRoZSBwYXJhbWV0ZXIgbmFtZXMgZm9yIHRoaXMgYm9keS5cbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBHZXQgYWxsIHRoZSBwYXJhbWV0ZXIgbmFtZXMgZm9yIHRoaXMgYm9keS5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEh0dHBQYXJhbXMucHJvdG90eXBlLmtleXMgPSAvKipcbiAgICAgKiBHZXQgYWxsIHRoZSBwYXJhbWV0ZXIgbmFtZXMgZm9yIHRoaXMgYm9keS5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5pbml0KCk7XG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKC8qKiBAdHlwZSB7P30gKi8gKCh0aGlzLm1hcCkpLmtleXMoKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3QgYSBuZXcgYm9keSB3aXRoIGFuIGFwcGVuZGVkIHZhbHVlIGZvciB0aGUgZ2l2ZW4gcGFyYW1ldGVyIG5hbWUuXG4gICAgICovXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0IGEgbmV3IGJvZHkgd2l0aCBhbiBhcHBlbmRlZCB2YWx1ZSBmb3IgdGhlIGdpdmVuIHBhcmFtZXRlciBuYW1lLlxuICAgICAqIEBwYXJhbSB7P30gcGFyYW1cbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBIdHRwUGFyYW1zLnByb3RvdHlwZS5hcHBlbmQgPSAvKipcbiAgICAgKiBDb25zdHJ1Y3QgYSBuZXcgYm9keSB3aXRoIGFuIGFwcGVuZGVkIHZhbHVlIGZvciB0aGUgZ2l2ZW4gcGFyYW1ldGVyIG5hbWUuXG4gICAgICogQHBhcmFtIHs/fSBwYXJhbVxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChwYXJhbSwgdmFsdWUpIHsgcmV0dXJuIHRoaXMuY2xvbmUoeyBwYXJhbTogcGFyYW0sIHZhbHVlOiB2YWx1ZSwgb3A6ICdhJyB9KTsgfTtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3QgYSBuZXcgYm9keSB3aXRoIGEgbmV3IHZhbHVlIGZvciB0aGUgZ2l2ZW4gcGFyYW1ldGVyIG5hbWUuXG4gICAgICovXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0IGEgbmV3IGJvZHkgd2l0aCBhIG5ldyB2YWx1ZSBmb3IgdGhlIGdpdmVuIHBhcmFtZXRlciBuYW1lLlxuICAgICAqIEBwYXJhbSB7P30gcGFyYW1cbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBIdHRwUGFyYW1zLnByb3RvdHlwZS5zZXQgPSAvKipcbiAgICAgKiBDb25zdHJ1Y3QgYSBuZXcgYm9keSB3aXRoIGEgbmV3IHZhbHVlIGZvciB0aGUgZ2l2ZW4gcGFyYW1ldGVyIG5hbWUuXG4gICAgICogQHBhcmFtIHs/fSBwYXJhbVxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChwYXJhbSwgdmFsdWUpIHsgcmV0dXJuIHRoaXMuY2xvbmUoeyBwYXJhbTogcGFyYW0sIHZhbHVlOiB2YWx1ZSwgb3A6ICdzJyB9KTsgfTtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3QgYSBuZXcgYm9keSB3aXRoIGVpdGhlciB0aGUgZ2l2ZW4gdmFsdWUgZm9yIHRoZSBnaXZlbiBwYXJhbWV0ZXJcbiAgICAgKiByZW1vdmVkLCBpZiBhIHZhbHVlIGlzIGdpdmVuLCBvciBhbGwgdmFsdWVzIGZvciB0aGUgZ2l2ZW4gcGFyYW1ldGVyIHJlbW92ZWRcbiAgICAgKiBpZiBub3QuXG4gICAgICovXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0IGEgbmV3IGJvZHkgd2l0aCBlaXRoZXIgdGhlIGdpdmVuIHZhbHVlIGZvciB0aGUgZ2l2ZW4gcGFyYW1ldGVyXG4gICAgICogcmVtb3ZlZCwgaWYgYSB2YWx1ZSBpcyBnaXZlbiwgb3IgYWxsIHZhbHVlcyBmb3IgdGhlIGdpdmVuIHBhcmFtZXRlciByZW1vdmVkXG4gICAgICogaWYgbm90LlxuICAgICAqIEBwYXJhbSB7P30gcGFyYW1cbiAgICAgKiBAcGFyYW0gez89fSB2YWx1ZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgSHR0cFBhcmFtcy5wcm90b3R5cGUuZGVsZXRlID0gLyoqXG4gICAgICogQ29uc3RydWN0IGEgbmV3IGJvZHkgd2l0aCBlaXRoZXIgdGhlIGdpdmVuIHZhbHVlIGZvciB0aGUgZ2l2ZW4gcGFyYW1ldGVyXG4gICAgICogcmVtb3ZlZCwgaWYgYSB2YWx1ZSBpcyBnaXZlbiwgb3IgYWxsIHZhbHVlcyBmb3IgdGhlIGdpdmVuIHBhcmFtZXRlciByZW1vdmVkXG4gICAgICogaWYgbm90LlxuICAgICAqIEBwYXJhbSB7P30gcGFyYW1cbiAgICAgKiBAcGFyYW0gez89fSB2YWx1ZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKHBhcmFtLCB2YWx1ZSkgeyByZXR1cm4gdGhpcy5jbG9uZSh7IHBhcmFtOiBwYXJhbSwgdmFsdWU6IHZhbHVlLCBvcDogJ2QnIH0pOyB9O1xuICAgIC8qKlxuICAgICAqIFNlcmlhbGl6ZSB0aGUgYm9keSB0byBhbiBlbmNvZGVkIHN0cmluZywgd2hlcmUga2V5LXZhbHVlIHBhaXJzIChzZXBhcmF0ZWQgYnkgYD1gKSBhcmVcbiAgICAgKiBzZXBhcmF0ZWQgYnkgYCZgcy5cbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBTZXJpYWxpemUgdGhlIGJvZHkgdG8gYW4gZW5jb2RlZCBzdHJpbmcsIHdoZXJlIGtleS12YWx1ZSBwYWlycyAoc2VwYXJhdGVkIGJ5IGA9YCkgYXJlXG4gICAgICogc2VwYXJhdGVkIGJ5IGAmYHMuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBIdHRwUGFyYW1zLnByb3RvdHlwZS50b1N0cmluZyA9IC8qKlxuICAgICAqIFNlcmlhbGl6ZSB0aGUgYm9keSB0byBhbiBlbmNvZGVkIHN0cmluZywgd2hlcmUga2V5LXZhbHVlIHBhaXJzIChzZXBhcmF0ZWQgYnkgYD1gKSBhcmVcbiAgICAgKiBzZXBhcmF0ZWQgYnkgYCZgcy5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5pbml0KCk7XG4gICAgICAgIHJldHVybiB0aGlzLmtleXMoKVxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlS2V5ID0gX3RoaXMuZW5jb2Rlci5lbmNvZGVLZXkoa2V5KTtcbiAgICAgICAgICAgIHJldHVybiAvKiogQHR5cGUgez99ICovICgoLyoqIEB0eXBlIHs/fSAqLyAoKF90aGlzLm1hcCkpLmdldChrZXkpKSkubWFwKGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gZUtleSArICc9JyArIF90aGlzLmVuY29kZXIuZW5jb2RlVmFsdWUodmFsdWUpOyB9KS5qb2luKCcmJyk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuam9pbignJicpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB1cGRhdGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEh0dHBQYXJhbXMucHJvdG90eXBlLmNsb25lID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSB1cGRhdGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uICh1cGRhdGUpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY2xvbmUgPSBuZXcgSHR0cFBhcmFtcyh7IGVuY29kZXI6IHRoaXMuZW5jb2RlciB9KTtcbiAgICAgICAgY2xvbmUuY2xvbmVGcm9tID0gdGhpcy5jbG9uZUZyb20gfHwgdGhpcztcbiAgICAgICAgY2xvbmUudXBkYXRlcyA9ICh0aGlzLnVwZGF0ZXMgfHwgW10pLmNvbmNhdChbdXBkYXRlXSk7XG4gICAgICAgIHJldHVybiBjbG9uZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgSHR0cFBhcmFtcy5wcm90b3R5cGUuaW5pdCA9IC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5tYXAgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMubWFwID0gbmV3IE1hcCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNsb25lRnJvbSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5jbG9uZUZyb20uaW5pdCgpO1xuICAgICAgICAgICAgdGhpcy5jbG9uZUZyb20ua2V5cygpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gLyoqIEB0eXBlIHs/fSAqLyAoKF90aGlzLm1hcCkpLnNldChrZXksIC8qKiBAdHlwZSB7P30gKi8gKCgvKiogQHR5cGUgez99ICovICgoLyoqIEB0eXBlIHs/fSAqLyAoKF90aGlzLmNsb25lRnJvbSkpLm1hcCkpLmdldChrZXkpKSkpOyB9KTsgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICAgICAgKCh0aGlzLnVwZGF0ZXMpKS5mb3JFYWNoKGZ1bmN0aW9uICh1cGRhdGUpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHVwZGF0ZS5vcCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdhJzpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAncyc6XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBiYXNlID0gKHVwZGF0ZS5vcCA9PT0gJ2EnID8gLyoqIEB0eXBlIHs/fSAqLyAoKF90aGlzLm1hcCkpLmdldCh1cGRhdGUucGFyYW0pIDogdW5kZWZpbmVkKSB8fCBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhc2UucHVzaCgvKiogQHR5cGUgez99ICovICgodXBkYXRlLnZhbHVlKSkpOyAvKiogQHR5cGUgez99ICovXG4gICAgICAgICAgICAgICAgICAgICAgICAoKF90aGlzLm1hcCkpLnNldCh1cGRhdGUucGFyYW0sIGJhc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2QnOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHVwZGF0ZS52YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYmFzZV8xID0gLyoqIEB0eXBlIHs/fSAqLyAoKF90aGlzLm1hcCkpLmdldCh1cGRhdGUucGFyYW0pIHx8IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGlkeCA9IGJhc2VfMS5pbmRleE9mKHVwZGF0ZS52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlkeCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmFzZV8xLnNwbGljZShpZHgsIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYmFzZV8xLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyoqIEB0eXBlIHs/fSAqLyAoKF90aGlzLm1hcCkpLnNldCh1cGRhdGUucGFyYW0sIGJhc2VfMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiogQHR5cGUgez99ICovICgoX3RoaXMubWFwKSkuZGVsZXRlKHVwZGF0ZS5wYXJhbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLyoqIEB0eXBlIHs/fSAqLyAoKF90aGlzLm1hcCkpLmRlbGV0ZSh1cGRhdGUucGFyYW0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5jbG9uZUZyb20gPSBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gSHR0cFBhcmFtcztcbn0oKSk7XG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBhZGRlZCBieSB0c2lja2xlXG4gKiBAc3VwcHJlc3Mge2NoZWNrVHlwZXN9IGNoZWNrZWQgYnkgdHNjXG4gKi9cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8qKlxuICogRGV0ZXJtaW5lIHdoZXRoZXIgdGhlIGdpdmVuIEhUVFAgbWV0aG9kIG1heSBpbmNsdWRlIGEgYm9keS5cbiAqIEBwYXJhbSB7P30gbWV0aG9kXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBtaWdodEhhdmVCb2R5KG1ldGhvZCkge1xuICAgIHN3aXRjaCAobWV0aG9kKSB7XG4gICAgICAgIGNhc2UgJ0RFTEVURSc6XG4gICAgICAgIGNhc2UgJ0dFVCc6XG4gICAgICAgIGNhc2UgJ0hFQUQnOlxuICAgICAgICBjYXNlICdPUFRJT05TJzpcbiAgICAgICAgY2FzZSAnSlNPTlAnOlxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufVxuLyoqXG4gKiBTYWZlbHkgYXNzZXJ0IHdoZXRoZXIgdGhlIGdpdmVuIHZhbHVlIGlzIGFuIEFycmF5QnVmZmVyLlxuICpcbiAqIEluIHNvbWUgZXhlY3V0aW9uIGVudmlyb25tZW50cyBBcnJheUJ1ZmZlciBpcyBub3QgZGVmaW5lZC5cbiAqIEBwYXJhbSB7P30gdmFsdWVcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXlCdWZmZXIodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiB2YWx1ZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyO1xufVxuLyoqXG4gKiBTYWZlbHkgYXNzZXJ0IHdoZXRoZXIgdGhlIGdpdmVuIHZhbHVlIGlzIGEgQmxvYi5cbiAqXG4gKiBJbiBzb21lIGV4ZWN1dGlvbiBlbnZpcm9ubWVudHMgQmxvYiBpcyBub3QgZGVmaW5lZC5cbiAqIEBwYXJhbSB7P30gdmFsdWVcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGlzQmxvYih2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgQmxvYiAhPT0gJ3VuZGVmaW5lZCcgJiYgdmFsdWUgaW5zdGFuY2VvZiBCbG9iO1xufVxuLyoqXG4gKiBTYWZlbHkgYXNzZXJ0IHdoZXRoZXIgdGhlIGdpdmVuIHZhbHVlIGlzIGEgRm9ybURhdGEgaW5zdGFuY2UuXG4gKlxuICogSW4gc29tZSBleGVjdXRpb24gZW52aXJvbm1lbnRzIEZvcm1EYXRhIGlzIG5vdCBkZWZpbmVkLlxuICogQHBhcmFtIHs/fSB2YWx1ZVxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gaXNGb3JtRGF0YSh2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgRm9ybURhdGEgIT09ICd1bmRlZmluZWQnICYmIHZhbHVlIGluc3RhbmNlb2YgRm9ybURhdGE7XG59XG4vKipcbiAqIEFuIG91dGdvaW5nIEhUVFAgcmVxdWVzdCB3aXRoIGFuIG9wdGlvbmFsIHR5cGVkIGJvZHkuXG4gKlxuICogYEh0dHBSZXF1ZXN0YCByZXByZXNlbnRzIGFuIG91dGdvaW5nIHJlcXVlc3QsIGluY2x1ZGluZyBVUkwsIG1ldGhvZCxcbiAqIGhlYWRlcnMsIGJvZHksIGFuZCBvdGhlciByZXF1ZXN0IGNvbmZpZ3VyYXRpb24gb3B0aW9ucy4gSW5zdGFuY2VzIHNob3VsZCBiZVxuICogYXNzdW1lZCB0byBiZSBpbW11dGFibGUuIFRvIG1vZGlmeSBhIGBIdHRwUmVxdWVzdGAsIHRoZSBgY2xvbmVgXG4gKiBtZXRob2Qgc2hvdWxkIGJlIHVzZWQuXG4gKlxuICogXFxAc3RhYmxlXG4gKi9cbnZhciBIdHRwUmVxdWVzdCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSHR0cFJlcXVlc3QobWV0aG9kLCB1cmwsIHRoaXJkLCBmb3VydGgpIHtcbiAgICAgICAgdGhpcy51cmwgPSB1cmw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgcmVxdWVzdCBib2R5LCBvciBgbnVsbGAgaWYgb25lIGlzbid0IHNldC5cbiAgICAgICAgICpcbiAgICAgICAgICogQm9kaWVzIGFyZSBub3QgZW5mb3JjZWQgdG8gYmUgaW1tdXRhYmxlLCBhcyB0aGV5IGNhbiBpbmNsdWRlIGEgcmVmZXJlbmNlIHRvIGFueVxuICAgICAgICAgKiB1c2VyLWRlZmluZWQgZGF0YSB0eXBlLiBIb3dldmVyLCBpbnRlcmNlcHRvcnMgc2hvdWxkIHRha2UgY2FyZSB0byBwcmVzZXJ2ZVxuICAgICAgICAgKiBpZGVtcG90ZW5jZSBieSB0cmVhdGluZyB0aGVtIGFzIHN1Y2guXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmJvZHkgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciB0aGlzIHJlcXVlc3Qgc2hvdWxkIGJlIG1hZGUgaW4gYSB3YXkgdGhhdCBleHBvc2VzIHByb2dyZXNzIGV2ZW50cy5cbiAgICAgICAgICpcbiAgICAgICAgICogUHJvZ3Jlc3MgZXZlbnRzIGFyZSBleHBlbnNpdmUgKGNoYW5nZSBkZXRlY3Rpb24gcnVucyBvbiBlYWNoIGV2ZW50KSBhbmQgc29cbiAgICAgICAgICogdGhleSBzaG91bGQgb25seSBiZSByZXF1ZXN0ZWQgaWYgdGhlIGNvbnN1bWVyIGludGVuZHMgdG8gbW9uaXRvciB0aGVtLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yZXBvcnRQcm9ncmVzcyA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciB0aGlzIHJlcXVlc3Qgc2hvdWxkIGJlIHNlbnQgd2l0aCBvdXRnb2luZyBjcmVkZW50aWFscyAoY29va2llcykuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLndpdGhDcmVkZW50aWFscyA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGV4cGVjdGVkIHJlc3BvbnNlIHR5cGUgb2YgdGhlIHNlcnZlci5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhpcyBpcyB1c2VkIHRvIHBhcnNlIHRoZSByZXNwb25zZSBhcHByb3ByaWF0ZWx5IGJlZm9yZSByZXR1cm5pbmcgaXQgdG9cbiAgICAgICAgICogdGhlIHJlcXVlc3RlZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmVzcG9uc2VUeXBlID0gJ2pzb24nO1xuICAgICAgICB0aGlzLm1ldGhvZCA9IG1ldGhvZC50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAvLyBOZXh0LCBuZWVkIHRvIGZpZ3VyZSBvdXQgd2hpY2ggYXJndW1lbnQgaG9sZHMgdGhlIEh0dHBSZXF1ZXN0SW5pdFxuICAgICAgICAvLyBvcHRpb25zLCBpZiBhbnkuXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG9wdGlvbnM7XG4gICAgICAgIC8vIENoZWNrIHdoZXRoZXIgYSBib2R5IGFyZ3VtZW50IGlzIGV4cGVjdGVkLiBUaGUgb25seSB2YWxpZCB3YXkgdG8gb21pdFxuICAgICAgICAvLyB0aGUgYm9keSBhcmd1bWVudCBpcyB0byB1c2UgYSBrbm93biBuby1ib2R5IG1ldGhvZCBsaWtlIEdFVC5cbiAgICAgICAgaWYgKG1pZ2h0SGF2ZUJvZHkodGhpcy5tZXRob2QpIHx8ICEhZm91cnRoKSB7XG4gICAgICAgICAgICAvLyBCb2R5IGlzIHRoZSB0aGlyZCBhcmd1bWVudCwgb3B0aW9ucyBhcmUgdGhlIGZvdXJ0aC5cbiAgICAgICAgICAgIHRoaXMuYm9keSA9IC8qKiBAdHlwZSB7P30gKi8gKHRoaXJkKSB8fCBudWxsO1xuICAgICAgICAgICAgb3B0aW9ucyA9IGZvdXJ0aDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIE5vIGJvZHkgcmVxdWlyZWQsIG9wdGlvbnMgYXJlIHRoZSB0aGlyZCBhcmd1bWVudC4gVGhlIGJvZHkgc3RheXMgbnVsbC5cbiAgICAgICAgICAgIG9wdGlvbnMgPSAvKiogQHR5cGUgez99ICovICh0aGlyZCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgb3B0aW9ucyBoYXZlIGJlZW4gcGFzc2VkLCBpbnRlcnByZXQgdGhlbS5cbiAgICAgICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIC8vIE5vcm1hbGl6ZSByZXBvcnRQcm9ncmVzcyBhbmQgd2l0aENyZWRlbnRpYWxzLlxuICAgICAgICAgICAgdGhpcy5yZXBvcnRQcm9ncmVzcyA9ICEhb3B0aW9ucy5yZXBvcnRQcm9ncmVzcztcbiAgICAgICAgICAgIHRoaXMud2l0aENyZWRlbnRpYWxzID0gISFvcHRpb25zLndpdGhDcmVkZW50aWFscztcbiAgICAgICAgICAgIC8vIE92ZXJyaWRlIGRlZmF1bHQgcmVzcG9uc2UgdHlwZSBvZiAnanNvbicgaWYgb25lIGlzIHByb3ZpZGVkLlxuICAgICAgICAgICAgaWYgKCEhb3B0aW9ucy5yZXNwb25zZVR5cGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc3BvbnNlVHlwZSA9IG9wdGlvbnMucmVzcG9uc2VUeXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gT3ZlcnJpZGUgaGVhZGVycyBpZiB0aGV5J3JlIHByb3ZpZGVkLlxuICAgICAgICAgICAgaWYgKCEhb3B0aW9ucy5oZWFkZXJzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5oZWFkZXJzID0gb3B0aW9ucy5oZWFkZXJzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCEhb3B0aW9ucy5wYXJhbXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmFtcyA9IG9wdGlvbnMucGFyYW1zO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIElmIG5vIGhlYWRlcnMgaGF2ZSBiZWVuIHBhc3NlZCBpbiwgY29uc3RydWN0IGEgbmV3IEh0dHBIZWFkZXJzIGluc3RhbmNlLlxuICAgICAgICBpZiAoIXRoaXMuaGVhZGVycykge1xuICAgICAgICAgICAgdGhpcy5oZWFkZXJzID0gbmV3IEh0dHBIZWFkZXJzKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgbm8gcGFyYW1ldGVycyBoYXZlIGJlZW4gcGFzc2VkIGluLCBjb25zdHJ1Y3QgYSBuZXcgSHR0cFVybEVuY29kZWRQYXJhbXMgaW5zdGFuY2UuXG4gICAgICAgIGlmICghdGhpcy5wYXJhbXMpIHtcbiAgICAgICAgICAgIHRoaXMucGFyYW1zID0gbmV3IEh0dHBQYXJhbXMoKTtcbiAgICAgICAgICAgIHRoaXMudXJsV2l0aFBhcmFtcyA9IHVybDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIEVuY29kZSB0aGUgcGFyYW1ldGVycyB0byBhIHN0cmluZyBpbiBwcmVwYXJhdGlvbiBmb3IgaW5jbHVzaW9uIGluIHRoZSBVUkwuXG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwYXJhbXMgPSB0aGlzLnBhcmFtcy50b1N0cmluZygpO1xuICAgICAgICAgICAgaWYgKHBhcmFtcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAvLyBObyBwYXJhbWV0ZXJzLCB0aGUgdmlzaWJsZSBVUkwgaXMganVzdCB0aGUgVVJMIGdpdmVuIGF0IGNyZWF0aW9uIHRpbWUuXG4gICAgICAgICAgICAgICAgdGhpcy51cmxXaXRoUGFyYW1zID0gdXJsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gRG9lcyB0aGUgVVJMIGFscmVhZHkgaGF2ZSBxdWVyeSBwYXJhbWV0ZXJzPyBMb29rIGZvciAnPycuXG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcUlkeCA9IHVybC5pbmRleE9mKCc/Jyk7XG4gICAgICAgICAgICAgICAgLy8gVGhlcmUgYXJlIDMgY2FzZXMgdG8gaGFuZGxlOlxuICAgICAgICAgICAgICAgIC8vIDEpIE5vIGV4aXN0aW5nIHBhcmFtZXRlcnMgLT4gYXBwZW5kICc/JyBmb2xsb3dlZCBieSBwYXJhbXMuXG4gICAgICAgICAgICAgICAgLy8gMikgJz8nIGV4aXN0cyBhbmQgaXMgZm9sbG93ZWQgYnkgZXhpc3RpbmcgcXVlcnkgc3RyaW5nIC0+XG4gICAgICAgICAgICAgICAgLy8gICAgYXBwZW5kICcmJyBmb2xsb3dlZCBieSBwYXJhbXMuXG4gICAgICAgICAgICAgICAgLy8gMykgJz8nIGV4aXN0cyBhdCB0aGUgZW5kIG9mIHRoZSB1cmwgLT4gYXBwZW5kIHBhcmFtcyBkaXJlY3RseS5cbiAgICAgICAgICAgICAgICAvLyBUaGlzIGJhc2ljYWxseSBhbW91bnRzIHRvIGRldGVybWluaW5nIHRoZSBjaGFyYWN0ZXIsIGlmIGFueSwgd2l0aFxuICAgICAgICAgICAgICAgIC8vIHdoaWNoIHRvIGpvaW4gdGhlIFVSTCBhbmQgcGFyYW1ldGVycy5cbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzZXAgPSBxSWR4ID09PSAtMSA/ICc/JyA6IChxSWR4IDwgdXJsLmxlbmd0aCAtIDEgPyAnJicgOiAnJyk7XG4gICAgICAgICAgICAgICAgdGhpcy51cmxXaXRoUGFyYW1zID0gdXJsICsgc2VwICsgcGFyYW1zO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRyYW5zZm9ybSB0aGUgZnJlZS1mb3JtIGJvZHkgaW50byBhIHNlcmlhbGl6ZWQgZm9ybWF0IHN1aXRhYmxlIGZvclxuICAgICAqIHRyYW5zbWlzc2lvbiB0byB0aGUgc2VydmVyLlxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIFRyYW5zZm9ybSB0aGUgZnJlZS1mb3JtIGJvZHkgaW50byBhIHNlcmlhbGl6ZWQgZm9ybWF0IHN1aXRhYmxlIGZvclxuICAgICAqIHRyYW5zbWlzc2lvbiB0byB0aGUgc2VydmVyLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgSHR0cFJlcXVlc3QucHJvdG90eXBlLnNlcmlhbGl6ZUJvZHkgPSAvKipcbiAgICAgKiBUcmFuc2Zvcm0gdGhlIGZyZWUtZm9ybSBib2R5IGludG8gYSBzZXJpYWxpemVkIGZvcm1hdCBzdWl0YWJsZSBmb3JcbiAgICAgKiB0cmFuc21pc3Npb24gdG8gdGhlIHNlcnZlci5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gSWYgbm8gYm9keSBpcyBwcmVzZW50LCBubyBuZWVkIHRvIHNlcmlhbGl6ZSBpdC5cbiAgICAgICAgaWYgKHRoaXMuYm9keSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2hlY2sgd2hldGhlciB0aGUgYm9keSBpcyBhbHJlYWR5IGluIGEgc2VyaWFsaXplZCBmb3JtLiBJZiBzbyxcbiAgICAgICAgLy8gaXQgY2FuIGp1c3QgYmUgcmV0dXJuZWQgZGlyZWN0bHkuXG4gICAgICAgIGlmIChpc0FycmF5QnVmZmVyKHRoaXMuYm9keSkgfHwgaXNCbG9iKHRoaXMuYm9keSkgfHwgaXNGb3JtRGF0YSh0aGlzLmJvZHkpIHx8XG4gICAgICAgICAgICB0eXBlb2YgdGhpcy5ib2R5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYm9keTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDaGVjayB3aGV0aGVyIHRoZSBib2R5IGlzIGFuIGluc3RhbmNlIG9mIEh0dHBVcmxFbmNvZGVkUGFyYW1zLlxuICAgICAgICBpZiAodGhpcy5ib2R5IGluc3RhbmNlb2YgSHR0cFBhcmFtcykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYm9keS50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIC8vIENoZWNrIHdoZXRoZXIgdGhlIGJvZHkgaXMgYW4gb2JqZWN0IG9yIGFycmF5LCBhbmQgc2VyaWFsaXplIHdpdGggSlNPTiBpZiBzby5cbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmJvZHkgPT09ICdvYmplY3QnIHx8IHR5cGVvZiB0aGlzLmJvZHkgPT09ICdib29sZWFuJyB8fFxuICAgICAgICAgICAgQXJyYXkuaXNBcnJheSh0aGlzLmJvZHkpKSB7XG4gICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcy5ib2R5KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBGYWxsIGJhY2sgb24gdG9TdHJpbmcoKSBmb3IgZXZlcnl0aGluZyBlbHNlLlxuICAgICAgICByZXR1cm4gKC8qKiBAdHlwZSB7P30gKi8gKHRoaXMuYm9keSkpLnRvU3RyaW5nKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBFeGFtaW5lIHRoZSBib2R5IGFuZCBhdHRlbXB0IHRvIGluZmVyIGFuIGFwcHJvcHJpYXRlIE1JTUUgdHlwZVxuICAgICAqIGZvciBpdC5cbiAgICAgKlxuICAgICAqIElmIG5vIHN1Y2ggdHlwZSBjYW4gYmUgaW5mZXJyZWQsIHRoaXMgbWV0aG9kIHdpbGwgcmV0dXJuIGBudWxsYC5cbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBFeGFtaW5lIHRoZSBib2R5IGFuZCBhdHRlbXB0IHRvIGluZmVyIGFuIGFwcHJvcHJpYXRlIE1JTUUgdHlwZVxuICAgICAqIGZvciBpdC5cbiAgICAgKlxuICAgICAqIElmIG5vIHN1Y2ggdHlwZSBjYW4gYmUgaW5mZXJyZWQsIHRoaXMgbWV0aG9kIHdpbGwgcmV0dXJuIGBudWxsYC5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEh0dHBSZXF1ZXN0LnByb3RvdHlwZS5kZXRlY3RDb250ZW50VHlwZUhlYWRlciA9IC8qKlxuICAgICAqIEV4YW1pbmUgdGhlIGJvZHkgYW5kIGF0dGVtcHQgdG8gaW5mZXIgYW4gYXBwcm9wcmlhdGUgTUlNRSB0eXBlXG4gICAgICogZm9yIGl0LlxuICAgICAqXG4gICAgICogSWYgbm8gc3VjaCB0eXBlIGNhbiBiZSBpbmZlcnJlZCwgdGhpcyBtZXRob2Qgd2lsbCByZXR1cm4gYG51bGxgLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBBbiBlbXB0eSBib2R5IGhhcyBubyBjb250ZW50IHR5cGUuXG4gICAgICAgIGlmICh0aGlzLmJvZHkgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZvcm1EYXRhIGJvZGllcyByZWx5IG9uIHRoZSBicm93c2VyJ3MgY29udGVudCB0eXBlIGFzc2lnbm1lbnQuXG4gICAgICAgIGlmIChpc0Zvcm1EYXRhKHRoaXMuYm9keSkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIEJsb2JzIHVzdWFsbHkgaGF2ZSB0aGVpciBvd24gY29udGVudCB0eXBlLiBJZiBpdCBkb2Vzbid0LCB0aGVuXG4gICAgICAgIC8vIG5vIHR5cGUgY2FuIGJlIGluZmVycmVkLlxuICAgICAgICBpZiAoaXNCbG9iKHRoaXMuYm9keSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJvZHkudHlwZSB8fCBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFycmF5IGJ1ZmZlcnMgaGF2ZSB1bmtub3duIGNvbnRlbnRzIGFuZCB0aHVzIG5vIHR5cGUgY2FuIGJlIGluZmVycmVkLlxuICAgICAgICBpZiAoaXNBcnJheUJ1ZmZlcih0aGlzLmJvZHkpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBUZWNobmljYWxseSwgc3RyaW5ncyBjb3VsZCBiZSBhIGZvcm0gb2YgSlNPTiBkYXRhLCBidXQgaXQncyBzYWZlIGVub3VnaFxuICAgICAgICAvLyB0byBhc3N1bWUgdGhleSdyZSBwbGFpbiBzdHJpbmdzLlxuICAgICAgICBpZiAodHlwZW9mIHRoaXMuYm9keSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiAndGV4dC9wbGFpbic7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYEh0dHBVcmxFbmNvZGVkUGFyYW1zYCBoYXMgaXRzIG93biBjb250ZW50LXR5cGUuXG4gICAgICAgIGlmICh0aGlzLmJvZHkgaW5zdGFuY2VvZiBIdHRwUGFyYW1zKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZDtjaGFyc2V0PVVURi04JztcbiAgICAgICAgfVxuICAgICAgICAvLyBBcnJheXMsIG9iamVjdHMsIGFuZCBudW1iZXJzIHdpbGwgYmUgZW5jb2RlZCBhcyBKU09OLlxuICAgICAgICBpZiAodHlwZW9mIHRoaXMuYm9keSA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIHRoaXMuYm9keSA9PT0gJ251bWJlcicgfHxcbiAgICAgICAgICAgIEFycmF5LmlzQXJyYXkodGhpcy5ib2R5KSkge1xuICAgICAgICAgICAgcmV0dXJuICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgICAgfVxuICAgICAgICAvLyBObyB0eXBlIGNvdWxkIGJlIGluZmVycmVkLlxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Pz19IHVwZGF0ZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgSHR0cFJlcXVlc3QucHJvdG90eXBlLmNsb25lID0gLyoqXG4gICAgICogQHBhcmFtIHs/PX0gdXBkYXRlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAodXBkYXRlKSB7XG4gICAgICAgIGlmICh1cGRhdGUgPT09IHZvaWQgMCkgeyB1cGRhdGUgPSB7fTsgfVxuICAgICAgICAvLyBGb3IgbWV0aG9kLCB1cmwsIGFuZCByZXNwb25zZVR5cGUsIHRha2UgdGhlIGN1cnJlbnQgdmFsdWUgdW5sZXNzXG4gICAgICAgIC8vIGl0IGlzIG92ZXJyaWRkZW4gaW4gdGhlIHVwZGF0ZSBoYXNoLlxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBtZXRob2QgPSB1cGRhdGUubWV0aG9kIHx8IHRoaXMubWV0aG9kO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB1cmwgPSB1cGRhdGUudXJsIHx8IHRoaXMudXJsO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZXNwb25zZVR5cGUgPSB1cGRhdGUucmVzcG9uc2VUeXBlIHx8IHRoaXMucmVzcG9uc2VUeXBlO1xuICAgICAgICAvLyBUaGUgYm9keSBpcyBzb21ld2hhdCBzcGVjaWFsIC0gYSBgbnVsbGAgdmFsdWUgaW4gdXBkYXRlLmJvZHkgbWVhbnNcbiAgICAgICAgLy8gd2hhdGV2ZXIgY3VycmVudCBib2R5IGlzIHByZXNlbnQgaXMgYmVpbmcgb3ZlcnJpZGRlbiB3aXRoIGFuIGVtcHR5XG4gICAgICAgIC8vIGJvZHksIHdoZXJlYXMgYW4gYHVuZGVmaW5lZGAgdmFsdWUgaW4gdXBkYXRlLmJvZHkgaW1wbGllcyBub1xuICAgICAgICAvLyBvdmVycmlkZS5cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYm9keSA9ICh1cGRhdGUuYm9keSAhPT0gdW5kZWZpbmVkKSA/IHVwZGF0ZS5ib2R5IDogdGhpcy5ib2R5O1xuICAgICAgICAvLyBDYXJlZnVsbHkgaGFuZGxlIHRoZSBib29sZWFuIG9wdGlvbnMgdG8gZGlmZmVyZW50aWF0ZSBiZXR3ZWVuXG4gICAgICAgIC8vIGBmYWxzZWAgYW5kIGB1bmRlZmluZWRgIGluIHRoZSB1cGRhdGUgYXJncy5cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gd2l0aENyZWRlbnRpYWxzID0gKHVwZGF0ZS53aXRoQ3JlZGVudGlhbHMgIT09IHVuZGVmaW5lZCkgPyB1cGRhdGUud2l0aENyZWRlbnRpYWxzIDogdGhpcy53aXRoQ3JlZGVudGlhbHM7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlcG9ydFByb2dyZXNzID0gKHVwZGF0ZS5yZXBvcnRQcm9ncmVzcyAhPT0gdW5kZWZpbmVkKSA/IHVwZGF0ZS5yZXBvcnRQcm9ncmVzcyA6IHRoaXMucmVwb3J0UHJvZ3Jlc3M7XG4gICAgICAgIC8vIEhlYWRlcnMgYW5kIHBhcmFtcyBtYXkgYmUgYXBwZW5kZWQgdG8gaWYgYHNldEhlYWRlcnNgIG9yXG4gICAgICAgIC8vIGBzZXRQYXJhbXNgIGFyZSB1c2VkLlxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBoZWFkZXJzID0gdXBkYXRlLmhlYWRlcnMgfHwgdGhpcy5oZWFkZXJzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwYXJhbXMgPSB1cGRhdGUucGFyYW1zIHx8IHRoaXMucGFyYW1zO1xuICAgICAgICAvLyBDaGVjayB3aGV0aGVyIHRoZSBjYWxsZXIgaGFzIGFza2VkIHRvIGFkZCBoZWFkZXJzLlxuICAgICAgICBpZiAodXBkYXRlLnNldEhlYWRlcnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gU2V0IGV2ZXJ5IHJlcXVlc3RlZCBoZWFkZXIuXG4gICAgICAgICAgICBoZWFkZXJzID1cbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyh1cGRhdGUuc2V0SGVhZGVycylcbiAgICAgICAgICAgICAgICAgICAgLnJlZHVjZShmdW5jdGlvbiAoaGVhZGVycywgbmFtZSkgeyByZXR1cm4gaGVhZGVycy5zZXQobmFtZSwgLyoqIEB0eXBlIHs/fSAqLyAoKHVwZGF0ZS5zZXRIZWFkZXJzKSlbbmFtZV0pOyB9LCBoZWFkZXJzKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDaGVjayB3aGV0aGVyIHRoZSBjYWxsZXIgaGFzIGFza2VkIHRvIHNldCBwYXJhbXMuXG4gICAgICAgIGlmICh1cGRhdGUuc2V0UGFyYW1zKSB7XG4gICAgICAgICAgICAvLyBTZXQgZXZlcnkgcmVxdWVzdGVkIHBhcmFtLlxuICAgICAgICAgICAgcGFyYW1zID0gT2JqZWN0LmtleXModXBkYXRlLnNldFBhcmFtcylcbiAgICAgICAgICAgICAgICAucmVkdWNlKGZ1bmN0aW9uIChwYXJhbXMsIHBhcmFtKSB7IHJldHVybiBwYXJhbXMuc2V0KHBhcmFtLCAvKiogQHR5cGUgez99ICovICgodXBkYXRlLnNldFBhcmFtcykpW3BhcmFtXSk7IH0sIHBhcmFtcyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRmluYWxseSwgY29uc3RydWN0IHRoZSBuZXcgSHR0cFJlcXVlc3QgdXNpbmcgdGhlIHBpZWNlcyBmcm9tIGFib3ZlLlxuICAgICAgICByZXR1cm4gbmV3IEh0dHBSZXF1ZXN0KG1ldGhvZCwgdXJsLCBib2R5LCB7XG4gICAgICAgICAgICBwYXJhbXM6IHBhcmFtcywgaGVhZGVyczogaGVhZGVycywgcmVwb3J0UHJvZ3Jlc3M6IHJlcG9ydFByb2dyZXNzLCByZXNwb25zZVR5cGU6IHJlc3BvbnNlVHlwZSwgd2l0aENyZWRlbnRpYWxzOiB3aXRoQ3JlZGVudGlhbHMsXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIEh0dHBSZXF1ZXN0O1xufSgpKTtcblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IGFkZGVkIGJ5IHRzaWNrbGVcbiAqIEBzdXBwcmVzcyB7Y2hlY2tUeXBlc30gY2hlY2tlZCBieSB0c2NcbiAqL1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLyoqIEBlbnVtIHtudW1iZXJ9ICovXG52YXIgSHR0cEV2ZW50VHlwZSA9IHtcbiAgICAvKipcbiAgICAgICAqIFRoZSByZXF1ZXN0IHdhcyBzZW50IG91dCBvdmVyIHRoZSB3aXJlLlxuICAgICAgICovXG4gICAgU2VudDogMCxcbiAgICAvKipcbiAgICAgICAqIEFuIHVwbG9hZCBwcm9ncmVzcyBldmVudCB3YXMgcmVjZWl2ZWQuXG4gICAgICAgKi9cbiAgICBVcGxvYWRQcm9ncmVzczogMSxcbiAgICAvKipcbiAgICAgICAqIFRoZSByZXNwb25zZSBzdGF0dXMgY29kZSBhbmQgaGVhZGVycyB3ZXJlIHJlY2VpdmVkLlxuICAgICAgICovXG4gICAgUmVzcG9uc2VIZWFkZXI6IDIsXG4gICAgLyoqXG4gICAgICAgKiBBIGRvd25sb2FkIHByb2dyZXNzIGV2ZW50IHdhcyByZWNlaXZlZC5cbiAgICAgICAqL1xuICAgIERvd25sb2FkUHJvZ3Jlc3M6IDMsXG4gICAgLyoqXG4gICAgICAgKiBUaGUgZnVsbCByZXNwb25zZSBpbmNsdWRpbmcgdGhlIGJvZHkgd2FzIHJlY2VpdmVkLlxuICAgICAgICovXG4gICAgUmVzcG9uc2U6IDQsXG4gICAgLyoqXG4gICAgICAgKiBBIGN1c3RvbSBldmVudCBmcm9tIGFuIGludGVyY2VwdG9yIG9yIGEgYmFja2VuZC5cbiAgICAgICAqL1xuICAgIFVzZXI6IDUsXG59O1xuSHR0cEV2ZW50VHlwZVtIdHRwRXZlbnRUeXBlLlNlbnRdID0gXCJTZW50XCI7XG5IdHRwRXZlbnRUeXBlW0h0dHBFdmVudFR5cGUuVXBsb2FkUHJvZ3Jlc3NdID0gXCJVcGxvYWRQcm9ncmVzc1wiO1xuSHR0cEV2ZW50VHlwZVtIdHRwRXZlbnRUeXBlLlJlc3BvbnNlSGVhZGVyXSA9IFwiUmVzcG9uc2VIZWFkZXJcIjtcbkh0dHBFdmVudFR5cGVbSHR0cEV2ZW50VHlwZS5Eb3dubG9hZFByb2dyZXNzXSA9IFwiRG93bmxvYWRQcm9ncmVzc1wiO1xuSHR0cEV2ZW50VHlwZVtIdHRwRXZlbnRUeXBlLlJlc3BvbnNlXSA9IFwiUmVzcG9uc2VcIjtcbkh0dHBFdmVudFR5cGVbSHR0cEV2ZW50VHlwZS5Vc2VyXSA9IFwiVXNlclwiO1xuLyoqXG4gKiBCYXNlIGludGVyZmFjZSBmb3IgcHJvZ3Jlc3MgZXZlbnRzLlxuICpcbiAqIFxcQHN0YWJsZVxuICogQHJlY29yZFxuICovXG5cbi8qKlxuICogQSBkb3dubG9hZCBwcm9ncmVzcyBldmVudC5cbiAqXG4gKiBcXEBzdGFibGVcbiAqIEByZWNvcmRcbiAqL1xuXG4vKipcbiAqIEFuIHVwbG9hZCBwcm9ncmVzcyBldmVudC5cbiAqXG4gKiBcXEBzdGFibGVcbiAqIEByZWNvcmRcbiAqL1xuXG4vKipcbiAqIEFuIGV2ZW50IGluZGljYXRpbmcgdGhhdCB0aGUgcmVxdWVzdCB3YXMgc2VudCB0byB0aGUgc2VydmVyLiBVc2VmdWxcbiAqIHdoZW4gYSByZXF1ZXN0IG1heSBiZSByZXRyaWVkIG11bHRpcGxlIHRpbWVzLCB0byBkaXN0aW5ndWlzaCBiZXR3ZWVuXG4gKiByZXRyaWVzIG9uIHRoZSBmaW5hbCBldmVudCBzdHJlYW0uXG4gKlxuICogXFxAc3RhYmxlXG4gKiBAcmVjb3JkXG4gKi9cblxuLyoqXG4gKiBBIHVzZXItZGVmaW5lZCBldmVudC5cbiAqXG4gKiBHcm91cGluZyBhbGwgY3VzdG9tIGV2ZW50cyB1bmRlciB0aGlzIHR5cGUgZW5zdXJlcyB0aGV5IHdpbGwgYmUgaGFuZGxlZFxuICogYW5kIGZvcndhcmRlZCBieSBhbGwgaW1wbGVtZW50YXRpb25zIG9mIGludGVyY2VwdG9ycy5cbiAqXG4gKiBcXEBzdGFibGVcbiAqIEByZWNvcmRcbiAqL1xuXG4vKipcbiAqIEFuIGVycm9yIHRoYXQgcmVwcmVzZW50cyBhIGZhaWxlZCBhdHRlbXB0IHRvIEpTT04ucGFyc2UgdGV4dCBjb21pbmcgYmFja1xuICogZnJvbSB0aGUgc2VydmVyLlxuICpcbiAqIEl0IGJ1bmRsZXMgdGhlIEVycm9yIG9iamVjdCB3aXRoIHRoZSBhY3R1YWwgcmVzcG9uc2UgYm9keSB0aGF0IGZhaWxlZCB0byBwYXJzZS5cbiAqXG4gKiBcXEBzdGFibGVcbiAqIEByZWNvcmRcbiAqL1xuXG4vKipcbiAqIEJhc2UgY2xhc3MgZm9yIGJvdGggYEh0dHBSZXNwb25zZWAgYW5kIGBIdHRwSGVhZGVyUmVzcG9uc2VgLlxuICpcbiAqIFxcQHN0YWJsZVxuICogQGFic3RyYWN0XG4gKi9cbnZhciBIdHRwUmVzcG9uc2VCYXNlID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBTdXBlci1jb25zdHJ1Y3RvciBmb3IgYWxsIHJlc3BvbnNlcy5cbiAgICAgKlxuICAgICAqIFRoZSBzaW5nbGUgcGFyYW1ldGVyIGFjY2VwdGVkIGlzIGFuIGluaXRpYWxpemF0aW9uIGhhc2guIEFueSBwcm9wZXJ0aWVzXG4gICAgICogb2YgdGhlIHJlc3BvbnNlIHBhc3NlZCB0aGVyZSB3aWxsIG92ZXJyaWRlIHRoZSBkZWZhdWx0IHZhbHVlcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBIdHRwUmVzcG9uc2VCYXNlKGluaXQsIGRlZmF1bHRTdGF0dXMsIGRlZmF1bHRTdGF0dXNUZXh0KSB7XG4gICAgICAgIGlmIChkZWZhdWx0U3RhdHVzID09PSB2b2lkIDApIHsgZGVmYXVsdFN0YXR1cyA9IDIwMDsgfVxuICAgICAgICBpZiAoZGVmYXVsdFN0YXR1c1RleHQgPT09IHZvaWQgMCkgeyBkZWZhdWx0U3RhdHVzVGV4dCA9ICdPSyc7IH1cbiAgICAgICAgLy8gSWYgdGhlIGhhc2ggaGFzIHZhbHVlcyBwYXNzZWQsIHVzZSB0aGVtIHRvIGluaXRpYWxpemUgdGhlIHJlc3BvbnNlLlxuICAgICAgICAvLyBPdGhlcndpc2UgdXNlIHRoZSBkZWZhdWx0IHZhbHVlcy5cbiAgICAgICAgdGhpcy5oZWFkZXJzID0gaW5pdC5oZWFkZXJzIHx8IG5ldyBIdHRwSGVhZGVycygpO1xuICAgICAgICB0aGlzLnN0YXR1cyA9IGluaXQuc3RhdHVzICE9PSB1bmRlZmluZWQgPyBpbml0LnN0YXR1cyA6IGRlZmF1bHRTdGF0dXM7XG4gICAgICAgIHRoaXMuc3RhdHVzVGV4dCA9IGluaXQuc3RhdHVzVGV4dCB8fCBkZWZhdWx0U3RhdHVzVGV4dDtcbiAgICAgICAgdGhpcy51cmwgPSBpbml0LnVybCB8fCBudWxsO1xuICAgICAgICAvLyBDYWNoZSB0aGUgb2sgdmFsdWUgdG8gYXZvaWQgZGVmaW5pbmcgYSBnZXR0ZXIuXG4gICAgICAgIHRoaXMub2sgPSB0aGlzLnN0YXR1cyA+PSAyMDAgJiYgdGhpcy5zdGF0dXMgPCAzMDA7XG4gICAgfVxuICAgIHJldHVybiBIdHRwUmVzcG9uc2VCYXNlO1xufSgpKTtcbi8qKlxuICogQSBwYXJ0aWFsIEhUVFAgcmVzcG9uc2Ugd2hpY2ggb25seSBpbmNsdWRlcyB0aGUgc3RhdHVzIGFuZCBoZWFkZXIgZGF0YSxcbiAqIGJ1dCBubyByZXNwb25zZSBib2R5LlxuICpcbiAqIGBIdHRwSGVhZGVyUmVzcG9uc2VgIGlzIGEgYEh0dHBFdmVudGAgYXZhaWxhYmxlIG9uIHRoZSByZXNwb25zZVxuICogZXZlbnQgc3RyZWFtLCBvbmx5IHdoZW4gcHJvZ3Jlc3MgZXZlbnRzIGFyZSByZXF1ZXN0ZWQuXG4gKlxuICogXFxAc3RhYmxlXG4gKi9cbnZhciBIdHRwSGVhZGVyUmVzcG9uc2UgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliLl9fZXh0ZW5kcyhIdHRwSGVhZGVyUmVzcG9uc2UsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IGBIdHRwSGVhZGVyUmVzcG9uc2VgIHdpdGggdGhlIGdpdmVuIHBhcmFtZXRlcnMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gSHR0cEhlYWRlclJlc3BvbnNlKGluaXQpIHtcbiAgICAgICAgaWYgKGluaXQgPT09IHZvaWQgMCkgeyBpbml0ID0ge307IH1cbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgaW5pdCkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudHlwZSA9IEh0dHBFdmVudFR5cGUuUmVzcG9uc2VIZWFkZXI7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29weSB0aGlzIGBIdHRwSGVhZGVyUmVzcG9uc2VgLCBvdmVycmlkaW5nIGl0cyBjb250ZW50cyB3aXRoIHRoZVxuICAgICAqIGdpdmVuIHBhcmFtZXRlciBoYXNoLlxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIENvcHkgdGhpcyBgSHR0cEhlYWRlclJlc3BvbnNlYCwgb3ZlcnJpZGluZyBpdHMgY29udGVudHMgd2l0aCB0aGVcbiAgICAgKiBnaXZlbiBwYXJhbWV0ZXIgaGFzaC5cbiAgICAgKiBAcGFyYW0gez89fSB1cGRhdGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEh0dHBIZWFkZXJSZXNwb25zZS5wcm90b3R5cGUuY2xvbmUgPSAvKipcbiAgICAgKiBDb3B5IHRoaXMgYEh0dHBIZWFkZXJSZXNwb25zZWAsIG92ZXJyaWRpbmcgaXRzIGNvbnRlbnRzIHdpdGggdGhlXG4gICAgICogZ2l2ZW4gcGFyYW1ldGVyIGhhc2guXG4gICAgICogQHBhcmFtIHs/PX0gdXBkYXRlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAodXBkYXRlKSB7XG4gICAgICAgIGlmICh1cGRhdGUgPT09IHZvaWQgMCkgeyB1cGRhdGUgPSB7fTsgfVxuICAgICAgICAvLyBQZXJmb3JtIGEgc3RyYWlnaHRmb3J3YXJkIGluaXRpYWxpemF0aW9uIG9mIHRoZSBuZXcgSHR0cEhlYWRlclJlc3BvbnNlLFxuICAgICAgICAvLyBvdmVycmlkaW5nIHRoZSBjdXJyZW50IHBhcmFtZXRlcnMgd2l0aCBuZXcgb25lcyBpZiBnaXZlbi5cbiAgICAgICAgcmV0dXJuIG5ldyBIdHRwSGVhZGVyUmVzcG9uc2Uoe1xuICAgICAgICAgICAgaGVhZGVyczogdXBkYXRlLmhlYWRlcnMgfHwgdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgc3RhdHVzOiB1cGRhdGUuc3RhdHVzICE9PSB1bmRlZmluZWQgPyB1cGRhdGUuc3RhdHVzIDogdGhpcy5zdGF0dXMsXG4gICAgICAgICAgICBzdGF0dXNUZXh0OiB1cGRhdGUuc3RhdHVzVGV4dCB8fCB0aGlzLnN0YXR1c1RleHQsXG4gICAgICAgICAgICB1cmw6IHVwZGF0ZS51cmwgfHwgdGhpcy51cmwgfHwgdW5kZWZpbmVkLFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBIdHRwSGVhZGVyUmVzcG9uc2U7XG59KEh0dHBSZXNwb25zZUJhc2UpKTtcbi8qKlxuICogQSBmdWxsIEhUVFAgcmVzcG9uc2UsIGluY2x1ZGluZyBhIHR5cGVkIHJlc3BvbnNlIGJvZHkgKHdoaWNoIG1heSBiZSBgbnVsbGBcbiAqIGlmIG9uZSB3YXMgbm90IHJldHVybmVkKS5cbiAqXG4gKiBgSHR0cFJlc3BvbnNlYCBpcyBhIGBIdHRwRXZlbnRgIGF2YWlsYWJsZSBvbiB0aGUgcmVzcG9uc2UgZXZlbnRcbiAqIHN0cmVhbS5cbiAqXG4gKiBcXEBzdGFibGVcbiAqL1xudmFyIEh0dHBSZXNwb25zZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWIuX19leHRlbmRzKEh0dHBSZXNwb25zZSwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3QgYSBuZXcgYEh0dHBSZXNwb25zZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gSHR0cFJlc3BvbnNlKGluaXQpIHtcbiAgICAgICAgaWYgKGluaXQgPT09IHZvaWQgMCkgeyBpbml0ID0ge307IH1cbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgaW5pdCkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudHlwZSA9IEh0dHBFdmVudFR5cGUuUmVzcG9uc2U7XG4gICAgICAgIF90aGlzLmJvZHkgPSBpbml0LmJvZHkgfHwgbnVsbDtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez89fSB1cGRhdGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEh0dHBSZXNwb25zZS5wcm90b3R5cGUuY2xvbmUgPSAvKipcbiAgICAgKiBAcGFyYW0gez89fSB1cGRhdGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uICh1cGRhdGUpIHtcbiAgICAgICAgaWYgKHVwZGF0ZSA9PT0gdm9pZCAwKSB7IHVwZGF0ZSA9IHt9OyB9XG4gICAgICAgIHJldHVybiBuZXcgSHR0cFJlc3BvbnNlKHtcbiAgICAgICAgICAgIGJvZHk6ICh1cGRhdGUuYm9keSAhPT0gdW5kZWZpbmVkKSA/IHVwZGF0ZS5ib2R5IDogdGhpcy5ib2R5LFxuICAgICAgICAgICAgaGVhZGVyczogdXBkYXRlLmhlYWRlcnMgfHwgdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgc3RhdHVzOiAodXBkYXRlLnN0YXR1cyAhPT0gdW5kZWZpbmVkKSA/IHVwZGF0ZS5zdGF0dXMgOiB0aGlzLnN0YXR1cyxcbiAgICAgICAgICAgIHN0YXR1c1RleHQ6IHVwZGF0ZS5zdGF0dXNUZXh0IHx8IHRoaXMuc3RhdHVzVGV4dCxcbiAgICAgICAgICAgIHVybDogdXBkYXRlLnVybCB8fCB0aGlzLnVybCB8fCB1bmRlZmluZWQsXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIEh0dHBSZXNwb25zZTtcbn0oSHR0cFJlc3BvbnNlQmFzZSkpO1xuLyoqXG4gKiBBIHJlc3BvbnNlIHRoYXQgcmVwcmVzZW50cyBhbiBlcnJvciBvciBmYWlsdXJlLCBlaXRoZXIgZnJvbSBhXG4gKiBub24tc3VjY2Vzc2Z1bCBIVFRQIHN0YXR1cywgYW4gZXJyb3Igd2hpbGUgZXhlY3V0aW5nIHRoZSByZXF1ZXN0LFxuICogb3Igc29tZSBvdGhlciBmYWlsdXJlIHdoaWNoIG9jY3VycmVkIGR1cmluZyB0aGUgcGFyc2luZyBvZiB0aGUgcmVzcG9uc2UuXG4gKlxuICogQW55IGVycm9yIHJldHVybmVkIG9uIHRoZSBgT2JzZXJ2YWJsZWAgcmVzcG9uc2Ugc3RyZWFtIHdpbGwgYmVcbiAqIHdyYXBwZWQgaW4gYW4gYEh0dHBFcnJvclJlc3BvbnNlYCB0byBwcm92aWRlIGFkZGl0aW9uYWwgY29udGV4dCBhYm91dFxuICogdGhlIHN0YXRlIG9mIHRoZSBIVFRQIGxheWVyIHdoZW4gdGhlIGVycm9yIG9jY3VycmVkLiBUaGUgZXJyb3IgcHJvcGVydHlcbiAqIHdpbGwgY29udGFpbiBlaXRoZXIgYSB3cmFwcGVkIEVycm9yIG9iamVjdCBvciB0aGUgZXJyb3IgcmVzcG9uc2UgcmV0dXJuZWRcbiAqIGZyb20gdGhlIHNlcnZlci5cbiAqXG4gKiBcXEBzdGFibGVcbiAqL1xudmFyIEh0dHBFcnJvclJlc3BvbnNlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYi5fX2V4dGVuZHMoSHR0cEVycm9yUmVzcG9uc2UsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSHR0cEVycm9yUmVzcG9uc2UoaW5pdCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBcbiAgICAgICAgLy8gSW5pdGlhbGl6ZSB3aXRoIGEgZGVmYXVsdCBzdGF0dXMgb2YgMCAvIFVua25vd24gRXJyb3IuXG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGluaXQsIDAsICdVbmtub3duIEVycm9yJykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMubmFtZSA9ICdIdHRwRXJyb3JSZXNwb25zZSc7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFcnJvcnMgYXJlIG5ldmVyIG9rYXksIGV2ZW4gd2hlbiB0aGUgc3RhdHVzIGNvZGUgaXMgaW4gdGhlIDJ4eCBzdWNjZXNzIHJhbmdlLlxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMub2sgPSBmYWxzZTtcbiAgICAgICAgLy8gSWYgdGhlIHJlc3BvbnNlIHdhcyBzdWNjZXNzZnVsLCB0aGVuIHRoaXMgd2FzIGEgcGFyc2UgZXJyb3IuIE90aGVyd2lzZSwgaXQgd2FzXG4gICAgICAgIC8vIGEgcHJvdG9jb2wtbGV2ZWwgZmFpbHVyZSBvZiBzb21lIHNvcnQuIEVpdGhlciB0aGUgcmVxdWVzdCBmYWlsZWQgaW4gdHJhbnNpdFxuICAgICAgICAvLyBvciB0aGUgc2VydmVyIHJldHVybmVkIGFuIHVuc3VjY2Vzc2Z1bCBzdGF0dXMgY29kZS5cbiAgICAgICAgaWYgKF90aGlzLnN0YXR1cyA+PSAyMDAgJiYgX3RoaXMuc3RhdHVzIDwgMzAwKSB7XG4gICAgICAgICAgICBfdGhpcy5tZXNzYWdlID0gXCJIdHRwIGZhaWx1cmUgZHVyaW5nIHBhcnNpbmcgZm9yIFwiICsgKGluaXQudXJsIHx8ICcodW5rbm93biB1cmwpJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBfdGhpcy5tZXNzYWdlID1cbiAgICAgICAgICAgICAgICBcIkh0dHAgZmFpbHVyZSByZXNwb25zZSBmb3IgXCIgKyAoaW5pdC51cmwgfHwgJyh1bmtub3duIHVybCknKSArIFwiOiBcIiArIGluaXQuc3RhdHVzICsgXCIgXCIgKyBpbml0LnN0YXR1c1RleHQ7XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXMuZXJyb3IgPSBpbml0LmVycm9yIHx8IG51bGw7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIEh0dHBFcnJvclJlc3BvbnNlO1xufShIdHRwUmVzcG9uc2VCYXNlKSk7XG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBhZGRlZCBieSB0c2lja2xlXG4gKiBAc3VwcHJlc3Mge2NoZWNrVHlwZXN9IGNoZWNrZWQgYnkgdHNjXG4gKi9cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8qKlxuICogQ29uc3RydWN0IGFuIGluc3RhbmNlIG9mIGBIdHRwUmVxdWVzdE9wdGlvbnM8VD5gIGZyb20gYSBzb3VyY2UgYEh0dHBNZXRob2RPcHRpb25zYCBhbmRcbiAqIHRoZSBnaXZlbiBgYm9keWAuIEJhc2ljYWxseSwgdGhpcyBjbG9uZXMgdGhlIG9iamVjdCBhbmQgYWRkcyB0aGUgYm9keS5cbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0gez99IG9wdGlvbnNcbiAqIEBwYXJhbSB7P30gYm9keVxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gYWRkQm9keShvcHRpb25zLCBib2R5KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYm9keTogYm9keSxcbiAgICAgICAgaGVhZGVyczogb3B0aW9ucy5oZWFkZXJzLFxuICAgICAgICBvYnNlcnZlOiBvcHRpb25zLm9ic2VydmUsXG4gICAgICAgIHBhcmFtczogb3B0aW9ucy5wYXJhbXMsXG4gICAgICAgIHJlcG9ydFByb2dyZXNzOiBvcHRpb25zLnJlcG9ydFByb2dyZXNzLFxuICAgICAgICByZXNwb25zZVR5cGU6IG9wdGlvbnMucmVzcG9uc2VUeXBlLFxuICAgICAgICB3aXRoQ3JlZGVudGlhbHM6IG9wdGlvbnMud2l0aENyZWRlbnRpYWxzLFxuICAgIH07XG59XG4vKipcbiAqIFBlcmZvcm0gSFRUUCByZXF1ZXN0cy5cbiAqXG4gKiBgSHR0cENsaWVudGAgaXMgYXZhaWxhYmxlIGFzIGFuIGluamVjdGFibGUgY2xhc3MsIHdpdGggbWV0aG9kcyB0byBwZXJmb3JtIEhUVFAgcmVxdWVzdHMuXG4gKiBFYWNoIHJlcXVlc3QgbWV0aG9kIGhhcyBtdWx0aXBsZSBzaWduYXR1cmVzLCBhbmQgdGhlIHJldHVybiB0eXBlIHZhcmllcyBhY2NvcmRpbmcgdG8gd2hpY2hcbiAqIHNpZ25hdHVyZSBpcyBjYWxsZWQgKG1haW5seSB0aGUgdmFsdWVzIG9mIGBvYnNlcnZlYCBhbmQgYHJlc3BvbnNlVHlwZWApLlxuICpcbiAqIFxcQHN0YWJsZVxuICovXG52YXIgSHR0cENsaWVudCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSHR0cENsaWVudChoYW5kbGVyKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlciA9IGhhbmRsZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdHMgYW4gYE9ic2VydmFibGVgIGZvciBhIHBhcnRpY3VsYXIgSFRUUCByZXF1ZXN0IHRoYXQsIHdoZW4gc3Vic2NyaWJlZCxcbiAgICAgKiBmaXJlcyB0aGUgcmVxdWVzdCB0aHJvdWdoIHRoZSBjaGFpbiBvZiByZWdpc3RlcmVkIGludGVyY2VwdG9ycyBhbmQgb24gdG8gdGhlXG4gICAgICogc2VydmVyLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgY2FuIGJlIGNhbGxlZCBpbiBvbmUgb2YgdHdvIHdheXMuIEVpdGhlciBhbiBgSHR0cFJlcXVlc3RgXG4gICAgICogaW5zdGFuY2UgY2FuIGJlIHBhc3NlZCBkaXJlY3RseSBhcyB0aGUgb25seSBwYXJhbWV0ZXIsIG9yIGEgbWV0aG9kIGNhbiBiZVxuICAgICAqIHBhc3NlZCBhcyB0aGUgZmlyc3QgcGFyYW1ldGVyLCBhIHN0cmluZyBVUkwgYXMgdGhlIHNlY29uZCwgYW5kIGFuXG4gICAgICogb3B0aW9ucyBoYXNoIGFzIHRoZSB0aGlyZC5cbiAgICAgKlxuICAgICAqIElmIGEgYEh0dHBSZXF1ZXN0YCBvYmplY3QgaXMgcGFzc2VkIGRpcmVjdGx5LCBhbiBgT2JzZXJ2YWJsZWAgb2YgdGhlXG4gICAgICogcmF3IGBIdHRwRXZlbnRgIHN0cmVhbSB3aWxsIGJlIHJldHVybmVkLlxuICAgICAqXG4gICAgICogSWYgYSByZXF1ZXN0IGlzIGluc3RlYWQgYnVpbHQgYnkgcHJvdmlkaW5nIGEgVVJMLCB0aGUgb3B0aW9ucyBvYmplY3RcbiAgICAgKiBkZXRlcm1pbmVzIHRoZSByZXR1cm4gdHlwZSBvZiBgcmVxdWVzdCgpYC4gSW4gYWRkaXRpb24gdG8gY29uZmlndXJpbmdcbiAgICAgKiByZXF1ZXN0IHBhcmFtZXRlcnMgc3VjaCBhcyB0aGUgb3V0Z29pbmcgaGVhZGVycyBhbmQvb3IgdGhlIGJvZHksIHRoZSBvcHRpb25zXG4gICAgICogaGFzaCBzcGVjaWZpZXMgdHdvIGtleSBwaWVjZXMgb2YgaW5mb3JtYXRpb24gYWJvdXQgdGhlIHJlcXVlc3Q6IHRoZVxuICAgICAqIGByZXNwb25zZVR5cGVgIGFuZCB3aGF0IHRvIGBvYnNlcnZlYC5cbiAgICAgKlxuICAgICAqIFRoZSBgcmVzcG9uc2VUeXBlYCB2YWx1ZSBkZXRlcm1pbmVzIGhvdyBhIHN1Y2Nlc3NmdWwgcmVzcG9uc2UgYm9keSB3aWxsIGJlXG4gICAgICogcGFyc2VkLiBJZiBgcmVzcG9uc2VUeXBlYCBpcyB0aGUgZGVmYXVsdCBganNvbmAsIGEgdHlwZSBpbnRlcmZhY2UgZm9yIHRoZVxuICAgICAqIHJlc3VsdGluZyBvYmplY3QgbWF5IGJlIHBhc3NlZCBhcyBhIHR5cGUgcGFyYW1ldGVyIHRvIGByZXF1ZXN0KClgLlxuICAgICAqXG4gICAgICogVGhlIGBvYnNlcnZlYCB2YWx1ZSBkZXRlcm1pbmVzIHRoZSByZXR1cm4gdHlwZSBvZiBgcmVxdWVzdCgpYCwgYmFzZWQgb24gd2hhdFxuICAgICAqIHRoZSBjb25zdW1lciBpcyBpbnRlcmVzdGVkIGluIG9ic2VydmluZy4gQSB2YWx1ZSBvZiBgZXZlbnRzYCB3aWxsIHJldHVybiBhblxuICAgICAqIGBPYnNlcnZhYmxlPEh0dHBFdmVudD5gIHJlcHJlc2VudGluZyB0aGUgcmF3IGBIdHRwRXZlbnRgIHN0cmVhbSxcbiAgICAgKiBpbmNsdWRpbmcgcHJvZ3Jlc3MgZXZlbnRzIGJ5IGRlZmF1bHQuIEEgdmFsdWUgb2YgYHJlc3BvbnNlYCB3aWxsIHJldHVybiBhblxuICAgICAqIGBPYnNlcnZhYmxlPEh0dHBSZXNwb25zZTxUPj5gIHdoZXJlIHRoZSBgVGAgcGFyYW1ldGVyIG9mIGBIdHRwUmVzcG9uc2VgXG4gICAgICogZGVwZW5kcyBvbiB0aGUgYHJlc3BvbnNlVHlwZWAgYW5kIGFueSBvcHRpb25hbGx5IHByb3ZpZGVkIHR5cGUgcGFyYW1ldGVyLlxuICAgICAqIEEgdmFsdWUgb2YgYGJvZHlgIHdpbGwgcmV0dXJuIGFuIGBPYnNlcnZhYmxlPFQ+YCB3aXRoIHRoZSBzYW1lIGBUYCBib2R5IHR5cGUuXG4gICAgICovXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0cyBhbiBgT2JzZXJ2YWJsZWAgZm9yIGEgcGFydGljdWxhciBIVFRQIHJlcXVlc3QgdGhhdCwgd2hlbiBzdWJzY3JpYmVkLFxuICAgICAqIGZpcmVzIHRoZSByZXF1ZXN0IHRocm91Z2ggdGhlIGNoYWluIG9mIHJlZ2lzdGVyZWQgaW50ZXJjZXB0b3JzIGFuZCBvbiB0byB0aGVcbiAgICAgKiBzZXJ2ZXIuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBjYW4gYmUgY2FsbGVkIGluIG9uZSBvZiB0d28gd2F5cy4gRWl0aGVyIGFuIGBIdHRwUmVxdWVzdGBcbiAgICAgKiBpbnN0YW5jZSBjYW4gYmUgcGFzc2VkIGRpcmVjdGx5IGFzIHRoZSBvbmx5IHBhcmFtZXRlciwgb3IgYSBtZXRob2QgY2FuIGJlXG4gICAgICogcGFzc2VkIGFzIHRoZSBmaXJzdCBwYXJhbWV0ZXIsIGEgc3RyaW5nIFVSTCBhcyB0aGUgc2Vjb25kLCBhbmQgYW5cbiAgICAgKiBvcHRpb25zIGhhc2ggYXMgdGhlIHRoaXJkLlxuICAgICAqXG4gICAgICogSWYgYSBgSHR0cFJlcXVlc3RgIG9iamVjdCBpcyBwYXNzZWQgZGlyZWN0bHksIGFuIGBPYnNlcnZhYmxlYCBvZiB0aGVcbiAgICAgKiByYXcgYEh0dHBFdmVudGAgc3RyZWFtIHdpbGwgYmUgcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBJZiBhIHJlcXVlc3QgaXMgaW5zdGVhZCBidWlsdCBieSBwcm92aWRpbmcgYSBVUkwsIHRoZSBvcHRpb25zIG9iamVjdFxuICAgICAqIGRldGVybWluZXMgdGhlIHJldHVybiB0eXBlIG9mIGByZXF1ZXN0KClgLiBJbiBhZGRpdGlvbiB0byBjb25maWd1cmluZ1xuICAgICAqIHJlcXVlc3QgcGFyYW1ldGVycyBzdWNoIGFzIHRoZSBvdXRnb2luZyBoZWFkZXJzIGFuZC9vciB0aGUgYm9keSwgdGhlIG9wdGlvbnNcbiAgICAgKiBoYXNoIHNwZWNpZmllcyB0d28ga2V5IHBpZWNlcyBvZiBpbmZvcm1hdGlvbiBhYm91dCB0aGUgcmVxdWVzdDogdGhlXG4gICAgICogYHJlc3BvbnNlVHlwZWAgYW5kIHdoYXQgdG8gYG9ic2VydmVgLlxuICAgICAqXG4gICAgICogVGhlIGByZXNwb25zZVR5cGVgIHZhbHVlIGRldGVybWluZXMgaG93IGEgc3VjY2Vzc2Z1bCByZXNwb25zZSBib2R5IHdpbGwgYmVcbiAgICAgKiBwYXJzZWQuIElmIGByZXNwb25zZVR5cGVgIGlzIHRoZSBkZWZhdWx0IGBqc29uYCwgYSB0eXBlIGludGVyZmFjZSBmb3IgdGhlXG4gICAgICogcmVzdWx0aW5nIG9iamVjdCBtYXkgYmUgcGFzc2VkIGFzIGEgdHlwZSBwYXJhbWV0ZXIgdG8gYHJlcXVlc3QoKWAuXG4gICAgICpcbiAgICAgKiBUaGUgYG9ic2VydmVgIHZhbHVlIGRldGVybWluZXMgdGhlIHJldHVybiB0eXBlIG9mIGByZXF1ZXN0KClgLCBiYXNlZCBvbiB3aGF0XG4gICAgICogdGhlIGNvbnN1bWVyIGlzIGludGVyZXN0ZWQgaW4gb2JzZXJ2aW5nLiBBIHZhbHVlIG9mIGBldmVudHNgIHdpbGwgcmV0dXJuIGFuXG4gICAgICogYE9ic2VydmFibGU8SHR0cEV2ZW50PmAgcmVwcmVzZW50aW5nIHRoZSByYXcgYEh0dHBFdmVudGAgc3RyZWFtLFxuICAgICAqIGluY2x1ZGluZyBwcm9ncmVzcyBldmVudHMgYnkgZGVmYXVsdC4gQSB2YWx1ZSBvZiBgcmVzcG9uc2VgIHdpbGwgcmV0dXJuIGFuXG4gICAgICogYE9ic2VydmFibGU8SHR0cFJlc3BvbnNlPFQ+PmAgd2hlcmUgdGhlIGBUYCBwYXJhbWV0ZXIgb2YgYEh0dHBSZXNwb25zZWBcbiAgICAgKiBkZXBlbmRzIG9uIHRoZSBgcmVzcG9uc2VUeXBlYCBhbmQgYW55IG9wdGlvbmFsbHkgcHJvdmlkZWQgdHlwZSBwYXJhbWV0ZXIuXG4gICAgICogQSB2YWx1ZSBvZiBgYm9keWAgd2lsbCByZXR1cm4gYW4gYE9ic2VydmFibGU8VD5gIHdpdGggdGhlIHNhbWUgYFRgIGJvZHkgdHlwZS5cbiAgICAgKiBAcGFyYW0gez99IGZpcnN0XG4gICAgICogQHBhcmFtIHs/PX0gdXJsXG4gICAgICogQHBhcmFtIHs/PX0gb3B0aW9uc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgSHR0cENsaWVudC5wcm90b3R5cGUucmVxdWVzdCA9IC8qKlxuICAgICAqIENvbnN0cnVjdHMgYW4gYE9ic2VydmFibGVgIGZvciBhIHBhcnRpY3VsYXIgSFRUUCByZXF1ZXN0IHRoYXQsIHdoZW4gc3Vic2NyaWJlZCxcbiAgICAgKiBmaXJlcyB0aGUgcmVxdWVzdCB0aHJvdWdoIHRoZSBjaGFpbiBvZiByZWdpc3RlcmVkIGludGVyY2VwdG9ycyBhbmQgb24gdG8gdGhlXG4gICAgICogc2VydmVyLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgY2FuIGJlIGNhbGxlZCBpbiBvbmUgb2YgdHdvIHdheXMuIEVpdGhlciBhbiBgSHR0cFJlcXVlc3RgXG4gICAgICogaW5zdGFuY2UgY2FuIGJlIHBhc3NlZCBkaXJlY3RseSBhcyB0aGUgb25seSBwYXJhbWV0ZXIsIG9yIGEgbWV0aG9kIGNhbiBiZVxuICAgICAqIHBhc3NlZCBhcyB0aGUgZmlyc3QgcGFyYW1ldGVyLCBhIHN0cmluZyBVUkwgYXMgdGhlIHNlY29uZCwgYW5kIGFuXG4gICAgICogb3B0aW9ucyBoYXNoIGFzIHRoZSB0aGlyZC5cbiAgICAgKlxuICAgICAqIElmIGEgYEh0dHBSZXF1ZXN0YCBvYmplY3QgaXMgcGFzc2VkIGRpcmVjdGx5LCBhbiBgT2JzZXJ2YWJsZWAgb2YgdGhlXG4gICAgICogcmF3IGBIdHRwRXZlbnRgIHN0cmVhbSB3aWxsIGJlIHJldHVybmVkLlxuICAgICAqXG4gICAgICogSWYgYSByZXF1ZXN0IGlzIGluc3RlYWQgYnVpbHQgYnkgcHJvdmlkaW5nIGEgVVJMLCB0aGUgb3B0aW9ucyBvYmplY3RcbiAgICAgKiBkZXRlcm1pbmVzIHRoZSByZXR1cm4gdHlwZSBvZiBgcmVxdWVzdCgpYC4gSW4gYWRkaXRpb24gdG8gY29uZmlndXJpbmdcbiAgICAgKiByZXF1ZXN0IHBhcmFtZXRlcnMgc3VjaCBhcyB0aGUgb3V0Z29pbmcgaGVhZGVycyBhbmQvb3IgdGhlIGJvZHksIHRoZSBvcHRpb25zXG4gICAgICogaGFzaCBzcGVjaWZpZXMgdHdvIGtleSBwaWVjZXMgb2YgaW5mb3JtYXRpb24gYWJvdXQgdGhlIHJlcXVlc3Q6IHRoZVxuICAgICAqIGByZXNwb25zZVR5cGVgIGFuZCB3aGF0IHRvIGBvYnNlcnZlYC5cbiAgICAgKlxuICAgICAqIFRoZSBgcmVzcG9uc2VUeXBlYCB2YWx1ZSBkZXRlcm1pbmVzIGhvdyBhIHN1Y2Nlc3NmdWwgcmVzcG9uc2UgYm9keSB3aWxsIGJlXG4gICAgICogcGFyc2VkLiBJZiBgcmVzcG9uc2VUeXBlYCBpcyB0aGUgZGVmYXVsdCBganNvbmAsIGEgdHlwZSBpbnRlcmZhY2UgZm9yIHRoZVxuICAgICAqIHJlc3VsdGluZyBvYmplY3QgbWF5IGJlIHBhc3NlZCBhcyBhIHR5cGUgcGFyYW1ldGVyIHRvIGByZXF1ZXN0KClgLlxuICAgICAqXG4gICAgICogVGhlIGBvYnNlcnZlYCB2YWx1ZSBkZXRlcm1pbmVzIHRoZSByZXR1cm4gdHlwZSBvZiBgcmVxdWVzdCgpYCwgYmFzZWQgb24gd2hhdFxuICAgICAqIHRoZSBjb25zdW1lciBpcyBpbnRlcmVzdGVkIGluIG9ic2VydmluZy4gQSB2YWx1ZSBvZiBgZXZlbnRzYCB3aWxsIHJldHVybiBhblxuICAgICAqIGBPYnNlcnZhYmxlPEh0dHBFdmVudD5gIHJlcHJlc2VudGluZyB0aGUgcmF3IGBIdHRwRXZlbnRgIHN0cmVhbSxcbiAgICAgKiBpbmNsdWRpbmcgcHJvZ3Jlc3MgZXZlbnRzIGJ5IGRlZmF1bHQuIEEgdmFsdWUgb2YgYHJlc3BvbnNlYCB3aWxsIHJldHVybiBhblxuICAgICAqIGBPYnNlcnZhYmxlPEh0dHBSZXNwb25zZTxUPj5gIHdoZXJlIHRoZSBgVGAgcGFyYW1ldGVyIG9mIGBIdHRwUmVzcG9uc2VgXG4gICAgICogZGVwZW5kcyBvbiB0aGUgYHJlc3BvbnNlVHlwZWAgYW5kIGFueSBvcHRpb25hbGx5IHByb3ZpZGVkIHR5cGUgcGFyYW1ldGVyLlxuICAgICAqIEEgdmFsdWUgb2YgYGJvZHlgIHdpbGwgcmV0dXJuIGFuIGBPYnNlcnZhYmxlPFQ+YCB3aXRoIHRoZSBzYW1lIGBUYCBib2R5IHR5cGUuXG4gICAgICogQHBhcmFtIHs/fSBmaXJzdFxuICAgICAqIEBwYXJhbSB7Pz19IHVybFxuICAgICAqIEBwYXJhbSB7Pz19IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChmaXJzdCwgdXJsLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlcTtcbiAgICAgICAgLy8gRmlyc3RseSwgY2hlY2sgd2hldGhlciB0aGUgcHJpbWFyeSBhcmd1bWVudCBpcyBhbiBpbnN0YW5jZSBvZiBgSHR0cFJlcXVlc3RgLlxuICAgICAgICBpZiAoZmlyc3QgaW5zdGFuY2VvZiBIdHRwUmVxdWVzdCkge1xuICAgICAgICAgICAgLy8gSXQgaXMuIFRoZSBvdGhlciBhcmd1bWVudHMgbXVzdCBiZSB1bmRlZmluZWQgKHBlciB0aGUgc2lnbmF0dXJlcykgYW5kIGNhbiBiZVxuICAgICAgICAgICAgLy8gaWdub3JlZC5cbiAgICAgICAgICAgIHJlcSA9IC8qKiBAdHlwZSB7P30gKi8gKGZpcnN0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIEl0J3MgYSBzdHJpbmcsIHNvIGl0IHJlcHJlc2VudHMgYSBVUkwuIENvbnN0cnVjdCBhIHJlcXVlc3QgYmFzZWQgb24gaXQsXG4gICAgICAgICAgICAvLyBhbmQgaW5jb3Jwb3JhdGUgdGhlIHJlbWFpbmluZyBhcmd1bWVudHMgKGFzc3VtaW5nIEdFVCB1bmxlc3MgYSBtZXRob2QgaXNcbiAgICAgICAgICAgIC8vIHByb3ZpZGVkLlxuICAgICAgICAgICAgLy8gRmlndXJlIG91dCB0aGUgaGVhZGVycy5cbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGhlYWRlcnMgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAoISFvcHRpb25zLmhlYWRlcnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmhlYWRlcnMgaW5zdGFuY2VvZiBIdHRwSGVhZGVycykge1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzID0gb3B0aW9ucy5oZWFkZXJzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVycyA9IG5ldyBIdHRwSGVhZGVycyhvcHRpb25zLmhlYWRlcnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFNvcnQgb3V0IHBhcmFtZXRlcnMuXG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwYXJhbXMgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAoISFvcHRpb25zLnBhcmFtcykge1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnBhcmFtcyBpbnN0YW5jZW9mIEh0dHBQYXJhbXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zID0gb3B0aW9ucy5wYXJhbXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwYXJhbXMgPSBuZXcgSHR0cFBhcmFtcyh7IGZyb21PYmplY3Q6IG9wdGlvbnMucGFyYW1zIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENvbnN0cnVjdCB0aGUgcmVxdWVzdC5cbiAgICAgICAgICAgIHJlcSA9IG5ldyBIdHRwUmVxdWVzdChmaXJzdCwgLyoqIEB0eXBlIHs/fSAqLyAoKHVybCkpLCBvcHRpb25zLmJvZHkgfHwgbnVsbCwge1xuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlcnMsXG4gICAgICAgICAgICAgICAgcGFyYW1zOiBwYXJhbXMsXG4gICAgICAgICAgICAgICAgcmVwb3J0UHJvZ3Jlc3M6IG9wdGlvbnMucmVwb3J0UHJvZ3Jlc3MsXG4gICAgICAgICAgICAgICAgLy8gQnkgZGVmYXVsdCwgSlNPTiBpcyBhc3N1bWVkIHRvIGJlIHJldHVybmVkIGZvciBhbGwgY2FsbHMuXG4gICAgICAgICAgICAgICAgcmVzcG9uc2VUeXBlOiBvcHRpb25zLnJlc3BvbnNlVHlwZSB8fCAnanNvbicsXG4gICAgICAgICAgICAgICAgd2l0aENyZWRlbnRpYWxzOiBvcHRpb25zLndpdGhDcmVkZW50aWFscyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIFN0YXJ0IHdpdGggYW4gT2JzZXJ2YWJsZS5vZigpIHRoZSBpbml0aWFsIHJlcXVlc3QsIGFuZCBydW4gdGhlIGhhbmRsZXIgKHdoaWNoXG4gICAgICAgIC8vIGluY2x1ZGVzIGFsbCBpbnRlcmNlcHRvcnMpIGluc2lkZSBhIGNvbmNhdE1hcCgpLiBUaGlzIHdheSwgdGhlIGhhbmRsZXIgcnVuc1xuICAgICAgICAvLyBpbnNpZGUgYW4gT2JzZXJ2YWJsZSBjaGFpbiwgd2hpY2ggY2F1c2VzIGludGVyY2VwdG9ycyB0byBiZSByZS1ydW4gb24gZXZlcnlcbiAgICAgICAgLy8gc3Vic2NyaXB0aW9uICh0aGlzIGFsc28gbWFrZXMgcmV0cmllcyByZS1ydW4gdGhlIGhhbmRsZXIsIGluY2x1ZGluZyBpbnRlcmNlcHRvcnMpLlxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBldmVudHMkID0gcnhqc19vcGVyYXRvcl9jb25jYXRNYXAuY29uY2F0TWFwLmNhbGwocnhqc19vYnNlcnZhYmxlX29mLm9mKHJlcSksIGZ1bmN0aW9uIChyZXEpIHsgcmV0dXJuIF90aGlzLmhhbmRsZXIuaGFuZGxlKHJlcSk7IH0pO1xuICAgICAgICAvLyBJZiBjb21pbmcgdmlhIHRoZSBBUEkgc2lnbmF0dXJlIHdoaWNoIGFjY2VwdHMgYSBwcmV2aW91c2x5IGNvbnN0cnVjdGVkIEh0dHBSZXF1ZXN0LFxuICAgICAgICAvLyB0aGUgb25seSBvcHRpb24gaXMgdG8gZ2V0IHRoZSBldmVudCBzdHJlYW0uIE90aGVyd2lzZSwgcmV0dXJuIHRoZSBldmVudCBzdHJlYW0gaWZcbiAgICAgICAgLy8gdGhhdCBpcyB3aGF0IHdhcyByZXF1ZXN0ZWQuXG4gICAgICAgIGlmIChmaXJzdCBpbnN0YW5jZW9mIEh0dHBSZXF1ZXN0IHx8IG9wdGlvbnMub2JzZXJ2ZSA9PT0gJ2V2ZW50cycpIHtcbiAgICAgICAgICAgIHJldHVybiBldmVudHMkO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRoZSByZXF1ZXN0ZWQgc3RyZWFtIGNvbnRhaW5zIGVpdGhlciB0aGUgZnVsbCByZXNwb25zZSBvciB0aGUgYm9keS4gSW4gZWl0aGVyXG4gICAgICAgIC8vIGNhc2UsIHRoZSBmaXJzdCBzdGVwIGlzIHRvIGZpbHRlciB0aGUgZXZlbnQgc3RyZWFtIHRvIGV4dHJhY3QgYSBzdHJlYW0gb2ZcbiAgICAgICAgLy8gcmVzcG9uc2VzKHMpLlxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZXMkID0gcnhqc19vcGVyYXRvcl9maWx0ZXIuZmlsdGVyLmNhbGwoZXZlbnRzJCwgZnVuY3Rpb24gKGV2ZW50KSB7IHJldHVybiBldmVudCBpbnN0YW5jZW9mIEh0dHBSZXNwb25zZTsgfSk7XG4gICAgICAgIC8vIERlY2lkZSB3aGljaCBzdHJlYW0gdG8gcmV0dXJuLlxuICAgICAgICBzd2l0Y2ggKG9wdGlvbnMub2JzZXJ2ZSB8fCAnYm9keScpIHtcbiAgICAgICAgICAgIGNhc2UgJ2JvZHknOlxuICAgICAgICAgICAgICAgIC8vIFRoZSByZXF1ZXN0ZWQgc3RyZWFtIGlzIHRoZSBib2R5LiBNYXAgdGhlIHJlc3BvbnNlIHN0cmVhbSB0byB0aGUgcmVzcG9uc2VcbiAgICAgICAgICAgICAgICAvLyBib2R5LiBUaGlzIGNvdWxkIGJlIGRvbmUgbW9yZSBzaW1wbHksIGJ1dCBhIG1pc2JlaGF2aW5nIGludGVyY2VwdG9yIG1pZ2h0XG4gICAgICAgICAgICAgICAgLy8gdHJhbnNmb3JtIHRoZSByZXNwb25zZSBib2R5IGludG8gYSBkaWZmZXJlbnQgZm9ybWF0IGFuZCBpZ25vcmUgdGhlIHJlcXVlc3RlZFxuICAgICAgICAgICAgICAgIC8vIHJlc3BvbnNlVHlwZS4gR3VhcmQgYWdhaW5zdCB0aGlzIGJ5IHZhbGlkYXRpbmcgdGhhdCB0aGUgcmVzcG9uc2UgaXMgb2YgdGhlXG4gICAgICAgICAgICAgICAgLy8gcmVxdWVzdGVkIHR5cGUuXG4gICAgICAgICAgICAgICAgc3dpdGNoIChyZXEucmVzcG9uc2VUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2FycmF5YnVmZmVyJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByeGpzX29wZXJhdG9yX21hcC5tYXAuY2FsbChyZXMkLCBmdW5jdGlvbiAocmVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVmFsaWRhdGUgdGhhdCB0aGUgYm9keSBpcyBhbiBBcnJheUJ1ZmZlci5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzLmJvZHkgIT09IG51bGwgJiYgIShyZXMuYm9keSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Jlc3BvbnNlIGlzIG5vdCBhbiBBcnJheUJ1ZmZlci4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlcy5ib2R5O1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2Jsb2InOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJ4anNfb3BlcmF0b3JfbWFwLm1hcC5jYWxsKHJlcyQsIGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBWYWxpZGF0ZSB0aGF0IHRoZSBib2R5IGlzIGEgQmxvYi5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzLmJvZHkgIT09IG51bGwgJiYgIShyZXMuYm9keSBpbnN0YW5jZW9mIEJsb2IpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUmVzcG9uc2UgaXMgbm90IGEgQmxvYi4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlcy5ib2R5O1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3RleHQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJ4anNfb3BlcmF0b3JfbWFwLm1hcC5jYWxsKHJlcyQsIGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBWYWxpZGF0ZSB0aGF0IHRoZSBib2R5IGlzIGEgc3RyaW5nLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXMuYm9keSAhPT0gbnVsbCAmJiB0eXBlb2YgcmVzLmJvZHkgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUmVzcG9uc2UgaXMgbm90IGEgc3RyaW5nLicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzLmJvZHk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnanNvbic6XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBObyB2YWxpZGF0aW9uIG5lZWRlZCBmb3IgSlNPTiByZXNwb25zZXMsIGFzIHRoZXkgY2FuIGJlIG9mIGFueSB0eXBlLlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJ4anNfb3BlcmF0b3JfbWFwLm1hcC5jYWxsKHJlcyQsIGZ1bmN0aW9uIChyZXMpIHsgcmV0dXJuIHJlcy5ib2R5OyB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdyZXNwb25zZSc6XG4gICAgICAgICAgICAgICAgLy8gVGhlIHJlc3BvbnNlIHN0cmVhbSB3YXMgcmVxdWVzdGVkIGRpcmVjdGx5LCBzbyByZXR1cm4gaXQuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcyQ7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIC8vIEd1YXJkIGFnYWluc3QgbmV3IGZ1dHVyZSBvYnNlcnZlIHR5cGVzIGJlaW5nIGFkZGVkLlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVucmVhY2hhYmxlOiB1bmhhbmRsZWQgb2JzZXJ2ZSB0eXBlIFwiICsgb3B0aW9ucy5vYnNlcnZlICsgXCJ9XCIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RzIGFuIGBPYnNlcnZhYmxlYCB3aGljaCwgd2hlbiBzdWJzY3JpYmVkLCB3aWxsIGNhdXNlIHRoZSBjb25maWd1cmVkXG4gICAgICogREVMRVRFIHJlcXVlc3QgdG8gYmUgZXhlY3V0ZWQgb24gdGhlIHNlcnZlci4gU2VlIHRoZSBpbmRpdmlkdWFsIG92ZXJsb2FkcyBmb3JcbiAgICAgKiBkZXRhaWxzIG9mIGBkZWxldGUoKWAncyByZXR1cm4gdHlwZSBiYXNlZCBvbiB0aGUgcHJvdmlkZWQgb3B0aW9ucy5cbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RzIGFuIGBPYnNlcnZhYmxlYCB3aGljaCwgd2hlbiBzdWJzY3JpYmVkLCB3aWxsIGNhdXNlIHRoZSBjb25maWd1cmVkXG4gICAgICogREVMRVRFIHJlcXVlc3QgdG8gYmUgZXhlY3V0ZWQgb24gdGhlIHNlcnZlci4gU2VlIHRoZSBpbmRpdmlkdWFsIG92ZXJsb2FkcyBmb3JcbiAgICAgKiBkZXRhaWxzIG9mIGBkZWxldGUoKWAncyByZXR1cm4gdHlwZSBiYXNlZCBvbiB0aGUgcHJvdmlkZWQgb3B0aW9ucy5cbiAgICAgKiBAcGFyYW0gez99IHVybFxuICAgICAqIEBwYXJhbSB7Pz19IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEh0dHBDbGllbnQucHJvdG90eXBlLmRlbGV0ZSA9IC8qKlxuICAgICAqIENvbnN0cnVjdHMgYW4gYE9ic2VydmFibGVgIHdoaWNoLCB3aGVuIHN1YnNjcmliZWQsIHdpbGwgY2F1c2UgdGhlIGNvbmZpZ3VyZWRcbiAgICAgKiBERUxFVEUgcmVxdWVzdCB0byBiZSBleGVjdXRlZCBvbiB0aGUgc2VydmVyLiBTZWUgdGhlIGluZGl2aWR1YWwgb3ZlcmxvYWRzIGZvclxuICAgICAqIGRldGFpbHMgb2YgYGRlbGV0ZSgpYCdzIHJldHVybiB0eXBlIGJhc2VkIG9uIHRoZSBwcm92aWRlZCBvcHRpb25zLlxuICAgICAqIEBwYXJhbSB7P30gdXJsXG4gICAgICogQHBhcmFtIHs/PX0gb3B0aW9uc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKHVybCwgb3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KCdERUxFVEUnLCB1cmwsIC8qKiBAdHlwZSB7P30gKi8gKG9wdGlvbnMpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdHMgYW4gYE9ic2VydmFibGVgIHdoaWNoLCB3aGVuIHN1YnNjcmliZWQsIHdpbGwgY2F1c2UgdGhlIGNvbmZpZ3VyZWRcbiAgICAgKiBHRVQgcmVxdWVzdCB0byBiZSBleGVjdXRlZCBvbiB0aGUgc2VydmVyLiBTZWUgdGhlIGluZGl2aWR1YWwgb3ZlcmxvYWRzIGZvclxuICAgICAqIGRldGFpbHMgb2YgYGdldCgpYCdzIHJldHVybiB0eXBlIGJhc2VkIG9uIHRoZSBwcm92aWRlZCBvcHRpb25zLlxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdHMgYW4gYE9ic2VydmFibGVgIHdoaWNoLCB3aGVuIHN1YnNjcmliZWQsIHdpbGwgY2F1c2UgdGhlIGNvbmZpZ3VyZWRcbiAgICAgKiBHRVQgcmVxdWVzdCB0byBiZSBleGVjdXRlZCBvbiB0aGUgc2VydmVyLiBTZWUgdGhlIGluZGl2aWR1YWwgb3ZlcmxvYWRzIGZvclxuICAgICAqIGRldGFpbHMgb2YgYGdldCgpYCdzIHJldHVybiB0eXBlIGJhc2VkIG9uIHRoZSBwcm92aWRlZCBvcHRpb25zLlxuICAgICAqIEBwYXJhbSB7P30gdXJsXG4gICAgICogQHBhcmFtIHs/PX0gb3B0aW9uc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgSHR0cENsaWVudC5wcm90b3R5cGUuZ2V0ID0gLyoqXG4gICAgICogQ29uc3RydWN0cyBhbiBgT2JzZXJ2YWJsZWAgd2hpY2gsIHdoZW4gc3Vic2NyaWJlZCwgd2lsbCBjYXVzZSB0aGUgY29uZmlndXJlZFxuICAgICAqIEdFVCByZXF1ZXN0IHRvIGJlIGV4ZWN1dGVkIG9uIHRoZSBzZXJ2ZXIuIFNlZSB0aGUgaW5kaXZpZHVhbCBvdmVybG9hZHMgZm9yXG4gICAgICogZGV0YWlscyBvZiBgZ2V0KClgJ3MgcmV0dXJuIHR5cGUgYmFzZWQgb24gdGhlIHByb3ZpZGVkIG9wdGlvbnMuXG4gICAgICogQHBhcmFtIHs/fSB1cmxcbiAgICAgKiBAcGFyYW0gez89fSBvcHRpb25zXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAodXJsLCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3QoJ0dFVCcsIHVybCwgLyoqIEB0eXBlIHs/fSAqLyAob3B0aW9ucykpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0cyBhbiBgT2JzZXJ2YWJsZWAgd2hpY2gsIHdoZW4gc3Vic2NyaWJlZCwgd2lsbCBjYXVzZSB0aGUgY29uZmlndXJlZFxuICAgICAqIEhFQUQgcmVxdWVzdCB0byBiZSBleGVjdXRlZCBvbiB0aGUgc2VydmVyLiBTZWUgdGhlIGluZGl2aWR1YWwgb3ZlcmxvYWRzIGZvclxuICAgICAqIGRldGFpbHMgb2YgYGhlYWQoKWAncyByZXR1cm4gdHlwZSBiYXNlZCBvbiB0aGUgcHJvdmlkZWQgb3B0aW9ucy5cbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RzIGFuIGBPYnNlcnZhYmxlYCB3aGljaCwgd2hlbiBzdWJzY3JpYmVkLCB3aWxsIGNhdXNlIHRoZSBjb25maWd1cmVkXG4gICAgICogSEVBRCByZXF1ZXN0IHRvIGJlIGV4ZWN1dGVkIG9uIHRoZSBzZXJ2ZXIuIFNlZSB0aGUgaW5kaXZpZHVhbCBvdmVybG9hZHMgZm9yXG4gICAgICogZGV0YWlscyBvZiBgaGVhZCgpYCdzIHJldHVybiB0eXBlIGJhc2VkIG9uIHRoZSBwcm92aWRlZCBvcHRpb25zLlxuICAgICAqIEBwYXJhbSB7P30gdXJsXG4gICAgICogQHBhcmFtIHs/PX0gb3B0aW9uc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgSHR0cENsaWVudC5wcm90b3R5cGUuaGVhZCA9IC8qKlxuICAgICAqIENvbnN0cnVjdHMgYW4gYE9ic2VydmFibGVgIHdoaWNoLCB3aGVuIHN1YnNjcmliZWQsIHdpbGwgY2F1c2UgdGhlIGNvbmZpZ3VyZWRcbiAgICAgKiBIRUFEIHJlcXVlc3QgdG8gYmUgZXhlY3V0ZWQgb24gdGhlIHNlcnZlci4gU2VlIHRoZSBpbmRpdmlkdWFsIG92ZXJsb2FkcyBmb3JcbiAgICAgKiBkZXRhaWxzIG9mIGBoZWFkKClgJ3MgcmV0dXJuIHR5cGUgYmFzZWQgb24gdGhlIHByb3ZpZGVkIG9wdGlvbnMuXG4gICAgICogQHBhcmFtIHs/fSB1cmxcbiAgICAgKiBAcGFyYW0gez89fSBvcHRpb25zXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAodXJsLCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3QoJ0hFQUQnLCB1cmwsIC8qKiBAdHlwZSB7P30gKi8gKG9wdGlvbnMpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdHMgYW4gYE9ic2VydmFibGVgIHdoaWNoLCB3aGVuIHN1YnNjcmliZWQsIHdpbGwgY2F1c2UgYSByZXF1ZXN0XG4gICAgICogd2l0aCB0aGUgc3BlY2lhbCBtZXRob2QgYEpTT05QYCB0byBiZSBkaXNwYXRjaGVkIHZpYSB0aGUgaW50ZXJjZXB0b3IgcGlwZWxpbmUuXG4gICAgICpcbiAgICAgKiBBIHN1aXRhYmxlIGludGVyY2VwdG9yIG11c3QgYmUgaW5zdGFsbGVkIChlLmcuIHZpYSB0aGUgYEh0dHBDbGllbnRKc29ucE1vZHVsZWApLlxuICAgICAqIElmIG5vIHN1Y2ggaW50ZXJjZXB0b3IgaXMgcmVhY2hlZCwgdGhlbiB0aGUgYEpTT05QYCByZXF1ZXN0IHdpbGwgbGlrZWx5IGJlXG4gICAgICogcmVqZWN0ZWQgYnkgdGhlIGNvbmZpZ3VyZWQgYmFja2VuZC5cbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RzIGFuIGBPYnNlcnZhYmxlYCB3aGljaCwgd2hlbiBzdWJzY3JpYmVkLCB3aWxsIGNhdXNlIGEgcmVxdWVzdFxuICAgICAqIHdpdGggdGhlIHNwZWNpYWwgbWV0aG9kIGBKU09OUGAgdG8gYmUgZGlzcGF0Y2hlZCB2aWEgdGhlIGludGVyY2VwdG9yIHBpcGVsaW5lLlxuICAgICAqXG4gICAgICogQSBzdWl0YWJsZSBpbnRlcmNlcHRvciBtdXN0IGJlIGluc3RhbGxlZCAoZS5nLiB2aWEgdGhlIGBIdHRwQ2xpZW50SnNvbnBNb2R1bGVgKS5cbiAgICAgKiBJZiBubyBzdWNoIGludGVyY2VwdG9yIGlzIHJlYWNoZWQsIHRoZW4gdGhlIGBKU09OUGAgcmVxdWVzdCB3aWxsIGxpa2VseSBiZVxuICAgICAqIHJlamVjdGVkIGJ5IHRoZSBjb25maWd1cmVkIGJhY2tlbmQuXG4gICAgICogQHRlbXBsYXRlIFRcbiAgICAgKiBAcGFyYW0gez99IHVybFxuICAgICAqIEBwYXJhbSB7P30gY2FsbGJhY2tQYXJhbVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgSHR0cENsaWVudC5wcm90b3R5cGUuanNvbnAgPSAvKipcbiAgICAgKiBDb25zdHJ1Y3RzIGFuIGBPYnNlcnZhYmxlYCB3aGljaCwgd2hlbiBzdWJzY3JpYmVkLCB3aWxsIGNhdXNlIGEgcmVxdWVzdFxuICAgICAqIHdpdGggdGhlIHNwZWNpYWwgbWV0aG9kIGBKU09OUGAgdG8gYmUgZGlzcGF0Y2hlZCB2aWEgdGhlIGludGVyY2VwdG9yIHBpcGVsaW5lLlxuICAgICAqXG4gICAgICogQSBzdWl0YWJsZSBpbnRlcmNlcHRvciBtdXN0IGJlIGluc3RhbGxlZCAoZS5nLiB2aWEgdGhlIGBIdHRwQ2xpZW50SnNvbnBNb2R1bGVgKS5cbiAgICAgKiBJZiBubyBzdWNoIGludGVyY2VwdG9yIGlzIHJlYWNoZWQsIHRoZW4gdGhlIGBKU09OUGAgcmVxdWVzdCB3aWxsIGxpa2VseSBiZVxuICAgICAqIHJlamVjdGVkIGJ5IHRoZSBjb25maWd1cmVkIGJhY2tlbmQuXG4gICAgICogQHRlbXBsYXRlIFRcbiAgICAgKiBAcGFyYW0gez99IHVybFxuICAgICAqIEBwYXJhbSB7P30gY2FsbGJhY2tQYXJhbVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKHVybCwgY2FsbGJhY2tQYXJhbSkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KCdKU09OUCcsIHVybCwge1xuICAgICAgICAgICAgcGFyYW1zOiBuZXcgSHR0cFBhcmFtcygpLmFwcGVuZChjYWxsYmFja1BhcmFtLCAnSlNPTlBfQ0FMTEJBQ0snKSxcbiAgICAgICAgICAgIG9ic2VydmU6ICdib2R5JyxcbiAgICAgICAgICAgIHJlc3BvbnNlVHlwZTogJ2pzb24nLFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdHMgYW4gYE9ic2VydmFibGVgIHdoaWNoLCB3aGVuIHN1YnNjcmliZWQsIHdpbGwgY2F1c2UgdGhlIGNvbmZpZ3VyZWRcbiAgICAgKiBPUFRJT05TIHJlcXVlc3QgdG8gYmUgZXhlY3V0ZWQgb24gdGhlIHNlcnZlci4gU2VlIHRoZSBpbmRpdmlkdWFsIG92ZXJsb2FkcyBmb3JcbiAgICAgKiBkZXRhaWxzIG9mIGBvcHRpb25zKClgJ3MgcmV0dXJuIHR5cGUgYmFzZWQgb24gdGhlIHByb3ZpZGVkIG9wdGlvbnMuXG4gICAgICovXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0cyBhbiBgT2JzZXJ2YWJsZWAgd2hpY2gsIHdoZW4gc3Vic2NyaWJlZCwgd2lsbCBjYXVzZSB0aGUgY29uZmlndXJlZFxuICAgICAqIE9QVElPTlMgcmVxdWVzdCB0byBiZSBleGVjdXRlZCBvbiB0aGUgc2VydmVyLiBTZWUgdGhlIGluZGl2aWR1YWwgb3ZlcmxvYWRzIGZvclxuICAgICAqIGRldGFpbHMgb2YgYG9wdGlvbnMoKWAncyByZXR1cm4gdHlwZSBiYXNlZCBvbiB0aGUgcHJvdmlkZWQgb3B0aW9ucy5cbiAgICAgKiBAcGFyYW0gez99IHVybFxuICAgICAqIEBwYXJhbSB7Pz19IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEh0dHBDbGllbnQucHJvdG90eXBlLm9wdGlvbnMgPSAvKipcbiAgICAgKiBDb25zdHJ1Y3RzIGFuIGBPYnNlcnZhYmxlYCB3aGljaCwgd2hlbiBzdWJzY3JpYmVkLCB3aWxsIGNhdXNlIHRoZSBjb25maWd1cmVkXG4gICAgICogT1BUSU9OUyByZXF1ZXN0IHRvIGJlIGV4ZWN1dGVkIG9uIHRoZSBzZXJ2ZXIuIFNlZSB0aGUgaW5kaXZpZHVhbCBvdmVybG9hZHMgZm9yXG4gICAgICogZGV0YWlscyBvZiBgb3B0aW9ucygpYCdzIHJldHVybiB0eXBlIGJhc2VkIG9uIHRoZSBwcm92aWRlZCBvcHRpb25zLlxuICAgICAqIEBwYXJhbSB7P30gdXJsXG4gICAgICogQHBhcmFtIHs/PX0gb3B0aW9uc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKHVybCwgb3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KCdPUFRJT05TJywgdXJsLCAvKiogQHR5cGUgez99ICovIChvcHRpb25zKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RzIGFuIGBPYnNlcnZhYmxlYCB3aGljaCwgd2hlbiBzdWJzY3JpYmVkLCB3aWxsIGNhdXNlIHRoZSBjb25maWd1cmVkXG4gICAgICogUEFUQ0ggcmVxdWVzdCB0byBiZSBleGVjdXRlZCBvbiB0aGUgc2VydmVyLiBTZWUgdGhlIGluZGl2aWR1YWwgb3ZlcmxvYWRzIGZvclxuICAgICAqIGRldGFpbHMgb2YgYHBhdGNoKClgJ3MgcmV0dXJuIHR5cGUgYmFzZWQgb24gdGhlIHByb3ZpZGVkIG9wdGlvbnMuXG4gICAgICovXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0cyBhbiBgT2JzZXJ2YWJsZWAgd2hpY2gsIHdoZW4gc3Vic2NyaWJlZCwgd2lsbCBjYXVzZSB0aGUgY29uZmlndXJlZFxuICAgICAqIFBBVENIIHJlcXVlc3QgdG8gYmUgZXhlY3V0ZWQgb24gdGhlIHNlcnZlci4gU2VlIHRoZSBpbmRpdmlkdWFsIG92ZXJsb2FkcyBmb3JcbiAgICAgKiBkZXRhaWxzIG9mIGBwYXRjaCgpYCdzIHJldHVybiB0eXBlIGJhc2VkIG9uIHRoZSBwcm92aWRlZCBvcHRpb25zLlxuICAgICAqIEBwYXJhbSB7P30gdXJsXG4gICAgICogQHBhcmFtIHs/fSBib2R5XG4gICAgICogQHBhcmFtIHs/PX0gb3B0aW9uc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgSHR0cENsaWVudC5wcm90b3R5cGUucGF0Y2ggPSAvKipcbiAgICAgKiBDb25zdHJ1Y3RzIGFuIGBPYnNlcnZhYmxlYCB3aGljaCwgd2hlbiBzdWJzY3JpYmVkLCB3aWxsIGNhdXNlIHRoZSBjb25maWd1cmVkXG4gICAgICogUEFUQ0ggcmVxdWVzdCB0byBiZSBleGVjdXRlZCBvbiB0aGUgc2VydmVyLiBTZWUgdGhlIGluZGl2aWR1YWwgb3ZlcmxvYWRzIGZvclxuICAgICAqIGRldGFpbHMgb2YgYHBhdGNoKClgJ3MgcmV0dXJuIHR5cGUgYmFzZWQgb24gdGhlIHByb3ZpZGVkIG9wdGlvbnMuXG4gICAgICogQHBhcmFtIHs/fSB1cmxcbiAgICAgKiBAcGFyYW0gez99IGJvZHlcbiAgICAgKiBAcGFyYW0gez89fSBvcHRpb25zXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAodXJsLCBib2R5LCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3QoJ1BBVENIJywgdXJsLCBhZGRCb2R5KG9wdGlvbnMsIGJvZHkpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdHMgYW4gYE9ic2VydmFibGVgIHdoaWNoLCB3aGVuIHN1YnNjcmliZWQsIHdpbGwgY2F1c2UgdGhlIGNvbmZpZ3VyZWRcbiAgICAgKiBQT1NUIHJlcXVlc3QgdG8gYmUgZXhlY3V0ZWQgb24gdGhlIHNlcnZlci4gU2VlIHRoZSBpbmRpdmlkdWFsIG92ZXJsb2FkcyBmb3JcbiAgICAgKiBkZXRhaWxzIG9mIGBwb3N0KClgJ3MgcmV0dXJuIHR5cGUgYmFzZWQgb24gdGhlIHByb3ZpZGVkIG9wdGlvbnMuXG4gICAgICovXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0cyBhbiBgT2JzZXJ2YWJsZWAgd2hpY2gsIHdoZW4gc3Vic2NyaWJlZCwgd2lsbCBjYXVzZSB0aGUgY29uZmlndXJlZFxuICAgICAqIFBPU1QgcmVxdWVzdCB0byBiZSBleGVjdXRlZCBvbiB0aGUgc2VydmVyLiBTZWUgdGhlIGluZGl2aWR1YWwgb3ZlcmxvYWRzIGZvclxuICAgICAqIGRldGFpbHMgb2YgYHBvc3QoKWAncyByZXR1cm4gdHlwZSBiYXNlZCBvbiB0aGUgcHJvdmlkZWQgb3B0aW9ucy5cbiAgICAgKiBAcGFyYW0gez99IHVybFxuICAgICAqIEBwYXJhbSB7P30gYm9keVxuICAgICAqIEBwYXJhbSB7Pz19IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEh0dHBDbGllbnQucHJvdG90eXBlLnBvc3QgPSAvKipcbiAgICAgKiBDb25zdHJ1Y3RzIGFuIGBPYnNlcnZhYmxlYCB3aGljaCwgd2hlbiBzdWJzY3JpYmVkLCB3aWxsIGNhdXNlIHRoZSBjb25maWd1cmVkXG4gICAgICogUE9TVCByZXF1ZXN0IHRvIGJlIGV4ZWN1dGVkIG9uIHRoZSBzZXJ2ZXIuIFNlZSB0aGUgaW5kaXZpZHVhbCBvdmVybG9hZHMgZm9yXG4gICAgICogZGV0YWlscyBvZiBgcG9zdCgpYCdzIHJldHVybiB0eXBlIGJhc2VkIG9uIHRoZSBwcm92aWRlZCBvcHRpb25zLlxuICAgICAqIEBwYXJhbSB7P30gdXJsXG4gICAgICogQHBhcmFtIHs/fSBib2R5XG4gICAgICogQHBhcmFtIHs/PX0gb3B0aW9uc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKHVybCwgYm9keSwgb3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KCdQT1NUJywgdXJsLCBhZGRCb2R5KG9wdGlvbnMsIGJvZHkpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdHMgYW4gYE9ic2VydmFibGVgIHdoaWNoLCB3aGVuIHN1YnNjcmliZWQsIHdpbGwgY2F1c2UgdGhlIGNvbmZpZ3VyZWRcbiAgICAgKiBQT1NUIHJlcXVlc3QgdG8gYmUgZXhlY3V0ZWQgb24gdGhlIHNlcnZlci4gU2VlIHRoZSBpbmRpdmlkdWFsIG92ZXJsb2FkcyBmb3JcbiAgICAgKiBkZXRhaWxzIG9mIGBwb3N0KClgJ3MgcmV0dXJuIHR5cGUgYmFzZWQgb24gdGhlIHByb3ZpZGVkIG9wdGlvbnMuXG4gICAgICovXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0cyBhbiBgT2JzZXJ2YWJsZWAgd2hpY2gsIHdoZW4gc3Vic2NyaWJlZCwgd2lsbCBjYXVzZSB0aGUgY29uZmlndXJlZFxuICAgICAqIFBPU1QgcmVxdWVzdCB0byBiZSBleGVjdXRlZCBvbiB0aGUgc2VydmVyLiBTZWUgdGhlIGluZGl2aWR1YWwgb3ZlcmxvYWRzIGZvclxuICAgICAqIGRldGFpbHMgb2YgYHBvc3QoKWAncyByZXR1cm4gdHlwZSBiYXNlZCBvbiB0aGUgcHJvdmlkZWQgb3B0aW9ucy5cbiAgICAgKiBAcGFyYW0gez99IHVybFxuICAgICAqIEBwYXJhbSB7P30gYm9keVxuICAgICAqIEBwYXJhbSB7Pz19IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEh0dHBDbGllbnQucHJvdG90eXBlLnB1dCA9IC8qKlxuICAgICAqIENvbnN0cnVjdHMgYW4gYE9ic2VydmFibGVgIHdoaWNoLCB3aGVuIHN1YnNjcmliZWQsIHdpbGwgY2F1c2UgdGhlIGNvbmZpZ3VyZWRcbiAgICAgKiBQT1NUIHJlcXVlc3QgdG8gYmUgZXhlY3V0ZWQgb24gdGhlIHNlcnZlci4gU2VlIHRoZSBpbmRpdmlkdWFsIG92ZXJsb2FkcyBmb3JcbiAgICAgKiBkZXRhaWxzIG9mIGBwb3N0KClgJ3MgcmV0dXJuIHR5cGUgYmFzZWQgb24gdGhlIHByb3ZpZGVkIG9wdGlvbnMuXG4gICAgICogQHBhcmFtIHs/fSB1cmxcbiAgICAgKiBAcGFyYW0gez99IGJvZHlcbiAgICAgKiBAcGFyYW0gez89fSBvcHRpb25zXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAodXJsLCBib2R5LCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3QoJ1BVVCcsIHVybCwgYWRkQm9keShvcHRpb25zLCBib2R5KSk7XG4gICAgfTtcbiAgICBIdHRwQ2xpZW50LmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3RhYmxlIH0sXG4gICAgXTtcbiAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICBIdHRwQ2xpZW50LmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgICAgICB7IHR5cGU6IEh0dHBIYW5kbGVyLCB9LFxuICAgIF07IH07XG4gICAgcmV0dXJuIEh0dHBDbGllbnQ7XG59KCkpO1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgYWRkZWQgYnkgdHNpY2tsZVxuICogQHN1cHByZXNzIHtjaGVja1R5cGVzfSBjaGVja2VkIGJ5IHRzY1xuICovXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vKipcbiAqIEludGVyY2VwdHMgYEh0dHBSZXF1ZXN0YCBhbmQgaGFuZGxlcyB0aGVtLlxuICpcbiAqIE1vc3QgaW50ZXJjZXB0b3JzIHdpbGwgdHJhbnNmb3JtIHRoZSBvdXRnb2luZyByZXF1ZXN0IGJlZm9yZSBwYXNzaW5nIGl0IHRvIHRoZVxuICogbmV4dCBpbnRlcmNlcHRvciBpbiB0aGUgY2hhaW4sIGJ5IGNhbGxpbmcgYG5leHQuaGFuZGxlKHRyYW5zZm9ybWVkUmVxKWAuXG4gKlxuICogSW4gcmFyZSBjYXNlcywgaW50ZXJjZXB0b3JzIG1heSB3aXNoIHRvIGNvbXBsZXRlbHkgaGFuZGxlIGEgcmVxdWVzdCB0aGVtc2VsdmVzLFxuICogYW5kIG5vdCBkZWxlZ2F0ZSB0byB0aGUgcmVtYWluZGVyIG9mIHRoZSBjaGFpbi4gVGhpcyBiZWhhdmlvciBpcyBhbGxvd2VkLlxuICpcbiAqIFxcQHN0YWJsZVxuICogQHJlY29yZFxuICovXG5cbi8qKlxuICogYEh0dHBIYW5kbGVyYCB3aGljaCBhcHBsaWVzIGFuIGBIdHRwSW50ZXJjZXB0b3JgIHRvIGFuIGBIdHRwUmVxdWVzdGAuXG4gKlxuICogXFxAc3RhYmxlXG4gKi9cbnZhciBIdHRwSW50ZXJjZXB0b3JIYW5kbGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBIdHRwSW50ZXJjZXB0b3JIYW5kbGVyKG5leHQsIGludGVyY2VwdG9yKSB7XG4gICAgICAgIHRoaXMubmV4dCA9IG5leHQ7XG4gICAgICAgIHRoaXMuaW50ZXJjZXB0b3IgPSBpbnRlcmNlcHRvcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSByZXFcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEh0dHBJbnRlcmNlcHRvckhhbmRsZXIucHJvdG90eXBlLmhhbmRsZSA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gcmVxXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAocmVxKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmludGVyY2VwdG9yLmludGVyY2VwdChyZXEsIHRoaXMubmV4dCk7XG4gICAgfTtcbiAgICByZXR1cm4gSHR0cEludGVyY2VwdG9ySGFuZGxlcjtcbn0oKSk7XG4vKipcbiAqIEEgbXVsdGktcHJvdmlkZXIgdG9rZW4gd2hpY2ggcmVwcmVzZW50cyB0aGUgYXJyYXkgb2YgYEh0dHBJbnRlcmNlcHRvcmBzIHRoYXRcbiAqIGFyZSByZWdpc3RlcmVkLlxuICpcbiAqIFxcQHN0YWJsZVxuICovXG52YXIgSFRUUF9JTlRFUkNFUFRPUlMgPSBuZXcgX2FuZ3VsYXJfY29yZS5JbmplY3Rpb25Ub2tlbignSFRUUF9JTlRFUkNFUFRPUlMnKTtcbnZhciBOb29wSW50ZXJjZXB0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE5vb3BJbnRlcmNlcHRvcigpIHtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSByZXFcbiAgICAgKiBAcGFyYW0gez99IG5leHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE5vb3BJbnRlcmNlcHRvci5wcm90b3R5cGUuaW50ZXJjZXB0ID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSByZXFcbiAgICAgKiBAcGFyYW0gez99IG5leHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChyZXEsIG5leHQpIHtcbiAgICAgICAgcmV0dXJuIG5leHQuaGFuZGxlKHJlcSk7XG4gICAgfTtcbiAgICBOb29wSW50ZXJjZXB0b3IuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdGFibGUgfSxcbiAgICBdO1xuICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgIE5vb3BJbnRlcmNlcHRvci5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9O1xuICAgIHJldHVybiBOb29wSW50ZXJjZXB0b3I7XG59KCkpO1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgYWRkZWQgYnkgdHNpY2tsZVxuICogQHN1cHByZXNzIHtjaGVja1R5cGVzfSBjaGVja2VkIGJ5IHRzY1xuICovXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vLyBFdmVyeSByZXF1ZXN0IG1hZGUgdGhyb3VnaCBKU09OUCBuZWVkcyBhIGNhbGxiYWNrIG5hbWUgdGhhdCdzIHVuaXF1ZSBhY3Jvc3MgdGhlXG4vLyB3aG9sZSBwYWdlLiBFYWNoIHJlcXVlc3QgaXMgYXNzaWduZWQgYW4gaWQgYW5kIHRoZSBjYWxsYmFjayBuYW1lIGlzIGNvbnN0cnVjdGVkXG4vLyBmcm9tIHRoYXQuIFRoZSBuZXh0IGlkIHRvIGJlIGFzc2lnbmVkIGlzIHRyYWNrZWQgaW4gYSBnbG9iYWwgdmFyaWFibGUgaGVyZSB0aGF0XG4vLyBpcyBzaGFyZWQgYW1vbmcgYWxsIGFwcGxpY2F0aW9ucyBvbiB0aGUgcGFnZS5cbnZhciBuZXh0UmVxdWVzdElkID0gMDtcbi8vIEVycm9yIHRleHQgZ2l2ZW4gd2hlbiBhIEpTT05QIHNjcmlwdCBpcyBpbmplY3RlZCwgYnV0IGRvZXNuJ3QgaW52b2tlIHRoZSBjYWxsYmFja1xuLy8gcGFzc2VkIGluIGl0cyBVUkwuXG52YXIgSlNPTlBfRVJSX05PX0NBTExCQUNLID0gJ0pTT05QIGluamVjdGVkIHNjcmlwdCBkaWQgbm90IGludm9rZSBjYWxsYmFjay4nO1xuLy8gRXJyb3IgdGV4dCBnaXZlbiB3aGVuIGEgcmVxdWVzdCBpcyBwYXNzZWQgdG8gdGhlIEpzb25wQ2xpZW50QmFja2VuZCB0aGF0IGRvZXNuJ3Rcbi8vIGhhdmUgYSByZXF1ZXN0IG1ldGhvZCBKU09OUC5cbnZhciBKU09OUF9FUlJfV1JPTkdfTUVUSE9EID0gJ0pTT05QIHJlcXVlc3RzIG11c3QgdXNlIEpTT05QIHJlcXVlc3QgbWV0aG9kLic7XG52YXIgSlNPTlBfRVJSX1dST05HX1JFU1BPTlNFX1RZUEUgPSAnSlNPTlAgcmVxdWVzdHMgbXVzdCB1c2UgSnNvbiByZXNwb25zZSB0eXBlLic7XG4vKipcbiAqIERJIHRva2VuL2Fic3RyYWN0IHR5cGUgcmVwcmVzZW50aW5nIGEgbWFwIG9mIEpTT05QIGNhbGxiYWNrcy5cbiAqXG4gKiBJbiB0aGUgYnJvd3NlciwgdGhpcyBzaG91bGQgYWx3YXlzIGJlIHRoZSBgd2luZG93YCBvYmplY3QuXG4gKlxuICogXFxAc3RhYmxlXG4gKiBAYWJzdHJhY3RcbiAqL1xudmFyIEpzb25wQ2FsbGJhY2tDb250ZXh0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBKc29ucENhbGxiYWNrQ29udGV4dCgpIHtcbiAgICB9XG4gICAgcmV0dXJuIEpzb25wQ2FsbGJhY2tDb250ZXh0O1xufSgpKTtcbi8qKlxuICogYEh0dHBCYWNrZW5kYCB0aGF0IG9ubHkgcHJvY2Vzc2VzIGBIdHRwUmVxdWVzdGAgd2l0aCB0aGUgSlNPTlAgbWV0aG9kLFxuICogYnkgcGVyZm9ybWluZyBKU09OUCBzdHlsZSByZXF1ZXN0cy5cbiAqXG4gKiBcXEBzdGFibGVcbiAqL1xudmFyIEpzb25wQ2xpZW50QmFja2VuZCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSnNvbnBDbGllbnRCYWNrZW5kKGNhbGxiYWNrTWFwLCBkb2N1bWVudCkge1xuICAgICAgICB0aGlzLmNhbGxiYWNrTWFwID0gY2FsbGJhY2tNYXA7XG4gICAgICAgIHRoaXMuZG9jdW1lbnQgPSBkb2N1bWVudDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBuYW1lIG9mIHRoZSBuZXh0IGNhbGxiYWNrIG1ldGhvZCwgYnkgaW5jcmVtZW50aW5nIHRoZSBnbG9iYWwgYG5leHRSZXF1ZXN0SWRgLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgSnNvbnBDbGllbnRCYWNrZW5kLnByb3RvdHlwZS5uZXh0Q2FsbGJhY2sgPSAvKipcbiAgICAgKiBHZXQgdGhlIG5hbWUgb2YgdGhlIG5leHQgY2FsbGJhY2sgbWV0aG9kLCBieSBpbmNyZW1lbnRpbmcgdGhlIGdsb2JhbCBgbmV4dFJlcXVlc3RJZGAuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoKSB7IHJldHVybiBcIm5nX2pzb25wX2NhbGxiYWNrX1wiICsgbmV4dFJlcXVlc3RJZCsrOyB9O1xuICAgIC8qKlxuICAgICAqIFByb2Nlc3MgYSBKU09OUCByZXF1ZXN0IGFuZCByZXR1cm4gYW4gZXZlbnQgc3RyZWFtIG9mIHRoZSByZXN1bHRzLlxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIFByb2Nlc3MgYSBKU09OUCByZXF1ZXN0IGFuZCByZXR1cm4gYW4gZXZlbnQgc3RyZWFtIG9mIHRoZSByZXN1bHRzLlxuICAgICAqIEBwYXJhbSB7P30gcmVxXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBKc29ucENsaWVudEJhY2tlbmQucHJvdG90eXBlLmhhbmRsZSA9IC8qKlxuICAgICAqIFByb2Nlc3MgYSBKU09OUCByZXF1ZXN0IGFuZCByZXR1cm4gYW4gZXZlbnQgc3RyZWFtIG9mIHRoZSByZXN1bHRzLlxuICAgICAqIEBwYXJhbSB7P30gcmVxXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAocmVxKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIC8vIEZpcnN0bHksIGNoZWNrIGJvdGggdGhlIG1ldGhvZCBhbmQgcmVzcG9uc2UgdHlwZS4gSWYgZWl0aGVyIGRvZXNuJ3QgbWF0Y2hcbiAgICAgICAgLy8gdGhlbiB0aGUgcmVxdWVzdCB3YXMgaW1wcm9wZXJseSByb3V0ZWQgaGVyZSBhbmQgY2Fubm90IGJlIGhhbmRsZWQuXG4gICAgICAgIGlmIChyZXEubWV0aG9kICE9PSAnSlNPTlAnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoSlNPTlBfRVJSX1dST05HX01FVEhPRCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocmVxLnJlc3BvbnNlVHlwZSAhPT0gJ2pzb24nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoSlNPTlBfRVJSX1dST05HX1JFU1BPTlNFX1RZUEUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEV2ZXJ5dGhpbmcgZWxzZSBoYXBwZW5zIGluc2lkZSB0aGUgT2JzZXJ2YWJsZSBib3VuZGFyeS5cbiAgICAgICAgcmV0dXJuIG5ldyByeGpzX09ic2VydmFibGUuT2JzZXJ2YWJsZShmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcbiAgICAgICAgICAgIC8vIFRoZSBmaXJzdCBzdGVwIHRvIG1ha2UgYSByZXF1ZXN0IGlzIHRvIGdlbmVyYXRlIHRoZSBjYWxsYmFjayBuYW1lLCBhbmQgcmVwbGFjZSB0aGVcbiAgICAgICAgICAgIC8vIGNhbGxiYWNrIHBsYWNlaG9sZGVyIGluIHRoZSBVUkwgd2l0aCB0aGUgbmFtZS4gQ2FyZSBoYXMgdG8gYmUgdGFrZW4gaGVyZSB0byBlbnN1cmVcbiAgICAgICAgICAgIC8vIGEgdHJhaWxpbmcgJiwgaWYgbWF0Y2hlZCwgZ2V0cyBpbnNlcnRlZCBiYWNrIGludG8gdGhlIFVSTCBpbiB0aGUgY29ycmVjdCBwbGFjZS5cbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNhbGxiYWNrID0gX3RoaXMubmV4dENhbGxiYWNrKCk7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB1cmwgPSByZXEudXJsV2l0aFBhcmFtcy5yZXBsYWNlKC89SlNPTlBfQ0FMTEJBQ0soJnwkKS8sIFwiPVwiICsgY2FsbGJhY2sgKyBcIiQxXCIpO1xuICAgICAgICAgICAgLy8gQ29uc3RydWN0IHRoZSA8c2NyaXB0PiB0YWcgYW5kIHBvaW50IGl0IGF0IHRoZSBVUkwuXG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBub2RlID0gX3RoaXMuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG4gICAgICAgICAgICBub2RlLnNyYyA9IHVybDtcbiAgICAgICAgICAgIC8vIEEgSlNPTlAgcmVxdWVzdCByZXF1aXJlcyB3YWl0aW5nIGZvciBtdWx0aXBsZSBjYWxsYmFja3MuIFRoZXNlIHZhcmlhYmxlc1xuICAgICAgICAgICAgLy8gYXJlIGNsb3NlZCBvdmVyIGFuZCB0cmFjayBzdGF0ZSBhY3Jvc3MgdGhvc2UgY2FsbGJhY2tzLlxuICAgICAgICAgICAgLy8gVGhlIHJlc3BvbnNlIG9iamVjdCwgaWYgb25lIGhhcyBiZWVuIHJlY2VpdmVkLCBvciBudWxsIG90aGVyd2lzZS5cbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGJvZHkgPSBudWxsO1xuICAgICAgICAgICAgLy8gV2hldGhlciB0aGUgcmVzcG9uc2UgY2FsbGJhY2sgaGFzIGJlZW4gY2FsbGVkLlxuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZmluaXNoZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIC8vIFdoZXRoZXIgdGhlIHJlcXVlc3QgaGFzIGJlZW4gY2FuY2VsbGVkIChhbmQgdGh1cyBhbnkgb3RoZXIgY2FsbGJhY2tzKVxuICAgICAgICAgICAgLy8gc2hvdWxkIGJlIGlnbm9yZWQuXG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjYW5jZWxsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIC8vIFNldCB0aGUgcmVzcG9uc2UgY2FsbGJhY2sgaW4gdGhpcy5jYWxsYmFja01hcCAod2hpY2ggd2lsbCBiZSB0aGUgd2luZG93XG4gICAgICAgICAgICAvLyBvYmplY3QgaW4gdGhlIGJyb3dzZXIuIFRoZSBzY3JpcHQgYmVpbmcgbG9hZGVkIHZpYSB0aGUgPHNjcmlwdD4gdGFnIHdpbGxcbiAgICAgICAgICAgIC8vIGV2ZW50dWFsbHkgY2FsbCB0aGlzIGNhbGxiYWNrLlxuICAgICAgICAgICAgLy8gU2V0IHRoZSByZXNwb25zZSBjYWxsYmFjayBpbiB0aGlzLmNhbGxiYWNrTWFwICh3aGljaCB3aWxsIGJlIHRoZSB3aW5kb3dcbiAgICAgICAgICAgIC8vIG9iamVjdCBpbiB0aGUgYnJvd3Nlci4gVGhlIHNjcmlwdCBiZWluZyBsb2FkZWQgdmlhIHRoZSA8c2NyaXB0PiB0YWcgd2lsbFxuICAgICAgICAgICAgLy8gZXZlbnR1YWxseSBjYWxsIHRoaXMgY2FsbGJhY2suXG4gICAgICAgICAgICBfdGhpcy5jYWxsYmFja01hcFtjYWxsYmFja10gPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgICAgIC8vIERhdGEgaGFzIGJlZW4gcmVjZWl2ZWQgZnJvbSB0aGUgSlNPTlAgc2NyaXB0LiBGaXJzdGx5LCBkZWxldGUgdGhpcyBjYWxsYmFjay5cbiAgICAgICAgICAgICAgICBkZWxldGUgX3RoaXMuY2FsbGJhY2tNYXBbY2FsbGJhY2tdO1xuICAgICAgICAgICAgICAgIC8vIE5leHQsIG1ha2Ugc3VyZSB0aGUgcmVxdWVzdCB3YXNuJ3QgY2FuY2VsbGVkIGluIHRoZSBtZWFudGltZS5cbiAgICAgICAgICAgICAgICBpZiAoY2FuY2VsbGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gU2V0IHN0YXRlIHRvIGluZGljYXRlIGRhdGEgd2FzIHJlY2VpdmVkLlxuICAgICAgICAgICAgICAgIGJvZHkgPSBkYXRhO1xuICAgICAgICAgICAgICAgIGZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvLyBjbGVhbnVwKCkgaXMgYSB1dGlsaXR5IGNsb3N1cmUgdGhhdCByZW1vdmVzIHRoZSA8c2NyaXB0PiBmcm9tIHRoZSBwYWdlIGFuZFxuICAgICAgICAgICAgLy8gdGhlIHJlc3BvbnNlIGNhbGxiYWNrIGZyb20gdGhlIHdpbmRvdy4gVGhpcyBsb2dpYyBpcyB1c2VkIGluIGJvdGggdGhlXG4gICAgICAgICAgICAvLyBzdWNjZXNzLCBlcnJvciwgYW5kIGNhbmNlbGxhdGlvbiBwYXRocywgc28gaXQncyBleHRyYWN0ZWQgb3V0IGZvciBjb252ZW5pZW5jZS5cbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNsZWFudXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSA8c2NyaXB0PiB0YWcgaWYgaXQncyBzdGlsbCBvbiB0aGUgcGFnZS5cbiAgICAgICAgICAgICAgICBpZiAobm9kZS5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChub2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSByZXNwb25zZSBjYWxsYmFjayBmcm9tIHRoZSBjYWxsYmFja01hcCAod2luZG93IG9iamVjdCBpbiB0aGVcbiAgICAgICAgICAgICAgICAvLyBicm93c2VyKS5cbiAgICAgICAgICAgICAgICBkZWxldGUgX3RoaXMuY2FsbGJhY2tNYXBbY2FsbGJhY2tdO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIG9uTG9hZCgpIGlzIHRoZSBzdWNjZXNzIGNhbGxiYWNrIHdoaWNoIHJ1bnMgYWZ0ZXIgdGhlIHJlc3BvbnNlIGNhbGxiYWNrXG4gICAgICAgICAgICAvLyBpZiB0aGUgSlNPTlAgc2NyaXB0IGxvYWRzIHN1Y2Nlc3NmdWxseS4gVGhlIGV2ZW50IGl0c2VsZiBpcyB1bmltcG9ydGFudC5cbiAgICAgICAgICAgIC8vIElmIHNvbWV0aGluZyB3ZW50IHdyb25nLCBvbkxvYWQoKSBtYXkgcnVuIHdpdGhvdXQgdGhlIHJlc3BvbnNlIGNhbGxiYWNrXG4gICAgICAgICAgICAvLyBoYXZpbmcgYmVlbiBpbnZva2VkLlxuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gb25Mb2FkID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgLy8gRG8gbm90aGluZyBpZiB0aGUgcmVxdWVzdCBoYXMgYmVlbiBjYW5jZWxsZWQuXG4gICAgICAgICAgICAgICAgaWYgKGNhbmNlbGxlZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIENsZWFudXAgdGhlIHBhZ2UuXG4gICAgICAgICAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICAgICAgICAgIC8vIENoZWNrIHdoZXRoZXIgdGhlIHJlc3BvbnNlIGNhbGxiYWNrIGhhcyBydW4uXG4gICAgICAgICAgICAgICAgaWYgKCFmaW5pc2hlZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJdCBoYXNuJ3QsIHNvbWV0aGluZyB3ZW50IHdyb25nIHdpdGggdGhlIHJlcXVlc3QuIFJldHVybiBhbiBlcnJvciB2aWFcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIE9ic2VydmFibGUgZXJyb3IgcGF0aC4gQWxsIEpTT05QIGVycm9ycyBoYXZlIHN0YXR1cyAwLlxuICAgICAgICAgICAgICAgICAgICBvYnNlcnZlci5lcnJvcihuZXcgSHR0cEVycm9yUmVzcG9uc2Uoe1xuICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiB1cmwsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXNUZXh0OiAnSlNPTlAgRXJyb3InLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IG5ldyBFcnJvcihKU09OUF9FUlJfTk9fQ0FMTEJBQ0spLFxuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gU3VjY2Vzcy4gYm9keSBlaXRoZXIgY29udGFpbnMgdGhlIHJlc3BvbnNlIGJvZHkgb3IgbnVsbCBpZiBub25lIHdhc1xuICAgICAgICAgICAgICAgIC8vIHJldHVybmVkLlxuICAgICAgICAgICAgICAgIG9ic2VydmVyLm5leHQobmV3IEh0dHBSZXNwb25zZSh7XG4gICAgICAgICAgICAgICAgICAgIGJvZHk6IGJvZHksXG4gICAgICAgICAgICAgICAgICAgIHN0YXR1czogMjAwLFxuICAgICAgICAgICAgICAgICAgICBzdGF0dXNUZXh0OiAnT0snLCB1cmw6IHVybCxcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgLy8gQ29tcGxldGUgdGhlIHN0cmVhbSwgdGhlIHJlc3Bvc25lIGlzIG92ZXIuXG4gICAgICAgICAgICAgICAgb2JzZXJ2ZXIuY29tcGxldGUoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvLyBvbkVycm9yKCkgaXMgdGhlIGVycm9yIGNhbGxiYWNrLCB3aGljaCBydW5zIGlmIHRoZSBzY3JpcHQgcmV0dXJuZWQgZ2VuZXJhdGVzXG4gICAgICAgICAgICAvLyBhIEphdmFzY3JpcHQgZXJyb3IuIEl0IGVtaXRzIHRoZSBlcnJvciB2aWEgdGhlIE9ic2VydmFibGUgZXJyb3IgY2hhbm5lbCBhc1xuICAgICAgICAgICAgLy8gYSBIdHRwRXJyb3JSZXNwb25zZS5cbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG9uRXJyb3IgPSBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgcmVxdWVzdCB3YXMgYWxyZWFkeSBjYW5jZWxsZWQsIG5vIG5lZWQgdG8gZW1pdCBhbnl0aGluZy5cbiAgICAgICAgICAgICAgICBpZiAoY2FuY2VsbGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICAgICAgICAgIC8vIFdyYXAgdGhlIGVycm9yIGluIGEgSHR0cEVycm9yUmVzcG9uc2UuXG4gICAgICAgICAgICAgICAgb2JzZXJ2ZXIuZXJyb3IobmV3IEh0dHBFcnJvclJlc3BvbnNlKHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGVycm9yLFxuICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IDAsXG4gICAgICAgICAgICAgICAgICAgIHN0YXR1c1RleHQ6ICdKU09OUCBFcnJvcicsIHVybDogdXJsLFxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvLyBTdWJzY3JpYmUgdG8gYm90aCB0aGUgc3VjY2VzcyAobG9hZCkgYW5kIGVycm9yIGV2ZW50cyBvbiB0aGUgPHNjcmlwdD4gdGFnLFxuICAgICAgICAgICAgLy8gYW5kIGFkZCBpdCB0byB0aGUgcGFnZS5cbiAgICAgICAgICAgIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIG9uTG9hZCk7XG4gICAgICAgICAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgb25FcnJvcik7XG4gICAgICAgICAgICBfdGhpcy5kb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKG5vZGUpO1xuICAgICAgICAgICAgLy8gVGhlIHJlcXVlc3QgaGFzIG5vdyBiZWVuIHN1Y2Nlc3NmdWxseSBzZW50LlxuICAgICAgICAgICAgb2JzZXJ2ZXIubmV4dCh7IHR5cGU6IEh0dHBFdmVudFR5cGUuU2VudCB9KTtcbiAgICAgICAgICAgIC8vIENhbmNlbGxhdGlvbiBoYW5kbGVyLlxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAvLyBUcmFjayB0aGUgY2FuY2VsbGF0aW9uIHNvIGV2ZW50IGxpc3RlbmVycyB3b24ndCBkbyBhbnl0aGluZyBldmVuIGlmIGFscmVhZHkgc2NoZWR1bGVkLlxuICAgICAgICAgICAgICAgIGNhbmNlbGxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBldmVudCBsaXN0ZW5lcnMgc28gdGhleSB3b24ndCBydW4gaWYgdGhlIGV2ZW50cyBsYXRlciBmaXJlLlxuICAgICAgICAgICAgICAgIG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcignbG9hZCcsIG9uTG9hZCk7XG4gICAgICAgICAgICAgICAgbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKCdlcnJvcicsIG9uRXJyb3IpO1xuICAgICAgICAgICAgICAgIC8vIEFuZCBmaW5hbGx5LCBjbGVhbiB1cCB0aGUgcGFnZS5cbiAgICAgICAgICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEpzb25wQ2xpZW50QmFja2VuZC5kZWNvcmF0b3JzID0gW1xuICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5qZWN0YWJsZSB9LFxuICAgIF07XG4gICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgSnNvbnBDbGllbnRCYWNrZW5kLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgICAgICB7IHR5cGU6IEpzb25wQ2FsbGJhY2tDb250ZXh0LCB9LFxuICAgICAgICB7IHR5cGU6IHVuZGVmaW5lZCwgZGVjb3JhdG9yczogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3QsIGFyZ3M6IFtfYW5ndWxhcl9jb21tb24uRE9DVU1FTlQsXSB9LF0gfSxcbiAgICBdOyB9O1xuICAgIHJldHVybiBKc29ucENsaWVudEJhY2tlbmQ7XG59KCkpO1xuLyoqXG4gKiBBbiBgSHR0cEludGVyY2VwdG9yYCB3aGljaCBpZGVudGlmaWVzIHJlcXVlc3RzIHdpdGggdGhlIG1ldGhvZCBKU09OUCBhbmRcbiAqIHNoaWZ0cyB0aGVtIHRvIHRoZSBgSnNvbnBDbGllbnRCYWNrZW5kYC5cbiAqXG4gKiBcXEBzdGFibGVcbiAqL1xudmFyIEpzb25wSW50ZXJjZXB0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEpzb25wSW50ZXJjZXB0b3IoanNvbnApIHtcbiAgICAgICAgdGhpcy5qc29ucCA9IGpzb25wO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHJlcVxuICAgICAqIEBwYXJhbSB7P30gbmV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgSnNvbnBJbnRlcmNlcHRvci5wcm90b3R5cGUuaW50ZXJjZXB0ID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSByZXFcbiAgICAgKiBAcGFyYW0gez99IG5leHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChyZXEsIG5leHQpIHtcbiAgICAgICAgaWYgKHJlcS5tZXRob2QgPT09ICdKU09OUCcpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmpzb25wLmhhbmRsZSgvKiogQHR5cGUgez99ICovIChyZXEpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBGYWxsIHRocm91Z2ggZm9yIG5vcm1hbCBIVFRQIHJlcXVlc3RzLlxuICAgICAgICByZXR1cm4gbmV4dC5oYW5kbGUocmVxKTtcbiAgICB9O1xuICAgIEpzb25wSW50ZXJjZXB0b3IuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdGFibGUgfSxcbiAgICBdO1xuICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgIEpzb25wSW50ZXJjZXB0b3IuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgICAgIHsgdHlwZTogSnNvbnBDbGllbnRCYWNrZW5kLCB9LFxuICAgIF07IH07XG4gICAgcmV0dXJuIEpzb25wSW50ZXJjZXB0b3I7XG59KCkpO1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgYWRkZWQgYnkgdHNpY2tsZVxuICogQHN1cHByZXNzIHtjaGVja1R5cGVzfSBjaGVja2VkIGJ5IHRzY1xuICovXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgWFNTSV9QUkVGSVggPSAvXlxcKVxcXVxcfScsP1xcbi87XG4vKipcbiAqIERldGVybWluZSBhbiBhcHByb3ByaWF0ZSBVUkwgZm9yIHRoZSByZXNwb25zZSwgYnkgY2hlY2tpbmcgZWl0aGVyXG4gKiBYTUxIdHRwUmVxdWVzdC5yZXNwb25zZVVSTCBvciB0aGUgWC1SZXF1ZXN0LVVSTCBoZWFkZXIuXG4gKiBAcGFyYW0gez99IHhoclxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gZ2V0UmVzcG9uc2VVcmwoeGhyKSB7XG4gICAgaWYgKCdyZXNwb25zZVVSTCcgaW4geGhyICYmIHhoci5yZXNwb25zZVVSTCkge1xuICAgICAgICByZXR1cm4geGhyLnJlc3BvbnNlVVJMO1xuICAgIH1cbiAgICBpZiAoL15YLVJlcXVlc3QtVVJMOi9tLnRlc3QoeGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpKSkge1xuICAgICAgICByZXR1cm4geGhyLmdldFJlc3BvbnNlSGVhZGVyKCdYLVJlcXVlc3QtVVJMJyk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuLyoqXG4gKiBBIHdyYXBwZXIgYXJvdW5kIHRoZSBgWE1MSHR0cFJlcXVlc3RgIGNvbnN0cnVjdG9yLlxuICpcbiAqIFxcQHN0YWJsZVxuICogQGFic3RyYWN0XG4gKi9cbnZhciBYaHJGYWN0b3J5ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBYaHJGYWN0b3J5KCkge1xuICAgIH1cbiAgICByZXR1cm4gWGhyRmFjdG9yeTtcbn0oKSk7XG4vKipcbiAqIEEgZmFjdG9yeSBmb3IgXFxAe2xpbmsgSHR0cFhockJhY2tlbmR9IHRoYXQgdXNlcyB0aGUgYFhNTEh0dHBSZXF1ZXN0YCBicm93c2VyIEFQSS5cbiAqXG4gKiBcXEBzdGFibGVcbiAqL1xudmFyIEJyb3dzZXJYaHIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEJyb3dzZXJYaHIoKSB7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQnJvd3Nlclhoci5wcm90b3R5cGUuYnVpbGQgPSAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uICgpIHsgcmV0dXJuIC8qKiBAdHlwZSB7P30gKi8gKChuZXcgWE1MSHR0cFJlcXVlc3QoKSkpOyB9O1xuICAgIEJyb3dzZXJYaHIuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdGFibGUgfSxcbiAgICBdO1xuICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgIEJyb3dzZXJYaHIuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXTsgfTtcbiAgICByZXR1cm4gQnJvd3Nlclhocjtcbn0oKSk7XG4vKipcbiAqIEFuIGBIdHRwQmFja2VuZGAgd2hpY2ggdXNlcyB0aGUgWE1MSHR0cFJlcXVlc3QgQVBJIHRvIHNlbmRcbiAqIHJlcXVlc3RzIHRvIGEgYmFja2VuZCBzZXJ2ZXIuXG4gKlxuICogXFxAc3RhYmxlXG4gKi9cbnZhciBIdHRwWGhyQmFja2VuZCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSHR0cFhockJhY2tlbmQoeGhyRmFjdG9yeSkge1xuICAgICAgICB0aGlzLnhockZhY3RvcnkgPSB4aHJGYWN0b3J5O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcm9jZXNzIGEgcmVxdWVzdCBhbmQgcmV0dXJuIGEgc3RyZWFtIG9mIHJlc3BvbnNlIGV2ZW50cy5cbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBQcm9jZXNzIGEgcmVxdWVzdCBhbmQgcmV0dXJuIGEgc3RyZWFtIG9mIHJlc3BvbnNlIGV2ZW50cy5cbiAgICAgKiBAcGFyYW0gez99IHJlcVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgSHR0cFhockJhY2tlbmQucHJvdG90eXBlLmhhbmRsZSA9IC8qKlxuICAgICAqIFByb2Nlc3MgYSByZXF1ZXN0IGFuZCByZXR1cm4gYSBzdHJlYW0gb2YgcmVzcG9uc2UgZXZlbnRzLlxuICAgICAqIEBwYXJhbSB7P30gcmVxXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAocmVxKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIC8vIFF1aWNrIGNoZWNrIHRvIGdpdmUgYSBiZXR0ZXIgZXJyb3IgbWVzc2FnZSB3aGVuIGEgdXNlciBhdHRlbXB0cyB0byB1c2VcbiAgICAgICAgLy8gSHR0cENsaWVudC5qc29ucCgpIHdpdGhvdXQgaW5zdGFsbGluZyB0aGUgSnNvbnBDbGllbnRNb2R1bGVcbiAgICAgICAgaWYgKHJlcS5tZXRob2QgPT09ICdKU09OUCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkF0dGVtcHRlZCB0byBjb25zdHJ1Y3QgSnNvbnAgcmVxdWVzdCB3aXRob3V0IEpzb25wQ2xpZW50TW9kdWxlIGluc3RhbGxlZC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRXZlcnl0aGluZyBoYXBwZW5zIG9uIE9ic2VydmFibGUgc3Vic2NyaXB0aW9uLlxuICAgICAgICByZXR1cm4gbmV3IHJ4anNfT2JzZXJ2YWJsZS5PYnNlcnZhYmxlKGZ1bmN0aW9uIChvYnNlcnZlcikge1xuICAgICAgICAgICAgLy8gU3RhcnQgYnkgc2V0dGluZyB1cCB0aGUgWEhSIG9iamVjdCB3aXRoIHJlcXVlc3QgbWV0aG9kLCBVUkwsIGFuZCB3aXRoQ3JlZGVudGlhbHMgZmxhZy5cbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHhociA9IF90aGlzLnhockZhY3RvcnkuYnVpbGQoKTtcbiAgICAgICAgICAgIHhoci5vcGVuKHJlcS5tZXRob2QsIHJlcS51cmxXaXRoUGFyYW1zKTtcbiAgICAgICAgICAgIGlmICghIXJlcS53aXRoQ3JlZGVudGlhbHMpIHtcbiAgICAgICAgICAgICAgICB4aHIud2l0aENyZWRlbnRpYWxzID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEFkZCBhbGwgdGhlIHJlcXVlc3RlZCBoZWFkZXJzLlxuICAgICAgICAgICAgcmVxLmhlYWRlcnMuZm9yRWFjaChmdW5jdGlvbiAobmFtZSwgdmFsdWVzKSB7IHJldHVybiB4aHIuc2V0UmVxdWVzdEhlYWRlcihuYW1lLCB2YWx1ZXMuam9pbignLCcpKTsgfSk7XG4gICAgICAgICAgICAvLyBBZGQgYW4gQWNjZXB0IGhlYWRlciBpZiBvbmUgaXNuJ3QgcHJlc2VudCBhbHJlYWR5LlxuICAgICAgICAgICAgaWYgKCFyZXEuaGVhZGVycy5oYXMoJ0FjY2VwdCcpKSB7XG4gICAgICAgICAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoJ0FjY2VwdCcsICdhcHBsaWNhdGlvbi9qc29uLCB0ZXh0L3BsYWluLCAqLyonKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEF1dG8tZGV0ZWN0IHRoZSBDb250ZW50LVR5cGUgaGVhZGVyIGlmIG9uZSBpc24ndCBwcmVzZW50IGFscmVhZHkuXG4gICAgICAgICAgICBpZiAoIXJlcS5oZWFkZXJzLmhhcygnQ29udGVudC1UeXBlJykpIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkZXRlY3RlZFR5cGUgPSByZXEuZGV0ZWN0Q29udGVudFR5cGVIZWFkZXIoKTtcbiAgICAgICAgICAgICAgICAvLyBTb21ldGltZXMgQ29udGVudC1UeXBlIGRldGVjdGlvbiBmYWlscy5cbiAgICAgICAgICAgICAgICBpZiAoZGV0ZWN0ZWRUeXBlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCdDb250ZW50LVR5cGUnLCBkZXRlY3RlZFR5cGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFNldCB0aGUgcmVzcG9uc2VUeXBlIGlmIG9uZSB3YXMgcmVxdWVzdGVkLlxuICAgICAgICAgICAgaWYgKHJlcS5yZXNwb25zZVR5cGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZXNwb25zZVR5cGUgPSByZXEucmVzcG9uc2VUeXBlLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgLy8gSlNPTiByZXNwb25zZXMgbmVlZCB0byBiZSBwcm9jZXNzZWQgYXMgdGV4dC4gVGhpcyBpcyBiZWNhdXNlIGlmIHRoZSBzZXJ2ZXJcbiAgICAgICAgICAgICAgICAvLyByZXR1cm5zIGFuIFhTU0ktcHJlZml4ZWQgSlNPTiByZXNwb25zZSwgdGhlIGJyb3dzZXIgd2lsbCBmYWlsIHRvIHBhcnNlIGl0LFxuICAgICAgICAgICAgICAgIC8vIHhoci5yZXNwb25zZSB3aWxsIGJlIG51bGwsIGFuZCB4aHIucmVzcG9uc2VUZXh0IGNhbm5vdCBiZSBhY2Nlc3NlZCB0b1xuICAgICAgICAgICAgICAgIC8vIHJldHJpZXZlIHRoZSBwcmVmaXhlZCBKU09OIGRhdGEgaW4gb3JkZXIgdG8gc3RyaXAgdGhlIHByZWZpeC4gVGh1cywgYWxsIEpTT05cbiAgICAgICAgICAgICAgICAvLyBpcyBwYXJzZWQgYnkgZmlyc3QgcmVxdWVzdGluZyB0ZXh0IGFuZCB0aGVuIGFwcGx5aW5nIEpTT04ucGFyc2UuXG4gICAgICAgICAgICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9IC8qKiBAdHlwZSB7P30gKi8gKCgocmVzcG9uc2VUeXBlICE9PSAnanNvbicpID8gcmVzcG9uc2VUeXBlIDogJ3RleHQnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTZXJpYWxpemUgdGhlIHJlcXVlc3QgYm9keSBpZiBvbmUgaXMgcHJlc2VudC4gSWYgbm90LCB0aGlzIHdpbGwgYmUgc2V0IHRvIG51bGwuXG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZXFCb2R5ID0gcmVxLnNlcmlhbGl6ZUJvZHkoKTtcbiAgICAgICAgICAgIC8vIElmIHByb2dyZXNzIGV2ZW50cyBhcmUgZW5hYmxlZCwgcmVzcG9uc2UgaGVhZGVycyB3aWxsIGJlIGRlbGl2ZXJlZFxuICAgICAgICAgICAgLy8gaW4gdHdvIGV2ZW50cyAtIHRoZSBIdHRwSGVhZGVyUmVzcG9uc2UgZXZlbnQgYW5kIHRoZSBmdWxsIEh0dHBSZXNwb25zZVxuICAgICAgICAgICAgLy8gZXZlbnQuIEhvd2V2ZXIsIHNpbmNlIHJlc3BvbnNlIGhlYWRlcnMgZG9uJ3QgY2hhbmdlIGluIGJldHdlZW4gdGhlc2VcbiAgICAgICAgICAgIC8vIHR3byBldmVudHMsIGl0IGRvZXNuJ3QgbWFrZSBzZW5zZSB0byBwYXJzZSB0aGVtIHR3aWNlLiBTbyBoZWFkZXJSZXNwb25zZVxuICAgICAgICAgICAgLy8gY2FjaGVzIHRoZSBkYXRhIGV4dHJhY3RlZCBmcm9tIHRoZSByZXNwb25zZSB3aGVuZXZlciBpdCdzIGZpcnN0IHBhcnNlZCxcbiAgICAgICAgICAgIC8vIHRvIGVuc3VyZSBwYXJzaW5nIGlzbid0IGR1cGxpY2F0ZWQuXG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBoZWFkZXJSZXNwb25zZSA9IG51bGw7XG4gICAgICAgICAgICAvLyBwYXJ0aWFsRnJvbVhociBleHRyYWN0cyB0aGUgSHR0cEhlYWRlclJlc3BvbnNlIGZyb20gdGhlIGN1cnJlbnQgWE1MSHR0cFJlcXVlc3RcbiAgICAgICAgICAgIC8vIHN0YXRlLCBhbmQgbWVtb2l6ZXMgaXQgaW50byBoZWFkZXJSZXNwb25zZS5cbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBhcnRpYWxGcm9tWGhyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmIChoZWFkZXJSZXNwb25zZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGVhZGVyUmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFJlYWQgc3RhdHVzIGFuZCBub3JtYWxpemUgYW4gSUU5IGJ1ZyAoaHR0cDovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvMTQ1MCkuXG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3RhdHVzID0geGhyLnN0YXR1cyA9PT0gMTIyMyA/IDIwNCA6IHhoci5zdGF0dXM7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3RhdHVzVGV4dCA9IHhoci5zdGF0dXNUZXh0IHx8ICdPSyc7XG4gICAgICAgICAgICAgICAgLy8gUGFyc2UgaGVhZGVycyBmcm9tIFhNTEh0dHBSZXF1ZXN0IC0gdGhpcyBzdGVwIGlzIGxhenkuXG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaGVhZGVycyA9IG5ldyBIdHRwSGVhZGVycyh4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkpO1xuICAgICAgICAgICAgICAgIC8vIFJlYWQgdGhlIHJlc3BvbnNlIFVSTCBmcm9tIHRoZSBYTUxIdHRwUmVzcG9uc2UgaW5zdGFuY2UgYW5kIGZhbGwgYmFjayBvbiB0aGVcbiAgICAgICAgICAgICAgICAvLyByZXF1ZXN0IFVSTC5cbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB1cmwgPSBnZXRSZXNwb25zZVVybCh4aHIpIHx8IHJlcS51cmw7XG4gICAgICAgICAgICAgICAgLy8gQ29uc3RydWN0IHRoZSBIdHRwSGVhZGVyUmVzcG9uc2UgYW5kIG1lbW9pemUgaXQuXG4gICAgICAgICAgICAgICAgaGVhZGVyUmVzcG9uc2UgPSBuZXcgSHR0cEhlYWRlclJlc3BvbnNlKHsgaGVhZGVyczogaGVhZGVycywgc3RhdHVzOiBzdGF0dXMsIHN0YXR1c1RleHQ6IHN0YXR1c1RleHQsIHVybDogdXJsIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBoZWFkZXJSZXNwb25zZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvLyBOZXh0LCBhIGZldyBjbG9zdXJlcyBhcmUgZGVmaW5lZCBmb3IgdGhlIHZhcmlvdXMgZXZlbnRzIHdoaWNoIFhNTEh0dHBSZXF1ZXN0IGNhblxuICAgICAgICAgICAgLy8gZW1pdC4gVGhpcyBhbGxvd3MgdGhlbSB0byBiZSB1bnJlZ2lzdGVyZWQgYXMgZXZlbnQgbGlzdGVuZXJzIGxhdGVyLlxuICAgICAgICAgICAgLy8gRmlyc3QgdXAgaXMgdGhlIGxvYWQgZXZlbnQsIHdoaWNoIHJlcHJlc2VudHMgYSByZXNwb25zZSBiZWluZyBmdWxseSBhdmFpbGFibGUuXG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBvbkxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgLy8gUmVhZCByZXNwb25zZSBzdGF0ZSBmcm9tIHRoZSBtZW1vaXplZCBwYXJ0aWFsIGRhdGEuXG4gICAgICAgICAgICAgICAgdmFyIF9hID0gcGFydGlhbEZyb21YaHIoKSwgaGVhZGVycyA9IF9hLmhlYWRlcnMsIHN0YXR1cyA9IF9hLnN0YXR1cywgc3RhdHVzVGV4dCA9IF9hLnN0YXR1c1RleHQsIHVybCA9IF9hLnVybDtcbiAgICAgICAgICAgICAgICAvLyBUaGUgYm9keSB3aWxsIGJlIHJlYWQgb3V0IGlmIHByZXNlbnQuXG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYm9keSA9IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXR1cyAhPT0gMjA0KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFVzZSBYTUxIdHRwUmVxdWVzdC5yZXNwb25zZSBpZiBzZXQsIHJlc3BvbnNlVGV4dCBvdGhlcndpc2UuXG4gICAgICAgICAgICAgICAgICAgIGJvZHkgPSAodHlwZW9mIHhoci5yZXNwb25zZSA9PT0gJ3VuZGVmaW5lZCcpID8geGhyLnJlc3BvbnNlVGV4dCA6IHhoci5yZXNwb25zZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gTm9ybWFsaXplIGFub3RoZXIgcG90ZW50aWFsIGJ1ZyAodGhpcyBvbmUgY29tZXMgZnJvbSBDT1JTKS5cbiAgICAgICAgICAgICAgICBpZiAoc3RhdHVzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cyA9ICEhYm9keSA/IDIwMCA6IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIG9rIGRldGVybWluZXMgd2hldGhlciB0aGUgcmVzcG9uc2Ugd2lsbCBiZSB0cmFuc21pdHRlZCBvbiB0aGUgZXZlbnQgb3JcbiAgICAgICAgICAgICAgICAvLyBlcnJvciBjaGFubmVsLiBVbnN1Y2Nlc3NmdWwgc3RhdHVzIGNvZGVzIChub3QgMnh4KSB3aWxsIGFsd2F5cyBiZSBlcnJvcnMsXG4gICAgICAgICAgICAgICAgLy8gYnV0IGEgc3VjY2Vzc2Z1bCBzdGF0dXMgY29kZSBjYW4gc3RpbGwgcmVzdWx0IGluIGFuIGVycm9yIGlmIHRoZSB1c2VyXG4gICAgICAgICAgICAgICAgLy8gYXNrZWQgZm9yIEpTT04gZGF0YSBhbmQgdGhlIGJvZHkgY2Fubm90IGJlIHBhcnNlZCBhcyBzdWNoLlxuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG9rID0gc3RhdHVzID49IDIwMCAmJiBzdGF0dXMgPCAzMDA7XG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgd2hldGhlciB0aGUgYm9keSBuZWVkcyB0byBiZSBwYXJzZWQgYXMgSlNPTiAoaW4gbWFueSBjYXNlcyB0aGUgYnJvd3NlclxuICAgICAgICAgICAgICAgIC8vIHdpbGwgaGF2ZSBkb25lIHRoYXQgYWxyZWFkeSkuXG4gICAgICAgICAgICAgICAgaWYgKG9rICYmIHJlcS5yZXNwb25zZVR5cGUgPT09ICdqc29uJyAmJiB0eXBlb2YgYm9keSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQXR0ZW1wdCB0aGUgcGFyc2UuIElmIGl0IGZhaWxzLCBhIHBhcnNlIGVycm9yIHNob3VsZCBiZSBkZWxpdmVyZWQgdG8gdGhlIHVzZXIuXG4gICAgICAgICAgICAgICAgICAgIGJvZHkgPSBib2R5LnJlcGxhY2UoWFNTSV9QUkVGSVgsICcnKTtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHkgPSBKU09OLnBhcnNlKGJvZHkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoICgvKiogQHR5cGUgez99ICovIGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBFdmVuIHRob3VnaCB0aGUgcmVzcG9uc2Ugc3RhdHVzIHdhcyAyeHgsIHRoaXMgaXMgc3RpbGwgYW4gZXJyb3IuXG4gICAgICAgICAgICAgICAgICAgICAgICBvayA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHBhcnNlIGVycm9yIGNvbnRhaW5zIHRoZSB0ZXh0IG9mIHRoZSBib2R5IHRoYXQgZmFpbGVkIHRvIHBhcnNlLlxuICAgICAgICAgICAgICAgICAgICAgICAgYm9keSA9IC8qKiBAdHlwZSB7P30gKi8gKHsgZXJyb3I6IGVycm9yLCB0ZXh0OiBib2R5IH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChvaykge1xuICAgICAgICAgICAgICAgICAgICAvLyBBIHN1Y2Nlc3NmdWwgcmVzcG9uc2UgaXMgZGVsaXZlcmVkIG9uIHRoZSBldmVudCBzdHJlYW0uXG4gICAgICAgICAgICAgICAgICAgIG9ic2VydmVyLm5leHQobmV3IEh0dHBSZXNwb25zZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5OiBib2R5LFxuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1czogc3RhdHVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzVGV4dDogc3RhdHVzVGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybDogdXJsIHx8IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgZnVsbCBib2R5IGhhcyBiZWVuIHJlY2VpdmVkIGFuZCBkZWxpdmVyZWQsIG5vIGZ1cnRoZXIgZXZlbnRzXG4gICAgICAgICAgICAgICAgICAgIC8vIGFyZSBwb3NzaWJsZS4gVGhpcyByZXF1ZXN0IGlzIGNvbXBsZXRlLlxuICAgICAgICAgICAgICAgICAgICBvYnNlcnZlci5jb21wbGV0ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQW4gdW5zdWNjZXNzZnVsIHJlcXVlc3QgaXMgZGVsaXZlcmVkIG9uIHRoZSBlcnJvciBjaGFubmVsLlxuICAgICAgICAgICAgICAgICAgICBvYnNlcnZlci5lcnJvcihuZXcgSHR0cEVycm9yUmVzcG9uc2Uoe1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGVycm9yIGluIHRoaXMgY2FzZSBpcyB0aGUgcmVzcG9uc2UgYm9keSAoZXJyb3IgZnJvbSB0aGUgc2VydmVyKS5cbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBib2R5LFxuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1czogc3RhdHVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzVGV4dDogc3RhdHVzVGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybDogdXJsIHx8IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvLyBUaGUgb25FcnJvciBjYWxsYmFjayBpcyBjYWxsZWQgd2hlbiBzb21ldGhpbmcgZ29lcyB3cm9uZyBhdCB0aGUgbmV0d29yayBsZXZlbC5cbiAgICAgICAgICAgIC8vIENvbm5lY3Rpb24gdGltZW91dCwgRE5TIGVycm9yLCBvZmZsaW5lLCBldGMuIFRoZXNlIGFyZSBhY3R1YWwgZXJyb3JzLCBhbmQgYXJlXG4gICAgICAgICAgICAvLyB0cmFuc21pdHRlZCBvbiB0aGUgZXJyb3IgY2hhbm5lbC5cbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG9uRXJyb3IgPSBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZXMgPSBuZXcgSHR0cEVycm9yUmVzcG9uc2Uoe1xuICAgICAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3IsXG4gICAgICAgICAgICAgICAgICAgIHN0YXR1czogeGhyLnN0YXR1cyB8fCAwLFxuICAgICAgICAgICAgICAgICAgICBzdGF0dXNUZXh0OiB4aHIuc3RhdHVzVGV4dCB8fCAnVW5rbm93biBFcnJvcicsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgb2JzZXJ2ZXIuZXJyb3IocmVzKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvLyBUaGUgc2VudEhlYWRlcnMgZmxhZyB0cmFja3Mgd2hldGhlciB0aGUgSHR0cFJlc3BvbnNlSGVhZGVycyBldmVudFxuICAgICAgICAgICAgLy8gaGFzIGJlZW4gc2VudCBvbiB0aGUgc3RyZWFtLiBUaGlzIGlzIG5lY2Vzc2FyeSB0byB0cmFjayBpZiBwcm9ncmVzc1xuICAgICAgICAgICAgLy8gaXMgZW5hYmxlZCBzaW5jZSB0aGUgZXZlbnQgd2lsbCBiZSBzZW50IG9uIG9ubHkgdGhlIGZpcnN0IGRvd25sb2FkXG4gICAgICAgICAgICAvLyBwcm9nZXJzcyBldmVudC5cbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHNlbnRIZWFkZXJzID0gZmFsc2U7XG4gICAgICAgICAgICAvLyBUaGUgZG93bmxvYWQgcHJvZ3Jlc3MgZXZlbnQgaGFuZGxlciwgd2hpY2ggaXMgb25seSByZWdpc3RlcmVkIGlmXG4gICAgICAgICAgICAvLyBwcm9ncmVzcyBldmVudHMgYXJlIGVuYWJsZWQuXG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBvbkRvd25Qcm9ncmVzcyA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgICAgIC8vIFNlbmQgdGhlIEh0dHBSZXNwb25zZUhlYWRlcnMgZXZlbnQgaWYgaXQgaGFzbid0IGJlZW4gc2VudCBhbHJlYWR5LlxuICAgICAgICAgICAgICAgIGlmICghc2VudEhlYWRlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgb2JzZXJ2ZXIubmV4dChwYXJ0aWFsRnJvbVhocigpKTtcbiAgICAgICAgICAgICAgICAgICAgc2VudEhlYWRlcnMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBTdGFydCBidWlsZGluZyB0aGUgZG93bmxvYWQgcHJvZ3Jlc3MgZXZlbnQgdG8gZGVsaXZlciBvbiB0aGUgcmVzcG9uc2VcbiAgICAgICAgICAgICAgICAvLyBldmVudCBzdHJlYW0uXG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcHJvZ3Jlc3NFdmVudCA9IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogSHR0cEV2ZW50VHlwZS5Eb3dubG9hZFByb2dyZXNzLFxuICAgICAgICAgICAgICAgICAgICBsb2FkZWQ6IGV2ZW50LmxvYWRlZCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIC8vIFNldCB0aGUgdG90YWwgbnVtYmVyIG9mIGJ5dGVzIGluIHRoZSBldmVudCBpZiBpdCdzIGF2YWlsYWJsZS5cbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQubGVuZ3RoQ29tcHV0YWJsZSkge1xuICAgICAgICAgICAgICAgICAgICBwcm9ncmVzc0V2ZW50LnRvdGFsID0gZXZlbnQudG90YWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIElmIHRoZSByZXF1ZXN0IHdhcyBmb3IgdGV4dCBjb250ZW50IGFuZCBhIHBhcnRpYWwgcmVzcG9uc2UgaXNcbiAgICAgICAgICAgICAgICAvLyBhdmFpbGFibGUgb24gWE1MSHR0cFJlcXVlc3QsIGluY2x1ZGUgaXQgaW4gdGhlIHByb2dyZXNzIGV2ZW50XG4gICAgICAgICAgICAgICAgLy8gdG8gYWxsb3cgZm9yIHN0cmVhbWluZyByZWFkcy5cbiAgICAgICAgICAgICAgICBpZiAocmVxLnJlc3BvbnNlVHlwZSA9PT0gJ3RleHQnICYmICEheGhyLnJlc3BvbnNlVGV4dCkge1xuICAgICAgICAgICAgICAgICAgICBwcm9ncmVzc0V2ZW50LnBhcnRpYWxUZXh0ID0geGhyLnJlc3BvbnNlVGV4dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gRmluYWxseSwgZmlyZSB0aGUgZXZlbnQuXG4gICAgICAgICAgICAgICAgb2JzZXJ2ZXIubmV4dChwcm9ncmVzc0V2ZW50KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvLyBUaGUgdXBsb2FkIHByb2dyZXNzIGV2ZW50IGhhbmRsZXIsIHdoaWNoIGlzIG9ubHkgcmVnaXN0ZXJlZCBpZlxuICAgICAgICAgICAgLy8gcHJvZ3Jlc3MgZXZlbnRzIGFyZSBlbmFibGVkLlxuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gb25VcFByb2dyZXNzID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgLy8gVXBsb2FkIHByb2dyZXNzIGV2ZW50cyBhcmUgc2ltcGxlci4gQmVnaW4gYnVpbGRpbmcgdGhlIHByb2dyZXNzXG4gICAgICAgICAgICAgICAgLy8gZXZlbnQuXG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcHJvZ3Jlc3MgPSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IEh0dHBFdmVudFR5cGUuVXBsb2FkUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgICAgICAgIGxvYWRlZDogZXZlbnQubG9hZGVkLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIHRvdGFsIG51bWJlciBvZiBieXRlcyBiZWluZyB1cGxvYWRlZCBpcyBhdmFpbGFibGUsIGluY2x1ZGVcbiAgICAgICAgICAgICAgICAvLyBpdC5cbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQubGVuZ3RoQ29tcHV0YWJsZSkge1xuICAgICAgICAgICAgICAgICAgICBwcm9ncmVzcy50b3RhbCA9IGV2ZW50LnRvdGFsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBTZW5kIHRoZSBldmVudC5cbiAgICAgICAgICAgICAgICBvYnNlcnZlci5uZXh0KHByb2dyZXNzKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvLyBCeSBkZWZhdWx0LCByZWdpc3RlciBmb3IgbG9hZCBhbmQgZXJyb3IgZXZlbnRzLlxuICAgICAgICAgICAgeGhyLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBvbkxvYWQpO1xuICAgICAgICAgICAgeGhyLmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgb25FcnJvcik7XG4gICAgICAgICAgICAvLyBQcm9ncmVzcyBldmVudHMgYXJlIG9ubHkgZW5hYmxlZCBpZiByZXF1ZXN0ZWQuXG4gICAgICAgICAgICBpZiAocmVxLnJlcG9ydFByb2dyZXNzKSB7XG4gICAgICAgICAgICAgICAgLy8gRG93bmxvYWQgcHJvZ3Jlc3MgaXMgYWx3YXlzIGVuYWJsZWQgaWYgcmVxdWVzdGVkLlxuICAgICAgICAgICAgICAgIHhoci5hZGRFdmVudExpc3RlbmVyKCdwcm9ncmVzcycsIG9uRG93blByb2dyZXNzKTtcbiAgICAgICAgICAgICAgICAvLyBVcGxvYWQgcHJvZ3Jlc3MgZGVwZW5kcyBvbiB3aGV0aGVyIHRoZXJlIGlzIGEgYm9keSB0byB1cGxvYWQuXG4gICAgICAgICAgICAgICAgaWYgKHJlcUJvZHkgIT09IG51bGwgJiYgeGhyLnVwbG9hZCkge1xuICAgICAgICAgICAgICAgICAgICB4aHIudXBsb2FkLmFkZEV2ZW50TGlzdGVuZXIoJ3Byb2dyZXNzJywgb25VcFByb2dyZXNzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBGaXJlIHRoZSByZXF1ZXN0LCBhbmQgbm90aWZ5IHRoZSBldmVudCBzdHJlYW0gdGhhdCBpdCB3YXMgZmlyZWQuXG4gICAgICAgICAgICB4aHIuc2VuZChyZXFCb2R5KTtcbiAgICAgICAgICAgIG9ic2VydmVyLm5leHQoeyB0eXBlOiBIdHRwRXZlbnRUeXBlLlNlbnQgfSk7XG4gICAgICAgICAgICAvLyBUaGlzIGlzIHRoZSByZXR1cm4gZnJvbSB0aGUgT2JzZXJ2YWJsZSBmdW5jdGlvbiwgd2hpY2ggaXMgdGhlXG4gICAgICAgICAgICAvLyByZXF1ZXN0IGNhbmNlbGxhdGlvbiBoYW5kbGVyLlxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAvLyBPbiBhIGNhbmNlbGxhdGlvbiwgcmVtb3ZlIGFsbCByZWdpc3RlcmVkIGV2ZW50IGxpc3RlbmVycy5cbiAgICAgICAgICAgICAgICB4aHIucmVtb3ZlRXZlbnRMaXN0ZW5lcignZXJyb3InLCBvbkVycm9yKTtcbiAgICAgICAgICAgICAgICB4aHIucmVtb3ZlRXZlbnRMaXN0ZW5lcignbG9hZCcsIG9uTG9hZCk7XG4gICAgICAgICAgICAgICAgaWYgKHJlcS5yZXBvcnRQcm9ncmVzcykge1xuICAgICAgICAgICAgICAgICAgICB4aHIucmVtb3ZlRXZlbnRMaXN0ZW5lcigncHJvZ3Jlc3MnLCBvbkRvd25Qcm9ncmVzcyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXFCb2R5ICE9PSBudWxsICYmIHhoci51cGxvYWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHhoci51cGxvYWQucmVtb3ZlRXZlbnRMaXN0ZW5lcigncHJvZ3Jlc3MnLCBvblVwUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEZpbmFsbHksIGFib3J0IHRoZSBpbi1mbGlnaHQgcmVxdWVzdC5cbiAgICAgICAgICAgICAgICB4aHIuYWJvcnQoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgSHR0cFhockJhY2tlbmQuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdGFibGUgfSxcbiAgICBdO1xuICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgIEh0dHBYaHJCYWNrZW5kLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgICAgICB7IHR5cGU6IFhockZhY3RvcnksIH0sXG4gICAgXTsgfTtcbiAgICByZXR1cm4gSHR0cFhockJhY2tlbmQ7XG59KCkpO1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgYWRkZWQgYnkgdHNpY2tsZVxuICogQHN1cHByZXNzIHtjaGVja1R5cGVzfSBjaGVja2VkIGJ5IHRzY1xuICovXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgWFNSRl9DT09LSUVfTkFNRSA9IG5ldyBfYW5ndWxhcl9jb3JlLkluamVjdGlvblRva2VuKCdYU1JGX0NPT0tJRV9OQU1FJyk7XG52YXIgWFNSRl9IRUFERVJfTkFNRSA9IG5ldyBfYW5ndWxhcl9jb3JlLkluamVjdGlvblRva2VuKCdYU1JGX0hFQURFUl9OQU1FJyk7XG4vKipcbiAqIFJldHJpZXZlcyB0aGUgY3VycmVudCBYU1JGIHRva2VuIHRvIHVzZSB3aXRoIHRoZSBuZXh0IG91dGdvaW5nIHJlcXVlc3QuXG4gKlxuICogXFxAc3RhYmxlXG4gKiBAYWJzdHJhY3RcbiAqL1xudmFyIEh0dHBYc3JmVG9rZW5FeHRyYWN0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEh0dHBYc3JmVG9rZW5FeHRyYWN0b3IoKSB7XG4gICAgfVxuICAgIHJldHVybiBIdHRwWHNyZlRva2VuRXh0cmFjdG9yO1xufSgpKTtcbi8qKlxuICogYEh0dHBYc3JmVG9rZW5FeHRyYWN0b3JgIHdoaWNoIHJldHJpZXZlcyB0aGUgdG9rZW4gZnJvbSBhIGNvb2tpZS5cbiAqL1xudmFyIEh0dHBYc3JmQ29va2llRXh0cmFjdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBIdHRwWHNyZkNvb2tpZUV4dHJhY3Rvcihkb2MsIHBsYXRmb3JtLCBjb29raWVOYW1lKSB7XG4gICAgICAgIHRoaXMuZG9jID0gZG9jO1xuICAgICAgICB0aGlzLnBsYXRmb3JtID0gcGxhdGZvcm07XG4gICAgICAgIHRoaXMuY29va2llTmFtZSA9IGNvb2tpZU5hbWU7XG4gICAgICAgIHRoaXMubGFzdENvb2tpZVN0cmluZyA9ICcnO1xuICAgICAgICB0aGlzLmxhc3RUb2tlbiA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBcXEBpbnRlcm5hbCBmb3IgdGVzdGluZ1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wYXJzZUNvdW50ID0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBIdHRwWHNyZkNvb2tpZUV4dHJhY3Rvci5wcm90b3R5cGUuZ2V0VG9rZW4gPSAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMucGxhdGZvcm0gPT09ICdzZXJ2ZXInKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb29raWVTdHJpbmcgPSB0aGlzLmRvYy5jb29raWUgfHwgJyc7XG4gICAgICAgIGlmIChjb29raWVTdHJpbmcgIT09IHRoaXMubGFzdENvb2tpZVN0cmluZykge1xuICAgICAgICAgICAgdGhpcy5wYXJzZUNvdW50Kys7XG4gICAgICAgICAgICB0aGlzLmxhc3RUb2tlbiA9IF9hbmd1bGFyX2NvbW1vbi7JtXBhcnNlQ29va2llVmFsdWUoY29va2llU3RyaW5nLCB0aGlzLmNvb2tpZU5hbWUpO1xuICAgICAgICAgICAgdGhpcy5sYXN0Q29va2llU3RyaW5nID0gY29va2llU3RyaW5nO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmxhc3RUb2tlbjtcbiAgICB9O1xuICAgIEh0dHBYc3JmQ29va2llRXh0cmFjdG9yLmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3RhYmxlIH0sXG4gICAgXTtcbiAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICBIdHRwWHNyZkNvb2tpZUV4dHJhY3Rvci5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICAgICAgeyB0eXBlOiB1bmRlZmluZWQsIGRlY29yYXRvcnM6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5qZWN0LCBhcmdzOiBbX2FuZ3VsYXJfY29tbW9uLkRPQ1VNRU5ULF0gfSxdIH0sXG4gICAgICAgIHsgdHlwZTogdW5kZWZpbmVkLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdCwgYXJnczogW19hbmd1bGFyX2NvcmUuUExBVEZPUk1fSUQsXSB9LF0gfSxcbiAgICAgICAgeyB0eXBlOiB1bmRlZmluZWQsIGRlY29yYXRvcnM6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5qZWN0LCBhcmdzOiBbWFNSRl9DT09LSUVfTkFNRSxdIH0sXSB9LFxuICAgIF07IH07XG4gICAgcmV0dXJuIEh0dHBYc3JmQ29va2llRXh0cmFjdG9yO1xufSgpKTtcbi8qKlxuICogYEh0dHBJbnRlcmNlcHRvcmAgd2hpY2ggYWRkcyBhbiBYU1JGIHRva2VuIHRvIGVsaWdpYmxlIG91dGdvaW5nIHJlcXVlc3RzLlxuICovXG52YXIgSHR0cFhzcmZJbnRlcmNlcHRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSHR0cFhzcmZJbnRlcmNlcHRvcih0b2tlblNlcnZpY2UsIGhlYWRlck5hbWUpIHtcbiAgICAgICAgdGhpcy50b2tlblNlcnZpY2UgPSB0b2tlblNlcnZpY2U7XG4gICAgICAgIHRoaXMuaGVhZGVyTmFtZSA9IGhlYWRlck5hbWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcmVxXG4gICAgICogQHBhcmFtIHs/fSBuZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBIdHRwWHNyZkludGVyY2VwdG9yLnByb3RvdHlwZS5pbnRlcmNlcHQgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IHJlcVxuICAgICAqIEBwYXJhbSB7P30gbmV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKHJlcSwgbmV4dCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBsY1VybCA9IHJlcS51cmwudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgLy8gU2tpcCBib3RoIG5vbi1tdXRhdGluZyByZXF1ZXN0cyBhbmQgYWJzb2x1dGUgVVJMcy5cbiAgICAgICAgLy8gTm9uLW11dGF0aW5nIHJlcXVlc3RzIGRvbid0IHJlcXVpcmUgYSB0b2tlbiwgYW5kIGFic29sdXRlIFVSTHMgcmVxdWlyZSBzcGVjaWFsIGhhbmRsaW5nXG4gICAgICAgIC8vIGFueXdheSBhcyB0aGUgY29va2llIHNldFxuICAgICAgICAvLyBvbiBvdXIgb3JpZ2luIGlzIG5vdCB0aGUgc2FtZSBhcyB0aGUgdG9rZW4gZXhwZWN0ZWQgYnkgYW5vdGhlciBvcmlnaW4uXG4gICAgICAgIGlmIChyZXEubWV0aG9kID09PSAnR0VUJyB8fCByZXEubWV0aG9kID09PSAnSEVBRCcgfHwgbGNVcmwuc3RhcnRzV2l0aCgnaHR0cDovLycpIHx8XG4gICAgICAgICAgICBsY1VybC5zdGFydHNXaXRoKCdodHRwczovLycpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV4dC5oYW5kbGUocmVxKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0b2tlbiA9IHRoaXMudG9rZW5TZXJ2aWNlLmdldFRva2VuKCk7XG4gICAgICAgIC8vIEJlIGNhcmVmdWwgbm90IHRvIG92ZXJ3cml0ZSBhbiBleGlzdGluZyBoZWFkZXIgb2YgdGhlIHNhbWUgbmFtZS5cbiAgICAgICAgaWYgKHRva2VuICE9PSBudWxsICYmICFyZXEuaGVhZGVycy5oYXModGhpcy5oZWFkZXJOYW1lKSkge1xuICAgICAgICAgICAgcmVxID0gcmVxLmNsb25lKHsgaGVhZGVyczogcmVxLmhlYWRlcnMuc2V0KHRoaXMuaGVhZGVyTmFtZSwgdG9rZW4pIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXh0LmhhbmRsZShyZXEpO1xuICAgIH07XG4gICAgSHR0cFhzcmZJbnRlcmNlcHRvci5kZWNvcmF0b3JzID0gW1xuICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5qZWN0YWJsZSB9LFxuICAgIF07XG4gICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgSHR0cFhzcmZJbnRlcmNlcHRvci5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICAgICAgeyB0eXBlOiBIdHRwWHNyZlRva2VuRXh0cmFjdG9yLCB9LFxuICAgICAgICB7IHR5cGU6IHVuZGVmaW5lZCwgZGVjb3JhdG9yczogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3QsIGFyZ3M6IFtYU1JGX0hFQURFUl9OQU1FLF0gfSxdIH0sXG4gICAgXTsgfTtcbiAgICByZXR1cm4gSHR0cFhzcmZJbnRlcmNlcHRvcjtcbn0oKSk7XG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBhZGRlZCBieSB0c2lja2xlXG4gKiBAc3VwcHJlc3Mge2NoZWNrVHlwZXN9IGNoZWNrZWQgYnkgdHNjXG4gKi9cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8qKlxuICogQ29uc3RydWN0cyBhbiBgSHR0cEhhbmRsZXJgIHRoYXQgYXBwbGllcyBhIGJ1bmNoIG9mIGBIdHRwSW50ZXJjZXB0b3Jgc1xuICogdG8gYSByZXF1ZXN0IGJlZm9yZSBwYXNzaW5nIGl0IHRvIHRoZSBnaXZlbiBgSHR0cEJhY2tlbmRgLlxuICpcbiAqIE1lYW50IHRvIGJlIHVzZWQgYXMgYSBmYWN0b3J5IGZ1bmN0aW9uIHdpdGhpbiBgSHR0cENsaWVudE1vZHVsZWAuXG4gKlxuICogXFxAc3RhYmxlXG4gKiBAcGFyYW0gez99IGJhY2tlbmRcbiAqIEBwYXJhbSB7Pz19IGludGVyY2VwdG9yc1xuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gaW50ZXJjZXB0aW5nSGFuZGxlcihiYWNrZW5kLCBpbnRlcmNlcHRvcnMpIHtcbiAgICBpZiAoaW50ZXJjZXB0b3JzID09PSB2b2lkIDApIHsgaW50ZXJjZXB0b3JzID0gW107IH1cbiAgICBpZiAoIWludGVyY2VwdG9ycykge1xuICAgICAgICByZXR1cm4gYmFja2VuZDtcbiAgICB9XG4gICAgcmV0dXJuIGludGVyY2VwdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbiAobmV4dCwgaW50ZXJjZXB0b3IpIHsgcmV0dXJuIG5ldyBIdHRwSW50ZXJjZXB0b3JIYW5kbGVyKG5leHQsIGludGVyY2VwdG9yKTsgfSwgYmFja2VuZCk7XG59XG4vKipcbiAqIEZhY3RvcnkgZnVuY3Rpb24gdGhhdCBkZXRlcm1pbmVzIHdoZXJlIHRvIHN0b3JlIEpTT05QIGNhbGxiYWNrcy5cbiAqXG4gKiBPcmRpbmFyaWx5IEpTT05QIGNhbGxiYWNrcyBhcmUgc3RvcmVkIG9uIHRoZSBgd2luZG93YCBvYmplY3QsIGJ1dCB0aGlzIG1heSBub3QgZXhpc3RcbiAqIGluIHRlc3QgZW52aXJvbm1lbnRzLiBJbiB0aGF0IGNhc2UsIGNhbGxiYWNrcyBhcmUgc3RvcmVkIG9uIGFuIGFub255bW91cyBvYmplY3QgaW5zdGVhZC5cbiAqXG4gKiBcXEBzdGFibGVcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGpzb25wQ2FsbGJhY2tDb250ZXh0KCkge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gd2luZG93O1xuICAgIH1cbiAgICByZXR1cm4ge307XG59XG4vKipcbiAqIGBOZ01vZHVsZWAgd2hpY2ggYWRkcyBYU1JGIHByb3RlY3Rpb24gc3VwcG9ydCB0byBvdXRnb2luZyByZXF1ZXN0cy5cbiAqXG4gKiBQcm92aWRlZCB0aGUgc2VydmVyIHN1cHBvcnRzIGEgY29va2llLWJhc2VkIFhTUkYgcHJvdGVjdGlvbiBzeXN0ZW0sIHRoaXNcbiAqIG1vZHVsZSBjYW4gYmUgdXNlZCBkaXJlY3RseSB0byBjb25maWd1cmUgWFNSRiBwcm90ZWN0aW9uIHdpdGggdGhlIGNvcnJlY3RcbiAqIGNvb2tpZSBhbmQgaGVhZGVyIG5hbWVzLlxuICpcbiAqIElmIG5vIHN1Y2ggbmFtZXMgYXJlIHByb3ZpZGVkLCB0aGUgZGVmYXVsdCBpcyB0byB1c2UgYFgtWFNSRi1UT0tFTmAgZm9yXG4gKiB0aGUgaGVhZGVyIG5hbWUgYW5kIGBYU1JGLVRPS0VOYCBmb3IgdGhlIGNvb2tpZSBuYW1lLlxuICpcbiAqIFxcQHN0YWJsZVxuICovXG52YXIgSHR0cENsaWVudFhzcmZNb2R1bGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEh0dHBDbGllbnRYc3JmTW9kdWxlKCkge1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEaXNhYmxlIHRoZSBkZWZhdWx0IFhTUkYgcHJvdGVjdGlvbi5cbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBEaXNhYmxlIHRoZSBkZWZhdWx0IFhTUkYgcHJvdGVjdGlvbi5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEh0dHBDbGllbnRYc3JmTW9kdWxlLmRpc2FibGUgPSAvKipcbiAgICAgKiBEaXNhYmxlIHRoZSBkZWZhdWx0IFhTUkYgcHJvdGVjdGlvbi5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5nTW9kdWxlOiBIdHRwQ2xpZW50WHNyZk1vZHVsZSxcbiAgICAgICAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICAgICAgICAgIHsgcHJvdmlkZTogSHR0cFhzcmZJbnRlcmNlcHRvciwgdXNlQ2xhc3M6IE5vb3BJbnRlcmNlcHRvciB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENvbmZpZ3VyZSBYU1JGIHByb3RlY3Rpb24gdG8gdXNlIHRoZSBnaXZlbiBjb29raWUgbmFtZSBvciBoZWFkZXIgbmFtZSxcbiAgICAgKiBvciB0aGUgZGVmYXVsdCBuYW1lcyAoYXMgZGVzY3JpYmVkIGFib3ZlKSBpZiBub3QgcHJvdmlkZWQuXG4gICAgICovXG4gICAgLyoqXG4gICAgICogQ29uZmlndXJlIFhTUkYgcHJvdGVjdGlvbiB0byB1c2UgdGhlIGdpdmVuIGNvb2tpZSBuYW1lIG9yIGhlYWRlciBuYW1lLFxuICAgICAqIG9yIHRoZSBkZWZhdWx0IG5hbWVzIChhcyBkZXNjcmliZWQgYWJvdmUpIGlmIG5vdCBwcm92aWRlZC5cbiAgICAgKiBAcGFyYW0gez89fSBvcHRpb25zXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBIdHRwQ2xpZW50WHNyZk1vZHVsZS53aXRoT3B0aW9ucyA9IC8qKlxuICAgICAqIENvbmZpZ3VyZSBYU1JGIHByb3RlY3Rpb24gdG8gdXNlIHRoZSBnaXZlbiBjb29raWUgbmFtZSBvciBoZWFkZXIgbmFtZSxcbiAgICAgKiBvciB0aGUgZGVmYXVsdCBuYW1lcyAoYXMgZGVzY3JpYmVkIGFib3ZlKSBpZiBub3QgcHJvdmlkZWQuXG4gICAgICogQHBhcmFtIHs/PX0gb3B0aW9uc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5nTW9kdWxlOiBIdHRwQ2xpZW50WHNyZk1vZHVsZSxcbiAgICAgICAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuY29va2llTmFtZSA/IHsgcHJvdmlkZTogWFNSRl9DT09LSUVfTkFNRSwgdXNlVmFsdWU6IG9wdGlvbnMuY29va2llTmFtZSB9IDogW10sXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5oZWFkZXJOYW1lID8geyBwcm92aWRlOiBYU1JGX0hFQURFUl9OQU1FLCB1c2VWYWx1ZTogb3B0aW9ucy5oZWFkZXJOYW1lIH0gOiBbXSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBIdHRwQ2xpZW50WHNyZk1vZHVsZS5kZWNvcmF0b3JzID0gW1xuICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuTmdNb2R1bGUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICAgICAgICAgICAgICAgICAgSHR0cFhzcmZJbnRlcmNlcHRvcixcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgcHJvdmlkZTogSFRUUF9JTlRFUkNFUFRPUlMsIHVzZUV4aXN0aW5nOiBIdHRwWHNyZkludGVyY2VwdG9yLCBtdWx0aTogdHJ1ZSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgeyBwcm92aWRlOiBIdHRwWHNyZlRva2VuRXh0cmFjdG9yLCB1c2VDbGFzczogSHR0cFhzcmZDb29raWVFeHRyYWN0b3IgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgcHJvdmlkZTogWFNSRl9DT09LSUVfTkFNRSwgdXNlVmFsdWU6ICdYU1JGLVRPS0VOJyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgeyBwcm92aWRlOiBYU1JGX0hFQURFUl9OQU1FLCB1c2VWYWx1ZTogJ1gtWFNSRi1UT0tFTicgfSxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB9LF0gfSxcbiAgICBdO1xuICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgIEh0dHBDbGllbnRYc3JmTW9kdWxlLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH07XG4gICAgcmV0dXJuIEh0dHBDbGllbnRYc3JmTW9kdWxlO1xufSgpKTtcbi8qKlxuICogYE5nTW9kdWxlYCB3aGljaCBwcm92aWRlcyB0aGUgYEh0dHBDbGllbnRgIGFuZCBhc3NvY2lhdGVkIHNlcnZpY2VzLlxuICpcbiAqIEludGVyY2VwdG9ycyBjYW4gYmUgYWRkZWQgdG8gdGhlIGNoYWluIGJlaGluZCBgSHR0cENsaWVudGAgYnkgYmluZGluZyB0aGVtXG4gKiB0byB0aGUgbXVsdGlwcm92aWRlciBmb3IgYEhUVFBfSU5URVJDRVBUT1JTYC5cbiAqXG4gKiBcXEBzdGFibGVcbiAqL1xudmFyIEh0dHBDbGllbnRNb2R1bGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEh0dHBDbGllbnRNb2R1bGUoKSB7XG4gICAgfVxuICAgIEh0dHBDbGllbnRNb2R1bGUuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLk5nTW9kdWxlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICBpbXBvcnRzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICBIdHRwQ2xpZW50WHNyZk1vZHVsZS53aXRoT3B0aW9ucyh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29va2llTmFtZTogJ1hTUkYtVE9LRU4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlck5hbWU6ICdYLVhTUkYtVE9LRU4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICAgICAgICAgICAgICAgICAgSHR0cENsaWVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEh0dHBIYW5kbGVyIGlzIHRoZSBiYWNrZW5kICsgaW50ZXJjZXB0b3JzIGFuZCBpcyBjb25zdHJ1Y3RlZFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdXNpbmcgdGhlIGludGVyY2VwdGluZ0hhbmRsZXIgZmFjdG9yeSBmdW5jdGlvbi5cbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlOiBIdHRwSGFuZGxlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1c2VGYWN0b3J5OiBpbnRlcmNlcHRpbmdIYW5kbGVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlcHM6IFtIdHRwQmFja2VuZCwgW25ldyBfYW5ndWxhcl9jb3JlLk9wdGlvbmFsKCksIG5ldyBfYW5ndWxhcl9jb3JlLkluamVjdChIVFRQX0lOVEVSQ0VQVE9SUyldXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBIdHRwWGhyQmFja2VuZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgcHJvdmlkZTogSHR0cEJhY2tlbmQsIHVzZUV4aXN0aW5nOiBIdHRwWGhyQmFja2VuZCB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgQnJvd3NlclhocixcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgcHJvdmlkZTogWGhyRmFjdG9yeSwgdXNlRXhpc3Rpbmc6IEJyb3dzZXJYaHIgfSxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB9LF0gfSxcbiAgICBdO1xuICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgIEh0dHBDbGllbnRNb2R1bGUuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXTsgfTtcbiAgICByZXR1cm4gSHR0cENsaWVudE1vZHVsZTtcbn0oKSk7XG4vKipcbiAqIGBOZ01vZHVsZWAgd2hpY2ggZW5hYmxlcyBKU09OUCBzdXBwb3J0IGluIGBIdHRwQ2xpZW50YC5cbiAqXG4gKiBXaXRob3V0IHRoaXMgbW9kdWxlLCBKc29ucCByZXF1ZXN0cyB3aWxsIHJlYWNoIHRoZSBiYWNrZW5kXG4gKiB3aXRoIG1ldGhvZCBKU09OUCwgd2hlcmUgdGhleSdsbCBiZSByZWplY3RlZC5cbiAqXG4gKiBcXEBzdGFibGVcbiAqL1xudmFyIEh0dHBDbGllbnRKc29ucE1vZHVsZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSHR0cENsaWVudEpzb25wTW9kdWxlKCkge1xuICAgIH1cbiAgICBIdHRwQ2xpZW50SnNvbnBNb2R1bGUuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLk5nTW9kdWxlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIEpzb25wQ2xpZW50QmFja2VuZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgcHJvdmlkZTogSnNvbnBDYWxsYmFja0NvbnRleHQsIHVzZUZhY3Rvcnk6IGpzb25wQ2FsbGJhY2tDb250ZXh0IH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7IHByb3ZpZGU6IEhUVFBfSU5URVJDRVBUT1JTLCB1c2VDbGFzczogSnNvbnBJbnRlcmNlcHRvciwgbXVsdGk6IHRydWUgfSxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB9LF0gfSxcbiAgICBdO1xuICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgIEh0dHBDbGllbnRKc29ucE1vZHVsZS5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9O1xuICAgIHJldHVybiBIdHRwQ2xpZW50SnNvbnBNb2R1bGU7XG59KCkpO1xuXG5leHBvcnRzLkh0dHBCYWNrZW5kID0gSHR0cEJhY2tlbmQ7XG5leHBvcnRzLkh0dHBIYW5kbGVyID0gSHR0cEhhbmRsZXI7XG5leHBvcnRzLkh0dHBDbGllbnQgPSBIdHRwQ2xpZW50O1xuZXhwb3J0cy5IdHRwSGVhZGVycyA9IEh0dHBIZWFkZXJzO1xuZXhwb3J0cy5IVFRQX0lOVEVSQ0VQVE9SUyA9IEhUVFBfSU5URVJDRVBUT1JTO1xuZXhwb3J0cy5Kc29ucENsaWVudEJhY2tlbmQgPSBKc29ucENsaWVudEJhY2tlbmQ7XG5leHBvcnRzLkpzb25wSW50ZXJjZXB0b3IgPSBKc29ucEludGVyY2VwdG9yO1xuZXhwb3J0cy5IdHRwQ2xpZW50SnNvbnBNb2R1bGUgPSBIdHRwQ2xpZW50SnNvbnBNb2R1bGU7XG5leHBvcnRzLkh0dHBDbGllbnRNb2R1bGUgPSBIdHRwQ2xpZW50TW9kdWxlO1xuZXhwb3J0cy5IdHRwQ2xpZW50WHNyZk1vZHVsZSA9IEh0dHBDbGllbnRYc3JmTW9kdWxlO1xuZXhwb3J0cy7JtWludGVyY2VwdGluZ0hhbmRsZXIgPSBpbnRlcmNlcHRpbmdIYW5kbGVyO1xuZXhwb3J0cy5IdHRwUGFyYW1zID0gSHR0cFBhcmFtcztcbmV4cG9ydHMuSHR0cFVybEVuY29kaW5nQ29kZWMgPSBIdHRwVXJsRW5jb2RpbmdDb2RlYztcbmV4cG9ydHMuSHR0cFJlcXVlc3QgPSBIdHRwUmVxdWVzdDtcbmV4cG9ydHMuSHR0cEVycm9yUmVzcG9uc2UgPSBIdHRwRXJyb3JSZXNwb25zZTtcbmV4cG9ydHMuSHR0cEV2ZW50VHlwZSA9IEh0dHBFdmVudFR5cGU7XG5leHBvcnRzLkh0dHBIZWFkZXJSZXNwb25zZSA9IEh0dHBIZWFkZXJSZXNwb25zZTtcbmV4cG9ydHMuSHR0cFJlc3BvbnNlID0gSHR0cFJlc3BvbnNlO1xuZXhwb3J0cy5IdHRwUmVzcG9uc2VCYXNlID0gSHR0cFJlc3BvbnNlQmFzZTtcbmV4cG9ydHMuSHR0cFhockJhY2tlbmQgPSBIdHRwWGhyQmFja2VuZDtcbmV4cG9ydHMuWGhyRmFjdG9yeSA9IFhockZhY3Rvcnk7XG5leHBvcnRzLkh0dHBYc3JmVG9rZW5FeHRyYWN0b3IgPSBIdHRwWHNyZlRva2VuRXh0cmFjdG9yO1xuZXhwb3J0cy7JtWEgPSBOb29wSW50ZXJjZXB0b3I7XG5leHBvcnRzLsm1YiA9IEpzb25wQ2FsbGJhY2tDb250ZXh0O1xuZXhwb3J0cy7JtWMgPSBqc29ucENhbGxiYWNrQ29udGV4dDtcbmV4cG9ydHMuybVkID0gQnJvd3NlclhocjtcbmV4cG9ydHMuybVnID0gSHR0cFhzcmZDb29raWVFeHRyYWN0b3I7XG5leHBvcnRzLsm1aCA9IEh0dHBYc3JmSW50ZXJjZXB0b3I7XG5leHBvcnRzLsm1ZSA9IFhTUkZfQ09PS0lFX05BTUU7XG5leHBvcnRzLsm1ZiA9IFhTUkZfSEVBREVSX05BTUU7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbn0pKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb21tb24taHR0cC51bWQuanMubWFwXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AYW5ndWxhci9jb21tb24vYnVuZGxlcy9jb21tb24taHR0cC51bWQuanNcbi8vIG1vZHVsZSBpZCA9IDExXG4vLyBtb2R1bGUgY2h1bmtzID0gNCIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBET01JbXBsZW1lbnRhdGlvbjtcblxudmFyIERvY3VtZW50ID0gcmVxdWlyZSgnLi9Eb2N1bWVudCcpO1xudmFyIERvY3VtZW50VHlwZSA9IHJlcXVpcmUoJy4vRG9jdW1lbnRUeXBlJyk7XG52YXIgSFRNTFBhcnNlciA9IHJlcXVpcmUoJy4vSFRNTFBhcnNlcicpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xudmFyIHhtbCA9IHJlcXVpcmUoJy4veG1sbmFtZXMnKTtcblxuLy8gRWFjaCBkb2N1bWVudCBtdXN0IGhhdmUgaXRzIG93biBpbnN0YW5jZSBvZiB0aGUgZG9taW1wbGVtZW50YXRpb24gb2JqZWN0XG4vLyBFdmVuIHRob3VnaCB0aGVzZSBvYmplY3RzIGhhdmUgbm8gc3RhdGVcbmZ1bmN0aW9uIERPTUltcGxlbWVudGF0aW9uKCkge31cblxuXG4vLyBGZWF0dXJlL3ZlcnNpb24gcGFpcnMgdGhhdCBET01JbXBsZW1lbnRhdGlvbi5oYXNGZWF0dXJlKCkgcmV0dXJuc1xuLy8gdHJ1ZSBmb3IuICBJdCByZXR1cm5zIGZhbHNlIGZvciBhbnl0aGluZyBlbHNlLlxudmFyIHN1cHBvcnRlZEZlYXR1cmVzID0ge1xuICAneG1sJzogeyAnJzogdHJ1ZSwgJzEuMCc6IHRydWUsICcyLjAnOiB0cnVlIH0sICAgLy8gRE9NIENvcmVcbiAgJ2NvcmUnOiB7ICcnOiB0cnVlLCAnMi4wJzogdHJ1ZSB9LCAgICAgICAgICAgICAgIC8vIERPTSBDb3JlXG4gICdodG1sJzogeyAnJzogdHJ1ZSwgJzEuMCc6IHRydWUsICcyLjAnOiB0cnVlfSAsICAvLyBIVE1MXG4gICd4aHRtbCc6IHsgJyc6IHRydWUsICcxLjAnOiB0cnVlLCAnMi4wJzogdHJ1ZX0gLCAvLyBIVE1MXG59O1xuXG5ET01JbXBsZW1lbnRhdGlvbi5wcm90b3R5cGUgPSB7XG4gIGhhc0ZlYXR1cmU6IGZ1bmN0aW9uIGhhc0ZlYXR1cmUoZmVhdHVyZSwgdmVyc2lvbikge1xuICAgIHZhciBmID0gc3VwcG9ydGVkRmVhdHVyZXNbKGZlYXR1cmUgfHwgJycpLnRvTG93ZXJDYXNlKCldO1xuICAgIHJldHVybiAoZiAmJiBmW3ZlcnNpb24gfHwgJyddKSB8fCBmYWxzZTtcbiAgfSxcblxuICBjcmVhdGVEb2N1bWVudFR5cGU6IGZ1bmN0aW9uIGNyZWF0ZURvY3VtZW50VHlwZShxdWFsaWZpZWROYW1lLCBwdWJsaWNJZCwgc3lzdGVtSWQpIHtcbiAgICBpZiAoIXhtbC5pc1ZhbGlkTmFtZShxdWFsaWZpZWROYW1lKSkgdXRpbHMuSW52YWxpZENoYXJhY3RlckVycm9yKCk7XG4gICAgaWYgKCF4bWwuaXNWYWxpZFFOYW1lKHF1YWxpZmllZE5hbWUpKSB1dGlscy5OYW1lc3BhY2VFcnJvcigpO1xuXG4gICAgcmV0dXJuIG5ldyBEb2N1bWVudFR5cGUocXVhbGlmaWVkTmFtZSwgcHVibGljSWQsIHN5c3RlbUlkKTtcbiAgfSxcblxuICBjcmVhdGVEb2N1bWVudDogZnVuY3Rpb24gY3JlYXRlRG9jdW1lbnQobmFtZXNwYWNlLCBxdWFsaWZpZWROYW1lLCBkb2N0eXBlKSB7XG4gICAgLy9cbiAgICAvLyBOb3RlIHRoYXQgdGhlIGN1cnJlbnQgRE9NQ29yZSBzcGVjIG1ha2VzIGl0IGltcG9zc2libGUgdG9cbiAgICAvLyBjcmVhdGUgYW4gSFRNTCBkb2N1bWVudCB3aXRoIHRoaXMgZnVuY3Rpb24sIGV2ZW4gaWYgdGhlXG4gICAgLy8gbmFtZXNwYWNlIGFuZCBkb2N0eXBlIGFyZSBwcm9wZXJ0bHkgc2V0LiAgU2VlIHRoaXMgdGhyZWFkOlxuICAgIC8vIGh0dHA6Ly9saXN0cy53My5vcmcvQXJjaGl2ZXMvUHVibGljL3d3dy1kb20vMjAxMUFwckp1bi8wMTMyLmh0bWxcbiAgICAvL1xuICAgIHZhciBkID0gbmV3IERvY3VtZW50KGZhbHNlLCBudWxsKTtcbiAgICB2YXIgZTtcblxuICAgIGlmIChxdWFsaWZpZWROYW1lKVxuICAgICAgZSA9IGQuY3JlYXRlRWxlbWVudE5TKG5hbWVzcGFjZSwgcXVhbGlmaWVkTmFtZSk7XG4gICAgZWxzZVxuICAgICAgZSA9IG51bGw7XG5cbiAgICBpZiAoZG9jdHlwZSkge1xuICAgICAgaWYgKGRvY3R5cGUub3duZXJEb2N1bWVudCkgdXRpbHMuV3JvbmdEb2N1bWVudEVycm9yKCk7XG4gICAgICBkLmFwcGVuZENoaWxkKGRvY3R5cGUpO1xuICAgIH1cblxuICAgIGlmIChlKSBkLmFwcGVuZENoaWxkKGUpO1xuXG4gICAgcmV0dXJuIGQ7XG4gIH0sXG5cbiAgY3JlYXRlSFRNTERvY3VtZW50OiBmdW5jdGlvbiBjcmVhdGVIVE1MRG9jdW1lbnQodGl0bGVUZXh0KSB7XG4gICAgdmFyIGQgPSBuZXcgRG9jdW1lbnQodHJ1ZSwgbnVsbCk7XG4gICAgZC5hcHBlbmRDaGlsZChuZXcgRG9jdW1lbnRUeXBlKCdodG1sJykpO1xuICAgIHZhciBodG1sID0gZC5jcmVhdGVFbGVtZW50KCdodG1sJyk7XG4gICAgZC5hcHBlbmRDaGlsZChodG1sKTtcbiAgICB2YXIgaGVhZCA9IGQuY3JlYXRlRWxlbWVudCgnaGVhZCcpO1xuICAgIGh0bWwuYXBwZW5kQ2hpbGQoaGVhZCk7XG4gICAgdmFyIHRpdGxlID0gZC5jcmVhdGVFbGVtZW50KCd0aXRsZScpO1xuICAgIGhlYWQuYXBwZW5kQ2hpbGQodGl0bGUpO1xuICAgIHRpdGxlLmFwcGVuZENoaWxkKGQuY3JlYXRlVGV4dE5vZGUodGl0bGVUZXh0KSk7XG4gICAgaHRtbC5hcHBlbmRDaGlsZChkLmNyZWF0ZUVsZW1lbnQoJ2JvZHknKSk7XG4gICAgZC5tb2RjbG9jayA9IDE7IC8vIFN0YXJ0IHRyYWNraW5nIG1vZGlmaWNhdGlvbnNcbiAgICByZXR1cm4gZDtcbiAgfSxcblxuICBtb3pTZXRPdXRwdXRNdXRhdGlvbkhhbmRsZXI6IGZ1bmN0aW9uKGRvYywgaGFuZGxlcikge1xuICAgIGRvYy5tdXRhdGlvbkhhbmRsZXIgPSBoYW5kbGVyO1xuICB9LFxuXG4gIG1vekdldElucHV0TXV0YXRpb25IYW5kbGVyOiBmdW5jdGlvbihkb2MpIHtcbiAgICB1dGlscy5ueWkoKTtcbiAgfSxcblxuICBtb3pIVE1MUGFyc2VyOiBIVE1MUGFyc2VyLFxufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2RvbWluby9saWIvRE9NSW1wbGVtZW50YXRpb24uanNcbi8vIG1vZHVsZSBpZCA9IDEyXG4vLyBtb2R1bGUgY2h1bmtzID0gNCIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBOb2RlTGlzdDtcblxuZnVuY3Rpb24gaXRlbShpKSB7XG4gIC8qIGpzaGludCB2YWxpZHRoaXM6IHRydWUgKi9cbiAgcmV0dXJuIHRoaXNbaV07XG59XG5cbmZ1bmN0aW9uIE5vZGVMaXN0KGEpIHtcbiAgaWYgKCFhKSBhID0gW107XG4gIGEuaXRlbSA9IGl0ZW07XG4gIHJldHVybiBhO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZG9taW5vL2xpYi9Ob2RlTGlzdC5qc1xuLy8gbW9kdWxlIGlkID0gMTNcbi8vIG1vZHVsZSBjaHVua3MgPSA0IiwiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IENoYXJhY3RlckRhdGE7XG5cbnZhciBMZWFmID0gcmVxdWlyZSgnLi9MZWFmJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG52YXIgQ2hpbGROb2RlID0gcmVxdWlyZSgnLi9DaGlsZE5vZGUnKTtcbnZhciBOb25Eb2N1bWVudFR5cGVDaGlsZE5vZGUgPSByZXF1aXJlKCcuL05vbkRvY3VtZW50VHlwZUNoaWxkTm9kZScpO1xuXG5mdW5jdGlvbiBDaGFyYWN0ZXJEYXRhKCkge1xufVxuXG5DaGFyYWN0ZXJEYXRhLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoTGVhZi5wcm90b3R5cGUsIHtcbiAgLy8gRE9NU3RyaW5nIHN1YnN0cmluZ0RhdGEodW5zaWduZWQgbG9uZyBvZmZzZXQsXG4gIC8vICAgICAgICAgICAgICAgdW5zaWduZWQgbG9uZyBjb3VudCk7XG4gIC8vIFRoZSBzdWJzdHJpbmdEYXRhKG9mZnNldCwgY291bnQpIG1ldGhvZCBtdXN0IHJ1biB0aGVzZSBzdGVwczpcbiAgLy9cbiAgLy8gICAgIElmIG9mZnNldCBpcyBncmVhdGVyIHRoYW4gdGhlIGNvbnRleHQgb2JqZWN0J3NcbiAgLy8gICAgIGxlbmd0aCwgdGhyb3cgYW4gSU5ERVhfU0laRV9FUlIgZXhjZXB0aW9uIGFuZFxuICAvLyAgICAgdGVybWluYXRlIHRoZXNlIHN0ZXBzLlxuICAvL1xuICAvLyAgICAgSWYgb2Zmc2V0K2NvdW50IGlzIGdyZWF0ZXIgdGhhbiB0aGUgY29udGV4dFxuICAvLyAgICAgb2JqZWN0J3MgbGVuZ3RoLCByZXR1cm4gYSBET01TdHJpbmcgd2hvc2UgdmFsdWUgaXNcbiAgLy8gICAgIHRoZSBVVEYtMTYgY29kZSB1bml0cyBmcm9tIHRoZSBvZmZzZXR0aCBVVEYtMTYgY29kZVxuICAvLyAgICAgdW5pdCB0byB0aGUgZW5kIG9mIGRhdGEuXG4gIC8vXG4gIC8vICAgICBSZXR1cm4gYSBET01TdHJpbmcgd2hvc2UgdmFsdWUgaXMgdGhlIFVURi0xNiBjb2RlXG4gIC8vICAgICB1bml0cyBmcm9tIHRoZSBvZmZzZXR0aCBVVEYtMTYgY29kZSB1bml0IHRvIHRoZVxuICAvLyAgICAgb2Zmc2V0K2NvdW50dGggVVRGLTE2IGNvZGUgdW5pdCBpbiBkYXRhLlxuICBzdWJzdHJpbmdEYXRhOiB7IHZhbHVlOiBmdW5jdGlvbiBzdWJzdHJpbmdEYXRhKG9mZnNldCwgY291bnQpIHtcbiAgICBpZiAob2Zmc2V0ID4gdGhpcy5kYXRhLmxlbmd0aCB8fCBvZmZzZXQgPCAwIHx8IGNvdW50IDwgMCkgXG4gICAgICB1dGlscy5JbmRleFNpemVFcnJvcigpO1xuICAgIHJldHVybiB0aGlzLmRhdGEuc3Vic3RyaW5nKG9mZnNldCwgb2Zmc2V0K2NvdW50KTtcbiAgfX0sXG5cbiAgLy8gdm9pZCBhcHBlbmREYXRhKERPTVN0cmluZyBkYXRhKTtcbiAgLy8gVGhlIGFwcGVuZERhdGEoZGF0YSkgbWV0aG9kIG11c3QgYXBwZW5kIGRhdGEgdG8gdGhlIGNvbnRleHRcbiAgLy8gb2JqZWN0J3MgZGF0YS5cbiAgYXBwZW5kRGF0YTogeyB2YWx1ZTogZnVuY3Rpb24gYXBwZW5kRGF0YShkYXRhKSB7XG4gICAgdGhpcy5kYXRhID0gdGhpcy5kYXRhICsgZGF0YTtcbiAgfX0sXG5cbiAgLy8gdm9pZCBpbnNlcnREYXRhKHVuc2lnbmVkIGxvbmcgb2Zmc2V0LCBET01TdHJpbmcgZGF0YSk7XG4gIC8vIFRoZSBpbnNlcnREYXRhKG9mZnNldCwgZGF0YSkgbWV0aG9kIG11c3QgcnVuIHRoZXNlIHN0ZXBzOlxuICAvL1xuICAvLyAgICAgSWYgb2Zmc2V0IGlzIGdyZWF0ZXIgdGhhbiB0aGUgY29udGV4dCBvYmplY3Qnc1xuICAvLyAgICAgbGVuZ3RoLCB0aHJvdyBhbiBJTkRFWF9TSVpFX0VSUiBleGNlcHRpb24gYW5kXG4gIC8vICAgICB0ZXJtaW5hdGUgdGhlc2Ugc3RlcHMuXG4gIC8vXG4gIC8vICAgICBJbnNlcnQgZGF0YSBpbnRvIHRoZSBjb250ZXh0IG9iamVjdCdzIGRhdGEgYWZ0ZXJcbiAgLy8gICAgIG9mZnNldCBVVEYtMTYgY29kZSB1bml0cy5cbiAgLy9cbiAgaW5zZXJ0RGF0YTogeyB2YWx1ZTogZnVuY3Rpb24gaW5zZXJ0RGF0YShvZmZzZXQsIGRhdGEpIHtcbiAgICB2YXIgY3VydGV4dCA9IHRoaXMuZGF0YTtcbiAgICBpZiAob2Zmc2V0ID4gY3VydGV4dC5sZW5ndGggfHwgb2Zmc2V0IDwgMCkgdXRpbHMuSW5kZXhTaXplRXJyb3IoKTtcbiAgICB2YXIgcHJlZml4ID0gY3VydGV4dC5zdWJzdHJpbmcoMCwgb2Zmc2V0KSxcbiAgICBzdWZmaXggPSBjdXJ0ZXh0LnN1YnN0cmluZyhvZmZzZXQpO1xuICAgIHRoaXMuZGF0YSA9IHByZWZpeCArIGRhdGEgKyBzdWZmaXg7XG4gIH19LFxuXG5cbiAgLy8gdm9pZCBkZWxldGVEYXRhKHVuc2lnbmVkIGxvbmcgb2Zmc2V0LCB1bnNpZ25lZCBsb25nIGNvdW50KTtcbiAgLy8gVGhlIGRlbGV0ZURhdGEob2Zmc2V0LCBjb3VudCkgbWV0aG9kIG11c3QgcnVuIHRoZXNlIHN0ZXBzOlxuICAvL1xuICAvLyAgICAgSWYgb2Zmc2V0IGlzIGdyZWF0ZXIgdGhhbiB0aGUgY29udGV4dCBvYmplY3Qnc1xuICAvLyAgICAgbGVuZ3RoLCB0aHJvdyBhbiBJTkRFWF9TSVpFX0VSUiBleGNlcHRpb24gYW5kXG4gIC8vICAgICB0ZXJtaW5hdGUgdGhlc2Ugc3RlcHMuXG4gIC8vXG4gIC8vICAgICBJZiBvZmZzZXQrY291bnQgaXMgZ3JlYXRlciB0aGFuIHRoZSBjb250ZXh0XG4gIC8vICAgICBvYmplY3QncyBsZW5ndGggdmFyIGNvdW50IGJlIGxlbmd0aC1vZmZzZXQuXG4gIC8vXG4gIC8vICAgICBTdGFydGluZyBmcm9tIG9mZnNldCBVVEYtMTYgY29kZSB1bml0cyByZW1vdmUgY291bnRcbiAgLy8gICAgIFVURi0xNiBjb2RlIHVuaXRzIGZyb20gdGhlIGNvbnRleHQgb2JqZWN0J3MgZGF0YS5cbiAgZGVsZXRlRGF0YTogeyB2YWx1ZTogZnVuY3Rpb24gZGVsZXRlRGF0YShvZmZzZXQsIGNvdW50KSB7XG4gICAgdmFyIGN1cnRleHQgPSB0aGlzLmRhdGEsIGxlbiA9IGN1cnRleHQubGVuZ3RoO1xuXG4gICAgaWYgKG9mZnNldCA+IGxlbiB8fCBvZmZzZXQgPCAwKSB1dGlscy5JbmRleFNpemVFcnJvcigpO1xuXG4gICAgaWYgKG9mZnNldCtjb3VudCA+IGxlbilcbiAgICAgIGNvdW50ID0gbGVuIC0gb2Zmc2V0O1xuXG4gICAgdmFyIHByZWZpeCA9IGN1cnRleHQuc3Vic3RyaW5nKDAsIG9mZnNldCksXG4gICAgc3VmZml4ID0gY3VydGV4dC5zdWJzdHJpbmcob2Zmc2V0K2NvdW50KTtcblxuICAgIHRoaXMuZGF0YSA9IHByZWZpeCArIHN1ZmZpeDtcbiAgfX0sXG5cblxuICAvLyB2b2lkIHJlcGxhY2VEYXRhKHVuc2lnbmVkIGxvbmcgb2Zmc2V0LCB1bnNpZ25lZCBsb25nIGNvdW50LFxuICAvLyAgICAgICAgICBET01TdHJpbmcgZGF0YSk7XG4gIC8vXG4gIC8vIFRoZSByZXBsYWNlRGF0YShvZmZzZXQsIGNvdW50LCBkYXRhKSBtZXRob2QgbXVzdCBhY3QgYXNcbiAgLy8gaWYgdGhlIGRlbGV0ZURhdGEoKSBtZXRob2QgaXMgaW52b2tlZCB3aXRoIG9mZnNldCBhbmRcbiAgLy8gY291bnQgYXMgYXJndW1lbnRzIGZvbGxvd2VkIGJ5IHRoZSBpbnNlcnREYXRhKCkgbWV0aG9kXG4gIC8vIHdpdGggb2Zmc2V0IGFuZCBkYXRhIGFzIGFyZ3VtZW50cyBhbmQgcmUtdGhyb3cgYW55XG4gIC8vIGV4Y2VwdGlvbnMgdGhlc2UgbWV0aG9kcyBtaWdodCBoYXZlIHRocm93bi5cbiAgcmVwbGFjZURhdGE6IHsgdmFsdWU6IGZ1bmN0aW9uIHJlcGxhY2VEYXRhKG9mZnNldCwgY291bnQsIGRhdGEpIHtcbiAgICB2YXIgY3VydGV4dCA9IHRoaXMuZGF0YSwgbGVuID0gY3VydGV4dC5sZW5ndGg7XG5cbiAgICBpZiAob2Zmc2V0ID4gbGVuIHx8IG9mZnNldCA8IDApIHV0aWxzLkluZGV4U2l6ZUVycm9yKCk7XG5cbiAgICBpZiAob2Zmc2V0K2NvdW50ID4gbGVuKVxuICAgICAgY291bnQgPSBsZW4gLSBvZmZzZXQ7XG5cbiAgICB2YXIgcHJlZml4ID0gY3VydGV4dC5zdWJzdHJpbmcoMCwgb2Zmc2V0KSxcbiAgICBzdWZmaXggPSBjdXJ0ZXh0LnN1YnN0cmluZyhvZmZzZXQrY291bnQpO1xuXG4gICAgdGhpcy5kYXRhID0gcHJlZml4ICsgZGF0YSArIHN1ZmZpeDtcbiAgfX0sXG5cbiAgLy8gVXRpbGl0eSBtZXRob2QgdGhhdCBOb2RlLmlzRXF1YWxOb2RlKCkgY2FsbHMgdG8gdGVzdCBUZXh0IGFuZFxuICAvLyBDb21tZW50IG5vZGVzIGZvciBlcXVhbGl0eS4gIEl0IGlzIG9rYXkgdG8gcHV0IGl0IGhlcmUsIHNpbmNlXG4gIC8vIE5vZGUgd2lsbCBoYXZlIGFscmVhZHkgdmVyaWZpZWQgdGhhdCBub2RlVHlwZSBpcyBlcXVhbFxuICBpc0VxdWFsOiB7IHZhbHVlOiBmdW5jdGlvbiBpc0VxdWFsKG4pIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YSA9PT0gbi5fZGF0YTtcbiAgfX0sXG5cbiAgbGVuZ3RoOiB7IGdldDogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLmRhdGEubGVuZ3RoOyB9fVxuXG59KTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoQ2hhcmFjdGVyRGF0YS5wcm90b3R5cGUsIENoaWxkTm9kZSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhDaGFyYWN0ZXJEYXRhLnByb3RvdHlwZSwgTm9uRG9jdW1lbnRUeXBlQ2hpbGROb2RlKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2RvbWluby9saWIvQ2hhcmFjdGVyRGF0YS5qc1xuLy8gbW9kdWxlIGlkID0gMTRcbi8vIG1vZHVsZSBjaHVua3MgPSA0IiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgTm9kZUZpbHRlciA9IHtcbiAgLy8gQ29uc3RhbnRzIGZvciBhY2NlcHROb2RlKClcbiAgRklMVEVSX0FDQ0VQVDogMSxcbiAgRklMVEVSX1JFSkVDVDogMixcbiAgRklMVEVSX1NLSVA6IDMsXG5cbiAgLy8gQ29uc3RhbnRzIGZvciB3aGF0VG9TaG93XG4gIFNIT1dfQUxMOiAweEZGRkZGRkZGLFxuICBTSE9XX0VMRU1FTlQ6IDB4MSxcbiAgU0hPV19BVFRSSUJVVEU6IDB4MiwgLy8gaGlzdG9yaWNhbFxuICBTSE9XX1RFWFQ6IDB4NCxcbiAgU0hPV19DREFUQV9TRUNUSU9OOiAweDgsIC8vIGhpc3RvcmljYWxcbiAgU0hPV19FTlRJVFlfUkVGRVJFTkNFOiAweDEwLCAvLyBoaXN0b3JpY2FsXG4gIFNIT1dfRU5USVRZOiAweDIwLCAvLyBoaXN0b3JpY2FsXG4gIFNIT1dfUFJPQ0VTU0lOR19JTlNUUlVDVElPTjogMHg0MCxcbiAgU0hPV19DT01NRU5UOiAweDgwLFxuICBTSE9XX0RPQ1VNRU5UOiAweDEwMCxcbiAgU0hPV19ET0NVTUVOVF9UWVBFOiAweDIwMCxcbiAgU0hPV19ET0NVTUVOVF9GUkFHTUVOVDogMHg0MDAsXG4gIFNIT1dfTk9UQVRJT046IDB4ODAwIC8vIGhpc3RvcmljYWxcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gKE5vZGVGaWx0ZXIuY29uc3RydWN0b3IgPSBOb2RlRmlsdGVyLnByb3RvdHlwZSA9IE5vZGVGaWx0ZXIpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZG9taW5vL2xpYi9Ob2RlRmlsdGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAxNVxuLy8gbW9kdWxlIGNodW5rcyA9IDQiLCJtb2R1bGUuZXhwb3J0cyA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKDIpKSgzNzcpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGRlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9AYW5ndWxhci9mb3Jtcy9idW5kbGVzL2Zvcm1zLnVtZC5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgLi92ZW5kb3Jcbi8vIG1vZHVsZSBpZCA9IDE2XG4vLyBtb2R1bGUgY2h1bmtzID0gNCIsIm1vZHVsZS5leHBvcnRzID0gKF9fd2VicGFja19yZXF1aXJlX18oMikpKDk2KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBkZWxlZ2F0ZWQgLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanMgZnJvbSBkbGwtcmVmZXJlbmNlIC4vdmVuZG9yXG4vLyBtb2R1bGUgaWQgPSAxN1xuLy8gbW9kdWxlIGNodW5rcyA9IDQiLCJpbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IFJvdXRlciB9IGZyb20gJ0Bhbmd1bGFyL3JvdXRlcic7XHJcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICdyeGpzL1J4JztcclxuXHJcbkBJbmplY3RhYmxlKClcclxuZXhwb3J0IGNsYXNzIFV0aWxpdHlTZXJ2aWNlIHtcclxuICAgIHB1YmxpYyBfcm91dGVyOiBSb3V0ZXI7XHJcbiAgICBjb25zdHJ1Y3Rvcihyb3V0ZXI6IFJvdXRlcikge1xyXG4gICAgICAgIHRoaXMuX3JvdXRlciA9IHJvdXRlcjtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgY29udmVydERhdGVUaW1lKGRhdGU6IERhdGUpIHtcclxuICAgICAgICBjb25zdCBfZm9ybWF0dGVkRGF0ZSA9IG5ldyBEYXRlKGRhdGUudG9TdHJpbmcoKSk7XHJcbiAgICAgICAgcmV0dXJuIF9mb3JtYXR0ZWREYXRlLnRvRGF0ZVN0cmluZygpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBuYXZpZ2F0ZShwYXRoOiBzdHJpbmcpIHtcclxuICAgICAgICB0aGlzLl9yb3V0ZXIubmF2aWdhdGUoW3BhdGhdKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgbmF2aWdhdGVUb1NpZ25JbigpIHtcclxuICAgICAgICB0aGlzLm5hdmlnYXRlKCcvbG9naW4nKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0UGFyYW1zKCkge1xyXG4gICAgICAgIGNvbnN0IHNlYXJjaFBhcmFtcyA9IHdpbmRvdy5sb2NhdGlvbi5zZWFyY2guc3BsaXQoJz8nKVsxXTtcclxuICAgICAgICBpZiAoc2VhcmNoUGFyYW1zKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHBhcmFtc09iajogYW55ID0ge307XHJcblxyXG4gICAgICAgICAgICBzZWFyY2hQYXJhbXMuc3BsaXQoJyYnKS5mb3JFYWNoKGkgPT4ge1xyXG4gICAgICAgICAgICAgICAgcGFyYW1zT2JqW2kuc3BsaXQoJz0nKVswXV0gPSBpLnNwbGl0KCc9JylbMV07XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gcGFyYW1zT2JqO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG4gICAgcHVibGljIHJlYWRhYmxlQ29sdW1uTmFtZShjb2x1bW5OYW1lOiBzdHJpbmcpOiBzdHJpbmcge1xyXG4gICAgICAgIC8vIENvbnZlcnQgdW5kZXJzY29yZXMgdG8gc3BhY2VzXHJcbiAgICAgICAgaWYgKHR5cGVvZiAoY29sdW1uTmFtZSkgPT09ICd1bmRlZmluZWQnIHx8IGNvbHVtbk5hbWUgPT09IHVuZGVmaW5lZCB8fCBjb2x1bW5OYW1lID09PSBudWxsKSB7IHJldHVybiBjb2x1bW5OYW1lOyB9XHJcblxyXG4gICAgICAgIGlmICh0eXBlb2YgKGNvbHVtbk5hbWUpICE9PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICBjb2x1bW5OYW1lID0gU3RyaW5nKGNvbHVtbk5hbWUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGNvbHVtbk5hbWUucmVwbGFjZSgvXysvZywgJyAnKVxyXG4gICAgICAgICAgICAvLyBSZXBsYWNlIGEgY29tcGxldGVseSBhbGwtY2Fwc2VkIHdvcmQgd2l0aCBhIGZpcnN0LWxldHRlci1jYXBpdGFsaXplZCB2ZXJzaW9uXHJcbiAgICAgICAgICAgIC5yZXBsYWNlKC9eW0EtWl0rJC8sIChtYXRjaCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICgobWF0Y2guY2hhckF0KDApKS50b1VwcGVyQ2FzZSgpICsgbWF0Y2guc2xpY2UoMSkpLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC8vIENhcGl0YWxpemUgdGhlIGZpcnN0IGxldHRlciBvZiB3b3Jkc1xyXG4gICAgICAgICAgICAucmVwbGFjZSgvKFtcXHdcXHUwMEMwLVxcdTAxN0ZdKykvZywgKG1hdGNoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKG1hdGNoLmNoYXJBdCgwKSkudG9VcHBlckNhc2UoKSArIG1hdGNoLnNsaWNlKDEpO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAvLyBQdXQgYSBzcGFjZSBpbiBiZXR3ZWVuIHdvcmRzIHRoYXQgaGF2ZSBwYXJ0aWFsIGNhcGlsaXphdGlvbnMgKGkuZS4gJ2ZpcnN0TmFtZScgYmVjb21lcyAnRmlyc3QgTmFtZScpXHJcbiAgICAgICAgICAgIC8vIC5yZXBsYWNlKC8oW0EtWl18W0EtWl1cXHcrKShbQS1aXSkvZywgXCIkMSAkMlwiKTtcclxuICAgICAgICAgICAgLy8gLnJlcGxhY2UoLyhcXHcrP3xcXHcpKFtBLVpdKS9nLCBcIiQxICQyXCIpO1xyXG4gICAgICAgICAgICAucmVwbGFjZSgvKFxcdys/KD89W0EtWl0pKS9nLCAnJDEgJyk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGxvYWRTdHlsZShsaW5rOiBzdHJpbmcpOiBPYnNlcnZhYmxlPGFueT4ge1xyXG4gICAgICAgIGlmICh0aGlzLmlzTG9hZGVkU3R5bGUobGluaykpIHtcclxuICAgICAgICAgICAgcmV0dXJuIE9ic2VydmFibGUub2YoJycpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGhlYWQgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdO1xyXG4gICAgICAgICAgICAvLyBMb2FkIGpxdWVyeSBVaVxyXG4gICAgICAgICAgICBjb25zdCBzdHlsZU5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsaW5rJyk7XHJcbiAgICAgICAgICAgIHN0eWxlTm9kZS5yZWwgPSAnc3R5bGVzaGVldCc7XHJcbiAgICAgICAgICAgIHN0eWxlTm9kZS50eXBlID0gJ3RleHQvY3NzJztcclxuICAgICAgICAgICAgc3R5bGVOb2RlLmhyZWYgPSBsaW5rO1xyXG4gICAgICAgICAgICBzdHlsZU5vZGUubWVkaWEgPSAnYWxsJztcclxuICAgICAgICAgICAgaGVhZC5hcHBlbmRDaGlsZChzdHlsZU5vZGUpO1xyXG4gICAgICAgICAgICByZXR1cm4gT2JzZXJ2YWJsZS5mcm9tRXZlbnQoc3R5bGVOb2RlLCAnbG9hZCcpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHB1YmxpYyBsb2FkU2NyaXB0KHNjcmlwdDogc3RyaW5nKTogT2JzZXJ2YWJsZTxhbnk+IHtcclxuICAgICAgICBpZiAodGhpcy5pc0xvYWRlZFNjcmlwdChzY3JpcHQpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBPYnNlcnZhYmxlLm9mKCcnKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBoZWFkID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXTtcclxuICAgICAgICAgICAgLy8gTG9hZCBqcXVlcnkgVWlcclxuICAgICAgICAgICAgY29uc3Qgc2NyaXB0Tm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xyXG4gICAgICAgICAgICBzY3JpcHROb2RlLnNyYyA9IHNjcmlwdDtcclxuICAgICAgICAgICAgc2NyaXB0Tm9kZS5hc3luYyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAvLyBzY3JpcHROb2RlLnR5cGUgPSAndGV4dC9qYXZhc2NyaXB0JztcclxuICAgICAgICAgICAgLy8gc2NyaXB0Tm9kZS5jaGFyc2V0ID0gJ3V0Zi04JztcclxuICAgICAgICAgICAgaGVhZC5pbnNlcnRCZWZvcmUoc2NyaXB0Tm9kZSwgaGVhZC5maXJzdENoaWxkKTtcclxuICAgICAgICAgICAgcmV0dXJuIE9ic2VydmFibGUuZnJvbUV2ZW50KHNjcmlwdE5vZGUsICdsb2FkJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIERldGVjdCBpZiBsaWJyYXJ5IGxvYWRlZFxyXG4gICAgcHJpdmF0ZSBpc0xvYWRlZFNjcmlwdChsaWI6IHN0cmluZykge1xyXG4gICAgICAgIHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdbc3JjPVwiJyArIGxpYiArICdcIl0nKS5sZW5ndGggPiAwO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgaXNMb2FkZWRTdHlsZShsaWI6IHN0cmluZykge1xyXG4gICAgICAgIHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdbaHJlZj1cIicgKyBsaWIgKyAnXCJdJykubGVuZ3RoID4gMDtcclxuICAgIH1cclxuXHJcbn1cclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2FuZ3VsYXIyLXRlbXBsYXRlLWxvYWRlciEuL0NsaWVudEFwcC9hcHAvY29yZS9zZXJ2aWNlcy91dGlsaXR5LnNlcnZpY2UudHMiLCIvKipcbiAqIEBsaWNlbnNlIEFuZ3VsYXIgdjUuMC4wLWJldGEuN1xuICogKGMpIDIwMTAtMjAxNyBHb29nbGUsIEluYy4gaHR0cHM6Ly9hbmd1bGFyLmlvL1xuICogTGljZW5zZTogTUlUXG4gKi9cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG5cdHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cykgOlxuXHR0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJ10sIGZhY3RvcnkpIDpcblx0KGZhY3RvcnkoKGdsb2JhbC5uZyA9IGdsb2JhbC5uZyB8fCB7fSwgZ2xvYmFsLm5nLmFuaW1hdGlvbnMgPSB7fSkpKTtcbn0odGhpcywgKGZ1bmN0aW9uIChleHBvcnRzKSB7ICd1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBAbGljZW5zZSBBbmd1bGFyIHY1LjAuMC1iZXRhLjdcbiAqIChjKSAyMDEwLTIwMTcgR29vZ2xlLCBJbmMuIGh0dHBzOi8vYW5ndWxhci5pby9cbiAqIExpY2Vuc2U6IE1JVFxuICovXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgYWRkZWQgYnkgdHNpY2tsZVxuICogQHN1cHByZXNzIHtjaGVja1R5cGVzfSBjaGVja2VkIGJ5IHRzY1xuICovXG4vKipcbiAqIEFuaW1hdGlvbkJ1aWxkZXIgaXMgYW4gaW5qZWN0YWJsZSBzZXJ2aWNlIHRoYXQgaXMgYXZhaWxhYmxlIHdoZW4gdGhlIHtcXEBsaW5rXG4gKiBCcm93c2VyQW5pbWF0aW9uc01vZHVsZSBCcm93c2VyQW5pbWF0aW9uc01vZHVsZX0gb3Ige1xcQGxpbmsgTm9vcEFuaW1hdGlvbnNNb2R1bGVcbiAqIE5vb3BBbmltYXRpb25zTW9kdWxlfSBtb2R1bGVzIGFyZSB1c2VkIHdpdGhpbiBhbiBhcHBsaWNhdGlvbi5cbiAqXG4gKiBUaGUgcHVycG9zZSBpZiB0aGlzIHNlcnZpY2UgaXMgdG8gcHJvZHVjZSBhbiBhbmltYXRpb24gc2VxdWVuY2UgcHJvZ3JhbW1hdGljYWxseSB3aXRoaW4gYW5cbiAqIGFuZ3VsYXIgY29tcG9uZW50IG9yIGRpcmVjdGl2ZS5cbiAqXG4gKiBQcm9ncmFtbWF0aWMgYW5pbWF0aW9ucyBhcmUgZmlyc3QgYnVpbHQgYW5kIHRoZW4gYSBwbGF5ZXIgaXMgY3JlYXRlZCB3aGVuIHRoZSBidWlsZCBhbmltYXRpb24gaXNcbiAqIGF0dGFjaGVkIHRvIGFuIGVsZW1lbnQuXG4gKlxuICogYGBgdHNcbiAqIC8vIHJlbWVtYmVyIHRvIGluY2x1ZGUgdGhlIEJyb3dzZXJBbmltYXRpb25zTW9kdWxlIG1vZHVsZSBmb3IgdGhpcyB0byB3b3JrLi4uXG4gKiBpbXBvcnQge0FuaW1hdGlvbkJ1aWxkZXJ9IGZyb20gJ1xcQGFuZ3VsYXIvYW5pbWF0aW9ucyc7XG4gKlxuICogY2xhc3MgTXlDbXAge1xuICogICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9idWlsZGVyOiBBbmltYXRpb25CdWlsZGVyKSB7fVxuICpcbiAqICAgbWFrZUFuaW1hdGlvbihlbGVtZW50OiBhbnkpIHtcbiAqICAgICAvLyBmaXJzdCBidWlsZCB0aGUgYW5pbWF0aW9uXG4gKiAgICAgY29uc3QgbXlBbmltYXRpb24gPSB0aGlzLl9idWlsZGVyLmJ1aWxkKFtcbiAqICAgICAgIHN0eWxlKHsgd2lkdGg6IDAgfSksXG4gKiAgICAgICBhbmltYXRlKDEwMDAsIHN0eWxlKHsgd2lkdGg6ICcxMDBweCcgfSkpXG4gKiAgICAgXSk7XG4gKlxuICogICAgIC8vIHRoZW4gY3JlYXRlIGEgcGxheWVyIGZyb20gaXRcbiAqICAgICBjb25zdCBwbGF5ZXIgPSBteUFuaW1hdGlvbi5jcmVhdGUoZWxlbWVudCk7XG4gKlxuICogICAgIHBsYXllci5wbGF5KCk7XG4gKiAgIH1cbiAqIH1cbiAqIGBgYFxuICpcbiAqIFdoZW4gYW4gYW5pbWF0aW9uIGlzIGJ1aWx0IGFuIGluc3RhbmNlIG9mIHtcXEBsaW5rIEFuaW1hdGlvbkZhY3RvcnkgQW5pbWF0aW9uRmFjdG9yeX0gd2lsbCBiZVxuICogcmV0dXJuZWQuIFVzaW5nIHRoYXQgYW4ge1xcQGxpbmsgQW5pbWF0aW9uUGxheWVyIEFuaW1hdGlvblBsYXllcn0gY2FuIGJlIGNyZWF0ZWQgd2hpY2ggY2FuIHRoZW4gYmVcbiAqIHVzZWQgdG8gc3RhcnQgdGhlIGFuaW1hdGlvbi5cbiAqXG4gKiBcXEBleHBlcmltZW50YWwgQW5pbWF0aW9uIHN1cHBvcnQgaXMgZXhwZXJpbWVudGFsLlxuICogQGFic3RyYWN0XG4gKi9cbnZhciBBbmltYXRpb25CdWlsZGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBbmltYXRpb25CdWlsZGVyKCkge1xuICAgIH1cbiAgICByZXR1cm4gQW5pbWF0aW9uQnVpbGRlcjtcbn0oKSk7XG4vKipcbiAqIEFuIGluc3RhbmNlIG9mIGBBbmltYXRpb25GYWN0b3J5YCBpcyByZXR1cm5lZCBmcm9tIHtcXEBsaW5rIEFuaW1hdGlvbkJ1aWxkZXIjYnVpbGRcbiAqIEFuaW1hdGlvbkJ1aWxkZXIuYnVpbGR9LlxuICpcbiAqIFxcQGV4cGVyaW1lbnRhbCBBbmltYXRpb24gc3VwcG9ydCBpcyBleHBlcmltZW50YWwuXG4gKiBAYWJzdHJhY3RcbiAqL1xudmFyIEFuaW1hdGlvbkZhY3RvcnkgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEFuaW1hdGlvbkZhY3RvcnkoKSB7XG4gICAgfVxuICAgIHJldHVybiBBbmltYXRpb25GYWN0b3J5O1xufSgpKTtcblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IGFkZGVkIGJ5IHRzaWNrbGVcbiAqIEBzdXBwcmVzcyB7Y2hlY2tUeXBlc30gY2hlY2tlZCBieSB0c2NcbiAqL1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqIEByZWNvcmRcbiAqL1xuXG4vKipcbiAqIFxcQGV4cGVyaW1lbnRhbCBBbmltYXRpb24gc3VwcG9ydCBpcyBleHBlcmltZW50YWwuXG4gKi9cbnZhciBBVVRPX1NUWUxFID0gJyonO1xuLyoqXG4gKiBcXEBleHBlcmltZW50YWwgQW5pbWF0aW9uIHN1cHBvcnQgaXMgZXhwZXJpbWVudGFsLlxuICogQHJlY29yZFxuICovXG5cbi8qKlxuICogTWV0YWRhdGEgcmVwcmVzZW50aW5nIHRoZSBlbnRyeSBvZiBhbmltYXRpb25zLiBJbnN0YW5jZXMgb2YgdGhpcyBpbnRlcmZhY2UgYXJlIHByb3ZpZGVkIHZpYSB0aGVcbiAqIGFuaW1hdGlvbiBEU0wgd2hlbiB0aGUge1xcQGxpbmsgdHJpZ2dlciB0cmlnZ2VyIGFuaW1hdGlvbiBmdW5jdGlvbn0gaXMgY2FsbGVkLlxuICpcbiAqIFxcQGV4cGVyaW1lbnRhbCBBbmltYXRpb24gc3VwcG9ydCBpcyBleHBlcmltZW50YWwuXG4gKiBAcmVjb3JkXG4gKi9cblxuLyoqXG4gKiBNZXRhZGF0YSByZXByZXNlbnRpbmcgdGhlIGVudHJ5IG9mIGFuaW1hdGlvbnMuIEluc3RhbmNlcyBvZiB0aGlzIGludGVyZmFjZSBhcmUgcHJvdmlkZWQgdmlhIHRoZVxuICogYW5pbWF0aW9uIERTTCB3aGVuIHRoZSB7XFxAbGluayBzdGF0ZSBzdGF0ZSBhbmltYXRpb24gZnVuY3Rpb259IGlzIGNhbGxlZC5cbiAqXG4gKiBcXEBleHBlcmltZW50YWwgQW5pbWF0aW9uIHN1cHBvcnQgaXMgZXhwZXJpbWVudGFsLlxuICogQHJlY29yZFxuICovXG5cbi8qKlxuICogTWV0YWRhdGEgcmVwcmVzZW50aW5nIHRoZSBlbnRyeSBvZiBhbmltYXRpb25zLiBJbnN0YW5jZXMgb2YgdGhpcyBpbnRlcmZhY2UgYXJlIHByb3ZpZGVkIHZpYSB0aGVcbiAqIGFuaW1hdGlvbiBEU0wgd2hlbiB0aGUge1xcQGxpbmsgdHJhbnNpdGlvbiB0cmFuc2l0aW9uIGFuaW1hdGlvbiBmdW5jdGlvbn0gaXMgY2FsbGVkLlxuICpcbiAqIFxcQGV4cGVyaW1lbnRhbCBBbmltYXRpb24gc3VwcG9ydCBpcyBleHBlcmltZW50YWwuXG4gKiBAcmVjb3JkXG4gKi9cblxuLyoqXG4gKiBcXEBleHBlcmltZW50YWwgQW5pbWF0aW9uIHN1cHBvcnQgaXMgZXhwZXJpbWVudGFsLlxuICogQHJlY29yZFxuICovXG5cbi8qKlxuICogXFxAZXhwZXJpbWVudGFsIEFuaW1hdGlvbiBzdXBwb3J0IGlzIGV4cGVyaW1lbnRhbC5cbiAqIEByZWNvcmRcbiAqL1xuXG4vKipcbiAqIE1ldGFkYXRhIHJlcHJlc2VudGluZyB0aGUgZW50cnkgb2YgYW5pbWF0aW9ucy4gSW5zdGFuY2VzIG9mIHRoaXMgaW50ZXJmYWNlIGFyZSBwcm92aWRlZCB2aWEgdGhlXG4gKiBhbmltYXRpb24gRFNMIHdoZW4gdGhlIHtcXEBsaW5rIGtleWZyYW1lcyBrZXlmcmFtZXMgYW5pbWF0aW9uIGZ1bmN0aW9ufSBpcyBjYWxsZWQuXG4gKlxuICogXFxAZXhwZXJpbWVudGFsIEFuaW1hdGlvbiBzdXBwb3J0IGlzIGV4cGVyaW1lbnRhbC5cbiAqIEByZWNvcmRcbiAqL1xuXG4vKipcbiAqIE1ldGFkYXRhIHJlcHJlc2VudGluZyB0aGUgZW50cnkgb2YgYW5pbWF0aW9ucy4gSW5zdGFuY2VzIG9mIHRoaXMgaW50ZXJmYWNlIGFyZSBwcm92aWRlZCB2aWEgdGhlXG4gKiBhbmltYXRpb24gRFNMIHdoZW4gdGhlIHtcXEBsaW5rIHN0eWxlIHN0eWxlIGFuaW1hdGlvbiBmdW5jdGlvbn0gaXMgY2FsbGVkLlxuICpcbiAqIFxcQGV4cGVyaW1lbnRhbCBBbmltYXRpb24gc3VwcG9ydCBpcyBleHBlcmltZW50YWwuXG4gKiBAcmVjb3JkXG4gKi9cblxuLyoqXG4gKiBNZXRhZGF0YSByZXByZXNlbnRpbmcgdGhlIGVudHJ5IG9mIGFuaW1hdGlvbnMuIEluc3RhbmNlcyBvZiB0aGlzIGludGVyZmFjZSBhcmUgcHJvdmlkZWQgdmlhIHRoZVxuICogYW5pbWF0aW9uIERTTCB3aGVuIHRoZSB7XFxAbGluayBhbmltYXRlIGFuaW1hdGUgYW5pbWF0aW9uIGZ1bmN0aW9ufSBpcyBjYWxsZWQuXG4gKlxuICogXFxAZXhwZXJpbWVudGFsIEFuaW1hdGlvbiBzdXBwb3J0IGlzIGV4cGVyaW1lbnRhbC5cbiAqIEByZWNvcmRcbiAqL1xuXG4vKipcbiAqIE1ldGFkYXRhIHJlcHJlc2VudGluZyB0aGUgZW50cnkgb2YgYW5pbWF0aW9ucy4gSW5zdGFuY2VzIG9mIHRoaXMgaW50ZXJmYWNlIGFyZSBwcm92aWRlZCB2aWEgdGhlXG4gKiBhbmltYXRpb24gRFNMIHdoZW4gdGhlIHtcXEBsaW5rIGFuaW1hdGVDaGlsZCBhbmltYXRlQ2hpbGQgYW5pbWF0aW9uIGZ1bmN0aW9ufSBpcyBjYWxsZWQuXG4gKlxuICogXFxAZXhwZXJpbWVudGFsIEFuaW1hdGlvbiBzdXBwb3J0IGlzIGV4cGVyaW1lbnRhbC5cbiAqIEByZWNvcmRcbiAqL1xuXG4vKipcbiAqIE1ldGFkYXRhIHJlcHJlc2VudGluZyB0aGUgZW50cnkgb2YgYW5pbWF0aW9ucy4gSW5zdGFuY2VzIG9mIHRoaXMgaW50ZXJmYWNlIGFyZSBwcm92aWRlZCB2aWEgdGhlXG4gKiBhbmltYXRpb24gRFNMIHdoZW4gdGhlIHtcXEBsaW5rIHVzZUFuaW1hdGlvbiB1c2VBbmltYXRpb24gYW5pbWF0aW9uIGZ1bmN0aW9ufSBpcyBjYWxsZWQuXG4gKlxuICogXFxAZXhwZXJpbWVudGFsIEFuaW1hdGlvbiBzdXBwb3J0IGlzIGV4cGVyaW1lbnRhbC5cbiAqIEByZWNvcmRcbiAqL1xuXG4vKipcbiAqIE1ldGFkYXRhIHJlcHJlc2VudGluZyB0aGUgZW50cnkgb2YgYW5pbWF0aW9ucy4gSW5zdGFuY2VzIG9mIHRoaXMgaW50ZXJmYWNlIGFyZSBwcm92aWRlZCB2aWEgdGhlXG4gKiBhbmltYXRpb24gRFNMIHdoZW4gdGhlIHtcXEBsaW5rIHNlcXVlbmNlIHNlcXVlbmNlIGFuaW1hdGlvbiBmdW5jdGlvbn0gaXMgY2FsbGVkLlxuICpcbiAqIFxcQGV4cGVyaW1lbnRhbCBBbmltYXRpb24gc3VwcG9ydCBpcyBleHBlcmltZW50YWwuXG4gKiBAcmVjb3JkXG4gKi9cblxuLyoqXG4gKiBNZXRhZGF0YSByZXByZXNlbnRpbmcgdGhlIGVudHJ5IG9mIGFuaW1hdGlvbnMuIEluc3RhbmNlcyBvZiB0aGlzIGludGVyZmFjZSBhcmUgcHJvdmlkZWQgdmlhIHRoZVxuICogYW5pbWF0aW9uIERTTCB3aGVuIHRoZSB7XFxAbGluayBncm91cCBncm91cCBhbmltYXRpb24gZnVuY3Rpb259IGlzIGNhbGxlZC5cbiAqXG4gKiBcXEBleHBlcmltZW50YWwgQW5pbWF0aW9uIHN1cHBvcnQgaXMgZXhwZXJpbWVudGFsLlxuICogQHJlY29yZFxuICovXG5cbi8qKlxuICogTWV0YWRhdGEgcmVwcmVzZW50aW5nIHRoZSBlbnRyeSBvZiBhbmltYXRpb25zLiBJbnN0YW5jZXMgb2YgdGhpcyBpbnRlcmZhY2UgYXJlIHByb3ZpZGVkIHZpYSB0aGVcbiAqIGFuaW1hdGlvbiBEU0wgd2hlbiB0aGUge1xcQGxpbmsgc3RhZ2dlciBzdGFnZ2VyIGFuaW1hdGlvbiBmdW5jdGlvbn0gaXMgY2FsbGVkLlxuICpcbiAqIFxcQGV4cGVyaW1lbnRhbCBBbmltYXRpb24gc3VwcG9ydCBpcyBleHBlcmltZW50YWwuXG4gKiBAcmVjb3JkXG4gKi9cblxuLyoqXG4gKiBgdHJpZ2dlcmAgaXMgYW4gYW5pbWF0aW9uLXNwZWNpZmljIGZ1bmN0aW9uIHRoYXQgaXMgZGVzaWduZWQgdG8gYmUgdXNlZCBpbnNpZGUgb2YgQW5ndWxhcidzXG4gKiBhbmltYXRpb24gRFNMIGxhbmd1YWdlLiBJZiB0aGlzIGluZm9ybWF0aW9uIGlzIG5ldywgcGxlYXNlIG5hdmlnYXRlIHRvIHRoZVxuICoge1xcQGxpbmsgQ29tcG9uZW50I2FuaW1hdGlvbnMgY29tcG9uZW50IGFuaW1hdGlvbnMgbWV0YWRhdGEgcGFnZX0gdG8gZ2FpbiBhIGJldHRlclxuICogdW5kZXJzdGFuZGluZyBvZiBob3cgYW5pbWF0aW9ucyBpbiBBbmd1bGFyIGFyZSB1c2VkLlxuICpcbiAqIGB0cmlnZ2VyYCBDcmVhdGVzIGFuIGFuaW1hdGlvbiB0cmlnZ2VyIHdoaWNoIHdpbGwgYSBsaXN0IG9mIHtcXEBsaW5rIHN0YXRlIHN0YXRlfSBhbmRcbiAqIHtcXEBsaW5rIHRyYW5zaXRpb24gdHJhbnNpdGlvbn0gZW50cmllcyB0aGF0IHdpbGwgYmUgZXZhbHVhdGVkIHdoZW4gdGhlIGV4cHJlc3Npb25cbiAqIGJvdW5kIHRvIHRoZSB0cmlnZ2VyIGNoYW5nZXMuXG4gKlxuICogVHJpZ2dlcnMgYXJlIHJlZ2lzdGVyZWQgd2l0aGluIHRoZSBjb21wb25lbnQgYW5ub3RhdGlvbiBkYXRhIHVuZGVyIHRoZVxuICoge1xcQGxpbmsgQ29tcG9uZW50I2FuaW1hdGlvbnMgYW5pbWF0aW9ucyBzZWN0aW9ufS4gQW4gYW5pbWF0aW9uIHRyaWdnZXIgY2FuIGJlIHBsYWNlZCBvbiBhbiBlbGVtZW50XG4gKiB3aXRoaW4gYSB0ZW1wbGF0ZSBieSByZWZlcmVuY2luZyB0aGUgbmFtZSBvZiB0aGUgdHJpZ2dlciBmb2xsb3dlZCBieSB0aGUgZXhwcmVzc2lvbiB2YWx1ZSB0aGF0XG4gKiB0aGVcbiAqIHRyaWdnZXIgaXMgYm91bmQgdG8gKGluIHRoZSBmb3JtIG9mIGBbXFxAdHJpZ2dlck5hbWVdPVwiZXhwcmVzc2lvblwiYC5cbiAqXG4gKiAjIyMgVXNhZ2VcbiAqXG4gKiBgdHJpZ2dlcmAgd2lsbCBjcmVhdGUgYW4gYW5pbWF0aW9uIHRyaWdnZXIgcmVmZXJlbmNlIGJhc2VkIG9uIHRoZSBwcm92aWRlZCBgbmFtZWAgdmFsdWUuIFRoZVxuICogcHJvdmlkZWQgYGFuaW1hdGlvbmAgdmFsdWUgaXMgZXhwZWN0ZWQgdG8gYmUgYW4gYXJyYXkgY29uc2lzdGluZyBvZiB7XFxAbGluayBzdGF0ZSBzdGF0ZX0gYW5kXG4gKiB7XFxAbGluayB0cmFuc2l0aW9uIHRyYW5zaXRpb259IGRlY2xhcmF0aW9ucy5cbiAqXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBcXEBDb21wb25lbnQoe1xuICogICBzZWxlY3RvcjogJ215LWNvbXBvbmVudCcsXG4gKiAgIHRlbXBsYXRlVXJsOiAnbXktY29tcG9uZW50LXRwbC5odG1sJyxcbiAqICAgYW5pbWF0aW9uczogW1xuICogICAgIHRyaWdnZXIoXCJteUFuaW1hdGlvblRyaWdnZXJcIiwgW1xuICogICAgICAgc3RhdGUoLi4uKSxcbiAqICAgICAgIHN0YXRlKC4uLiksXG4gKiAgICAgICB0cmFuc2l0aW9uKC4uLiksXG4gKiAgICAgICB0cmFuc2l0aW9uKC4uLilcbiAqICAgICBdKVxuICogICBdXG4gKiB9KVxuICogY2xhc3MgTXlDb21wb25lbnQge1xuICogICBteVN0YXR1c0V4cCA9IFwic29tZXRoaW5nXCI7XG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBUaGUgdGVtcGxhdGUgYXNzb2NpYXRlZCB3aXRoIHRoaXMgY29tcG9uZW50IHdpbGwgbWFrZSB1c2Ugb2YgdGhlIGBteUFuaW1hdGlvblRyaWdnZXJgIGFuaW1hdGlvblxuICogdHJpZ2dlciBieSBiaW5kaW5nIHRvIGFuIGVsZW1lbnQgd2l0aGluIGl0cyB0ZW1wbGF0ZSBjb2RlLlxuICpcbiAqIGBgYGh0bWxcbiAqIDwhLS0gc29tZXdoZXJlIGluc2lkZSBvZiBteS1jb21wb25lbnQtdHBsLmh0bWwgLS0+XG4gKiA8ZGl2IFtcXEBteUFuaW1hdGlvblRyaWdnZXJdPVwibXlTdGF0dXNFeHBcIj4uLi48L2Rpdj5cbiAqIGBgYFxuICpcbiAqICMjIERpc2FibGUgQW5pbWF0aW9uc1xuICogQSBzcGVjaWFsIGFuaW1hdGlvbiBjb250cm9sIGJpbmRpbmcgY2FsbGVkIGBcXEAuZGlzYWJsZWRgIGNhbiBiZSBwbGFjZWQgb24gYW4gZWxlbWVudCB3aGljaCB3aWxsXG4gKiB0aGVuIGRpc2FibGUgYW5pbWF0aW9ucyBmb3IgYW55IGlubmVyIGFuaW1hdGlvbiB0cmlnZ2VycyBzaXR1YXRlZCB3aXRoaW4gdGhlIGVsZW1lbnQgYXMgd2VsbCBhc1xuICogYW55IGFuaW1hdGlvbnMgb24gdGhlIGVsZW1lbnQgaXRzZWxmLlxuICpcbiAqIFdoZW4gdHJ1ZSwgdGhlIGBcXEAuZGlzYWJsZWRgIGJpbmRpbmcgd2lsbCBwcmV2ZW50IGFsbCBhbmltYXRpb25zIGZyb20gcmVuZGVyaW5nLiBUaGUgZXhhbXBsZVxuICogYmVsb3cgc2hvd3MgaG93IHRvIHVzZSB0aGlzIGZlYXR1cmU6XG4gKlxuICogYGBgdHNcbiAqIFxcQENvbXBvbmVudCh7XG4gKiAgIHNlbGVjdG9yOiAnbXktY29tcG9uZW50JyxcbiAqICAgdGVtcGxhdGU6IGBcbiAqICAgICA8ZGl2IFtcXEAuZGlzYWJsZWRdPVwiaXNEaXNhYmxlZFwiPlxuICogICAgICAgPGRpdiBbXFxAY2hpbGRBbmltYXRpb25dPVwiZXhwXCI+PC9kaXY+XG4gKiAgICAgPC9kaXY+XG4gKiAgIGAsXG4gKiAgIGFuaW1hdGlvbnM6IFtcbiAqICAgICB0cmlnZ2VyKFwiY2hpbGRBbmltYXRpb25cIiwgW1xuICogICAgICAgLy8gLi4uXG4gKiAgICAgXSlcbiAqICAgXVxuICogfSlcbiAqIGNsYXNzIE15Q29tcG9uZW50IHtcbiAqICAgaXNEaXNhYmxlZCA9IHRydWU7XG4gKiAgIGV4cCA9ICcuLi4nO1xuICogfVxuICogYGBgXG4gKlxuICogVGhlIGBcXEBjaGlsZEFuaW1hdGlvbmAgdHJpZ2dlciB3aWxsIG5vdCBhbmltYXRlIGJlY2F1c2UgYFxcQC5kaXNhYmxlZGAgcHJldmVudHMgaXQgZnJvbSBoYXBwZW5pbmdcbiAqICh3aGVuIHRydWUpLlxuICpcbiAqIE5vdGUgdGhhdCBgXFxALmRpc2JsZWRgIHdpbGwgb25seSBkaXNhYmxlIGFsbCBhbmltYXRpb25zICh0aGlzIG1lYW5zIGFueSBhbmltYXRpb25zIHJ1bm5pbmcgb25cbiAqIHRoZSBzYW1lIGVsZW1lbnQgd2lsbCBhbHNvIGJlIGRpc2FibGVkKS5cbiAqXG4gKiAjIyMgRGlzYWJsaW5nIEFuaW1hdGlvbnMgQXBwbGljYXRpb24td2lkZVxuICogV2hlbiBhbiBhcmVhIG9mIHRoZSB0ZW1wbGF0ZSBpcyBzZXQgdG8gaGF2ZSBhbmltYXRpb25zIGRpc2FibGVkLCAqKmFsbCoqIGlubmVyIGNvbXBvbmVudHMgd2lsbFxuICogYWxzbyBoYXZlIHRoZWlyIGFuaW1hdGlvbnMgZGlzYWJsZWQgYXMgd2VsbC4gVGhpcyBtZWFucyB0aGF0IGFsbCBhbmltYXRpb25zIGZvciBhbiBhbmd1bGFyXG4gKiBhcHBsaWNhdGlvbiBjYW4gYmUgZGlzYWJsZWQgYnkgcGxhY2luZyBhIGhvc3QgYmluZGluZyBzZXQgb24gYFxcQC5kaXNhYmxlZGAgb24gdGhlIHRvcG1vc3QgQW5ndWxhclxuICogY29tcG9uZW50LlxuICpcbiAqIGBgYHRzXG4gKiBpbXBvcnQge0NvbXBvbmVudCwgSG9zdEJpbmRpbmd9IGZyb20gJ1xcQGFuZ3VsYXIvY29yZSc7XG4gKlxuICogXFxAQ29tcG9uZW50KHtcbiAqICAgc2VsZWN0b3I6ICdhcHAtY29tcG9uZW50JyxcbiAqICAgdGVtcGxhdGVVcmw6ICdhcHAuY29tcG9uZW50Lmh0bWwnLFxuICogfSlcbiAqIGNsYXNzIEFwcENvbXBvbmVudCB7XG4gKiAgIFxcQEhvc3RCaW5kaW5nKCdcXEAuZGlzYWJsZWQnKVxuICogICBwdWJsaWMgYW5pbWF0aW9uc0Rpc2FibGVkID0gdHJ1ZTtcbiAqIH1cbiAqIGBgYFxuICpcbiAqICMjIyBXaGF0IGFib3V0IGFuaW1hdGlvbnMgdGhhdCB1cyBgcXVlcnkoKWAgYW5kIGBhbmltYXRlQ2hpbGQoKWA/XG4gKiBEZXNwaXRlIGlubmVyIGFuaW1hdGlvbnMgYmVpbmcgZGlzYWJsZWQsIGEgcGFyZW50IGFuaW1hdGlvbiBjYW4ge1xcQGxpbmsgcXVlcnkgcXVlcnl9IGZvciBpbm5lclxuICogZWxlbWVudHMgbG9jYXRlZCBpbiBkaXNhYmxlZCBhcmVhcyBvZiB0aGUgdGVtcGxhdGUgYW5kIHN0aWxsIGFuaW1hdGUgdGhlbSBhcyBpdCBzZWVzIGZpdC4gVGhpcyBpc1xuICogYWxzbyB0aGUgY2FzZSBmb3Igd2hlbiBhIHN1YiBhbmltYXRpb24gaXMgcXVlcmllZCBieSBhIHBhcmVudCBhbmQgdGhlbiBsYXRlciBhbmltYXRlZCB1c2luZyB7XFxAbGlua1xuICogYW5pbWF0ZUNoaWxkIGFuaW1hdGVDaGlsZH0uXG4gKlxuICogXFxAZXhwZXJpbWVudGFsIEFuaW1hdGlvbiBzdXBwb3J0IGlzIGV4cGVyaW1lbnRhbC5cbiAqIEBwYXJhbSB7P30gbmFtZVxuICogQHBhcmFtIHs/fSBkZWZpbml0aW9uc1xuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gdHJpZ2dlcihuYW1lLCBkZWZpbml0aW9ucykge1xuICAgIHJldHVybiB7IHR5cGU6IDcgLyogVHJpZ2dlciAqLywgbmFtZTogbmFtZSwgZGVmaW5pdGlvbnM6IGRlZmluaXRpb25zLCBvcHRpb25zOiB7fSB9O1xufVxuLyoqXG4gKiBgYW5pbWF0ZWAgaXMgYW4gYW5pbWF0aW9uLXNwZWNpZmljIGZ1bmN0aW9uIHRoYXQgaXMgZGVzaWduZWQgdG8gYmUgdXNlZCBpbnNpZGUgb2YgQW5ndWxhcidzXG4gKiBhbmltYXRpb24gRFNMIGxhbmd1YWdlLiBJZiB0aGlzIGluZm9ybWF0aW9uIGlzIG5ldywgcGxlYXNlIG5hdmlnYXRlIHRvIHRoZSB7XFxAbGlua1xuICogQ29tcG9uZW50I2FuaW1hdGlvbnMgY29tcG9uZW50IGFuaW1hdGlvbnMgbWV0YWRhdGEgcGFnZX0gdG8gZ2FpbiBhIGJldHRlciB1bmRlcnN0YW5kaW5nIG9mXG4gKiBob3cgYW5pbWF0aW9ucyBpbiBBbmd1bGFyIGFyZSB1c2VkLlxuICpcbiAqIGBhbmltYXRlYCBzcGVjaWZpZXMgYW4gYW5pbWF0aW9uIHN0ZXAgdGhhdCB3aWxsIGFwcGx5IHRoZSBwcm92aWRlZCBgc3R5bGVzYCBkYXRhIGZvciBhIGdpdmVuXG4gKiBhbW91bnQgb2YgdGltZSBiYXNlZCBvbiB0aGUgcHJvdmlkZWQgYHRpbWluZ2AgZXhwcmVzc2lvbiB2YWx1ZS4gQ2FsbHMgdG8gYGFuaW1hdGVgIGFyZSBleHBlY3RlZFxuICogdG8gYmUgdXNlZCB3aXRoaW4ge1xcQGxpbmsgc2VxdWVuY2UgYW4gYW5pbWF0aW9uIHNlcXVlbmNlfSwge1xcQGxpbmsgZ3JvdXAgZ3JvdXB9LCBvciB7XFxAbGlua1xuICogdHJhbnNpdGlvbiB0cmFuc2l0aW9ufS5cbiAqXG4gKiAjIyMgVXNhZ2VcbiAqXG4gKiBUaGUgYGFuaW1hdGVgIGZ1bmN0aW9uIGFjY2VwdHMgdHdvIGlucHV0IHBhcmFtZXRlcnM6IGB0aW1pbmdgIGFuZCBgc3R5bGVzYDpcbiAqXG4gKiAtIGB0aW1pbmdgIGlzIGEgc3RyaW5nIGJhc2VkIHZhbHVlIHRoYXQgY2FuIGJlIGEgY29tYmluYXRpb24gb2YgYSBkdXJhdGlvbiB3aXRoIG9wdGlvbmFsIGRlbGF5XG4gKiBhbmQgZWFzaW5nIHZhbHVlcy4gVGhlIGZvcm1hdCBmb3IgdGhlIGV4cHJlc3Npb24gYnJlYWtzIGRvd24gdG8gYGR1cmF0aW9uIGRlbGF5IGVhc2luZ2BcbiAqICh0aGVyZWZvcmUgYSB2YWx1ZSBzdWNoIGFzIGAxcyAxMDBtcyBlYXNlLW91dGAgd2lsbCBiZSBwYXJzZSBpdHNlbGYgaW50byBgZHVyYXRpb249MTAwMCxcbiAqIGRlbGF5PTEwMCwgZWFzaW5nPWVhc2Utb3V0YC4gSWYgYSBudW1lcmljIHZhbHVlIGlzIHByb3ZpZGVkIHRoZW4gdGhhdCB3aWxsIGJlIHVzZWQgYXMgdGhlXG4gKiBgZHVyYXRpb25gIHZhbHVlIGluIG1pbGxpc2Vjb25kIGZvcm0uXG4gKiAtIGBzdHlsZXNgIGlzIHRoZSBzdHlsZSBpbnB1dCBkYXRhIHdoaWNoIGNhbiBlaXRoZXIgYmUgYSBjYWxsIHRvIHtcXEBsaW5rIHN0eWxlIHN0eWxlfSBvciB7XFxAbGlua1xuICoga2V5ZnJhbWVzIGtleWZyYW1lc30uIElmIGxlZnQgZW1wdHkgdGhlbiB0aGUgc3R5bGVzIGZyb20gdGhlIGRlc3RpbmF0aW9uIHN0YXRlIHdpbGwgYmUgY29sbGVjdGVkXG4gKiBhbmQgdXNlZCAodGhpcyBpcyB1c2VmdWwgd2hlbiBkZXNjcmliaW5nIGFuIGFuaW1hdGlvbiBzdGVwIHRoYXQgd2lsbCBjb21wbGV0ZSBhbiBhbmltYXRpb24gYnlcbiAqIHtcXEBsaW5rIHRyYW5zaXRpb24jdGhlLWZpbmFsLWFuaW1hdGUtY2FsbCBhbmltYXRpbmcgdG8gdGhlIGZpbmFsIHN0YXRlfSkuXG4gKlxuICogYGBgdHlwZXNjcmlwdFxuICogLy8gdmFyaW91cyBmdW5jdGlvbnMgZm9yIHNwZWNpZnlpbmcgdGltaW5nIGRhdGFcbiAqIGFuaW1hdGUoNTAwLCBzdHlsZSguLi4pKVxuICogYW5pbWF0ZShcIjFzXCIsIHN0eWxlKC4uLikpXG4gKiBhbmltYXRlKFwiMTAwbXMgMC41c1wiLCBzdHlsZSguLi4pKVxuICogYW5pbWF0ZShcIjVzIGVhc2VcIiwgc3R5bGUoLi4uKSlcbiAqIGFuaW1hdGUoXCI1cyAxMG1zIGN1YmljLWJlemllciguMTcsLjY3LC44OCwuMSlcIiwgc3R5bGUoLi4uKSlcbiAqXG4gKiAvLyBlaXRoZXIgc3R5bGUoKSBvZiBrZXlmcmFtZXMoKSBjYW4gYmUgdXNlZFxuICogYW5pbWF0ZSg1MDAsIHN0eWxlKHsgYmFja2dyb3VuZDogXCJyZWRcIiB9KSlcbiAqIGFuaW1hdGUoNTAwLCBrZXlmcmFtZXMoW1xuICogICBzdHlsZSh7IGJhY2tncm91bmQ6IFwiYmx1ZVwiIH0pKSxcbiAqICAgc3R5bGUoeyBiYWNrZ3JvdW5kOiBcInJlZFwiIH0pKVxuICogXSlcbiAqIGBgYFxuICpcbiAqIHtcXEBleGFtcGxlIGNvcmUvYW5pbWF0aW9uL3RzL2RzbC9hbmltYXRpb25fZXhhbXBsZS50cyByZWdpb249J0NvbXBvbmVudCd9XG4gKlxuICogXFxAZXhwZXJpbWVudGFsIEFuaW1hdGlvbiBzdXBwb3J0IGlzIGV4cGVyaW1lbnRhbC5cbiAqIEBwYXJhbSB7P30gdGltaW5nc1xuICogQHBhcmFtIHs/PX0gc3R5bGVzXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBhbmltYXRlKHRpbWluZ3MsIHN0eWxlcykge1xuICAgIGlmIChzdHlsZXMgPT09IHZvaWQgMCkgeyBzdHlsZXMgPSBudWxsOyB9XG4gICAgcmV0dXJuIHsgdHlwZTogNCAvKiBBbmltYXRlICovLCBzdHlsZXM6IHN0eWxlcywgdGltaW5nczogdGltaW5ncyB9O1xufVxuLyoqXG4gKiBgZ3JvdXBgIGlzIGFuIGFuaW1hdGlvbi1zcGVjaWZpYyBmdW5jdGlvbiB0aGF0IGlzIGRlc2lnbmVkIHRvIGJlIHVzZWQgaW5zaWRlIG9mIEFuZ3VsYXInc1xuICogYW5pbWF0aW9uIERTTCBsYW5ndWFnZS4gSWYgdGhpcyBpbmZvcm1hdGlvbiBpcyBuZXcsIHBsZWFzZSBuYXZpZ2F0ZSB0byB0aGUge1xcQGxpbmtcbiAqIENvbXBvbmVudCNhbmltYXRpb25zIGNvbXBvbmVudCBhbmltYXRpb25zIG1ldGFkYXRhIHBhZ2V9IHRvIGdhaW4gYSBiZXR0ZXIgdW5kZXJzdGFuZGluZyBvZlxuICogaG93IGFuaW1hdGlvbnMgaW4gQW5ndWxhciBhcmUgdXNlZC5cbiAqXG4gKiBgZ3JvdXBgIHNwZWNpZmllcyBhIGxpc3Qgb2YgYW5pbWF0aW9uIHN0ZXBzIHRoYXQgYXJlIGFsbCBydW4gaW4gcGFyYWxsZWwuIEdyb3VwZWQgYW5pbWF0aW9ucyBhcmVcbiAqIHVzZWZ1bCB3aGVuIGEgc2VyaWVzIG9mIHN0eWxlcyBtdXN0IGJlIGFuaW1hdGVkL2Nsb3NlZCBvZmYgYXQgZGlmZmVyZW50IHN0YXJ0aW5nL2VuZGluZyB0aW1lcy5cbiAqXG4gKiBUaGUgYGdyb3VwYCBmdW5jdGlvbiBjYW4gZWl0aGVyIGJlIHVzZWQgd2l0aGluIGEge1xcQGxpbmsgc2VxdWVuY2Ugc2VxdWVuY2V9IG9yIGEge1xcQGxpbmsgdHJhbnNpdGlvblxuICogdHJhbnNpdGlvbn0gYW5kIGl0IHdpbGwgb25seSBjb250aW51ZSB0byB0aGUgbmV4dCBpbnN0cnVjdGlvbiBvbmNlIGFsbCBvZiB0aGUgaW5uZXIgYW5pbWF0aW9uXG4gKiBzdGVwcyBoYXZlIGNvbXBsZXRlZC5cbiAqXG4gKiAjIyMgVXNhZ2VcbiAqXG4gKiBUaGUgYHN0ZXBzYCBkYXRhIHRoYXQgaXMgcGFzc2VkIGludG8gdGhlIGBncm91cGAgYW5pbWF0aW9uIGZ1bmN0aW9uIGNhbiBlaXRoZXIgY29uc2lzdCBvZiB7XFxAbGlua1xuICogc3R5bGUgc3R5bGV9IG9yIHtcXEBsaW5rIGFuaW1hdGUgYW5pbWF0ZX0gZnVuY3Rpb24gY2FsbHMuIEVhY2ggY2FsbCB0byBgc3R5bGUoKWAgb3IgYGFuaW1hdGUoKWBcbiAqIHdpdGhpbiBhIGdyb3VwIHdpbGwgYmUgZXhlY3V0ZWQgaW5zdGFudGx5ICh1c2Uge1xcQGxpbmsga2V5ZnJhbWVzIGtleWZyYW1lc30gb3IgYSB7XFxAbGlua1xuICogYW5pbWF0ZSN1c2FnZSBhbmltYXRlKCkgd2l0aCBhIGRlbGF5IHZhbHVlfSB0byBvZmZzZXQgc3R5bGVzIHRvIGJlIGFwcGxpZWQgYXQgYSBsYXRlciB0aW1lKS5cbiAqXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBncm91cChbXG4gKiAgIGFuaW1hdGUoXCIxc1wiLCB7IGJhY2tncm91bmQ6IFwiYmxhY2tcIiB9KSlcbiAqICAgYW5pbWF0ZShcIjJzXCIsIHsgY29sb3I6IFwid2hpdGVcIiB9KSlcbiAqIF0pXG4gKiBgYGBcbiAqXG4gKiB7XFxAZXhhbXBsZSBjb3JlL2FuaW1hdGlvbi90cy9kc2wvYW5pbWF0aW9uX2V4YW1wbGUudHMgcmVnaW9uPSdDb21wb25lbnQnfVxuICpcbiAqIFxcQGV4cGVyaW1lbnRhbCBBbmltYXRpb24gc3VwcG9ydCBpcyBleHBlcmltZW50YWwuXG4gKiBAcGFyYW0gez99IHN0ZXBzXG4gKiBAcGFyYW0gez89fSBvcHRpb25zXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBncm91cChzdGVwcywgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IG51bGw7IH1cbiAgICByZXR1cm4geyB0eXBlOiAzIC8qIEdyb3VwICovLCBzdGVwczogc3RlcHMsIG9wdGlvbnM6IG9wdGlvbnMgfTtcbn1cbi8qKlxuICogYHNlcXVlbmNlYCBpcyBhbiBhbmltYXRpb24tc3BlY2lmaWMgZnVuY3Rpb24gdGhhdCBpcyBkZXNpZ25lZCB0byBiZSB1c2VkIGluc2lkZSBvZiBBbmd1bGFyJ3NcbiAqIGFuaW1hdGlvbiBEU0wgbGFuZ3VhZ2UuIElmIHRoaXMgaW5mb3JtYXRpb24gaXMgbmV3LCBwbGVhc2UgbmF2aWdhdGUgdG8gdGhlIHtcXEBsaW5rXG4gKiBDb21wb25lbnQjYW5pbWF0aW9ucyBjb21wb25lbnQgYW5pbWF0aW9ucyBtZXRhZGF0YSBwYWdlfSB0byBnYWluIGEgYmV0dGVyIHVuZGVyc3RhbmRpbmcgb2ZcbiAqIGhvdyBhbmltYXRpb25zIGluIEFuZ3VsYXIgYXJlIHVzZWQuXG4gKlxuICogYHNlcXVlbmNlYCBTcGVjaWZpZXMgYSBsaXN0IG9mIGFuaW1hdGlvbiBzdGVwcyB0aGF0IGFyZSBydW4gb25lIGJ5IG9uZS4gKGBzZXF1ZW5jZWAgaXMgdXNlZCBieVxuICogZGVmYXVsdCB3aGVuIGFuIGFycmF5IGlzIHBhc3NlZCBhcyBhbmltYXRpb24gZGF0YSBpbnRvIHtcXEBsaW5rIHRyYW5zaXRpb24gdHJhbnNpdGlvbn0uKVxuICpcbiAqIFRoZSBgc2VxdWVuY2VgIGZ1bmN0aW9uIGNhbiBlaXRoZXIgYmUgdXNlZCB3aXRoaW4gYSB7XFxAbGluayBncm91cCBncm91cH0gb3IgYSB7XFxAbGluayB0cmFuc2l0aW9uXG4gKiB0cmFuc2l0aW9ufSBhbmQgaXQgd2lsbCBvbmx5IGNvbnRpbnVlIHRvIHRoZSBuZXh0IGluc3RydWN0aW9uIG9uY2UgZWFjaCBvZiB0aGUgaW5uZXIgYW5pbWF0aW9uXG4gKiBzdGVwcyBoYXZlIGNvbXBsZXRlZC5cbiAqXG4gKiBUbyBwZXJmb3JtIGFuaW1hdGlvbiBzdHlsaW5nIGluIHBhcmFsbGVsIHdpdGggb3RoZXIgYW5pbWF0aW9uIHN0ZXBzIHRoZW4gaGF2ZSBhIGxvb2sgYXQgdGhlXG4gKiB7XFxAbGluayBncm91cCBncm91cH0gYW5pbWF0aW9uIGZ1bmN0aW9uLlxuICpcbiAqICMjIyBVc2FnZVxuICpcbiAqIFRoZSBgc3RlcHNgIGRhdGEgdGhhdCBpcyBwYXNzZWQgaW50byB0aGUgYHNlcXVlbmNlYCBhbmltYXRpb24gZnVuY3Rpb24gY2FuIGVpdGhlciBjb25zaXN0IG9mXG4gKiB7XFxAbGluayBzdHlsZSBzdHlsZX0gb3Ige1xcQGxpbmsgYW5pbWF0ZSBhbmltYXRlfSBmdW5jdGlvbiBjYWxscy4gQSBjYWxsIHRvIGBzdHlsZSgpYCB3aWxsIGFwcGx5IHRoZVxuICogcHJvdmlkZWQgc3R5bGluZyBkYXRhIGltbWVkaWF0ZWx5IHdoaWxlIGEgY2FsbCB0byBgYW5pbWF0ZSgpYCB3aWxsIGFwcGx5IGl0cyBzdHlsaW5nIGRhdGEgb3ZlciBhXG4gKiBnaXZlbiB0aW1lIGRlcGVuZGluZyBvbiBpdHMgdGltaW5nIGRhdGEuXG4gKlxuICogYGBgdHlwZXNjcmlwdFxuICogc2VxdWVuY2UoW1xuICogICBzdHlsZSh7IG9wYWNpdHk6IDAgfSkpLFxuICogICBhbmltYXRlKFwiMXNcIiwgeyBvcGFjaXR5OiAxIH0pKVxuICogXSlcbiAqIGBgYFxuICpcbiAqIHtcXEBleGFtcGxlIGNvcmUvYW5pbWF0aW9uL3RzL2RzbC9hbmltYXRpb25fZXhhbXBsZS50cyByZWdpb249J0NvbXBvbmVudCd9XG4gKlxuICogXFxAZXhwZXJpbWVudGFsIEFuaW1hdGlvbiBzdXBwb3J0IGlzIGV4cGVyaW1lbnRhbC5cbiAqIEBwYXJhbSB7P30gc3RlcHNcbiAqIEBwYXJhbSB7Pz19IG9wdGlvbnNcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIHNlcXVlbmNlKHN0ZXBzLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0gbnVsbDsgfVxuICAgIHJldHVybiB7IHR5cGU6IDIgLyogU2VxdWVuY2UgKi8sIHN0ZXBzOiBzdGVwcywgb3B0aW9uczogb3B0aW9ucyB9O1xufVxuLyoqXG4gKiBgc3R5bGVgIGlzIGFuIGFuaW1hdGlvbi1zcGVjaWZpYyBmdW5jdGlvbiB0aGF0IGlzIGRlc2lnbmVkIHRvIGJlIHVzZWQgaW5zaWRlIG9mIEFuZ3VsYXInc1xuICogYW5pbWF0aW9uIERTTCBsYW5ndWFnZS4gSWYgdGhpcyBpbmZvcm1hdGlvbiBpcyBuZXcsIHBsZWFzZSBuYXZpZ2F0ZSB0byB0aGUge1xcQGxpbmtcbiAqIENvbXBvbmVudCNhbmltYXRpb25zIGNvbXBvbmVudCBhbmltYXRpb25zIG1ldGFkYXRhIHBhZ2V9IHRvIGdhaW4gYSBiZXR0ZXIgdW5kZXJzdGFuZGluZyBvZlxuICogaG93IGFuaW1hdGlvbnMgaW4gQW5ndWxhciBhcmUgdXNlZC5cbiAqXG4gKiBgc3R5bGVgIGRlY2xhcmVzIGEga2V5L3ZhbHVlIG9iamVjdCBjb250YWluaW5nIENTUyBwcm9wZXJ0aWVzL3N0eWxlcyB0aGF0IGNhbiB0aGVuIGJlIHVzZWQgZm9yXG4gKiB7XFxAbGluayBzdGF0ZSBhbmltYXRpb24gc3RhdGVzfSwgd2l0aGluIGFuIHtcXEBsaW5rIHNlcXVlbmNlIGFuaW1hdGlvbiBzZXF1ZW5jZX0sIG9yIGFzIHN0eWxpbmcgZGF0YVxuICogZm9yIGJvdGgge1xcQGxpbmsgYW5pbWF0ZSBhbmltYXRlfSBhbmQge1xcQGxpbmsga2V5ZnJhbWVzIGtleWZyYW1lc30uXG4gKlxuICogIyMjIFVzYWdlXG4gKlxuICogYHN0eWxlYCB0YWtlcyBpbiBhIGtleS92YWx1ZSBzdHJpbmcgbWFwIGFzIGRhdGEgYW5kIGV4cGVjdHMgb25lIG9yIG1vcmUgQ1NTIHByb3BlcnR5L3ZhbHVlIHBhaXJzXG4gKiB0byBiZSBkZWZpbmVkLlxuICpcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIC8vIHN0cmluZyB2YWx1ZXMgYXJlIHVzZWQgZm9yIGNzcyBwcm9wZXJ0aWVzXG4gKiBzdHlsZSh7IGJhY2tncm91bmQ6IFwicmVkXCIsIGNvbG9yOiBcImJsdWVcIiB9KVxuICpcbiAqIC8vIG51bWVyaWNhbCAocGl4ZWwpIHZhbHVlcyBhcmUgYWxzbyBzdXBwb3J0ZWRcbiAqIHN0eWxlKHsgd2lkdGg6IDEwMCwgaGVpZ2h0OiAwIH0pXG4gKiBgYGBcbiAqXG4gKiAjIyMjIEF1dG8tc3R5bGVzICh1c2luZyBgKmApXG4gKlxuICogV2hlbiBhbiBhc3Rlcml4IChgKmApIGNoYXJhY3RlciBpcyB1c2VkIGFzIGEgdmFsdWUgdGhlbiBpdCB3aWxsIGJlIGRldGVjdGVkIGZyb20gdGhlIGVsZW1lbnRcbiAqIGJlaW5nIGFuaW1hdGVkIGFuZCBhcHBsaWVkIGFzIGFuaW1hdGlvbiBkYXRhIHdoZW4gdGhlIGFuaW1hdGlvbiBzdGFydHMuXG4gKlxuICogVGhpcyBmZWF0dXJlIHByb3ZlcyB1c2VmdWwgZm9yIGEgc3RhdGUgZGVwZW5kaW5nIG9uIGxheW91dCBhbmQvb3IgZW52aXJvbm1lbnQgZmFjdG9yczsgaW4gc3VjaFxuICogY2FzZXMgdGhlIHN0eWxlcyBhcmUgY2FsY3VsYXRlZCBqdXN0IGJlZm9yZSB0aGUgYW5pbWF0aW9uIHN0YXJ0cy5cbiAqXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiAvLyB0aGUgc3RlcHMgYmVsb3cgd2lsbCBhbmltYXRlIGZyb20gMCB0byB0aGVcbiAqIC8vIGFjdHVhbCBoZWlnaHQgb2YgdGhlIGVsZW1lbnRcbiAqIHN0eWxlKHsgaGVpZ2h0OiAwIH0pLFxuICogYW5pbWF0ZShcIjFzXCIsIHN0eWxlKHsgaGVpZ2h0OiBcIipcIiB9KSlcbiAqIGBgYFxuICpcbiAqIHtcXEBleGFtcGxlIGNvcmUvYW5pbWF0aW9uL3RzL2RzbC9hbmltYXRpb25fZXhhbXBsZS50cyByZWdpb249J0NvbXBvbmVudCd9XG4gKlxuICogXFxAZXhwZXJpbWVudGFsIEFuaW1hdGlvbiBzdXBwb3J0IGlzIGV4cGVyaW1lbnRhbC5cbiAqIEBwYXJhbSB7P30gdG9rZW5zXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBzdHlsZSh0b2tlbnMpIHtcbiAgICByZXR1cm4geyB0eXBlOiA2IC8qIFN0eWxlICovLCBzdHlsZXM6IHRva2Vucywgb2Zmc2V0OiBudWxsIH07XG59XG4vKipcbiAqIGBzdGF0ZWAgaXMgYW4gYW5pbWF0aW9uLXNwZWNpZmljIGZ1bmN0aW9uIHRoYXQgaXMgZGVzaWduZWQgdG8gYmUgdXNlZCBpbnNpZGUgb2YgQW5ndWxhcidzXG4gKiBhbmltYXRpb24gRFNMIGxhbmd1YWdlLiBJZiB0aGlzIGluZm9ybWF0aW9uIGlzIG5ldywgcGxlYXNlIG5hdmlnYXRlIHRvIHRoZSB7XFxAbGlua1xuICogQ29tcG9uZW50I2FuaW1hdGlvbnMgY29tcG9uZW50IGFuaW1hdGlvbnMgbWV0YWRhdGEgcGFnZX0gdG8gZ2FpbiBhIGJldHRlciB1bmRlcnN0YW5kaW5nIG9mXG4gKiBob3cgYW5pbWF0aW9ucyBpbiBBbmd1bGFyIGFyZSB1c2VkLlxuICpcbiAqIGBzdGF0ZWAgZGVjbGFyZXMgYW4gYW5pbWF0aW9uIHN0YXRlIHdpdGhpbiB0aGUgZ2l2ZW4gdHJpZ2dlci4gV2hlbiBhIHN0YXRlIGlzIGFjdGl2ZSB3aXRoaW4gYVxuICogY29tcG9uZW50IHRoZW4gaXRzIGFzc29jaWF0ZWQgc3R5bGVzIHdpbGwgcGVyc2lzdCBvbiB0aGUgZWxlbWVudCB0aGF0IHRoZSB0cmlnZ2VyIGlzIGF0dGFjaGVkIHRvXG4gKiAoZXZlbiB3aGVuIHRoZSBhbmltYXRpb24gZW5kcykuXG4gKlxuICogVG8gYW5pbWF0ZSBiZXR3ZWVuIHN0YXRlcywgaGF2ZSBhIGxvb2sgYXQgdGhlIGFuaW1hdGlvbiB7XFxAbGluayB0cmFuc2l0aW9uIHRyYW5zaXRpb259IERTTFxuICogZnVuY3Rpb24uIFRvIHJlZ2lzdGVyIHN0YXRlcyB0byBhbiBhbmltYXRpb24gdHJpZ2dlciBwbGVhc2UgaGF2ZSBhIGxvb2sgYXQgdGhlIHtcXEBsaW5rIHRyaWdnZXJcbiAqIHRyaWdnZXJ9IGZ1bmN0aW9uLlxuICpcbiAqICMjIyMgVGhlIGB2b2lkYCBzdGF0ZVxuICpcbiAqIFRoZSBgdm9pZGAgc3RhdGUgdmFsdWUgaXMgYSByZXNlcnZlZCB3b3JkIHRoYXQgYW5ndWxhciB1c2VzIHRvIGRldGVybWluZSB3aGVuIHRoZSBlbGVtZW50IGlzIG5vdFxuICogYXBhcnQgb2YgdGhlIGFwcGxpY2F0aW9uIGFueW1vcmUgKGUuZy4gd2hlbiBhbiBgbmdJZmAgZXZhbHVhdGVzIHRvIGZhbHNlIHRoZW4gdGhlIHN0YXRlIG9mIHRoZVxuICogYXNzb2NpYXRlZCBlbGVtZW50IGlzIHZvaWQpLlxuICpcbiAqICMjIyMgVGhlIGAqYCAoZGVmYXVsdCkgc3RhdGVcbiAqXG4gKiBUaGUgYCpgIHN0YXRlICh3aGVuIHN0eWxlZCkgaXMgYSBmYWxsYmFjayBzdGF0ZSB0aGF0IHdpbGwgYmUgdXNlZCBpZiB0aGUgc3RhdGUgdGhhdCBpcyBiZWluZ1xuICogYW5pbWF0ZWQgaXMgbm90IGRlY2xhcmVkIHdpdGhpbiB0aGUgdHJpZ2dlci5cbiAqXG4gKiAjIyMgVXNhZ2VcbiAqXG4gKiBgc3RhdGVgIHdpbGwgZGVjbGFyZSBhbiBhbmltYXRpb24gc3RhdGUgd2l0aCBpdHMgYXNzb2NpYXRlZCBzdHlsZXNcbiAqIHdpdGhpbiB0aGUgZ2l2ZW4gdHJpZ2dlci5cbiAqXG4gKiAtIGBzdGF0ZU5hbWVFeHByYCBjYW4gYmUgb25lIG9yIG1vcmUgc3RhdGUgbmFtZXMgc2VwYXJhdGVkIGJ5IGNvbW1hcy5cbiAqIC0gYHN0eWxlc2AgcmVmZXJzIHRvIHRoZSB7XFxAbGluayBzdHlsZSBzdHlsaW5nIGRhdGF9IHRoYXQgd2lsbCBiZSBwZXJzaXN0ZWQgb24gdGhlIGVsZW1lbnQgb25jZVxuICogdGhlIHN0YXRlIGhhcyBiZWVuIHJlYWNoZWQuXG4gKlxuICogYGBgdHlwZXNjcmlwdFxuICogLy8gXCJ2b2lkXCIgaXMgYSByZXNlcnZlZCBuYW1lIGZvciBhIHN0YXRlIGFuZCBpcyB1c2VkIHRvIHJlcHJlc2VudFxuICogLy8gdGhlIHN0YXRlIGluIHdoaWNoIGFuIGVsZW1lbnQgaXMgZGV0YWNoZWQgZnJvbSBmcm9tIHRoZSBhcHBsaWNhdGlvbi5cbiAqIHN0YXRlKFwidm9pZFwiLCBzdHlsZSh7IGhlaWdodDogMCB9KSlcbiAqXG4gKiAvLyB1c2VyLWRlZmluZWQgc3RhdGVzXG4gKiBzdGF0ZShcImNsb3NlZFwiLCBzdHlsZSh7IGhlaWdodDogMCB9KSlcbiAqIHN0YXRlKFwib3BlbiwgdmlzaWJsZVwiLCBzdHlsZSh7IGhlaWdodDogXCIqXCIgfSkpXG4gKiBgYGBcbiAqXG4gKiB7XFxAZXhhbXBsZSBjb3JlL2FuaW1hdGlvbi90cy9kc2wvYW5pbWF0aW9uX2V4YW1wbGUudHMgcmVnaW9uPSdDb21wb25lbnQnfVxuICpcbiAqIFxcQGV4cGVyaW1lbnRhbCBBbmltYXRpb24gc3VwcG9ydCBpcyBleHBlcmltZW50YWwuXG4gKiBAcGFyYW0gez99IG5hbWVcbiAqIEBwYXJhbSB7P30gc3R5bGVzXG4gKiBAcGFyYW0gez89fSBvcHRpb25zXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBzdGF0ZShuYW1lLCBzdHlsZXMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4geyB0eXBlOiAwIC8qIFN0YXRlICovLCBuYW1lOiBuYW1lLCBzdHlsZXM6IHN0eWxlcywgb3B0aW9uczogb3B0aW9ucyB9O1xufVxuLyoqXG4gKiBga2V5ZnJhbWVzYCBpcyBhbiBhbmltYXRpb24tc3BlY2lmaWMgZnVuY3Rpb24gdGhhdCBpcyBkZXNpZ25lZCB0byBiZSB1c2VkIGluc2lkZSBvZiBBbmd1bGFyJ3NcbiAqIGFuaW1hdGlvbiBEU0wgbGFuZ3VhZ2UuIElmIHRoaXMgaW5mb3JtYXRpb24gaXMgbmV3LCBwbGVhc2UgbmF2aWdhdGUgdG8gdGhlIHtcXEBsaW5rXG4gKiBDb21wb25lbnQjYW5pbWF0aW9ucyBjb21wb25lbnQgYW5pbWF0aW9ucyBtZXRhZGF0YSBwYWdlfSB0byBnYWluIGEgYmV0dGVyIHVuZGVyc3RhbmRpbmcgb2ZcbiAqIGhvdyBhbmltYXRpb25zIGluIEFuZ3VsYXIgYXJlIHVzZWQuXG4gKlxuICogYGtleWZyYW1lc2Agc3BlY2lmaWVzIGEgY29sbGVjdGlvbiBvZiB7XFxAbGluayBzdHlsZSBzdHlsZX0gZW50cmllcyBlYWNoIG9wdGlvbmFsbHkgY2hhcmFjdGVyaXplZFxuICogYnkgYW4gYG9mZnNldGAgdmFsdWUuXG4gKlxuICogIyMjIFVzYWdlXG4gKlxuICogVGhlIGBrZXlmcmFtZXNgIGFuaW1hdGlvbiBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBiZSB1c2VkIGFsb25nc2lkZSB0aGUge1xcQGxpbmsgYW5pbWF0ZSBhbmltYXRlfVxuICogYW5pbWF0aW9uIGZ1bmN0aW9uLiBJbnN0ZWFkIG9mIGFwcGx5aW5nIGFuaW1hdGlvbnMgZnJvbSB3aGVyZSB0aGV5IGFyZSBjdXJyZW50bHkgdG8gdGhlaXJcbiAqIGRlc3RpbmF0aW9uLCBrZXlmcmFtZXMgY2FuIGRlc2NyaWJlIGhvdyBlYWNoIHN0eWxlIGVudHJ5IGlzIGFwcGxpZWQgYW5kIGF0IHdoYXQgcG9pbnQgd2l0aGluIHRoZVxuICogYW5pbWF0aW9uIGFyYyAobXVjaCBsaWtlIENTUyBLZXlmcmFtZSBBbmltYXRpb25zIGRvKS5cbiAqXG4gKiBGb3IgZWFjaCBgc3R5bGUoKWAgZW50cnkgYW4gYG9mZnNldGAgdmFsdWUgY2FuIGJlIHNldC4gRG9pbmcgc28gYWxsb3dzIHRvIHNwZWNpZml5IGF0IHdoYXRcbiAqIHBlcmNlbnRhZ2Ugb2YgdGhlIGFuaW1hdGUgdGltZSB0aGUgc3R5bGVzIHdpbGwgYmUgYXBwbGllZC5cbiAqXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiAvLyB0aGUgcHJvdmlkZWQgb2Zmc2V0IHZhbHVlcyBkZXNjcmliZSB3aGVuIGVhY2ggYmFja2dyb3VuZENvbG9yIHZhbHVlIGlzIGFwcGxpZWQuXG4gKiBhbmltYXRlKFwiNXNcIiwga2V5ZnJhbWVzKFtcbiAqICAgc3R5bGUoeyBiYWNrZ3JvdW5kQ29sb3I6IFwicmVkXCIsIG9mZnNldDogMCB9KSxcbiAqICAgc3R5bGUoeyBiYWNrZ3JvdW5kQ29sb3I6IFwiYmx1ZVwiLCBvZmZzZXQ6IDAuMiB9KSxcbiAqICAgc3R5bGUoeyBiYWNrZ3JvdW5kQ29sb3I6IFwib3JhbmdlXCIsIG9mZnNldDogMC4zIH0pLFxuICogICBzdHlsZSh7IGJhY2tncm91bmRDb2xvcjogXCJibGFja1wiLCBvZmZzZXQ6IDEgfSlcbiAqIF0pKVxuICogYGBgXG4gKlxuICogQWx0ZXJuYXRpdmVseSwgaWYgdGhlcmUgYXJlIG5vIGBvZmZzZXRgIHZhbHVlcyB1c2VkIHdpdGhpbiB0aGUgc3R5bGUgZW50cmllcyB0aGVuIHRoZSBvZmZzZXRzXG4gKiB3aWxsIGJlIGNhbGN1bGF0ZWQgYXV0b21hdGljYWxseS5cbiAqXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBhbmltYXRlKFwiNXNcIiwga2V5ZnJhbWVzKFtcbiAqICAgc3R5bGUoeyBiYWNrZ3JvdW5kQ29sb3I6IFwicmVkXCIgfSkgLy8gb2Zmc2V0ID0gMFxuICogICBzdHlsZSh7IGJhY2tncm91bmRDb2xvcjogXCJibHVlXCIgfSkgLy8gb2Zmc2V0ID0gMC4zM1xuICogICBzdHlsZSh7IGJhY2tncm91bmRDb2xvcjogXCJvcmFuZ2VcIiB9KSAvLyBvZmZzZXQgPSAwLjY2XG4gKiAgIHN0eWxlKHsgYmFja2dyb3VuZENvbG9yOiBcImJsYWNrXCIgfSkgLy8gb2Zmc2V0ID0gMVxuICogXSkpXG4gKiBgYGBcbiAqXG4gKiB7XFxAZXhhbXBsZSBjb3JlL2FuaW1hdGlvbi90cy9kc2wvYW5pbWF0aW9uX2V4YW1wbGUudHMgcmVnaW9uPSdDb21wb25lbnQnfVxuICpcbiAqIFxcQGV4cGVyaW1lbnRhbCBBbmltYXRpb24gc3VwcG9ydCBpcyBleHBlcmltZW50YWwuXG4gKiBAcGFyYW0gez99IHN0ZXBzXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBrZXlmcmFtZXMoc3RlcHMpIHtcbiAgICByZXR1cm4geyB0eXBlOiA1IC8qIEtleWZyYW1lcyAqLywgc3RlcHM6IHN0ZXBzIH07XG59XG4vKipcbiAqIGB0cmFuc2l0aW9uYCBpcyBhbiBhbmltYXRpb24tc3BlY2lmaWMgZnVuY3Rpb24gdGhhdCBpcyBkZXNpZ25lZCB0byBiZSB1c2VkIGluc2lkZSBvZiBBbmd1bGFyJ3NcbiAqIGFuaW1hdGlvbiBEU0wgbGFuZ3VhZ2UuIElmIHRoaXMgaW5mb3JtYXRpb24gaXMgbmV3LCBwbGVhc2UgbmF2aWdhdGUgdG8gdGhlIHtcXEBsaW5rXG4gKiBDb21wb25lbnQjYW5pbWF0aW9ucyBjb21wb25lbnQgYW5pbWF0aW9ucyBtZXRhZGF0YSBwYWdlfSB0byBnYWluIGEgYmV0dGVyIHVuZGVyc3RhbmRpbmcgb2ZcbiAqIGhvdyBhbmltYXRpb25zIGluIEFuZ3VsYXIgYXJlIHVzZWQuXG4gKlxuICogYHRyYW5zaXRpb25gIGRlY2xhcmVzIHRoZSB7XFxAbGluayBzZXF1ZW5jZSBzZXF1ZW5jZSBvZiBhbmltYXRpb24gc3RlcHN9IHRoYXQgd2lsbCBiZSBydW4gd2hlbiB0aGVcbiAqIHByb3ZpZGVkIGBzdGF0ZUNoYW5nZUV4cHJgIHZhbHVlIGlzIHNhdGlzZmllZC4gVGhlIGBzdGF0ZUNoYW5nZUV4cHJgIGNvbnNpc3RzIG9mIGEgYHN0YXRlMSA9PlxuICogc3RhdGUyYCB3aGljaCBjb25zaXN0cyBvZiB0d28ga25vd24gc3RhdGVzICh1c2UgYW4gYXN0ZXJpeCAoYCpgKSB0byByZWZlciB0byBhIGR5bmFtaWMgc3RhcnRpbmdcbiAqIGFuZC9vciBlbmRpbmcgc3RhdGUpLlxuICpcbiAqIEEgZnVuY3Rpb24gY2FuIGFsc28gYmUgcHJvdmlkZWQgYXMgdGhlIGBzdGF0ZUNoYW5nZUV4cHJgIGFyZ3VtZW50IGZvciBhIHRyYW5zaXRpb24gYW5kIHRoaXNcbiAqIGZ1bmN0aW9uIHdpbGwgYmUgZXhlY3V0ZWQgZWFjaCB0aW1lIGEgc3RhdGUgY2hhbmdlIG9jY3Vycy4gSWYgdGhlIHZhbHVlIHJldHVybmVkIHdpdGhpbiB0aGVcbiAqIGZ1bmN0aW9uIGlzIHRydWUgdGhlbiB0aGUgYXNzb2NpYXRlZCBhbmltYXRpb24gd2lsbCBiZSBydW4uXG4gKlxuICogQW5pbWF0aW9uIHRyYW5zaXRpb25zIGFyZSBwbGFjZWQgd2l0aGluIGFuIHtcXEBsaW5rIHRyaWdnZXIgYW5pbWF0aW9uIHRyaWdnZXJ9LiBGb3IgYW4gdHJhbnNpdGlvblxuICogdG8gYW5pbWF0ZSB0byBhIHN0YXRlIHZhbHVlIGFuZCBwZXJzaXN0IGl0cyBzdHlsZXMgdGhlbiBvbmUgb3IgbW9yZSB7XFxAbGluayBzdGF0ZSBhbmltYXRpb25cbiAqIHN0YXRlc30gaXMgZXhwZWN0ZWQgdG8gYmUgZGVmaW5lZC5cbiAqXG4gKiAjIyMgVXNhZ2VcbiAqXG4gKiBBbiBhbmltYXRpb24gdHJhbnNpdGlvbiBpcyBraWNrZWQgb2ZmIHRoZSBgc3RhdGVDaGFuZ2VFeHByYCBwcmVkaWNhdGUgZXZhbHVhdGVzIHRvIHRydWUgYmFzZWQgb25cbiAqIHdoYXQgdGhlIHByZXZpb3VzIHN0YXRlIGlzIGFuZCB3aGF0IHRoZSBjdXJyZW50IHN0YXRlIGhhcyBiZWNvbWUuIEluIG90aGVyIHdvcmRzLCBpZiBhIHRyYW5zaXRpb25cbiAqIGlzIGRlZmluZWQgdGhhdCBtYXRjaGVzIHRoZSBvbGQvY3VycmVudCBzdGF0ZSBjcml0ZXJpYSB0aGVuIHRoZSBhc3NvY2lhdGVkIGFuaW1hdGlvbiB3aWxsIGJlXG4gKiB0cmlnZ2VyZWQuXG4gKlxuICogYGBgdHlwZXNjcmlwdFxuICogLy8gYWxsIHRyYW5zaXRpb24vc3RhdGUgY2hhbmdlcyBhcmUgZGVmaW5lZCB3aXRoaW4gYW4gYW5pbWF0aW9uIHRyaWdnZXJcbiAqIHRyaWdnZXIoXCJteUFuaW1hdGlvblRyaWdnZXJcIiwgW1xuICogICAvLyBpZiBhIHN0YXRlIGlzIGRlZmluZWQgdGhlbiBpdHMgc3R5bGVzIHdpbGwgYmUgcGVyc2lzdGVkIHdoZW4gdGhlXG4gKiAgIC8vIGFuaW1hdGlvbiBoYXMgZnVsbHkgY29tcGxldGVkIGl0c2VsZlxuICogICBzdGF0ZShcIm9uXCIsIHN0eWxlKHsgYmFja2dyb3VuZDogXCJncmVlblwiIH0pKSxcbiAqICAgc3RhdGUoXCJvZmZcIiwgc3R5bGUoeyBiYWNrZ3JvdW5kOiBcImdyZXlcIiB9KSksXG4gKlxuICogICAvLyBhIHRyYW5zaXRpb24gYW5pbWF0aW9uIHRoYXQgd2lsbCBiZSBraWNrZWQgb2ZmIHdoZW4gdGhlIHN0YXRlIHZhbHVlXG4gKiAgIC8vIGJvdW5kIHRvIFwibXlBbmltYXRpb25UcmlnZ2VyXCIgY2hhbmdlcyBmcm9tIFwib25cIiB0byBcIm9mZlwiXG4gKiAgIHRyYW5zaXRpb24oXCJvbiA9PiBvZmZcIiwgYW5pbWF0ZSg1MDApKSxcbiAqXG4gKiAgIC8vIGl0IGlzIGFsc28gcG9zc2libGUgdG8gZG8gcnVuIHRoZSBzYW1lIGFuaW1hdGlvbiBmb3IgYm90aCBkaXJlY3Rpb25zXG4gKiAgIHRyYW5zaXRpb24oXCJvbiA8PT4gb2ZmXCIsIGFuaW1hdGUoNTAwKSksXG4gKlxuICogICAvLyBvciB0byBkZWZpbmUgbXVsdGlwbGUgc3RhdGVzIHBhaXJzIHNlcGFyYXRlZCBieSBjb21tYXNcbiAqICAgdHJhbnNpdGlvbihcIm9uID0+IG9mZiwgb2ZmID0+IHZvaWRcIiwgYW5pbWF0ZSg1MDApKSxcbiAqXG4gKiAgIC8vIHRoaXMgaXMgYSBjYXRjaC1hbGwgc3RhdGUgY2hhbmdlIGZvciB3aGVuIGFuIGVsZW1lbnQgaXMgaW5zZXJ0ZWQgaW50b1xuICogICAvLyB0aGUgcGFnZSBhbmQgdGhlIGRlc3RpbmF0aW9uIHN0YXRlIGlzIHVua25vd25cbiAqICAgdHJhbnNpdGlvbihcInZvaWQgPT4gKlwiLCBbXG4gKiAgICAgc3R5bGUoeyBvcGFjaXR5OiAwIH0pLFxuICogICAgIGFuaW1hdGUoNTAwKVxuICogICBdKSxcbiAqXG4gKiAgIC8vIHRoaXMgd2lsbCBjYXB0dXJlIGEgc3RhdGUgY2hhbmdlIGJldHdlZW4gYW55IHN0YXRlc1xuICogICB0cmFuc2l0aW9uKFwiKiA9PiAqXCIsIGFuaW1hdGUoXCIxcyAwc1wiKSksXG4gKlxuICogICAvLyB5b3UgY2FuIGFsc28gZ28gZnVsbCBvdXQgYW5kIGluY2x1ZGUgYSBmdW5jdGlvblxuICogICB0cmFuc2l0aW9uKChmcm9tU3RhdGUsIHRvU3RhdGUpID0+IHtcbiAqICAgICAvLyB3aGVuIGB0cnVlYCB0aGVuIGl0IHdpbGwgYWxsb3cgdGhlIGFuaW1hdGlvbiBiZWxvdyB0byBiZSBpbnZva2VkXG4gKiAgICAgcmV0dXJuIGZyb21TdGF0ZSA9PSBcIm9mZlwiICYmIHRvU3RhdGUgPT0gXCJvblwiO1xuICogICB9LCBhbmltYXRlKFwiMXMgMHNcIikpXG4gKiBdKVxuICogYGBgXG4gKlxuICogVGhlIHRlbXBsYXRlIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGNvbXBvbmVudCB3aWxsIG1ha2UgdXNlIG9mIHRoZSBgbXlBbmltYXRpb25UcmlnZ2VyYCBhbmltYXRpb25cbiAqIHRyaWdnZXIgYnkgYmluZGluZyB0byBhbiBlbGVtZW50IHdpdGhpbiBpdHMgdGVtcGxhdGUgY29kZS5cbiAqXG4gKiBgYGBodG1sXG4gKiA8IS0tIHNvbWV3aGVyZSBpbnNpZGUgb2YgbXktY29tcG9uZW50LXRwbC5odG1sIC0tPlxuICogPGRpdiBbXFxAbXlBbmltYXRpb25UcmlnZ2VyXT1cIm15U3RhdHVzRXhwXCI+Li4uPC9kaXY+XG4gKiBgYGBcbiAqXG4gKiAjIyMjIFRoZSBmaW5hbCBgYW5pbWF0ZWAgY2FsbFxuICpcbiAqIElmIHRoZSBmaW5hbCBzdGVwIHdpdGhpbiB0aGUgdHJhbnNpdGlvbiBzdGVwcyBpcyBhIGNhbGwgdG8gYGFuaW1hdGUoKWAgdGhhdCAqKm9ubHkqKiB1c2VzIGFcbiAqIHRpbWluZyB2YWx1ZSB3aXRoICoqbm8gc3R5bGUgZGF0YSoqIHRoZW4gaXQgd2lsbCBiZSBhdXRvbWF0aWNhbGx5IHVzZWQgYXMgdGhlIGZpbmFsIGFuaW1hdGlvbiBhcmNcbiAqIGZvciB0aGUgZWxlbWVudCB0byBhbmltYXRlIGl0c2VsZiB0byB0aGUgZmluYWwgc3RhdGUuIFRoaXMgaW52b2x2ZXMgYW4gYXV0b21hdGljIG1peCBvZlxuICogYWRkaW5nL3JlbW92aW5nIENTUyBzdHlsZXMgc28gdGhhdCB0aGUgZWxlbWVudCB3aWxsIGJlIGluIHRoZSBleGFjdCBzdGF0ZSBpdCBzaG91bGQgYmUgZm9yIHRoZVxuICogYXBwbGllZCBzdGF0ZSB0byBiZSBwcmVzZW50ZWQgY29ycmVjdGx5LlxuICpcbiAqIGBgYFxuICogLy8gc3RhcnQgb2ZmIGJ5IGhpZGluZyB0aGUgZWxlbWVudCwgYnV0IG1ha2Ugc3VyZSB0aGF0IGl0IGFuaW1hdGVzIHByb3Blcmx5IHRvIHdoYXRldmVyIHN0YXRlXG4gKiAvLyBpcyBjdXJyZW50bHkgYWN0aXZlIGZvciBcIm15QW5pbWF0aW9uVHJpZ2dlclwiXG4gKiB0cmFuc2l0aW9uKFwidm9pZCA9PiAqXCIsIFtcbiAqICAgc3R5bGUoeyBvcGFjaXR5OiAwIH0pLFxuICogICBhbmltYXRlKDUwMClcbiAqIF0pXG4gKiBgYGBcbiAqXG4gKiAjIyMgVXNpbmcgOmVudGVyIGFuZCA6bGVhdmVcbiAqXG4gKiBHaXZlbiB0aGF0IGVudGVyIChpbnNlcnRpb24pIGFuZCBsZWF2ZSAocmVtb3ZhbCkgYW5pbWF0aW9ucyBhcmUgc28gY29tbW9uLCB0aGUgYHRyYW5zaXRpb25gXG4gKiBmdW5jdGlvbiBhY2NlcHRzIGJvdGggYDplbnRlcmAgYW5kIGA6bGVhdmVgIHZhbHVlcyB3aGljaCBhcmUgYWxpYXNlcyBmb3IgdGhlIGB2b2lkID0+ICpgIGFuZCBgKlxuICogPT4gdm9pZGAgc3RhdGUgY2hhbmdlcy5cbiAqXG4gKiBgYGBcbiAqIHRyYW5zaXRpb24oXCI6ZW50ZXJcIiwgW1xuICogICBzdHlsZSh7IG9wYWNpdHk6IDAgfSksXG4gKiAgIGFuaW1hdGUoNTAwLCBzdHlsZSh7IG9wYWNpdHk6IDEgfSkpXG4gKiBdKSxcbiAqIHRyYW5zaXRpb24oXCI6bGVhdmVcIiwgW1xuICogICBhbmltYXRlKDUwMCwgc3R5bGUoeyBvcGFjaXR5OiAwIH0pKVxuICogXSlcbiAqIGBgYFxuICpcbiAqICMjIyBVc2luZyA6aW5jcmVtZW50IGFuZCA6ZGVjcmVtZW50XG4gKiBJbiBhZGRpdGlvbiB0byB0aGUgOmVudGVyIGFuZCA6bGVhdmUgdHJhbnNpdGlvbiBhbGlhc2VzLCB0aGUgOmluY3JlbWVudCBhbmQgOmRlY3JlbWVudCBhbGlhc2VzXG4gKiBjYW4gYmUgdXNlZCB0byBraWNrIG9mZiBhIHRyYW5zaXRpb24gd2hlbiBhIG51bWVyaWMgdmFsdWUgaGFzIGluY3JlYXNlZCBvciBkZWNyZWFzZWQgaW4gdmFsdWUuXG4gKlxuICogYGBgXG4gKiBpbXBvcnQge2dyb3VwLCBhbmltYXRlLCBxdWVyeSwgdHJhbnNpdGlvbiwgc3R5bGUsIHRyaWdnZXJ9IGZyb20gJ1xcQGFuZ3VsYXIvYW5pbWF0aW9ucyc7XG4gKiBpbXBvcnQge0NvbXBvbmVudH0gZnJvbSAnXFxAYW5ndWxhci9jb3JlJztcbiAqXG4gKiBcXEBDb21wb25lbnQoe1xuICogICBzZWxlY3RvcjogJ2Jhbm5lci1jYXJvdXNlbC1jb21wb25lbnQnLFxuICogICBzdHlsZXM6IFtgXG4gKiAgICAgLmJhbm5lci1jb250YWluZXIge1xuICogICAgICAgIHBvc2l0aW9uOnJlbGF0aXZlO1xuICogICAgICAgIGhlaWdodDo1MDBweDtcbiAqICAgICAgICBvdmVyZmxvdzpoaWRkZW47XG4gKiAgICAgIH1cbiAqICAgICAuYmFubmVyLWNvbnRhaW5lciA+IC5iYW5uZXIge1xuICogICAgICAgIHBvc2l0aW9uOmFic29sdXRlO1xuICogICAgICAgIGxlZnQ6MDtcbiAqICAgICAgICB0b3A6MDtcbiAqICAgICAgICBmb250LXNpemU6MjAwcHg7XG4gKiAgICAgICAgbGluZS1oZWlnaHQ6NTAwcHg7XG4gKiAgICAgICAgZm9udC13ZWlnaHQ6Ym9sZDtcbiAqICAgICAgICB0ZXh0LWFsaWduOmNlbnRlcjtcbiAqICAgICAgICB3aWR0aDoxMDAlO1xuICogICAgICB9XG4gKiAgIGBdLFxuICogICB0ZW1wbGF0ZTogYFxuICogICAgIDxidXR0b24gKGNsaWNrKT1cInByZXZpb3VzKClcIj5QcmV2aW91czwvYnV0dG9uPlxuICogICAgIDxidXR0b24gKGNsaWNrKT1cIm5leHQoKVwiPk5leHQ8L2J1dHRvbj5cbiAqICAgICA8aHI+XG4gKiAgICAgPGRpdiBbXFxAYmFubmVyQW5pbWF0aW9uXT1cInNlbGVjdGVkSW5kZXhcIiBjbGFzcz1cImJhbm5lci1jb250YWluZXJcIj5cbiAqICAgICAgIDxkaXYgY2xhc3M9XCJiYW5uZXJcIj4ge3sgYmFubmVyIH19IDwvZGl2PlxuICogICAgIDwvZGl2PlxuICogICBgXG4gKiAgIGFuaW1hdGlvbnM6IFtcbiAqICAgICB0cmlnZ2VyKCdiYW5uZXJBbmltYXRpb24nLCBbXG4gKiAgICAgICB0cmFuc2l0aW9uKFwiOmluY3JlbWVudFwiLCBncm91cChbXG4gKiAgICAgICAgIHF1ZXJ5KCc6ZW50ZXInLCBbXG4gKiAgICAgICAgICAgc3R5bGUoeyBsZWZ0OiAnMTAwJScgfSksXG4gKiAgICAgICAgICAgYW5pbWF0ZSgnMC41cyBlYXNlLW91dCcsIHN0eWxlKCcqJykpXG4gKiAgICAgICAgIF0pLFxuICogICAgICAgICBxdWVyeSgnOmxlYXZlJywgW1xuICogICAgICAgICAgIGFuaW1hdGUoJzAuNXMgZWFzZS1vdXQnLCBzdHlsZSh7IGxlZnQ6ICctMTAwJScgfSkpXG4gKiAgICAgICAgIF0pXG4gKiAgICAgICBdKSksXG4gKiAgICAgICB0cmFuc2l0aW9uKFwiOmRlY3JlbWVudFwiLCBncm91cChbXG4gKiAgICAgICAgIHF1ZXJ5KCc6ZW50ZXInLCBbXG4gKiAgICAgICAgICAgc3R5bGUoeyBsZWZ0OiAnLTEwMCUnIH0pLFxuICogICAgICAgICAgIGFuaW1hdGUoJzAuNXMgZWFzZS1vdXQnLCBzdHlsZSgnKicpKVxuICogICAgICAgICBdKSxcbiAqICAgICAgICAgcXVlcnkoJzpsZWF2ZScsIFtcbiAqICAgICAgICAgICBhbmltYXRlKCcwLjVzIGVhc2Utb3V0Jywgc3R5bGUoeyBsZWZ0OiAnMTAwJScgfSkpXG4gKiAgICAgICAgIF0pXG4gKiAgICAgICBdKSksXG4gKiAgICAgXSlcbiAqICAgXVxuICogfSlcbiAqIGNsYXNzIEJhbm5lckNhcm91c2VsQ29tcG9uZW50IHtcbiAqICAgYWxsQmFubmVyczogc3RyaW5nW10gPSBbJzEnLCAnMicsICczJywgJzQnXTtcbiAqICAgc2VsZWN0ZWRJbmRleDogbnVtYmVyID0gMDtcbiAqXG4gKiAgIGdldCBiYW5uZXJzKCkge1xuICogICAgICByZXR1cm4gW3RoaXMuYWxsQmFubmVyc1t0aGlzLnNlbGVjdGVkSW5kZXhdXTtcbiAqICAgfVxuICpcbiAqICAgcHJldmlvdXMoKSB7XG4gKiAgICAgdGhpcy5zZWxlY3RlZEluZGV4ID0gTWF0aC5tYXgodGhpcy5zZWxlY3RlZEluZGV4IC0gMSwgMCk7XG4gKiAgIH1cbiAqXG4gKiAgIG5leHQoKSB7XG4gKiAgICAgdGhpcy5zZWxlY3RlZEluZGV4ID0gTWF0aC5taW4odGhpcy5zZWxlY3RlZEluZGV4ICsgMSwgdGhpcy5hbGxCYW5uZXJzLmxlbmd0aCAtIDEpO1xuICogICB9XG4gKiB9XG4gKiBgYGBcbiAqXG4gKiB7XFxAZXhhbXBsZSBjb3JlL2FuaW1hdGlvbi90cy9kc2wvYW5pbWF0aW9uX2V4YW1wbGUudHMgcmVnaW9uPSdDb21wb25lbnQnfVxuICpcbiAqIFxcQGV4cGVyaW1lbnRhbCBBbmltYXRpb24gc3VwcG9ydCBpcyBleHBlcmltZW50YWwuXG4gKiBAcGFyYW0gez99IHN0YXRlQ2hhbmdlRXhwclxuICogQHBhcmFtIHs/fSBzdGVwc1xuICogQHBhcmFtIHs/PX0gb3B0aW9uc1xuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gdHJhbnNpdGlvbihzdGF0ZUNoYW5nZUV4cHIsIHN0ZXBzLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0gbnVsbDsgfVxuICAgIHJldHVybiB7IHR5cGU6IDEgLyogVHJhbnNpdGlvbiAqLywgZXhwcjogc3RhdGVDaGFuZ2VFeHByLCBhbmltYXRpb246IHN0ZXBzLCBvcHRpb25zOiBvcHRpb25zIH07XG59XG4vKipcbiAqIGBhbmltYXRpb25gIGlzIGFuIGFuaW1hdGlvbi1zcGVjaWZpYyBmdW5jdGlvbiB0aGF0IGlzIGRlc2lnbmVkIHRvIGJlIHVzZWQgaW5zaWRlIG9mIEFuZ3VsYXInc1xuICogYW5pbWF0aW9uIERTTCBsYW5ndWFnZS5cbiAqXG4gKiBgdmFyIG15QW5pbWF0aW9uID0gYW5pbWF0aW9uKC4uLilgIGlzIGRlc2lnbmVkIHRvIHByb2R1Y2UgYSByZXVzYWJsZSBhbmltYXRpb24gdGhhdCBjYW4gYmUgbGF0ZXJcbiAqIGludm9rZWQgaW4gYW5vdGhlciBhbmltYXRpb24gb3Igc2VxdWVuY2UuIFJldXNhYmxlIGFuaW1hdGlvbnMgYXJlIGRlc2lnbmVkIHRvIG1ha2UgdXNlIG9mXG4gKiBhbmltYXRpb24gcGFyYW1ldGVycyBhbmQgdGhlIHByb2R1Y2VkIGFuaW1hdGlvbiBjYW4gYmUgdXNlZCB2aWEgdGhlIGB1c2VBbmltYXRpb25gIG1ldGhvZC5cbiAqXG4gKiBgYGBcbiAqIHZhciBmYWRlQW5pbWF0aW9uID0gYW5pbWF0aW9uKFtcbiAqICAgc3R5bGUoeyBvcGFjaXR5OiAne3sgc3RhcnQgfX0nIH0pLFxuICogICBhbmltYXRlKCd7eyB0aW1lIH19JyxcbiAqICAgICBzdHlsZSh7IG9wYWNpdHk6ICd7eyBlbmQgfX0nKSlcbiAqIF0sIHsgcGFyYW1zOiB7IHRpbWU6ICcxMDAwbXMnLCBzdGFydDogMCwgZW5kOiAxIH19KTtcbiAqIGBgYFxuICpcbiAqIElmIHBhcmFtZXRlcnMgYXJlIGF0dGFjaGVkIHRvIGFuIGFuaW1hdGlvbiB0aGVuIHRoZXkgYWN0IGFzICoqZGVmYXVsdCBwYXJhbWV0ZXIgdmFsdWVzKiouIFdoZW4gYW5cbiAqIGFuaW1hdGlvbiBpcyBpbnZva2VkIHZpYSBgdXNlQW5pbWF0aW9uYCB0aGVuIHBhcmFtZXRlciB2YWx1ZXMgYXJlIGFsbG93ZWQgdG8gYmUgcGFzc2VkIGluXG4gKiBkaXJlY3RseS4gSWYgYW55IG9mIHRoZSBwYXNzZWQgaW4gcGFyYW1ldGVyIHZhbHVlcyBhcmUgbWlzc2luZyB0aGVuIHRoZSBkZWZhdWx0IHZhbHVlcyB3aWxsIGJlXG4gKiB1c2VkLlxuICpcbiAqIGBgYFxuICogdXNlQW5pbWF0aW9uKGZhZGVBbmltYXRpb24sIHtcbiAqICAgcGFyYW1zOiB7XG4gKiAgICAgdGltZTogJzJzJyxcbiAqICAgICBzdGFydDogMSxcbiAqICAgICBlbmQ6IDBcbiAqICAgfVxuICogfSlcbiAqIGBgYFxuICpcbiAqIElmIG9uZSBvciBtb3JlIHBhcmFtZXRlciB2YWx1ZXMgYXJlIG1pc3NpbmcgYmVmb3JlIGFuaW1hdGVkIHRoZW4gYW4gZXJyb3Igd2lsbCBiZSB0aHJvd24uXG4gKlxuICogXFxAZXhwZXJpbWVudGFsIEFuaW1hdGlvbiBzdXBwb3J0IGlzIGV4cGVyaW1lbnRhbC5cbiAqIEBwYXJhbSB7P30gc3RlcHNcbiAqIEBwYXJhbSB7Pz19IG9wdGlvbnNcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGFuaW1hdGlvbihzdGVwcywgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IG51bGw7IH1cbiAgICByZXR1cm4geyB0eXBlOiA4IC8qIFJlZmVyZW5jZSAqLywgYW5pbWF0aW9uOiBzdGVwcywgb3B0aW9uczogb3B0aW9ucyB9O1xufVxuLyoqXG4gKiBgYW5pbWF0ZUNoaWxkYCBpcyBhbiBhbmltYXRpb24tc3BlY2lmaWMgZnVuY3Rpb24gdGhhdCBpcyBkZXNpZ25lZCB0byBiZSB1c2VkIGluc2lkZSBvZiBBbmd1bGFyJ3NcbiAqIGFuaW1hdGlvbiBEU0wgbGFuZ3VhZ2UuIEl0IHdvcmtzIGJ5IGFsbG93aW5nIGEgcXVlcmllZCBlbGVtZW50IHRvIGV4ZWN1dGUgaXRzIG93blxuICogYW5pbWF0aW9uIHdpdGhpbiB0aGUgYW5pbWF0aW9uIHNlcXVlbmNlLlxuICpcbiAqIEVhY2ggdGltZSBhbiBhbmltYXRpb24gaXMgdHJpZ2dlcmVkIGluIGFuZ3VsYXIsIHRoZSBwYXJlbnQgYW5pbWF0aW9uXG4gKiB3aWxsIGFsd2F5cyBnZXQgcHJpb3JpdHkgYW5kIGFueSBjaGlsZCBhbmltYXRpb25zIHdpbGwgYmUgYmxvY2tlZC4gSW4gb3JkZXJcbiAqIGZvciBhIGNoaWxkIGFuaW1hdGlvbiB0byBydW4sIHRoZSBwYXJlbnQgYW5pbWF0aW9uIG11c3QgcXVlcnkgZWFjaCBvZiB0aGUgZWxlbWVudHNcbiAqIGNvbnRhaW5pbmcgY2hpbGQgYW5pbWF0aW9ucyBhbmQgdGhlbiBhbGxvdyB0aGUgYW5pbWF0aW9ucyB0byBydW4gdXNpbmcgYGFuaW1hdGVDaGlsZGAuXG4gKlxuICogVGhlIGV4YW1wbGUgSFRNTCBjb2RlIGJlbG93IHNob3dzIGJvdGggcGFyZW50IGFuZCBjaGlsZCBlbGVtZW50cyB0aGF0IGhhdmUgYW5pbWF0aW9uXG4gKiB0cmlnZ2VycyB0aGF0IHdpbGwgZXhlY3V0ZSBhdCB0aGUgc2FtZSB0aW1lLlxuICpcbiAqIGBgYGh0bWxcbiAqIDwhLS0gcGFyZW50LWNoaWxkLmNvbXBvbmVudC5odG1sIC0tPlxuICogPGJ1dHRvbiAoY2xpY2spPVwiZXhwID0hIGV4cFwiPlRvZ2dsZTwvYnV0dG9uPlxuICogPGhyPlxuICpcbiAqIDxkaXYgW1xcQHBhcmVudEFuaW1hdGlvbl09XCJleHBcIj5cbiAqICAgPGhlYWRlcj5IZWxsbzwvaGVhZGVyPlxuICogICA8ZGl2IFtcXEBjaGlsZEFuaW1hdGlvbl09XCJleHBcIj5cbiAqICAgICAgIG9uZVxuICogICA8L2Rpdj5cbiAqICAgPGRpdiBbXFxAY2hpbGRBbmltYXRpb25dPVwiZXhwXCI+XG4gKiAgICAgICB0d29cbiAqICAgPC9kaXY+XG4gKiAgIDxkaXYgW1xcQGNoaWxkQW5pbWF0aW9uXT1cImV4cFwiPlxuICogICAgICAgdGhyZWVcbiAqICAgPC9kaXY+XG4gKiA8L2Rpdj5cbiAqIGBgYFxuICpcbiAqIE5vdyB3aGVuIHRoZSBgZXhwYCB2YWx1ZSBjaGFuZ2VzIHRvIHRydWUsIG9ubHkgdGhlIGBwYXJlbnRBbmltYXRpb25gIGFuaW1hdGlvbiB3aWxsIGFuaW1hdGVcbiAqIGJlY2F1c2UgaXQgaGFzIHByaW9yaXR5LiBIb3dldmVyLCB1c2luZyBgcXVlcnlgIGFuZCBgYW5pbWF0ZUNoaWxkYCBlYWNoIG9mIHRoZSBpbm5lciBhbmltYXRpb25zXG4gKiBjYW4gYWxzbyBmaXJlOlxuICpcbiAqIGBgYHRzXG4gKiAvLyBwYXJlbnQtY2hpbGQuY29tcG9uZW50LnRzXG4gKiBpbXBvcnQge3RyaWdnZXIsIHRyYW5zaXRpb24sIGFuaW1hdGUsIHN0eWxlLCBxdWVyeSwgYW5pbWF0ZUNoaWxkfSBmcm9tICdcXEBhbmd1bGFyL2FuaW1hdGlvbnMnO1xuICogXFxAQ29tcG9uZW50KHtcbiAqICAgc2VsZWN0b3I6ICdwYXJlbnQtY2hpbGQtY29tcG9uZW50JyxcbiAqICAgYW5pbWF0aW9uczogW1xuICogICAgIHRyaWdnZXIoJ3BhcmVudEFuaW1hdGlvbicsIFtcbiAqICAgICAgIHRyYW5zaXRpb24oJ2ZhbHNlID0+IHRydWUnLCBbXG4gKiAgICAgICAgIHF1ZXJ5KCdoZWFkZXInLCBbXG4gKiAgICAgICAgICAgc3R5bGUoeyBvcGFjaXR5OiAwIH0pLFxuICogICAgICAgICAgIGFuaW1hdGUoNTAwLCBzdHlsZSh7IG9wYWNpdHk6IDEgfSkpXG4gKiAgICAgICAgIF0pLFxuICogICAgICAgICBxdWVyeSgnXFxAY2hpbGRBbmltYXRpb24nLCBbXG4gKiAgICAgICAgICAgYW5pbWF0ZUNoaWxkKClcbiAqICAgICAgICAgXSlcbiAqICAgICAgIF0pXG4gKiAgICAgXSksXG4gKiAgICAgdHJpZ2dlcignY2hpbGRBbmltYXRpb24nLCBbXG4gKiAgICAgICB0cmFuc2l0aW9uKCdmYWxzZSA9PiB0cnVlJywgW1xuICogICAgICAgICBzdHlsZSh7IG9wYWNpdHk6IDAgfSksXG4gKiAgICAgICAgIGFuaW1hdGUoNTAwLCBzdHlsZSh7IG9wYWNpdHk6IDEgfSkpXG4gKiAgICAgICBdKVxuICogICAgIF0pXG4gKiAgIF1cbiAqIH0pXG4gKiBjbGFzcyBQYXJlbnRDaGlsZENtcCB7XG4gKiAgIGV4cDogYm9vbGVhbiA9IGZhbHNlO1xuICogfVxuICogYGBgXG4gKlxuICogSW4gdGhlIGFuaW1hdGlvbiBjb2RlIGFib3ZlLCB3aGVuIHRoZSBgcGFyZW50QW5pbWF0aW9uYCB0cmFuc2l0aW9uIGtpY2tzIG9mZiBpdCBmaXJzdCBxdWVyaWVzIHRvXG4gKiBmaW5kIHRoZSBoZWFkZXIgZWxlbWVudCBhbmQgZmFkZXMgaXQgaW4uIEl0IHRoZW4gZmluZHMgZWFjaCBvZiB0aGUgc3ViIGVsZW1lbnRzIHRoYXQgY29udGFpbiB0aGVcbiAqIGBcXEBjaGlsZEFuaW1hdGlvbmAgdHJpZ2dlciBhbmQgdGhlbiBhbGxvd3MgZm9yIHRoZWlyIGFuaW1hdGlvbnMgdG8gZmlyZS5cbiAqXG4gKiBUaGlzIGV4YW1wbGUgY2FuIGJlIGZ1cnRoZXIgZXh0ZW5kZWQgYnkgdXNpbmcgc3RhZ2dlcjpcbiAqXG4gKiBgYGB0c1xuICogcXVlcnkoJ1xcQGNoaWxkQW5pbWF0aW9uJywgc3RhZ2dlcigxMDAsIFtcbiAqICAgYW5pbWF0ZUNoaWxkKClcbiAqIF0pKVxuICogYGBgXG4gKlxuICogTm93IGVhY2ggb2YgdGhlIHN1YiBhbmltYXRpb25zIHN0YXJ0IG9mZiB3aXRoIHJlc3BlY3QgdG8gdGhlIGAxMDBtc2Agc3RhZ2dlcmluZyBzdGVwLlxuICpcbiAqICMjIFRoZSBmaXJzdCBmcmFtZSBvZiBjaGlsZCBhbmltYXRpb25zXG4gKiBXaGVuIHN1YiBhbmltYXRpb25zIGFyZSBleGVjdXRlZCB1c2luZyBgYW5pbWF0ZUNoaWxkYCB0aGUgYW5pbWF0aW9uIGVuZ2luZSB3aWxsIGFsd2F5cyBhcHBseSB0aGVcbiAqIGZpcnN0IGZyYW1lIG9mIGV2ZXJ5IHN1YiBhbmltYXRpb24gaW1tZWRpYXRlbHkgYXQgdGhlIHN0YXJ0IG9mIHRoZSBhbmltYXRpb24gc2VxdWVuY2UuIFRoaXMgd2F5XG4gKiB0aGUgcGFyZW50IGFuaW1hdGlvbiBkb2VzIG5vdCBuZWVkIHRvIHNldCBhbnkgaW5pdGlhbCBzdHlsaW5nIGRhdGEgb24gdGhlIHN1YiBlbGVtZW50cyBiZWZvcmUgdGhlXG4gKiBzdWIgYW5pbWF0aW9ucyBraWNrIG9mZi5cbiAqXG4gKiBJbiB0aGUgZXhhbXBsZSBhYm92ZSB0aGUgZmlyc3QgZnJhbWUgb2YgdGhlIGBjaGlsZEFuaW1hdGlvbmAncyBgZmFsc2UgPT4gdHJ1ZWAgdHJhbnNpdGlvblxuICogY29uc2lzdHMgb2YgYSBzdHlsZSBvZiBgb3BhY2l0eTogMGAuIFRoaXMgaXMgYXBwbGllZCBpbW1lZGlhdGVseSB3aGVuIHRoZSBgcGFyZW50QW5pbWF0aW9uYFxuICogYW5pbWF0aW9uIHRyYW5zaXRpb24gc2VxdWVuY2Ugc3RhcnRzLiBPbmx5IHRoZW4gd2hlbiB0aGUgYFxcQGNoaWxkQW5pbWF0aW9uYCBpcyBxdWVyaWVkIGFuZCBjYWxsZWRcbiAqIHdpdGggYGFuaW1hdGVDaGlsZGAgd2lsbCBpdCB0aGVuIGFuaW1hdGUgdG8gaXRzIGRlc3RpbmF0aW9uIG9mIGBvcGFjaXR5OiAxYC5cbiAqXG4gKiBOb3RlIHRoYXQgdGhpcyBmZWF0dXJlIGRlc2lnbmVkIHRvIGJlIHVzZWQgYWxvbmdzaWRlIHtcXEBsaW5rIHF1ZXJ5IHF1ZXJ5KCl9IGFuZCBpdCB3aWxsIG9ubHkgd29ya1xuICogd2l0aCBhbmltYXRpb25zIHRoYXQgYXJlIGFzc2lnbmVkIHVzaW5nIHRoZSBBbmd1bGFyIGFuaW1hdGlvbiBEU0wgKHRoaXMgbWVhbnMgdGhhdCBDU1Mga2V5ZnJhbWVzXG4gKiBhbmQgdHJhbnNpdGlvbnMgYXJlIG5vdCBoYW5kbGVkIGJ5IHRoaXMgQVBJKS5cbiAqXG4gKiBcXEBleHBlcmltZW50YWwgQW5pbWF0aW9uIHN1cHBvcnQgaXMgZXhwZXJpbWVudGFsLlxuICogQHBhcmFtIHs/PX0gb3B0aW9uc1xuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gYW5pbWF0ZUNoaWxkKG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSBudWxsOyB9XG4gICAgcmV0dXJuIHsgdHlwZTogOSAvKiBBbmltYXRlQ2hpbGQgKi8sIG9wdGlvbnM6IG9wdGlvbnMgfTtcbn1cbi8qKlxuICogYHVzZUFuaW1hdGlvbmAgaXMgYW4gYW5pbWF0aW9uLXNwZWNpZmljIGZ1bmN0aW9uIHRoYXQgaXMgZGVzaWduZWQgdG8gYmUgdXNlZCBpbnNpZGUgb2YgQW5ndWxhcidzXG4gKiBhbmltYXRpb24gRFNMIGxhbmd1YWdlLiBJdCBpcyB1c2VkIHRvIGtpY2sgb2ZmIGEgcmV1c2FibGUgYW5pbWF0aW9uIHRoYXQgaXMgY3JlYXRlZCB1c2luZyB7XFxAbGlua1xuICogYW5pbWF0aW9uIGFuaW1hdGlvbigpfS5cbiAqXG4gKiBcXEBleHBlcmltZW50YWwgQW5pbWF0aW9uIHN1cHBvcnQgaXMgZXhwZXJpbWVudGFsLlxuICogQHBhcmFtIHs/fSBhbmltYXRpb25cbiAqIEBwYXJhbSB7Pz19IG9wdGlvbnNcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIHVzZUFuaW1hdGlvbihhbmltYXRpb24sIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSBudWxsOyB9XG4gICAgcmV0dXJuIHsgdHlwZTogMTAgLyogQW5pbWF0ZVJlZiAqLywgYW5pbWF0aW9uOiBhbmltYXRpb24sIG9wdGlvbnM6IG9wdGlvbnMgfTtcbn1cbi8qKlxuICogYHF1ZXJ5YCBpcyBhbiBhbmltYXRpb24tc3BlY2lmaWMgZnVuY3Rpb24gdGhhdCBpcyBkZXNpZ25lZCB0byBiZSB1c2VkIGluc2lkZSBvZiBBbmd1bGFyJ3NcbiAqIGFuaW1hdGlvbiBEU0wgbGFuZ3VhZ2UuXG4gKlxuICogcXVlcnkoKSBpcyB1c2VkIHRvIGZpbmQgb25lIG9yIG1vcmUgaW5uZXIgZWxlbWVudHMgd2l0aGluIHRoZSBjdXJyZW50IGVsZW1lbnQgdGhhdCBpc1xuICogYmVpbmcgYW5pbWF0ZWQgd2l0aGluIHRoZSBzZXF1ZW5jZS4gVGhlIHByb3ZpZGVkIGFuaW1hdGlvbiBzdGVwcyBhcmUgYXBwbGllZFxuICogdG8gdGhlIHF1ZXJpZWQgZWxlbWVudCAoYnkgZGVmYXVsdCwgYW4gYXJyYXkgaXMgcHJvdmlkZWQsIHRoZW4gdGhpcyB3aWxsIGJlXG4gKiB0cmVhdGVkIGFzIGFuIGFuaW1hdGlvbiBzZXF1ZW5jZSkuXG4gKlxuICogIyMjIFVzYWdlXG4gKlxuICogcXVlcnkoKSBpcyBkZXNpZ25lZCB0byBjb2xsZWN0IG11dGlwbGUgZWxlbWVudHMgYW5kIHdvcmtzIGludGVybmFsbHkgYnkgdXNpbmdcbiAqIGBlbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGxgLiBBbiBhZGRpdGlvbmFsIG9wdGlvbnMgb2JqZWN0IGNhbiBiZSBwcm92aWRlZCB3aGljaFxuICogY2FuIGJlIHVzZWQgdG8gbGltaXQgdGhlIHRvdGFsIGFtb3VudCBvZiBpdGVtcyB0byBiZSBjb2xsZWN0ZWQuXG4gKlxuICogYGBganNcbiAqIHF1ZXJ5KCdkaXYnLCBbXG4gKiAgIGFuaW1hdGUoLi4uKSxcbiAqICAgYW5pbWF0ZSguLi4pXG4gKiBdLCB7IGxpbWl0OiAxIH0pXG4gKiBgYGBcbiAqXG4gKiBxdWVyeSgpLCBieSBkZWZhdWx0LCB3aWxsIHRocm93IGFuIGVycm9yIHdoZW4gemVybyBpdGVtcyBhcmUgZm91bmQuIElmIGEgcXVlcnlcbiAqIGhhcyB0aGUgYG9wdGlvbmFsYCBmbGFnIHNldCB0byB0cnVlIHRoZW4gdGhpcyBlcnJvciB3aWxsIGJlIGlnbm9yZWQuXG4gKlxuICogYGBganNcbiAqIHF1ZXJ5KCcuc29tZS1lbGVtZW50LXRoYXQtbWF5LW5vdC1iZS10aGVyZScsIFtcbiAqICAgYW5pbWF0ZSguLi4pLFxuICogICBhbmltYXRlKC4uLilcbiAqIF0sIHsgb3B0aW9uYWw6IHRydWUgfSlcbiAqIGBgYFxuICpcbiAqICMjIyBTcGVjaWFsIFNlbGVjdG9yIFZhbHVlc1xuICpcbiAqIFRoZSBzZWxlY3RvciB2YWx1ZSB3aXRoaW4gYSBxdWVyeSBjYW4gY29sbGVjdCBlbGVtZW50cyB0aGF0IGNvbnRhaW4gYW5ndWxhci1zcGVjaWZpY1xuICogY2hhcmFjdGVyaXN0aWNzXG4gKiB1c2luZyBzcGVjaWFsIHBzZXVkby1zZWxlY3RvcnMgdG9rZW5zLlxuICpcbiAqIFRoZXNlIGluY2x1ZGU6XG4gKlxuICogIC0gUXVlcnlpbmcgZm9yIG5ld2x5IGluc2VydGVkL3JlbW92ZWQgZWxlbWVudHMgdXNpbmcgYHF1ZXJ5KFwiOmVudGVyXCIpYC9gcXVlcnkoXCI6bGVhdmVcIilgXG4gKiAgLSBRdWVyeWluZyBhbGwgY3VycmVudGx5IGFuaW1hdGluZyBlbGVtZW50cyB1c2luZyBgcXVlcnkoXCI6YW5pbWF0aW5nXCIpYFxuICogIC0gUXVlcnlpbmcgZWxlbWVudHMgdGhhdCBjb250YWluIGFuIGFuaW1hdGlvbiB0cmlnZ2VyIHVzaW5nIGBxdWVyeShcIlxcQHRyaWdnZXJOYW1lXCIpYFxuICogIC0gUXVlcnlpbmcgYWxsIGVsZW1lbnRzIHRoYXQgY29udGFpbiBhbiBhbmltYXRpb24gdHJpZ2dlcnMgdXNpbmcgYHF1ZXJ5KFwiXFxAKlwiKWBcbiAqICAtIEluY2x1ZGluZyB0aGUgY3VycmVudCBlbGVtZW50IGludG8gdGhlIGFuaW1hdGlvbiBzZXF1ZW5jZSB1c2luZyBgcXVlcnkoXCI6c2VsZlwiKWBcbiAqXG4gKlxuICogIEVhY2ggb2YgdGhlc2UgcHNldWRvLXNlbGVjdG9yIHRva2VucyBjYW4gYmUgbWVyZ2VkIHRvZ2V0aGVyIGludG8gYSBjb21iaW5lZCBxdWVyeSBzZWxlY3RvclxuICogc3RyaW5nOlxuICpcbiAqICBgYGBcbiAqICBxdWVyeSgnOnNlbGYsIC5yZWNvcmQ6ZW50ZXIsIC5yZWNvcmQ6bGVhdmUsIFxcQHN1YlRyaWdnZXInLCBbLi4uXSlcbiAqICBgYGBcbiAqXG4gKiAjIyMgRGVtb1xuICpcbiAqIGBgYFxuICogXFxAQ29tcG9uZW50KHtcbiAqICAgc2VsZWN0b3I6ICdpbm5lcicsXG4gKiAgIHRlbXBsYXRlOiBgXG4gKiAgICAgPGRpdiBbXFxAcXVlcnlBbmltYXRpb25dPVwiZXhwXCI+XG4gKiAgICAgICA8aDE+VGl0bGU8L2gxPlxuICogICAgICAgPGRpdiBjbGFzcz1cImNvbnRlbnRcIj5cbiAqICAgICAgICAgQmxhaCBibGFoIGJsYWhcbiAqICAgICAgIDwvZGl2PlxuICogICAgIDwvZGl2PlxuICogICBgLFxuICogICBhbmltYXRpb25zOiBbXG4gKiAgICB0cmlnZ2VyKCdxdWVyeUFuaW1hdGlvbicsIFtcbiAqICAgICAgdHJhbnNpdGlvbignKiA9PiBnb0FuaW1hdGUnLCBbXG4gKiAgICAgICAgLy8gaGlkZSB0aGUgaW5uZXIgZWxlbWVudHNcbiAqICAgICAgICBxdWVyeSgnaDEnLCBzdHlsZSh7IG9wYWNpdHk6IDAgfSkpLFxuICogICAgICAgIHF1ZXJ5KCcuY29udGVudCcsIHN0eWxlKHsgb3BhY2l0eTogMCB9KSksXG4gKlxuICogICAgICAgIC8vIGFuaW1hdGUgdGhlIGlubmVyIGVsZW1lbnRzIGluLCBvbmUgYnkgb25lXG4gKiAgICAgICAgcXVlcnkoJ2gxJywgYW5pbWF0ZSgxMDAwLCBzdHlsZSh7IG9wYWNpdHk6IDEgfSkpLFxuICogICAgICAgIHF1ZXJ5KCcuY29udGVudCcsIGFuaW1hdGUoMTAwMCwgc3R5bGUoeyBvcGFjaXR5OiAxIH0pKSxcbiAqICAgICAgXSlcbiAqICAgIF0pXG4gKiAgXVxuICogfSlcbiAqIGNsYXNzIENtcCB7XG4gKiAgIGV4cCA9ICcnO1xuICpcbiAqICAgZ29BbmltYXRlKCkge1xuICogICAgIHRoaXMuZXhwID0gJ2dvQW5pbWF0ZSc7XG4gKiAgIH1cbiAqIH1cbiAqIGBgYFxuICpcbiAqIFxcQGV4cGVyaW1lbnRhbCBBbmltYXRpb24gc3VwcG9ydCBpcyBleHBlcmltZW50YWwuXG4gKiBAcGFyYW0gez99IHNlbGVjdG9yXG4gKiBAcGFyYW0gez99IGFuaW1hdGlvblxuICogQHBhcmFtIHs/PX0gb3B0aW9uc1xuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gcXVlcnkoc2VsZWN0b3IsIGFuaW1hdGlvbiwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IG51bGw7IH1cbiAgICByZXR1cm4geyB0eXBlOiAxMSAvKiBRdWVyeSAqLywgc2VsZWN0b3I6IHNlbGVjdG9yLCBhbmltYXRpb246IGFuaW1hdGlvbiwgb3B0aW9uczogb3B0aW9ucyB9O1xufVxuLyoqXG4gKiBgc3RhZ2dlcmAgaXMgYW4gYW5pbWF0aW9uLXNwZWNpZmljIGZ1bmN0aW9uIHRoYXQgaXMgZGVzaWduZWQgdG8gYmUgdXNlZCBpbnNpZGUgb2YgQW5ndWxhcidzXG4gKiBhbmltYXRpb24gRFNMIGxhbmd1YWdlLiBJdCBpcyBkZXNpZ25lZCB0byBiZSB1c2VkIGluc2lkZSBvZiBhbiBhbmltYXRpb24ge1xcQGxpbmsgcXVlcnkgcXVlcnkoKX1cbiAqIGFuZCB3b3JrcyBieSBpc3N1aW5nIGEgdGltaW5nIGdhcCBiZXR3ZWVuIGFmdGVyIGVhY2ggcXVlcmllZCBpdGVtIGlzIGFuaW1hdGVkLlxuICpcbiAqICMjIyBVc2FnZVxuICpcbiAqIEluIHRoZSBleGFtcGxlIGJlbG93IHRoZXJlIGlzIGEgY29udGFpbmVyIGVsZW1lbnQgdGhhdCB3cmFwcyBhIGxpc3Qgb2YgaXRlbXMgc3RhbXBlZCBvdXRcbiAqIGJ5IGFuIG5nRm9yLiBUaGUgY29udGFpbmVyIGVsZW1lbnQgY29udGFpbnMgYW4gYW5pbWF0aW9uIHRyaWdnZXIgdGhhdCB3aWxsIGxhdGVyIGJlIHNldFxuICogdG8gcXVlcnkgZm9yIGVhY2ggb2YgdGhlIGlubmVyIGl0ZW1zLlxuICpcbiAqIGBgYGh0bWxcbiAqIDwhLS0gbGlzdC5jb21wb25lbnQuaHRtbCAtLT5cbiAqIDxidXR0b24gKGNsaWNrKT1cInRvZ2dsZSgpXCI+U2hvdyAvIEhpZGUgSXRlbXM8L2J1dHRvbj5cbiAqIDxociAvPlxuICogPGRpdiBbXFxAbGlzdEFuaW1hdGlvbl09XCJpdGVtcy5sZW5ndGhcIj5cbiAqICAgPGRpdiAqbmdGb3I9XCJsZXQgaXRlbSBvZiBpdGVtc1wiPlxuICogICAgIHt7IGl0ZW0gfX1cbiAqICAgPC9kaXY+XG4gKiA8L2Rpdj5cbiAqIGBgYFxuICpcbiAqIFRoZSBjb21wb25lbnQgY29kZSBmb3IgdGhpcyBsb29rcyBhcyBzdWNoOlxuICpcbiAqIGBgYHRzXG4gKiBpbXBvcnQge3RyaWdnZXIsIHRyYW5zaXRpb24sIHN0eWxlLCBhbmltYXRlLCBxdWVyeSwgc3RhZ2dlcn0gZnJvbSAnXFxAYW5ndWxhci9hbmltYXRpb25zJztcbiAqIFxcQENvbXBvbmVudCh7XG4gKiAgIHRlbXBsYXRlVXJsOiAnbGlzdC5jb21wb25lbnQuaHRtbCcsXG4gKiAgIGFuaW1hdGlvbnM6IFtcbiAqICAgICB0cmlnZ2VyKCdsaXN0QW5pbWF0aW9uJywgW1xuICogICAgICAgIC8vLi4uXG4gKiAgICAgXSlcbiAqICAgXVxuICogfSlcbiAqIGNsYXNzIExpc3RDb21wb25lbnQge1xuICogICBpdGVtcyA9IFtdO1xuICpcbiAqICAgc2hvd0l0ZW1zKCkge1xuICogICAgIHRoaXMuaXRlbXMgPSBbMCwxLDIsMyw0XTtcbiAqICAgfVxuICpcbiAqICAgaGlkZUl0ZW1zKCkge1xuICogICAgIHRoaXMuaXRlbXMgPSBbXTtcbiAqICAgfVxuICpcbiAqICAgdG9nZ2xlKCkge1xuICogICAgIHRoaXMuaXRlbXMubGVuZ3RoID8gdGhpcy5oaWRlSXRlbXMoKSA6IHRoaXMuc2hvd0l0ZW1zKCk7XG4gKiAgIH1cbiAqIH1cbiAqIGBgYFxuICpcbiAqIEFuZCBub3cgZm9yIHRoZSBhbmltYXRpb24gdHJpZ2dlciBjb2RlOlxuICpcbiAqIGBgYHRzXG4gKiB0cmlnZ2VyKCdsaXN0QW5pbWF0aW9uJywgW1xuICogICB0cmFuc2l0aW9uKCcqID0+IConLCBbIC8vIGVhY2ggdGltZSB0aGUgYmluZGluZyB2YWx1ZSBjaGFuZ2VzXG4gKiAgICAgcXVlcnkoJzpsZWF2ZScsIFtcbiAqICAgICAgIHN0YWdnZXIoMTAwLCBbXG4gKiAgICAgICAgIGFuaW1hdGUoJzAuNXMnLCBzdHlsZSh7IG9wYWNpdHk6IDAgfSkpXG4gKiAgICAgICBdKVxuICogICAgIF0pLFxuICogICAgIHF1ZXJ5KCc6ZW50ZXInLCBbXG4gKiAgICAgICBzdHlsZSh7IG9wYWNpdHk6IDAgfSksXG4gKiAgICAgICBzdGFnZ2VyKDEwMCwgW1xuICogICAgICAgICBhbmltYXRlKCcwLjVzJywgc3R5bGUoeyBvcGFjaXR5OiAxIH0pKVxuICogICAgICAgXSlcbiAqICAgICBdKVxuICogICBdKVxuICogXSlcbiAqIGBgYFxuICpcbiAqIE5vdyBlYWNoIHRpbWUgdGhlIGl0ZW1zIGFyZSBhZGRlZC9yZW1vdmVkIHRoZW4gZWl0aGVyIHRoZSBvcGFjaXR5XG4gKiBmYWRlLWluIGFuaW1hdGlvbiB3aWxsIHJ1biBvciBlYWNoIHJlbW92ZWQgaXRlbSB3aWxsIGJlIGZhZGVkIG91dC5cbiAqIFdoZW4gZWl0aGVyIG9mIHRoZXNlIGFuaW1hdGlvbnMgb2NjdXIgdGhlbiBhIHN0YWdnZXIgZWZmZWN0IHdpbGwgYmVcbiAqIGFwcGxpZWQgYWZ0ZXIgZWFjaCBpdGVtJ3MgYW5pbWF0aW9uIGlzIHN0YXJ0ZWQuXG4gKlxuICogXFxAZXhwZXJpbWVudGFsIEFuaW1hdGlvbiBzdXBwb3J0IGlzIGV4cGVyaW1lbnRhbC5cbiAqIEBwYXJhbSB7P30gdGltaW5nc1xuICogQHBhcmFtIHs/fSBhbmltYXRpb25cbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIHN0YWdnZXIodGltaW5ncywgYW5pbWF0aW9uKSB7XG4gICAgcmV0dXJuIHsgdHlwZTogMTIgLyogU3RhZ2dlciAqLywgdGltaW5nczogdGltaW5ncywgYW5pbWF0aW9uOiBhbmltYXRpb24gfTtcbn1cblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IGFkZGVkIGJ5IHRzaWNrbGVcbiAqIEBzdXBwcmVzcyB7Y2hlY2tUeXBlc30gY2hlY2tlZCBieSB0c2NcbiAqL1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqIEBwYXJhbSB7P30gY2JcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIHNjaGVkdWxlTWljcm9UYXNrKGNiKSB7XG4gICAgUHJvbWlzZS5yZXNvbHZlKG51bGwpLnRoZW4oY2IpO1xufVxuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgYWRkZWQgYnkgdHNpY2tsZVxuICogQHN1cHByZXNzIHtjaGVja1R5cGVzfSBjaGVja2VkIGJ5IHRzY1xuICovXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vKipcbiAqIEFuaW1hdGlvblBsYXllciBjb250cm9scyBhbiBhbmltYXRpb24gc2VxdWVuY2UgdGhhdCB3YXMgcHJvZHVjZWQgZnJvbSBhIHByb2dyYW1tYXRpYyBhbmltYXRpb24uXG4gKiAoc2VlIHtcXEBsaW5rIEFuaW1hdGlvbkJ1aWxkZXIgQW5pbWF0aW9uQnVpbGRlcn0gZm9yIG1vcmUgaW5mb3JtYXRpb24gb24gaG93IHRvIGNyZWF0ZSBwcm9ncmFtbWF0aWNcbiAqIGFuaW1hdGlvbnMuKVxuICpcbiAqIFxcQGV4cGVyaW1lbnRhbCBBbmltYXRpb24gc3VwcG9ydCBpcyBleHBlcmltZW50YWwuXG4gKiBAcmVjb3JkXG4gKi9cblxuLyoqXG4gKiBcXEBleHBlcmltZW50YWwgQW5pbWF0aW9uIHN1cHBvcnQgaXMgZXhwZXJpbWVudGFsLlxuICovXG52YXIgTm9vcEFuaW1hdGlvblBsYXllciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTm9vcEFuaW1hdGlvblBsYXllcigpIHtcbiAgICAgICAgdGhpcy5fb25Eb25lRm5zID0gW107XG4gICAgICAgIHRoaXMuX29uU3RhcnRGbnMgPSBbXTtcbiAgICAgICAgdGhpcy5fb25EZXN0cm95Rm5zID0gW107XG4gICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fZGVzdHJveWVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2ZpbmlzaGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMucGFyZW50UGxheWVyID0gbnVsbDtcbiAgICAgICAgdGhpcy50b3RhbFRpbWUgPSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE5vb3BBbmltYXRpb25QbGF5ZXIucHJvdG90eXBlLl9vbkZpbmlzaCA9IC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuX2ZpbmlzaGVkKSB7XG4gICAgICAgICAgICB0aGlzLl9maW5pc2hlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9vbkRvbmVGbnMuZm9yRWFjaChmdW5jdGlvbiAoZm4pIHsgcmV0dXJuIGZuKCk7IH0pO1xuICAgICAgICAgICAgdGhpcy5fb25Eb25lRm5zID0gW107XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZm5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE5vb3BBbmltYXRpb25QbGF5ZXIucHJvdG90eXBlLm9uU3RhcnQgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IGZuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoZm4pIHsgdGhpcy5fb25TdGFydEZucy5wdXNoKGZuKTsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGZuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBOb29wQW5pbWF0aW9uUGxheWVyLnByb3RvdHlwZS5vbkRvbmUgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IGZuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoZm4pIHsgdGhpcy5fb25Eb25lRm5zLnB1c2goZm4pOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZm5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE5vb3BBbmltYXRpb25QbGF5ZXIucHJvdG90eXBlLm9uRGVzdHJveSA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gZm5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChmbikgeyB0aGlzLl9vbkRlc3Ryb3lGbnMucHVzaChmbik7IH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBOb29wQW5pbWF0aW9uUGxheWVyLnByb3RvdHlwZS5oYXNTdGFydGVkID0gLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9zdGFydGVkOyB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTm9vcEFuaW1hdGlvblBsYXllci5wcm90b3R5cGUuaW5pdCA9IC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKCkgeyB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTm9vcEFuaW1hdGlvblBsYXllci5wcm90b3R5cGUucGxheSA9IC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuaGFzU3RhcnRlZCgpKSB7XG4gICAgICAgICAgICB0aGlzLnRyaWdnZXJNaWNyb3Rhc2soKTtcbiAgICAgICAgICAgIHRoaXMuX29uU3RhcnQoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zdGFydGVkID0gdHJ1ZTtcbiAgICB9O1xuICAgIC8qIEBpbnRlcm5hbCAqL1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTm9vcEFuaW1hdGlvblBsYXllci5wcm90b3R5cGUudHJpZ2dlck1pY3JvdGFzayA9IC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBzY2hlZHVsZU1pY3JvVGFzayhmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5fb25GaW5pc2goKTsgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE5vb3BBbmltYXRpb25QbGF5ZXIucHJvdG90eXBlLl9vblN0YXJ0ID0gLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX29uU3RhcnRGbnMuZm9yRWFjaChmdW5jdGlvbiAoZm4pIHsgcmV0dXJuIGZuKCk7IH0pO1xuICAgICAgICB0aGlzLl9vblN0YXJ0Rm5zID0gW107XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE5vb3BBbmltYXRpb25QbGF5ZXIucHJvdG90eXBlLnBhdXNlID0gLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoKSB7IH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBOb29wQW5pbWF0aW9uUGxheWVyLnByb3RvdHlwZS5yZXN0YXJ0ID0gLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoKSB7IH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBOb29wQW5pbWF0aW9uUGxheWVyLnByb3RvdHlwZS5maW5pc2ggPSAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uICgpIHsgdGhpcy5fb25GaW5pc2goKTsgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE5vb3BBbmltYXRpb25QbGF5ZXIucHJvdG90eXBlLmRlc3Ryb3kgPSAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9kZXN0cm95ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2Rlc3Ryb3llZCA9IHRydWU7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaGFzU3RhcnRlZCgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fb25TdGFydCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICAgIHRoaXMuX29uRGVzdHJveUZucy5mb3JFYWNoKGZ1bmN0aW9uIChmbikgeyByZXR1cm4gZm4oKTsgfSk7XG4gICAgICAgICAgICB0aGlzLl9vbkRlc3Ryb3lGbnMgPSBbXTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBOb29wQW5pbWF0aW9uUGxheWVyLnByb3RvdHlwZS5yZXNldCA9IC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKCkgeyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTm9vcEFuaW1hdGlvblBsYXllci5wcm90b3R5cGUuc2V0UG9zaXRpb24gPSAvKipcbiAgICAgKiBAcGFyYW0gez99IHBcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChwKSB7IH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBOb29wQW5pbWF0aW9uUGxheWVyLnByb3RvdHlwZS5nZXRQb3NpdGlvbiA9IC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKCkgeyByZXR1cm4gMDsgfTtcbiAgICByZXR1cm4gTm9vcEFuaW1hdGlvblBsYXllcjtcbn0oKSk7XG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBhZGRlZCBieSB0c2lja2xlXG4gKiBAc3VwcHJlc3Mge2NoZWNrVHlwZXN9IGNoZWNrZWQgYnkgdHNjXG4gKi9cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBBbmltYXRpb25Hcm91cFBsYXllciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQW5pbWF0aW9uR3JvdXBQbGF5ZXIoX3BsYXllcnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5fcGxheWVycyA9IF9wbGF5ZXJzO1xuICAgICAgICB0aGlzLl9vbkRvbmVGbnMgPSBbXTtcbiAgICAgICAgdGhpcy5fb25TdGFydEZucyA9IFtdO1xuICAgICAgICB0aGlzLl9maW5pc2hlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9zdGFydGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2Rlc3Ryb3llZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9vbkRlc3Ryb3lGbnMgPSBbXTtcbiAgICAgICAgdGhpcy5wYXJlbnRQbGF5ZXIgPSBudWxsO1xuICAgICAgICB0aGlzLnRvdGFsVGltZSA9IDA7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGRvbmVDb3VudCA9IDA7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGRlc3Ryb3lDb3VudCA9IDA7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0YXJ0Q291bnQgPSAwO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0b3RhbCA9IHRoaXMuX3BsYXllcnMubGVuZ3RoO1xuICAgICAgICBpZiAodG90YWwgPT0gMCkge1xuICAgICAgICAgICAgc2NoZWR1bGVNaWNyb1Rhc2soZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuX29uRmluaXNoKCk7IH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fcGxheWVycy5mb3JFYWNoKGZ1bmN0aW9uIChwbGF5ZXIpIHtcbiAgICAgICAgICAgICAgICBwbGF5ZXIucGFyZW50UGxheWVyID0gX3RoaXM7XG4gICAgICAgICAgICAgICAgcGxheWVyLm9uRG9uZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgrK2RvbmVDb3VudCA+PSB0b3RhbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX29uRmluaXNoKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBwbGF5ZXIub25EZXN0cm95KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCsrZGVzdHJveUNvdW50ID49IHRvdGFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fb25EZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBwbGF5ZXIub25TdGFydChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgrK3N0YXJ0Q291bnQgPj0gdG90YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9vblN0YXJ0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudG90YWxUaW1lID0gdGhpcy5fcGxheWVycy5yZWR1Y2UoZnVuY3Rpb24gKHRpbWUsIHBsYXllcikgeyByZXR1cm4gTWF0aC5tYXgodGltZSwgcGxheWVyLnRvdGFsVGltZSk7IH0sIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFuaW1hdGlvbkdyb3VwUGxheWVyLnByb3RvdHlwZS5fb25GaW5pc2ggPSAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9maW5pc2hlZCkge1xuICAgICAgICAgICAgdGhpcy5fZmluaXNoZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fb25Eb25lRm5zLmZvckVhY2goZnVuY3Rpb24gKGZuKSB7IHJldHVybiBmbigpOyB9KTtcbiAgICAgICAgICAgIHRoaXMuX29uRG9uZUZucyA9IFtdO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFuaW1hdGlvbkdyb3VwUGxheWVyLnByb3RvdHlwZS5pbml0ID0gLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoKSB7IHRoaXMuX3BsYXllcnMuZm9yRWFjaChmdW5jdGlvbiAocGxheWVyKSB7IHJldHVybiBwbGF5ZXIuaW5pdCgpOyB9KTsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGZuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBbmltYXRpb25Hcm91cFBsYXllci5wcm90b3R5cGUub25TdGFydCA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gZm5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChmbikgeyB0aGlzLl9vblN0YXJ0Rm5zLnB1c2goZm4pOyB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQW5pbWF0aW9uR3JvdXBQbGF5ZXIucHJvdG90eXBlLl9vblN0YXJ0ID0gLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5oYXNTdGFydGVkKCkpIHtcbiAgICAgICAgICAgIHRoaXMuX29uU3RhcnRGbnMuZm9yRWFjaChmdW5jdGlvbiAoZm4pIHsgcmV0dXJuIGZuKCk7IH0pO1xuICAgICAgICAgICAgdGhpcy5fb25TdGFydEZucyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fc3RhcnRlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZm5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFuaW1hdGlvbkdyb3VwUGxheWVyLnByb3RvdHlwZS5vbkRvbmUgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IGZuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoZm4pIHsgdGhpcy5fb25Eb25lRm5zLnB1c2goZm4pOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZm5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFuaW1hdGlvbkdyb3VwUGxheWVyLnByb3RvdHlwZS5vbkRlc3Ryb3kgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IGZuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoZm4pIHsgdGhpcy5fb25EZXN0cm95Rm5zLnB1c2goZm4pOyB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQW5pbWF0aW9uR3JvdXBQbGF5ZXIucHJvdG90eXBlLmhhc1N0YXJ0ZWQgPSAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3N0YXJ0ZWQ7IH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBbmltYXRpb25Hcm91cFBsYXllci5wcm90b3R5cGUucGxheSA9IC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMucGFyZW50UGxheWVyKSB7XG4gICAgICAgICAgICB0aGlzLmluaXQoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9vblN0YXJ0KCk7XG4gICAgICAgIHRoaXMuX3BsYXllcnMuZm9yRWFjaChmdW5jdGlvbiAocGxheWVyKSB7IHJldHVybiBwbGF5ZXIucGxheSgpOyB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQW5pbWF0aW9uR3JvdXBQbGF5ZXIucHJvdG90eXBlLnBhdXNlID0gLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoKSB7IHRoaXMuX3BsYXllcnMuZm9yRWFjaChmdW5jdGlvbiAocGxheWVyKSB7IHJldHVybiBwbGF5ZXIucGF1c2UoKTsgfSk7IH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBbmltYXRpb25Hcm91cFBsYXllci5wcm90b3R5cGUucmVzdGFydCA9IC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKCkgeyB0aGlzLl9wbGF5ZXJzLmZvckVhY2goZnVuY3Rpb24gKHBsYXllcikgeyByZXR1cm4gcGxheWVyLnJlc3RhcnQoKTsgfSk7IH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBbmltYXRpb25Hcm91cFBsYXllci5wcm90b3R5cGUuZmluaXNoID0gLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX29uRmluaXNoKCk7XG4gICAgICAgIHRoaXMuX3BsYXllcnMuZm9yRWFjaChmdW5jdGlvbiAocGxheWVyKSB7IHJldHVybiBwbGF5ZXIuZmluaXNoKCk7IH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBbmltYXRpb25Hcm91cFBsYXllci5wcm90b3R5cGUuZGVzdHJveSA9IC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKCkgeyB0aGlzLl9vbkRlc3Ryb3koKTsgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFuaW1hdGlvbkdyb3VwUGxheWVyLnByb3RvdHlwZS5fb25EZXN0cm95ID0gLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5fZGVzdHJveWVkKSB7XG4gICAgICAgICAgICB0aGlzLl9kZXN0cm95ZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fb25GaW5pc2goKTtcbiAgICAgICAgICAgIHRoaXMuX3BsYXllcnMuZm9yRWFjaChmdW5jdGlvbiAocGxheWVyKSB7IHJldHVybiBwbGF5ZXIuZGVzdHJveSgpOyB9KTtcbiAgICAgICAgICAgIHRoaXMuX29uRGVzdHJveUZucy5mb3JFYWNoKGZ1bmN0aW9uIChmbikgeyByZXR1cm4gZm4oKTsgfSk7XG4gICAgICAgICAgICB0aGlzLl9vbkRlc3Ryb3lGbnMgPSBbXTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBbmltYXRpb25Hcm91cFBsYXllci5wcm90b3R5cGUucmVzZXQgPSAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fcGxheWVycy5mb3JFYWNoKGZ1bmN0aW9uIChwbGF5ZXIpIHsgcmV0dXJuIHBsYXllci5yZXNldCgpOyB9KTtcbiAgICAgICAgdGhpcy5fZGVzdHJveWVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2ZpbmlzaGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSBmYWxzZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQW5pbWF0aW9uR3JvdXBQbGF5ZXIucHJvdG90eXBlLnNldFBvc2l0aW9uID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBwXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAocCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0aW1lQXRQb3NpdGlvbiA9IHAgKiB0aGlzLnRvdGFsVGltZTtcbiAgICAgICAgdGhpcy5fcGxheWVycy5mb3JFYWNoKGZ1bmN0aW9uIChwbGF5ZXIpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBvc2l0aW9uID0gcGxheWVyLnRvdGFsVGltZSA/IE1hdGgubWluKDEsIHRpbWVBdFBvc2l0aW9uIC8gcGxheWVyLnRvdGFsVGltZSkgOiAxO1xuICAgICAgICAgICAgcGxheWVyLnNldFBvc2l0aW9uKHBvc2l0aW9uKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFuaW1hdGlvbkdyb3VwUGxheWVyLnByb3RvdHlwZS5nZXRQb3NpdGlvbiA9IC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBtaW4gPSAwO1xuICAgICAgICB0aGlzLl9wbGF5ZXJzLmZvckVhY2goZnVuY3Rpb24gKHBsYXllcikge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcCA9IHBsYXllci5nZXRQb3NpdGlvbigpO1xuICAgICAgICAgICAgbWluID0gTWF0aC5taW4ocCwgbWluKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBtaW47XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQW5pbWF0aW9uR3JvdXBQbGF5ZXIucHJvdG90eXBlLCBcInBsYXllcnNcIiwge1xuICAgICAgICBnZXQ6IC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fcGxheWVyczsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBbmltYXRpb25Hcm91cFBsYXllci5wcm90b3R5cGUuYmVmb3JlRGVzdHJveSA9IC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnBsYXllcnMuZm9yRWFjaChmdW5jdGlvbiAocGxheWVyKSB7XG4gICAgICAgICAgICBpZiAocGxheWVyLmJlZm9yZURlc3Ryb3kpIHtcbiAgICAgICAgICAgICAgICBwbGF5ZXIuYmVmb3JlRGVzdHJveSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBBbmltYXRpb25Hcm91cFBsYXllcjtcbn0oKSk7XG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBhZGRlZCBieSB0c2lja2xlXG4gKiBAc3VwcHJlc3Mge2NoZWNrVHlwZXN9IGNoZWNrZWQgYnkgdHNjXG4gKi9cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciDJtVBSRV9TVFlMRSA9ICchJztcblxuZXhwb3J0cy5BbmltYXRpb25CdWlsZGVyID0gQW5pbWF0aW9uQnVpbGRlcjtcbmV4cG9ydHMuQW5pbWF0aW9uRmFjdG9yeSA9IEFuaW1hdGlvbkZhY3Rvcnk7XG5leHBvcnRzLkFVVE9fU1RZTEUgPSBBVVRPX1NUWUxFO1xuZXhwb3J0cy5hbmltYXRlID0gYW5pbWF0ZTtcbmV4cG9ydHMuYW5pbWF0ZUNoaWxkID0gYW5pbWF0ZUNoaWxkO1xuZXhwb3J0cy5hbmltYXRpb24gPSBhbmltYXRpb247XG5leHBvcnRzLmdyb3VwID0gZ3JvdXA7XG5leHBvcnRzLmtleWZyYW1lcyA9IGtleWZyYW1lcztcbmV4cG9ydHMucXVlcnkgPSBxdWVyeTtcbmV4cG9ydHMuc2VxdWVuY2UgPSBzZXF1ZW5jZTtcbmV4cG9ydHMuc3RhZ2dlciA9IHN0YWdnZXI7XG5leHBvcnRzLnN0YXRlID0gc3RhdGU7XG5leHBvcnRzLnN0eWxlID0gc3R5bGU7XG5leHBvcnRzLnRyYW5zaXRpb24gPSB0cmFuc2l0aW9uO1xuZXhwb3J0cy50cmlnZ2VyID0gdHJpZ2dlcjtcbmV4cG9ydHMudXNlQW5pbWF0aW9uID0gdXNlQW5pbWF0aW9uO1xuZXhwb3J0cy5Ob29wQW5pbWF0aW9uUGxheWVyID0gTm9vcEFuaW1hdGlvblBsYXllcjtcbmV4cG9ydHMuybVBbmltYXRpb25Hcm91cFBsYXllciA9IEFuaW1hdGlvbkdyb3VwUGxheWVyO1xuZXhwb3J0cy7JtVBSRV9TVFlMRSA9IMm1UFJFX1NUWUxFO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG59KSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YW5pbWF0aW9ucy51bWQuanMubWFwXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AYW5ndWxhci9hbmltYXRpb25zL2J1bmRsZXMvYW5pbWF0aW9ucy51bWQuanNcbi8vIG1vZHVsZSBpZCA9IDE5XG4vLyBtb2R1bGUgY2h1bmtzID0gNCIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBEb2N1bWVudDtcblxudmFyIE5vZGUgPSByZXF1aXJlKCcuL05vZGUnKTtcbnZhciBOb2RlTGlzdCA9IHJlcXVpcmUoJy4vTm9kZUxpc3QnKTtcbnZhciBFbGVtZW50ID0gcmVxdWlyZSgnLi9FbGVtZW50Jyk7XG52YXIgVGV4dCA9IHJlcXVpcmUoJy4vVGV4dCcpO1xudmFyIENvbW1lbnQgPSByZXF1aXJlKCcuL0NvbW1lbnQnKTtcbnZhciBFdmVudCA9IHJlcXVpcmUoJy4vRXZlbnQnKTtcbnZhciBEb2N1bWVudEZyYWdtZW50ID0gcmVxdWlyZSgnLi9Eb2N1bWVudEZyYWdtZW50Jyk7XG52YXIgUHJvY2Vzc2luZ0luc3RydWN0aW9uID0gcmVxdWlyZSgnLi9Qcm9jZXNzaW5nSW5zdHJ1Y3Rpb24nKTtcbnZhciBET01JbXBsZW1lbnRhdGlvbiA9IHJlcXVpcmUoJy4vRE9NSW1wbGVtZW50YXRpb24nKTtcbnZhciBUcmVlV2Fsa2VyID0gcmVxdWlyZSgnLi9UcmVlV2Fsa2VyJyk7XG52YXIgTm9kZUl0ZXJhdG9yID0gcmVxdWlyZSgnLi9Ob2RlSXRlcmF0b3InKTtcbnZhciBOb2RlRmlsdGVyID0gcmVxdWlyZSgnLi9Ob2RlRmlsdGVyJyk7XG52YXIgVVJMID0gcmVxdWlyZSgnLi9VUkwnKTtcbnZhciBzZWxlY3QgPSByZXF1aXJlKCcuL3NlbGVjdCcpO1xudmFyIGV2ZW50cyA9IHJlcXVpcmUoJy4vZXZlbnRzJyk7XG52YXIgeG1sID0gcmVxdWlyZSgnLi94bWxuYW1lcycpO1xudmFyIGh0bWwgPSByZXF1aXJlKCcuL2h0bWxlbHRzJyk7XG52YXIgc3ZnID0gcmVxdWlyZSgnLi9zdmcnKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbnZhciBNVVRBVEUgPSByZXF1aXJlKCcuL011dGF0aW9uQ29uc3RhbnRzJyk7XG52YXIgTkFNRVNQQUNFID0gdXRpbHMuTkFNRVNQQUNFO1xudmFyIGlzQXBpV3JpdGFibGUgPSByZXF1aXJlKFwiLi9jb25maWdcIikuaXNBcGlXcml0YWJsZTtcblxuZnVuY3Rpb24gRG9jdW1lbnQoaXNIVE1MLCBhZGRyZXNzKSB7XG4gIHRoaXMubm9kZVR5cGUgPSBOb2RlLkRPQ1VNRU5UX05PREU7XG4gIHRoaXMuaXNIVE1MID0gaXNIVE1MO1xuICB0aGlzLl9hZGRyZXNzID0gYWRkcmVzcyB8fCAnYWJvdXQ6YmxhbmsnO1xuICB0aGlzLnJlYWR5U3RhdGUgPSAnbG9hZGluZyc7XG4gIHRoaXMuaW1wbGVtZW50YXRpb24gPSBuZXcgRE9NSW1wbGVtZW50YXRpb24oKTtcblxuICAvLyBET01Db3JlIHNheXMgdGhhdCBkb2N1bWVudHMgYXJlIGFsd2F5cyBhc3NvY2lhdGVkIHdpdGggdGhlbXNlbHZlc1xuICB0aGlzLm93bmVyRG9jdW1lbnQgPSBudWxsOyAvLyAuLi4gYnV0IFczQyB0ZXN0cyBleHBlY3QgbnVsbFxuXG4gIC8vIFRoZXNlIHdpbGwgYmUgaW5pdGlhbGl6ZWQgYnkgb3VyIGN1c3RvbSB2ZXJzaW9ucyBvZlxuICAvLyBhcHBlbmRDaGlsZCBhbmQgaW5zZXJ0QmVmb3JlIHRoYXQgb3ZlcnJpZGUgdGhlIGluaGVyaXRlZFxuICAvLyBOb2RlIG1ldGhvZHMuXG4gIC8vIFhYWDogb3ZlcnJpZGUgdGhvc2UgbWV0aG9kcyFcbiAgdGhpcy5kb2N0eXBlID0gbnVsbDtcbiAgdGhpcy5kb2N1bWVudEVsZW1lbnQgPSBudWxsO1xuICB0aGlzLmNoaWxkTm9kZXMgPSBuZXcgTm9kZUxpc3QoKTtcblxuICAvLyBcIkFzc29jaWF0ZWQgaW5lcnQgdGVtcGxhdGUgZG9jdW1lbnRcIlxuICB0aGlzLl90ZW1wbGF0ZURvY0NhY2hlID0gbnVsbDtcblxuICAvLyBEb2N1bWVudHMgYXJlIGFsd2F5cyByb290ZWQsIGJ5IGRlZmluaXRpb25cbiAgdGhpcy5fbmlkID0gMTtcbiAgdGhpcy5fbmV4dG5pZCA9IDI7IC8vIEZvciBudW1iZXJpbmcgY2hpbGRyZW4gb2YgdGhlIGRvY3VtZW50XG4gIHRoaXMuX25vZGVzID0gW251bGwsIHRoaXNdOyAgLy8gbmlkIHRvIG5vZGUgbWFwXG5cbiAgLy8gVGhpcyBtYWludGFpbnMgdGhlIG1hcHBpbmcgZnJvbSBlbGVtZW50IGlkcyB0byBlbGVtZW50IG5vZGVzLlxuICAvLyBXZSBtYXkgbmVlZCB0byB1cGRhdGUgdGhpcyBtYXBwaW5nIGV2ZXJ5IHRpbWUgYSBub2RlIGlzIHJvb3RlZFxuICAvLyBvciB1cHJvb3RlZCwgYW5kIGFueSB0aW1lIGFuIGF0dHJpYnV0ZSBpcyBhZGRlZCwgcmVtb3ZlZCBvciBjaGFuZ2VkXG4gIC8vIG9uIGEgcm9vdGVkIGVsZW1lbnQuXG4gIHRoaXMuYnlJZCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgLy8gVGhpcyBwcm9wZXJ0eSBob2xkcyBhIG1vbm90b25pY2FsbHkgaW5jcmVhc2luZyB2YWx1ZSBha2luIHRvXG4gIC8vIGEgdGltZXN0YW1wIHVzZWQgdG8gcmVjb3JkIHRoZSBsYXN0IG1vZGlmaWNhdGlvbiB0aW1lIG9mIG5vZGVzXG4gIC8vIGFuZCB0aGVpciBzdWJ0cmVlcy4gU2VlIHRoZSBsYXN0TW9kVGltZSBhdHRyaWJ1dGUgYW5kIG1vZGlmeSgpXG4gIC8vIG1ldGhvZCBvZiB0aGUgTm9kZSBjbGFzcy4gQW5kIHNlZSBGaWx0ZXJlZEVsZW1lbnRMaXN0IGZvciBhbiBleGFtcGxlXG4gIC8vIG9mIHRoZSB1c2Ugb2YgbGFzdE1vZFRpbWVcbiAgdGhpcy5tb2RjbG9jayA9IDA7XG59XG5cbi8vIE1hcCBmcm9tIGxvd2VyY2FzZSBldmVudCBjYXRlZ29yeSBuYW1lcyAodXNlZCBhcyBhcmd1bWVudHMgdG9cbi8vIGNyZWF0ZUV2ZW50KCkpIHRvIHRoZSBwcm9wZXJ0eSBuYW1lIGluIHRoZSBpbXBsIG9iamVjdCBvZiB0aGVcbi8vIGV2ZW50IGNvbnN0cnVjdG9yLlxudmFyIHN1cHBvcnRlZEV2ZW50cyA9IHtcbiAgZXZlbnQ6ICdFdmVudCcsXG4gIGN1c3RvbWV2ZW50OiAnQ3VzdG9tRXZlbnQnLFxuICB1aWV2ZW50OiAnVUlFdmVudCcsXG4gIG1vdXNlZXZlbnQ6ICdNb3VzZUV2ZW50J1xufTtcblxuLy8gQ2VydGFpbiBhcmd1bWVudHMgdG8gZG9jdW1lbnQuY3JlYXRlRXZlbnQoKSBtdXN0IGJlIHRyZWF0ZWQgc3BlY2lhbGx5XG52YXIgcmVwbGFjZW1lbnRFdmVudCA9IHtcbiAgZXZlbnRzOiAnZXZlbnQnLFxuICBodG1sZXZlbnRzOiAnZXZlbnQnLFxuICBtb3VzZWV2ZW50czogJ21vdXNlZXZlbnQnLFxuICBtdXRhdGlvbmV2ZW50czogJ211dGF0aW9uZXZlbnQnLFxuICB1aWV2ZW50czogJ3VpZXZlbnQnXG59O1xuXG52YXIgbWlycm9yQXR0ciA9IGZ1bmN0aW9uKGYsIG5hbWUsIGRlZmF1bHRWYWx1ZSkge1xuICByZXR1cm4ge1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbyA9IGYuY2FsbCh0aGlzKTtcbiAgICAgIGlmIChvKSB7IHJldHVybiBvW25hbWVdOyB9XG4gICAgICByZXR1cm4gZGVmYXVsdFZhbHVlO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgdmFyIG8gPSBmLmNhbGwodGhpcyk7XG4gICAgICBpZiAobykgeyBvW25hbWVdID0gdmFsdWU7IH1cbiAgICB9LFxuICB9O1xufTtcblxuRG9jdW1lbnQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShOb2RlLnByb3RvdHlwZSwge1xuICAvLyBUaGlzIG1ldGhvZCBhbGxvd3MgZG9tLmpzIHRvIGNvbW11bmljYXRlIHdpdGggYSByZW5kZXJlclxuICAvLyB0aGF0IGRpc3BsYXlzIHRoZSBkb2N1bWVudCBpbiBzb21lIHdheVxuICAvLyBYWFg6IEkgc2hvdWxkIHByb2JhYmx5IG1vdmUgdGhpcyB0byB0aGUgd2luZG93IG9iamVjdFxuICBfc2V0TXV0YXRpb25IYW5kbGVyOiB7IHZhbHVlOiBmdW5jdGlvbihoYW5kbGVyKSB7XG4gICAgdGhpcy5tdXRhdGlvbkhhbmRsZXIgPSBoYW5kbGVyO1xuICB9fSxcblxuICAvLyBUaGlzIG1ldGhvZCBhbGxvd3MgZG9tLmpzIHRvIHJlY2VpdmUgZXZlbnQgbm90aWZpY2F0aW9uc1xuICAvLyBmcm9tIHRoZSByZW5kZXJlci5cbiAgLy8gWFhYOiBJIHNob3VsZCBwcm9iYWJseSBtb3ZlIHRoaXMgdG8gdGhlIHdpbmRvdyBvYmplY3RcbiAgX2Rpc3BhdGNoUmVuZGVyZXJFdmVudDogeyB2YWx1ZTogZnVuY3Rpb24odGFyZ2V0TmlkLCB0eXBlLCBkZXRhaWxzKSB7XG4gICAgdmFyIHRhcmdldCA9IHRoaXMuX25vZGVzW3RhcmdldE5pZF07XG4gICAgaWYgKCF0YXJnZXQpIHJldHVybjtcbiAgICB0YXJnZXQuX2Rpc3BhdGNoRXZlbnQobmV3IEV2ZW50KHR5cGUsIGRldGFpbHMpLCB0cnVlKTtcbiAgfX0sXG5cbiAgbm9kZU5hbWU6IHsgdmFsdWU6ICcjZG9jdW1lbnQnfSxcbiAgbm9kZVZhbHVlOiB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbigpIHt9XG4gIH0sXG5cbiAgLy8gWFhYOiBET01Db3JlIG1heSByZW1vdmUgZG9jdW1lbnRVUkksIHNvIGl0IGlzIE5ZSSBmb3Igbm93XG4gIGRvY3VtZW50VVJJOiB7IGdldDogdXRpbHMubnlpLCBzZXQ6IHV0aWxzLm55aSB9LFxuICBjb21wYXRNb2RlOiB7IGdldDogZnVuY3Rpb24oKSB7XG4gICAgLy8gVGhlIF9xdWlya3MgcHJvcGVydHkgaXMgc2V0IGJ5IHRoZSBIVE1MIHBhcnNlclxuICAgIHJldHVybiB0aGlzLl9xdWlya3MgPyAnQmFja0NvbXBhdCcgOiAnQ1NTMUNvbXBhdCc7XG4gIH19LFxuICBwYXJlbnROb2RlOiB7IHZhbHVlOiBudWxsIH0sXG5cbiAgY3JlYXRlVGV4dE5vZGU6IHsgdmFsdWU6IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICByZXR1cm4gbmV3IFRleHQodGhpcywgJycgKyBkYXRhKTtcbiAgfX0sXG4gIGNyZWF0ZUNvbW1lbnQ6IHsgdmFsdWU6IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICByZXR1cm4gbmV3IENvbW1lbnQodGhpcywgZGF0YSk7XG4gIH19LFxuICBjcmVhdGVEb2N1bWVudEZyYWdtZW50OiB7IHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbmV3IERvY3VtZW50RnJhZ21lbnQodGhpcyk7XG4gIH19LFxuICBjcmVhdGVQcm9jZXNzaW5nSW5zdHJ1Y3Rpb246IHsgdmFsdWU6IGZ1bmN0aW9uKHRhcmdldCwgZGF0YSkge1xuICAgIGlmICgheG1sLmlzVmFsaWROYW1lKHRhcmdldCkgfHwgZGF0YS5pbmRleE9mKCc/PicpICE9PSAtMSlcbiAgICAgIHV0aWxzLkludmFsaWRDaGFyYWN0ZXJFcnJvcigpO1xuICAgIHJldHVybiBuZXcgUHJvY2Vzc2luZ0luc3RydWN0aW9uKHRoaXMsIHRhcmdldCwgZGF0YSk7XG4gIH19LFxuXG4gIGNyZWF0ZUVsZW1lbnQ6IHsgdmFsdWU6IGZ1bmN0aW9uKGxvY2FsTmFtZSkge1xuICAgIGlmICgheG1sLmlzVmFsaWROYW1lKGxvY2FsTmFtZSkpIHV0aWxzLkludmFsaWRDaGFyYWN0ZXJFcnJvcigpO1xuICAgIGlmICh0aGlzLmlzSFRNTCkgbG9jYWxOYW1lID0gdXRpbHMudG9BU0NJSUxvd2VyQ2FzZShsb2NhbE5hbWUpO1xuICAgIHJldHVybiBodG1sLmNyZWF0ZUVsZW1lbnQodGhpcywgbG9jYWxOYW1lLCBudWxsKTtcbiAgfSwgd3JpdGFibGU6IGlzQXBpV3JpdGFibGUgfSxcblxuICBjcmVhdGVFbGVtZW50TlM6IHsgdmFsdWU6IGZ1bmN0aW9uKG5hbWVzcGFjZSwgcXVhbGlmaWVkTmFtZSkge1xuICAgIGlmICgheG1sLmlzVmFsaWROYW1lKHF1YWxpZmllZE5hbWUpKSB1dGlscy5JbnZhbGlkQ2hhcmFjdGVyRXJyb3IoKTtcbiAgICBpZiAoIXhtbC5pc1ZhbGlkUU5hbWUocXVhbGlmaWVkTmFtZSkpIHV0aWxzLk5hbWVzcGFjZUVycm9yKCk7XG5cbiAgICB2YXIgcG9zLCBwcmVmaXgsIGxvY2FsTmFtZTtcbiAgICBpZiAoKHBvcyA9IHF1YWxpZmllZE5hbWUuaW5kZXhPZignOicpKSAhPT0gLTEpIHtcbiAgICAgIHByZWZpeCA9IHF1YWxpZmllZE5hbWUuc3Vic3RyaW5nKDAsIHBvcyk7XG4gICAgICBsb2NhbE5hbWUgPSBxdWFsaWZpZWROYW1lLnN1YnN0cmluZyhwb3MrMSk7XG5cbiAgICAgIGlmIChuYW1lc3BhY2UgPT09ICcnIHx8XG4gICAgICAgIChwcmVmaXggPT09ICd4bWwnICYmIG5hbWVzcGFjZSAhPT0gTkFNRVNQQUNFLlhNTCkpXG4gICAgICAgIHV0aWxzLk5hbWVzcGFjZUVycm9yKCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcHJlZml4ID0gbnVsbDtcbiAgICAgIGxvY2FsTmFtZSA9IHF1YWxpZmllZE5hbWU7XG4gICAgfVxuXG4gICAgaWYgKCgocXVhbGlmaWVkTmFtZSA9PT0gJ3htbG5zJyB8fCBwcmVmaXggPT09ICd4bWxucycpICYmXG4gICAgICAgbmFtZXNwYWNlICE9PSBOQU1FU1BBQ0UuWE1MTlMpIHx8XG4gICAgICAobmFtZXNwYWNlID09PSBOQU1FU1BBQ0UuWE1MTlMgJiZcbiAgICAgICBxdWFsaWZpZWROYW1lICE9PSAneG1sbnMnICYmXG4gICAgICAgcHJlZml4ICE9PSAneG1sbnMnKSlcbiAgICAgIHV0aWxzLk5hbWVzcGFjZUVycm9yKCk7XG5cbiAgICBpZiAobmFtZXNwYWNlID09PSBOQU1FU1BBQ0UuSFRNTCkge1xuICAgICAgcmV0dXJuIGh0bWwuY3JlYXRlRWxlbWVudCh0aGlzLCBsb2NhbE5hbWUsIHByZWZpeCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKG5hbWVzcGFjZSA9PT0gTkFNRVNQQUNFLlNWRykge1xuICAgICAgcmV0dXJuIHN2Zy5jcmVhdGVFbGVtZW50KHRoaXMsIGxvY2FsTmFtZSwgcHJlZml4KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IEVsZW1lbnQodGhpcywgbG9jYWxOYW1lLCBuYW1lc3BhY2UsIHByZWZpeCk7XG4gIH0sIHdyaXRhYmxlOiBpc0FwaVdyaXRhYmxlIH0sXG5cbiAgY3JlYXRlRXZlbnQ6IHsgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZUV2ZW50KGludGVyZmFjZU5hbWUpIHtcbiAgICBpbnRlcmZhY2VOYW1lID0gaW50ZXJmYWNlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIHZhciBuYW1lID0gcmVwbGFjZW1lbnRFdmVudFtpbnRlcmZhY2VOYW1lXSB8fCBpbnRlcmZhY2VOYW1lO1xuICAgIHZhciBjb25zdHJ1Y3RvciA9IGV2ZW50c1tzdXBwb3J0ZWRFdmVudHNbbmFtZV1dO1xuXG4gICAgaWYgKGNvbnN0cnVjdG9yKSB7XG4gICAgICB2YXIgZSA9IG5ldyBjb25zdHJ1Y3RvcigpO1xuICAgICAgZS5faW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICAgIHJldHVybiBlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHV0aWxzLk5vdFN1cHBvcnRlZEVycm9yKCk7XG4gICAgfVxuICB9fSxcblxuICAvLyBTZWU6IGh0dHA6Ly93d3cudzMub3JnL1RSL2RvbS8jZG9tLWRvY3VtZW50LWNyZWF0ZXRyZWV3YWxrZXJcbiAgY3JlYXRlVHJlZVdhbGtlcjoge3ZhbHVlOiBmdW5jdGlvbiAocm9vdCwgd2hhdFRvU2hvdywgZmlsdGVyKSB7XG4gICAgd2hhdFRvU2hvdyA9IHdoYXRUb1Nob3cgPT09IHVuZGVmaW5lZCA/IE5vZGVGaWx0ZXIuU0hPV19BTEwgOiB3aGF0VG9TaG93O1xuXG4gICAgaWYgKGZpbHRlciAmJiB0eXBlb2YgZmlsdGVyID09PSAnb2JqZWN0JyAmJlxuICAgICAgICB0eXBlb2YgZmlsdGVyLmFjY2VwdE5vZGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGZpbHRlciA9IGZpbHRlci5hY2NlcHROb2RlLmJpbmQoZmlsdGVyKTtcbiAgICAgIC8vIFN1cHBvcnQgZmlsdGVyIGJlaW5nIGEgZnVuY3Rpb25cbiAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvRE9NL2RvY3VtZW50LmNyZWF0ZVRyZWVXYWxrZXJcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGZpbHRlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZmlsdGVyID0gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBUcmVlV2Fsa2VyKHJvb3QsIHdoYXRUb1Nob3csIGZpbHRlcik7XG4gIH19LFxuXG4gIC8vIFNlZTogaHR0cDovL3d3dy53My5vcmcvVFIvZG9tLyNkb20tZG9jdW1lbnQtY3JlYXRlbm9kZWl0ZXJhdG9yXG4gIGNyZWF0ZU5vZGVJdGVyYXRvcjoge3ZhbHVlOiBmdW5jdGlvbiAocm9vdCwgd2hhdFRvU2hvdywgZmlsdGVyKSB7XG4gICAgd2hhdFRvU2hvdyA9IHdoYXRUb1Nob3cgPT09IHVuZGVmaW5lZCA/IE5vZGVGaWx0ZXIuU0hPV19BTEwgOiB3aGF0VG9TaG93O1xuXG4gICAgaWYgKGZpbHRlciAmJiB0eXBlb2YgZmlsdGVyID09PSAnb2JqZWN0JyAmJlxuICAgICAgICB0eXBlb2YgZmlsdGVyLmFjY2VwdE5vZGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGZpbHRlciA9IGZpbHRlci5hY2NlcHROb2RlLmJpbmQoZmlsdGVyKTtcbiAgICAgIC8vIFN1cHBvcnQgZmlsdGVyIGJlaW5nIGEgZnVuY3Rpb25cbiAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvRE9NL2RvY3VtZW50LmNyZWF0ZU5vZGVJdGVyYXRvclxuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgZmlsdGVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBmaWx0ZXIgPSBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IE5vZGVJdGVyYXRvcihyb290LCB3aGF0VG9TaG93LCBmaWx0ZXIpO1xuICB9fSxcblxuICAvLyBNYWludGFpbiB0aGUgZG9jdW1lbnRFbGVtZW50IGFuZFxuICAvLyBkb2N0eXBlIHByb3BlcnRpZXMgb2YgdGhlIGRvY3VtZW50LiAgRWFjaCBvZiB0aGUgZm9sbG93aW5nXG4gIC8vIG1ldGhvZHMgY2hhaW5zIHRvIHRoZSBOb2RlIGltcGxlbWVudGF0aW9uIG9mIHRoZSBtZXRob2RcbiAgLy8gdG8gZG8gdGhlIGFjdHVhbCBpbnNlcnRpbmcsIHJlbW92YWwgb3IgcmVwbGFjZW1lbnQuXG5cbiAgX3VwZGF0ZURvY1R5cGVFbGVtZW50OiB7IHZhbHVlOiBmdW5jdGlvbiBfdXBkYXRlRG9jVHlwZUVsZW1lbnQoKSB7XG4gICAgdmFyIGksIG4sIG5vZGVzID0gdGhpcy5jaGlsZE5vZGVzLCBsZW5ndGggPSBub2Rlcy5sZW5ndGg7XG4gICAgdGhpcy5kb2N0eXBlID0gdGhpcy5kb2N1bWVudEVsZW1lbnQgPSBudWxsO1xuICAgIGZvciAoaT0wOyBpPGxlbmd0aDsgaSsrKSB7XG4gICAgICBuID0gbm9kZXNbaV07XG4gICAgICBpZiAobi5ub2RlVHlwZSA9PT0gTm9kZS5ET0NVTUVOVF9UWVBFX05PREUpXG4gICAgICAgIHRoaXMuZG9jdHlwZSA9IG47XG4gICAgICBlbHNlIGlmIChuLm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSlcbiAgICAgICAgdGhpcy5kb2N1bWVudEVsZW1lbnQgPSBuO1xuICAgIH1cbiAgfX0sXG5cbiAgaW5zZXJ0QmVmb3JlOiB7IHZhbHVlOiBmdW5jdGlvbiBpbnNlcnRCZWZvcmUoY2hpbGQsIHJlZkNoaWxkKSB7XG4gICAgTm9kZS5wcm90b3R5cGUuaW5zZXJ0QmVmb3JlLmNhbGwodGhpcywgY2hpbGQsIHJlZkNoaWxkKTtcbiAgICB0aGlzLl91cGRhdGVEb2NUeXBlRWxlbWVudCgpO1xuICAgIHJldHVybiBjaGlsZDtcbiAgfX0sXG5cbiAgcmVwbGFjZUNoaWxkOiB7IHZhbHVlOiBmdW5jdGlvbiByZXBsYWNlQ2hpbGQobm9kZSwgY2hpbGQpIHtcbiAgICBOb2RlLnByb3RvdHlwZS5yZXBsYWNlQ2hpbGQuY2FsbCh0aGlzLCBub2RlLCBjaGlsZCk7XG4gICAgdGhpcy5fdXBkYXRlRG9jVHlwZUVsZW1lbnQoKTtcbiAgICByZXR1cm4gY2hpbGQ7XG4gIH19LFxuXG4gIHJlbW92ZUNoaWxkOiB7IHZhbHVlOiBmdW5jdGlvbiByZW1vdmVDaGlsZChjaGlsZCkge1xuICAgIE5vZGUucHJvdG90eXBlLnJlbW92ZUNoaWxkLmNhbGwodGhpcywgY2hpbGQpO1xuICAgIHRoaXMuX3VwZGF0ZURvY1R5cGVFbGVtZW50KCk7XG4gICAgcmV0dXJuIGNoaWxkO1xuICB9fSxcblxuICBnZXRFbGVtZW50QnlJZDogeyB2YWx1ZTogZnVuY3Rpb24oaWQpIHtcbiAgICB2YXIgbiA9IHRoaXMuYnlJZFtpZF07XG4gICAgaWYgKCFuKSByZXR1cm4gbnVsbDtcbiAgICBpZiAobiBpbnN0YW5jZW9mIE11bHRpSWQpIHsgLy8gdGhlcmUgd2FzIG1vcmUgdGhhbiBvbmUgZWxlbWVudCB3aXRoIHRoaXMgaWRcbiAgICAgIHJldHVybiBuLmdldEZpcnN0KCk7XG4gICAgfVxuICAgIHJldHVybiBuO1xuICB9fSxcblxuICBfaGFzTXVsdGlwbGVFbGVtZW50c1dpdGhJZDogeyB2YWx1ZTogZnVuY3Rpb24oaWQpIHtcbiAgICAvLyBVc2VkIGludGVybmFsbHkgYnkgcXVlcnlTZWxlY3RvckFsbCBvcHRpbWl6YXRpb25cbiAgICByZXR1cm4gKHRoaXMuYnlJZFtpZF0gaW5zdGFuY2VvZiBNdWx0aUlkKTtcbiAgfX0sXG5cbiAgLy8gSnVzdCBjb3B5IHRoaXMgbWV0aG9kIGZyb20gdGhlIEVsZW1lbnQgcHJvdG90eXBlXG4gIGdldEVsZW1lbnRzQnlOYW1lOiB7IHZhbHVlOiBFbGVtZW50LnByb3RvdHlwZS5nZXRFbGVtZW50c0J5TmFtZSB9LFxuICBnZXRFbGVtZW50c0J5VGFnTmFtZTogeyB2YWx1ZTogRWxlbWVudC5wcm90b3R5cGUuZ2V0RWxlbWVudHNCeVRhZ05hbWUgfSxcbiAgZ2V0RWxlbWVudHNCeVRhZ05hbWVOUzogeyB2YWx1ZTogRWxlbWVudC5wcm90b3R5cGUuZ2V0RWxlbWVudHNCeVRhZ05hbWVOUyB9LFxuICBnZXRFbGVtZW50c0J5Q2xhc3NOYW1lOiB7IHZhbHVlOiBFbGVtZW50LnByb3RvdHlwZS5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lIH0sXG5cbiAgYWRvcHROb2RlOiB7IHZhbHVlOiBmdW5jdGlvbiBhZG9wdE5vZGUobm9kZSkge1xuICAgIGlmIChub2RlLm5vZGVUeXBlID09PSBOb2RlLkRPQ1VNRU5UX05PREUpIHV0aWxzLk5vdFN1cHBvcnRlZEVycm9yKCk7XG5cbiAgICBpZiAobm9kZS5wYXJlbnROb2RlKSBub2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobm9kZSk7XG5cbiAgICBpZiAobm9kZS5vd25lckRvY3VtZW50ICE9PSB0aGlzKVxuICAgICAgcmVjdXJzaXZlbHlTZXRPd25lcihub2RlLCB0aGlzKTtcblxuICAgIHJldHVybiBub2RlO1xuICB9fSxcblxuICBpbXBvcnROb2RlOiB7IHZhbHVlOiBmdW5jdGlvbiBpbXBvcnROb2RlKG5vZGUsIGRlZXApIHtcbiAgICByZXR1cm4gdGhpcy5hZG9wdE5vZGUobm9kZS5jbG9uZU5vZGUoZGVlcCkpO1xuICB9LCB3cml0YWJsZTogaXNBcGlXcml0YWJsZSB9LFxuXG4gIC8vIFRoZSBmb2xsb3dpbmcgYXR0cmlidXRlcyBhbmQgbWV0aG9kcyBhcmUgZnJvbSB0aGUgSFRNTCBzcGVjXG4gIFVSTDogeyBnZXQ6IHV0aWxzLm55aSB9LFxuICBkb21haW46IHsgZ2V0OiB1dGlscy5ueWksIHNldDogdXRpbHMubnlpIH0sXG4gIHJlZmVycmVyOiB7IGdldDogdXRpbHMubnlpIH0sXG4gIGNvb2tpZTogeyBnZXQ6IHV0aWxzLm55aSwgc2V0OiB1dGlscy5ueWkgfSxcbiAgbGFzdE1vZGlmaWVkOiB7IGdldDogdXRpbHMubnlpIH0sXG4gIGxvY2F0aW9uOiB7XG5cdGdldDogZnVuY3Rpb24oKSB7XG5cdCAgcmV0dXJuIHRoaXMuZGVmYXVsdFZpZXcgPyB0aGlzLmRlZmF1bHRWaWV3LmxvY2F0aW9uIDogbnVsbDsgLy8gZ2ggIzc1XG5cdH0sXG5cdHNldDogdXRpbHMubnlpXG4gIH0sXG4gIF90aXRsZUVsZW1lbnQ6IHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgLy8gVGhlIHRpdGxlIGVsZW1lbnQgb2YgYSBkb2N1bWVudCBpcyB0aGUgZmlyc3QgdGl0bGUgZWxlbWVudCBpbiB0aGVcbiAgICAgIC8vIGRvY3VtZW50IGluIHRyZWUgb3JkZXIsIGlmIHRoZXJlIGlzIG9uZSwgb3IgbnVsbCBvdGhlcndpc2UuXG4gICAgICByZXR1cm4gdGhpcy5nZXRFbGVtZW50c0J5VGFnTmFtZSgndGl0bGUnKS5pdGVtKDApIHx8IG51bGw7XG4gICAgfVxuICB9LFxuICB0aXRsZToge1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZWx0ID0gdGhpcy5fdGl0bGVFbGVtZW50O1xuICAgICAgLy8gVGhlIGNoaWxkIHRleHQgY29udGVudCBvZiB0aGUgdGl0bGUgZWxlbWVudCwgb3IgJycgaWYgbnVsbC5cbiAgICAgIHZhciB2YWx1ZSA9IGVsdCA/IGVsdC50ZXh0Q29udGVudCA6ICcnO1xuICAgICAgLy8gU3RyaXAgYW5kIGNvbGxhcHNlIHdoaXRlc3BhY2UgaW4gdmFsdWVcbiAgICAgIHJldHVybiB2YWx1ZS5yZXBsYWNlKC9bIFxcdFxcblxcclxcZl0rL2csICcgJykudHJpbSgpO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgdmFyIGVsdCA9IHRoaXMuX3RpdGxlRWxlbWVudDtcbiAgICAgIHZhciBoZWFkID0gdGhpcy5oZWFkO1xuICAgICAgaWYgKCFlbHQgJiYgIWhlYWQpIHsgcmV0dXJuOyAvKiBhY2NvcmRpbmcgdG8gc3BlYyAqLyB9XG4gICAgICBpZiAoIWVsdCkge1xuICAgICAgICBlbHQgPSB0aGlzLmNyZWF0ZUVsZW1lbnQoJ3RpdGxlJyk7XG4gICAgICAgIGhlYWQuYXBwZW5kQ2hpbGQoZWx0KTtcbiAgICAgIH1cbiAgICAgIGVsdC50ZXh0Q29udGVudCA9IHZhbHVlO1xuICAgIH1cbiAgfSxcbiAgZGlyOiBtaXJyb3JBdHRyKGZ1bmN0aW9uKCkge1xuICAgIHZhciBodG1sRWxlbWVudCA9IHRoaXMuZG9jdW1lbnRFbGVtZW50O1xuICAgIGlmIChodG1sRWxlbWVudCAmJiBodG1sRWxlbWVudC50YWdOYW1lID09PSAnSFRNTCcpIHsgcmV0dXJuIGh0bWxFbGVtZW50OyB9XG4gIH0sICdkaXInLCAnJyksXG4gIGZnQ29sb3I6IG1pcnJvckF0dHIoZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLmJvZHk7IH0sICd0ZXh0JywgJycpLFxuICBsaW5rQ29sb3I6IG1pcnJvckF0dHIoZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLmJvZHk7IH0sICdsaW5rJywgJycpLFxuICB2bGlua0NvbG9yOiBtaXJyb3JBdHRyKGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5ib2R5OyB9LCAndkxpbmsnLCAnJyksXG4gIGFsaW5rQ29sb3I6IG1pcnJvckF0dHIoZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLmJvZHk7IH0sICdhTGluaycsICcnKSxcbiAgYmdDb2xvcjogbWlycm9yQXR0cihmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuYm9keTsgfSwgJ2JnQ29sb3InLCAnJyksXG5cbiAgLy8gUmV0dXJuIHRoZSBmaXJzdCA8Ym9keT4gY2hpbGQgb2YgdGhlIGRvY3VtZW50IGVsZW1lbnQuXG4gIC8vIFhYWCBGb3Igbm93LCBzZXR0aW5nIHRoaXMgYXR0cmlidXRlIGlzIG5vdCBpbXBsZW1lbnRlZC5cbiAgYm9keToge1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gbmFtZWRIVE1MQ2hpbGQodGhpcy5kb2N1bWVudEVsZW1lbnQsICdib2R5Jyk7XG4gICAgfSxcbiAgICBzZXQ6IHV0aWxzLm55aVxuICB9LFxuICAvLyBSZXR1cm4gdGhlIGZpcnN0IDxoZWFkPiBjaGlsZCBvZiB0aGUgZG9jdW1lbnQgZWxlbWVudC5cbiAgaGVhZDogeyBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBuYW1lZEhUTUxDaGlsZCh0aGlzLmRvY3VtZW50RWxlbWVudCwgJ2hlYWQnKTtcbiAgfX0sXG4gIGltYWdlczogeyBnZXQ6IHV0aWxzLm55aSB9LFxuICBlbWJlZHM6IHsgZ2V0OiB1dGlscy5ueWkgfSxcbiAgcGx1Z2luczogeyBnZXQ6IHV0aWxzLm55aSB9LFxuICBsaW5rczogeyBnZXQ6IHV0aWxzLm55aSB9LFxuICBmb3JtczogeyBnZXQ6IHV0aWxzLm55aSB9LFxuICBzY3JpcHRzOiB7IGdldDogdXRpbHMubnlpIH0sXG4gIGlubmVySFRNTDoge1xuICAgIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLnNlcmlhbGl6ZSgpOyB9LFxuICAgIHNldDogdXRpbHMubnlpXG4gIH0sXG4gIG91dGVySFRNTDoge1xuICAgIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLnNlcmlhbGl6ZSgpOyB9LFxuICAgIHNldDogdXRpbHMubnlpXG4gIH0sXG5cbiAgd3JpdGU6IHsgdmFsdWU6IGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICBpZiAoIXRoaXMuaXNIVE1MKSB1dGlscy5JbnZhbGlkU3RhdGVFcnJvcigpO1xuXG4gICAgLy8gWFhYOiBzdGlsbCBoYXZlIHRvIGltcGxlbWVudCB0aGUgaWdub3JlIHBhcnRcbiAgICBpZiAoIXRoaXMuX3BhcnNlciAvKiAmJiB0aGlzLl9pZ25vcmVfZGVzdHJ1Y3RpdmVfd3JpdGVzID4gMCAqLyApXG4gICAgICByZXR1cm47XG5cbiAgICBpZiAoIXRoaXMuX3BhcnNlcikge1xuICAgICAgLy8gWFhYIGNhbGwgZG9jdW1lbnQub3BlbiwgZXRjLlxuICAgIH1cblxuICAgIHZhciBzID0gYXJndW1lbnRzLmpvaW4oJycpO1xuXG4gICAgLy8gSWYgdGhlIERvY3VtZW50IG9iamVjdCdzIHJlbG9hZCBvdmVycmlkZSBmbGFnIGlzIHNldCwgdGhlblxuICAgIC8vIGFwcGVuZCB0aGUgc3RyaW5nIGNvbnNpc3Rpbmcgb2YgdGhlIGNvbmNhdGVuYXRpb24gb2YgYWxsIHRoZVxuICAgIC8vIGFyZ3VtZW50cyB0byB0aGUgbWV0aG9kIHRvIHRoZSBEb2N1bWVudCdzIHJlbG9hZCBvdmVycmlkZVxuICAgIC8vIGJ1ZmZlci5cbiAgICAvLyBYWFg6IGRvbid0IGtub3cgd2hhdCB0aGlzIGlzIGFib3V0LiAgU3RpbGwgaGF2ZSB0byBkbyBpdFxuXG4gICAgLy8gSWYgdGhlcmUgaXMgbm8gcGVuZGluZyBwYXJzaW5nLWJsb2NraW5nIHNjcmlwdCwgaGF2ZSB0aGVcbiAgICAvLyB0b2tlbml6ZXIgcHJvY2VzcyB0aGUgY2hhcmFjdGVycyB0aGF0IHdlcmUgaW5zZXJ0ZWQsIG9uZSBhdCBhXG4gICAgLy8gdGltZSwgcHJvY2Vzc2luZyByZXN1bHRpbmcgdG9rZW5zIGFzIHRoZXkgYXJlIGVtaXR0ZWQsIGFuZFxuICAgIC8vIHN0b3BwaW5nIHdoZW4gdGhlIHRva2VuaXplciByZWFjaGVzIHRoZSBpbnNlcnRpb24gcG9pbnQgb3Igd2hlblxuICAgIC8vIHRoZSBwcm9jZXNzaW5nIG9mIHRoZSB0b2tlbml6ZXIgaXMgYWJvcnRlZCBieSB0aGUgdHJlZVxuICAgIC8vIGNvbnN0cnVjdGlvbiBzdGFnZSAodGhpcyBjYW4gaGFwcGVuIGlmIGEgc2NyaXB0IGVuZCB0YWcgdG9rZW4gaXNcbiAgICAvLyBlbWl0dGVkIGJ5IHRoZSB0b2tlbml6ZXIpLlxuXG4gICAgLy8gWFhYOiBzdGlsbCBoYXZlIHRvIGRvIHRoZSBhYm92ZS4gU291bmRzIGFzIGlmIHdlIGRvbid0XG4gICAgLy8gYWx3YXlzIGNhbGwgcGFyc2UoKSBoZXJlLiAgSWYgd2UncmUgYmxvY2tlZCwgdGhlbiB3ZSBqdXN0XG4gICAgLy8gaW5zZXJ0IHRoZSB0ZXh0IGludG8gdGhlIHN0cmVhbSBidXQgZG9uJ3QgcGFyc2UgaXQgcmVlbnRyYW50bHkuLi5cblxuICAgIC8vIEludm9rZSB0aGUgcGFyc2VyIHJlZW50cmFudGx5XG4gICAgdGhpcy5fcGFyc2VyLnBhcnNlKHMpO1xuICB9fSxcblxuICB3cml0ZWxuOiB7IHZhbHVlOiBmdW5jdGlvbiB3cml0ZWxuKGFyZ3MpIHtcbiAgICB0aGlzLndyaXRlKEFycmF5LnByb3RvdHlwZS5qb2luLmNhbGwoYXJndW1lbnRzLCAnJykgKyAnXFxuJyk7XG4gIH19LFxuXG4gIG9wZW46IHsgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuZG9jdW1lbnRFbGVtZW50ID0gbnVsbDtcbiAgfX0sXG5cbiAgY2xvc2U6IHsgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMucmVhZHlTdGF0ZSA9ICdjb21wbGV0ZSc7XG4gICAgdmFyIGV2ID0gbmV3IEV2ZW50KCdET01Db250ZW50TG9hZGVkJyk7XG4gICAgdGhpcy5fZGlzcGF0Y2hFdmVudChldiwgdHJ1ZSk7XG4gICAgaWYgKHRoaXMuZGVmYXVsdFZpZXcpIHtcbiAgICAgIGV2ID0gbmV3IEV2ZW50KCdsb2FkJyk7XG4gICAgICB0aGlzLmRlZmF1bHRWaWV3Ll9kaXNwYXRjaEV2ZW50KGV2LCB0cnVlKTtcbiAgICB9XG4gIH19LFxuXG4gIC8vIFV0aWxpdHkgbWV0aG9kc1xuICBjbG9uZTogeyB2YWx1ZTogZnVuY3Rpb24gY2xvbmUoKSB7XG4gICAgLy8gQ2FuJ3QgY2xvbmUgYW4gZW50aXJlIGRvY3VtZW50XG4gICAgdXRpbHMuRGF0YUNsb25lRXJyb3IoKTtcbiAgfX0sXG5cbiAgaXNFcXVhbDogeyB2YWx1ZTogZnVuY3Rpb24gaXNFcXVhbChuKSB7XG4gICAgLy8gQW55IHR3byBkb2N1bWVudHMgYXJlIHNoYWxsb3dseSBlcXVhbC5cbiAgICAvLyBOb2RlLmlzRXF1YWxOb2RlIHdpbGwgYWxzbyB0ZXN0IHRoZSBjaGlsZHJlblxuICAgIHJldHVybiB0cnVlO1xuICB9fSxcblxuICAvLyBJbXBsZW1lbnRhdGlvbi1zcGVjaWZpYyBmdW5jdGlvbi4gIENhbGxlZCB3aGVuIGEgdGV4dCwgY29tbWVudCxcbiAgLy8gb3IgcGkgdmFsdWUgY2hhbmdlcy5cbiAgbXV0YXRlVmFsdWU6IHsgdmFsdWU6IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICBpZiAodGhpcy5tdXRhdGlvbkhhbmRsZXIpIHtcbiAgICAgIHRoaXMubXV0YXRpb25IYW5kbGVyKHtcbiAgICAgICAgdHlwZTogTVVUQVRFLlZBTFVFLFxuICAgICAgICB0YXJnZXQ6IG5vZGUsXG4gICAgICAgIGRhdGE6IG5vZGUuZGF0YVxuICAgICAgfSk7XG4gICAgfVxuICB9fSxcblxuICAvLyBJbnZva2VkIHdoZW4gYW4gYXR0cmlidXRlJ3MgdmFsdWUgY2hhbmdlcy4gQXR0ciBob2xkcyB0aGUgbmV3XG4gIC8vIHZhbHVlLiAgb2xkdmFsIGlzIHRoZSBvbGQgdmFsdWUuICBBdHRyaWJ1dGUgbXV0YXRpb25zIGNhbiBhbHNvXG4gIC8vIGludm9sdmUgY2hhbmdlcyB0byB0aGUgcHJlZml4IChhbmQgdGhlcmVmb3JlIHRoZSBxdWFsaWZpZWQgbmFtZSlcbiAgbXV0YXRlQXR0cjogeyB2YWx1ZTogZnVuY3Rpb24oYXR0ciwgb2xkdmFsKSB7XG4gICAgLy8gTWFuYWdlIGlkLT5lbGVtZW50IG1hcHBpbmcgZm9yIGdldEVsZW1lbnRzQnlJZCgpXG4gICAgLy8gWFhYOiB0aGlzIHNwZWNpYWwgY2FzZSBpZCBoYW5kbGluZyBzaG91bGQgbm90IGdvIGhlcmUsXG4gICAgLy8gYnV0IGluIHRoZSBhdHRyaWJ1dGUgZGVjbGFyYXRpb24gZm9yIHRoZSBpZCBhdHRyaWJ1dGVcbiAgICAvKlxuICAgIGlmIChhdHRyLmxvY2FsTmFtZSA9PT0gJ2lkJyAmJiBhdHRyLm5hbWVzcGFjZVVSSSA9PT0gbnVsbCkge1xuICAgICAgaWYgKG9sZHZhbCkgZGVsSWQob2xkdmFsLCBhdHRyLm93bmVyRWxlbWVudCk7XG4gICAgICBhZGRJZChhdHRyLnZhbHVlLCBhdHRyLm93bmVyRWxlbWVudCk7XG4gICAgfVxuICAgICovXG4gICAgaWYgKHRoaXMubXV0YXRpb25IYW5kbGVyKSB7XG4gICAgICB0aGlzLm11dGF0aW9uSGFuZGxlcih7XG4gICAgICAgIHR5cGU6IE1VVEFURS5BVFRSLFxuICAgICAgICB0YXJnZXQ6IGF0dHIub3duZXJFbGVtZW50LFxuICAgICAgICBhdHRyOiBhdHRyXG4gICAgICB9KTtcbiAgICB9XG4gIH19LFxuXG4gIC8vIFVzZWQgYnkgcmVtb3ZlQXR0cmlidXRlIGFuZCByZW1vdmVBdHRyaWJ1dGVOUyBmb3IgYXR0cmlidXRlcy5cbiAgbXV0YXRlUmVtb3ZlQXR0cjogeyB2YWx1ZTogZnVuY3Rpb24oYXR0cikge1xuLypcbiogVGhpcyBpcyBub3cgaGFuZGxlZCBpbiBBdHRyaWJ1dGVzLmpzXG4gICAgLy8gTWFuYWdlIGlkIHRvIGVsZW1lbnQgbWFwcGluZ1xuICAgIGlmIChhdHRyLmxvY2FsTmFtZSA9PT0gJ2lkJyAmJiBhdHRyLm5hbWVzcGFjZVVSSSA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5kZWxJZChhdHRyLnZhbHVlLCBhdHRyLm93bmVyRWxlbWVudCk7XG4gICAgfVxuKi9cbiAgICBpZiAodGhpcy5tdXRhdGlvbkhhbmRsZXIpIHtcbiAgICAgIHRoaXMubXV0YXRpb25IYW5kbGVyKHtcbiAgICAgICAgdHlwZTogTVVUQVRFLlJFTU9WRV9BVFRSLFxuICAgICAgICB0YXJnZXQ6IGF0dHIub3duZXJFbGVtZW50LFxuICAgICAgICBhdHRyOiBhdHRyXG4gICAgICB9KTtcbiAgICB9XG4gIH19LFxuXG4gIC8vIENhbGxlZCBieSBOb2RlLnJlbW92ZUNoaWxkLCBldGMuIHRvIHJlbW92ZSBhIHJvb3RlZCBlbGVtZW50IGZyb21cbiAgLy8gdGhlIHRyZWUuIE9ubHkgbmVlZHMgdG8gZ2VuZXJhdGUgYSBzaW5nbGUgbXV0YXRpb24gZXZlbnQgd2hlbiBhXG4gIC8vIG5vZGUgaXMgcmVtb3ZlZCwgYnV0IG11c3QgcmVjdXJzaXZlbHkgbWFyayBhbGwgZGVzY2VuZGFudHMgYXMgbm90XG4gIC8vIHJvb3RlZC5cbiAgbXV0YXRlUmVtb3ZlOiB7IHZhbHVlOiBmdW5jdGlvbihub2RlKSB7XG4gICAgLy8gU2VuZCBhIHNpbmdsZSBtdXRhdGlvbiBldmVudFxuICAgIGlmICh0aGlzLm11dGF0aW9uSGFuZGxlcikge1xuICAgICAgdGhpcy5tdXRhdGlvbkhhbmRsZXIoe1xuICAgICAgICB0eXBlOiBNVVRBVEUuUkVNT1ZFLFxuICAgICAgICB0YXJnZXQ6IG5vZGUucGFyZW50Tm9kZSxcbiAgICAgICAgbm9kZTogbm9kZVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gTWFyayB0aGlzIGFuZCBhbGwgZGVzY2VuZGFudHMgYXMgbm90IHJvb3RlZFxuICAgIHJlY3Vyc2l2ZWx5VXByb290KG5vZGUpO1xuICB9fSxcblxuICAvLyBDYWxsZWQgd2hlbiBhIG5ldyBlbGVtZW50IGJlY29tZXMgcm9vdGVkLiAgSXQgbXVzdCByZWN1cnNpdmVseVxuICAvLyBnZW5lcmF0ZSBtdXRhdGlvbiBldmVudHMgZm9yIGVhY2ggb2YgdGhlIGNoaWxkcmVuLCBhbmQgbWFyayB0aGVtIGFsbFxuICAvLyBhcyByb290ZWQuXG4gIG11dGF0ZUluc2VydDogeyB2YWx1ZTogZnVuY3Rpb24obm9kZSkge1xuICAgIC8vIE1hcmsgbm9kZSBhbmQgaXRzIGRlc2NlbmRhbnRzIGFzIHJvb3RlZFxuICAgIHJlY3Vyc2l2ZWx5Um9vdChub2RlKTtcblxuICAgIC8vIFNlbmQgYSBzaW5nbGUgbXV0YXRpb24gZXZlbnRcbiAgICBpZiAodGhpcy5tdXRhdGlvbkhhbmRsZXIpIHtcbiAgICAgIHRoaXMubXV0YXRpb25IYW5kbGVyKHtcbiAgICAgICAgdHlwZTogTVVUQVRFLklOU0VSVCxcbiAgICAgICAgdGFyZ2V0OiBub2RlLnBhcmVudE5vZGUsXG4gICAgICAgIG5vZGU6IG5vZGVcbiAgICAgIH0pO1xuICAgIH1cbiAgfX0sXG5cbiAgLy8gQ2FsbGVkIHdoZW4gYSByb290ZWQgZWxlbWVudCBpcyBtb3ZlZCB3aXRoaW4gdGhlIGRvY3VtZW50XG4gIG11dGF0ZU1vdmU6IHsgdmFsdWU6IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICBpZiAodGhpcy5tdXRhdGlvbkhhbmRsZXIpIHtcbiAgICAgIHRoaXMubXV0YXRpb25IYW5kbGVyKHtcbiAgICAgICAgdHlwZTogTVVUQVRFLk1PVkUsXG4gICAgICAgIHRhcmdldDogbm9kZVxuICAgICAgfSk7XG4gICAgfVxuICB9fSxcblxuXG4gIC8vIEFkZCBhIG1hcHBpbmcgZnJvbSAgaWQgdG8gbiBmb3Igbi5vd25lckRvY3VtZW50XG4gIGFkZElkOiB7IHZhbHVlOiBmdW5jdGlvbiBhZGRJZChpZCwgbikge1xuICAgIHZhciB2YWwgPSB0aGlzLmJ5SWRbaWRdO1xuICAgIGlmICghdmFsKSB7XG4gICAgICB0aGlzLmJ5SWRbaWRdID0gbjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAvLyBUT0RPOiBBZGQgYSB3YXkgdG8gb3B0LW91dCBjb25zb2xlIHdhcm5pbmdzXG4gICAgICAvL2NvbnNvbGUud2FybignRHVwbGljYXRlIGVsZW1lbnQgaWQgJyArIGlkKTtcbiAgICAgIGlmICghKHZhbCBpbnN0YW5jZW9mIE11bHRpSWQpKSB7XG4gICAgICAgIHZhbCA9IG5ldyBNdWx0aUlkKHZhbCk7XG4gICAgICAgIHRoaXMuYnlJZFtpZF0gPSB2YWw7XG4gICAgICB9XG4gICAgICB2YWwuYWRkKG4pO1xuICAgIH1cbiAgfX0sXG5cbiAgLy8gRGVsZXRlIHRoZSBtYXBwaW5nIGZyb20gaWQgdG8gbiBmb3Igbi5vd25lckRvY3VtZW50XG4gIGRlbElkOiB7IHZhbHVlOiBmdW5jdGlvbiBkZWxJZChpZCwgbikge1xuICAgIHZhciB2YWwgPSB0aGlzLmJ5SWRbaWRdO1xuICAgIHV0aWxzLmFzc2VydCh2YWwpO1xuXG4gICAgaWYgKHZhbCBpbnN0YW5jZW9mIE11bHRpSWQpIHtcbiAgICAgIHZhbC5kZWwobik7XG4gICAgICBpZiAodmFsLmxlbmd0aCA9PT0gMSkgeyAvLyBjb252ZXJ0IGJhY2sgdG8gYSBzaW5nbGUgbm9kZVxuICAgICAgICB0aGlzLmJ5SWRbaWRdID0gdmFsLmRvd25ncmFkZSgpO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRoaXMuYnlJZFtpZF0gPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9fSxcblxuICBfcmVzb2x2ZTogeyB2YWx1ZTogZnVuY3Rpb24oaHJlZikge1xuICAgIC8vWFhYOiBDYWNoZSB0aGUgVVJMXG4gICAgcmV0dXJuIG5ldyBVUkwodGhpcy5fZG9jdW1lbnRCYXNlVVJMKS5yZXNvbHZlKGhyZWYpO1xuICB9fSxcblxuICBfZG9jdW1lbnRCYXNlVVJMOiB7IGdldDogZnVuY3Rpb24oKSB7XG4gICAgLy8gWFhYOiBUaGlzIGlzIG5vdCBpbXBsZW1lbnRlZCBjb3JyZWN0bHkgeWV0XG4gICAgdmFyIHVybCA9IHRoaXMuX2FkZHJlc3M7XG4gICAgaWYgKHVybCA9PT0gJ2Fib3V0OmJsYW5rJykgdXJsID0gJy8nO1xuXG4gICAgdmFyIGJhc2UgPSB0aGlzLnF1ZXJ5U2VsZWN0b3IoJ2Jhc2VbaHJlZl0nKTtcbiAgICBpZiAoYmFzZSkge1xuICAgICAgcmV0dXJuIG5ldyBVUkwodXJsKS5yZXNvbHZlKGJhc2UuZ2V0QXR0cmlidXRlKCdocmVmJykpO1xuICAgIH1cbiAgICByZXR1cm4gdXJsO1xuXG4gICAgLy8gVGhlIGRvY3VtZW50IGJhc2UgVVJMIG9mIGEgRG9jdW1lbnQgb2JqZWN0IGlzIHRoZVxuICAgIC8vIGFic29sdXRlIFVSTCBvYnRhaW5lZCBieSBydW5uaW5nIHRoZXNlIHN1YnN0ZXBzOlxuXG4gICAgLy8gICAgIExldCBmYWxsYmFjayBiYXNlIHVybCBiZSB0aGUgZG9jdW1lbnQncyBhZGRyZXNzLlxuXG4gICAgLy8gICAgIElmIGZhbGxiYWNrIGJhc2UgdXJsIGlzIGFib3V0OmJsYW5rLCBhbmQgdGhlXG4gICAgLy8gICAgIERvY3VtZW50J3MgYnJvd3NpbmcgY29udGV4dCBoYXMgYSBjcmVhdG9yIGJyb3dzaW5nXG4gICAgLy8gICAgIGNvbnRleHQsIHRoZW4gbGV0IGZhbGxiYWNrIGJhc2UgdXJsIGJlIHRoZSBkb2N1bWVudFxuICAgIC8vICAgICBiYXNlIFVSTCBvZiB0aGUgY3JlYXRvciBEb2N1bWVudCBpbnN0ZWFkLlxuXG4gICAgLy8gICAgIElmIHRoZSBEb2N1bWVudCBpcyBhbiBpZnJhbWUgc3JjZG9jIGRvY3VtZW50LCB0aGVuXG4gICAgLy8gICAgIGxldCBmYWxsYmFjayBiYXNlIHVybCBiZSB0aGUgZG9jdW1lbnQgYmFzZSBVUkwgb2ZcbiAgICAvLyAgICAgdGhlIERvY3VtZW50J3MgYnJvd3NpbmcgY29udGV4dCdzIGJyb3dzaW5nIGNvbnRleHRcbiAgICAvLyAgICAgY29udGFpbmVyJ3MgRG9jdW1lbnQgaW5zdGVhZC5cblxuICAgIC8vICAgICBJZiB0aGVyZSBpcyBubyBiYXNlIGVsZW1lbnQgdGhhdCBoYXMgYW4gaHJlZlxuICAgIC8vICAgICBhdHRyaWJ1dGUsIHRoZW4gdGhlIGRvY3VtZW50IGJhc2UgVVJMIGlzIGZhbGxiYWNrXG4gICAgLy8gICAgIGJhc2UgdXJsOyBhYm9ydCB0aGVzZSBzdGVwcy4gT3RoZXJ3aXNlLCBsZXQgdXJsIGJlXG4gICAgLy8gICAgIHRoZSB2YWx1ZSBvZiB0aGUgaHJlZiBhdHRyaWJ1dGUgb2YgdGhlIGZpcnN0IHN1Y2hcbiAgICAvLyAgICAgZWxlbWVudC5cblxuICAgIC8vICAgICBSZXNvbHZlIHVybCByZWxhdGl2ZSB0byBmYWxsYmFjayBiYXNlIHVybCAodGh1cyxcbiAgICAvLyAgICAgdGhlIGJhc2UgaHJlZiBhdHRyaWJ1dGUgaXNuJ3QgYWZmZWN0ZWQgYnkgeG1sOmJhc2VcbiAgICAvLyAgICAgYXR0cmlidXRlcykuXG5cbiAgICAvLyAgICAgVGhlIGRvY3VtZW50IGJhc2UgVVJMIGlzIHRoZSByZXN1bHQgb2YgdGhlIHByZXZpb3VzXG4gICAgLy8gICAgIHN0ZXAgaWYgaXQgd2FzIHN1Y2Nlc3NmdWw7IG90aGVyd2lzZSBpdCBpcyBmYWxsYmFja1xuICAgIC8vICAgICBiYXNlIHVybC5cbiAgfX0sXG5cbiAgX3RlbXBsYXRlRG9jOiB7IGdldDogZnVuY3Rpb24oKSB7XG4gICAgaWYgKCF0aGlzLl90ZW1wbGF0ZURvY0NhY2hlKSB7XG4gICAgICAvLyBcImFzc29jaWF0ZWQgaW5lcnQgdGVtcGxhdGUgZG9jdW1lbnRcIlxuICAgICAgdmFyIG5ld0RvYyA9IG5ldyBEb2N1bWVudCh0aGlzLmlzSFRNTCwgdGhpcy5fYWRkcmVzcyk7XG4gICAgICB0aGlzLl90ZW1wbGF0ZURvY0NhY2hlID0gbmV3RG9jLl90ZW1wbGF0ZURvY0NhY2hlID0gbmV3RG9jO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fdGVtcGxhdGVEb2NDYWNoZTtcbiAgfX0sXG5cbiAgcXVlcnlTZWxlY3RvcjogeyB2YWx1ZTogZnVuY3Rpb24oc2VsZWN0b3IpIHtcbiAgICByZXR1cm4gc2VsZWN0KHNlbGVjdG9yLCB0aGlzKVswXTtcbiAgfX0sXG5cbiAgcXVlcnlTZWxlY3RvckFsbDogeyB2YWx1ZTogZnVuY3Rpb24oc2VsZWN0b3IpIHtcbiAgICB2YXIgbm9kZXMgPSBzZWxlY3Qoc2VsZWN0b3IsIHRoaXMpO1xuICAgIHJldHVybiBub2Rlcy5pdGVtID8gbm9kZXMgOiBuZXcgTm9kZUxpc3Qobm9kZXMpO1xuICB9fVxuXG59KTtcblxuXG52YXIgZXZlbnRIYW5kbGVyVHlwZXMgPSBbXG4gICdhYm9ydCcsICdjYW5wbGF5JywgJ2NhbnBsYXl0aHJvdWdoJywgJ2NoYW5nZScsICdjbGljaycsICdjb250ZXh0bWVudScsXG4gICdjdWVjaGFuZ2UnLCAnZGJsY2xpY2snLCAnZHJhZycsICdkcmFnZW5kJywgJ2RyYWdlbnRlcicsICdkcmFnbGVhdmUnLFxuICAnZHJhZ292ZXInLCAnZHJhZ3N0YXJ0JywgJ2Ryb3AnLCAnZHVyYXRpb25jaGFuZ2UnLCAnZW1wdGllZCcsICdlbmRlZCcsXG4gICdpbnB1dCcsICdpbnZhbGlkJywgJ2tleWRvd24nLCAna2V5cHJlc3MnLCAna2V5dXAnLCAnbG9hZGVkZGF0YScsXG4gICdsb2FkZWRtZXRhZGF0YScsICdsb2Fkc3RhcnQnLCAnbW91c2Vkb3duJywgJ21vdXNlbW92ZScsICdtb3VzZW91dCcsXG4gICdtb3VzZW92ZXInLCAnbW91c2V1cCcsICdtb3VzZXdoZWVsJywgJ3BhdXNlJywgJ3BsYXknLCAncGxheWluZycsXG4gICdwcm9ncmVzcycsICdyYXRlY2hhbmdlJywgJ3JlYWR5c3RhdGVjaGFuZ2UnLCAncmVzZXQnLCAnc2Vla2VkJyxcbiAgJ3NlZWtpbmcnLCAnc2VsZWN0JywgJ3Nob3cnLCAnc3RhbGxlZCcsICdzdWJtaXQnLCAnc3VzcGVuZCcsXG4gICd0aW1ldXBkYXRlJywgJ3ZvbHVtZWNoYW5nZScsICd3YWl0aW5nJyxcblxuICAnYmx1cicsICdlcnJvcicsICdmb2N1cycsICdsb2FkJywgJ3Njcm9sbCdcbl07XG5cbi8vIEFkZCBldmVudCBoYW5kbGVyIGlkbCBhdHRyaWJ1dGUgZ2V0dGVycyBhbmQgc2V0dGVycyB0byBEb2N1bWVudFxuZXZlbnRIYW5kbGVyVHlwZXMuZm9yRWFjaChmdW5jdGlvbih0eXBlKSB7XG4gIC8vIERlZmluZSB0aGUgZXZlbnQgaGFuZGxlciByZWdpc3RyYXRpb24gSURMIGF0dHJpYnV0ZSBmb3IgdGhpcyB0eXBlXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEb2N1bWVudC5wcm90b3R5cGUsICdvbicgKyB0eXBlLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9nZXRFdmVudEhhbmRsZXIodHlwZSk7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uKHYpIHtcbiAgICAgIHRoaXMuX3NldEV2ZW50SGFuZGxlcih0eXBlLCB2KTtcbiAgICB9XG4gIH0pO1xufSk7XG5cbmZ1bmN0aW9uIG5hbWVkSFRNTENoaWxkKHBhcmVudCwgbmFtZSkge1xuICBpZiAocGFyZW50ICYmIHBhcmVudC5pc0hUTUwpIHtcbiAgICB2YXIga2lkcyA9IHBhcmVudC5jaGlsZE5vZGVzO1xuICAgIGZvcih2YXIgaSA9IDAsIG4gPSBraWRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgaWYgKGtpZHNbaV0ubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFICYmXG4gICAgICAgIGtpZHNbaV0ubG9jYWxOYW1lID09PSBuYW1lICYmXG4gICAgICAgIGtpZHNbaV0ubmFtZXNwYWNlVVJJID09PSBOQU1FU1BBQ0UuSFRNTCkge1xuICAgICAgICByZXR1cm4ga2lkc1tpXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIHJvb3Qobikge1xuICBuLl9uaWQgPSBuLm93bmVyRG9jdW1lbnQuX25leHRuaWQrKztcbiAgbi5vd25lckRvY3VtZW50Ll9ub2Rlc1tuLl9uaWRdID0gbjtcbiAgLy8gTWFuYWdlIGlkIHRvIGVsZW1lbnQgbWFwcGluZ1xuICBpZiAobi5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUpIHtcbiAgICB2YXIgaWQgPSBuLmdldEF0dHJpYnV0ZSgnaWQnKTtcbiAgICBpZiAoaWQpIG4ub3duZXJEb2N1bWVudC5hZGRJZChpZCwgbik7XG5cbiAgICAvLyBTY3JpcHQgZWxlbWVudHMgbmVlZCB0byBrbm93IHdoZW4gdGhleSdyZSBpbnNlcnRlZFxuICAgIC8vIGludG8gdGhlIGRvY3VtZW50XG4gICAgaWYgKG4uX3Jvb3Rob29rKSBuLl9yb290aG9vaygpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVwcm9vdChuKSB7XG4gIC8vIE1hbmFnZSBpZCB0byBlbGVtZW50IG1hcHBpbmdcbiAgaWYgKG4ubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XG4gICAgdmFyIGlkID0gbi5nZXRBdHRyaWJ1dGUoJ2lkJyk7XG4gICAgaWYgKGlkKSBuLm93bmVyRG9jdW1lbnQuZGVsSWQoaWQsIG4pO1xuICB9XG4gIG4ub3duZXJEb2N1bWVudC5fbm9kZXNbbi5fbmlkXSA9IHVuZGVmaW5lZDtcbiAgbi5fbmlkID0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiByZWN1cnNpdmVseVJvb3Qobm9kZSkge1xuICByb290KG5vZGUpO1xuICAvLyBYWFg6XG4gIC8vIGFjY2Vzc2luZyBjaGlsZE5vZGVzIG9uIGEgbGVhZiBub2RlIGNyZWF0ZXMgYSBuZXcgYXJyYXkgdGhlXG4gIC8vIGZpcnN0IHRpbWUsIHNvIGJlIGNhcmVmdWwgdG8gd3JpdGUgdGhpcyBsb29wIHNvIHRoYXQgaXRcbiAgLy8gZG9lc24ndCBkbyB0aGF0LiBub2RlIGlzIHBvbHltb3JwaGljLCBzbyBtYXliZSB0aGlzIGlzIGhhcmQgdG9cbiAgLy8gb3B0aW1pemU/ICBUcnkgc3dpdGNoaW5nIG9uIG5vZGVUeXBlP1xuLypcbiAgaWYgKG5vZGUuaGFzQ2hpbGROb2RlcygpKSB7XG4gICAgdmFyIGtpZHMgPSBub2RlLmNoaWxkTm9kZXM7XG4gICAgZm9yKHZhciBpID0gMCwgbiA9IGtpZHMubGVuZ3RoOyAgaSA8IG47IGkrKylcbiAgICAgIHJlY3Vyc2l2ZWx5Um9vdChraWRzW2ldKTtcbiAgfVxuKi9cbiAgaWYgKG5vZGUubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XG4gICAgdmFyIGtpZHMgPSBub2RlLmNoaWxkTm9kZXM7XG4gICAgZm9yKHZhciBpID0gMCwgbiA9IGtpZHMubGVuZ3RoOyBpIDwgbjsgaSsrKVxuICAgICAgcmVjdXJzaXZlbHlSb290KGtpZHNbaV0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlY3Vyc2l2ZWx5VXByb290KG5vZGUpIHtcbiAgdXByb290KG5vZGUpO1xuICBmb3IodmFyIGkgPSAwLCBuID0gbm9kZS5jaGlsZE5vZGVzLmxlbmd0aDsgaSA8IG47IGkrKylcbiAgICByZWN1cnNpdmVseVVwcm9vdChub2RlLmNoaWxkTm9kZXNbaV0pO1xufVxuXG5mdW5jdGlvbiByZWN1cnNpdmVseVNldE93bmVyKG5vZGUsIG93bmVyKSB7XG4gIG5vZGUub3duZXJEb2N1bWVudCA9IG93bmVyO1xuICBub2RlLl9sYXN0TW9kVGltZSA9IHVuZGVmaW5lZDsgLy8gbW9kIHRpbWVzIGFyZSBkb2N1bWVudC1iYXNlZFxuICB2YXIga2lkcyA9IG5vZGUuY2hpbGROb2RlcztcbiAgZm9yKHZhciBpID0gMCwgbiA9IGtpZHMubGVuZ3RoOyBpIDwgbjsgaSsrKVxuICAgIHJlY3Vyc2l2ZWx5U2V0T3duZXIoa2lkc1tpXSwgb3duZXIpO1xufVxuXG4vLyBBIGNsYXNzIGZvciBzdG9yaW5nIG11bHRpcGxlIG5vZGVzIHdpdGggdGhlIHNhbWUgSURcbmZ1bmN0aW9uIE11bHRpSWQobm9kZSkge1xuICB0aGlzLm5vZGVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgdGhpcy5ub2Rlc1tub2RlLl9uaWRdID0gbm9kZTtcbiAgdGhpcy5sZW5ndGggPSAxO1xuICB0aGlzLmZpcnN0Tm9kZSA9IHVuZGVmaW5lZDtcbn1cblxuLy8gQWRkIGEgbm9kZSB0byB0aGUgbGlzdCwgd2l0aCBPKDEpIHRpbWVcbk11bHRpSWQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgaWYgKCF0aGlzLm5vZGVzW25vZGUuX25pZF0pIHtcbiAgICB0aGlzLm5vZGVzW25vZGUuX25pZF0gPSBub2RlO1xuICAgIHRoaXMubGVuZ3RoKys7XG4gICAgdGhpcy5maXJzdE5vZGUgPSB1bmRlZmluZWQ7XG4gIH1cbn07XG5cbi8vIFJlbW92ZSBhIG5vZGUgZnJvbSB0aGUgbGlzdCwgd2l0aCBPKDEpIHRpbWVcbk11bHRpSWQucHJvdG90eXBlLmRlbCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgaWYgKHRoaXMubm9kZXNbbm9kZS5fbmlkXSkge1xuICAgIGRlbGV0ZSB0aGlzLm5vZGVzW25vZGUuX25pZF07XG4gICAgdGhpcy5sZW5ndGgtLTtcbiAgICB0aGlzLmZpcnN0Tm9kZSA9IHVuZGVmaW5lZDtcbiAgfVxufTtcblxuLy8gR2V0IHRoZSBmaXJzdCBub2RlIGZyb20gdGhlIGxpc3QsIGluIHRoZSBkb2N1bWVudCBvcmRlclxuLy8gVGFrZXMgTyhOKSB0aW1lIGluIHRoZSBzaXplIG9mIHRoZSBsaXN0LCB3aXRoIGEgY2FjaGUgdGhhdCBpcyBpbnZhbGlkYXRlZFxuLy8gd2hlbiB0aGUgbGlzdCBpcyBtb2RpZmllZC5cbk11bHRpSWQucHJvdG90eXBlLmdldEZpcnN0ID0gZnVuY3Rpb24oKSB7XG4gIC8qIGpzaGludCBiaXR3aXNlOiBmYWxzZSAqL1xuICBpZiAoIXRoaXMuZmlyc3ROb2RlKSB7XG4gICAgdmFyIG5pZDtcbiAgICBmb3IgKG5pZCBpbiB0aGlzLm5vZGVzKSB7XG4gICAgICBpZiAodGhpcy5maXJzdE5vZGUgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICB0aGlzLmZpcnN0Tm9kZS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbih0aGlzLm5vZGVzW25pZF0pICYgTm9kZS5ET0NVTUVOVF9QT1NJVElPTl9QUkVDRURJTkcpIHtcbiAgICAgICAgdGhpcy5maXJzdE5vZGUgPSB0aGlzLm5vZGVzW25pZF07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB0aGlzLmZpcnN0Tm9kZTtcbn07XG5cbi8vIElmIHRoZXJlIGlzIG9ubHkgb25lIG5vZGUgbGVmdCwgcmV0dXJuIGl0LiBPdGhlcndpc2UgcmV0dXJuIFwidGhpc1wiLlxuTXVsdGlJZC5wcm90b3R5cGUuZG93bmdyYWRlID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLmxlbmd0aCA9PT0gMSkge1xuICAgIHZhciBuaWQ7XG4gICAgZm9yIChuaWQgaW4gdGhpcy5ub2Rlcykge1xuICAgICAgcmV0dXJuIHRoaXMubm9kZXNbbmlkXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZG9taW5vL2xpYi9Eb2N1bWVudC5qc1xuLy8gbW9kdWxlIGlkID0gMjBcbi8vIG1vZHVsZSBjaHVua3MgPSA0IiwiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBUaGlzIGdyYW1tYXIgaXMgZnJvbSB0aGUgWE1MIGFuZCBYTUwgTmFtZXNwYWNlIHNwZWNzLiBJdCBzcGVjaWZpZXMgd2hldGhlclxuLy8gYSBzdHJpbmcgKHN1Y2ggYXMgYW4gZWxlbWVudCBvciBhdHRyaWJ1dGUgbmFtZSkgaXMgYSB2YWxpZCBOYW1lIG9yIFFOYW1lLlxuLy9cbi8vIE5hbWUgICAgICAgICAgIDo6PSBOYW1lU3RhcnRDaGFyIChOYW1lQ2hhcikqXG4vLyBOYW1lU3RhcnRDaGFyICA6Oj0gXCI6XCIgfCBbQS1aXSB8IFwiX1wiIHwgW2Etel0gfFxuLy8gICAgICAgICAgICAgICAgICAgIFsjeEMwLSN4RDZdIHwgWyN4RDgtI3hGNl0gfCBbI3hGOC0jeDJGRl0gfFxuLy8gICAgICAgICAgICAgICAgICAgIFsjeDM3MC0jeDM3RF0gfCBbI3gzN0YtI3gxRkZGXSB8XG4vLyAgICAgICAgICAgICAgICAgICAgWyN4MjAwQy0jeDIwMERdIHwgWyN4MjA3MC0jeDIxOEZdIHxcbi8vICAgICAgICAgICAgICAgICAgICBbI3gyQzAwLSN4MkZFRl0gfCBbI3gzMDAxLSN4RDdGRl0gfFxuLy8gICAgICAgICAgICAgICAgICAgIFsjeEY5MDAtI3hGRENGXSB8IFsjeEZERjAtI3hGRkZEXSB8XG4vLyAgICAgICAgICAgICAgICAgICAgWyN4MTAwMDAtI3hFRkZGRl1cbi8vXG4vLyBOYW1lQ2hhciAgICAgICA6Oj0gTmFtZVN0YXJ0Q2hhciB8IFwiLVwiIHwgXCIuXCIgfCBbMC05XSB8XG4vLyAgICAgICAgICAgICAgICAgICAgI3hCNyB8IFsjeDAzMDAtI3gwMzZGXSB8IFsjeDIwM0YtI3gyMDQwXVxuLy9cbi8vIFFOYW1lICAgICAgICAgIDo6PSBQcmVmaXhlZE5hbWV8IFVucHJlZml4ZWROYW1lXG4vLyBQcmVmaXhlZE5hbWUgICA6Oj0gUHJlZml4ICc6JyBMb2NhbFBhcnRcbi8vIFVucHJlZml4ZWROYW1lIDo6PSBMb2NhbFBhcnRcbi8vIFByZWZpeCAgICAgICAgIDo6PSBOQ05hbWVcbi8vIExvY2FsUGFydCAgICAgIDo6PSBOQ05hbWVcbi8vIE5DTmFtZSAgICAgICAgIDo6PSBOYW1lIC0gKENoYXIqICc6JyBDaGFyKilcbi8vICAgICAgICAgICAgICAgICAgICAjIEFuIFhNTCBOYW1lLCBtaW51cyB0aGUgXCI6XCJcbi8vXG5cbmV4cG9ydHMuaXNWYWxpZE5hbWUgPSBpc1ZhbGlkTmFtZTtcbmV4cG9ydHMuaXNWYWxpZFFOYW1lID0gaXNWYWxpZFFOYW1lO1xuXG4vLyBNb3N0IG5hbWVzIHdpbGwgYmUgQVNDSUkgb25seS4gVHJ5IG1hdGNoaW5nIGFnYWluc3Qgc2ltcGxlIHJlZ2V4cHMgZmlyc3RcbnZhciBzaW1wbGVuYW1lID0gL15bXzpBLVphLXpdWy0uOlxcd10rJC87XG52YXIgc2ltcGxlcW5hbWUgPSAvXihbX0EtWmEtel1bLS5cXHddK3xbX0EtWmEtel1bLS5cXHddKzpbX0EtWmEtel1bLS5cXHddKykkLztcblxuLy8gSWYgdGhlIHJlZ3VsYXIgZXhwcmVzc2lvbnMgYWJvdmUgZmFpbCwgdHJ5IG1vcmUgY29tcGxleCBvbmVzIHRoYXQgd29ya1xuLy8gZm9yIGFueSBpZGVudGlmaWVycyB1c2luZyBjb2RlcG9pbnRzIGZyb20gdGhlIFVuaWNvZGUgQk1QXG52YXIgbmNuYW1lc3RhcnRjaGFycyA9IFwiX0EtWmEtelxcdTAwQzAtXFx1MDBENlxcdTAwRDgtXFx1MDBGNlxcdTAwRjgtXFx1MDJmZlxcdTAzNzAtXFx1MDM3RFxcdTAzN0YtXFx1MUZGRlxcdTIwMEMtXFx1MjAwRFxcdTIwNzAtXFx1MjE4RlxcdTJDMDAtXFx1MkZFRlxcdTMwMDEtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZGRFwiO1xudmFyIG5jbmFtZWNoYXJzID0gXCItLl9BLVphLXowLTlcXHUwMEI3XFx1MDBDMC1cXHUwMEQ2XFx1MDBEOC1cXHUwMEY2XFx1MDBGOC1cXHUwMmZmXFx1MDMwMC1cXHUwMzdEXFx1MDM3Ri1cXHUxRkZGXFx1MjAwQ1xcdTIwMERcXHUyMDNmXFx1MjA0MFxcdTIwNzAtXFx1MjE4RlxcdTJDMDAtXFx1MkZFRlxcdTMwMDEtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZGRFwiO1xuXG52YXIgbmNuYW1lID0gXCJbXCIgKyBuY25hbWVzdGFydGNoYXJzICsgXCJdW1wiICsgbmNuYW1lY2hhcnMgKyBcIl0qXCI7XG52YXIgbmFtZXN0YXJ0Y2hhcnMgPSBuY25hbWVzdGFydGNoYXJzICsgXCI6XCI7XG52YXIgbmFtZWNoYXJzID0gbmNuYW1lY2hhcnMgKyBcIjpcIjtcbnZhciBuYW1lID0gbmV3IFJlZ0V4cChcIl5bXCIgKyBuYW1lc3RhcnRjaGFycyArIFwiXVwiICsgXCJbXCIgKyBuYW1lY2hhcnMgKyBcIl0qJFwiKTtcbnZhciBxbmFtZSA9IG5ldyBSZWdFeHAoXCJeKFwiICsgbmNuYW1lICsgXCJ8XCIgKyBuY25hbWUgKyBcIjpcIiArIG5jbmFtZSArIFwiKSRcIik7XG5cbi8vIFhNTCBzYXlzIHRoYXQgdGhlc2UgY2hhcmFjdGVycyBhcmUgYWxzbyBsZWdhbDpcbi8vIFsjeDEwMDAwLSN4RUZGRkZdLiAgU28gaWYgdGhlIHBhdHRlcm5zIGFib3ZlIGZhaWwsIGFuZCB0aGVcbi8vIHRhcmdldCBzdHJpbmcgaW5jbHVkZXMgc3Vycm9nYXRlcywgdGhlbiB0cnkgdGhlIGZvbGxvd2luZ1xuLy8gcGF0dGVybnMgdGhhdCBhbGxvdyBzdXJyb2dhdGVzIGFuZCB0aGVuIHJ1biBhbiBleHRyYSB2YWxpZGF0aW9uXG4vLyBzdGVwIHRvIG1ha2Ugc3VyZSB0aGF0IHRoZSBzdXJyb2dhdGVzIGFyZSBpbiB2YWxpZCBwYWlycyBhbmQgaW5cbi8vIHRoZSByaWdodCByYW5nZS4gIE5vdGUgdGhhdCBzaW5jZSB0aGUgY2hhcmFjdGVycyBcXHVmMDAwMCB0byBcXHUxZjAwMDBcbi8vIGFyZSBub3QgYWxsb3dlZCwgaXQgbWVhbnMgdGhhdCB0aGUgaGlnaCBzdXJyb2dhdGUgY2FuIG9ubHkgZ28gdXAgdG9cbi8vIFxcdURCN2YgaW5zdGVhZCBvZiBcXHVEQkZGLlxudmFyIGhhc3N1cnJvZ2F0ZXMgPSAvW1xcdUQ4MDAtXFx1REI3RlxcdURDMDAtXFx1REZGRl0vO1xudmFyIHN1cnJvZ2F0ZWNoYXJzID0gL1tcXHVEODAwLVxcdURCN0ZcXHVEQzAwLVxcdURGRkZdL2c7XG52YXIgc3Vycm9nYXRlcGFpcnMgPSAvW1xcdUQ4MDAtXFx1REI3Rl1bXFx1REMwMC1cXHVERkZGXS9nO1xuXG4vLyBNb2RpZnkgdGhlIHZhcmlhYmxlcyBhYm92ZSB0byBhbGxvdyBzdXJyb2dhdGVzXG5uY25hbWVzdGFydGNoYXJzICs9IFwiXFx1RDgwMC1cXHVEQjdGXFx1REMwMC1cXHVERkZGXCI7XG5uY25hbWVjaGFycyArPSBcIlxcdUQ4MDAtXFx1REI3RlxcdURDMDAtXFx1REZGRlwiO1xubmNuYW1lID0gXCJbXCIgKyBuY25hbWVzdGFydGNoYXJzICsgXCJdW1wiICsgbmNuYW1lY2hhcnMgKyBcIl0qXCI7XG5uYW1lc3RhcnRjaGFycyA9IG5jbmFtZXN0YXJ0Y2hhcnMgKyBcIjpcIjtcbm5hbWVjaGFycyA9IG5jbmFtZWNoYXJzICsgXCI6XCI7XG5cbi8vIEJ1aWxkIGFub3RoZXIgc2V0IG9mIHJlZ2V4cHMgdGhhdCBpbmNsdWRlIHN1cnJvZ2F0ZXNcbnZhciBzdXJyb2dhdGVuYW1lID0gbmV3IFJlZ0V4cChcIl5bXCIgKyBuYW1lc3RhcnRjaGFycyArIFwiXVwiICsgXCJbXCIgKyBuYW1lY2hhcnMgKyBcIl0qJFwiKTtcbnZhciBzdXJyb2dhdGVxbmFtZSA9IG5ldyBSZWdFeHAoXCJeKFwiICsgbmNuYW1lICsgXCJ8XCIgKyBuY25hbWUgKyBcIjpcIiArIG5jbmFtZSArIFwiKSRcIik7XG5cbmZ1bmN0aW9uIGlzVmFsaWROYW1lKHMpIHtcbiAgaWYgKHNpbXBsZW5hbWUudGVzdChzKSkgcmV0dXJuIHRydWU7IC8vIFBsYWluIEFTQ0lJXG4gIGlmIChuYW1lLnRlc3QocykpIHJldHVybiB0cnVlOyAvLyBVbmljb2RlIEJNUFxuXG4gIC8vIE1heWJlIHRoZSB0ZXN0cyBhYm92ZSBmYWlsZWQgYmVjYXVzZSBzIGluY2x1ZGVzIHN1cnJvZ2F0ZSBwYWlyc1xuICAvLyBNb3N0IGxpa2VseSwgdGhvdWdoLCB0aGV5IGZhaWxlZCBmb3Igc29tZSBtb3JlIGJhc2ljIHN5bnRheCBwcm9ibGVtXG4gIGlmICghaGFzc3Vycm9nYXRlcy50ZXN0KHMpKSByZXR1cm4gZmFsc2U7XG5cbiAgLy8gSXMgdGhlIHN0cmluZyBhIHZhbGlkIG5hbWUgaWYgd2UgYWxsb3cgc3Vycm9nYXRlcz9cbiAgaWYgKCFzdXJyb2dhdGVuYW1lLnRlc3QocykpIHJldHVybiBmYWxzZTtcblxuICAvLyBGaW5hbGx5LCBhcmUgdGhlIHN1cnJvZ2F0ZXMgYWxsIGNvcnJlY3RseSBwYWlyZWQgdXA/XG4gIHZhciBjaGFycyA9IHMubWF0Y2goc3Vycm9nYXRlY2hhcnMpLCBwYWlycyA9IHMubWF0Y2goc3Vycm9nYXRlcGFpcnMpO1xuICByZXR1cm4gcGFpcnMgIT09IG51bGwgJiYgMipwYWlycy5sZW5ndGggPT09IGNoYXJzLmxlbmd0aDtcbn1cblxuZnVuY3Rpb24gaXNWYWxpZFFOYW1lKHMpIHtcbiAgaWYgKHNpbXBsZXFuYW1lLnRlc3QocykpIHJldHVybiB0cnVlOyAvLyBQbGFpbiBBU0NJSVxuICBpZiAocW5hbWUudGVzdChzKSkgcmV0dXJuIHRydWU7IC8vIFVuaWNvZGUgQk1QXG5cbiAgaWYgKCFoYXNzdXJyb2dhdGVzLnRlc3QocykpIHJldHVybiBmYWxzZTtcbiAgaWYgKCFzdXJyb2dhdGVxbmFtZS50ZXN0KHMpKSByZXR1cm4gZmFsc2U7XG4gIHZhciBjaGFycyA9IHMubWF0Y2goc3Vycm9nYXRlY2hhcnMpLCBwYWlycyA9IHMubWF0Y2goc3Vycm9nYXRlcGFpcnMpO1xuICByZXR1cm4gcGFpcnMgIT09IG51bGwgJiYgMipwYWlycy5sZW5ndGggPT09IGNoYXJzLmxlbmd0aDtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2RvbWluby9saWIveG1sbmFtZXMuanNcbi8vIG1vZHVsZSBpZCA9IDIxXG4vLyBtb2R1bGUgY2h1bmtzID0gNCIsIlwidXNlIHN0cmljdFwiO1xuLyoganNoaW50IGVxbnVsbDogdHJ1ZSAqL1xuLyoqXG4gKiBaZXN0IChodHRwczovL2dpdGh1Yi5jb20vY2hqai96ZXN0KVxuICogQSBjc3Mgc2VsZWN0b3IgZW5naW5lLlxuICogQ29weXJpZ2h0IChjKSAyMDExLTIwMTIsIENocmlzdG9waGVyIEplZmZyZXkuIChNSVQgTGljZW5zZWQpXG4gKi9cblxuLyoqXG4gKiBIZWxwZXJzXG4gKi9cblxudmFyIHdpbmRvdyA9IE9iamVjdC5jcmVhdGUobnVsbCwge1xuICBsb2NhdGlvbjogeyBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignd2luZG93LmxvY2F0aW9uIGlzIG5vdCBzdXBwb3J0ZWQuJyk7XG4gIH0gfVxufSk7XG5cbnZhciBjb21wYXJlRG9jdW1lbnRQb3NpdGlvbiA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgIHJldHVybiBhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKGIpO1xufTtcblxudmFyIG9yZGVyID0gZnVuY3Rpb24oYSwgYikge1xuICAvKiBqc2hpbnQgYml0d2lzZTogZmFsc2UgKi9cbiAgcmV0dXJuIGNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKGEsIGIpICYgMiA/IDEgOiAtMTtcbn07XG5cbnZhciBuZXh0ID0gZnVuY3Rpb24oZWwpIHtcbiAgd2hpbGUgKChlbCA9IGVsLm5leHRTaWJsaW5nKVxuICAgICAgICAgJiYgZWwubm9kZVR5cGUgIT09IDEpO1xuICByZXR1cm4gZWw7XG59O1xuXG52YXIgcHJldiA9IGZ1bmN0aW9uKGVsKSB7XG4gIHdoaWxlICgoZWwgPSBlbC5wcmV2aW91c1NpYmxpbmcpXG4gICAgICAgICAmJiBlbC5ub2RlVHlwZSAhPT0gMSk7XG4gIHJldHVybiBlbDtcbn07XG5cbnZhciBjaGlsZCA9IGZ1bmN0aW9uKGVsKSB7XG4gIC8qanNoaW50IC1XMDg0ICovXG4gIGlmIChlbCA9IGVsLmZpcnN0Q2hpbGQpIHtcbiAgICB3aGlsZSAoZWwubm9kZVR5cGUgIT09IDFcbiAgICAgICAgICAgJiYgKGVsID0gZWwubmV4dFNpYmxpbmcpKTtcbiAgfVxuICByZXR1cm4gZWw7XG59O1xuXG52YXIgbGFzdENoaWxkID0gZnVuY3Rpb24oZWwpIHtcbiAgLypqc2hpbnQgLVcwODQgKi9cbiAgaWYgKGVsID0gZWwubGFzdENoaWxkKSB7XG4gICAgd2hpbGUgKGVsLm5vZGVUeXBlICE9PSAxXG4gICAgICAgICAgICYmIChlbCA9IGVsLnByZXZpb3VzU2libGluZykpO1xuICB9XG4gIHJldHVybiBlbDtcbn07XG5cbnZhciB1bnF1b3RlID0gZnVuY3Rpb24oc3RyKSB7XG4gIGlmICghc3RyKSByZXR1cm4gc3RyO1xuICB2YXIgY2ggPSBzdHJbMF07XG4gIGlmIChjaCA9PT0gJ1wiJyB8fCBjaCA9PT0gJ1xcJycpIHtcbiAgICBpZiAoc3RyW3N0ci5sZW5ndGgtMV0gPT09IGNoKSB7XG4gICAgICBzdHIgPSBzdHIuc2xpY2UoMSwgLTEpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBiYWQgc3RyaW5nLlxuICAgICAgc3RyID0gc3RyLnNsaWNlKDEpO1xuICAgIH1cbiAgICByZXR1cm4gc3RyLnJlcGxhY2UocnVsZXMuc3RyX2VzY2FwZSwgZnVuY3Rpb24ocykge1xuICAgICAgdmFyIG0gPSAvXlxcXFwoPzooWzAtOUEtRmEtZl0rKXwoW1xcclxcblxcZl0rKSkvLmV4ZWMocyk7XG4gICAgICBpZiAoIW0pIHsgcmV0dXJuIHMuc2xpY2UoMSk7IH1cbiAgICAgIGlmIChtWzJdKSB7IHJldHVybiAnJzsgLyogZXNjYXBlZCBuZXdsaW5lcyBhcmUgaWdub3JlZCBpbiBzdHJpbmdzLiAqLyB9XG4gICAgICB2YXIgY3AgPSBwYXJzZUludChtWzFdLCAxNik7XG4gICAgICByZXR1cm4gU3RyaW5nLmZyb21Db2RlUG9pbnQgPyBTdHJpbmcuZnJvbUNvZGVQb2ludChjcCkgOlxuICAgICAgICAvLyBOb3QgYWxsIEphdmFTY3JpcHQgaW1wbGVtZW50YXRpb25zIGhhdmUgU3RyaW5nLmZyb21Db2RlUG9pbnQgeWV0LlxuICAgICAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKGNwKTtcbiAgICB9KTtcbiAgfSBlbHNlIGlmIChydWxlcy5pZGVudC50ZXN0KHN0cikpIHtcbiAgICByZXR1cm4gZGVjb2RlaWQoc3RyKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBOVU1CRVIsIFBFUkNFTlRBR0UsIERJTUVOU0lPTiwgZXRjXG4gICAgcmV0dXJuIHN0cjtcbiAgfVxufTtcblxudmFyIGRlY29kZWlkID0gZnVuY3Rpb24oc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZShydWxlcy5lc2NhcGUsIGZ1bmN0aW9uKHMpIHtcbiAgICB2YXIgbSA9IC9eXFxcXChbMC05QS1GYS1mXSspLy5leGVjKHMpO1xuICAgIGlmICghbSkgeyByZXR1cm4gc1sxXTsgfVxuICAgIHZhciBjcCA9IHBhcnNlSW50KG1bMV0sIDE2KTtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21Db2RlUG9pbnQgPyBTdHJpbmcuZnJvbUNvZGVQb2ludChjcCkgOlxuICAgICAgLy8gTm90IGFsbCBKYXZhU2NyaXB0IGltcGxlbWVudGF0aW9ucyBoYXZlIFN0cmluZy5mcm9tQ29kZVBvaW50IHlldC5cbiAgICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoY3ApO1xuICB9KTtcbn07XG5cbnZhciBpbmRleE9mID0gKGZ1bmN0aW9uKCkge1xuICBpZiAoQXJyYXkucHJvdG90eXBlLmluZGV4T2YpIHtcbiAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmluZGV4T2Y7XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uKG9iaiwgaXRlbSkge1xuICAgIHZhciBpID0gdGhpcy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgaWYgKHRoaXNbaV0gPT09IGl0ZW0pIHJldHVybiBpO1xuICAgIH1cbiAgICByZXR1cm4gLTE7XG4gIH07XG59KSgpO1xuXG52YXIgbWFrZUluc2lkZSA9IGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJlZ2V4ID0gcnVsZXMuaW5zaWRlLnNvdXJjZVxuICAgIC5yZXBsYWNlKC88L2csIHN0YXJ0KVxuICAgIC5yZXBsYWNlKC8+L2csIGVuZCk7XG5cbiAgcmV0dXJuIG5ldyBSZWdFeHAocmVnZXgpO1xufTtcblxudmFyIHJlcGxhY2UgPSBmdW5jdGlvbihyZWdleCwgbmFtZSwgdmFsKSB7XG4gIHJlZ2V4ID0gcmVnZXguc291cmNlO1xuICByZWdleCA9IHJlZ2V4LnJlcGxhY2UobmFtZSwgdmFsLnNvdXJjZSB8fCB2YWwpO1xuICByZXR1cm4gbmV3IFJlZ0V4cChyZWdleCk7XG59O1xuXG52YXIgdHJ1bmNhdGVVcmwgPSBmdW5jdGlvbih1cmwsIG51bSkge1xuICByZXR1cm4gdXJsXG4gICAgLnJlcGxhY2UoL14oPzpcXHcrOlxcL1xcL3xcXC8rKS8sICcnKVxuICAgIC5yZXBsYWNlKC8oPzpcXC8rfFxcLyojLio/KSQvLCAnJylcbiAgICAuc3BsaXQoJy8nLCBudW0pXG4gICAgLmpvaW4oJy8nKTtcbn07XG5cbi8qKlxuICogSGFuZGxlIGBudGhgIFNlbGVjdG9yc1xuICovXG5cbnZhciBwYXJzZU50aCA9IGZ1bmN0aW9uKHBhcmFtXywgdGVzdCkge1xuICB2YXIgcGFyYW0gPSBwYXJhbV8ucmVwbGFjZSgvXFxzKy9nLCAnJylcbiAgICAsIGNhcDtcblxuICBpZiAocGFyYW0gPT09ICdldmVuJykge1xuICAgIHBhcmFtID0gJzJuKzAnO1xuICB9IGVsc2UgaWYgKHBhcmFtID09PSAnb2RkJykge1xuICAgIHBhcmFtID0gJzJuKzEnO1xuICB9IGVsc2UgaWYgKHBhcmFtLmluZGV4T2YoJ24nKSA9PT0gLTEpIHtcbiAgICBwYXJhbSA9ICcwbicgKyBwYXJhbTtcbiAgfVxuXG4gIGNhcCA9IC9eKFsrLV0pPyhcXGQrKT9uKFsrLV0pPyhcXGQrKT8kLy5leGVjKHBhcmFtKTtcblxuICByZXR1cm4ge1xuICAgIGdyb3VwOiBjYXBbMV0gPT09ICctJ1xuICAgICAgPyAtKGNhcFsyXSB8fCAxKVxuICAgICAgOiArKGNhcFsyXSB8fCAxKSxcbiAgICBvZmZzZXQ6IGNhcFs0XVxuICAgICAgPyAoY2FwWzNdID09PSAnLScgPyAtY2FwWzRdIDogK2NhcFs0XSlcbiAgICAgIDogMFxuICB9O1xufTtcblxudmFyIG50aCA9IGZ1bmN0aW9uKHBhcmFtXywgdGVzdCwgbGFzdCkge1xuICB2YXIgcGFyYW0gPSBwYXJzZU50aChwYXJhbV8pXG4gICAgLCBncm91cCA9IHBhcmFtLmdyb3VwXG4gICAgLCBvZmZzZXQgPSBwYXJhbS5vZmZzZXRcbiAgICAsIGZpbmQgPSAhbGFzdCA/IGNoaWxkIDogbGFzdENoaWxkXG4gICAgLCBhZHZhbmNlID0gIWxhc3QgPyBuZXh0IDogcHJldjtcblxuICByZXR1cm4gZnVuY3Rpb24oZWwpIHtcbiAgICBpZiAoZWwucGFyZW50Tm9kZS5ub2RlVHlwZSAhPT0gMSkgcmV0dXJuO1xuXG4gICAgdmFyIHJlbCA9IGZpbmQoZWwucGFyZW50Tm9kZSlcbiAgICAgICwgcG9zID0gMDtcblxuICAgIHdoaWxlIChyZWwpIHtcbiAgICAgIGlmICh0ZXN0KHJlbCwgZWwpKSBwb3MrKztcbiAgICAgIGlmIChyZWwgPT09IGVsKSB7XG4gICAgICAgIHBvcyAtPSBvZmZzZXQ7XG4gICAgICAgIHJldHVybiBncm91cCAmJiBwb3NcbiAgICAgICAgICA/IChwb3MgJSBncm91cCkgPT09IDAgJiYgKHBvcyA8IDAgPT09IGdyb3VwIDwgMClcbiAgICAgICAgICA6ICFwb3M7XG4gICAgICB9XG4gICAgICByZWwgPSBhZHZhbmNlKHJlbCk7XG4gICAgfVxuICB9O1xufTtcblxuLyoqXG4gKiBTaW1wbGUgU2VsZWN0b3JzXG4gKi9cblxudmFyIHNlbGVjdG9ycyA9IHtcbiAgJyonOiAoZnVuY3Rpb24oKSB7XG4gICAgaWYgKGZhbHNlLypmdW5jdGlvbigpIHtcbiAgICAgIHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgZWwuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlQ29tbWVudCgnJykpO1xuICAgICAgcmV0dXJuICEhZWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJyonKVswXTtcbiAgICB9KCkqLykge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKGVsKSB7XG4gICAgICAgIGlmIChlbC5ub2RlVHlwZSA9PT0gMSkgcmV0dXJuIHRydWU7XG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICB9KSgpLFxuICAndHlwZSc6IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICB0eXBlID0gdHlwZS50b0xvd2VyQ2FzZSgpO1xuICAgIHJldHVybiBmdW5jdGlvbihlbCkge1xuICAgICAgcmV0dXJuIGVsLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IHR5cGU7XG4gICAgfTtcbiAgfSxcbiAgJ2F0dHInOiBmdW5jdGlvbihrZXksIG9wLCB2YWwsIGkpIHtcbiAgICBvcCA9IG9wZXJhdG9yc1tvcF07XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGVsKSB7XG4gICAgICB2YXIgYXR0cjtcbiAgICAgIHN3aXRjaCAoa2V5KSB7XG4gICAgICAgIGNhc2UgJ2Zvcic6XG4gICAgICAgICAgYXR0ciA9IGVsLmh0bWxGb3I7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2NsYXNzJzpcbiAgICAgICAgICAvLyBjbGFzc05hbWUgaXMgJycgd2hlbiBub24tZXhpc3RlbnRcbiAgICAgICAgICAvLyBnZXRBdHRyaWJ1dGUoJ2NsYXNzJykgaXMgbnVsbFxuICAgICAgICAgIGF0dHIgPSBlbC5jbGFzc05hbWU7XG4gICAgICAgICAgaWYgKGF0dHIgPT09ICcnICYmIGVsLmdldEF0dHJpYnV0ZSgnY2xhc3MnKSA9PSBudWxsKSB7XG4gICAgICAgICAgICBhdHRyID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2hyZWYnOlxuICAgICAgICAgIGF0dHIgPSBlbC5nZXRBdHRyaWJ1dGUoJ2hyZWYnLCAyKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAndGl0bGUnOlxuICAgICAgICAgIC8vIGdldEF0dHJpYnV0ZSgndGl0bGUnKSBjYW4gYmUgJycgd2hlbiBub24tZXhpc3RlbnQgc29tZXRpbWVzP1xuICAgICAgICAgIGF0dHIgPSBlbC5nZXRBdHRyaWJ1dGUoJ3RpdGxlJykgfHwgbnVsbDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgLy8gY2FyZWZ1bCB3aXRoIGF0dHJpYnV0ZXMgd2l0aCBzcGVjaWFsIGdldHRlciBmdW5jdGlvbnNcbiAgICAgICAgY2FzZSAnaWQnOlxuICAgICAgICBjYXNlICdsYW5nJzpcbiAgICAgICAgY2FzZSAnZGlyJzpcbiAgICAgICAgY2FzZSAnYWNjZXNzS2V5JzpcbiAgICAgICAgY2FzZSAnaGlkZGVuJzpcbiAgICAgICAgY2FzZSAndGFiSW5kZXgnOlxuICAgICAgICBjYXNlICdzdHlsZSc6XG4gICAgICAgICAgaWYgKGVsLmdldEF0dHJpYnV0ZSkge1xuICAgICAgICAgICAgYXR0ciA9IGVsLmdldEF0dHJpYnV0ZShrZXkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgaWYgKGVsLmhhc0F0dHJpYnV0ZSAmJiAhZWwuaGFzQXR0cmlidXRlKGtleSkpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhdHRyID0gZWxba2V5XSAhPSBudWxsXG4gICAgICAgICAgICA/IGVsW2tleV1cbiAgICAgICAgICAgIDogZWwuZ2V0QXR0cmlidXRlICYmIGVsLmdldEF0dHJpYnV0ZShrZXkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKGF0dHIgPT0gbnVsbCkgcmV0dXJuO1xuICAgICAgYXR0ciA9IGF0dHIgKyAnJztcbiAgICAgIGlmIChpKSB7XG4gICAgICAgIGF0dHIgPSBhdHRyLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHZhbCA9IHZhbC50b0xvd2VyQ2FzZSgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9wKGF0dHIsIHZhbCk7XG4gICAgfTtcbiAgfSxcbiAgJzpmaXJzdC1jaGlsZCc6IGZ1bmN0aW9uKGVsKSB7XG4gICAgcmV0dXJuICFwcmV2KGVsKSAmJiBlbC5wYXJlbnROb2RlLm5vZGVUeXBlID09PSAxO1xuICB9LFxuICAnOmxhc3QtY2hpbGQnOiBmdW5jdGlvbihlbCkge1xuICAgIHJldHVybiAhbmV4dChlbCkgJiYgZWwucGFyZW50Tm9kZS5ub2RlVHlwZSA9PT0gMTtcbiAgfSxcbiAgJzpvbmx5LWNoaWxkJzogZnVuY3Rpb24oZWwpIHtcbiAgICByZXR1cm4gIXByZXYoZWwpICYmICFuZXh0KGVsKVxuICAgICAgJiYgZWwucGFyZW50Tm9kZS5ub2RlVHlwZSA9PT0gMTtcbiAgfSxcbiAgJzpudGgtY2hpbGQnOiBmdW5jdGlvbihwYXJhbSwgbGFzdCkge1xuICAgIHJldHVybiBudGgocGFyYW0sIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSwgbGFzdCk7XG4gIH0sXG4gICc6bnRoLWxhc3QtY2hpbGQnOiBmdW5jdGlvbihwYXJhbSkge1xuICAgIHJldHVybiBzZWxlY3RvcnNbJzpudGgtY2hpbGQnXShwYXJhbSwgdHJ1ZSk7XG4gIH0sXG4gICc6cm9vdCc6IGZ1bmN0aW9uKGVsKSB7XG4gICAgcmV0dXJuIGVsLm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ID09PSBlbDtcbiAgfSxcbiAgJzplbXB0eSc6IGZ1bmN0aW9uKGVsKSB7XG4gICAgcmV0dXJuICFlbC5maXJzdENoaWxkO1xuICB9LFxuICAnOm5vdCc6IGZ1bmN0aW9uKHNlbCkge1xuICAgIHZhciB0ZXN0ID0gY29tcGlsZUdyb3VwKHNlbCk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGVsKSB7XG4gICAgICByZXR1cm4gIXRlc3QoZWwpO1xuICAgIH07XG4gIH0sXG4gICc6Zmlyc3Qtb2YtdHlwZSc6IGZ1bmN0aW9uKGVsKSB7XG4gICAgaWYgKGVsLnBhcmVudE5vZGUubm9kZVR5cGUgIT09IDEpIHJldHVybjtcbiAgICB2YXIgdHlwZSA9IGVsLm5vZGVOYW1lO1xuICAgIC8qanNoaW50IC1XMDg0ICovXG4gICAgd2hpbGUgKGVsID0gcHJldihlbCkpIHtcbiAgICAgIGlmIChlbC5ub2RlTmFtZSA9PT0gdHlwZSkgcmV0dXJuO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcbiAgJzpsYXN0LW9mLXR5cGUnOiBmdW5jdGlvbihlbCkge1xuICAgIGlmIChlbC5wYXJlbnROb2RlLm5vZGVUeXBlICE9PSAxKSByZXR1cm47XG4gICAgdmFyIHR5cGUgPSBlbC5ub2RlTmFtZTtcbiAgICAvKmpzaGludCAtVzA4NCAqL1xuICAgIHdoaWxlIChlbCA9IG5leHQoZWwpKSB7XG4gICAgICBpZiAoZWwubm9kZU5hbWUgPT09IHR5cGUpIHJldHVybjtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sXG4gICc6b25seS1vZi10eXBlJzogZnVuY3Rpb24oZWwpIHtcbiAgICByZXR1cm4gc2VsZWN0b3JzWyc6Zmlyc3Qtb2YtdHlwZSddKGVsKVxuICAgICAgICAmJiBzZWxlY3RvcnNbJzpsYXN0LW9mLXR5cGUnXShlbCk7XG4gIH0sXG4gICc6bnRoLW9mLXR5cGUnOiBmdW5jdGlvbihwYXJhbSwgbGFzdCkge1xuICAgIHJldHVybiBudGgocGFyYW0sIGZ1bmN0aW9uKHJlbCwgZWwpIHtcbiAgICAgIHJldHVybiByZWwubm9kZU5hbWUgPT09IGVsLm5vZGVOYW1lO1xuICAgIH0sIGxhc3QpO1xuICB9LFxuICAnOm50aC1sYXN0LW9mLXR5cGUnOiBmdW5jdGlvbihwYXJhbSkge1xuICAgIHJldHVybiBzZWxlY3RvcnNbJzpudGgtb2YtdHlwZSddKHBhcmFtLCB0cnVlKTtcbiAgfSxcbiAgJzpjaGVja2VkJzogZnVuY3Rpb24oZWwpIHtcbiAgICByZXR1cm4gISEoZWwuY2hlY2tlZCB8fCBlbC5zZWxlY3RlZCk7XG4gIH0sXG4gICc6aW5kZXRlcm1pbmF0ZSc6IGZ1bmN0aW9uKGVsKSB7XG4gICAgcmV0dXJuICFzZWxlY3RvcnNbJzpjaGVja2VkJ10oZWwpO1xuICB9LFxuICAnOmVuYWJsZWQnOiBmdW5jdGlvbihlbCkge1xuICAgIHJldHVybiAhZWwuZGlzYWJsZWQgJiYgZWwudHlwZSAhPT0gJ2hpZGRlbic7XG4gIH0sXG4gICc6ZGlzYWJsZWQnOiBmdW5jdGlvbihlbCkge1xuICAgIHJldHVybiAhIWVsLmRpc2FibGVkO1xuICB9LFxuICAnOnRhcmdldCc6IGZ1bmN0aW9uKGVsKSB7XG4gICAgcmV0dXJuIGVsLmlkID09PSB3aW5kb3cubG9jYXRpb24uaGFzaC5zdWJzdHJpbmcoMSk7XG4gIH0sXG4gICc6Zm9jdXMnOiBmdW5jdGlvbihlbCkge1xuICAgIHJldHVybiBlbCA9PT0gZWwub3duZXJEb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICB9LFxuICAnOm1hdGNoZXMnOiBmdW5jdGlvbihzZWwpIHtcbiAgICByZXR1cm4gY29tcGlsZUdyb3VwKHNlbCk7XG4gIH0sXG4gICc6bnRoLW1hdGNoJzogZnVuY3Rpb24ocGFyYW0sIGxhc3QpIHtcbiAgICB2YXIgYXJncyA9IHBhcmFtLnNwbGl0KC9cXHMqLFxccyovKVxuICAgICAgLCBhcmcgPSBhcmdzLnNoaWZ0KClcbiAgICAgICwgdGVzdCA9IGNvbXBpbGVHcm91cChhcmdzLmpvaW4oJywnKSk7XG5cbiAgICByZXR1cm4gbnRoKGFyZywgdGVzdCwgbGFzdCk7XG4gIH0sXG4gICc6bnRoLWxhc3QtbWF0Y2gnOiBmdW5jdGlvbihwYXJhbSkge1xuICAgIHJldHVybiBzZWxlY3RvcnNbJzpudGgtbWF0Y2gnXShwYXJhbSwgdHJ1ZSk7XG4gIH0sXG4gICc6bGlua3MtaGVyZSc6IGZ1bmN0aW9uKGVsKSB7XG4gICAgcmV0dXJuIGVsICsgJycgPT09IHdpbmRvdy5sb2NhdGlvbiArICcnO1xuICB9LFxuICAnOmxhbmcnOiBmdW5jdGlvbihwYXJhbSkge1xuICAgIHJldHVybiBmdW5jdGlvbihlbCkge1xuICAgICAgd2hpbGUgKGVsKSB7XG4gICAgICAgIGlmIChlbC5sYW5nKSByZXR1cm4gZWwubGFuZy5pbmRleE9mKHBhcmFtKSA9PT0gMDtcbiAgICAgICAgZWwgPSBlbC5wYXJlbnROb2RlO1xuICAgICAgfVxuICAgIH07XG4gIH0sXG4gICc6ZGlyJzogZnVuY3Rpb24ocGFyYW0pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oZWwpIHtcbiAgICAgIHdoaWxlIChlbCkge1xuICAgICAgICBpZiAoZWwuZGlyKSByZXR1cm4gZWwuZGlyID09PSBwYXJhbTtcbiAgICAgICAgZWwgPSBlbC5wYXJlbnROb2RlO1xuICAgICAgfVxuICAgIH07XG4gIH0sXG4gICc6c2NvcGUnOiBmdW5jdGlvbihlbCwgY29uKSB7XG4gICAgdmFyIGNvbnRleHQgPSBjb24gfHwgZWwub3duZXJEb2N1bWVudDtcbiAgICBpZiAoY29udGV4dC5ub2RlVHlwZSA9PT0gOSkge1xuICAgICAgcmV0dXJuIGVsID09PSBjb250ZXh0LmRvY3VtZW50RWxlbWVudDtcbiAgICB9XG4gICAgcmV0dXJuIGVsID09PSBjb250ZXh0O1xuICB9LFxuICAnOmFueS1saW5rJzogZnVuY3Rpb24oZWwpIHtcbiAgICByZXR1cm4gdHlwZW9mIGVsLmhyZWYgPT09ICdzdHJpbmcnO1xuICB9LFxuICAnOmxvY2FsLWxpbmsnOiBmdW5jdGlvbihlbCkge1xuICAgIGlmIChlbC5ub2RlTmFtZSkge1xuICAgICAgcmV0dXJuIGVsLmhyZWYgJiYgZWwuaG9zdCA9PT0gd2luZG93LmxvY2F0aW9uLmhvc3Q7XG4gICAgfVxuICAgIHZhciBwYXJhbSA9ICtlbCArIDE7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGVsKSB7XG4gICAgICBpZiAoIWVsLmhyZWYpIHJldHVybjtcblxuICAgICAgdmFyIHVybCA9IHdpbmRvdy5sb2NhdGlvbiArICcnXG4gICAgICAgICwgaHJlZiA9IGVsICsgJyc7XG5cbiAgICAgIHJldHVybiB0cnVuY2F0ZVVybCh1cmwsIHBhcmFtKSA9PT0gdHJ1bmNhdGVVcmwoaHJlZiwgcGFyYW0pO1xuICAgIH07XG4gIH0sXG4gICc6ZGVmYXVsdCc6IGZ1bmN0aW9uKGVsKSB7XG4gICAgcmV0dXJuICEhZWwuZGVmYXVsdFNlbGVjdGVkO1xuICB9LFxuICAnOnZhbGlkJzogZnVuY3Rpb24oZWwpIHtcbiAgICByZXR1cm4gZWwud2lsbFZhbGlkYXRlIHx8IChlbC52YWxpZGl0eSAmJiBlbC52YWxpZGl0eS52YWxpZCk7XG4gIH0sXG4gICc6aW52YWxpZCc6IGZ1bmN0aW9uKGVsKSB7XG4gICAgcmV0dXJuICFzZWxlY3RvcnNbJzp2YWxpZCddKGVsKTtcbiAgfSxcbiAgJzppbi1yYW5nZSc6IGZ1bmN0aW9uKGVsKSB7XG4gICAgcmV0dXJuIGVsLnZhbHVlID4gZWwubWluICYmIGVsLnZhbHVlIDw9IGVsLm1heDtcbiAgfSxcbiAgJzpvdXQtb2YtcmFuZ2UnOiBmdW5jdGlvbihlbCkge1xuICAgIHJldHVybiAhc2VsZWN0b3JzWyc6aW4tcmFuZ2UnXShlbCk7XG4gIH0sXG4gICc6cmVxdWlyZWQnOiBmdW5jdGlvbihlbCkge1xuICAgIHJldHVybiAhIWVsLnJlcXVpcmVkO1xuICB9LFxuICAnOm9wdGlvbmFsJzogZnVuY3Rpb24oZWwpIHtcbiAgICByZXR1cm4gIWVsLnJlcXVpcmVkO1xuICB9LFxuICAnOnJlYWQtb25seSc6IGZ1bmN0aW9uKGVsKSB7XG4gICAgaWYgKGVsLnJlYWRPbmx5KSByZXR1cm4gdHJ1ZTtcblxuICAgIHZhciBhdHRyID0gZWwuZ2V0QXR0cmlidXRlKCdjb250ZW50ZWRpdGFibGUnKVxuICAgICAgLCBwcm9wID0gZWwuY29udGVudEVkaXRhYmxlXG4gICAgICAsIG5hbWUgPSBlbC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgbmFtZSA9IG5hbWUgIT09ICdpbnB1dCcgJiYgbmFtZSAhPT0gJ3RleHRhcmVhJztcblxuICAgIHJldHVybiAobmFtZSB8fCBlbC5kaXNhYmxlZCkgJiYgYXR0ciA9PSBudWxsICYmIHByb3AgIT09ICd0cnVlJztcbiAgfSxcbiAgJzpyZWFkLXdyaXRlJzogZnVuY3Rpb24oZWwpIHtcbiAgICByZXR1cm4gIXNlbGVjdG9yc1snOnJlYWQtb25seSddKGVsKTtcbiAgfSxcbiAgJzpob3Zlcic6IGZ1bmN0aW9uKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignOmhvdmVyIGlzIG5vdCBzdXBwb3J0ZWQuJyk7XG4gIH0sXG4gICc6YWN0aXZlJzogZnVuY3Rpb24oKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCc6YWN0aXZlIGlzIG5vdCBzdXBwb3J0ZWQuJyk7XG4gIH0sXG4gICc6bGluayc6IGZ1bmN0aW9uKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignOmxpbmsgaXMgbm90IHN1cHBvcnRlZC4nKTtcbiAgfSxcbiAgJzp2aXNpdGVkJzogZnVuY3Rpb24oKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCc6dmlzaXRlZCBpcyBub3Qgc3VwcG9ydGVkLicpO1xuICB9LFxuICAnOmNvbHVtbic6IGZ1bmN0aW9uKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignOmNvbHVtbiBpcyBub3Qgc3VwcG9ydGVkLicpO1xuICB9LFxuICAnOm50aC1jb2x1bW4nOiBmdW5jdGlvbigpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJzpudGgtY29sdW1uIGlzIG5vdCBzdXBwb3J0ZWQuJyk7XG4gIH0sXG4gICc6bnRoLWxhc3QtY29sdW1uJzogZnVuY3Rpb24oKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCc6bnRoLWxhc3QtY29sdW1uIGlzIG5vdCBzdXBwb3J0ZWQuJyk7XG4gIH0sXG4gICc6Y3VycmVudCc6IGZ1bmN0aW9uKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignOmN1cnJlbnQgaXMgbm90IHN1cHBvcnRlZC4nKTtcbiAgfSxcbiAgJzpwYXN0JzogZnVuY3Rpb24oKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCc6cGFzdCBpcyBub3Qgc3VwcG9ydGVkLicpO1xuICB9LFxuICAnOmZ1dHVyZSc6IGZ1bmN0aW9uKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignOmZ1dHVyZSBpcyBub3Qgc3VwcG9ydGVkLicpO1xuICB9LFxuICAvLyBOb24tc3RhbmRhcmQsIGZvciBjb21wYXRpYmlsaXR5IHB1cnBvc2VzLlxuICAnOmNvbnRhaW5zJzogZnVuY3Rpb24ocGFyYW0pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oZWwpIHtcbiAgICAgIHZhciB0ZXh0ID0gZWwuaW5uZXJUZXh0IHx8IGVsLnRleHRDb250ZW50IHx8IGVsLnZhbHVlIHx8ICcnO1xuICAgICAgcmV0dXJuIHRleHQuaW5kZXhPZihwYXJhbSkgIT09IC0xO1xuICAgIH07XG4gIH0sXG4gICc6aGFzJzogZnVuY3Rpb24ocGFyYW0pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oZWwpIHtcbiAgICAgIHJldHVybiBmaW5kKHBhcmFtLCBlbCkubGVuZ3RoID4gMDtcbiAgICB9O1xuICB9XG4gIC8vIFBvdGVudGlhbGx5IGFkZCBtb3JlIHBzZXVkbyBzZWxlY3RvcnMgZm9yXG4gIC8vIGNvbXBhdGliaWxpdHkgd2l0aCBzaXp6bGUgYW5kIG1vc3Qgb3RoZXJcbiAgLy8gc2VsZWN0b3IgZW5naW5lcyAoPykuXG59O1xuXG4vKipcbiAqIEF0dHJpYnV0ZSBPcGVyYXRvcnNcbiAqL1xuXG52YXIgb3BlcmF0b3JzID0ge1xuICAnLSc6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9LFxuICAnPSc6IGZ1bmN0aW9uKGF0dHIsIHZhbCkge1xuICAgIHJldHVybiBhdHRyID09PSB2YWw7XG4gIH0sXG4gICcqPSc6IGZ1bmN0aW9uKGF0dHIsIHZhbCkge1xuICAgIHJldHVybiBhdHRyLmluZGV4T2YodmFsKSAhPT0gLTE7XG4gIH0sXG4gICd+PSc6IGZ1bmN0aW9uKGF0dHIsIHZhbCkge1xuICAgIHZhciBpID0gYXR0ci5pbmRleE9mKHZhbClcbiAgICAgICwgZlxuICAgICAgLCBsO1xuXG4gICAgaWYgKGkgPT09IC0xKSByZXR1cm47XG4gICAgZiA9IGF0dHJbaSAtIDFdO1xuICAgIGwgPSBhdHRyW2kgKyB2YWwubGVuZ3RoXTtcblxuICAgIHJldHVybiAoIWYgfHwgZiA9PT0gJyAnKSAmJiAoIWwgfHwgbCA9PT0gJyAnKTtcbiAgfSxcbiAgJ3w9JzogZnVuY3Rpb24oYXR0ciwgdmFsKSB7XG4gICAgdmFyIGkgPSBhdHRyLmluZGV4T2YodmFsKVxuICAgICAgLCBsO1xuXG4gICAgaWYgKGkgIT09IDApIHJldHVybjtcbiAgICBsID0gYXR0cltpICsgdmFsLmxlbmd0aF07XG5cbiAgICByZXR1cm4gbCA9PT0gJy0nIHx8ICFsO1xuICB9LFxuICAnXj0nOiBmdW5jdGlvbihhdHRyLCB2YWwpIHtcbiAgICByZXR1cm4gYXR0ci5pbmRleE9mKHZhbCkgPT09IDA7XG4gIH0sXG4gICckPSc6IGZ1bmN0aW9uKGF0dHIsIHZhbCkge1xuICAgIHJldHVybiBhdHRyLmluZGV4T2YodmFsKSArIHZhbC5sZW5ndGggPT09IGF0dHIubGVuZ3RoO1xuICB9LFxuICAvLyBub24tc3RhbmRhcmRcbiAgJyE9JzogZnVuY3Rpb24oYXR0ciwgdmFsKSB7XG4gICAgcmV0dXJuIGF0dHIgIT09IHZhbDtcbiAgfVxufTtcblxuLyoqXG4gKiBDb21iaW5hdG9yIExvZ2ljXG4gKi9cblxudmFyIGNvbWJpbmF0b3JzID0ge1xuICAnICc6IGZ1bmN0aW9uKHRlc3QpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oZWwpIHtcbiAgICAgIC8qanNoaW50IC1XMDg0ICovXG4gICAgICB3aGlsZSAoZWwgPSBlbC5wYXJlbnROb2RlKSB7XG4gICAgICAgIGlmICh0ZXN0KGVsKSkgcmV0dXJuIGVsO1xuICAgICAgfVxuICAgIH07XG4gIH0sXG4gICc+JzogZnVuY3Rpb24odGVzdCkge1xuICAgIHJldHVybiBmdW5jdGlvbihlbCkge1xuICAgICAgLypqc2hpbnQgLVcwODQgKi9cbiAgICAgIGlmIChlbCA9IGVsLnBhcmVudE5vZGUpIHtcbiAgICAgICAgcmV0dXJuIHRlc3QoZWwpICYmIGVsO1xuICAgICAgfVxuICAgIH07XG4gIH0sXG4gICcrJzogZnVuY3Rpb24odGVzdCkge1xuICAgIHJldHVybiBmdW5jdGlvbihlbCkge1xuICAgICAgLypqc2hpbnQgLVcwODQgKi9cbiAgICAgIGlmIChlbCA9IHByZXYoZWwpKSB7XG4gICAgICAgIHJldHVybiB0ZXN0KGVsKSAmJiBlbDtcbiAgICAgIH1cbiAgICB9O1xuICB9LFxuICAnfic6IGZ1bmN0aW9uKHRlc3QpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oZWwpIHtcbiAgICAgIC8qanNoaW50IC1XMDg0ICovXG4gICAgICB3aGlsZSAoZWwgPSBwcmV2KGVsKSkge1xuICAgICAgICBpZiAodGVzdChlbCkpIHJldHVybiBlbDtcbiAgICAgIH1cbiAgICB9O1xuICB9LFxuICAnbm9vcCc6IGZ1bmN0aW9uKHRlc3QpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oZWwpIHtcbiAgICAgIHJldHVybiB0ZXN0KGVsKSAmJiBlbDtcbiAgICB9O1xuICB9LFxuICAncmVmJzogZnVuY3Rpb24odGVzdCwgbmFtZSkge1xuICAgIHZhciBub2RlO1xuXG4gICAgZnVuY3Rpb24gcmVmKGVsKSB7XG4gICAgICB2YXIgZG9jID0gZWwub3duZXJEb2N1bWVudFxuICAgICAgICAsIG5vZGVzID0gZG9jLmdldEVsZW1lbnRzQnlUYWdOYW1lKCcqJylcbiAgICAgICAgLCBpID0gbm9kZXMubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgaWYgKHJlZi50ZXN0KGVsKSkge1xuICAgICAgICAgIG5vZGUgPSBudWxsO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG5vZGUgPSBudWxsO1xuICAgIH1cblxuICAgIHJlZi5jb21iaW5hdG9yID0gZnVuY3Rpb24oZWwpIHtcbiAgICAgIGlmICghbm9kZSB8fCAhbm9kZS5nZXRBdHRyaWJ1dGUpIHJldHVybjtcblxuICAgICAgdmFyIGF0dHIgPSBub2RlLmdldEF0dHJpYnV0ZShuYW1lKSB8fCAnJztcbiAgICAgIGlmIChhdHRyWzBdID09PSAnIycpIGF0dHIgPSBhdHRyLnN1YnN0cmluZygxKTtcblxuICAgICAgaWYgKGF0dHIgPT09IGVsLmlkICYmIHRlc3Qobm9kZSkpIHtcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiByZWY7XG4gIH1cbn07XG5cbi8qKlxuICogR3JhbW1hclxuICovXG5cbnZhciBydWxlcyA9IHtcbiAgZXNjYXBlOiAvXFxcXCg/OlteMC05QS1GYS1mXFxyXFxuXXxbMC05QS1GYS1mXXsxLDZ9W1xcclxcblxcdCBdPykvZyxcbiAgc3RyX2VzY2FwZTogLyhlc2NhcGUpfFxcXFwoXFxufFxcclxcbj98XFxmKS9nLFxuICBub25hc2NpaTogL1tcXHUwMEEwLVxcdUZGRkZdLyxcbiAgY3NzaWQ6IC8oPzooPyEtP1swLTldKSg/OmVzY2FwZXxub25hc2NpaXxbLV9hLXpBLVowLTldKSspLyxcbiAgcW5hbWU6IC9eICooY3NzaWR8XFwqKS8sXG4gIHNpbXBsZTogL14oPzooWy4jXWNzc2lkKXxwc2V1ZG98YXR0cikvLFxuICByZWY6IC9eICpcXC8oY3NzaWQpXFwvICovLFxuICBjb21iaW5hdG9yOiAvXig/OiArKFteIFxcdyouI1xcXFxdKSArfCggKSt8KFteIFxcdyouI1xcXFxdKSkoPyEgKiQpLyxcbiAgYXR0cjogL15cXFsoY3NzaWQpKD86KFteXFx3XT89KShpbnNpZGUpKT9cXF0vLFxuICBwc2V1ZG86IC9eKDpjc3NpZCkoPzpcXCgoaW5zaWRlKVxcKSk/LyxcbiAgaW5zaWRlOiAvKD86XCIoPzpcXFxcXCJ8W15cIl0pKlwifCcoPzpcXFxcJ3xbXiddKSonfDxbXlwiJz5dKj58XFxcXFtcIic+XXxbXlwiJz5dKSovLFxuICBpZGVudDogL14oY3NzaWQpJC9cbn07XG5cbnJ1bGVzLmNzc2lkID0gcmVwbGFjZShydWxlcy5jc3NpZCwgJ25vbmFzY2lpJywgcnVsZXMubm9uYXNjaWkpO1xucnVsZXMuY3NzaWQgPSByZXBsYWNlKHJ1bGVzLmNzc2lkLCAnZXNjYXBlJywgcnVsZXMuZXNjYXBlKTtcbnJ1bGVzLnFuYW1lID0gcmVwbGFjZShydWxlcy5xbmFtZSwgJ2Nzc2lkJywgcnVsZXMuY3NzaWQpO1xucnVsZXMuc2ltcGxlID0gcmVwbGFjZShydWxlcy5zaW1wbGUsICdjc3NpZCcsIHJ1bGVzLmNzc2lkKTtcbnJ1bGVzLnJlZiA9IHJlcGxhY2UocnVsZXMucmVmLCAnY3NzaWQnLCBydWxlcy5jc3NpZCk7XG5ydWxlcy5hdHRyID0gcmVwbGFjZShydWxlcy5hdHRyLCAnY3NzaWQnLCBydWxlcy5jc3NpZCk7XG5ydWxlcy5wc2V1ZG8gPSByZXBsYWNlKHJ1bGVzLnBzZXVkbywgJ2Nzc2lkJywgcnVsZXMuY3NzaWQpO1xucnVsZXMuaW5zaWRlID0gcmVwbGFjZShydWxlcy5pbnNpZGUsICdbXlwiXFwnPl0qJywgcnVsZXMuaW5zaWRlKTtcbnJ1bGVzLmF0dHIgPSByZXBsYWNlKHJ1bGVzLmF0dHIsICdpbnNpZGUnLCBtYWtlSW5zaWRlKCdcXFxcWycsICdcXFxcXScpKTtcbnJ1bGVzLnBzZXVkbyA9IHJlcGxhY2UocnVsZXMucHNldWRvLCAnaW5zaWRlJywgbWFrZUluc2lkZSgnXFxcXCgnLCAnXFxcXCknKSk7XG5ydWxlcy5zaW1wbGUgPSByZXBsYWNlKHJ1bGVzLnNpbXBsZSwgJ3BzZXVkbycsIHJ1bGVzLnBzZXVkbyk7XG5ydWxlcy5zaW1wbGUgPSByZXBsYWNlKHJ1bGVzLnNpbXBsZSwgJ2F0dHInLCBydWxlcy5hdHRyKTtcbnJ1bGVzLmlkZW50ID0gcmVwbGFjZShydWxlcy5pZGVudCwgJ2Nzc2lkJywgcnVsZXMuY3NzaWQpO1xucnVsZXMuc3RyX2VzY2FwZSA9IHJlcGxhY2UocnVsZXMuc3RyX2VzY2FwZSwgJ2VzY2FwZScsIHJ1bGVzLmVzY2FwZSk7XG5cbi8qKlxuICogQ29tcGlsaW5nXG4gKi9cblxudmFyIGNvbXBpbGUgPSBmdW5jdGlvbihzZWxfKSB7XG4gIHZhciBzZWwgPSBzZWxfLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKVxuICAgICwgdGVzdFxuICAgICwgZmlsdGVyID0gW11cbiAgICAsIGJ1ZmYgPSBbXVxuICAgICwgc3ViamVjdFxuICAgICwgcW5hbWVcbiAgICAsIGNhcFxuICAgICwgb3BcbiAgICAsIHJlZjtcblxuICAvKmpzaGludCAtVzA4NCAqL1xuICB3aGlsZSAoc2VsKSB7XG4gICAgaWYgKGNhcCA9IHJ1bGVzLnFuYW1lLmV4ZWMoc2VsKSkge1xuICAgICAgc2VsID0gc2VsLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcbiAgICAgIHFuYW1lID0gY2FwWzFdO1xuICAgICAgYnVmZi5wdXNoKHRvayhxbmFtZSwgdHJ1ZSkpO1xuICAgIH0gZWxzZSBpZiAoY2FwID0gcnVsZXMuc2ltcGxlLmV4ZWMoc2VsKSkge1xuICAgICAgc2VsID0gc2VsLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcbiAgICAgIHFuYW1lID0gJyonO1xuICAgICAgYnVmZi5wdXNoKHRvayhxbmFtZSwgdHJ1ZSkpO1xuICAgICAgYnVmZi5wdXNoKHRvayhjYXApKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdJbnZhbGlkIHNlbGVjdG9yLicpO1xuICAgIH1cblxuICAgIHdoaWxlIChjYXAgPSBydWxlcy5zaW1wbGUuZXhlYyhzZWwpKSB7XG4gICAgICBzZWwgPSBzZWwuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuICAgICAgYnVmZi5wdXNoKHRvayhjYXApKTtcbiAgICB9XG5cbiAgICBpZiAoc2VsWzBdID09PSAnIScpIHtcbiAgICAgIHNlbCA9IHNlbC5zdWJzdHJpbmcoMSk7XG4gICAgICBzdWJqZWN0ID0gbWFrZVN1YmplY3QoKTtcbiAgICAgIHN1YmplY3QucW5hbWUgPSBxbmFtZTtcbiAgICAgIGJ1ZmYucHVzaChzdWJqZWN0LnNpbXBsZSk7XG4gICAgfVxuXG4gICAgaWYgKGNhcCA9IHJ1bGVzLnJlZi5leGVjKHNlbCkpIHtcbiAgICAgIHNlbCA9IHNlbC5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG4gICAgICByZWYgPSBjb21iaW5hdG9ycy5yZWYobWFrZVNpbXBsZShidWZmKSwgZGVjb2RlaWQoY2FwWzFdKSk7XG4gICAgICBmaWx0ZXIucHVzaChyZWYuY29tYmluYXRvcik7XG4gICAgICBidWZmID0gW107XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAoY2FwID0gcnVsZXMuY29tYmluYXRvci5leGVjKHNlbCkpIHtcbiAgICAgIHNlbCA9IHNlbC5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG4gICAgICBvcCA9IGNhcFsxXSB8fCBjYXBbMl0gfHwgY2FwWzNdO1xuICAgICAgaWYgKG9wID09PSAnLCcpIHtcbiAgICAgICAgZmlsdGVyLnB1c2goY29tYmluYXRvcnMubm9vcChtYWtlU2ltcGxlKGJ1ZmYpKSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBvcCA9ICdub29wJztcbiAgICB9XG5cbiAgICBpZiAoIWNvbWJpbmF0b3JzW29wXSkgeyB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ0JhZCBjb21iaW5hdG9yLicpOyB9XG4gICAgZmlsdGVyLnB1c2goY29tYmluYXRvcnNbb3BdKG1ha2VTaW1wbGUoYnVmZikpKTtcbiAgICBidWZmID0gW107XG4gIH1cblxuICB0ZXN0ID0gbWFrZVRlc3QoZmlsdGVyKTtcbiAgdGVzdC5xbmFtZSA9IHFuYW1lO1xuICB0ZXN0LnNlbCA9IHNlbDtcblxuICBpZiAoc3ViamVjdCkge1xuICAgIHN1YmplY3QubG5hbWUgPSB0ZXN0LnFuYW1lO1xuXG4gICAgc3ViamVjdC50ZXN0ID0gdGVzdDtcbiAgICBzdWJqZWN0LnFuYW1lID0gc3ViamVjdC5xbmFtZTtcbiAgICBzdWJqZWN0LnNlbCA9IHRlc3Quc2VsO1xuICAgIHRlc3QgPSBzdWJqZWN0O1xuICB9XG5cbiAgaWYgKHJlZikge1xuICAgIHJlZi50ZXN0ID0gdGVzdDtcbiAgICByZWYucW5hbWUgPSB0ZXN0LnFuYW1lO1xuICAgIHJlZi5zZWwgPSB0ZXN0LnNlbDtcbiAgICB0ZXN0ID0gcmVmO1xuICB9XG5cbiAgcmV0dXJuIHRlc3Q7XG59O1xuXG52YXIgdG9rID0gZnVuY3Rpb24oY2FwLCBxbmFtZSkge1xuICAvLyBxbmFtZVxuICBpZiAocW5hbWUpIHtcbiAgICByZXR1cm4gY2FwID09PSAnKidcbiAgICAgID8gc2VsZWN0b3JzWycqJ11cbiAgICAgIDogc2VsZWN0b3JzLnR5cGUoZGVjb2RlaWQoY2FwKSk7XG4gIH1cblxuICAvLyBjbGFzcy9pZFxuICBpZiAoY2FwWzFdKSB7XG4gICAgcmV0dXJuIGNhcFsxXVswXSA9PT0gJy4nXG5cdCAgLy8gWFhYIHVuZXNjYXBlIGhlcmU/ICBvciBpbiBhdHRyP1xuICAgICAgPyBzZWxlY3RvcnMuYXR0cignY2xhc3MnLCAnfj0nLCBkZWNvZGVpZChjYXBbMV0uc3Vic3RyaW5nKDEpKSlcbiAgICAgIDogc2VsZWN0b3JzLmF0dHIoJ2lkJywgJz0nLCBkZWNvZGVpZChjYXBbMV0uc3Vic3RyaW5nKDEpKSk7XG4gIH1cblxuICAvLyBwc2V1ZG8tbmFtZVxuICAvLyBpbnNpZGUtcHNldWRvXG4gIGlmIChjYXBbMl0pIHtcbiAgICByZXR1cm4gY2FwWzNdXG4gICAgICA/IHNlbGVjdG9yc1tkZWNvZGVpZChjYXBbMl0pXSh1bnF1b3RlKGNhcFszXSkpXG4gICAgICA6IHNlbGVjdG9yc1tkZWNvZGVpZChjYXBbMl0pXTtcbiAgfVxuXG4gIC8vIGF0dHIgbmFtZVxuICAvLyBhdHRyIG9wXG4gIC8vIGF0dHIgdmFsdWVcbiAgaWYgKGNhcFs0XSkge1xuICAgIHJldHVybiBzZWxlY3RvcnMuYXR0cihkZWNvZGVpZChjYXBbNF0pLCBjYXBbNV0gfHwgJy0nLCB1bnF1b3RlKGNhcFs2XSksIGZhbHNlKTtcbiAgfVxuXG4gIHRocm93IG5ldyBTeW50YXhFcnJvcignVW5rbm93biBTZWxlY3Rvci4nKTtcbn07XG5cbnZhciBtYWtlU2ltcGxlID0gZnVuY3Rpb24oZnVuYykge1xuICB2YXIgbCA9IGZ1bmMubGVuZ3RoXG4gICAgLCBpO1xuXG4gIC8vIFBvdGVudGlhbGx5IG1ha2Ugc3VyZVxuICAvLyBgZWxgIGlzIHRydXRoeS5cbiAgaWYgKGwgPCAyKSByZXR1cm4gZnVuY1swXTtcblxuICByZXR1cm4gZnVuY3Rpb24oZWwpIHtcbiAgICBpZiAoIWVsKSByZXR1cm47XG4gICAgZm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgaWYgKCFmdW5jW2ldKGVsKSkgcmV0dXJuO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcbn07XG5cbnZhciBtYWtlVGVzdCA9IGZ1bmN0aW9uKGZ1bmMpIHtcbiAgaWYgKGZ1bmMubGVuZ3RoIDwgMikge1xuICAgIHJldHVybiBmdW5jdGlvbihlbCkge1xuICAgICAgcmV0dXJuICEhZnVuY1swXShlbCk7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24oZWwpIHtcbiAgICB2YXIgaSA9IGZ1bmMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIGlmICghKGVsID0gZnVuY1tpXShlbCkpKSByZXR1cm47XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9O1xufTtcblxudmFyIG1ha2VTdWJqZWN0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciB0YXJnZXQ7XG5cbiAgZnVuY3Rpb24gc3ViamVjdChlbCkge1xuICAgIHZhciBub2RlID0gZWwub3duZXJEb2N1bWVudFxuICAgICAgLCBzY29wZSA9IG5vZGUuZ2V0RWxlbWVudHNCeVRhZ05hbWUoc3ViamVjdC5sbmFtZSlcbiAgICAgICwgaSA9IHNjb3BlLmxlbmd0aDtcblxuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIGlmIChzdWJqZWN0LnRlc3Qoc2NvcGVbaV0pICYmIHRhcmdldCA9PT0gZWwpIHtcbiAgICAgICAgdGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGFyZ2V0ID0gbnVsbDtcbiAgfVxuXG4gIHN1YmplY3Quc2ltcGxlID0gZnVuY3Rpb24oZWwpIHtcbiAgICB0YXJnZXQgPSBlbDtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICByZXR1cm4gc3ViamVjdDtcbn07XG5cbnZhciBjb21waWxlR3JvdXAgPSBmdW5jdGlvbihzZWwpIHtcbiAgdmFyIHRlc3QgPSBjb21waWxlKHNlbClcbiAgICAsIHRlc3RzID0gWyB0ZXN0IF07XG5cbiAgd2hpbGUgKHRlc3Quc2VsKSB7XG4gICAgdGVzdCA9IGNvbXBpbGUodGVzdC5zZWwpO1xuICAgIHRlc3RzLnB1c2godGVzdCk7XG4gIH1cblxuICBpZiAodGVzdHMubGVuZ3RoIDwgMikgcmV0dXJuIHRlc3Q7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKGVsKSB7XG4gICAgdmFyIGwgPSB0ZXN0cy5sZW5ndGhcbiAgICAgICwgaSA9IDA7XG5cbiAgICBmb3IgKDsgaSA8IGw7IGkrKykge1xuICAgICAgaWYgKHRlc3RzW2ldKGVsKSkgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9O1xufTtcblxuLyoqXG4gKiBTZWxlY3Rpb25cbiAqL1xuXG52YXIgZmluZCA9IGZ1bmN0aW9uKHNlbCwgbm9kZSkge1xuICB2YXIgcmVzdWx0cyA9IFtdXG4gICAgLCB0ZXN0ID0gY29tcGlsZShzZWwpXG4gICAgLCBzY29wZSA9IG5vZGUuZ2V0RWxlbWVudHNCeVRhZ05hbWUodGVzdC5xbmFtZSlcbiAgICAsIGkgPSAwXG4gICAgLCBlbDtcblxuICAvKmpzaGludCAtVzA4NCAqL1xuICB3aGlsZSAoZWwgPSBzY29wZVtpKytdKSB7XG4gICAgaWYgKHRlc3QoZWwpKSByZXN1bHRzLnB1c2goZWwpO1xuICB9XG5cbiAgaWYgKHRlc3Quc2VsKSB7XG4gICAgd2hpbGUgKHRlc3Quc2VsKSB7XG4gICAgICB0ZXN0ID0gY29tcGlsZSh0ZXN0LnNlbCk7XG4gICAgICBzY29wZSA9IG5vZGUuZ2V0RWxlbWVudHNCeVRhZ05hbWUodGVzdC5xbmFtZSk7XG4gICAgICBpID0gMDtcbiAgICAgIC8qanNoaW50IC1XMDg0ICovXG4gICAgICB3aGlsZSAoZWwgPSBzY29wZVtpKytdKSB7XG4gICAgICAgIGlmICh0ZXN0KGVsKSAmJiBpbmRleE9mLmNhbGwocmVzdWx0cywgZWwpID09PSAtMSkge1xuICAgICAgICAgIHJlc3VsdHMucHVzaChlbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmVzdWx0cy5zb3J0KG9yZGVyKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHRzO1xufTtcblxuLyoqXG4gKiBFeHBvc2VcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmdW5jdGlvbihzZWwsIGNvbnRleHQpIHtcbiAgLyogd2hlbiBjb250ZXh0IGlzbid0IGEgRG9jdW1lbnRGcmFnbWVudCBhbmQgdGhlIHNlbGVjdG9yIGlzIHNpbXBsZTogKi9cbiAgdmFyIGlkLCByO1xuICBpZiAoY29udGV4dC5ub2RlVHlwZSAhPT0gMTEgJiYgc2VsLmluZGV4T2YoJyAnKSA9PT0gLTEpIHtcbiAgICBpZiAoc2VsWzBdID09PSAnIycgJiYgY29udGV4dC5yb290ZWQgJiYgL14jW0EtWl9dWy1BLVowLTlfXSokL2kudGVzdChzZWwpKSB7XG4gICAgICBpZiAoY29udGV4dC5kb2MuX2hhc011bHRpcGxlRWxlbWVudHNXaXRoSWQpIHtcbiAgICAgICAgaWQgPSBzZWwuc3Vic3RyaW5nKDEpO1xuICAgICAgICBpZiAoIWNvbnRleHQuZG9jLl9oYXNNdWx0aXBsZUVsZW1lbnRzV2l0aElkKGlkKSkge1xuICAgICAgICAgIHIgPSBjb250ZXh0LmRvYy5nZXRFbGVtZW50QnlJZChpZCk7XG4gICAgICAgICAgcmV0dXJuIHIgPyBbcl0gOiBbXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoc2VsWzBdID09PSAnLicgJiYgL15cXC5cXHcrJC8udGVzdChzZWwpKSB7XG4gICAgICByZXR1cm4gY29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKHNlbC5zdWJzdHJpbmcoMSkpO1xuICAgIH1cbiAgICBpZiAoL15cXHcrJC8udGVzdChzZWwpKSB7XG4gICAgICByZXR1cm4gY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZShzZWwpO1xuICAgIH1cbiAgfVxuICAvKiBkbyB0aGluZ3MgdGhlIGhhcmQvc2xvdyB3YXkgKi9cbiAgcmV0dXJuIGZpbmQoc2VsLCBjb250ZXh0KTtcbn07XG5cbmV4cG9ydHMuc2VsZWN0b3JzID0gc2VsZWN0b3JzO1xuZXhwb3J0cy5vcGVyYXRvcnMgPSBvcGVyYXRvcnM7XG5leHBvcnRzLmNvbWJpbmF0b3JzID0gY29tYmluYXRvcnM7XG5cbmV4cG9ydHMubWF0Y2hlcyA9IGZ1bmN0aW9uKGVsLCBzZWwpIHtcbiAgdmFyIHRlc3QgPSB7IHNlbDogc2VsIH07XG4gIGRvIHtcbiAgICB0ZXN0ID0gY29tcGlsZSh0ZXN0LnNlbCk7XG4gICAgaWYgKHRlc3QoZWwpKSB7IHJldHVybiB0cnVlOyB9XG4gIH0gd2hpbGUgKHRlc3Quc2VsKTtcbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2RvbWluby9saWIvc2VsZWN0LmpzXG4vLyBtb2R1bGUgaWQgPSAyMlxuLy8gbW9kdWxlIGNodW5rcyA9IDQiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIE5vZGUgPSByZXF1aXJlKCcuL05vZGUnKTtcblxudmFyIGNyZWF0ZURvY3VtZW50RnJhZ21lbnRGcm9tQXJndW1lbnRzID0gZnVuY3Rpb24oZG9jdW1lbnQsIGFyZ3MpIHtcbiAgdmFyIGRvY0ZyYWcgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG5cbiAgZm9yICh2YXIgaT0wOyBpPGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgYXJnSXRlbSA9IGFyZ3NbaV07XG4gICAgdmFyIGlzTm9kZSA9IGFyZ0l0ZW0gaW5zdGFuY2VvZiBOb2RlO1xuICAgIGRvY0ZyYWcuYXBwZW5kQ2hpbGQoaXNOb2RlID8gYXJnSXRlbSA6XG4gICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShTdHJpbmcoYXJnSXRlbSkpKTtcbiAgfVxuXG4gIHJldHVybiBkb2NGcmFnO1xufTtcblxuLy8gVGhlIENoaWxkTm9kZSBpbnRlcmZhY2UgY29udGFpbnMgbWV0aG9kcyB0aGF0IGFyZSBwYXJ0aWN1bGFyIHRvIGBOb2RlYFxuLy8gb2JqZWN0cyB0aGF0IGNhbiBoYXZlIGEgcGFyZW50LiAgSXQgaXMgaW1wbGVtZW50ZWQgYnkgYEVsZW1lbnRgLFxuLy8gYERvY3VtZW50VHlwZWAsIGFuZCBgQ2hhcmFjdGVyRGF0YWAgb2JqZWN0cy5cbnZhciBDaGlsZE5vZGUgPSB7XG5cbiAgLy8gSW5zZXJ0cyBhIHNldCBvZiBOb2RlIG9yIFN0cmluZyBvYmplY3RzIGluIHRoZSBjaGlsZHJlbiBsaXN0IG9mIHRoaXNcbiAgLy8gQ2hpbGROb2RlJ3MgcGFyZW50LCBqdXN0IGFmdGVyIHRoaXMgQ2hpbGROb2RlLiAgU3RyaW5nIG9iamVjdHMgYXJlXG4gIC8vIGluc2VydGVkIGFzIHRoZSBlcXVpdmFsZW50IFRleHQgbm9kZXMuXG4gIGFmdGVyOiB7IHZhbHVlOiBmdW5jdGlvbiBhZnRlcigpIHtcbiAgICB2YXIgYXJnQXJyID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICB2YXIgcGFyZW50Tm9kZSA9IHRoaXMucGFyZW50Tm9kZSwgbmV4dFNpYmxpbmcgPSB0aGlzLm5leHRTaWJsaW5nO1xuICAgIGlmIChwYXJlbnROb2RlID09PSBudWxsKSB7IHJldHVybjsgfVxuICAgIC8vIEZpbmQgXCJ2aWFibGUgbmV4dCBzaWJsaW5nXCI7IHRoYXQgaXMsIG5leHQgb25lIG5vdCBpbiBhcmdBcnJcbiAgICB3aGlsZSAobmV4dFNpYmxpbmcgJiYgYXJnQXJyLnNvbWUoZnVuY3Rpb24odikgeyByZXR1cm4gdj09PW5leHRTaWJsaW5nOyB9KSlcbiAgICAgIG5leHRTaWJsaW5nID0gbmV4dFNpYmxpbmcubmV4dFNpYmxpbmc7XG4gICAgLy8gb2ssIHBhcmVudCBhbmQgc2libGluZyBhcmUgc2F2ZWQgYXdheSBzaW5jZSB0aGlzIG5vZGUgY291bGQgaXRzZWxmXG4gICAgLy8gYXBwZWFyIGluIGFyZ0FyciBhbmQgd2UncmUgYWJvdXQgdG8gbW92ZSBhcmdBcnIgdG8gYSBkb2N1bWVudCBmcmFnbWVudC5cbiAgICB2YXIgZG9jRnJhZyA9IGNyZWF0ZURvY3VtZW50RnJhZ21lbnRGcm9tQXJndW1lbnRzKHRoaXMuZG9jLCBhcmdBcnIpO1xuXG4gICAgcGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoZG9jRnJhZywgbmV4dFNpYmxpbmcpO1xuICB9fSxcblxuICAvLyBJbnNlcnRzIGEgc2V0IG9mIE5vZGUgb3IgU3RyaW5nIG9iamVjdHMgaW4gdGhlIGNoaWxkcmVuIGxpc3Qgb2YgdGhpc1xuICAvLyBDaGlsZE5vZGUncyBwYXJlbnQsIGp1c3QgYmVmb3JlIHRoaXMgQ2hpbGROb2RlLiAgU3RyaW5nIG9iamVjdHMgYXJlXG4gIC8vIGluc2VydGVkIGFzIHRoZSBlcXVpdmFsZW50IFRleHQgbm9kZXMuXG4gIGJlZm9yZTogeyB2YWx1ZTogZnVuY3Rpb24gYmVmb3JlKCkge1xuICAgIHZhciBhcmdBcnIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgIHZhciBwYXJlbnROb2RlID0gdGhpcy5wYXJlbnROb2RlLCBwcmV2U2libGluZyA9IHRoaXMucHJldmlvdXNTaWJsaW5nO1xuICAgIGlmIChwYXJlbnROb2RlID09PSBudWxsKSB7IHJldHVybjsgfVxuICAgIC8vIEZpbmQgXCJ2aWFibGUgcHJldiBzaWJsaW5nXCI7IHRoYXQgaXMsIHByZXYgb25lIG5vdCBpbiBhcmdBcnJcbiAgICB3aGlsZSAocHJldlNpYmxpbmcgJiYgYXJnQXJyLnNvbWUoZnVuY3Rpb24odikgeyByZXR1cm4gdj09PXByZXZTaWJsaW5nOyB9KSlcbiAgICAgIHByZXZTaWJsaW5nID0gcHJldlNpYmxpbmcucHJldmlvdXNTaWJsaW5nO1xuICAgIC8vIG9rLCBwYXJlbnQgYW5kIHNpYmxpbmcgYXJlIHNhdmVkIGF3YXkgc2luY2UgdGhpcyBub2RlIGNvdWxkIGl0c2VsZlxuICAgIC8vIGFwcGVhciBpbiBhcmdBcnIgYW5kIHdlJ3JlIGFib3V0IHRvIG1vdmUgYXJnQXJyIHRvIGEgZG9jdW1lbnQgZnJhZ21lbnQuXG4gICAgdmFyIGRvY0ZyYWcgPSBjcmVhdGVEb2N1bWVudEZyYWdtZW50RnJvbUFyZ3VtZW50cyh0aGlzLmRvYywgYXJnQXJyKTtcblxuICAgIHZhciBuZXh0U2libGluZyA9XG4gICAgICAgIHByZXZTaWJsaW5nID8gcHJldlNpYmxpbmcubmV4dFNpYmxpbmcgOiBwYXJlbnROb2RlLmZpcnN0Q2hpbGQ7XG4gICAgcGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoZG9jRnJhZywgbmV4dFNpYmxpbmcpO1xuICB9fSxcblxuICAvLyBSZW1vdmUgdGhpcyBub2RlIGZyb20gaXRzIHBhcmVudFxuICByZW1vdmU6IHsgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZSgpIHtcbiAgICBpZiAodGhpcy5wYXJlbnROb2RlID09PSBudWxsKSByZXR1cm47XG5cbiAgICAvLyBTZW5kIG11dGF0aW9uIGV2ZW50cyBpZiBuZWNlc3NhcnlcbiAgICBpZiAodGhpcy5yb290ZWQgJiYgdGhpcy5kb2MpIHRoaXMuZG9jLm11dGF0ZVJlbW92ZSh0aGlzKTtcblxuICAgIC8vIFJlbW92ZSB0aGlzIG5vZGUgZnJvbSBpdHMgcGFyZW50cyBhcnJheSBvZiBjaGlsZHJlblxuICAgIHRoaXMucGFyZW50Tm9kZS5jaGlsZE5vZGVzLnNwbGljZSh0aGlzLmluZGV4LCAxKTtcblxuICAgIC8vIFVwZGF0ZSB0aGUgc3RydWN0dXJlIGlkIGZvciBhbGwgYW5jZXN0b3JzXG4gICAgdGhpcy5wYXJlbnROb2RlLm1vZGlmeSgpO1xuXG4gICAgLy8gRm9yZ2V0IHRoaXMgbm9kZSdzIHBhcmVudFxuICAgIHRoaXMucGFyZW50Tm9kZSA9IG51bGw7XG4gIH19LFxuXG4gIC8vIFJlcGxhY2UgdGhpcyBub2RlIHdpdGggdGhlIG5vZGVzIG9yIHN0cmluZ3MgcHJvdmlkZWQgYXMgYXJndW1lbnRzLlxuICByZXBsYWNlV2l0aDogeyB2YWx1ZTogZnVuY3Rpb24gcmVwbGFjZVdpdGgoKSB7XG4gICAgdmFyIGFyZ0FyciA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgdmFyIHBhcmVudE5vZGUgPSB0aGlzLnBhcmVudE5vZGUsIG5leHRTaWJsaW5nID0gdGhpcy5uZXh0U2libGluZztcbiAgICBpZiAocGFyZW50Tm9kZSA9PT0gbnVsbCkgeyByZXR1cm47IH1cbiAgICAvLyBGaW5kIFwidmlhYmxlIG5leHQgc2libGluZ1wiOyB0aGF0IGlzLCBuZXh0IG9uZSBub3QgaW4gYXJnQXJyXG4gICAgd2hpbGUgKG5leHRTaWJsaW5nICYmIGFyZ0Fyci5zb21lKGZ1bmN0aW9uKHYpIHsgcmV0dXJuIHY9PT1uZXh0U2libGluZzsgfSkpXG4gICAgICBuZXh0U2libGluZyA9IG5leHRTaWJsaW5nLm5leHRTaWJsaW5nO1xuICAgIC8vIG9rLCBwYXJlbnQgYW5kIHNpYmxpbmcgYXJlIHNhdmVkIGF3YXkgc2luY2UgdGhpcyBub2RlIGNvdWxkIGl0c2VsZlxuICAgIC8vIGFwcGVhciBpbiBhcmdBcnIgYW5kIHdlJ3JlIGFib3V0IHRvIG1vdmUgYXJnQXJyIHRvIGEgZG9jdW1lbnQgZnJhZ21lbnQuXG4gICAgdmFyIGRvY0ZyYWcgPSBjcmVhdGVEb2N1bWVudEZyYWdtZW50RnJvbUFyZ3VtZW50cyh0aGlzLmRvYywgYXJnQXJyKTtcbiAgICBpZiAodGhpcy5wYXJlbnROb2RlID09PSBwYXJlbnROb2RlKSB7XG4gICAgICBwYXJlbnROb2RlLnJlcGxhY2VDaGlsZChkb2NGcmFnLCB0aGlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gYHRoaXNgIHdhcyBpbnNlcnRlZCBpbnRvIGRvY0ZyYWdcbiAgICAgIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGRvY0ZyYWcsIG5leHRTaWJsaW5nKTtcbiAgICB9XG4gIH19LFxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENoaWxkTm9kZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2RvbWluby9saWIvQ2hpbGROb2RlLmpzXG4vLyBtb2R1bGUgaWQgPSAyM1xuLy8gbW9kdWxlIGNodW5rcyA9IDQiLCJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gVVJMO1xuXG5mdW5jdGlvbiBVUkwodXJsKSB7XG4gIGlmICghdXJsKSByZXR1cm4gT2JqZWN0LmNyZWF0ZShVUkwucHJvdG90eXBlKTtcbiAgLy8gQ2FuJ3QgdXNlIFN0cmluZy50cmltKCkgc2luY2UgaXQgZGVmaW5lcyB3aGl0ZXNwYWNlIGRpZmZlcmVudGx5IHRoYW4gSFRNTFxuICB0aGlzLnVybCA9IHVybC5yZXBsYWNlKC9eWyBcXHRcXG5cXHJcXGZdK3xbIFxcdFxcblxcclxcZl0rJC9nLCBcIlwiKTtcblxuICAvLyBTZWUgaHR0cDovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzk4NiNhcHBlbmRpeC1CXG4gIC8vIGFuZCBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI3BhcnNpbmdcbiAgdmFyIG1hdGNoID0gVVJMLnBhdHRlcm4uZXhlYyh0aGlzLnVybCk7XG4gIGlmIChtYXRjaCkge1xuICAgIGlmIChtYXRjaFsyXSkgdGhpcy5zY2hlbWUgPSBtYXRjaFsyXTtcbiAgICBpZiAobWF0Y2hbNF0pIHtcbiAgICAgIC8vIHBhcnNlIHVzZXJuYW1lL3Bhc3N3b3JkXG4gICAgICB2YXIgdXNlcmluZm8gPSBtYXRjaFs0XS5tYXRjaChVUkwudXNlcmluZm9QYXR0ZXJuKTtcbiAgICAgIGlmICh1c2VyaW5mbykge1xuICAgICAgICB0aGlzLnVzZXJuYW1lID0gdXNlcmluZm9bMV07XG4gICAgICAgIHRoaXMucGFzc3dvcmQgPSB1c2VyaW5mb1szXTtcbiAgICAgICAgbWF0Y2hbNF0gPSBtYXRjaFs0XS5zdWJzdHJpbmcodXNlcmluZm9bMF0ubGVuZ3RoKTtcbiAgICAgIH1cbiAgICAgIGlmIChtYXRjaFs0XS5tYXRjaChVUkwucG9ydFBhdHRlcm4pKSB7XG4gICAgICAgIHZhciBwb3MgPSBtYXRjaFs0XS5sYXN0SW5kZXhPZignOicpO1xuICAgICAgICB0aGlzLmhvc3QgPSBtYXRjaFs0XS5zdWJzdHJpbmcoMCwgcG9zKTtcbiAgICAgICAgdGhpcy5wb3J0ID0gbWF0Y2hbNF0uc3Vic3RyaW5nKHBvcysxKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0aGlzLmhvc3QgPSBtYXRjaFs0XTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG1hdGNoWzVdKSB0aGlzLnBhdGggPSBtYXRjaFs1XTtcbiAgICBpZiAobWF0Y2hbNl0pIHRoaXMucXVlcnkgPSBtYXRjaFs3XTtcbiAgICBpZiAobWF0Y2hbOF0pIHRoaXMuZnJhZ21lbnQgPSBtYXRjaFs5XTtcbiAgfVxufVxuXG5VUkwucGF0dGVybiA9IC9eKChbXjpcXC8/I10rKTopPyhcXC9cXC8oW15cXC8/I10qKSk/KFtePyNdKikoXFw/KFteI10qKSk/KCMoLiopKT8kLztcblVSTC51c2VyaW5mb1BhdHRlcm4gPSAvXihbXkA6XSopKDooW15AXSopKT9ALztcblVSTC5wb3J0UGF0dGVybiA9IC86XFxkKyQvO1xuVVJMLmF1dGhvcml0eVBhdHRlcm4gPSAvXlteOlxcLz8jXSs6XFwvXFwvLztcblVSTC5oaWVyYXJjaHlQYXR0ZXJuID0gL15bXjpcXC8/I10rOlxcLy87XG5cbi8vIFJldHVybiBhIHBlcmNlbnRFbmNvZGVkIHZlcnNpb24gb2Ygcy5cbi8vIFMgc2hvdWxkIGJlIGEgc2luZ2xlLWNoYXJhY3RlciBzdHJpbmdcbi8vIFhYWDogbmVlZHMgdG8gZG8gdXRmLTggZW5jb2Rpbmc/XG5VUkwucGVyY2VudEVuY29kZSA9IGZ1bmN0aW9uIHBlcmNlbnRFbmNvZGUocykge1xuICB2YXIgYyA9IHMuY2hhckNvZGVBdCgwKTtcbiAgaWYgKGMgPCAyNTYpIHJldHVybiBcIiVcIiArIGMudG9TdHJpbmcoMTYpO1xuICBlbHNlIHRocm93IEVycm9yKFwiY2FuJ3QgcGVyY2VudC1lbmNvZGUgY29kZXBvaW50cyA+IDI1NSB5ZXRcIik7XG59O1xuXG5VUkwucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogVVJMLFxuXG4gIC8vIFhYWDogbm90IHN1cmUgaWYgdGhpcyBpcyB0aGUgcHJlY2lzZSBkZWZpbml0aW9uIG9mIGFic29sdXRlXG4gIGlzQWJzb2x1dGU6IGZ1bmN0aW9uKCkgeyByZXR1cm4gISF0aGlzLnNjaGVtZTsgfSxcbiAgaXNBdXRob3JpdHlCYXNlZDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFVSTC5hdXRob3JpdHlQYXR0ZXJuLnRlc3QodGhpcy51cmwpO1xuICB9LFxuICBpc0hpZXJhcmNoaWNhbDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFVSTC5oaWVyYXJjaHlQYXR0ZXJuLnRlc3QodGhpcy51cmwpO1xuICB9LFxuXG4gIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgcyA9IFwiXCI7XG4gICAgaWYgKHRoaXMuc2NoZW1lICE9PSB1bmRlZmluZWQpIHMgKz0gdGhpcy5zY2hlbWUgKyBcIjpcIjtcbiAgICBpZiAodGhpcy5pc0Fic29sdXRlKCkpIHtcbiAgICAgIHMgKz0gJy8vJztcbiAgICAgIGlmICh0aGlzLnVzZXJuYW1lIHx8IHRoaXMucGFzc3dvcmQpIHtcbiAgICAgICAgcyArPSB0aGlzLnVzZXJuYW1lIHx8ICcnO1xuICAgICAgICBpZiAodGhpcy5wYXNzd29yZCkge1xuICAgICAgICAgIHMgKz0gJzonICsgdGhpcy5wYXNzd29yZDtcbiAgICAgICAgfVxuICAgICAgICBzICs9ICdAJztcbiAgICAgIH1cbiAgICAgIHMgKz0gdGhpcy5ob3N0O1xuICAgIH1cbiAgICBpZiAodGhpcy5wb3J0ICE9PSB1bmRlZmluZWQpIHMgKz0gXCI6XCIgKyB0aGlzLnBvcnQ7XG4gICAgaWYgKHRoaXMucGF0aCAhPT0gdW5kZWZpbmVkKSBzICs9IHRoaXMucGF0aDtcbiAgICBpZiAodGhpcy5xdWVyeSAhPT0gdW5kZWZpbmVkKSBzICs9IFwiP1wiICsgdGhpcy5xdWVyeTtcbiAgICBpZiAodGhpcy5mcmFnbWVudCAhPT0gdW5kZWZpbmVkKSBzICs9IFwiI1wiICsgdGhpcy5mcmFnbWVudDtcbiAgICByZXR1cm4gcztcbiAgfSxcblxuICAvLyBTZWU6IGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM5ODYjc2VjdGlvbi01LjJcbiAgLy8gYW5kIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jY29uc3RydWN0b3JzXG4gIHJlc29sdmU6IGZ1bmN0aW9uKHJlbGF0aXZlKSB7XG4gICAgdmFyIGJhc2UgPSB0aGlzOyAgICAgICAgICAgLy8gVGhlIGJhc2UgdXJsIHdlJ3JlIHJlc29sdmluZyBhZ2FpbnN0XG4gICAgdmFyIHIgPSBuZXcgVVJMKHJlbGF0aXZlKTsgLy8gVGhlIHJlbGF0aXZlIHJlZmVyZW5jZSB1cmwgdG8gcmVzb2x2ZVxuICAgIHZhciB0ID0gbmV3IFVSTCgpOyAgICAgICAgIC8vIFRoZSBhYnNvbHV0ZSB0YXJnZXQgdXJsIHdlIHdpbGwgcmV0dXJuXG5cbiAgICBpZiAoci5zY2hlbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdC5zY2hlbWUgPSByLnNjaGVtZTtcbiAgICAgIHQudXNlcm5hbWUgPSByLnVzZXJuYW1lO1xuICAgICAgdC5wYXNzd29yZCA9IHIucGFzc3dvcmQ7XG4gICAgICB0Lmhvc3QgPSByLmhvc3Q7XG4gICAgICB0LnBvcnQgPSByLnBvcnQ7XG4gICAgICB0LnBhdGggPSByZW1vdmVfZG90X3NlZ21lbnRzKHIucGF0aCk7XG4gICAgICB0LnF1ZXJ5ID0gci5xdWVyeTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0LnNjaGVtZSA9IGJhc2Uuc2NoZW1lO1xuICAgICAgaWYgKHIuaG9zdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHQudXNlcm5hbWUgPSByLnVzZXJuYW1lO1xuICAgICAgICB0LnBhc3N3b3JkID0gci5wYXNzd29yZDtcbiAgICAgICAgdC5ob3N0ID0gci5ob3N0O1xuICAgICAgICB0LnBvcnQgPSByLnBvcnQ7XG4gICAgICAgIHQucGF0aCA9IHJlbW92ZV9kb3Rfc2VnbWVudHMoci5wYXRoKTtcbiAgICAgICAgdC5xdWVyeSA9IHIucXVlcnk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdC51c2VybmFtZSA9IGJhc2UudXNlcm5hbWU7XG4gICAgICAgIHQucGFzc3dvcmQgPSBiYXNlLnBhc3N3b3JkO1xuICAgICAgICB0Lmhvc3QgPSBiYXNlLmhvc3Q7XG4gICAgICAgIHQucG9ydCA9IGJhc2UucG9ydDtcbiAgICAgICAgaWYgKCFyLnBhdGgpIHsgLy8gdW5kZWZpbmVkIG9yIGVtcHR5XG4gICAgICAgICAgdC5wYXRoID0gYmFzZS5wYXRoO1xuICAgICAgICAgIGlmIChyLnF1ZXJ5ICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICB0LnF1ZXJ5ID0gci5xdWVyeTtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB0LnF1ZXJ5ID0gYmFzZS5xdWVyeTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBpZiAoci5wYXRoLmNoYXJBdCgwKSA9PT0gXCIvXCIpIHtcbiAgICAgICAgICAgIHQucGF0aCA9IHJlbW92ZV9kb3Rfc2VnbWVudHMoci5wYXRoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0LnBhdGggPSBtZXJnZShiYXNlLnBhdGgsIHIucGF0aCk7XG4gICAgICAgICAgICB0LnBhdGggPSByZW1vdmVfZG90X3NlZ21lbnRzKHQucGF0aCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHQucXVlcnkgPSByLnF1ZXJ5O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHQuZnJhZ21lbnQgPSByLmZyYWdtZW50O1xuXG4gICAgcmV0dXJuIHQudG9TdHJpbmcoKTtcblxuXG4gICAgZnVuY3Rpb24gbWVyZ2UoYmFzZXBhdGgsIHJlZnBhdGgpIHtcbiAgICAgIGlmIChiYXNlLmhvc3QgIT09IHVuZGVmaW5lZCAmJiAhYmFzZS5wYXRoKVxuICAgICAgICByZXR1cm4gXCIvXCIgKyByZWZwYXRoO1xuXG4gICAgICB2YXIgbGFzdHNsYXNoID0gYmFzZXBhdGgubGFzdEluZGV4T2YoXCIvXCIpO1xuICAgICAgaWYgKGxhc3RzbGFzaCA9PT0gLTEpXG4gICAgICAgIHJldHVybiByZWZwYXRoO1xuICAgICAgZWxzZVxuICAgICAgICByZXR1cm4gYmFzZXBhdGguc3Vic3RyaW5nKDAsIGxhc3RzbGFzaCsxKSArIHJlZnBhdGg7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVtb3ZlX2RvdF9zZWdtZW50cyhwYXRoKSB7XG4gICAgICBpZiAoIXBhdGgpIHJldHVybiBwYXRoOyAvLyBGb3IgXCJcIiBvciB1bmRlZmluZWRcblxuICAgICAgdmFyIG91dHB1dCA9IFwiXCI7XG4gICAgICB3aGlsZShwYXRoLmxlbmd0aCA+IDApIHtcbiAgICAgICAgaWYgKHBhdGggPT09IFwiLlwiIHx8IHBhdGggPT09IFwiLi5cIikge1xuICAgICAgICAgIHBhdGggPSBcIlwiO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHR3b2NoYXJzID0gcGF0aC5zdWJzdHJpbmcoMCwyKTtcbiAgICAgICAgdmFyIHRocmVlY2hhcnMgPSBwYXRoLnN1YnN0cmluZygwLDMpO1xuICAgICAgICB2YXIgZm91cmNoYXJzID0gcGF0aC5zdWJzdHJpbmcoMCw0KTtcbiAgICAgICAgaWYgKHRocmVlY2hhcnMgPT09IFwiLi4vXCIpIHtcbiAgICAgICAgICBwYXRoID0gcGF0aC5zdWJzdHJpbmcoMyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHdvY2hhcnMgPT09IFwiLi9cIikge1xuICAgICAgICAgIHBhdGggPSBwYXRoLnN1YnN0cmluZygyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aHJlZWNoYXJzID09PSBcIi8uL1wiKSB7XG4gICAgICAgICAgcGF0aCA9IFwiL1wiICsgcGF0aC5zdWJzdHJpbmcoMyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHdvY2hhcnMgPT09IFwiLy5cIiAmJiBwYXRoLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgIHBhdGggPSBcIi9cIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChmb3VyY2hhcnMgPT09IFwiLy4uL1wiIHx8XG4gICAgICAgICAgICAgKHRocmVlY2hhcnMgPT09IFwiLy4uXCIgJiYgcGF0aC5sZW5ndGggPT09IDMpKSB7XG4gICAgICAgICAgcGF0aCA9IFwiL1wiICsgcGF0aC5zdWJzdHJpbmcoNCk7XG5cbiAgICAgICAgICBvdXRwdXQgPSBvdXRwdXQucmVwbGFjZSgvXFwvP1teXFwvXSokLywgXCJcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgdmFyIHNlZ21lbnQgPSBwYXRoLm1hdGNoKC8oXFwvPyhbXlxcL10qKSkvKVswXTtcbiAgICAgICAgICBvdXRwdXQgKz0gc2VnbWVudDtcbiAgICAgICAgICBwYXRoID0gcGF0aC5zdWJzdHJpbmcoc2VnbWVudC5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfVxuICB9LFxufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2RvbWluby9saWIvVVJMLmpzXG4vLyBtb2R1bGUgaWQgPSAyNFxuLy8gbW9kdWxlIGNodW5rcyA9IDQiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBOb2RlID0gcmVxdWlyZSgnLi9Ob2RlJyk7XG52YXIgRWxlbWVudCA9IHJlcXVpcmUoJy4vRWxlbWVudCcpO1xudmFyIENTU1N0eWxlRGVjbGFyYXRpb24gPSByZXF1aXJlKCcuL0NTU1N0eWxlRGVjbGFyYXRpb24nKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbnZhciBVUkxVdGlscyA9IHJlcXVpcmUoJy4vVVJMVXRpbHMnKTtcbnZhciBkZWZpbmVFbGVtZW50ID0gcmVxdWlyZSgnLi9kZWZpbmVFbGVtZW50Jyk7XG5cbnZhciBodG1sRWxlbWVudHMgPSBleHBvcnRzLmVsZW1lbnRzID0ge307XG52YXIgaHRtbE5hbWVUb0ltcGwgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG5leHBvcnRzLmNyZWF0ZUVsZW1lbnQgPSBmdW5jdGlvbihkb2MsIGxvY2FsTmFtZSwgcHJlZml4KSB7XG4gIHZhciBpbXBsID0gaHRtbE5hbWVUb0ltcGxbbG9jYWxOYW1lXSB8fCBIVE1MVW5rbm93bkVsZW1lbnQ7XG4gIHJldHVybiBuZXcgaW1wbChkb2MsIGxvY2FsTmFtZSwgcHJlZml4KTtcbn07XG5cbmZ1bmN0aW9uIGRlZmluZShzcGVjKSB7XG4gIHJldHVybiBkZWZpbmVFbGVtZW50KHNwZWMsIEhUTUxFbGVtZW50LCBodG1sRWxlbWVudHMsIGh0bWxOYW1lVG9JbXBsKTtcbn1cblxuZnVuY3Rpb24gVVJMKGF0dHIpIHtcbiAgcmV0dXJuIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHYgPSB0aGlzLl9nZXRhdHRyKGF0dHIpO1xuICAgICAgaWYgKHYgPT09IG51bGwpIHsgcmV0dXJuICcnOyB9XG4gICAgICB2YXIgdXJsID0gdGhpcy5kb2MuX3Jlc29sdmUodik7XG4gICAgICByZXR1cm4gKHVybCA9PT0gbnVsbCkgPyB2IDogdXJsO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgdGhpcy5fc2V0YXR0cihhdHRyLCB2YWx1ZSk7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBDT1JTKGF0dHIpIHtcbiAgcmV0dXJuIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHYgPSB0aGlzLl9nZXRhdHRyKGF0dHIpO1xuICAgICAgaWYgKHYgPT09IG51bGwpIHsgcmV0dXJuIG51bGw7IH1cbiAgICAgIGlmICh2LnRvTG93ZXJDYXNlKCkgPT09ICd1c2UtY3JlZGVudGlhbHMnKSB7IHJldHVybiAndXNlLWNyZWRlbnRpYWxzJzsgfVxuICAgICAgcmV0dXJuICdhbm9ueW1vdXMnO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlPT09bnVsbCB8fCB2YWx1ZT09PXVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLnJlbW92ZUF0dHJpYnV0ZShhdHRyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3NldGF0dHIoYXR0ciwgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cblxudmFyIFJFRkVSUkVSID0ge1xuICB0eXBlOiBbXCJcIiwgXCJuby1yZWZlcnJlclwiLCBcIm5vLXJlZmVycmVyLXdoZW4tZG93bmdyYWRlXCIsIFwic2FtZS1vcmlnaW5cIiwgXCJvcmlnaW5cIiwgXCJzdHJpY3Qtb3JpZ2luXCIsIFwib3JpZ2luLXdoZW4tY3Jvc3Mtb3JpZ2luXCIsIFwic3RyaWN0LW9yaWdpbi13aGVuLWNyb3NzLW9yaWdpblwiLCBcInVuc2FmZS11cmxcIl0sXG4gIG1pc3Npbmc6ICcnLFxufTtcblxuXG4vLyBYWFg6IHRoZSBkZWZhdWx0IHZhbHVlIGZvciB0YWJJbmRleCBzaG91bGQgYmUgMCBpZiB0aGUgZWxlbWVudCBpc1xuLy8gZm9jdXNhYmxlIGFuZCAtMSBpZiBpdCBpcyBub3QuICBCdXQgdGhlIGZ1bGwgZGVmaW5pdGlvbiBvZiBmb2N1c2FibGVcbi8vIGlzIGFjdHVhbGx5IGhhcmQgdG8gY29tcHV0ZSwgc28gZm9yIG5vdywgSSdsbCBmb2xsb3cgRmlyZWZveCBhbmRcbi8vIGp1c3QgYmFzZSB0aGUgZGVmYXVsdCB2YWx1ZSBvbiB0aGUgdHlwZSBvZiB0aGUgZWxlbWVudC5cbnZhciBmb2N1c2FibGVFbGVtZW50cyA9IHtcbiAgXCJBXCI6dHJ1ZSwgXCJMSU5LXCI6dHJ1ZSwgXCJCVVRUT05cIjp0cnVlLCBcIklOUFVUXCI6dHJ1ZSxcbiAgXCJTRUxFQ1RcIjp0cnVlLCBcIlRFWFRBUkVBXCI6dHJ1ZSwgXCJDT01NQU5EXCI6dHJ1ZVxufTtcblxudmFyIEhUTUxFbGVtZW50ID0gZXhwb3J0cy5IVE1MRWxlbWVudCA9IGRlZmluZSh7XG4gIHN1cGVyY2xhc3M6IEVsZW1lbnQsXG4gIGN0b3I6IGZ1bmN0aW9uIEhUTUxFbGVtZW50KGRvYywgbG9jYWxOYW1lLCBwcmVmaXgpIHtcbiAgICBFbGVtZW50LmNhbGwodGhpcywgZG9jLCBsb2NhbE5hbWUsIHV0aWxzLk5BTUVTUEFDRS5IVE1MLCBwcmVmaXgpO1xuICB9LFxuICBwcm9wczoge1xuICAgIGlubmVySFRNTDoge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VyaWFsaXplKCk7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbih2KSB7XG4gICAgICAgIHZhciBwYXJzZXIgPSB0aGlzLm93bmVyRG9jdW1lbnQuaW1wbGVtZW50YXRpb24ubW96SFRNTFBhcnNlcihcbiAgICAgICAgICB0aGlzLm93bmVyRG9jdW1lbnQuX2FkZHJlc3MsXG4gICAgICAgICAgdGhpcyk7XG4gICAgICAgIHBhcnNlci5wYXJzZSh2LCB0cnVlKTtcbiAgICAgICAgdmFyIHRtcGRvYyA9IHBhcnNlci5kb2N1bWVudCgpO1xuICAgICAgICB2YXIgcm9vdCA9IHRtcGRvYy5maXJzdENoaWxkO1xuICAgICAgICB2YXIgdGFyZ2V0ID0gKHRoaXMgaW5zdGFuY2VvZiBodG1sTmFtZVRvSW1wbC50ZW1wbGF0ZSkgP1xuICAgICAgICAgICAgdGhpcy5jb250ZW50IDogdGhpcztcblxuICAgICAgICAvLyBSZW1vdmUgYW55IGV4aXN0aW5nIGNoaWxkcmVuIG9mIHRoaXMgbm9kZVxuICAgICAgICB3aGlsZSh0YXJnZXQuaGFzQ2hpbGROb2RlcygpKVxuICAgICAgICAgIHRhcmdldC5yZW1vdmVDaGlsZCh0YXJnZXQuZmlyc3RDaGlsZCk7XG5cbiAgICAgICAgLy8gTm93IGNvcHkgbmV3bHkgcGFyc2VkIGNoaWxkcmVuIGZyb20gdGhlIHJvb3QgdG8gdGhpcyBub2RlXG4gICAgICAgIHRhcmdldC5kb2MuYWRvcHROb2RlKHJvb3QpO1xuICAgICAgICB3aGlsZShyb290Lmhhc0NoaWxkTm9kZXMoKSkge1xuICAgICAgICAgIHRhcmdldC5hcHBlbmRDaGlsZChyb290LmZpcnN0Q2hpbGQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBzdHlsZTogeyBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCF0aGlzLl9zdHlsZSlcbiAgICAgICAgdGhpcy5fc3R5bGUgPSBuZXcgQ1NTU3R5bGVEZWNsYXJhdGlvbih0aGlzKTtcbiAgICAgIHJldHVybiB0aGlzLl9zdHlsZTtcbiAgICB9fSxcblxuICAgIGNsaWNrOiB7IHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLl9jbGlja19pbl9wcm9ncmVzcykgcmV0dXJuO1xuICAgICAgdGhpcy5fY2xpY2tfaW5fcHJvZ3Jlc3MgPSB0cnVlO1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKHRoaXMuX3ByZV9jbGlja19hY3RpdmF0aW9uX3N0ZXBzKVxuICAgICAgICAgIHRoaXMuX3ByZV9jbGlja19hY3RpdmF0aW9uX3N0ZXBzKCk7XG5cbiAgICAgICAgdmFyIGV2ZW50ID0gdGhpcy5vd25lckRvY3VtZW50LmNyZWF0ZUV2ZW50KFwiTW91c2VFdmVudFwiKTtcbiAgICAgICAgZXZlbnQuaW5pdE1vdXNlRXZlbnQoXCJjbGlja1wiLCB0cnVlLCB0cnVlLFxuICAgICAgICAgIHRoaXMub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldywgMSxcbiAgICAgICAgICAwLCAwLCAwLCAwLFxuICAgICAgICAgIC8vIFRoZXNlIDQgc2hvdWxkIGJlIGluaXRpYWxpemVkIHdpdGhcbiAgICAgICAgICAvLyB0aGUgYWN0dWFsbHkgY3VycmVudCBrZXlib2FyZCBzdGF0ZVxuICAgICAgICAgIC8vIHNvbWVob3cuLi5cbiAgICAgICAgICBmYWxzZSwgZmFsc2UsIGZhbHNlLCBmYWxzZSxcbiAgICAgICAgICAwLCBudWxsXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gRGlzcGF0Y2ggdGhpcyBhcyBhbiB1bnRydXN0ZWQgZXZlbnQgc2luY2UgaXQgaXMgc3ludGhldGljXG4gICAgICAgIHZhciBzdWNjZXNzID0gdGhpcy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcblxuICAgICAgICBpZiAoc3VjY2Vzcykge1xuICAgICAgICAgIGlmICh0aGlzLl9wb3N0X2NsaWNrX2FjdGl2YXRpb25fc3RlcHMpXG4gICAgICAgICAgICB0aGlzLl9wb3N0X2NsaWNrX2FjdGl2YXRpb25fc3RlcHMoZXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGlmICh0aGlzLl9jYW5jZWxsZWRfYWN0aXZhdGlvbl9zdGVwcylcbiAgICAgICAgICAgIHRoaXMuX2NhbmNlbGxlZF9hY3RpdmF0aW9uX3N0ZXBzKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZpbmFsbHkge1xuICAgICAgICB0aGlzLl9jbGlja19pbl9wcm9ncmVzcyA9IGZhbHNlO1xuICAgICAgfVxuICAgIH19XG4gIH0sXG4gIGF0dHJpYnV0ZXM6IHtcbiAgICB0aXRsZTogU3RyaW5nLFxuICAgIGxhbmc6IFN0cmluZyxcbiAgICBkaXI6IHt0eXBlOiBbXCJsdHJcIiwgXCJydGxcIiwgXCJhdXRvXCJdLCBtaXNzaW5nOiAnJ30sXG4gICAgYWNjZXNzS2V5OiBTdHJpbmcsXG4gICAgaGlkZGVuOiBCb29sZWFuLFxuICAgIHRhYkluZGV4OiB7dHlwZTogXCJsb25nXCIsIGRlZmF1bHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMudGFnTmFtZSBpbiBmb2N1c2FibGVFbGVtZW50cyB8fFxuICAgICAgICB0aGlzLmNvbnRlbnRFZGl0YWJsZSlcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICBlbHNlXG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9fVxuICB9LFxuICBldmVudHM6IFtcbiAgICBcImFib3J0XCIsIFwiY2FucGxheVwiLCBcImNhbnBsYXl0aHJvdWdoXCIsIFwiY2hhbmdlXCIsIFwiY2xpY2tcIiwgXCJjb250ZXh0bWVudVwiLFxuICAgIFwiY3VlY2hhbmdlXCIsIFwiZGJsY2xpY2tcIiwgXCJkcmFnXCIsIFwiZHJhZ2VuZFwiLCBcImRyYWdlbnRlclwiLCBcImRyYWdsZWF2ZVwiLFxuICAgIFwiZHJhZ292ZXJcIiwgXCJkcmFnc3RhcnRcIiwgXCJkcm9wXCIsIFwiZHVyYXRpb25jaGFuZ2VcIiwgXCJlbXB0aWVkXCIsIFwiZW5kZWRcIixcbiAgICBcImlucHV0XCIsIFwiaW52YWxpZFwiLCBcImtleWRvd25cIiwgXCJrZXlwcmVzc1wiLCBcImtleXVwXCIsIFwibG9hZGVkZGF0YVwiLFxuICAgIFwibG9hZGVkbWV0YWRhdGFcIiwgXCJsb2Fkc3RhcnRcIiwgXCJtb3VzZWRvd25cIiwgXCJtb3VzZW1vdmVcIiwgXCJtb3VzZW91dFwiLFxuICAgIFwibW91c2VvdmVyXCIsIFwibW91c2V1cFwiLCBcIm1vdXNld2hlZWxcIiwgXCJwYXVzZVwiLCBcInBsYXlcIiwgXCJwbGF5aW5nXCIsXG4gICAgXCJwcm9ncmVzc1wiLCBcInJhdGVjaGFuZ2VcIiwgXCJyZWFkeXN0YXRlY2hhbmdlXCIsIFwicmVzZXRcIiwgXCJzZWVrZWRcIixcbiAgICBcInNlZWtpbmdcIiwgXCJzZWxlY3RcIiwgXCJzaG93XCIsIFwic3RhbGxlZFwiLCBcInN1Ym1pdFwiLCBcInN1c3BlbmRcIixcbiAgICBcInRpbWV1cGRhdGVcIiwgXCJ2b2x1bWVjaGFuZ2VcIiwgXCJ3YWl0aW5nXCIsXG5cbiAgICAvLyBUaGVzZSBsYXN0IDUgZXZlbnQgdHlwZXMgd2lsbCBiZSBvdmVycmlkZW4gYnkgSFRNTEJvZHlFbGVtZW50XG4gICAgXCJibHVyXCIsIFwiZXJyb3JcIiwgXCJmb2N1c1wiLCBcImxvYWRcIiwgXCJzY3JvbGxcIlxuICBdXG59KTtcblxuXG4vLyBYWFg6IHJlZmxlY3QgY29udGV4dG1lbnUgYXMgY29udGV4dE1lbnUsIHdpdGggZWxlbWVudCB0eXBlXG5cblxuLy8gc3R5bGU6IHRoZSBzcGVjIGRvZXNuJ3QgY2FsbCB0aGlzIGEgcmVmbGVjdGVkIGF0dHJpYnV0ZS5cbi8vICAgbWF5IHdhbnQgdG8gaGFuZGxlIGl0IG1hbnVhbGx5LlxuXG4vLyBjb250ZW50RWRpdGFibGU6IGVudW1lcmF0ZWQsIG5vdCBjbGVhciBpZiBpdCBpcyBhY3R1YWxseVxuLy8gcmVmbGVjdGVkIG9yIHJlcXVpcmVzIGN1c3RvbSBnZXR0ZXIvc2V0dGVyLiBOb3QgbGlzdGVkIGFzXG4vLyBcImxpbWl0ZWQgdG8ga25vd24gdmFsdWVzXCIuICBSYWlzZXMgc3ludGF4X2VyciBvbiBiYWQgc2V0dGluZyxcbi8vIHNvIEkgdGhpbmsgdGhpcyBpcyBjdXN0b20uXG5cbi8vIGNvbnRleHRtZW51OiBjb250ZW50IGlzIGVsZW1lbnQgaWQsIGlkbCB0eXBlIGlzIGFuIGVsZW1lbnRcbi8vIGRyYWdnYWJsZTogYm9vbGVhbiwgYnV0IG5vdCBhIHJlZmxlY3RlZCBhdHRyaWJ1dGVcbi8vIGRyb3B6b25lOiByZWZsZWN0ZWQgU2V0dGFibGVUb2tlbkxpc3QsIGV4cGVyaW1lbnRhbCwgc28gZG9uJ3Rcbi8vICAgaW1wbGVtZW50IGl0IHJpZ2h0IGF3YXkuXG5cbi8vIGRhdGEtKiBhdHRyaWJ1dGVzOiBuZWVkIHNwZWNpYWwgaGFuZGxpbmcgaW4gc2V0QXR0cmlidXRlP1xuLy8gT3IgbWF5YmUgdGhhdCBpc24ndCBuZWNlc3NhcnkuIENhbiBJIGp1c3Qgc2NhbiB0aGUgYXR0cmlidXRlIGxpc3Rcbi8vIHdoZW4gYnVpbGRpbmcgdGhlIGRhdGFzZXQ/ICBMaXZlbmVzcyBhbmQgY2FjaGluZyBpc3N1ZXM/XG5cbi8vIG1pY3JvZGF0YSBhdHRyaWJ1dGVzOiBtYW55IGFyZSBzaW1wbGUgcmVmbGVjdGVkIGF0dHJpYnV0ZXMsIGJ1dFxuLy8gSSdtIG5vdCBnb2luZyB0byBpbXBsZW1lbnQgdGhpcyBub3cuXG5cblxudmFyIEhUTUxVbmtub3duRWxlbWVudCA9IGRlZmluZSh7XG4gIGN0b3I6IGZ1bmN0aW9uIEhUTUxVbmtub3duRWxlbWVudChkb2MsIGxvY2FsTmFtZSwgcHJlZml4KSB7XG4gICAgSFRNTEVsZW1lbnQuY2FsbCh0aGlzLCBkb2MsIGxvY2FsTmFtZSwgcHJlZml4KTtcbiAgfVxufSk7XG5cblxudmFyIGZvcm1Bc3NvY2lhdGVkUHJvcHMgPSB7XG4gIC8vIFNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sNS9hc3NvY2lhdGlvbi1vZi1jb250cm9scy1hbmQtZm9ybXMuaHRtbCNmb3JtLW93bmVyXG4gIGZvcm06IHsgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fZm9ybTtcbiAgfX1cbn07XG5cbmRlZmluZSh7XG4gIHRhZzogJ2EnLFxuICBjdG9yOiBmdW5jdGlvbiBIVE1MQW5jaG9yRWxlbWVudChkb2MsIGxvY2FsTmFtZSwgcHJlZml4KSB7XG4gICAgSFRNTEVsZW1lbnQuY2FsbCh0aGlzLCBkb2MsIGxvY2FsTmFtZSwgcHJlZml4KTtcbiAgfSxcbiAgcHJvcHM6IHtcbiAgICBfcG9zdF9jbGlja19hY3RpdmF0aW9uX3N0ZXBzOiB7IHZhbHVlOiBmdW5jdGlvbihlKSB7XG4gICAgICBpZiAodGhpcy5ocmVmKSB7XG4gICAgICAgIC8vIEZvbGxvdyB0aGUgbGlua1xuICAgICAgICAvLyBYWFg6IHRoaXMgaXMganVzdCBhIHF1aWNrIGhhY2tcbiAgICAgICAgLy8gWFhYOiB0aGUgSFRNTCBzcGVjIHByb2JhYmx5IHJlcXVpcmVzIG1vcmUgdGhhbiB0aGlzXG4gICAgICAgIHRoaXMub3duZXJEb2N1bWVudC5kZWZhdWx0Vmlldy5sb2NhdGlvbiA9IHRoaXMuaHJlZjtcbiAgICAgIH1cbiAgICB9fSxcbiAgICBibHVyOiB7IHZhbHVlOiBmdW5jdGlvbigpIHt9fSxcbiAgICBmb2N1czogeyB2YWx1ZTogZnVuY3Rpb24oKSB7fX1cbiAgfSxcbiAgYXR0cmlidXRlczoge1xuICAgIGhyZWY6IFVSTCxcbiAgICBwaW5nOiBTdHJpbmcsXG4gICAgZG93bmxvYWQ6IFN0cmluZyxcbiAgICB0YXJnZXQ6IFN0cmluZyxcbiAgICByZWw6IFN0cmluZyxcbiAgICBtZWRpYTogU3RyaW5nLFxuICAgIGhyZWZsYW5nOiBTdHJpbmcsXG4gICAgdHlwZTogU3RyaW5nLFxuICAgIHJlZmVycmVyUG9saWN5OiBSRUZFUlJFUixcbiAgICAvLyBPYnNvbGV0ZVxuICAgIGNvb3JkczogU3RyaW5nLFxuICAgIGNoYXJzZXQ6IFN0cmluZyxcbiAgICBuYW1lOiBTdHJpbmcsXG4gICAgcmV2OiBTdHJpbmcsXG4gICAgc2hhcGU6IFN0cmluZyxcbiAgfVxufSk7XG5VUkxVdGlscy5faW5oZXJpdChodG1sTmFtZVRvSW1wbC5hLnByb3RvdHlwZSk7XG5cbmRlZmluZSh7XG4gIHRhZzogJ2FyZWEnLFxuICBjdG9yOiBmdW5jdGlvbiBIVE1MQXJlYUVsZW1lbnQoZG9jLCBsb2NhbE5hbWUsIHByZWZpeCkge1xuICAgIEhUTUxFbGVtZW50LmNhbGwodGhpcywgZG9jLCBsb2NhbE5hbWUsIHByZWZpeCk7XG4gIH0sXG4gIGF0dHJpYnV0ZXM6IHtcbiAgICBhbHQ6IFN0cmluZyxcbiAgICB0YXJnZXQ6IFN0cmluZyxcbiAgICBkb3dubG9hZDogU3RyaW5nLFxuICAgIHJlbDogU3RyaW5nLFxuICAgIG1lZGlhOiBTdHJpbmcsXG4gICAgaHJlZjogVVJMLFxuICAgIGhyZWZsYW5nOiBTdHJpbmcsXG4gICAgdHlwZTogU3RyaW5nLFxuICAgIHNoYXBlOiBTdHJpbmcsXG4gICAgY29vcmRzOiBTdHJpbmcsXG4gICAgcGluZzogU3RyaW5nLFxuICAgIC8vIFhYWDogYWxzbyByZWZsZWN0IHJlbExpc3RcbiAgICByZWZlcnJlclBvbGljeTogUkVGRVJSRVIsXG4gICAgLy8gT2Jzb2xldGVcbiAgICBub0hyZWY6IEJvb2xlYW4sXG4gIH1cbn0pO1xuXG5kZWZpbmUoe1xuICB0YWc6ICdicicsXG4gIGN0b3I6IGZ1bmN0aW9uIEhUTUxCUkVsZW1lbnQoZG9jLCBsb2NhbE5hbWUsIHByZWZpeCkge1xuICAgIEhUTUxFbGVtZW50LmNhbGwodGhpcywgZG9jLCBsb2NhbE5hbWUsIHByZWZpeCk7XG4gIH0sXG4gIGF0dHJpYnV0ZXM6IHtcbiAgICAvLyBPYnNvbGV0ZVxuICAgIGNsZWFyOiBTdHJpbmdcbiAgfSxcbn0pO1xuXG5kZWZpbmUoe1xuICB0YWc6ICdiYXNlJyxcbiAgY3RvcjogZnVuY3Rpb24gSFRNTEJhc2VFbGVtZW50KGRvYywgbG9jYWxOYW1lLCBwcmVmaXgpIHtcbiAgICBIVE1MRWxlbWVudC5jYWxsKHRoaXMsIGRvYywgbG9jYWxOYW1lLCBwcmVmaXgpO1xuICB9LFxuICBhdHRyaWJ1dGVzOiB7XG4gICAgXCJ0YXJnZXRcIjogU3RyaW5nXG4gIH1cbn0pO1xuXG5cbmRlZmluZSh7XG4gIHRhZzogJ2JvZHknLFxuICBjdG9yOiBmdW5jdGlvbiBIVE1MQm9keUVsZW1lbnQoZG9jLCBsb2NhbE5hbWUsIHByZWZpeCkge1xuICAgIEhUTUxFbGVtZW50LmNhbGwodGhpcywgZG9jLCBsb2NhbE5hbWUsIHByZWZpeCk7XG4gIH0sXG4gIC8vIENlcnRhaW4gZXZlbnQgaGFuZGxlciBhdHRyaWJ1dGVzIG9uIGEgPGJvZHk+IHRhZyBhY3R1YWxseSBzZXRcbiAgLy8gaGFuZGxlcnMgZm9yIHRoZSB3aW5kb3cgcmF0aGVyIHRoYW4ganVzdCB0aGF0IGVsZW1lbnQuICBEZWZpbmVcbiAgLy8gZ2V0dGVycyBhbmQgc2V0dGVycyBmb3IgdGhvc2UgaGVyZS4gIE5vdGUgdGhhdCBzb21lIG9mIHRoZXNlIG92ZXJyaWRlXG4gIC8vIHByb3BlcnRpZXMgb24gSFRNTEVsZW1lbnQucHJvdG90eXBlLlxuICAvLyBYWFg6IElmIEkgYWRkIHN1cHBvcnQgZm9yIDxmcmFtZXNldD4sIHRoZXNlIGhhdmUgdG8gZ28gdGhlcmUsIHRvb1xuICAvLyBYWFhcbiAgLy8gV2hlbiB0aGUgV2luZG93IG9iamVjdCBpcyBpbXBsZW1lbnRlZCwgdGhlc2UgYXR0cmlidXRlIHdpbGwgaGF2ZVxuICAvLyB0byB3b3JrIHdpdGggdGhlIHNhbWUtbmFtZWQgYXR0cmlidXRlcyBvbiB0aGUgV2luZG93LlxuICBldmVudHM6IFtcbiAgICBcImFmdGVycHJpbnRcIiwgXCJiZWZvcmVwcmludFwiLCBcImJlZm9yZXVubG9hZFwiLCBcImJsdXJcIiwgXCJlcnJvclwiLFxuICAgIFwiZm9jdXNcIixcImhhc2hjaGFuZ2VcIiwgXCJsb2FkXCIsIFwibWVzc2FnZVwiLCBcIm9mZmxpbmVcIiwgXCJvbmxpbmVcIixcbiAgICBcInBhZ2VoaWRlXCIsIFwicGFnZXNob3dcIixcInBvcHN0YXRlXCIsXCJyZXNpemVcIixcInNjcm9sbFwiLFwic3RvcmFnZVwiLFwidW5sb2FkXCIsXG4gIF0sXG4gIGF0dHJpYnV0ZXM6IHtcbiAgICAvLyBPYnNvbGV0ZVxuICAgIHRleHQ6IHsgdHlwZTogU3RyaW5nLCB0cmVhdE51bGxBc0VtcHR5U3RyaW5nOiB0cnVlIH0sXG4gICAgbGluazogeyB0eXBlOiBTdHJpbmcsIHRyZWF0TnVsbEFzRW1wdHlTdHJpbmc6IHRydWUgfSxcbiAgICB2TGluazogeyB0eXBlOiBTdHJpbmcsIHRyZWF0TnVsbEFzRW1wdHlTdHJpbmc6IHRydWUgfSxcbiAgICBhTGluazogeyB0eXBlOiBTdHJpbmcsIHRyZWF0TnVsbEFzRW1wdHlTdHJpbmc6IHRydWUgfSxcbiAgICBiZ0NvbG9yOiB7IHR5cGU6IFN0cmluZywgdHJlYXROdWxsQXNFbXB0eVN0cmluZzogdHJ1ZSB9LFxuICAgIGJhY2tncm91bmQ6IFN0cmluZyxcbiAgfVxufSk7XG5cbmRlZmluZSh7XG4gIHRhZzogJ2J1dHRvbicsXG4gIGN0b3I6IGZ1bmN0aW9uIEhUTUxCdXR0b25FbGVtZW50KGRvYywgbG9jYWxOYW1lLCBwcmVmaXgpIHtcbiAgICBIVE1MRWxlbWVudC5jYWxsKHRoaXMsIGRvYywgbG9jYWxOYW1lLCBwcmVmaXgpO1xuICB9LFxuICBwcm9wczogZm9ybUFzc29jaWF0ZWRQcm9wcyxcbiAgYXR0cmlidXRlczoge1xuICAgIG5hbWU6IFN0cmluZyxcbiAgICB2YWx1ZTogU3RyaW5nLFxuICAgIGRpc2FibGVkOiBCb29sZWFuLFxuICAgIGF1dG9mb2N1czogQm9vbGVhbixcbiAgICB0eXBlOiB7IHR5cGU6W1wic3VibWl0XCIsIFwicmVzZXRcIiwgXCJidXR0b25cIiwgXCJtZW51XCJdLCBtaXNzaW5nOiAnc3VibWl0JyB9LFxuICAgIGZvcm1UYXJnZXQ6IFN0cmluZyxcbiAgICBmb3JtTm9WYWxpZGF0ZTogQm9vbGVhbixcbiAgICBmb3JtTWV0aG9kOiB7IHR5cGU6IFtcImdldFwiLCBcInBvc3RcIiwgXCJkaWFsb2dcIl0sIGludmFsaWQ6ICdnZXQnLCBtaXNzaW5nOiAnJyB9LFxuICAgIGZvcm1FbmN0eXBlOiB7IHR5cGU6IFtcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiLCBcIm11bHRpcGFydC9mb3JtLWRhdGFcIiwgXCJ0ZXh0L3BsYWluXCJdLCBpbnZhbGlkOiBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiLCBtaXNzaW5nOiAnJyB9LFxuICB9XG59KTtcblxuZGVmaW5lKHtcbiAgdGFnOiAnZGwnLFxuICBjdG9yOiBmdW5jdGlvbiBIVE1MRExpc3RFbGVtZW50KGRvYywgbG9jYWxOYW1lLCBwcmVmaXgpIHtcbiAgICBIVE1MRWxlbWVudC5jYWxsKHRoaXMsIGRvYywgbG9jYWxOYW1lLCBwcmVmaXgpO1xuICB9LFxuICBhdHRyaWJ1dGVzOiB7XG4gICAgLy8gT2Jzb2xldGVcbiAgICBjb21wYWN0OiBCb29sZWFuLFxuICB9XG59KTtcblxuZGVmaW5lKHtcbiAgdGFnOiAnZGF0YScsXG4gIGN0b3I6IGZ1bmN0aW9uIEhUTUxEYXRhRWxlbWVudChkb2MsIGxvY2FsTmFtZSwgcHJlZml4KSB7XG4gICAgSFRNTEVsZW1lbnQuY2FsbCh0aGlzLCBkb2MsIGxvY2FsTmFtZSwgcHJlZml4KTtcbiAgfSxcbiAgYXR0cmlidXRlczoge1xuICAgIHZhbHVlOiBTdHJpbmcsXG4gIH1cbn0pO1xuXG5kZWZpbmUoe1xuICB0YWc6ICdkYXRhbGlzdCcsXG4gIGN0b3I6IGZ1bmN0aW9uIEhUTUxEYXRhTGlzdEVsZW1lbnQoZG9jLCBsb2NhbE5hbWUsIHByZWZpeCkge1xuICAgIEhUTUxFbGVtZW50LmNhbGwodGhpcywgZG9jLCBsb2NhbE5hbWUsIHByZWZpeCk7XG4gIH1cbn0pO1xuXG5kZWZpbmUoe1xuICB0YWc6ICdkZXRhaWxzJyxcbiAgY3RvcjogZnVuY3Rpb24gSFRNTERldGFpbHNFbGVtZW50KGRvYywgbG9jYWxOYW1lLCBwcmVmaXgpIHtcbiAgICBIVE1MRWxlbWVudC5jYWxsKHRoaXMsIGRvYywgbG9jYWxOYW1lLCBwcmVmaXgpO1xuICB9LFxuICBhdHRyaWJ1dGVzOiB7XG4gICAgXCJvcGVuXCI6IEJvb2xlYW5cbiAgfVxufSk7XG5cbmRlZmluZSh7XG4gIHRhZzogJ2RpdicsXG4gIGN0b3I6IGZ1bmN0aW9uIEhUTUxEaXZFbGVtZW50KGRvYywgbG9jYWxOYW1lLCBwcmVmaXgpIHtcbiAgICBIVE1MRWxlbWVudC5jYWxsKHRoaXMsIGRvYywgbG9jYWxOYW1lLCBwcmVmaXgpO1xuICB9LFxuICBhdHRyaWJ1dGVzOiB7XG4gICAgLy8gT2Jzb2xldGVcbiAgICBhbGlnbjogU3RyaW5nXG4gIH1cbn0pO1xuXG5kZWZpbmUoe1xuICB0YWc6ICdlbWJlZCcsXG4gIGN0b3I6IGZ1bmN0aW9uIEhUTUxFbWJlZEVsZW1lbnQoZG9jLCBsb2NhbE5hbWUsIHByZWZpeCkge1xuICAgIEhUTUxFbGVtZW50LmNhbGwodGhpcywgZG9jLCBsb2NhbE5hbWUsIHByZWZpeCk7XG4gIH0sXG4gIGF0dHJpYnV0ZXM6IHtcbiAgICBzcmM6IFVSTCxcbiAgICB0eXBlOiBTdHJpbmcsXG4gICAgd2lkdGg6IFN0cmluZyxcbiAgICBoZWlnaHQ6IFN0cmluZyxcbiAgICAvLyBPYnNvbGV0ZVxuICAgIGFsaWduOiBTdHJpbmcsXG4gICAgbmFtZTogU3RyaW5nLFxuICB9XG59KTtcblxuZGVmaW5lKHtcbiAgdGFnOiAnZmllbGRzZXQnLFxuICBjdG9yOiBmdW5jdGlvbiBIVE1MRmllbGRTZXRFbGVtZW50KGRvYywgbG9jYWxOYW1lLCBwcmVmaXgpIHtcbiAgICBIVE1MRWxlbWVudC5jYWxsKHRoaXMsIGRvYywgbG9jYWxOYW1lLCBwcmVmaXgpO1xuICB9LFxuICBwcm9wczogZm9ybUFzc29jaWF0ZWRQcm9wcyxcbiAgYXR0cmlidXRlczoge1xuICAgIGRpc2FibGVkOiBCb29sZWFuLFxuICAgIG5hbWU6IFN0cmluZ1xuICB9XG59KTtcblxuZGVmaW5lKHtcbiAgdGFnOiAnZm9ybScsXG4gIGN0b3I6IGZ1bmN0aW9uIEhUTUxGb3JtRWxlbWVudChkb2MsIGxvY2FsTmFtZSwgcHJlZml4KSB7XG4gICAgSFRNTEVsZW1lbnQuY2FsbCh0aGlzLCBkb2MsIGxvY2FsTmFtZSwgcHJlZml4KTtcbiAgfSxcbiAgYXR0cmlidXRlczoge1xuICAgIGFjdGlvbjogU3RyaW5nLFxuICAgIGF1dG9jb21wbGV0ZToge3R5cGU6WydvbicsICdvZmYnXSwgbWlzc2luZzogJ29uJ30sXG4gICAgbmFtZTogU3RyaW5nLFxuICAgIGFjY2VwdENoYXJzZXQ6IHtuYW1lOiBcImFjY2VwdC1jaGFyc2V0XCJ9LFxuICAgIHRhcmdldDogU3RyaW5nLFxuICAgIG5vVmFsaWRhdGU6IEJvb2xlYW4sXG4gICAgbWV0aG9kOiB7IHR5cGU6IFtcImdldFwiLCBcInBvc3RcIiwgXCJkaWFsb2dcIl0sIGludmFsaWQ6ICdnZXQnLCBtaXNzaW5nOiAnZ2V0JyB9LFxuICAgIC8vIEJvdGggZW5jdHlwZSBhbmQgZW5jb2RpbmcgcmVmbGVjdCB0aGUgZW5jdHlwZSBjb250ZW50IGF0dHJpYnV0ZVxuICAgIGVuY3R5cGU6IHsgdHlwZTogW1wiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIsIFwibXVsdGlwYXJ0L2Zvcm0tZGF0YVwiLCBcInRleHQvcGxhaW5cIl0sIGludmFsaWQ6IFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIsIG1pc3Npbmc6IFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIgfSxcbiAgICBlbmNvZGluZzoge25hbWU6ICdlbmN0eXBlJywgdHlwZTogW1wiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIsIFwibXVsdGlwYXJ0L2Zvcm0tZGF0YVwiLCBcInRleHQvcGxhaW5cIl0sIGludmFsaWQ6IFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIsIG1pc3Npbmc6IFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIgfSxcbiAgfVxufSk7XG5cbmRlZmluZSh7XG4gIHRhZzogJ2hyJyxcbiAgY3RvcjogZnVuY3Rpb24gSFRNTEhSRWxlbWVudChkb2MsIGxvY2FsTmFtZSwgcHJlZml4KSB7XG4gICAgSFRNTEVsZW1lbnQuY2FsbCh0aGlzLCBkb2MsIGxvY2FsTmFtZSwgcHJlZml4KTtcbiAgfSxcbiAgYXR0cmlidXRlczoge1xuICAgIC8vIE9ic29sZXRlXG4gICAgYWxpZ246IFN0cmluZyxcbiAgICBjb2xvcjogU3RyaW5nLFxuICAgIG5vU2hhZGU6IEJvb2xlYW4sXG4gICAgc2l6ZTogU3RyaW5nLFxuICAgIHdpZHRoOiBTdHJpbmcsXG4gIH0sXG59KTtcblxuZGVmaW5lKHtcbiAgdGFnOiAnaGVhZCcsXG4gIGN0b3I6IGZ1bmN0aW9uIEhUTUxIZWFkRWxlbWVudChkb2MsIGxvY2FsTmFtZSwgcHJlZml4KSB7XG4gICAgSFRNTEVsZW1lbnQuY2FsbCh0aGlzLCBkb2MsIGxvY2FsTmFtZSwgcHJlZml4KTtcbiAgfVxufSk7XG5cbmRlZmluZSh7XG4gIHRhZ3M6IFsnaDEnLCdoMicsJ2gzJywnaDQnLCdoNScsJ2g2J10sXG4gIGN0b3I6IGZ1bmN0aW9uIEhUTUxIZWFkaW5nRWxlbWVudChkb2MsIGxvY2FsTmFtZSwgcHJlZml4KSB7XG4gICAgSFRNTEVsZW1lbnQuY2FsbCh0aGlzLCBkb2MsIGxvY2FsTmFtZSwgcHJlZml4KTtcbiAgfSxcbiAgYXR0cmlidXRlczoge1xuICAgIC8vIE9ic29sZXRlXG4gICAgYWxpZ246IFN0cmluZyxcbiAgfSxcbn0pO1xuXG5kZWZpbmUoe1xuICB0YWc6ICdodG1sJyxcbiAgY3RvcjogZnVuY3Rpb24gSFRNTEh0bWxFbGVtZW50KGRvYywgbG9jYWxOYW1lLCBwcmVmaXgpIHtcbiAgICBIVE1MRWxlbWVudC5jYWxsKHRoaXMsIGRvYywgbG9jYWxOYW1lLCBwcmVmaXgpO1xuICB9LFxuICBhdHRyaWJ1dGVzOiB7XG4gICAgLy8gT2Jzb2xldGVcbiAgICB2ZXJzaW9uOiBTdHJpbmdcbiAgfVxufSk7XG5cbmRlZmluZSh7XG4gIHRhZzogJ2lmcmFtZScsXG4gIGN0b3I6IGZ1bmN0aW9uIEhUTUxJRnJhbWVFbGVtZW50KGRvYywgbG9jYWxOYW1lLCBwcmVmaXgpIHtcbiAgICBIVE1MRWxlbWVudC5jYWxsKHRoaXMsIGRvYywgbG9jYWxOYW1lLCBwcmVmaXgpO1xuICAgIHZhciBXaW5kb3cgPSByZXF1aXJlKCcuL1dpbmRvdycpOyAvLyBBdm9pZCBjaXJjdWxhciBkZXBlbmRlbmNpZXMuXG4gICAgdGhpcy5fY29udGVudFdpbmRvdyA9IG5ldyBXaW5kb3coKTtcbiAgfSxcbiAgcHJvcHM6IHtcbiAgICBjb250ZW50V2luZG93OiB7IGdldDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fY29udGVudFdpbmRvdztcbiAgICB9IH0sXG4gICAgY29udGVudERvY3VtZW50OiB7IGdldDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb250ZW50V2luZG93LmRvY3VtZW50O1xuICAgIH0gfSxcbiAgfSxcbiAgYXR0cmlidXRlczoge1xuICAgIHNyYzogVVJMLFxuICAgIHNyY2RvYzogU3RyaW5nLFxuICAgIG5hbWU6IFN0cmluZyxcbiAgICB3aWR0aDogU3RyaW5nLFxuICAgIGhlaWdodDogU3RyaW5nLFxuICAgIC8vIFhYWDogc2FuZGJveCBpcyBhIHJlZmxlY3RlZCBzZXR0YWJsZSB0b2tlbiBsaXN0XG4gICAgc2VhbWxlc3M6IEJvb2xlYW4sXG4gICAgYWxsb3dGdWxsc2NyZWVuOiBCb29sZWFuLFxuICAgIGFsbG93VXNlck1lZGlhOiBCb29sZWFuLFxuICAgIGFsbG93UGF5bWVudFJlcXVlc3Q6IEJvb2xlYW4sXG4gICAgcmVmZXJyZXJQb2xpY3k6IFJFRkVSUkVSLFxuICAgIC8vIE9ic29sZXRlXG4gICAgYWxpZ246IFN0cmluZyxcbiAgICBzY3JvbGxpbmc6IFN0cmluZyxcbiAgICBmcmFtZUJvcmRlcjogU3RyaW5nLFxuICAgIGxvbmdEZXNjOiBVUkwsXG4gICAgbWFyZ2luSGVpZ2h0OiB7IHR5cGU6IFN0cmluZywgdHJlYXROdWxsQXNFbXB0eVN0cmluZzogdHJ1ZSB9LFxuICAgIG1hcmdpbldpZHRoOiB7IHR5cGU6IFN0cmluZywgdHJlYXROdWxsQXNFbXB0eVN0cmluZzogdHJ1ZSB9LFxuICB9XG59KTtcblxuZGVmaW5lKHtcbiAgdGFnOiAnaW1nJyxcbiAgY3RvcjogZnVuY3Rpb24gSFRNTEltYWdlRWxlbWVudChkb2MsIGxvY2FsTmFtZSwgcHJlZml4KSB7XG4gICAgSFRNTEVsZW1lbnQuY2FsbCh0aGlzLCBkb2MsIGxvY2FsTmFtZSwgcHJlZml4KTtcbiAgfSxcbiAgYXR0cmlidXRlczoge1xuICAgIGFsdDogU3RyaW5nLFxuICAgIHNyYzogVVJMLFxuICAgIHNyY3NldDogU3RyaW5nLFxuICAgIGNyb3NzT3JpZ2luOiBDT1JTLFxuICAgIHVzZU1hcDogU3RyaW5nLFxuICAgIGlzTWFwOiBCb29sZWFuLFxuICAgIGhlaWdodDogeyB0eXBlOiBcInVuc2lnbmVkIGxvbmdcIiwgZGVmYXVsdDogMCB9LFxuICAgIHdpZHRoOiB7IHR5cGU6IFwidW5zaWduZWQgbG9uZ1wiLCBkZWZhdWx0OiAwIH0sXG4gICAgcmVmZXJyZXJQb2xpY3k6IFJFRkVSUkVSLFxuICAgIC8vIE9ic29sZXRlOlxuICAgIG5hbWU6IFN0cmluZyxcbiAgICBsb3dzcmM6IFVSTCxcbiAgICBhbGlnbjogU3RyaW5nLFxuICAgIGhzcGFjZTogeyB0eXBlOiBcInVuc2lnbmVkIGxvbmdcIiwgZGVmYXVsdDogMCB9LFxuICAgIHZzcGFjZTogeyB0eXBlOiBcInVuc2lnbmVkIGxvbmdcIiwgZGVmYXVsdDogMCB9LFxuICAgIGxvbmdEZXNjOiBVUkwsXG4gICAgYm9yZGVyOiB7IHR5cGU6IFN0cmluZywgdHJlYXROdWxsQXNFbXB0eVN0cmluZzogdHJ1ZSB9LFxuICB9XG59KTtcblxuZGVmaW5lKHtcbiAgdGFnOiAnaW5wdXQnLFxuICBjdG9yOiBmdW5jdGlvbiBIVE1MSW5wdXRFbGVtZW50KGRvYywgbG9jYWxOYW1lLCBwcmVmaXgpIHtcbiAgICBIVE1MRWxlbWVudC5jYWxsKHRoaXMsIGRvYywgbG9jYWxOYW1lLCBwcmVmaXgpO1xuICB9LFxuICBwcm9wczoge1xuICAgIGZvcm06IGZvcm1Bc3NvY2lhdGVkUHJvcHMuZm9ybSxcbiAgICBfcG9zdF9jbGlja19hY3RpdmF0aW9uX3N0ZXBzOiB7IHZhbHVlOiBmdW5jdGlvbihlKSB7XG4gICAgICBpZiAodGhpcy50eXBlID09PSAnY2hlY2tib3gnKSB7XG4gICAgICAgIHRoaXMuY2hlY2tlZCA9ICF0aGlzLmNoZWNrZWQ7XG4gICAgICB9XG4gICAgICBlbHNlIGlmICh0aGlzLnR5cGUgPT09ICdyYWRpbycpIHtcbiAgICAgICAgdmFyIGdyb3VwID0gdGhpcy5mb3JtLmdldEVsZW1lbnRzQnlOYW1lKHRoaXMubmFtZSk7XG4gICAgICAgIGZvciAodmFyIGk9Z3JvdXAubGVuZ3RoLTE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgdmFyIGVsID0gZ3JvdXBbaV07XG4gICAgICAgICAgZWwuY2hlY2tlZCA9IChlbCA9PT0gdGhpcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9fSxcbiAgfSxcbiAgYXR0cmlidXRlczoge1xuICAgIG5hbWU6IFN0cmluZyxcbiAgICBkaXNhYmxlZDogQm9vbGVhbixcbiAgICBhdXRvZm9jdXM6IEJvb2xlYW4sXG4gICAgYWNjZXB0OiBTdHJpbmcsXG4gICAgYWx0OiBTdHJpbmcsXG4gICAgbWF4OiBTdHJpbmcsXG4gICAgbWluOiBTdHJpbmcsXG4gICAgcGF0dGVybjogU3RyaW5nLFxuICAgIHBsYWNlaG9sZGVyOiBTdHJpbmcsXG4gICAgc3RlcDogU3RyaW5nLFxuICAgIGRpck5hbWU6IFN0cmluZyxcbiAgICBkZWZhdWx0VmFsdWU6IHtuYW1lOiAndmFsdWUnfSxcbiAgICBtdWx0aXBsZTogQm9vbGVhbixcbiAgICByZXF1aXJlZDogQm9vbGVhbixcbiAgICByZWFkT25seTogQm9vbGVhbixcbiAgICBjaGVja2VkOiBCb29sZWFuLFxuICAgIHZhbHVlOiBTdHJpbmcsXG4gICAgc3JjOiBVUkwsXG4gICAgZGVmYXVsdENoZWNrZWQ6IHtuYW1lOiAnY2hlY2tlZCcsIHR5cGU6IEJvb2xlYW59LFxuICAgIHNpemU6IHt0eXBlOiAndW5zaWduZWQgbG9uZycsIGRlZmF1bHQ6IDIwLCBtaW46IDEsIHNldG1pbjogMX0sXG4gICAgbWF4TGVuZ3RoOiB7dHlwZTogJ3Vuc2lnbmVkIGxvbmcnLCBtaW46IDAsIHNldG1pbjogMCwgZGVmYXVsdDogLTF9LFxuICAgIGF1dG9jb21wbGV0ZTogU3RyaW5nLCAvLyBJdCdzIGNvbXBsaWNhdGVkXG4gICAgdHlwZTogeyB0eXBlOlxuICAgICAgICAgICAgW1widGV4dFwiLCBcImhpZGRlblwiLCBcInNlYXJjaFwiLCBcInRlbFwiLCBcInVybFwiLCBcImVtYWlsXCIsIFwicGFzc3dvcmRcIixcbiAgICAgICAgICAgICBcImRhdGV0aW1lXCIsIFwiZGF0ZVwiLCBcIm1vbnRoXCIsIFwid2Vla1wiLCBcInRpbWVcIiwgXCJkYXRldGltZS1sb2NhbFwiLFxuICAgICAgICAgICAgIFwibnVtYmVyXCIsIFwicmFuZ2VcIiwgXCJjb2xvclwiLCBcImNoZWNrYm94XCIsIFwicmFkaW9cIiwgXCJmaWxlXCIsIFwic3VibWl0XCIsXG4gICAgICAgICAgICAgXCJpbWFnZVwiLCBcInJlc2V0XCIsIFwiYnV0dG9uXCJdLFxuICAgICAgICAgICAgbWlzc2luZzogJ3RleHQnIH0sXG4gICAgZm9ybVRhcmdldDogU3RyaW5nLFxuICAgIGZvcm1Ob1ZhbGlkYXRlOiBCb29sZWFuLFxuICAgIGZvcm1NZXRob2Q6IHsgdHlwZTogW1wiZ2V0XCIsIFwicG9zdFwiXSwgaW52YWxpZDogJ2dldCcsIG1pc3Npbmc6ICcnIH0sXG4gICAgZm9ybUVuY3R5cGU6IHsgdHlwZTogW1wiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIsIFwibXVsdGlwYXJ0L2Zvcm0tZGF0YVwiLCBcInRleHQvcGxhaW5cIl0sIGludmFsaWQ6IFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIsIG1pc3Npbmc6ICcnIH0sXG4gICAgaW5wdXRNb2RlOiB7IHR5cGU6IFsgXCJ2ZXJiYXRpbVwiLCBcImxhdGluXCIsIFwibGF0aW4tbmFtZVwiLCBcImxhdGluLXByb3NlXCIsIFwiZnVsbC13aWR0aC1sYXRpblwiLCBcImthbmFcIiwgXCJrYW5hLW5hbWVcIiwgXCJrYXRha2FuYVwiLCBcIm51bWVyaWNcIiwgXCJ0ZWxcIiwgXCJlbWFpbFwiLCBcInVybFwiIF0sIG1pc3Npbmc6ICcnIH0sXG4gICAgLy8gT2Jzb2xldGVcbiAgICBhbGlnbjogU3RyaW5nLFxuICAgIHVzZU1hcDogU3RyaW5nLFxuICB9XG59KTtcblxuZGVmaW5lKHtcbiAgdGFnOiAna2V5Z2VuJyxcbiAgY3RvcjogZnVuY3Rpb24gSFRNTEtleWdlbkVsZW1lbnQoZG9jLCBsb2NhbE5hbWUsIHByZWZpeCkge1xuICAgIEhUTUxFbGVtZW50LmNhbGwodGhpcywgZG9jLCBsb2NhbE5hbWUsIHByZWZpeCk7XG4gIH0sXG4gIHByb3BzOiBmb3JtQXNzb2NpYXRlZFByb3BzLFxuICBhdHRyaWJ1dGVzOiB7XG4gICAgbmFtZTogU3RyaW5nLFxuICAgIGRpc2FibGVkOiBCb29sZWFuLFxuICAgIGF1dG9mb2N1czogQm9vbGVhbixcbiAgICBjaGFsbGVuZ2U6IFN0cmluZyxcbiAgICBrZXl0eXBlOiB7IHR5cGU6W1wicnNhXCJdLCBtaXNzaW5nOiAnJyB9LFxuICB9XG59KTtcblxuZGVmaW5lKHtcbiAgdGFnOiAnbGknLFxuICBjdG9yOiBmdW5jdGlvbiBIVE1MTElFbGVtZW50KGRvYywgbG9jYWxOYW1lLCBwcmVmaXgpIHtcbiAgICBIVE1MRWxlbWVudC5jYWxsKHRoaXMsIGRvYywgbG9jYWxOYW1lLCBwcmVmaXgpO1xuICB9LFxuICBhdHRyaWJ1dGVzOiB7XG4gICAgdmFsdWU6IHt0eXBlOiBcImxvbmdcIiwgZGVmYXVsdDogMH0sXG4gICAgLy8gT2Jzb2xldGVcbiAgICB0eXBlOiBTdHJpbmcsXG4gIH1cbn0pO1xuXG5kZWZpbmUoe1xuICB0YWc6ICdsYWJlbCcsXG4gIGN0b3I6IGZ1bmN0aW9uIEhUTUxMYWJlbEVsZW1lbnQoZG9jLCBsb2NhbE5hbWUsIHByZWZpeCkge1xuICAgIEhUTUxFbGVtZW50LmNhbGwodGhpcywgZG9jLCBsb2NhbE5hbWUsIHByZWZpeCk7XG4gIH0sXG4gIHByb3BzOiBmb3JtQXNzb2NpYXRlZFByb3BzLFxuICBhdHRyaWJ1dGVzOiB7XG4gICAgaHRtbEZvcjoge25hbWU6ICdmb3InLCB0eXBlOiBTdHJpbmd9XG4gIH1cbn0pO1xuXG5kZWZpbmUoe1xuICB0YWc6ICdsZWdlbmQnLFxuICBjdG9yOiBmdW5jdGlvbiBIVE1MTGVnZW5kRWxlbWVudChkb2MsIGxvY2FsTmFtZSwgcHJlZml4KSB7XG4gICAgSFRNTEVsZW1lbnQuY2FsbCh0aGlzLCBkb2MsIGxvY2FsTmFtZSwgcHJlZml4KTtcbiAgfSxcbiAgYXR0cmlidXRlczoge1xuICAgIC8vIE9ic29sZXRlXG4gICAgYWxpZ246IFN0cmluZ1xuICB9LFxufSk7XG5cbmRlZmluZSh7XG4gIHRhZzogJ2xpbmsnLFxuICBjdG9yOiBmdW5jdGlvbiBIVE1MTGlua0VsZW1lbnQoZG9jLCBsb2NhbE5hbWUsIHByZWZpeCkge1xuICAgIEhUTUxFbGVtZW50LmNhbGwodGhpcywgZG9jLCBsb2NhbE5hbWUsIHByZWZpeCk7XG4gIH0sXG4gIGF0dHJpYnV0ZXM6IHtcbiAgICAvLyBYWFggUmVmbGVjdCBET01TZXR0YWJsZVRva2VuTGlzdCBzaXplcyBhbHNvIERPTVRva2VuTGlzdCByZWxMaXN0XG4gICAgaHJlZjogVVJMLFxuICAgIHJlbDogU3RyaW5nLFxuICAgIG1lZGlhOiBTdHJpbmcsXG4gICAgaHJlZmxhbmc6IFN0cmluZyxcbiAgICB0eXBlOiBTdHJpbmcsXG4gICAgY3Jvc3NPcmlnaW46IENPUlMsXG4gICAgbm9uY2U6IFN0cmluZyxcbiAgICBpbnRlZ3JpdHk6IFN0cmluZyxcbiAgICByZWZlcnJlclBvbGljeTogUkVGRVJSRVIsXG4gICAgLy8gT2Jzb2xldGVcbiAgICBjaGFyc2V0OiBTdHJpbmcsXG4gICAgcmV2OiBTdHJpbmcsXG4gICAgdGFyZ2V0OiBTdHJpbmcsXG4gIH1cbn0pO1xuXG5kZWZpbmUoe1xuICB0YWc6ICdtYXAnLFxuICBjdG9yOiBmdW5jdGlvbiBIVE1MTWFwRWxlbWVudChkb2MsIGxvY2FsTmFtZSwgcHJlZml4KSB7XG4gICAgSFRNTEVsZW1lbnQuY2FsbCh0aGlzLCBkb2MsIGxvY2FsTmFtZSwgcHJlZml4KTtcbiAgfSxcbiAgYXR0cmlidXRlczoge1xuICAgIG5hbWU6IFN0cmluZ1xuICB9XG59KTtcblxuZGVmaW5lKHtcbiAgdGFnOiAnbWVudScsXG4gIGN0b3I6IGZ1bmN0aW9uIEhUTUxNZW51RWxlbWVudChkb2MsIGxvY2FsTmFtZSwgcHJlZml4KSB7XG4gICAgSFRNTEVsZW1lbnQuY2FsbCh0aGlzLCBkb2MsIGxvY2FsTmFtZSwgcHJlZml4KTtcbiAgfSxcbiAgYXR0cmlidXRlczoge1xuICAgIC8vIFhYWDogbm90IHF1aXRlIHJpZ2h0LCBkZWZhdWx0IHNob3VsZCBiZSBwb3B1cCBpZiBwYXJlbnQgZWxlbWVudCBpc1xuICAgIC8vIHBvcHVwLlxuICAgIHR5cGU6IHsgdHlwZTogWyAnY29udGV4dCcsICdwb3B1cCcsICd0b29sYmFyJyBdLCBtaXNzaW5nOiAndG9vbGJhcicgfSxcbiAgICBsYWJlbDogU3RyaW5nLFxuICAgIC8vIE9ic29sZXRlXG4gICAgY29tcGFjdDogQm9vbGVhbixcbiAgfVxufSk7XG5cbmRlZmluZSh7XG4gIHRhZzogJ21ldGEnLFxuICBjdG9yOiBmdW5jdGlvbiBIVE1MTWV0YUVsZW1lbnQoZG9jLCBsb2NhbE5hbWUsIHByZWZpeCkge1xuICAgIEhUTUxFbGVtZW50LmNhbGwodGhpcywgZG9jLCBsb2NhbE5hbWUsIHByZWZpeCk7XG4gIH0sXG4gIGF0dHJpYnV0ZXM6IHtcbiAgICBuYW1lOiBTdHJpbmcsXG4gICAgY29udGVudDogU3RyaW5nLFxuICAgIGh0dHBFcXVpdjoge25hbWU6ICdodHRwLWVxdWl2JywgdHlwZTogU3RyaW5nfSxcbiAgICAvLyBPYnNvbGV0ZVxuICAgIHNjaGVtZTogU3RyaW5nLFxuICB9XG59KTtcblxuZGVmaW5lKHtcbiAgdGFnOiAnbWV0ZXInLFxuICBjdG9yOiBmdW5jdGlvbiBIVE1MTWV0ZXJFbGVtZW50KGRvYywgbG9jYWxOYW1lLCBwcmVmaXgpIHtcbiAgICBIVE1MRWxlbWVudC5jYWxsKHRoaXMsIGRvYywgbG9jYWxOYW1lLCBwcmVmaXgpO1xuICB9LFxuICBwcm9wczogZm9ybUFzc29jaWF0ZWRQcm9wc1xufSk7XG5cbmRlZmluZSh7XG4gIHRhZ3M6IFsnaW5zJywgJ2RlbCddLFxuICBjdG9yOiBmdW5jdGlvbiBIVE1MTW9kRWxlbWVudChkb2MsIGxvY2FsTmFtZSwgcHJlZml4KSB7XG4gICAgSFRNTEVsZW1lbnQuY2FsbCh0aGlzLCBkb2MsIGxvY2FsTmFtZSwgcHJlZml4KTtcbiAgfSxcbiAgYXR0cmlidXRlczoge1xuICAgIGNpdGU6IFVSTCxcbiAgICBkYXRlVGltZTogU3RyaW5nXG4gIH1cbn0pO1xuXG5kZWZpbmUoe1xuICB0YWc6ICdvbCcsXG4gIGN0b3I6IGZ1bmN0aW9uIEhUTUxPTGlzdEVsZW1lbnQoZG9jLCBsb2NhbE5hbWUsIHByZWZpeCkge1xuICAgIEhUTUxFbGVtZW50LmNhbGwodGhpcywgZG9jLCBsb2NhbE5hbWUsIHByZWZpeCk7XG4gIH0sXG4gIHByb3BzOiB7XG4gICAgLy8gVXRpbGl0eSBmdW5jdGlvbiAoc2VlIHRoZSBzdGFydCBhdHRyaWJ1dGUgZGVmYXVsdCB2YWx1ZSkuIFJldHVybnNcbiAgICAvLyB0aGUgbnVtYmVyIG9mIDxsaT4gY2hpbGRyZW4gb2YgdGhpcyBlbGVtZW50XG4gICAgX251bWl0ZW1zOiB7IGdldDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgaXRlbXMgPSAwO1xuICAgICAgdGhpcy5jaGlsZE5vZGVzLmZvckVhY2goZnVuY3Rpb24obikge1xuICAgICAgICBpZiAobi5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUgJiYgbi50YWdOYW1lID09PSBcIkxJXCIpXG4gICAgICAgICAgaXRlbXMrKztcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGl0ZW1zO1xuICAgIH19XG4gIH0sXG4gIGF0dHJpYnV0ZXM6IHtcbiAgICB0eXBlOiBTdHJpbmcsXG4gICAgcmV2ZXJzZWQ6IEJvb2xlYW4sXG4gICAgc3RhcnQ6IHtcbiAgICAgIHR5cGU6IFwibG9uZ1wiLFxuICAgICAgZGVmYXVsdDogZnVuY3Rpb24oKSB7XG4gICAgICAgLy8gVGhlIGRlZmF1bHQgdmFsdWUgb2YgdGhlIHN0YXJ0IGF0dHJpYnV0ZSBpcyAxIHVubGVzcyB0aGUgbGlzdCBpc1xuICAgICAgIC8vIHJldmVyc2VkLiBUaGVuIGl0IGlzIHRoZSAjIG9mIGxpIGNoaWxkcmVuXG4gICAgICAgaWYgKHRoaXMucmV2ZXJzZWQpXG4gICAgICAgICByZXR1cm4gdGhpcy5fbnVtaXRlbXM7XG4gICAgICAgZWxzZVxuICAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9XG4gICAgfSxcbiAgICAvLyBPYnNvbGV0ZVxuICAgIGNvbXBhY3Q6IEJvb2xlYW4sXG4gIH1cbn0pO1xuXG5kZWZpbmUoe1xuICB0YWc6ICdvYmplY3QnLFxuICBjdG9yOiBmdW5jdGlvbiBIVE1MT2JqZWN0RWxlbWVudChkb2MsIGxvY2FsTmFtZSwgcHJlZml4KSB7XG4gICAgSFRNTEVsZW1lbnQuY2FsbCh0aGlzLCBkb2MsIGxvY2FsTmFtZSwgcHJlZml4KTtcbiAgfSxcbiAgcHJvcHM6IGZvcm1Bc3NvY2lhdGVkUHJvcHMsXG4gIGF0dHJpYnV0ZXM6IHtcbiAgICBkYXRhOiBVUkwsXG4gICAgdHlwZTogU3RyaW5nLFxuICAgIG5hbWU6IFN0cmluZyxcbiAgICB1c2VNYXA6IFN0cmluZyxcbiAgICB0eXBlTXVzdE1hdGNoOiBCb29sZWFuLFxuICAgIHdpZHRoOiBTdHJpbmcsXG4gICAgaGVpZ2h0OiBTdHJpbmcsXG4gICAgLy8gT2Jzb2xldGVcbiAgICBhbGlnbjogU3RyaW5nLFxuICAgIGFyY2hpdmU6IFN0cmluZyxcbiAgICBjb2RlOiBTdHJpbmcsXG4gICAgZGVjbGFyZTogQm9vbGVhbixcbiAgICBoc3BhY2U6IHsgdHlwZTogXCJ1bnNpZ25lZCBsb25nXCIsIGRlZmF1bHQ6IDAgfSxcbiAgICBzdGFuZGJ5OiBTdHJpbmcsXG4gICAgdnNwYWNlOiB7IHR5cGU6IFwidW5zaWduZWQgbG9uZ1wiLCBkZWZhdWx0OiAwIH0sXG4gICAgY29kZUJhc2U6IFVSTCxcbiAgICBjb2RlVHlwZTogU3RyaW5nLFxuICAgIGJvcmRlcjogeyB0eXBlOiBTdHJpbmcsIHRyZWF0TnVsbEFzRW1wdHlTdHJpbmc6IHRydWUgfSxcbiAgfVxufSk7XG5cbmRlZmluZSh7XG4gIHRhZzogJ29wdGdyb3VwJyxcbiAgY3RvcjogZnVuY3Rpb24gSFRNTE9wdEdyb3VwRWxlbWVudChkb2MsIGxvY2FsTmFtZSwgcHJlZml4KSB7XG4gICAgSFRNTEVsZW1lbnQuY2FsbCh0aGlzLCBkb2MsIGxvY2FsTmFtZSwgcHJlZml4KTtcbiAgfSxcbiAgYXR0cmlidXRlczoge1xuICAgIGRpc2FibGVkOiBCb29sZWFuLFxuICAgIGxhYmVsOiBTdHJpbmdcbiAgfVxufSk7XG5cbmRlZmluZSh7XG4gIHRhZzogJ29wdGlvbicsXG4gIGN0b3I6IGZ1bmN0aW9uIEhUTUxPcHRpb25FbGVtZW50KGRvYywgbG9jYWxOYW1lLCBwcmVmaXgpIHtcbiAgICBIVE1MRWxlbWVudC5jYWxsKHRoaXMsIGRvYywgbG9jYWxOYW1lLCBwcmVmaXgpO1xuICB9LFxuICBwcm9wczoge1xuICAgIGZvcm06IHsgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBwID0gdGhpcy5wYXJlbnROb2RlO1xuICAgICAgd2hpbGUgKHAgJiYgcC5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUpIHtcbiAgICAgICAgaWYgKHAubG9jYWxOYW1lID09PSAnc2VsZWN0JykgcmV0dXJuIHAuZm9ybTtcbiAgICAgICAgcCA9IHAucGFyZW50Tm9kZTtcbiAgICAgIH1cbiAgICB9fVxuICB9LFxuICBhdHRyaWJ1dGVzOiB7XG4gICAgZGlzYWJsZWQ6IEJvb2xlYW4sXG4gICAgZGVmYXVsdFNlbGVjdGVkOiB7bmFtZTogJ3NlbGVjdGVkJywgdHlwZTogQm9vbGVhbn0sXG4gICAgbGFiZWw6IFN0cmluZyxcbiAgICB2YWx1ZTogU3RyaW5nLFxuICB9XG59KTtcblxuZGVmaW5lKHtcbiAgdGFnOiAnb3V0cHV0JyxcbiAgY3RvcjogZnVuY3Rpb24gSFRNTE91dHB1dEVsZW1lbnQoZG9jLCBsb2NhbE5hbWUsIHByZWZpeCkge1xuICAgIEhUTUxFbGVtZW50LmNhbGwodGhpcywgZG9jLCBsb2NhbE5hbWUsIHByZWZpeCk7XG4gIH0sXG4gIHByb3BzOiBmb3JtQXNzb2NpYXRlZFByb3BzLFxuICBhdHRyaWJ1dGVzOiB7XG4gICAgLy8gWFhYIFJlZmxlY3QgZm9yL2h0bWxGb3IgYXMgYSBzZXR0YWJsZSB0b2tlbiBsaXN0XG4gICAgbmFtZTogU3RyaW5nXG4gIH1cbn0pO1xuXG5kZWZpbmUoe1xuICB0YWc6ICdwJyxcbiAgY3RvcjogZnVuY3Rpb24gSFRNTFBhcmFncmFwaEVsZW1lbnQoZG9jLCBsb2NhbE5hbWUsIHByZWZpeCkge1xuICAgIEhUTUxFbGVtZW50LmNhbGwodGhpcywgZG9jLCBsb2NhbE5hbWUsIHByZWZpeCk7XG4gIH0sXG4gIGF0dHJpYnV0ZXM6IHtcbiAgICAvLyBPYnNvbGV0ZVxuICAgIGFsaWduOiBTdHJpbmdcbiAgfVxufSk7XG5cbmRlZmluZSh7XG4gIHRhZzogJ3BhcmFtJyxcbiAgY3RvcjogZnVuY3Rpb24gSFRNTFBhcmFtRWxlbWVudChkb2MsIGxvY2FsTmFtZSwgcHJlZml4KSB7XG4gICAgSFRNTEVsZW1lbnQuY2FsbCh0aGlzLCBkb2MsIGxvY2FsTmFtZSwgcHJlZml4KTtcbiAgfSxcbiAgYXR0cmlidXRlczoge1xuICAgIG5hbWU6IFN0cmluZyxcbiAgICB2YWx1ZTogU3RyaW5nLFxuICAgIC8vIE9ic29sZXRlXG4gICAgdHlwZTogU3RyaW5nLFxuICAgIHZhbHVlVHlwZTogU3RyaW5nLFxuICB9XG59KTtcblxuZGVmaW5lKHtcbiAgdGFnczogWydwcmUnLC8qbGVnYWN5IGVsZW1lbnRzOiovJ2xpc3RpbmcnLCd4bXAnXSxcbiAgY3RvcjogZnVuY3Rpb24gSFRNTFByZUVsZW1lbnQoZG9jLCBsb2NhbE5hbWUsIHByZWZpeCkge1xuICAgIEhUTUxFbGVtZW50LmNhbGwodGhpcywgZG9jLCBsb2NhbE5hbWUsIHByZWZpeCk7XG4gIH0sXG4gIGF0dHJpYnV0ZXM6IHtcbiAgICAvLyBPYnNvbGV0ZVxuICAgIHdpZHRoOiB7IHR5cGU6IFwibG9uZ1wiLCBkZWZhdWx0OiAwIH0sXG4gIH1cbn0pO1xuXG5kZWZpbmUoe1xuICB0YWc6ICdwcm9ncmVzcycsXG4gIGN0b3I6IGZ1bmN0aW9uIEhUTUxQcm9ncmVzc0VsZW1lbnQoZG9jLCBsb2NhbE5hbWUsIHByZWZpeCkge1xuICAgIEhUTUxFbGVtZW50LmNhbGwodGhpcywgZG9jLCBsb2NhbE5hbWUsIHByZWZpeCk7XG4gIH0sXG4gIHByb3BzOiBmb3JtQXNzb2NpYXRlZFByb3BzLFxuICBhdHRyaWJ1dGVzOiB7XG4gICAgbWF4OiB7dHlwZTogTnVtYmVyLCBmbG9hdDogdHJ1ZSwgZGVmYXVsdDogMS4wLCBtaW46IDB9XG4gIH1cbn0pO1xuXG5kZWZpbmUoe1xuICB0YWdzOiBbJ3EnLCAnYmxvY2txdW90ZSddLFxuICBjdG9yOiBmdW5jdGlvbiBIVE1MUXVvdGVFbGVtZW50KGRvYywgbG9jYWxOYW1lLCBwcmVmaXgpIHtcbiAgICBIVE1MRWxlbWVudC5jYWxsKHRoaXMsIGRvYywgbG9jYWxOYW1lLCBwcmVmaXgpO1xuICB9LFxuICBhdHRyaWJ1dGVzOiB7XG4gICAgY2l0ZTogVVJMXG4gIH1cbn0pO1xuXG5kZWZpbmUoe1xuICB0YWc6ICdzY3JpcHQnLFxuICBjdG9yOiBmdW5jdGlvbiBIVE1MU2NyaXB0RWxlbWVudChkb2MsIGxvY2FsTmFtZSwgcHJlZml4KSB7XG4gICAgSFRNTEVsZW1lbnQuY2FsbCh0aGlzLCBkb2MsIGxvY2FsTmFtZSwgcHJlZml4KTtcbiAgfSxcbiAgcHJvcHM6IHtcbiAgICB0ZXh0OiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcyA9IFwiXCI7XG4gICAgICAgIGZvcih2YXIgaSA9IDAsIG4gPSB0aGlzLmNoaWxkTm9kZXMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgdmFyIGNoaWxkID0gdGhpcy5jaGlsZE5vZGVzW2ldO1xuICAgICAgICAgIGlmIChjaGlsZC5ub2RlVHlwZSA9PT0gTm9kZS5URVhUX05PREUpXG4gICAgICAgICAgICBzICs9IGNoaWxkLl9kYXRhO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVDaGlsZHJlbigpO1xuICAgICAgICBpZiAodmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IFwiXCIpIHtcbiAgICAgICAgICB0aGlzLmFwcGVuZENoaWxkKHRoaXMub3duZXJEb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh2YWx1ZSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBhdHRyaWJ1dGVzOiB7XG4gICAgc3JjOiBVUkwsXG4gICAgdHlwZTogU3RyaW5nLFxuICAgIGNoYXJzZXQ6IFN0cmluZyxcbiAgICBkZWZlcjogQm9vbGVhbixcbiAgICBhc3luYzogQm9vbGVhbixcbiAgICBjcm9zc09yaWdpbjogQ09SUyxcbiAgICBub25jZTogU3RyaW5nLFxuICAgIGludGVncml0eTogU3RyaW5nLFxuICB9XG59KTtcblxuZGVmaW5lKHtcbiAgdGFnOiAnc2VsZWN0JyxcbiAgY3RvcjogZnVuY3Rpb24gSFRNTFNlbGVjdEVsZW1lbnQoZG9jLCBsb2NhbE5hbWUsIHByZWZpeCkge1xuICAgIEhUTUxFbGVtZW50LmNhbGwodGhpcywgZG9jLCBsb2NhbE5hbWUsIHByZWZpeCk7XG4gIH0sXG4gIHByb3BzOiB7XG4gICAgZm9ybTogZm9ybUFzc29jaWF0ZWRQcm9wcy5mb3JtLFxuICAgIG9wdGlvbnM6IHsgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdvcHRpb24nKTtcbiAgICB9fVxuICB9LFxuICBhdHRyaWJ1dGVzOiB7XG4gICAgbmFtZTogU3RyaW5nLFxuICAgIGRpc2FibGVkOiBCb29sZWFuLFxuICAgIGF1dG9mb2N1czogQm9vbGVhbixcbiAgICBtdWx0aXBsZTogQm9vbGVhbixcbiAgICByZXF1aXJlZDogQm9vbGVhbixcbiAgICBzaXplOiB7dHlwZTogXCJ1bnNpZ25lZCBsb25nXCIsIGRlZmF1bHQ6IDB9XG4gIH1cbn0pO1xuXG5kZWZpbmUoe1xuICB0YWc6ICdzb3VyY2UnLFxuICBjdG9yOiBmdW5jdGlvbiBIVE1MU291cmNlRWxlbWVudChkb2MsIGxvY2FsTmFtZSwgcHJlZml4KSB7XG4gICAgSFRNTEVsZW1lbnQuY2FsbCh0aGlzLCBkb2MsIGxvY2FsTmFtZSwgcHJlZml4KTtcbiAgfSxcbiAgYXR0cmlidXRlczoge1xuICAgIHNyYzogVVJMLFxuICAgIHR5cGU6IFN0cmluZyxcbiAgICBtZWRpYTogU3RyaW5nXG4gIH1cbn0pO1xuXG5kZWZpbmUoe1xuICB0YWc6ICdzcGFuJyxcbiAgY3RvcjogZnVuY3Rpb24gSFRNTFNwYW5FbGVtZW50KGRvYywgbG9jYWxOYW1lLCBwcmVmaXgpIHtcbiAgICBIVE1MRWxlbWVudC5jYWxsKHRoaXMsIGRvYywgbG9jYWxOYW1lLCBwcmVmaXgpO1xuICB9XG59KTtcblxuZGVmaW5lKHtcbiAgdGFnOiAnc3R5bGUnLFxuICBjdG9yOiBmdW5jdGlvbiBIVE1MU3R5bGVFbGVtZW50KGRvYywgbG9jYWxOYW1lLCBwcmVmaXgpIHtcbiAgICBIVE1MRWxlbWVudC5jYWxsKHRoaXMsIGRvYywgbG9jYWxOYW1lLCBwcmVmaXgpO1xuICB9LFxuICBhdHRyaWJ1dGVzOiB7XG4gICAgbWVkaWE6IFN0cmluZyxcbiAgICB0eXBlOiBTdHJpbmcsXG4gICAgc2NvcGVkOiBCb29sZWFuXG4gIH1cbn0pO1xuXG5kZWZpbmUoe1xuICB0YWc6ICdjYXB0aW9uJyxcbiAgY3RvcjogZnVuY3Rpb24gSFRNTFRhYmxlQ2FwdGlvbkVsZW1lbnQoZG9jLCBsb2NhbE5hbWUsIHByZWZpeCkge1xuICAgIEhUTUxFbGVtZW50LmNhbGwodGhpcywgZG9jLCBsb2NhbE5hbWUsIHByZWZpeCk7XG4gIH0sXG4gIGF0dHJpYnV0ZXM6IHtcbiAgICAvLyBPYnNvbGV0ZVxuICAgIGFsaWduOiBTdHJpbmcsXG4gIH1cbn0pO1xuXG5cbmRlZmluZSh7XG4gIGN0b3I6IGZ1bmN0aW9uIEhUTUxUYWJsZUNlbGxFbGVtZW50KGRvYywgbG9jYWxOYW1lLCBwcmVmaXgpIHtcbiAgICBIVE1MRWxlbWVudC5jYWxsKHRoaXMsIGRvYywgbG9jYWxOYW1lLCBwcmVmaXgpO1xuICB9LFxuICBhdHRyaWJ1dGVzOiB7XG4gICAgY29sU3Bhbjoge3R5cGU6IFwidW5zaWduZWQgbG9uZ1wiLCBkZWZhdWx0OiAxfSxcbiAgICByb3dTcGFuOiB7dHlwZTogXCJ1bnNpZ25lZCBsb25nXCIsIGRlZmF1bHQ6IDF9LFxuICAgIC8vWFhYIEFsc28gcmVmbGVjdCBzZXR0YWJsZSB0b2tlbiBsaXN0IGhlYWRlcnNcbiAgICBzY29wZTogeyB0eXBlOiBbJ3JvdycsJ2NvbCcsJ3Jvd2dyb3VwJywnY29sZ3JvdXAnXSwgbWlzc2luZzogJycgfSxcbiAgICBhYmJyOiBTdHJpbmcsXG4gICAgLy8gT2Jzb2xldGVcbiAgICBhbGlnbjogU3RyaW5nLFxuICAgIGF4aXM6IFN0cmluZyxcbiAgICBoZWlnaHQ6IFN0cmluZyxcbiAgICB3aWR0aDogU3RyaW5nLFxuICAgIGNoOiB7IG5hbWU6ICdjaGFyJywgdHlwZTogU3RyaW5nIH0sXG4gICAgY2hPZmY6IHsgbmFtZTogJ2NoYXJvZmYnLCB0eXBlOiBTdHJpbmcgfSxcbiAgICBub1dyYXA6IEJvb2xlYW4sXG4gICAgdkFsaWduOiBTdHJpbmcsXG4gICAgYmdDb2xvcjogeyB0eXBlOiBTdHJpbmcsIHRyZWF0TnVsbEFzRW1wdHlTdHJpbmc6IHRydWUgfSxcbiAgfVxufSk7XG5cbmRlZmluZSh7XG4gIHRhZ3M6IFsnY29sJywgJ2NvbGdyb3VwJ10sXG4gIGN0b3I6IGZ1bmN0aW9uIEhUTUxUYWJsZUNvbEVsZW1lbnQoZG9jLCBsb2NhbE5hbWUsIHByZWZpeCkge1xuICAgIEhUTUxFbGVtZW50LmNhbGwodGhpcywgZG9jLCBsb2NhbE5hbWUsIHByZWZpeCk7XG4gIH0sXG4gIGF0dHJpYnV0ZXM6IHtcbiAgICBzcGFuOiB7dHlwZTogJ2xpbWl0ZWQgdW5zaWduZWQgbG9uZyB3aXRoIGZhbGxiYWNrJywgZGVmYXVsdDogMSwgbWluOiAxfSxcbiAgICAvLyBPYnNvbGV0ZVxuICAgIGFsaWduOiBTdHJpbmcsXG4gICAgY2g6IHsgbmFtZTogJ2NoYXInLCB0eXBlOiBTdHJpbmcgfSxcbiAgICBjaE9mZjogeyBuYW1lOiAnY2hhcm9mZicsIHR5cGU6IFN0cmluZyB9LFxuICAgIHZBbGlnbjogU3RyaW5nLFxuICAgIHdpZHRoOiBTdHJpbmcsXG4gIH1cbn0pO1xuXG5kZWZpbmUoe1xuICB0YWc6ICd0YWJsZScsXG4gIGN0b3I6IGZ1bmN0aW9uIEhUTUxUYWJsZUVsZW1lbnQoZG9jLCBsb2NhbE5hbWUsIHByZWZpeCkge1xuICAgIEhUTUxFbGVtZW50LmNhbGwodGhpcywgZG9jLCBsb2NhbE5hbWUsIHByZWZpeCk7XG4gIH0sXG4gIHByb3BzOiB7XG4gICAgcm93czogeyBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3RyJyk7XG4gICAgfX1cbiAgfSxcbiAgYXR0cmlidXRlczoge1xuICAgIC8vIE9ic29sZXRlXG4gICAgYWxpZ246IFN0cmluZyxcbiAgICBib3JkZXI6IFN0cmluZyxcbiAgICBmcmFtZTogU3RyaW5nLFxuICAgIHJ1bGVzOiBTdHJpbmcsXG4gICAgc3VtbWFyeTogU3RyaW5nLFxuICAgIHdpZHRoOiBTdHJpbmcsXG4gICAgYmdDb2xvcjogeyB0eXBlOiBTdHJpbmcsIHRyZWF0TnVsbEFzRW1wdHlTdHJpbmc6IHRydWUgfSxcbiAgICBjZWxsUGFkZGluZzogeyB0eXBlOiBTdHJpbmcsIHRyZWF0TnVsbEFzRW1wdHlTdHJpbmc6IHRydWUgfSxcbiAgICBjZWxsU3BhY2luZzogeyB0eXBlOiBTdHJpbmcsIHRyZWF0TnVsbEFzRW1wdHlTdHJpbmc6IHRydWUgfSxcbiAgfVxufSk7XG5cbmRlZmluZSh7XG4gIHRhZzogJ3RlbXBsYXRlJyxcbiAgY3RvcjogZnVuY3Rpb24gSFRNTFRlbXBsYXRlRWxlbWVudChkb2MsIGxvY2FsTmFtZSwgcHJlZml4KSB7XG4gICAgSFRNTEVsZW1lbnQuY2FsbCh0aGlzLCBkb2MsIGxvY2FsTmFtZSwgcHJlZml4KTtcbiAgICB0aGlzLl9jb250ZW50RnJhZ21lbnQgPSBkb2MuX3RlbXBsYXRlRG9jLmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgfSxcbiAgcHJvcHM6IHtcbiAgICBjb250ZW50OiB7IGdldDogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLl9jb250ZW50RnJhZ21lbnQ7IH0gfSxcbiAgICBzZXJpYWxpemU6IHsgdmFsdWU6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5jb250ZW50LnNlcmlhbGl6ZSgpOyB9IH1cbiAgfVxufSk7XG5cbmRlZmluZSh7XG4gIHRhZzogJ3RyJyxcbiAgY3RvcjogZnVuY3Rpb24gSFRNTFRhYmxlUm93RWxlbWVudChkb2MsIGxvY2FsTmFtZSwgcHJlZml4KSB7XG4gICAgSFRNTEVsZW1lbnQuY2FsbCh0aGlzLCBkb2MsIGxvY2FsTmFtZSwgcHJlZml4KTtcbiAgfSxcbiAgcHJvcHM6IHtcbiAgICBjZWxsczogeyBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMucXVlcnlTZWxlY3RvckFsbCgndGQsdGgnKTtcbiAgICB9fVxuICB9LFxuICBhdHRyaWJ1dGVzOiB7XG4gICAgLy8gT2Jzb2xldGVcbiAgICBhbGlnbjogU3RyaW5nLFxuICAgIGNoOiB7IG5hbWU6ICdjaGFyJywgdHlwZTogU3RyaW5nIH0sXG4gICAgY2hPZmY6IHsgbmFtZTogJ2NoYXJvZmYnLCB0eXBlOiBTdHJpbmcgfSxcbiAgICB2QWxpZ246IFN0cmluZyxcbiAgICBiZ0NvbG9yOiB7IHR5cGU6IFN0cmluZywgdHJlYXROdWxsQXNFbXB0eVN0cmluZzogdHJ1ZSB9LFxuICB9LFxufSk7XG5cbmRlZmluZSh7XG4gIHRhZ3M6IFsndGhlYWQnLCAndGZvb3QnLCAndGJvZHknXSxcbiAgY3RvcjogZnVuY3Rpb24gSFRNTFRhYmxlU2VjdGlvbkVsZW1lbnQoZG9jLCBsb2NhbE5hbWUsIHByZWZpeCkge1xuICAgIEhUTUxFbGVtZW50LmNhbGwodGhpcywgZG9jLCBsb2NhbE5hbWUsIHByZWZpeCk7XG4gIH0sXG4gIHByb3BzOiB7XG4gICAgcm93czogeyBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3RyJyk7XG4gICAgfX1cbiAgfSxcbiAgYXR0cmlidXRlczoge1xuICAgIC8vIE9ic29sZXRlXG4gICAgYWxpZ246IFN0cmluZyxcbiAgICBjaDogeyBuYW1lOiAnY2hhcicsIHR5cGU6IFN0cmluZyB9LFxuICAgIGNoT2ZmOiB7IG5hbWU6ICdjaGFyb2ZmJywgdHlwZTogU3RyaW5nIH0sXG4gICAgdkFsaWduOiBTdHJpbmcsXG4gIH1cbn0pO1xuXG5kZWZpbmUoe1xuICB0YWc6ICd0ZXh0YXJlYScsXG4gIGN0b3I6IGZ1bmN0aW9uIEhUTUxUZXh0QXJlYUVsZW1lbnQoZG9jLCBsb2NhbE5hbWUsIHByZWZpeCkge1xuICAgIEhUTUxFbGVtZW50LmNhbGwodGhpcywgZG9jLCBsb2NhbE5hbWUsIHByZWZpeCk7XG4gIH0sXG4gIHByb3BzOiBmb3JtQXNzb2NpYXRlZFByb3BzLFxuICBhdHRyaWJ1dGVzOiB7XG4gICAgYXV0b2NvbXBsZXRlOiBTdHJpbmcsIC8vIEl0J3MgY29tcGxpY2F0ZWRcbiAgICBuYW1lOiBTdHJpbmcsXG4gICAgZGlzYWJsZWQ6IEJvb2xlYW4sXG4gICAgYXV0b2ZvY3VzOiBCb29sZWFuLFxuICAgIHBsYWNlaG9sZGVyOiBTdHJpbmcsXG4gICAgd3JhcDogU3RyaW5nLFxuICAgIGRpck5hbWU6IFN0cmluZyxcbiAgICByZXF1aXJlZDogQm9vbGVhbixcbiAgICByZWFkT25seTogQm9vbGVhbixcbiAgICByb3dzOiB7dHlwZTogJ2xpbWl0ZWQgdW5zaWduZWQgbG9uZyB3aXRoIGZhbGxiYWNrJywgZGVmYXVsdDogMiB9LFxuICAgIGNvbHM6IHt0eXBlOiAnbGltaXRlZCB1bnNpZ25lZCBsb25nIHdpdGggZmFsbGJhY2snLCBkZWZhdWx0OiAyMCB9LFxuICAgIG1heExlbmd0aDoge3R5cGU6ICd1bnNpZ25lZCBsb25nJywgbWluOiAwLCBzZXRtaW46IDAsIGRlZmF1bHQ6IC0xfSxcbiAgICBpbnB1dE1vZGU6IHsgdHlwZTogWyBcInZlcmJhdGltXCIsIFwibGF0aW5cIiwgXCJsYXRpbi1uYW1lXCIsIFwibGF0aW4tcHJvc2VcIiwgXCJmdWxsLXdpZHRoLWxhdGluXCIsIFwia2FuYVwiLCBcImthbmEtbmFtZVwiLCBcImthdGFrYW5hXCIsIFwibnVtZXJpY1wiLCBcInRlbFwiLCBcImVtYWlsXCIsIFwidXJsXCIgXSwgbWlzc2luZzogJycgfSxcbiAgfVxufSk7XG5cbmRlZmluZSh7XG4gIHRhZzogJ3RpbWUnLFxuICBjdG9yOiBmdW5jdGlvbiBIVE1MVGltZUVsZW1lbnQoZG9jLCBsb2NhbE5hbWUsIHByZWZpeCkge1xuICAgIEhUTUxFbGVtZW50LmNhbGwodGhpcywgZG9jLCBsb2NhbE5hbWUsIHByZWZpeCk7XG4gIH0sXG4gIGF0dHJpYnV0ZXM6IHtcbiAgICBkYXRlVGltZTogU3RyaW5nLFxuICAgIHB1YkRhdGU6IEJvb2xlYW5cbiAgfVxufSk7XG5cbmRlZmluZSh7XG4gIHRhZzogJ3RpdGxlJyxcbiAgY3RvcjogZnVuY3Rpb24gSFRNTFRpdGxlRWxlbWVudChkb2MsIGxvY2FsTmFtZSwgcHJlZml4KSB7XG4gICAgSFRNTEVsZW1lbnQuY2FsbCh0aGlzLCBkb2MsIGxvY2FsTmFtZSwgcHJlZml4KTtcbiAgfSxcbiAgcHJvcHM6IHtcbiAgICB0ZXh0OiB7IGdldDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy50ZXh0Q29udGVudDtcbiAgICB9fVxuICB9XG59KTtcblxuZGVmaW5lKHtcbiAgdGFnOiAndWwnLFxuICBjdG9yOiBmdW5jdGlvbiBIVE1MVUxpc3RFbGVtZW50KGRvYywgbG9jYWxOYW1lLCBwcmVmaXgpIHtcbiAgICBIVE1MRWxlbWVudC5jYWxsKHRoaXMsIGRvYywgbG9jYWxOYW1lLCBwcmVmaXgpO1xuICB9LFxuICBhdHRyaWJ1dGVzOiB7XG4gICAgdHlwZTogU3RyaW5nLFxuICAgIC8vIE9ic29sZXRlXG4gICAgY29tcGFjdDogQm9vbGVhbixcbiAgfVxufSk7XG5cbmRlZmluZSh7XG4gIGN0b3I6IGZ1bmN0aW9uIEhUTUxNZWRpYUVsZW1lbnQoZG9jLCBsb2NhbE5hbWUsIHByZWZpeCkge1xuICAgIEhUTUxFbGVtZW50LmNhbGwodGhpcywgZG9jLCBsb2NhbE5hbWUsIHByZWZpeCk7XG4gIH0sXG4gIGF0dHJpYnV0ZXM6IHtcbiAgICBzcmM6IFVSTCxcbiAgICBjcm9zc09yaWdpbjogQ09SUyxcbiAgICBwcmVsb2FkOiB7IHR5cGU6W1wibWV0YWRhdGFcIiwgXCJub25lXCIsIFwiYXV0b1wiLCB7dmFsdWU6IFwiXCIsIGFsaWFzOiBcImF1dG9cIn1dLCBtaXNzaW5nOiAnYXV0bycgfSxcbiAgICBsb29wOiBCb29sZWFuLFxuICAgIGF1dG9wbGF5OiBCb29sZWFuLFxuICAgIG1lZGlhR3JvdXA6IFN0cmluZyxcbiAgICBjb250cm9sczogQm9vbGVhbixcbiAgICBkZWZhdWx0TXV0ZWQ6IHtuYW1lOiBcIm11dGVkXCIsIHR5cGU6IEJvb2xlYW59XG4gIH1cbn0pO1xuXG5kZWZpbmUoe1xuICB0YWc6ICdhdWRpbycsXG4gIHN1cGVyY2xhc3M6IGh0bWxFbGVtZW50cy5IVE1MTWVkaWFFbGVtZW50LFxuICBjdG9yOiBmdW5jdGlvbiBIVE1MQXVkaW9FbGVtZW50KGRvYywgbG9jYWxOYW1lLCBwcmVmaXgpIHtcbiAgICBodG1sRWxlbWVudHMuSFRNTE1lZGlhRWxlbWVudC5jYWxsKHRoaXMsIGRvYywgbG9jYWxOYW1lLCBwcmVmaXgpO1xuICB9XG59KTtcblxuZGVmaW5lKHtcbiAgdGFnOiAndmlkZW8nLFxuICBzdXBlcmNsYXNzOiBodG1sRWxlbWVudHMuSFRNTE1lZGlhRWxlbWVudCxcbiAgY3RvcjogZnVuY3Rpb24gSFRNTFZpZGVvRWxlbWVudChkb2MsIGxvY2FsTmFtZSwgcHJlZml4KSB7XG4gICAgaHRtbEVsZW1lbnRzLkhUTUxNZWRpYUVsZW1lbnQuY2FsbCh0aGlzLCBkb2MsIGxvY2FsTmFtZSwgcHJlZml4KTtcbiAgfSxcbiAgYXR0cmlidXRlczoge1xuICAgIHBvc3RlcjogVVJMLFxuICAgIHdpZHRoOiB7dHlwZTogXCJ1bnNpZ25lZCBsb25nXCIsIG1pbjogMCwgZGVmYXVsdDogMCB9LFxuICAgIGhlaWdodDoge3R5cGU6IFwidW5zaWduZWQgbG9uZ1wiLCBtaW46IDAsIGRlZmF1bHQ6IDAgfVxuICB9XG59KTtcblxuZGVmaW5lKHtcbiAgdGFnOiAndGQnLFxuICBzdXBlcmNsYXNzOiBodG1sRWxlbWVudHMuSFRNTFRhYmxlQ2VsbEVsZW1lbnQsXG4gIGN0b3I6IGZ1bmN0aW9uIEhUTUxUYWJsZURhdGFDZWxsRWxlbWVudChkb2MsIGxvY2FsTmFtZSwgcHJlZml4KSB7XG4gICAgaHRtbEVsZW1lbnRzLkhUTUxUYWJsZUNlbGxFbGVtZW50LmNhbGwodGhpcywgZG9jLCBsb2NhbE5hbWUsIHByZWZpeCk7XG4gIH1cbn0pO1xuXG5kZWZpbmUoe1xuICB0YWc6ICd0aCcsXG4gIHN1cGVyY2xhc3M6IGh0bWxFbGVtZW50cy5IVE1MVGFibGVDZWxsRWxlbWVudCxcbiAgY3RvcjogZnVuY3Rpb24gSFRNTFRhYmxlSGVhZGVyQ2VsbEVsZW1lbnQoZG9jLCBsb2NhbE5hbWUsIHByZWZpeCkge1xuICAgIGh0bWxFbGVtZW50cy5IVE1MVGFibGVDZWxsRWxlbWVudC5jYWxsKHRoaXMsIGRvYywgbG9jYWxOYW1lLCBwcmVmaXgpO1xuICB9LFxufSk7XG5cbmRlZmluZSh7XG4gIHRhZzogJ2ZyYW1lc2V0JyxcbiAgY3RvcjogZnVuY3Rpb24gSFRNTEZyYW1lU2V0RWxlbWVudChkb2MsIGxvY2FsTmFtZSwgcHJlZml4KSB7XG4gICAgSFRNTEVsZW1lbnQuY2FsbCh0aGlzLCBkb2MsIGxvY2FsTmFtZSwgcHJlZml4KTtcbiAgfVxufSk7XG5cbmRlZmluZSh7XG4gIHRhZzogJ2ZyYW1lJyxcbiAgY3RvcjogZnVuY3Rpb24gSFRNTEZyYW1lRWxlbWVudChkb2MsIGxvY2FsTmFtZSwgcHJlZml4KSB7XG4gICAgSFRNTEVsZW1lbnQuY2FsbCh0aGlzLCBkb2MsIGxvY2FsTmFtZSwgcHJlZml4KTtcbiAgfVxufSk7XG5cbmRlZmluZSh7XG4gIHRhZzogJ2NhbnZhcycsXG4gIGN0b3I6IGZ1bmN0aW9uIEhUTUxDYW52YXNFbGVtZW50KGRvYywgbG9jYWxOYW1lLCBwcmVmaXgpIHtcbiAgICBIVE1MRWxlbWVudC5jYWxsKHRoaXMsIGRvYywgbG9jYWxOYW1lLCBwcmVmaXgpO1xuICB9LFxuICBwcm9wczoge1xuICAgIGdldENvbnRleHQ6IHsgdmFsdWU6IHV0aWxzLm55aSB9LFxuICAgIHByb2JhYmx5U3VwcG9ydHNDb250ZXh0OiB7IHZhbHVlOiB1dGlscy5ueWkgfSxcbiAgICBzZXRDb250ZXh0OiB7IHZhbHVlOiB1dGlscy5ueWkgfSxcbiAgICB0cmFuc2ZlckNvbnRyb2xUb1Byb3h5OiB7IHZhbHVlOiB1dGlscy5ueWkgfSxcbiAgICB0b0RhdGFVUkw6IHsgdmFsdWU6IHV0aWxzLm55aSB9LFxuICAgIHRvQmxvYjogeyB2YWx1ZTogdXRpbHMubnlpIH1cbiAgfSxcbiAgYXR0cmlidXRlczoge1xuICAgIHdpZHRoOiB7IHR5cGU6IFwidW5zaWduZWQgbG9uZ1wiLCBkZWZhdWx0OiAzMDB9LFxuICAgIGhlaWdodDogeyB0eXBlOiBcInVuc2lnbmVkIGxvbmdcIiwgZGVmYXVsdDogMTUwfVxuICB9XG59KTtcblxuZGVmaW5lKHtcbiAgdGFnOiAnZGlhbG9nJyxcbiAgY3RvcjogZnVuY3Rpb24gSFRNTERpYWxvZ0VsZW1lbnQoZG9jLCBsb2NhbE5hbWUsIHByZWZpeCkge1xuICAgIEhUTUxFbGVtZW50LmNhbGwodGhpcywgZG9jLCBsb2NhbE5hbWUsIHByZWZpeCk7XG4gIH0sXG4gIHByb3BzOiB7XG4gICAgc2hvdzogeyB2YWx1ZTogdXRpbHMubnlpIH0sXG4gICAgc2hvd01vZGFsOiB7IHZhbHVlOiB1dGlscy5ueWkgfSxcbiAgICBjbG9zZTogeyB2YWx1ZTogdXRpbHMubnlpIH1cbiAgfSxcbiAgYXR0cmlidXRlczoge1xuICAgIG9wZW46IEJvb2xlYW4sXG4gICAgcmV0dXJuVmFsdWU6IFN0cmluZ1xuICB9XG59KTtcblxuZGVmaW5lKHtcbiAgdGFnOiAnbWVudWl0ZW0nLFxuICBjdG9yOiBmdW5jdGlvbiBIVE1MTWVudUl0ZW1FbGVtZW50KGRvYywgbG9jYWxOYW1lLCBwcmVmaXgpIHtcbiAgICBIVE1MRWxlbWVudC5jYWxsKHRoaXMsIGRvYywgbG9jYWxOYW1lLCBwcmVmaXgpO1xuICB9LFxuICBwcm9wczoge1xuICAgIC8vIFRoZSBtZW51aXRlbSdzIGxhYmVsXG4gICAgX2xhYmVsOiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdmFsID0gdGhpcy5fZ2V0YXR0cignbGFiZWwnKTtcbiAgICAgICAgaWYgKHZhbCAhPT0gbnVsbCAmJiB2YWwgIT09ICcnKSB7IHJldHVybiB2YWw7IH1cbiAgICAgICAgdmFsID0gdGhpcy50ZXh0Q29udGVudDtcbiAgICAgICAgLy8gU3RyaXAgYW5kIGNvbGxhcHNlIHdoaXRlc3BhY2VcbiAgICAgICAgcmV0dXJuIHZhbC5yZXBsYWNlKC9bIFxcdFxcblxcZlxccl0rL2csICcgJykudHJpbSgpO1xuICAgICAgfVxuICAgIH0sXG4gICAgLy8gVGhlIG1lbnVpdGVtIGxhYmVsIElETCBhdHRyaWJ1dGVcbiAgICBsYWJlbDoge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHZhbCA9IHRoaXMuX2dldGF0dHIoJ2xhYmVsJyk7XG4gICAgICAgIGlmICh2YWwgIT09IG51bGwpIHsgcmV0dXJuIHZhbDsgfVxuICAgICAgICByZXR1cm4gdGhpcy5fbGFiZWw7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbih2KSB7XG4gICAgICAgIHRoaXMuX3NldGF0dHIoJ2xhYmVsJywgdik7XG4gICAgICB9LFxuICAgIH1cbiAgfSxcbiAgYXR0cmlidXRlczoge1xuICAgIHR5cGU6IHsgdHlwZTogW1wiY29tbWFuZFwiLFwiY2hlY2tib3hcIixcInJhZGlvXCJdLCBtaXNzaW5nOiAnY29tbWFuZCcgfSxcbiAgICBpY29uOiBVUkwsXG4gICAgZGlzYWJsZWQ6IEJvb2xlYW4sXG4gICAgY2hlY2tlZDogQm9vbGVhbixcbiAgICByYWRpb2dyb3VwOiBTdHJpbmcsXG4gICAgZGVmYXVsdDogQm9vbGVhblxuICB9XG59KTtcblxuZGVmaW5lKHtcbiAgdGFnOiAnc291cmNlJyxcbiAgY3RvcjogZnVuY3Rpb24gSFRNTFNvdXJjZUVsZW1lbnQoZG9jLCBsb2NhbE5hbWUsIHByZWZpeCkge1xuICAgIEhUTUxFbGVtZW50LmNhbGwodGhpcywgZG9jLCBsb2NhbE5hbWUsIHByZWZpeCk7XG4gIH0sXG4gIGF0dHJpYnV0ZXM6IHtcbiAgICBzcmNzZXQ6IFN0cmluZyxcbiAgICBzaXplczogU3RyaW5nLFxuICAgIG1lZGlhOiBTdHJpbmcsXG4gICAgc3JjOiBVUkwsXG4gICAgdHlwZTogU3RyaW5nXG4gIH1cbn0pO1xuXG5kZWZpbmUoe1xuICB0YWc6ICd0cmFjaycsXG4gIGN0b3I6IGZ1bmN0aW9uIEhUTUxUcmFja0VsZW1lbnQoZG9jLCBsb2NhbE5hbWUsIHByZWZpeCkge1xuICAgIEhUTUxFbGVtZW50LmNhbGwodGhpcywgZG9jLCBsb2NhbE5hbWUsIHByZWZpeCk7XG4gIH0sXG4gIGF0dHJpYnV0ZXM6IHtcbiAgICBzcmM6IFVSTCxcbiAgICBzcmNsYW5nOiBTdHJpbmcsXG4gICAgbGFiZWw6IFN0cmluZyxcbiAgICBkZWZhdWx0OiBCb29sZWFuLFxuICAgIGtpbmQ6IHsgdHlwZTogW1wic3VidGl0bGVzXCIsIFwiY2FwdGlvbnNcIiwgXCJkZXNjcmlwdGlvbnNcIiwgXCJjaGFwdGVyc1wiLCBcIm1ldGFkYXRhXCJdLCBtaXNzaW5nOiAnc3VidGl0bGVzJywgaW52YWxpZDogJ21ldGFkYXRhJyB9LFxuICB9LFxuICBwcm9wczoge1xuICAgIE5PTkU6IHsgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH0gfSxcbiAgICBMT0FESU5HOiB7IGdldDogZnVuY3Rpb24oKSB7IHJldHVybiAxOyB9IH0sXG4gICAgTE9BREVEOiB7IGdldDogZnVuY3Rpb24oKSB7IHJldHVybiAyOyB9IH0sXG4gICAgRVJST1I6IHsgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIDM7IH0gfSxcbiAgICByZWFkeVN0YXRlOiB7IGdldDogdXRpbHMubnlpIH0sXG4gICAgdHJhY2s6IHsgZ2V0OiB1dGlscy5ueWkgfVxuICB9XG59KTtcblxuZGVmaW5lKHtcbiAgdGFnczogW1xuICAgIFwiYWJiclwiLCBcImFkZHJlc3NcIiwgXCJhcnRpY2xlXCIsIFwiYXNpZGVcIiwgXCJiXCIsIFwiYmRpXCIsIFwiYmRvXCIsXG4gICAgXCJjaXRlXCIsIFwiY29kZVwiLCBcImRkXCIsIFwiZGZuXCIsIFwiZHRcIiwgXCJlbVwiLCBcImZpZ2NhcHRpb25cIiwgXCJmaWd1cmVcIixcbiAgICBcImZvb3RlclwiLCBcImhlYWRlclwiLCBcImhncm91cFwiLCBcImlcIiwgXCJrYmRcIiwgXCJtYWluXCIsIFwibWFya1wiLCBcIm5hdlwiLCBcIm5vc2NyaXB0XCIsXG4gICAgXCJyYlwiLCBcInJwXCIsIFwicnRcIiwgXCJydGNcIiwgXCJydWJ5XCIsIFwic1wiLCBcInNhbXBcIiwgXCJzZWN0aW9uXCIsIFwic21hbGxcIiwgXCJzdHJvbmdcIixcbiAgICBcInN1YlwiLCBcInN1bW1hcnlcIiwgXCJzdXBcIiwgXCJ1XCIsIFwidmFyXCIsIFwid2JyXCIsXG4gICAgLy8gTGVnYWN5IGVsZW1lbnRzXG4gICAgXCJhY3JvbnltXCIsIFwiYmFzZWZvbnRcIiwgXCJiaWdcIiwgXCJjZW50ZXJcIiwgXCJub2JyXCIsIFwibm9lbWJlZFwiLCBcIm5vZnJhbWVzXCIsXG4gICAgXCJwbGFpbnRleHRcIiwgXCJzdHJpa2VcIiwgXCJ0dFwiXG4gIF1cbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZG9taW5vL2xpYi9odG1sZWx0cy5qc1xuLy8gbW9kdWxlIGlkID0gMjVcbi8vIG1vZHVsZSBjaHVua3MgPSA0IiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgcGFyc2VybGliID0gcmVxdWlyZSgnLi9jc3NwYXJzZXInKTtcblxubW9kdWxlLmV4cG9ydHMgPSBDU1NTdHlsZURlY2xhcmF0aW9uO1xuXG5mdW5jdGlvbiBDU1NTdHlsZURlY2xhcmF0aW9uKGVsdCkge1xuICB0aGlzLl9lbGVtZW50ID0gZWx0O1xufVxuXG4vLyBVdGlsaXR5IGZ1bmN0aW9uIGZvciBwYXJzaW5nIHN0eWxlIGRlY2xhcmF0aW9uc1xuLy8gUGFzcyBpbiBhIHN0cmluZyBsaWtlIFwibWFyZ2luLWxlZnQ6IDVweDsgYm9yZGVyLXN0eWxlOiBzb2xpZFwiXG4vLyBhbmQgdGhpcyBmdW5jdGlvbiByZXR1cm5zIGFuIG9iamVjdCBsaWtlXG4vLyB7XCJtYXJnaW4tbGVmdFwiOlwiNXB4XCIsIFwiYm9yZGVyLXN0eWxlXCI6XCJzb2xpZFwifVxuZnVuY3Rpb24gcGFyc2VTdHlsZXMocykge1xuICB2YXIgcGFyc2VyID0gbmV3IHBhcnNlcmxpYi5jc3MuUGFyc2VyKCk7XG4gIHZhciByZXN1bHQgPSB7IHByb3BlcnR5OiBPYmplY3QuY3JlYXRlKG51bGwpLCBwcmlvcml0eTogT2JqZWN0LmNyZWF0ZShudWxsKSB9O1xuICBwYXJzZXIuYWRkTGlzdGVuZXIoXCJwcm9wZXJ0eVwiLCBmdW5jdGlvbihlKSB7XG4gICAgaWYgKGUuaW52YWxpZCkgcmV0dXJuOyAvLyBTa2lwIGVycm9yc1xuICAgIHJlc3VsdC5wcm9wZXJ0eVtlLnByb3BlcnR5LnRleHRdID0gZS52YWx1ZS50ZXh0O1xuICAgIGlmIChlLmltcG9ydGFudCkgcmVzdWx0LnByaW9yaXR5W2UucHJvcGVydHkudGV4dF0gPSAnaW1wb3J0YW50JztcbiAgfSk7XG4gIHMgPSAoJycrcykucmVwbGFjZSgvXjsvLCAnJyk7XG4gIHBhcnNlci5wYXJzZVN0eWxlQXR0cmlidXRlKHMpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG52YXIgTk9fQ0hBTkdFID0ge307IC8vIFByaXZhdGUgbWFya2VyIG9iamVjdFxuXG5DU1NTdHlsZURlY2xhcmF0aW9uLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoT2JqZWN0LnByb3RvdHlwZSwge1xuXG4gIC8vIFJldHVybiB0aGUgcGFyc2VkIGZvcm0gb2YgdGhlIGVsZW1lbnQncyBzdHlsZSBhdHRyaWJ1dGUuXG4gIC8vIElmIHRoZSBlbGVtZW50J3Mgc3R5bGUgYXR0cmlidXRlIGhhcyBuZXZlciBiZWVuIHBhcnNlZFxuICAvLyBvciBpZiBpdCBoYXMgY2hhbmdlZCBzaW5jZSB0aGUgbGFzdCBwYXJzZSwgdGhlbiByZXBhcnNlIGl0XG4gIC8vIE5vdGUgdGhhdCB0aGUgc3R5bGVzIGRvbid0IGdldCBwYXJzZWQgdW50aWwgdGhleSdyZSBhY3R1YWxseSBuZWVkZWRcbiAgX3BhcnNlZDogeyBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIGlmICghdGhpcy5fcGFyc2VkU3R5bGVzIHx8IHRoaXMuY3NzVGV4dCAhPT0gdGhpcy5fbGFzdFBhcnNlZFRleHQpIHtcbiAgICAgIHZhciB0ZXh0ID0gdGhpcy5jc3NUZXh0O1xuICAgICAgdGhpcy5fcGFyc2VkU3R5bGVzID0gcGFyc2VTdHlsZXModGV4dCk7XG4gICAgICB0aGlzLl9sYXN0UGFyc2VkVGV4dCA9IHRleHQ7XG4gICAgICBkZWxldGUgdGhpcy5fbmFtZXM7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9wYXJzZWRTdHlsZXM7XG4gIH19LFxuXG4gIC8vIENhbGwgdGhpcyBtZXRob2QgYW55IHRpbWUgdGhlIHBhcnNlZCByZXByZXNlbnRhdGlvbiBvZiB0aGVcbiAgLy8gc3R5bGUgY2hhbmdlcy4gIEl0IGNvbnZlcnRzIHRoZSBzdHlsZSBwcm9wZXJ0aWVzIHRvIGEgc3RyaW5nIGFuZFxuICAvLyBzZXRzIGNzc1RleHQgYW5kIHRoZSBlbGVtZW50J3Mgc3R5bGUgYXR0cmlidXRlXG4gIF9zZXJpYWxpemU6IHsgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzdHlsZXMgPSB0aGlzLl9wYXJzZWQ7XG4gICAgdmFyIHMgPSBcIlwiO1xuXG4gICAgZm9yKHZhciBuYW1lIGluIHN0eWxlcy5wcm9wZXJ0eSkge1xuICAgICAgaWYgKHMpIHMgKz0gXCIgXCI7XG4gICAgICBzICs9IG5hbWUgKyBcIjogXCIgKyBzdHlsZXMucHJvcGVydHlbbmFtZV07XG4gICAgICBpZiAoc3R5bGVzLnByaW9yaXR5W25hbWVdKSB7XG4gICAgICAgIHMgKz0gXCIgIVwiICsgc3R5bGVzLnByaW9yaXR5W25hbWVdO1xuICAgICAgfVxuICAgICAgcyArPSBcIjtcIjtcbiAgICB9XG5cbiAgICB0aGlzLmNzc1RleHQgPSBzOyAgICAgIC8vIGFsc28gc2V0cyB0aGUgc3R5bGUgYXR0cmlidXRlXG4gICAgdGhpcy5fbGFzdFBhcnNlZFRleHQgPSBzOyAgLy8gc28gd2UgZG9uJ3QgcmVwYXJzZVxuICAgIGRlbGV0ZSB0aGlzLl9uYW1lcztcbiAgfX0sXG5cbiAgY3NzVGV4dDoge1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAvLyBYWFg6IHRoaXMgaXMgYSBDU1NTdHlsZURlY2xhcmF0aW9uIGZvciBhbiBlbGVtZW50LlxuICAgICAgLy8gQSBkaWZmZXJlbnQgaW1wbCBtaWdodCBiZSBuZWNlc3NhcnkgZm9yIGEgc2V0IG9mIHN0eWxlc1xuICAgICAgLy8gYXNzb2NpYXRlZCByZXR1cm5lZCBieSBnZXRDb21wdXRlZFN0eWxlKCksIGUuZy5cbiAgICAgIHJldHVybiB0aGlzLl9lbGVtZW50LmdldEF0dHJpYnV0ZShcInN0eWxlXCIpO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgLy8gWFhYOiBJIHNob3VsZCBwYXJzZSBhbmQgc2VyaWFsaXplIHRoZSB2YWx1ZSB0b1xuICAgICAgLy8gbm9ybWFsaXplIGl0IGFuZCByZW1vdmUgZXJyb3JzLiBGRiBhbmQgY2hyb21lIGRvIHRoYXQuXG4gICAgICB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZShcInN0eWxlXCIsIHZhbHVlKTtcbiAgICB9XG4gIH0sXG5cbiAgbGVuZ3RoOiB7IGdldDogZnVuY3Rpb24oKSB7XG4gICAgaWYgKCF0aGlzLl9uYW1lcylcbiAgICAgIHRoaXMuX25hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGhpcy5fcGFyc2VkLnByb3BlcnR5KTtcbiAgICByZXR1cm4gdGhpcy5fbmFtZXMubGVuZ3RoO1xuICB9fSxcblxuICBpdGVtOiB7IHZhbHVlOiBmdW5jdGlvbihuKSB7XG4gICAgaWYgKCF0aGlzLl9uYW1lcylcbiAgICAgIHRoaXMuX25hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGhpcy5fcGFyc2VkLnByb3BlcnR5KTtcbiAgICByZXR1cm4gdGhpcy5fbmFtZXNbbl07XG4gIH19LFxuXG4gIGdldFByb3BlcnR5VmFsdWU6IHsgdmFsdWU6IGZ1bmN0aW9uKHByb3BlcnR5KSB7XG4gICAgcHJvcGVydHkgPSBwcm9wZXJ0eS50b0xvd2VyQ2FzZSgpO1xuICAgIHJldHVybiB0aGlzLl9wYXJzZWQucHJvcGVydHlbcHJvcGVydHldIHx8IFwiXCI7XG4gIH19LFxuXG4gIGdldFByb3BlcnR5UHJpb3JpdHk6IHsgdmFsdWU6IGZ1bmN0aW9uKHByb3BlcnR5KSB7XG4gICAgcHJvcGVydHkgPSBwcm9wZXJ0eS50b0xvd2VyQ2FzZSgpO1xuICAgIHJldHVybiB0aGlzLl9wYXJzZWQucHJpb3JpdHlbcHJvcGVydHldIHx8IFwiXCI7XG4gIH19LFxuXG4gIHNldFByb3BlcnR5OiB7IHZhbHVlOiBmdW5jdGlvbihwcm9wZXJ0eSwgdmFsdWUsIHByaW9yaXR5KSB7XG4gICAgcHJvcGVydHkgPSBwcm9wZXJ0eS50b0xvd2VyQ2FzZSgpO1xuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YWx1ZSA9IFwiXCI7XG4gICAgfVxuICAgIGlmIChwcmlvcml0eSA9PT0gbnVsbCB8fCBwcmlvcml0eSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBwcmlvcml0eSA9IFwiXCI7XG4gICAgfVxuXG4gICAgLy8gU3RyaW5nIGNvZXJjaW9uXG4gICAgaWYgKHZhbHVlICE9PSBOT19DSEFOR0UpIHtcbiAgICAgIHZhbHVlID0gXCJcIiArIHZhbHVlO1xuICAgIH1cblxuICAgIGlmICh2YWx1ZSA9PT0gXCJcIikge1xuICAgICAgdGhpcy5yZW1vdmVQcm9wZXJ0eShwcm9wZXJ0eSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHByaW9yaXR5ICE9PSBcIlwiICYmIHByaW9yaXR5ICE9PSBOT19DSEFOR0UgJiZcbiAgICAgICAgIS9eaW1wb3J0YW50JC9pLnRlc3QocHJpb3JpdHkpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHN0eWxlcyA9IHRoaXMuX3BhcnNlZDtcbiAgICBpZiAodmFsdWUgPT09IE5PX0NIQU5HRSkge1xuICAgICAgaWYgKCFzdHlsZXMucHJvcGVydHlbcHJvcGVydHldKSB7XG4gICAgICAgIHJldHVybjsgLy8gTm90IGEgdmFsaWQgcHJvcGVydHkgbmFtZS5cbiAgICAgIH1cbiAgICAgIGlmIChwcmlvcml0eSAhPT0gXCJcIikge1xuICAgICAgICBzdHlsZXMucHJpb3JpdHlbcHJvcGVydHldID0gXCJpbXBvcnRhbnRcIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlbGV0ZSBzdHlsZXMucHJpb3JpdHlbcHJvcGVydHldO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBXZSBkb24ndCBqdXN0IGFjY2VwdCB0aGUgcHJvcGVydHkgdmFsdWUuICBJbnN0ZWFkXG4gICAgICAvLyB3ZSBwYXJzZSBpdCB0byBlbnN1cmUgdGhhdCBpdCBpcyBzb21ldGhpbmcgdmFsaWQuXG4gICAgICAvLyBJZiBpdCBjb250YWlucyBhIHNlbWljb2xvbiBpdCBpcyBpbnZhbGlkXG4gICAgICBpZiAodmFsdWUuaW5kZXhPZihcIjtcIikgIT09IC0xKSByZXR1cm47XG5cbiAgICAgIHZhciBuZXdwcm9wcyA9IHBhcnNlU3R5bGVzKHByb3BlcnR5ICsgXCI6XCIgKyB2YWx1ZSk7XG4gICAgICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMobmV3cHJvcHMucHJvcGVydHkpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm47IC8vIG5vIHZhbGlkIHByb3BlcnR5IGZvdW5kXG4gICAgICB9XG4gICAgICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMobmV3cHJvcHMucHJpb3JpdHkpLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICByZXR1cm47IC8vIGlmIHRoZSB2YWx1ZSBpbmNsdWRlZCAnIWltcG9ydGFudCcgaXQgd2Fzbid0IHZhbGlkLlxuICAgICAgfVxuXG4gICAgICAvLyBYWFggaGFuZGxlIHNob3J0aGFuZCBwcm9wZXJ0aWVzXG5cbiAgICAgIGZvciAodmFyIHAgaW4gbmV3cHJvcHMucHJvcGVydHkpIHtcbiAgICAgICAgc3R5bGVzLnByb3BlcnR5W3BdID0gbmV3cHJvcHMucHJvcGVydHlbcF07XG4gICAgICAgIGlmIChwcmlvcml0eSA9PT0gTk9fQ0hBTkdFKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gZWxzZSBpZiAocHJpb3JpdHkgIT09IFwiXCIpIHtcbiAgICAgICAgICBzdHlsZXMucHJpb3JpdHlbcF0gPSBcImltcG9ydGFudFwiO1xuICAgICAgICB9IGVsc2UgaWYgKHN0eWxlcy5wcmlvcml0eVtwXSkge1xuICAgICAgICAgIGRlbGV0ZSBzdHlsZXMucHJpb3JpdHlbcF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBTZXJpYWxpemUgYW5kIHVwZGF0ZSBjc3NUZXh0IGFuZCBlbGVtZW50LnN0eWxlIVxuICAgIHRoaXMuX3NlcmlhbGl6ZSgpO1xuICB9fSxcblxuICBzZXRQcm9wZXJ0eVZhbHVlOiB7IHZhbHVlOiBmdW5jdGlvbihwcm9wZXJ0eSwgdmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5zZXRQcm9wZXJ0eShwcm9wZXJ0eSwgdmFsdWUsIE5PX0NIQU5HRSk7XG4gIH19LFxuXG4gIHNldFByb3BlcnR5UHJpb3JpdHk6IHsgdmFsdWU6IGZ1bmN0aW9uKHByb3BlcnR5LCBwcmlvcml0eSkge1xuICAgIHJldHVybiB0aGlzLnNldFByb3BlcnR5KHByb3BlcnR5LCBOT19DSEFOR0UsIHByaW9yaXR5KTtcbiAgfX0sXG5cbiAgcmVtb3ZlUHJvcGVydHk6IHsgdmFsdWU6IGZ1bmN0aW9uKHByb3BlcnR5KSB7XG4gICAgcHJvcGVydHkgPSBwcm9wZXJ0eS50b0xvd2VyQ2FzZSgpO1xuICAgIHZhciBzdHlsZXMgPSB0aGlzLl9wYXJzZWQ7XG4gICAgaWYgKHByb3BlcnR5IGluIHN0eWxlcy5wcm9wZXJ0eSkge1xuICAgICAgZGVsZXRlIHN0eWxlcy5wcm9wZXJ0eVtwcm9wZXJ0eV07XG4gICAgICBkZWxldGUgc3R5bGVzLnByaW9yaXR5W3Byb3BlcnR5XTtcblxuICAgICAgLy8gU2VyaWFsaXplIGFuZCB1cGRhdGUgY3NzVGV4dCBhbmQgZWxlbWVudC5zdHlsZSFcbiAgICAgIHRoaXMuX3NlcmlhbGl6ZSgpO1xuICAgIH1cbiAgfX0sXG59KTtcblxudmFyIGNzc1Byb3BlcnRpZXMgPSB7XG4gIGJhY2tncm91bmQ6IFwiYmFja2dyb3VuZFwiLFxuICBiYWNrZ3JvdW5kQXR0YWNobWVudDogXCJiYWNrZ3JvdW5kLWF0dGFjaG1lbnRcIixcbiAgYmFja2dyb3VuZENvbG9yOiBcImJhY2tncm91bmQtY29sb3JcIixcbiAgYmFja2dyb3VuZEltYWdlOiBcImJhY2tncm91bmQtaW1hZ2VcIixcbiAgYmFja2dyb3VuZFBvc2l0aW9uOiBcImJhY2tncm91bmQtcG9zaXRpb25cIixcbiAgYmFja2dyb3VuZFJlcGVhdDogXCJiYWNrZ3JvdW5kLXJlcGVhdFwiLFxuICBib3JkZXI6IFwiYm9yZGVyXCIsXG4gIGJvcmRlckNvbGxhcHNlOiBcImJvcmRlci1jb2xsYXBzZVwiLFxuICBib3JkZXJDb2xvcjogXCJib3JkZXItY29sb3JcIixcbiAgYm9yZGVyU3BhY2luZzogXCJib3JkZXItc3BhY2luZ1wiLFxuICBib3JkZXJTdHlsZTogXCJib3JkZXItc3R5bGVcIixcbiAgYm9yZGVyVG9wOiBcImJvcmRlci10b3BcIixcbiAgYm9yZGVyUmlnaHQ6IFwiYm9yZGVyLXJpZ2h0XCIsXG4gIGJvcmRlckJvdHRvbTogXCJib3JkZXItYm90dG9tXCIsXG4gIGJvcmRlckxlZnQ6IFwiYm9yZGVyLWxlZnRcIixcbiAgYm9yZGVyVG9wQ29sb3I6IFwiYm9yZGVyLXRvcC1jb2xvclwiLFxuICBib3JkZXJSaWdodENvbG9yOiBcImJvcmRlci1yaWdodC1jb2xvclwiLFxuICBib3JkZXJCb3R0b21Db2xvcjogXCJib3JkZXItYm90dG9tLWNvbG9yXCIsXG4gIGJvcmRlckxlZnRDb2xvcjogXCJib3JkZXItbGVmdC1jb2xvclwiLFxuICBib3JkZXJUb3BTdHlsZTogXCJib3JkZXItdG9wLXN0eWxlXCIsXG4gIGJvcmRlclJpZ2h0U3R5bGU6IFwiYm9yZGVyLXJpZ2h0LXN0eWxlXCIsXG4gIGJvcmRlckJvdHRvbVN0eWxlOiBcImJvcmRlci1ib3R0b20tc3R5bGVcIixcbiAgYm9yZGVyTGVmdFN0eWxlOiBcImJvcmRlci1sZWZ0LXN0eWxlXCIsXG4gIGJvcmRlclRvcFdpZHRoOiBcImJvcmRlci10b3Atd2lkdGhcIixcbiAgYm9yZGVyUmlnaHRXaWR0aDogXCJib3JkZXItcmlnaHQtd2lkdGhcIixcbiAgYm9yZGVyQm90dG9tV2lkdGg6IFwiYm9yZGVyLWJvdHRvbS13aWR0aFwiLFxuICBib3JkZXJMZWZ0V2lkdGg6IFwiYm9yZGVyLWxlZnQtd2lkdGhcIixcbiAgYm9yZGVyV2lkdGg6IFwiYm9yZGVyLXdpZHRoXCIsXG4gIGJvdHRvbTogXCJib3R0b21cIixcbiAgY2FwdGlvblNpZGU6IFwiY2FwdGlvbi1zaWRlXCIsXG4gIGNsZWFyOiBcImNsZWFyXCIsXG4gIGNsaXA6IFwiY2xpcFwiLFxuICBjb2xvcjogXCJjb2xvclwiLFxuICBjb250ZW50OiBcImNvbnRlbnRcIixcbiAgY291bnRlckluY3JlbWVudDogXCJjb3VudGVyLWluY3JlbWVudFwiLFxuICBjb3VudGVyUmVzZXQ6IFwiY291bnRlci1yZXNldFwiLFxuICBjdXJzb3I6IFwiY3Vyc29yXCIsXG4gIGRpcmVjdGlvbjogXCJkaXJlY3Rpb25cIixcbiAgZGlzcGxheTogXCJkaXNwbGF5XCIsXG4gIGVtcHR5Q2VsbHM6IFwiZW1wdHktY2VsbHNcIixcbiAgY3NzRmxvYXQ6IFwiZmxvYXRcIixcbiAgZm9udDogXCJmb250XCIsXG4gIGZvbnRGYW1pbHk6IFwiZm9udC1mYW1pbHlcIixcbiAgZm9udFNpemU6IFwiZm9udC1zaXplXCIsXG4gIGZvbnRTaXplQWRqdXN0OiBcImZvbnQtc2l6ZS1hZGp1c3RcIixcbiAgZm9udFN0cmV0Y2g6IFwiZm9udC1zdHJldGNoXCIsXG4gIGZvbnRTdHlsZTogXCJmb250LXN0eWxlXCIsXG4gIGZvbnRWYXJpYW50OiBcImZvbnQtdmFyaWFudFwiLFxuICBmb250V2VpZ2h0OiBcImZvbnQtd2VpZ2h0XCIsXG4gIGhlaWdodDogXCJoZWlnaHRcIixcbiAgbGVmdDogXCJsZWZ0XCIsXG4gIGxldHRlclNwYWNpbmc6IFwibGV0dGVyLXNwYWNpbmdcIixcbiAgbGluZUhlaWdodDogXCJsaW5lLWhlaWdodFwiLFxuICBsaXN0U3R5bGU6IFwibGlzdC1zdHlsZVwiLFxuICBsaXN0U3R5bGVJbWFnZTogXCJsaXN0LXN0eWxlLWltYWdlXCIsXG4gIGxpc3RTdHlsZVBvc2l0aW9uOiBcImxpc3Qtc3R5bGUtcG9zaXRpb25cIixcbiAgbGlzdFN0eWxlVHlwZTogXCJsaXN0LXN0eWxlLXR5cGVcIixcbiAgbWFyZ2luOiBcIm1hcmdpblwiLFxuICBtYXJnaW5Ub3A6IFwibWFyZ2luLXRvcFwiLFxuICBtYXJnaW5SaWdodDogXCJtYXJnaW4tcmlnaHRcIixcbiAgbWFyZ2luQm90dG9tOiBcIm1hcmdpbi1ib3R0b21cIixcbiAgbWFyZ2luTGVmdDogXCJtYXJnaW4tbGVmdFwiLFxuICBtYXJrZXJPZmZzZXQ6IFwibWFya2VyLW9mZnNldFwiLFxuICBtYXJrczogXCJtYXJrc1wiLFxuICBtYXhIZWlnaHQ6IFwibWF4LWhlaWdodFwiLFxuICBtYXhXaWR0aDogXCJtYXgtd2lkdGhcIixcbiAgbWluSGVpZ2h0OiBcIm1pbi1oZWlnaHRcIixcbiAgbWluV2lkdGg6IFwibWluLXdpZHRoXCIsXG4gIG9wYWNpdHk6IFwib3BhY2l0eVwiLFxuICBvcnBoYW5zOiBcIm9ycGhhbnNcIixcbiAgb3V0bGluZTogXCJvdXRsaW5lXCIsXG4gIG91dGxpbmVDb2xvcjogXCJvdXRsaW5lLWNvbG9yXCIsXG4gIG91dGxpbmVTdHlsZTogXCJvdXRsaW5lLXN0eWxlXCIsXG4gIG91dGxpbmVXaWR0aDogXCJvdXRsaW5lLXdpZHRoXCIsXG4gIG92ZXJmbG93OiBcIm92ZXJmbG93XCIsXG4gIHBhZGRpbmc6IFwicGFkZGluZ1wiLFxuICBwYWRkaW5nVG9wOiBcInBhZGRpbmctdG9wXCIsXG4gIHBhZGRpbmdSaWdodDogXCJwYWRkaW5nLXJpZ2h0XCIsXG4gIHBhZGRpbmdCb3R0b206IFwicGFkZGluZy1ib3R0b21cIixcbiAgcGFkZGluZ0xlZnQ6IFwicGFkZGluZy1sZWZ0XCIsXG4gIHBhZ2U6IFwicGFnZVwiLFxuICBwYWdlQnJlYWtBZnRlcjogXCJwYWdlLWJyZWFrLWFmdGVyXCIsXG4gIHBhZ2VCcmVha0JlZm9yZTogXCJwYWdlLWJyZWFrLWJlZm9yZVwiLFxuICBwYWdlQnJlYWtJbnNpZGU6IFwicGFnZS1icmVhay1pbnNpZGVcIixcbiAgcG9zaXRpb246IFwicG9zaXRpb25cIixcbiAgcXVvdGVzOiBcInF1b3Rlc1wiLFxuICByaWdodDogXCJyaWdodFwiLFxuICBzaXplOiBcInNpemVcIixcbiAgdGFibGVMYXlvdXQ6IFwidGFibGUtbGF5b3V0XCIsXG4gIHRleHRBbGlnbjogXCJ0ZXh0LWFsaWduXCIsXG4gIHRleHREZWNvcmF0aW9uOiBcInRleHQtZGVjb3JhdGlvblwiLFxuICB0ZXh0SW5kZW50OiBcInRleHQtaW5kZW50XCIsXG4gIHRleHRTaGFkb3c6IFwidGV4dC1zaGFkb3dcIixcbiAgdGV4dFRyYW5zZm9ybTogXCJ0ZXh0LXRyYW5zZm9ybVwiLFxuICB0b3A6IFwidG9wXCIsXG4gIHVuaWNvZGVCaWRpOiBcInVuaWNvZGUtYmlkaVwiLFxuICB2ZXJ0aWNhbEFsaWduOiBcInZlcnRpY2FsLWFsaWduXCIsXG4gIHZpc2liaWxpdHk6IFwidmlzaWJpbGl0eVwiLFxuICB3aGl0ZVNwYWNlOiBcIndoaXRlLXNwYWNlXCIsXG4gIHdpZG93czogXCJ3aWRvd3NcIixcbiAgd2lkdGg6IFwid2lkdGhcIixcbiAgd29yZFNwYWNpbmc6IFwid29yZC1zcGFjaW5nXCIsXG4gIHpJbmRleDogXCJ6LWluZGV4XCIsXG59O1xuXG5mb3IodmFyIHByb3AgaW4gY3NzUHJvcGVydGllcykgZGVmaW5lU3R5bGVQcm9wZXJ0eShwcm9wKTtcblxuZnVuY3Rpb24gZGVmaW5lU3R5bGVQcm9wZXJ0eShqc25hbWUpIHtcbiAgdmFyIGNzc25hbWUgPSBjc3NQcm9wZXJ0aWVzW2pzbmFtZV07XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDU1NTdHlsZURlY2xhcmF0aW9uLnByb3RvdHlwZSwganNuYW1lLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFByb3BlcnR5VmFsdWUoY3NzbmFtZSk7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICB0aGlzLnNldFByb3BlcnR5KGNzc25hbWUsIHZhbHVlKTtcbiAgICB9XG4gIH0pO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZG9taW5vL2xpYi9DU1NTdHlsZURlY2xhcmF0aW9uLmpzXG4vLyBtb2R1bGUgaWQgPSAyNlxuLy8gbW9kdWxlIGNodW5rcyA9IDQiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBET01JbXBsZW1lbnRhdGlvbiA9IHJlcXVpcmUoJy4vRE9NSW1wbGVtZW50YXRpb24nKTtcbnZhciBFdmVudFRhcmdldCA9IHJlcXVpcmUoJy4vRXZlbnRUYXJnZXQnKTtcbnZhciBMb2NhdGlvbiA9IHJlcXVpcmUoJy4vTG9jYXRpb24nKTtcbnZhciBzbG9wcHkgPSByZXF1aXJlKCcuL3Nsb3BweScpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdpbmRvdztcblxuZnVuY3Rpb24gV2luZG93KGRvY3VtZW50KSB7XG4gIHRoaXMuZG9jdW1lbnQgPSBkb2N1bWVudCB8fCBuZXcgRE9NSW1wbGVtZW50YXRpb24oKS5jcmVhdGVIVE1MRG9jdW1lbnQoXCJcIik7XG4gIHRoaXMuZG9jdW1lbnQuX3NjcmlwdGluZ19lbmFibGVkID0gdHJ1ZTtcbiAgdGhpcy5kb2N1bWVudC5kZWZhdWx0VmlldyA9IHRoaXM7XG4gIHRoaXMubG9jYXRpb24gPSBuZXcgTG9jYXRpb24odGhpcywgdGhpcy5kb2N1bWVudC5fYWRkcmVzcyB8fCAnYWJvdXQ6YmxhbmsnKTtcbn1cblxuV2luZG93LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXZlbnRUYXJnZXQucHJvdG90eXBlLCB7XG4gIF9ydW46IHsgdmFsdWU6IHNsb3BweS5XaW5kb3dfcnVuIH0sXG4gIGNvbnNvbGU6IHsgdmFsdWU6IGNvbnNvbGUgfSxcbiAgaGlzdG9yeTogeyB2YWx1ZToge1xuICAgIGJhY2s6IHV0aWxzLm55aSxcbiAgICBmb3J3YXJkOiB1dGlscy5ueWksXG4gICAgZ286IHV0aWxzLm55aVxuICB9fSxcbiAgbmF2aWdhdG9yOiB7IHZhbHVlOiByZXF1aXJlKFwiLi9OYXZpZ2F0b3JJRFwiKSB9LFxuXG4gIC8vIFNlbGYtcmVmZXJlbnRpYWwgcHJvcGVydGllc1xuICB3aW5kb3c6IHsgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH19LFxuICBzZWxmOiB7IGdldDogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9fSxcbiAgZnJhbWVzOiB7IGdldDogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9fSxcblxuICAvLyBTZWxmLXJlZmVyZW50aWFsIHByb3BlcnRpZXMgZm9yIGEgdG9wLWxldmVsIHdpbmRvd1xuICBwYXJlbnQ6IHsgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH19LFxuICB0b3A6IHsgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH19LFxuXG4gIC8vIFdlIGRvbid0IHN1cHBvcnQgYW55IG90aGVyIHdpbmRvd3MgZm9yIG5vd1xuICBsZW5ndGg6IHsgdmFsdWU6IDAgfSwgICAgICAgICAgIC8vIG5vIGZyYW1lc1xuICBmcmFtZUVsZW1lbnQ6IHsgdmFsdWU6IG51bGwgfSwgIC8vIG5vdCBwYXJ0IG9mIGEgZnJhbWVcbiAgb3BlbmVyOiB7IHZhbHVlOiBudWxsIH0sICAgICAgICAvLyBub3Qgb3BlbmVkIGJ5IGFub3RoZXIgd2luZG93XG5cbiAgLy8gVGhlIG9ubG9hZCBldmVudCBoYW5kbGVyLlxuICAvLyBYWFg6IG5lZWQgdG8gc3VwcG9ydCBhIGJ1bmNoIG9mIG90aGVyIGV2ZW50IHR5cGVzLCB0b28sXG4gIC8vIGFuZCBoYXZlIHRoZW0gaW50ZXJvcGVyYXRlIHdpdGggZG9jdW1lbnQuYm9keS5cblxuICBvbmxvYWQ6IHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2dldEV2ZW50SGFuZGxlcihcImxvYWRcIik7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uKHYpIHtcbiAgICAgIHRoaXMuX3NldEV2ZW50SGFuZGxlcihcImxvYWRcIiwgdik7XG4gICAgfVxuICB9LFxuXG4gIC8vIFhYWCBUaGlzIGlzIGEgY29tcGxldGVseSBicm9rZW4gaW1wbGVtZW50YXRpb25cbiAgZ2V0Q29tcHV0ZWRTdHlsZTogeyB2YWx1ZTogZnVuY3Rpb24gZ2V0Q29tcHV0ZWRTdHlsZShlbHQpIHtcbiAgICByZXR1cm4gZWx0LnN0eWxlO1xuICB9fVxuXG59KTtcblxudXRpbHMuZXhwb3NlKHJlcXVpcmUoJy4vV2luZG93VGltZXJzJyksIFdpbmRvdyk7XG51dGlscy5leHBvc2UocmVxdWlyZSgnLi9pbXBsJyksIFdpbmRvdyk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9kb21pbm8vbGliL1dpbmRvdy5qc1xuLy8gbW9kdWxlIGlkID0gMjdcbi8vIG1vZHVsZSBjaHVua3MgPSA0IiwiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IERvY3VtZW50VHlwZTtcblxudmFyIE5vZGUgPSByZXF1aXJlKCcuL05vZGUnKTtcbnZhciBMZWFmID0gcmVxdWlyZSgnLi9MZWFmJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG52YXIgQ2hpbGROb2RlID0gcmVxdWlyZSgnLi9DaGlsZE5vZGUnKTtcblxuZnVuY3Rpb24gRG9jdW1lbnRUeXBlKG5hbWUsIHB1YmxpY0lkLCBzeXN0ZW1JZCkge1xuICAvLyBVbmxpa2Ugb3RoZXIgbm9kZXMsIGRvY3R5cGUgbm9kZXMgYWx3YXlzIHN0YXJ0IG9mZiB1bm93bmVkXG4gIC8vIHVudGlsIGluc2VydGVkXG4gIHRoaXMubm9kZVR5cGUgPSBOb2RlLkRPQ1VNRU5UX1RZUEVfTk9ERTtcbiAgdGhpcy5vd25lckRvY3VtZW50ID0gbnVsbDtcbiAgdGhpcy5uYW1lID0gbmFtZTtcbiAgdGhpcy5wdWJsaWNJZCA9IHB1YmxpY0lkIHx8IFwiXCI7XG4gIHRoaXMuc3lzdGVtSWQgPSBzeXN0ZW1JZCB8fCBcIlwiO1xufVxuXG5Eb2N1bWVudFR5cGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShMZWFmLnByb3RvdHlwZSwge1xuICBub2RlTmFtZTogeyBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5uYW1lOyB9fSxcbiAgbm9kZVZhbHVlOiB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG51bGw7IH0sXG4gICAgc2V0OiBmdW5jdGlvbigpIHt9XG4gIH0sXG5cbiAgLy8gVXRpbGl0eSBtZXRob2RzXG4gIGNsb25lOiB7IHZhbHVlOiBmdW5jdGlvbiBjbG9uZSgpIHtcbiAgICB1dGlscy5EYXRhQ2xvbmVFcnJvcigpO1xuICB9fSxcblxuICBpc0VxdWFsOiB7IHZhbHVlOiBmdW5jdGlvbiBpc0VxdWFsKG4pIHtcbiAgICByZXR1cm4gdGhpcy5uYW1lID09PSBuLm5hbWUgJiZcbiAgICAgIHRoaXMucHVibGljSWQgPT09IG4ucHVibGljSWQgJiZcbiAgICAgIHRoaXMuc3lzdGVtSWQgPT09IG4uc3lzdGVtSWQ7XG4gIH19XG59KTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoRG9jdW1lbnRUeXBlLnByb3RvdHlwZSwgQ2hpbGROb2RlKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2RvbWluby9saWIvRG9jdW1lbnRUeXBlLmpzXG4vLyBtb2R1bGUgaWQgPSAyOFxuLy8gbW9kdWxlIGNodW5rcyA9IDQiLCJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gSFRNTFBhcnNlcjtcblxudmFyIERvY3VtZW50ID0gcmVxdWlyZSgnLi9Eb2N1bWVudCcpO1xudmFyIERvY3VtZW50VHlwZSA9IHJlcXVpcmUoJy4vRG9jdW1lbnRUeXBlJyk7XG52YXIgTm9kZSA9IHJlcXVpcmUoJy4vTm9kZScpO1xudmFyIE5BTUVTUEFDRSA9IHJlcXVpcmUoJy4vdXRpbHMnKS5OQU1FU1BBQ0U7XG52YXIgaHRtbCA9IHJlcXVpcmUoJy4vaHRtbGVsdHMnKTtcbnZhciBpbXBsID0gaHRtbC5lbGVtZW50cztcblxudmFyIHB1c2hBbGwgPSBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuYmluZChBcnJheS5wcm90b3R5cGUucHVzaCk7XG5cbi8qXG4gKiBUaGlzIGZpbGUgY29udGFpbnMgYW4gaW1wbGVtZW50YXRpb24gb2YgdGhlIEhUTUwgcGFyc2luZyBhbGdvcml0aG0uXG4gKiBUaGUgYWxnb3JpdGhtIGFuZCB0aGUgaW1wbGVtZW50YXRpb24gYXJlIGNvbXBsZXggYmVjYXVzZSBIVE1MXG4gKiBleHBsaWNpdGx5IGRlZmluZXMgaG93IHRoZSBwYXJzZXIgc2hvdWxkIGJlaGF2ZSBmb3IgYWxsIHBvc3NpYmxlXG4gKiB2YWxpZCBhbmQgaW52YWxpZCBpbnB1dHMuXG4gKlxuICogVXNhZ2U6XG4gKlxuICogVGhlIGZpbGUgZGVmaW5lcyBhIHNpbmdsZSBIVE1MUGFyc2VyKCkgZnVuY3Rpb24sIHdoaWNoIGRvbS5qcyBleHBvc2VzXG4gKiBwdWJsaWNseSBhcyBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5tb3pIVE1MUGFyc2VyKCkuIFRoaXMgaXMgYVxuICogZmFjdG9yeSBmdW5jdGlvbiwgbm90IGEgY29uc3RydWN0b3IuXG4gKlxuICogV2hlbiB5b3UgY2FsbCBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5tb3pIVE1MUGFyc2VyKCksIGl0IHJldHVybnNcbiAqIGFuIG9iamVjdCB0aGF0IGhhcyBwYXJzZSgpIGFuZCBkb2N1bWVudCgpIG1ldGhvZHMuIFRvIHBhcnNlIEhUTUwgdGV4dCxcbiAqIHBhc3MgdGhlIHRleHQgKGluIG9uZSBvciBtb3JlIGNodW5rcykgdG8gdGhlIHBhcnNlKCkgbWV0aG9kLiAgV2hlblxuICogeW91J3ZlIHBhc3NlZCBhbGwgdGhlIHRleHQgKG9uIHRoZSBsYXN0IGNodW5rLCBvciBhZnRlcndhcmQpIHBhc3NcbiAqIHRydWUgYXMgdGhlIHNlY29uZCBhcmd1bWVudCB0byBwYXJzZSgpIHRvIHRlbGwgdGhlIHBhcnNlciB0aGF0IHRoZXJlXG4gKiBpcyBubyBtb3JlIGNvbWluZy4gQ2FsbCBkb2N1bWVudCgpIHRvIGdldCB0aGUgZG9jdW1lbnQgb2JqZWN0IHRoYXRcbiAqIHRoZSBwYXJzZXIgaXMgcGFyc2luZyBpbnRvLiAgWW91IGNhbiBjYWxsIHRoaXMgYXQgYW55IHRpbWUsIGJlZm9yZVxuICogb3IgYWZ0ZXIgY2FsbGluZyBwYXJzZSgpLlxuICpcbiAqIFRoZSBmaXJzdCBhcmd1bWVudCB0byBtb3pIVE1MUGFyc2VyIGlzIHRoZSBhYnNvbHV0ZSBVUkwgb2YgdGhlIGRvY3VtZW50LlxuICpcbiAqIFRoZSBzZWNvbmQgYXJndW1lbnQgaXMgb3B0aW9uYWwgYW5kIGlzIGZvciBpbnRlcm5hbCB1c2Ugb25seS4gIFBhc3MgYW5cbiAqIGVsZW1lbnQgYXMgdGhlIGZyYWdtZW50Q29udGV4dCB0byBkbyBpbm5lckhUTUwgcGFyc2luZyBmb3IgdGhlXG4gKiBlbGVtZW50LiAgVG8gZG8gaW5uZXJIVE1MIHBhcnNpbmcgb24gYSBkb2N1bWVudCwgcGFzcyBudWxsLiBPdGhlcndpc2UsXG4gKiBvbWl0IHRoZSAybmQgYXJndW1lbnQuIFNlZSBIVE1MRWxlbWVudC5pbm5lckhUTUwgZm9yIGFuIGV4YW1wbGUuICBOb3RlXG4gKiB0aGF0IGlmIHlvdSBwYXNzIGEgY29udGV4dCBlbGVtZW50LCB0aGUgZW5kKCkgbWV0aG9kIHdpbGwgcmV0dXJuIGFuXG4gKiB1bndyYXBwZWQgZG9jdW1lbnQgaW5zdGVhZCBvZiBhIHdyYXBwZWQgb25lLlxuICpcbiAqIEltcGxlbWVudGF0aW9uIGRldGFpbHM6XG4gKlxuICogVGhpcyBpcyBhIGxvbmcgZmlsZSBvZiBhbG1vc3QgNzAwMCBsaW5lcy4gSXQgaXMgc3RydWN0dXJlZCBhcyBvbmVcbiAqIGJpZyBmdW5jdGlvbiBuZXN0ZWQgd2l0aGluIGFub3RoZXIgYmlnIGZ1bmN0aW9uLiAgVGhlIG91dGVyXG4gKiBmdW5jdGlvbiBkZWZpbmVzIGEgYnVuY2ggb2YgY29uc3RhbnQgZGF0YSwgdXRpbGl0eSBmdW5jdGlvbnNcbiAqIHRoYXQgdXNlIHRoYXQgZGF0YSwgYW5kIGEgY291cGxlIG9mIGNsYXNzZXMgdXNlZCBieSB0aGUgcGFyc2VyLlxuICogVGhlIG91dGVyIGZ1bmN0aW9uIGFsc28gZGVmaW5lcyBhbmQgcmV0dXJucyB0aGVcbiAqIGlubmVyIGZ1bmN0aW9uLiBUaGlzIGlubmVyIGZ1bmN0aW9uIGlzIHRoZSBIVE1MUGFyc2VyIGZhY3RvcnlcbiAqIGZ1bmN0aW9uIHRoYXQgaW1wbGVtZW50cyB0aGUgcGFyc2VyIGFuZCBob2xkcyBhbGwgdGhlIHBhcnNlciBzdGF0ZVxuICogYXMgbG9jYWwgdmFyaWFibGVzLiAgVGhlIEhUTUxQYXJzZXIgZnVuY3Rpb24gaXMgcXVpdGUgYmlnIGJlY2F1c2VcbiAqIGl0IGRlZmluZXMgbWFueSBuZXN0ZWQgZnVuY3Rpb25zIHRoYXQgdXNlIHRob3NlIGxvY2FsIHZhcmlhYmxlcy5cbiAqXG4gKiBUaGVyZSBhcmUgdGhyZWUgdGlnaHRseSBjb3VwbGVkIHBhcnNlciBzdGFnZXM6IGEgc2Nhbm5lciwgYVxuICogdG9rZW5pemVyIGFuZCBhIHRyZWUgYnVpbGRlci4gSW4gYSAocG9zc2libHkgbWlzZ3VpZGVkKSBhdHRlbXB0IGF0XG4gKiBlZmZpY2llbmN5LCB0aGUgc3RhZ2VzIGFyZSBub3QgaW1wbGVtZW50ZWQgYXMgc2VwYXJhdGUgY2xhc3NlczpcbiAqIGV2ZXJ5dGhpbmcgc2hhcmVzIHN0YXRlIGFuZCBpcyAobW9zdGx5KSBpbXBsZW1lbnRlZCBpbiBpbXBlcmF0aXZlXG4gKiAocmF0aGVyIHRoYW4gT08pIHN0eWxlLlxuICpcbiAqIFRoZSBzdGFnZXMgb2YgdGhlIHBhcnNlciB3b3JrIGxpa2UgdGhpczogV2hlbiB0aGUgY2xpZW50IGNvZGUgY2FsbHNcbiAqIHRoZSBwYXJzZXIncyBwYXJzZSgpIG1ldGhvZCwgdGhlIHNwZWNpZmllZCBzdHJpbmcgaXMgcGFzc2VkIHRvXG4gKiBzY2FuQ2hhcnMoKS4gVGhlIHNjYW5uZXIgbG9vcHMgdGhyb3VnaCB0aGF0IHN0cmluZyBhbmQgcGFzc2VzIGNoYXJhY3RlcnNcbiAqIChzb21ldGltZXMgb25lIGF0IGEgdGltZSwgc29tZXRpbWVzIGluIGNodW5rcykgdG8gdGhlIHRva2VuaXplciBzdGFnZS5cbiAqIFRoZSB0b2tlbml6ZXIgZ3JvdXBzIHRoZSBjaGFyYWN0ZXJzIGludG8gdG9rZW5zOiB0YWdzLCBlbmR0YWdzLCBydW5zXG4gKiBvZiB0ZXh0LCBjb21tZW50cywgZG9jdHlwZSBkZWNsYXJhdGlvbnMsIGFuZCB0aGUgZW5kLW9mLWZpbGUgKEVPRilcbiAqIHRva2VuLiAgVGhlc2UgdG9rZW5zIGFyZSB0aGVuIHBhc3NlZCB0byB0aGUgdHJlZSBidWlsZGluZyBzdGFnZSB2aWFcbiAqIHRoZSBpbnNlcnRUb2tlbigpIGZ1bmN0aW9uLiAgVGhlIHRyZWUgYnVpbGRpbmcgc3RhZ2UgYnVpbGRzIHVwIHRoZVxuICogZG9jdW1lbnQgdHJlZS5cbiAqXG4gKiBUaGUgdG9rZW5pemVyIHN0YWdlIGlzIGEgZmluaXRlIHN0YXRlIG1hY2hpbmUuICBFYWNoIHN0YXRlIGlzXG4gKiBpbXBsZW1lbnRlZCBhcyBhIGZ1bmN0aW9uIHdpdGggYSBuYW1lIHRoYXQgZW5kcyBpbiBcIl9zdGF0ZVwiLiAgVGhlXG4gKiBpbml0aWFsIHN0YXRlIGlzIGRhdGFfc3RhdGUoKS4gVGhlIGN1cnJlbnQgdG9rZW5pemVyIHN0YXRlIGlzIHN0b3JlZFxuICogaW4gdGhlIHZhcmlhYmxlICd0b2tlbml6ZXInLiAgTW9zdCBzdGF0ZSBmdW5jdGlvbnMgZXhwZWN0IGEgc2luZ2xlXG4gKiBpbnRlZ2VyIGFyZ3VtZW50IHdoaWNoIHJlcHJlc2VudHMgYSBzaW5nbGUgVVRGLTE2IGNvZGVwb2ludC4gIFNvbWVcbiAqIHN0YXRlcyB3YW50IG1vcmUgY2hhcmFjdGVycyBhbmQgc2V0IGEgbG9va2FoZWFkIHByb3BlcnR5IG9uXG4gKiB0aGVtc2VsdmVzLiAgVGhlIHNjYW5DaGFycygpIGZ1bmN0aW9uIGluIHRoZSBzY2FubmVyIGNoZWNrcyBmb3IgdGhpc1xuICogbG9va2FoZWFkIHByb3BlcnR5LiAgSWYgaXQgZG9lc24ndCBleGlzdCwgdGhlbiBzY2FuQ2hhcnMoKSBqdXN0IHBhc3Nlc1xuICogdGhlIG5leHQgaW5wdXQgY2hhcmFjdGVyIHRvIHRoZSBjdXJyZW50IHRva2VuaXplciBzdGF0ZSBmdW5jdGlvbi5cbiAqIE90aGVyd2lzZSwgc2NhbkNoYXJzKCkgbG9va3MgYWhlYWQgKGEgZ2l2ZW4gIyBvZiBjaGFyYWN0ZXJzLCBvciBmb3IgYVxuICogbWF0Y2hpbmcgc3RyaW5nLCBvciBmb3IgYSBtYXRjaGluZyByZWdleHApIGFuZCBwYXNzZXMgYSBzdHJpbmcgb2ZcbiAqIGNoYXJhY3RlcnMgdG8gdGhlIGN1cnJlbnQgdG9rZW5pemVyIHN0YXRlIGZ1bmN0aW9uLlxuICpcbiAqIEFzIGEgc2hvcnRjdXQsIGNlcnRhaW4gc3RhdGVzIG9mIHRoZSB0b2tlbml6ZXIgdXNlIHJlZ3VsYXIgZXhwcmVzc2lvbnNcbiAqIHRvIGxvb2sgYWhlYWQgaW4gdGhlIHNjYW5uZXIncyBpbnB1dCBidWZmZXIgZm9yIHJ1bnMgb2YgdGV4dCwgc2ltcGxlXG4gKiB0YWdzIGFuZCBhdHRyaWJ1dGVzLiAgRm9yIHdlbGwtZm9ybWVkIGlucHV0LCB0aGVzZSBzaG9ydGN1dHMgc2tpcCBhXG4gKiBsb3Qgb2Ygc3RhdGUgdHJhbnNpdGlvbnMgYW5kIHNwZWVkIHRoaW5ncyB1cCBhIGJpdC5cbiAqXG4gKiBXaGVuIGEgdG9rZW5pemVyIHN0YXRlIGZ1bmN0aW9uIGhhcyBjb25zdW1lZCBhIGNvbXBsZXRlIHRva2VuLCBpdFxuICogZW1pdHMgdGhhdCB0b2tlbiwgYnkgY2FsbGluZyBpbnNlcnRUb2tlbigpLCBvciBieSBjYWxsaW5nIGEgdXRpbGl0eVxuICogZnVuY3Rpb24gdGhhdCBpdHNlbGYgY2FsbHMgaW5zZXJ0VG9rZW4oKS4gIFRoZXNlIHRva2VucyBhcmUgcGFzc2VkIHRvXG4gKiB0aGUgdHJlZSBidWlsZGluZyBzdGFnZSwgd2hpY2ggaXMgYWxzbyBhIHN0YXRlIG1hY2hpbmUuICBMaWtlIHRoZVxuICogdG9rZW5pemVyLCB0aGUgdHJlZSBidWlsZGluZyBzdGF0ZXMgYXJlIGltcGxlbWVudGVkIGFzIGZ1bmN0aW9ucywgYW5kXG4gKiB0aGVzZSBmdW5jdGlvbnMgaGF2ZSBuYW1lcyB0aGF0IGVuZCB3aXRoIF9tb2RlIChiZWNhdXNlIHRoZSBIVE1MIHNwZWNcbiAqIHJlZmVycyB0byB0aGVtIGFzIGluc2VydGlvbiBtb2RlcykuIFRoZSBjdXJyZW50IGluc2VydGlvbiBtb2RlIGlzIGhlbGRcbiAqIGJ5IHRoZSAncGFyc2VyJyB2YXJpYWJsZS4gIEVhY2ggaW5zZXJ0aW9uIG1vZGUgZnVuY3Rpb24gdGFrZXMgdXAgdG8gNFxuICogYXJndW1lbnRzLiAgVGhlIGZpcnN0IGlzIGEgdG9rZW4gdHlwZSwgcmVwcmVzZW50ZWQgYnkgdGhlIGNvbnN0YW50c1xuICogVEFHLCBFTkRUQUcsIFRFWFQsIENPTU1FTlQsIERPQ1RZUEUgYW5kIEVPRi4gIFRoZSBzZWNvbmQgYXJndW1lbnQgaXNcbiAqIHRoZSB2YWx1ZSBvZiB0aGUgdG9rZW46IHRoZSB0ZXh0IG9yIGNvbW1lbnQgZGF0YSwgb3IgdGFnbmFtZSBvclxuICogZG9jdHlwZS4gIEZvciB0YWdzLCB0aGUgM3JkIGFyZ3VtZW50IGlzIGFuIGFycmF5IG9mIGF0dHJpYnV0ZXMuICBGb3JcbiAqIERPQ1RZUEVTIGl0IGlzIHRoZSBvcHRpb25hbCBwdWJsaWMgaWQuICBGb3IgdGFncywgdGhlIDR0aCBhcmd1bWVudCBpc1xuICogdHJ1ZSBpZiB0aGUgdGFnIGlzIHNlbGYtY2xvc2luZy4gRm9yIGRvY3R5cGVzLCB0aGUgNHRoIGFyZ3VtZW50IGlzIHRoZVxuICogb3B0aW9uYWwgc3lzdGVtIGlkLlxuICpcbiAqIFNlYXJjaCBmb3IgXCIqKipcIiB0byBmaW5kIHRoZSBtYWpvciBzdWItZGl2aXNpb25zIGluIHRoZSBjb2RlLlxuICovXG5cblxuLyoqKlxuICogRGF0YSBwcm9sb2cuICBMb3RzIG9mIGNvbnN0YW50cyBkZWNsYXJlZCBoZXJlLCBpbmNsdWRpbmcgc29tZVxuICogdmVyeSBsYXJnZSBvYmplY3RzLiAgVGhleSdyZSB1c2VkIHRocm91Z2hvdXQgdGhlIGNvZGUgdGhhdCBmb2xsb3dzXG4gKi9cbi8vIFRva2VuIHR5cGVzIGZvciB0aGUgdHJlZSBidWlsZGVyLlxudmFyIEVPRiA9IC0xO1xudmFyIFRFWFQgPSAxO1xudmFyIFRBRyA9IDI7XG52YXIgRU5EVEFHID0gMztcbnZhciBDT01NRU5UID0gNDtcbnZhciBET0NUWVBFID0gNTtcblxuLy8gQSByZS11c2FibGUgZW1wdHkgYXJyYXlcbnZhciBOT0FUVFJTID0gW107XG5cbi8vIFRoZXNlIERURCBwdWJsaWMgaWRzIHB1dCB0aGUgYnJvd3NlciBpbiBxdWlya3MgbW9kZVxudmFyIHF1aXJreVB1YmxpY0lkcyA9IC9eSFRNTCR8Xi1cXC9cXC9XM09cXC9cXC9EVEQgVzMgSFRNTCBTdHJpY3QgM1xcLjBcXC9cXC9FTlxcL1xcLyR8Xi1cXC9XM0NcXC9EVEQgSFRNTCA0XFwuMCBUcmFuc2l0aW9uYWxcXC9FTiR8XlxcK1xcL1xcL1NpbG1hcmlsXFwvXFwvZHRkIGh0bWwgUHJvIHYwcjExIDE5OTcwMTAxXFwvXFwvfF4tXFwvXFwvQWR2YVNvZnQgTHRkXFwvXFwvRFREIEhUTUwgM1xcLjAgYXNXZWRpdCBcXCsgZXh0ZW5zaW9uc1xcL1xcL3xeLVxcL1xcL0FTXFwvXFwvRFREIEhUTUwgM1xcLjAgYXNXZWRpdCBcXCsgZXh0ZW5zaW9uc1xcL1xcL3xeLVxcL1xcL0lFVEZcXC9cXC9EVEQgSFRNTCAyXFwuMCBMZXZlbCAxXFwvXFwvfF4tXFwvXFwvSUVURlxcL1xcL0RURCBIVE1MIDJcXC4wIExldmVsIDJcXC9cXC98Xi1cXC9cXC9JRVRGXFwvXFwvRFREIEhUTUwgMlxcLjAgU3RyaWN0IExldmVsIDFcXC9cXC98Xi1cXC9cXC9JRVRGXFwvXFwvRFREIEhUTUwgMlxcLjAgU3RyaWN0IExldmVsIDJcXC9cXC98Xi1cXC9cXC9JRVRGXFwvXFwvRFREIEhUTUwgMlxcLjAgU3RyaWN0XFwvXFwvfF4tXFwvXFwvSUVURlxcL1xcL0RURCBIVE1MIDJcXC4wXFwvXFwvfF4tXFwvXFwvSUVURlxcL1xcL0RURCBIVE1MIDJcXC4xRVxcL1xcL3xeLVxcL1xcL0lFVEZcXC9cXC9EVEQgSFRNTCAzXFwuMFxcL1xcL3xeLVxcL1xcL0lFVEZcXC9cXC9EVEQgSFRNTCAzXFwuMiBGaW5hbFxcL1xcL3xeLVxcL1xcL0lFVEZcXC9cXC9EVEQgSFRNTCAzXFwuMlxcL1xcL3xeLVxcL1xcL0lFVEZcXC9cXC9EVEQgSFRNTCAzXFwvXFwvfF4tXFwvXFwvSUVURlxcL1xcL0RURCBIVE1MIExldmVsIDBcXC9cXC98Xi1cXC9cXC9JRVRGXFwvXFwvRFREIEhUTUwgTGV2ZWwgMVxcL1xcL3xeLVxcL1xcL0lFVEZcXC9cXC9EVEQgSFRNTCBMZXZlbCAyXFwvXFwvfF4tXFwvXFwvSUVURlxcL1xcL0RURCBIVE1MIExldmVsIDNcXC9cXC98Xi1cXC9cXC9JRVRGXFwvXFwvRFREIEhUTUwgU3RyaWN0IExldmVsIDBcXC9cXC98Xi1cXC9cXC9JRVRGXFwvXFwvRFREIEhUTUwgU3RyaWN0IExldmVsIDFcXC9cXC98Xi1cXC9cXC9JRVRGXFwvXFwvRFREIEhUTUwgU3RyaWN0IExldmVsIDJcXC9cXC98Xi1cXC9cXC9JRVRGXFwvXFwvRFREIEhUTUwgU3RyaWN0IExldmVsIDNcXC9cXC98Xi1cXC9cXC9JRVRGXFwvXFwvRFREIEhUTUwgU3RyaWN0XFwvXFwvfF4tXFwvXFwvSUVURlxcL1xcL0RURCBIVE1MXFwvXFwvfF4tXFwvXFwvTWV0cml1c1xcL1xcL0RURCBNZXRyaXVzIFByZXNlbnRhdGlvbmFsXFwvXFwvfF4tXFwvXFwvTWljcm9zb2Z0XFwvXFwvRFREIEludGVybmV0IEV4cGxvcmVyIDJcXC4wIEhUTUwgU3RyaWN0XFwvXFwvfF4tXFwvXFwvTWljcm9zb2Z0XFwvXFwvRFREIEludGVybmV0IEV4cGxvcmVyIDJcXC4wIEhUTUxcXC9cXC98Xi1cXC9cXC9NaWNyb3NvZnRcXC9cXC9EVEQgSW50ZXJuZXQgRXhwbG9yZXIgMlxcLjAgVGFibGVzXFwvXFwvfF4tXFwvXFwvTWljcm9zb2Z0XFwvXFwvRFREIEludGVybmV0IEV4cGxvcmVyIDNcXC4wIEhUTUwgU3RyaWN0XFwvXFwvfF4tXFwvXFwvTWljcm9zb2Z0XFwvXFwvRFREIEludGVybmV0IEV4cGxvcmVyIDNcXC4wIEhUTUxcXC9cXC98Xi1cXC9cXC9NaWNyb3NvZnRcXC9cXC9EVEQgSW50ZXJuZXQgRXhwbG9yZXIgM1xcLjAgVGFibGVzXFwvXFwvfF4tXFwvXFwvTmV0c2NhcGUgQ29tbVxcLiBDb3JwXFwuXFwvXFwvRFREIEhUTUxcXC9cXC98Xi1cXC9cXC9OZXRzY2FwZSBDb21tXFwuIENvcnBcXC5cXC9cXC9EVEQgU3RyaWN0IEhUTUxcXC9cXC98Xi1cXC9cXC9PJ1JlaWxseSBhbmQgQXNzb2NpYXRlc1xcL1xcL0RURCBIVE1MIDJcXC4wXFwvXFwvfF4tXFwvXFwvTydSZWlsbHkgYW5kIEFzc29jaWF0ZXNcXC9cXC9EVEQgSFRNTCBFeHRlbmRlZCAxXFwuMFxcL1xcL3xeLVxcL1xcL08nUmVpbGx5IGFuZCBBc3NvY2lhdGVzXFwvXFwvRFREIEhUTUwgRXh0ZW5kZWQgUmVsYXhlZCAxXFwuMFxcL1xcL3xeLVxcL1xcL1NvZnRRdWFkIFNvZnR3YXJlXFwvXFwvRFREIEhvVE1ldGFMIFBSTyA2XFwuMDo6MTk5OTA2MDE6OmV4dGVuc2lvbnMgdG8gSFRNTCA0XFwuMFxcL1xcL3xeLVxcL1xcL1NvZnRRdWFkXFwvXFwvRFREIEhvVE1ldGFMIFBSTyA0XFwuMDo6MTk5NzEwMTA6OmV4dGVuc2lvbnMgdG8gSFRNTCA0XFwuMFxcL1xcL3xeLVxcL1xcL1NweWdsYXNzXFwvXFwvRFREIEhUTUwgMlxcLjAgRXh0ZW5kZWRcXC9cXC98Xi1cXC9cXC9TUVxcL1xcL0RURCBIVE1MIDJcXC4wIEhvVE1ldGFMIFxcKyBleHRlbnNpb25zXFwvXFwvfF4tXFwvXFwvU3VuIE1pY3Jvc3lzdGVtcyBDb3JwXFwuXFwvXFwvRFREIEhvdEphdmEgSFRNTFxcL1xcL3xeLVxcL1xcL1N1biBNaWNyb3N5c3RlbXMgQ29ycFxcLlxcL1xcL0RURCBIb3RKYXZhIFN0cmljdCBIVE1MXFwvXFwvfF4tXFwvXFwvVzNDXFwvXFwvRFREIEhUTUwgMyAxOTk1LTAzLTI0XFwvXFwvfF4tXFwvXFwvVzNDXFwvXFwvRFREIEhUTUwgM1xcLjIgRHJhZnRcXC9cXC98Xi1cXC9cXC9XM0NcXC9cXC9EVEQgSFRNTCAzXFwuMiBGaW5hbFxcL1xcL3xeLVxcL1xcL1czQ1xcL1xcL0RURCBIVE1MIDNcXC4yXFwvXFwvfF4tXFwvXFwvVzNDXFwvXFwvRFREIEhUTUwgM1xcLjJTIERyYWZ0XFwvXFwvfF4tXFwvXFwvVzNDXFwvXFwvRFREIEhUTUwgNFxcLjAgRnJhbWVzZXRcXC9cXC98Xi1cXC9cXC9XM0NcXC9cXC9EVEQgSFRNTCA0XFwuMCBUcmFuc2l0aW9uYWxcXC9cXC98Xi1cXC9cXC9XM0NcXC9cXC9EVEQgSFRNTCBFeHBlcmltZW50YWwgMTk5NjA3MTJcXC9cXC98Xi1cXC9cXC9XM0NcXC9cXC9EVEQgSFRNTCBFeHBlcmltZW50YWwgOTcwNDIxXFwvXFwvfF4tXFwvXFwvVzNDXFwvXFwvRFREIFczIEhUTUxcXC9cXC98Xi1cXC9cXC9XM09cXC9cXC9EVEQgVzMgSFRNTCAzXFwuMFxcL1xcL3xeLVxcL1xcL1dlYlRlY2hzXFwvXFwvRFREIE1vemlsbGEgSFRNTCAyXFwuMFxcL1xcL3xeLVxcL1xcL1dlYlRlY2hzXFwvXFwvRFREIE1vemlsbGEgSFRNTFxcL1xcLy9pO1xuXG52YXIgcXVpcmt5U3lzdGVtSWQgPSBcImh0dHA6Ly93d3cuaWJtLmNvbS9kYXRhL2R0ZC92MTEvaWJteGh0bWwxLXRyYW5zaXRpb25hbC5kdGRcIjtcblxudmFyIGNvbmRpdGlvbmFsbHlRdWlya3lQdWJsaWNJZHMgPSAvXi1cXC9cXC9XM0NcXC9cXC9EVEQgSFRNTCA0XFwuMDEgRnJhbWVzZXRcXC9cXC98Xi1cXC9cXC9XM0NcXC9cXC9EVEQgSFRNTCA0XFwuMDEgVHJhbnNpdGlvbmFsXFwvXFwvL2k7XG5cbi8vIFRoZXNlIERURCBwdWJsaWMgaWRzIHB1dCB0aGUgYnJvd3NlciBpbiBsaW1pdGVkIHF1aXJrcyBtb2RlXG52YXIgbGltaXRlZFF1aXJreVB1YmxpY0lkcyA9IC9eLVxcL1xcL1czQ1xcL1xcL0RURCBYSFRNTCAxXFwuMCBGcmFtZXNldFxcL1xcL3xeLVxcL1xcL1czQ1xcL1xcL0RURCBYSFRNTCAxXFwuMCBUcmFuc2l0aW9uYWxcXC9cXC8vaTtcblxuXG4vLyBFbGVtZW50IHNldHMgYmVsb3cuIFNlZSB0aGUgaXNBKCkgZnVuY3Rpb24gZm9yIGEgd2F5IHRvIHRlc3Rcbi8vIHdoZXRoZXIgYW4gZWxlbWVudCBpcyBhIG1lbWJlciBvZiBhIHNldFxudmFyIHNwZWNpYWxTZXQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuc3BlY2lhbFNldFtOQU1FU1BBQ0UuSFRNTF0gPSB7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgXCJhZGRyZXNzXCI6dHJ1ZSwgXCJhcHBsZXRcIjp0cnVlLCBcImFyZWFcIjp0cnVlLCBcImFydGljbGVcIjp0cnVlLFxuICBcImFzaWRlXCI6dHJ1ZSwgXCJiYXNlXCI6dHJ1ZSwgXCJiYXNlZm9udFwiOnRydWUsIFwiYmdzb3VuZFwiOnRydWUsXG4gIFwiYmxvY2txdW90ZVwiOnRydWUsIFwiYm9keVwiOnRydWUsIFwiYnJcIjp0cnVlLCBcImJ1dHRvblwiOnRydWUsXG4gIFwiY2FwdGlvblwiOnRydWUsIFwiY2VudGVyXCI6dHJ1ZSwgXCJjb2xcIjp0cnVlLCBcImNvbGdyb3VwXCI6dHJ1ZSxcbiAgXCJkZFwiOnRydWUsIFwiZGV0YWlsc1wiOnRydWUsIFwiZGlyXCI6dHJ1ZSxcbiAgXCJkaXZcIjp0cnVlLCBcImRsXCI6dHJ1ZSwgXCJkdFwiOnRydWUsIFwiZW1iZWRcIjp0cnVlLFxuICBcImZpZWxkc2V0XCI6dHJ1ZSwgXCJmaWdjYXB0aW9uXCI6dHJ1ZSwgXCJmaWd1cmVcIjp0cnVlLCBcImZvb3RlclwiOnRydWUsXG4gIFwiZm9ybVwiOnRydWUsIFwiZnJhbWVcIjp0cnVlLCBcImZyYW1lc2V0XCI6dHJ1ZSwgXCJoMVwiOnRydWUsXG4gIFwiaDJcIjp0cnVlLCBcImgzXCI6dHJ1ZSwgXCJoNFwiOnRydWUsIFwiaDVcIjp0cnVlLFxuICBcImg2XCI6dHJ1ZSwgXCJoZWFkXCI6dHJ1ZSwgXCJoZWFkZXJcIjp0cnVlLCBcImhncm91cFwiOnRydWUsXG4gIFwiaHJcIjp0cnVlLCBcImh0bWxcIjp0cnVlLCBcImlmcmFtZVwiOnRydWUsIFwiaW1nXCI6dHJ1ZSxcbiAgXCJpbnB1dFwiOnRydWUsIFwibGlcIjp0cnVlLCBcImxpbmtcIjp0cnVlLFxuICBcImxpc3RpbmdcIjp0cnVlLCBcIm1haW5cIjp0cnVlLCBcIm1hcnF1ZWVcIjp0cnVlLCBcIm1lbnVcIjp0cnVlLCBcIm1ldGFcIjp0cnVlLFxuICBcIm5hdlwiOnRydWUsIFwibm9lbWJlZFwiOnRydWUsIFwibm9mcmFtZXNcIjp0cnVlLCBcIm5vc2NyaXB0XCI6dHJ1ZSxcbiAgXCJvYmplY3RcIjp0cnVlLCBcIm9sXCI6dHJ1ZSwgXCJwXCI6dHJ1ZSwgXCJwYXJhbVwiOnRydWUsXG4gIFwicGxhaW50ZXh0XCI6dHJ1ZSwgXCJwcmVcIjp0cnVlLCBcInNjcmlwdFwiOnRydWUsIFwic2VjdGlvblwiOnRydWUsXG4gIFwic2VsZWN0XCI6dHJ1ZSwgXCJzb3VyY2VcIjp0cnVlLCBcInN0eWxlXCI6dHJ1ZSwgXCJzdW1tYXJ5XCI6dHJ1ZSwgXCJ0YWJsZVwiOnRydWUsXG4gIFwidGJvZHlcIjp0cnVlLCBcInRkXCI6dHJ1ZSwgXCJ0ZW1wbGF0ZVwiOnRydWUsIFwidGV4dGFyZWFcIjp0cnVlLCBcInRmb290XCI6dHJ1ZSxcbiAgXCJ0aFwiOnRydWUsIFwidGhlYWRcIjp0cnVlLCBcInRpdGxlXCI6dHJ1ZSwgXCJ0clwiOnRydWUsIFwidHJhY2tcIjp0cnVlLFxuICAvLyBOb3RlIHRoYXQgXCJ4bXBcIiB3YXMgcmVtb3ZlZCBmcm9tIHRoZSBcInNwZWNpYWxcIiBzZXQgaW4gdGhlIGxhdGVzdFxuICAvLyBzcGVjLCBhcHBhcmVudGx5IGJ5IGFjY2lkZW50OyBzZWVcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3doYXR3Zy9odG1sL3B1bGwvMTkxOVxuICBcInVsXCI6dHJ1ZSwgXCJ3YnJcIjp0cnVlLCBcInhtcFwiOnRydWVcbn07XG5zcGVjaWFsU2V0W05BTUVTUEFDRS5TVkddID0ge1xuICBfX3Byb3RvX186IG51bGwsXG4gIFwiZm9yZWlnbk9iamVjdFwiOiB0cnVlLCBcImRlc2NcIjogdHJ1ZSwgXCJ0aXRsZVwiOiB0cnVlXG59O1xuc3BlY2lhbFNldFtOQU1FU1BBQ0UuTUFUSE1MXSA9IHtcbiAgX19wcm90b19fOiBudWxsLFxuICBcIm1pXCI6dHJ1ZSwgXCJtb1wiOnRydWUsIFwibW5cIjp0cnVlLCBcIm1zXCI6dHJ1ZSxcbiAgXCJtdGV4dFwiOnRydWUsIFwiYW5ub3RhdGlvbi14bWxcIjp0cnVlXG59O1xuXG4vLyBUaGUgc2V0IG9mIGFkZHJlc3MsIGRpdiwgYW5kIHAgSFRNTCB0YWdzXG52YXIgYWRkcmVzc2RpdnBTZXQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuYWRkcmVzc2RpdnBTZXRbTkFNRVNQQUNFLkhUTUxdID0ge1xuICBfX3Byb3RvX186IG51bGwsXG4gIFwiYWRkcmVzc1wiOnRydWUsIFwiZGl2XCI6dHJ1ZSwgXCJwXCI6dHJ1ZVxufTtcblxudmFyIGRkZHRTZXQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuZGRkdFNldFtOQU1FU1BBQ0UuSFRNTF0gPSB7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgXCJkZFwiOnRydWUsIFwiZHRcIjp0cnVlXG59O1xuXG52YXIgdGFibGVzZWN0aW9ucm93U2V0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbnRhYmxlc2VjdGlvbnJvd1NldFtOQU1FU1BBQ0UuSFRNTF0gPSB7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgXCJ0YWJsZVwiOnRydWUsIFwidGhlYWRcIjp0cnVlLCBcInRib2R5XCI6dHJ1ZSwgXCJ0Zm9vdFwiOnRydWUsIFwidHJcIjp0cnVlXG59O1xuXG52YXIgaW1wbGllZEVuZFRhZ3NTZXQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuaW1wbGllZEVuZFRhZ3NTZXRbTkFNRVNQQUNFLkhUTUxdID0ge1xuICBfX3Byb3RvX186IG51bGwsXG4gIFwiZGRcIjogdHJ1ZSwgXCJkdFwiOiB0cnVlLCBcImxpXCI6IHRydWUsIFwibWVudWl0ZW1cIjogdHJ1ZSwgXCJvcHRncm91cFwiOiB0cnVlLFxuICBcIm9wdGlvblwiOiB0cnVlLCBcInBcIjogdHJ1ZSwgXCJyYlwiOiB0cnVlLCBcInJwXCI6IHRydWUsIFwicnRcIjogdHJ1ZSwgXCJydGNcIjogdHJ1ZVxufTtcblxudmFyIHRob3JvdWdoSW1wbGllZEVuZFRhZ3NTZXQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xudGhvcm91Z2hJbXBsaWVkRW5kVGFnc1NldFtOQU1FU1BBQ0UuSFRNTF0gPSB7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgXCJjYXB0aW9uXCI6IHRydWUsIFwiY29sZ3JvdXBcIjogdHJ1ZSwgXCJkZFwiOiB0cnVlLCBcImR0XCI6IHRydWUsIFwibGlcIjogdHJ1ZSxcbiAgXCJvcHRncm91cFwiOiB0cnVlLCBcIm9wdGlvblwiOiB0cnVlLCBcInBcIjogdHJ1ZSwgXCJyYlwiOiB0cnVlLCBcInJwXCI6IHRydWUsXG4gIFwicnRcIjogdHJ1ZSwgXCJydGNcIjogdHJ1ZSwgXCJ0Ym9keVwiOiB0cnVlLCBcInRkXCI6IHRydWUsIFwidGZvb3RcIjogdHJ1ZSxcbiAgXCJ0aFwiOiB0cnVlLCBcInRoZWFkXCI6IHRydWUsIFwidHJcIjogdHJ1ZVxufTtcblxudmFyIHRhYmxlQ29udGV4dFNldCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG50YWJsZUNvbnRleHRTZXRbTkFNRVNQQUNFLkhUTUxdID0ge1xuICBfX3Byb3RvX186IG51bGwsXG4gIFwidGFibGVcIjogdHJ1ZSwgXCJ0ZW1wbGF0ZVwiOiB0cnVlLCBcImh0bWxcIjogdHJ1ZVxufTtcblxudmFyIHRhYmxlQm9keUNvbnRleHRTZXQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xudGFibGVCb2R5Q29udGV4dFNldFtOQU1FU1BBQ0UuSFRNTF0gPSB7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgXCJ0Ym9keVwiOiB0cnVlLCBcInRmb290XCI6IHRydWUsIFwidGhlYWRcIjogdHJ1ZSwgXCJ0ZW1wbGF0ZVwiOiB0cnVlLCBcImh0bWxcIjogdHJ1ZVxufTtcblxudmFyIHRhYmxlUm93Q29udGV4dFNldCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG50YWJsZVJvd0NvbnRleHRTZXRbTkFNRVNQQUNFLkhUTUxdID0ge1xuICBfX3Byb3RvX186IG51bGwsXG4gIFwidHJcIjogdHJ1ZSwgXCJ0ZW1wbGF0ZVwiOiB0cnVlLCBcImh0bWxcIjogdHJ1ZVxufTtcblxuLy8gU2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWw1L2Zvcm1zLmh0bWwjZm9ybS1hc3NvY2lhdGVkLWVsZW1lbnRcbnZhciBmb3JtYXNzb2NpYXRlZFNldCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5mb3JtYXNzb2NpYXRlZFNldFtOQU1FU1BBQ0UuSFRNTF0gPSB7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgXCJidXR0b25cIjogdHJ1ZSwgXCJmaWVsZHNldFwiOiB0cnVlLCBcImlucHV0XCI6IHRydWUsIFwia2V5Z2VuXCI6IHRydWUsXG4gIFwib2JqZWN0XCI6IHRydWUsIFwib3V0cHV0XCI6IHRydWUsIFwic2VsZWN0XCI6IHRydWUsIFwidGV4dGFyZWFcIjogdHJ1ZSxcbiAgXCJpbWdcIjogdHJ1ZVxufTtcblxudmFyIGluU2NvcGVTZXQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuaW5TY29wZVNldFtOQU1FU1BBQ0UuSFRNTF09IHtcbiAgX19wcm90b19fOiBudWxsLFxuICBcImFwcGxldFwiOnRydWUsIFwiY2FwdGlvblwiOnRydWUsIFwiaHRtbFwiOnRydWUsIFwidGFibGVcIjp0cnVlLFxuICBcInRkXCI6dHJ1ZSwgXCJ0aFwiOnRydWUsIFwibWFycXVlZVwiOnRydWUsIFwib2JqZWN0XCI6dHJ1ZSxcbiAgXCJ0ZW1wbGF0ZVwiOnRydWVcbn07XG5pblNjb3BlU2V0W05BTUVTUEFDRS5NQVRITUxdID0ge1xuICBfX3Byb3RvX186IG51bGwsXG4gIFwibWlcIjp0cnVlLCBcIm1vXCI6dHJ1ZSwgXCJtblwiOnRydWUsIFwibXNcIjp0cnVlLFxuICBcIm10ZXh0XCI6dHJ1ZSwgXCJhbm5vdGF0aW9uLXhtbFwiOnRydWVcbn07XG5pblNjb3BlU2V0W05BTUVTUEFDRS5TVkddID0ge1xuICBfX3Byb3RvX186IG51bGwsXG4gIFwiZm9yZWlnbk9iamVjdFwiOnRydWUsIFwiZGVzY1wiOnRydWUsIFwidGl0bGVcIjp0cnVlXG59O1xuXG52YXIgaW5MaXN0SXRlbVNjb3BlU2V0ID0gT2JqZWN0LmNyZWF0ZShpblNjb3BlU2V0KTtcbmluTGlzdEl0ZW1TY29wZVNldFtOQU1FU1BBQ0UuSFRNTF0gPVxuICBPYmplY3QuY3JlYXRlKGluU2NvcGVTZXRbTkFNRVNQQUNFLkhUTUxdKTtcbmluTGlzdEl0ZW1TY29wZVNldFtOQU1FU1BBQ0UuSFRNTF0ub2wgPSB0cnVlO1xuaW5MaXN0SXRlbVNjb3BlU2V0W05BTUVTUEFDRS5IVE1MXS51bCA9IHRydWU7XG5cbnZhciBpbkJ1dHRvblNjb3BlU2V0ID0gT2JqZWN0LmNyZWF0ZShpblNjb3BlU2V0KTtcbmluQnV0dG9uU2NvcGVTZXRbTkFNRVNQQUNFLkhUTUxdID1cbiAgT2JqZWN0LmNyZWF0ZShpblNjb3BlU2V0W05BTUVTUEFDRS5IVE1MXSk7XG5pbkJ1dHRvblNjb3BlU2V0W05BTUVTUEFDRS5IVE1MXS5idXR0b24gPSB0cnVlO1xuXG52YXIgaW5UYWJsZVNjb3BlU2V0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbmluVGFibGVTY29wZVNldFtOQU1FU1BBQ0UuSFRNTF0gPSB7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgXCJodG1sXCI6dHJ1ZSwgXCJ0YWJsZVwiOnRydWUsIFwidGVtcGxhdGVcIjp0cnVlXG59O1xuXG4vLyBUaGUgc2V0IG9mIGVsZW1lbnRzIGZvciBzZWxlY3Qgc2NvcGUgaXMgdGhlIGV2ZXJ5dGhpbmcgKmV4Y2VwdCogdGhlc2VcbnZhciBpbnZlcnRlZFNlbGVjdFNjb3BlU2V0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbmludmVydGVkU2VsZWN0U2NvcGVTZXRbTkFNRVNQQUNFLkhUTUxdID0ge1xuICBfX3Byb3RvX186IG51bGwsXG4gIFwib3B0Z3JvdXBcIjp0cnVlLCBcIm9wdGlvblwiOnRydWVcbn07XG5cbnZhciBtYXRobWxUZXh0SW50ZWdyYXRpb25Qb2ludFNldCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5tYXRobWxUZXh0SW50ZWdyYXRpb25Qb2ludFNldFtOQU1FU1BBQ0UuTUFUSE1MXSA9IHtcbiAgX19wcm90b19fOiBudWxsLFxuICBtaTogdHJ1ZSxcbiAgbW86IHRydWUsXG4gIG1uOiB0cnVlLFxuICBtczogdHJ1ZSxcbiAgbXRleHQ6IHRydWVcbn07XG5cbnZhciBodG1sSW50ZWdyYXRpb25Qb2ludFNldCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5odG1sSW50ZWdyYXRpb25Qb2ludFNldFtOQU1FU1BBQ0UuU1ZHXSA9IHtcbiAgX19wcm90b19fOiBudWxsLFxuICBmb3JlaWduT2JqZWN0OiB0cnVlLFxuICBkZXNjOiB0cnVlLFxuICB0aXRsZTogdHJ1ZVxufTtcblxudmFyIGZvcmVpZ25BdHRyaWJ1dGVzID0ge1xuICBfX3Byb3RvX186IG51bGwsXG4gIFwieGxpbms6YWN0dWF0ZVwiOiBOQU1FU1BBQ0UuWExJTkssIFwieGxpbms6YXJjcm9sZVwiOiBOQU1FU1BBQ0UuWExJTkssXG4gIFwieGxpbms6aHJlZlwiOiAgIE5BTUVTUEFDRS5YTElOSywgIFwieGxpbms6cm9sZVwiOiAgICBOQU1FU1BBQ0UuWExJTkssXG4gIFwieGxpbms6c2hvd1wiOiAgIE5BTUVTUEFDRS5YTElOSywgIFwieGxpbms6dGl0bGVcIjogICBOQU1FU1BBQ0UuWExJTkssXG4gIFwieGxpbms6dHlwZVwiOiAgIE5BTUVTUEFDRS5YTElOSywgIFwieG1sOmJhc2VcIjogICAgICBOQU1FU1BBQ0UuWE1MLFxuICBcInhtbDpsYW5nXCI6ICAgICBOQU1FU1BBQ0UuWE1MLCAgICBcInhtbDpzcGFjZVwiOiAgICAgTkFNRVNQQUNFLlhNTCxcbiAgXCJ4bWxuc1wiOiAgICAgICAgTkFNRVNQQUNFLlhNTE5TLCAgXCJ4bWxuczp4bGlua1wiOiAgIE5BTUVTUEFDRS5YTUxOU1xufTtcblxuXG4vLyBMb3dlcmNhc2UgdG8gbWl4ZWQgY2FzZSBtYXBwaW5nIGZvciBTVkcgYXR0cmlidXRlcyBhbmQgdGFnbmFtZXNcbnZhciBzdmdBdHRyQWRqdXN0bWVudHMgPSB7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgYXR0cmlidXRlbmFtZTogXCJhdHRyaWJ1dGVOYW1lXCIsIGF0dHJpYnV0ZXR5cGU6IFwiYXR0cmlidXRlVHlwZVwiLFxuICBiYXNlZnJlcXVlbmN5OiBcImJhc2VGcmVxdWVuY3lcIiwgYmFzZXByb2ZpbGU6IFwiYmFzZVByb2ZpbGVcIixcbiAgY2FsY21vZGU6IFwiY2FsY01vZGVcIiwgY2xpcHBhdGh1bml0czogXCJjbGlwUGF0aFVuaXRzXCIsXG4gIGRpZmZ1c2Vjb25zdGFudDogXCJkaWZmdXNlQ29uc3RhbnRcIixcbiAgZWRnZW1vZGU6IFwiZWRnZU1vZGVcIixcbiAgZmlsdGVydW5pdHM6IFwiZmlsdGVyVW5pdHNcIixcbiAgZ2x5cGhyZWY6IFwiZ2x5cGhSZWZcIiwgZ3JhZGllbnR0cmFuc2Zvcm06IFwiZ3JhZGllbnRUcmFuc2Zvcm1cIixcbiAgZ3JhZGllbnR1bml0czogXCJncmFkaWVudFVuaXRzXCIsIGtlcm5lbG1hdHJpeDogXCJrZXJuZWxNYXRyaXhcIixcbiAga2VybmVsdW5pdGxlbmd0aDogXCJrZXJuZWxVbml0TGVuZ3RoXCIsIGtleXBvaW50czogXCJrZXlQb2ludHNcIixcbiAga2V5c3BsaW5lczogXCJrZXlTcGxpbmVzXCIsIGtleXRpbWVzOiBcImtleVRpbWVzXCIsXG4gIGxlbmd0aGFkanVzdDogXCJsZW5ndGhBZGp1c3RcIiwgbGltaXRpbmdjb25lYW5nbGU6IFwibGltaXRpbmdDb25lQW5nbGVcIixcbiAgbWFya2VyaGVpZ2h0OiBcIm1hcmtlckhlaWdodFwiLCBtYXJrZXJ1bml0czogXCJtYXJrZXJVbml0c1wiLFxuICBtYXJrZXJ3aWR0aDogXCJtYXJrZXJXaWR0aFwiLCBtYXNrY29udGVudHVuaXRzOiBcIm1hc2tDb250ZW50VW5pdHNcIixcbiAgbWFza3VuaXRzOiBcIm1hc2tVbml0c1wiLCBudW1vY3RhdmVzOiBcIm51bU9jdGF2ZXNcIixcbiAgcGF0aGxlbmd0aDogXCJwYXRoTGVuZ3RoXCIsIHBhdHRlcm5jb250ZW50dW5pdHM6IFwicGF0dGVybkNvbnRlbnRVbml0c1wiLFxuICBwYXR0ZXJudHJhbnNmb3JtOiBcInBhdHRlcm5UcmFuc2Zvcm1cIiwgcGF0dGVybnVuaXRzOiBcInBhdHRlcm5Vbml0c1wiLFxuICBwb2ludHNhdHg6IFwicG9pbnRzQXRYXCIsIHBvaW50c2F0eTogXCJwb2ludHNBdFlcIixcbiAgcG9pbnRzYXR6OiBcInBvaW50c0F0WlwiLCBwcmVzZXJ2ZWFscGhhOiBcInByZXNlcnZlQWxwaGFcIixcbiAgcHJlc2VydmVhc3BlY3RyYXRpbzogXCJwcmVzZXJ2ZUFzcGVjdFJhdGlvXCIsXG4gIHByaW1pdGl2ZXVuaXRzOiBcInByaW1pdGl2ZVVuaXRzXCIsIHJlZng6IFwicmVmWFwiLFxuICByZWZ5OiBcInJlZllcIiwgcmVwZWF0Y291bnQ6IFwicmVwZWF0Q291bnRcIixcbiAgcmVwZWF0ZHVyOiBcInJlcGVhdER1clwiLCByZXF1aXJlZGV4dGVuc2lvbnM6IFwicmVxdWlyZWRFeHRlbnNpb25zXCIsXG4gIHJlcXVpcmVkZmVhdHVyZXM6IFwicmVxdWlyZWRGZWF0dXJlc1wiLFxuICBzcGVjdWxhcmNvbnN0YW50OiBcInNwZWN1bGFyQ29uc3RhbnRcIixcbiAgc3BlY3VsYXJleHBvbmVudDogXCJzcGVjdWxhckV4cG9uZW50XCIsIHNwcmVhZG1ldGhvZDogXCJzcHJlYWRNZXRob2RcIixcbiAgc3RhcnRvZmZzZXQ6IFwic3RhcnRPZmZzZXRcIiwgc3RkZGV2aWF0aW9uOiBcInN0ZERldmlhdGlvblwiLFxuICBzdGl0Y2h0aWxlczogXCJzdGl0Y2hUaWxlc1wiLCBzdXJmYWNlc2NhbGU6IFwic3VyZmFjZVNjYWxlXCIsXG4gIHN5c3RlbWxhbmd1YWdlOiBcInN5c3RlbUxhbmd1YWdlXCIsIHRhYmxldmFsdWVzOiBcInRhYmxlVmFsdWVzXCIsXG4gIHRhcmdldHg6IFwidGFyZ2V0WFwiLCB0YXJnZXR5OiBcInRhcmdldFlcIixcbiAgdGV4dGxlbmd0aDogXCJ0ZXh0TGVuZ3RoXCIsIHZpZXdib3g6IFwidmlld0JveFwiLFxuICB2aWV3dGFyZ2V0OiBcInZpZXdUYXJnZXRcIiwgeGNoYW5uZWxzZWxlY3RvcjogXCJ4Q2hhbm5lbFNlbGVjdG9yXCIsXG4gIHljaGFubmVsc2VsZWN0b3I6IFwieUNoYW5uZWxTZWxlY3RvclwiLCB6b29tYW5kcGFuOiBcInpvb21BbmRQYW5cIlxufTtcblxudmFyIHN2Z1RhZ05hbWVBZGp1c3RtZW50cyA9IHtcbiAgX19wcm90b19fOiBudWxsLFxuICBhbHRnbHlwaDogXCJhbHRHbHlwaFwiLCBhbHRnbHlwaGRlZjogXCJhbHRHbHlwaERlZlwiLFxuICBhbHRnbHlwaGl0ZW06IFwiYWx0R2x5cGhJdGVtXCIsIGFuaW1hdGVjb2xvcjogXCJhbmltYXRlQ29sb3JcIixcbiAgYW5pbWF0ZW1vdGlvbjogXCJhbmltYXRlTW90aW9uXCIsIGFuaW1hdGV0cmFuc2Zvcm06IFwiYW5pbWF0ZVRyYW5zZm9ybVwiLFxuICBjbGlwcGF0aDogXCJjbGlwUGF0aFwiLCBmZWJsZW5kOiBcImZlQmxlbmRcIixcbiAgZmVjb2xvcm1hdHJpeDogXCJmZUNvbG9yTWF0cml4XCIsXG4gIGZlY29tcG9uZW50dHJhbnNmZXI6IFwiZmVDb21wb25lbnRUcmFuc2ZlclwiLCBmZWNvbXBvc2l0ZTogXCJmZUNvbXBvc2l0ZVwiLFxuICBmZWNvbnZvbHZlbWF0cml4OiBcImZlQ29udm9sdmVNYXRyaXhcIixcbiAgZmVkaWZmdXNlbGlnaHRpbmc6IFwiZmVEaWZmdXNlTGlnaHRpbmdcIixcbiAgZmVkaXNwbGFjZW1lbnRtYXA6IFwiZmVEaXNwbGFjZW1lbnRNYXBcIixcbiAgZmVkaXN0YW50bGlnaHQ6IFwiZmVEaXN0YW50TGlnaHRcIiwgZmVmbG9vZDogXCJmZUZsb29kXCIsXG4gIGZlZnVuY2E6IFwiZmVGdW5jQVwiLCBmZWZ1bmNiOiBcImZlRnVuY0JcIixcbiAgZmVmdW5jZzogXCJmZUZ1bmNHXCIsIGZlZnVuY3I6IFwiZmVGdW5jUlwiLFxuICBmZWdhdXNzaWFuYmx1cjogXCJmZUdhdXNzaWFuQmx1clwiLCBmZWltYWdlOiBcImZlSW1hZ2VcIixcbiAgZmVtZXJnZTogXCJmZU1lcmdlXCIsIGZlbWVyZ2Vub2RlOiBcImZlTWVyZ2VOb2RlXCIsXG4gIGZlbW9ycGhvbG9neTogXCJmZU1vcnBob2xvZ3lcIiwgZmVvZmZzZXQ6IFwiZmVPZmZzZXRcIixcbiAgZmVwb2ludGxpZ2h0OiBcImZlUG9pbnRMaWdodFwiLCBmZXNwZWN1bGFybGlnaHRpbmc6IFwiZmVTcGVjdWxhckxpZ2h0aW5nXCIsXG4gIGZlc3BvdGxpZ2h0OiBcImZlU3BvdExpZ2h0XCIsIGZldGlsZTogXCJmZVRpbGVcIixcbiAgZmV0dXJidWxlbmNlOiBcImZlVHVyYnVsZW5jZVwiLCBmb3JlaWdub2JqZWN0OiBcImZvcmVpZ25PYmplY3RcIixcbiAgZ2x5cGhyZWY6IFwiZ2x5cGhSZWZcIiwgbGluZWFyZ3JhZGllbnQ6IFwibGluZWFyR3JhZGllbnRcIixcbiAgcmFkaWFsZ3JhZGllbnQ6IFwicmFkaWFsR3JhZGllbnRcIiwgdGV4dHBhdGg6IFwidGV4dFBhdGhcIlxufTtcblxuXG4vLyBEYXRhIGZvciBwYXJzaW5nIG51bWVyaWMgYW5kIG5hbWVkIGNoYXJhY3RlciByZWZlcmVuY2VzXG4vLyBUaGVzZSBuZXh0IDMgb2JqZWN0cyBhcmUgZGlyZWN0IHRyYW5zbGF0aW9ucyBvZiB0YWJsZXNcbi8vIGluIHRoZSBIVE1MIHNwZWMgaW50byBKYXZhU2NyaXB0IG9iamVjdCBmb3JtYXRcbnZhciBudW1lcmljQ2hhclJlZlJlcGxhY2VtZW50cyA9IHtcbiAgX19wcm90b19fOiBudWxsLFxuICAweDAwOjB4RkZGRCwgMHg4MDoweDIwQUMsIDB4ODI6MHgyMDFBLCAweDgzOjB4MDE5MiwgMHg4NDoweDIwMUUsXG4gIDB4ODU6MHgyMDI2LCAweDg2OjB4MjAyMCwgMHg4NzoweDIwMjEsIDB4ODg6MHgwMkM2LCAweDg5OjB4MjAzMCxcbiAgMHg4QToweDAxNjAsIDB4OEI6MHgyMDM5LCAweDhDOjB4MDE1MiwgMHg4RToweDAxN0QsIDB4OTE6MHgyMDE4LFxuICAweDkyOjB4MjAxOSwgMHg5MzoweDIwMUMsIDB4OTQ6MHgyMDFELCAweDk1OjB4MjAyMiwgMHg5NjoweDIwMTMsXG4gIDB4OTc6MHgyMDE0LCAweDk4OjB4MDJEQywgMHg5OToweDIxMjIsIDB4OUE6MHgwMTYxLCAweDlCOjB4MjAzQSxcbiAgMHg5QzoweDAxNTMsIDB4OUU6MHgwMTdFLCAweDlGOjB4MDE3OFxufTtcblxuLypcbiAqIFRoaXMgdGFibGUgaXMgZ2VuZXJhdGVkIHdpdGggdGVzdC90b29scy91cGRhdGUtZW50aXRpZXMuanNcbiAqL1xudmFyIG5hbWVkQ2hhclJlZnMgPSB7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgXCJBRWxpZ1wiOjB4YzYsIFwiQUVsaWc7XCI6MHhjNixcbiAgXCJBTVBcIjoweDI2LCBcIkFNUDtcIjoweDI2LFxuICBcIkFhY3V0ZVwiOjB4YzEsIFwiQWFjdXRlO1wiOjB4YzEsXG4gIFwiQWJyZXZlO1wiOjB4MTAyLCBcIkFjaXJjXCI6MHhjMixcbiAgXCJBY2lyYztcIjoweGMyLCBcIkFjeTtcIjoweDQxMCxcbiAgXCJBZnI7XCI6WzB4ZDgzNSwweGRkMDRdLCBcIkFncmF2ZVwiOjB4YzAsXG4gIFwiQWdyYXZlO1wiOjB4YzAsIFwiQWxwaGE7XCI6MHgzOTEsXG4gIFwiQW1hY3I7XCI6MHgxMDAsIFwiQW5kO1wiOjB4MmE1MyxcbiAgXCJBb2dvbjtcIjoweDEwNCwgXCJBb3BmO1wiOlsweGQ4MzUsMHhkZDM4XSxcbiAgXCJBcHBseUZ1bmN0aW9uO1wiOjB4MjA2MSwgXCJBcmluZ1wiOjB4YzUsXG4gIFwiQXJpbmc7XCI6MHhjNSwgXCJBc2NyO1wiOlsweGQ4MzUsMHhkYzljXSxcbiAgXCJBc3NpZ247XCI6MHgyMjU0LCBcIkF0aWxkZVwiOjB4YzMsXG4gIFwiQXRpbGRlO1wiOjB4YzMsIFwiQXVtbFwiOjB4YzQsXG4gIFwiQXVtbDtcIjoweGM0LCBcIkJhY2tzbGFzaDtcIjoweDIyMTYsXG4gIFwiQmFydjtcIjoweDJhZTcsIFwiQmFyd2VkO1wiOjB4MjMwNixcbiAgXCJCY3k7XCI6MHg0MTEsIFwiQmVjYXVzZTtcIjoweDIyMzUsXG4gIFwiQmVybm91bGxpcztcIjoweDIxMmMsIFwiQmV0YTtcIjoweDM5MixcbiAgXCJCZnI7XCI6WzB4ZDgzNSwweGRkMDVdLCBcIkJvcGY7XCI6WzB4ZDgzNSwweGRkMzldLFxuICBcIkJyZXZlO1wiOjB4MmQ4LCBcIkJzY3I7XCI6MHgyMTJjLFxuICBcIkJ1bXBlcTtcIjoweDIyNGUsIFwiQ0hjeTtcIjoweDQyNyxcbiAgXCJDT1BZXCI6MHhhOSwgXCJDT1BZO1wiOjB4YTksXG4gIFwiQ2FjdXRlO1wiOjB4MTA2LCBcIkNhcDtcIjoweDIyZDIsXG4gIFwiQ2FwaXRhbERpZmZlcmVudGlhbEQ7XCI6MHgyMTQ1LCBcIkNheWxleXM7XCI6MHgyMTJkLFxuICBcIkNjYXJvbjtcIjoweDEwYywgXCJDY2VkaWxcIjoweGM3LFxuICBcIkNjZWRpbDtcIjoweGM3LCBcIkNjaXJjO1wiOjB4MTA4LFxuICBcIkNjb25pbnQ7XCI6MHgyMjMwLCBcIkNkb3Q7XCI6MHgxMGEsXG4gIFwiQ2VkaWxsYTtcIjoweGI4LCBcIkNlbnRlckRvdDtcIjoweGI3LFxuICBcIkNmcjtcIjoweDIxMmQsIFwiQ2hpO1wiOjB4M2E3LFxuICBcIkNpcmNsZURvdDtcIjoweDIyOTksIFwiQ2lyY2xlTWludXM7XCI6MHgyMjk2LFxuICBcIkNpcmNsZVBsdXM7XCI6MHgyMjk1LCBcIkNpcmNsZVRpbWVzO1wiOjB4MjI5NyxcbiAgXCJDbG9ja3dpc2VDb250b3VySW50ZWdyYWw7XCI6MHgyMjMyLCBcIkNsb3NlQ3VybHlEb3VibGVRdW90ZTtcIjoweDIwMWQsXG4gIFwiQ2xvc2VDdXJseVF1b3RlO1wiOjB4MjAxOSwgXCJDb2xvbjtcIjoweDIyMzcsXG4gIFwiQ29sb25lO1wiOjB4MmE3NCwgXCJDb25ncnVlbnQ7XCI6MHgyMjYxLFxuICBcIkNvbmludDtcIjoweDIyMmYsIFwiQ29udG91ckludGVncmFsO1wiOjB4MjIyZSxcbiAgXCJDb3BmO1wiOjB4MjEwMiwgXCJDb3Byb2R1Y3Q7XCI6MHgyMjEwLFxuICBcIkNvdW50ZXJDbG9ja3dpc2VDb250b3VySW50ZWdyYWw7XCI6MHgyMjMzLCBcIkNyb3NzO1wiOjB4MmEyZixcbiAgXCJDc2NyO1wiOlsweGQ4MzUsMHhkYzllXSwgXCJDdXA7XCI6MHgyMmQzLFxuICBcIkN1cENhcDtcIjoweDIyNGQsIFwiREQ7XCI6MHgyMTQ1LFxuICBcIkREb3RyYWhkO1wiOjB4MjkxMSwgXCJESmN5O1wiOjB4NDAyLFxuICBcIkRTY3k7XCI6MHg0MDUsIFwiRFpjeTtcIjoweDQwZixcbiAgXCJEYWdnZXI7XCI6MHgyMDIxLCBcIkRhcnI7XCI6MHgyMWExLFxuICBcIkRhc2h2O1wiOjB4MmFlNCwgXCJEY2Fyb247XCI6MHgxMGUsXG4gIFwiRGN5O1wiOjB4NDE0LCBcIkRlbDtcIjoweDIyMDcsXG4gIFwiRGVsdGE7XCI6MHgzOTQsIFwiRGZyO1wiOlsweGQ4MzUsMHhkZDA3XSxcbiAgXCJEaWFjcml0aWNhbEFjdXRlO1wiOjB4YjQsIFwiRGlhY3JpdGljYWxEb3Q7XCI6MHgyZDksXG4gIFwiRGlhY3JpdGljYWxEb3VibGVBY3V0ZTtcIjoweDJkZCwgXCJEaWFjcml0aWNhbEdyYXZlO1wiOjB4NjAsXG4gIFwiRGlhY3JpdGljYWxUaWxkZTtcIjoweDJkYywgXCJEaWFtb25kO1wiOjB4MjJjNCxcbiAgXCJEaWZmZXJlbnRpYWxEO1wiOjB4MjE0NiwgXCJEb3BmO1wiOlsweGQ4MzUsMHhkZDNiXSxcbiAgXCJEb3Q7XCI6MHhhOCwgXCJEb3REb3Q7XCI6MHgyMGRjLFxuICBcIkRvdEVxdWFsO1wiOjB4MjI1MCwgXCJEb3VibGVDb250b3VySW50ZWdyYWw7XCI6MHgyMjJmLFxuICBcIkRvdWJsZURvdDtcIjoweGE4LCBcIkRvdWJsZURvd25BcnJvdztcIjoweDIxZDMsXG4gIFwiRG91YmxlTGVmdEFycm93O1wiOjB4MjFkMCwgXCJEb3VibGVMZWZ0UmlnaHRBcnJvdztcIjoweDIxZDQsXG4gIFwiRG91YmxlTGVmdFRlZTtcIjoweDJhZTQsIFwiRG91YmxlTG9uZ0xlZnRBcnJvdztcIjoweDI3ZjgsXG4gIFwiRG91YmxlTG9uZ0xlZnRSaWdodEFycm93O1wiOjB4MjdmYSwgXCJEb3VibGVMb25nUmlnaHRBcnJvdztcIjoweDI3ZjksXG4gIFwiRG91YmxlUmlnaHRBcnJvdztcIjoweDIxZDIsIFwiRG91YmxlUmlnaHRUZWU7XCI6MHgyMmE4LFxuICBcIkRvdWJsZVVwQXJyb3c7XCI6MHgyMWQxLCBcIkRvdWJsZVVwRG93bkFycm93O1wiOjB4MjFkNSxcbiAgXCJEb3VibGVWZXJ0aWNhbEJhcjtcIjoweDIyMjUsIFwiRG93bkFycm93O1wiOjB4MjE5MyxcbiAgXCJEb3duQXJyb3dCYXI7XCI6MHgyOTEzLCBcIkRvd25BcnJvd1VwQXJyb3c7XCI6MHgyMWY1LFxuICBcIkRvd25CcmV2ZTtcIjoweDMxMSwgXCJEb3duTGVmdFJpZ2h0VmVjdG9yO1wiOjB4Mjk1MCxcbiAgXCJEb3duTGVmdFRlZVZlY3RvcjtcIjoweDI5NWUsIFwiRG93bkxlZnRWZWN0b3I7XCI6MHgyMWJkLFxuICBcIkRvd25MZWZ0VmVjdG9yQmFyO1wiOjB4Mjk1NiwgXCJEb3duUmlnaHRUZWVWZWN0b3I7XCI6MHgyOTVmLFxuICBcIkRvd25SaWdodFZlY3RvcjtcIjoweDIxYzEsIFwiRG93blJpZ2h0VmVjdG9yQmFyO1wiOjB4Mjk1NyxcbiAgXCJEb3duVGVlO1wiOjB4MjJhNCwgXCJEb3duVGVlQXJyb3c7XCI6MHgyMWE3LFxuICBcIkRvd25hcnJvdztcIjoweDIxZDMsIFwiRHNjcjtcIjpbMHhkODM1LDB4ZGM5Zl0sXG4gIFwiRHN0cm9rO1wiOjB4MTEwLCBcIkVORztcIjoweDE0YSxcbiAgXCJFVEhcIjoweGQwLCBcIkVUSDtcIjoweGQwLFxuICBcIkVhY3V0ZVwiOjB4YzksIFwiRWFjdXRlO1wiOjB4YzksXG4gIFwiRWNhcm9uO1wiOjB4MTFhLCBcIkVjaXJjXCI6MHhjYSxcbiAgXCJFY2lyYztcIjoweGNhLCBcIkVjeTtcIjoweDQyZCxcbiAgXCJFZG90O1wiOjB4MTE2LCBcIkVmcjtcIjpbMHhkODM1LDB4ZGQwOF0sXG4gIFwiRWdyYXZlXCI6MHhjOCwgXCJFZ3JhdmU7XCI6MHhjOCxcbiAgXCJFbGVtZW50O1wiOjB4MjIwOCwgXCJFbWFjcjtcIjoweDExMixcbiAgXCJFbXB0eVNtYWxsU3F1YXJlO1wiOjB4MjVmYiwgXCJFbXB0eVZlcnlTbWFsbFNxdWFyZTtcIjoweDI1YWIsXG4gIFwiRW9nb247XCI6MHgxMTgsIFwiRW9wZjtcIjpbMHhkODM1LDB4ZGQzY10sXG4gIFwiRXBzaWxvbjtcIjoweDM5NSwgXCJFcXVhbDtcIjoweDJhNzUsXG4gIFwiRXF1YWxUaWxkZTtcIjoweDIyNDIsIFwiRXF1aWxpYnJpdW07XCI6MHgyMWNjLFxuICBcIkVzY3I7XCI6MHgyMTMwLCBcIkVzaW07XCI6MHgyYTczLFxuICBcIkV0YTtcIjoweDM5NywgXCJFdW1sXCI6MHhjYixcbiAgXCJFdW1sO1wiOjB4Y2IsIFwiRXhpc3RzO1wiOjB4MjIwMyxcbiAgXCJFeHBvbmVudGlhbEU7XCI6MHgyMTQ3LCBcIkZjeTtcIjoweDQyNCxcbiAgXCJGZnI7XCI6WzB4ZDgzNSwweGRkMDldLCBcIkZpbGxlZFNtYWxsU3F1YXJlO1wiOjB4MjVmYyxcbiAgXCJGaWxsZWRWZXJ5U21hbGxTcXVhcmU7XCI6MHgyNWFhLCBcIkZvcGY7XCI6WzB4ZDgzNSwweGRkM2RdLFxuICBcIkZvckFsbDtcIjoweDIyMDAsIFwiRm91cmllcnRyZjtcIjoweDIxMzEsXG4gIFwiRnNjcjtcIjoweDIxMzEsIFwiR0pjeTtcIjoweDQwMyxcbiAgXCJHVFwiOjB4M2UsIFwiR1Q7XCI6MHgzZSxcbiAgXCJHYW1tYTtcIjoweDM5MywgXCJHYW1tYWQ7XCI6MHgzZGMsXG4gIFwiR2JyZXZlO1wiOjB4MTFlLCBcIkdjZWRpbDtcIjoweDEyMixcbiAgXCJHY2lyYztcIjoweDExYywgXCJHY3k7XCI6MHg0MTMsXG4gIFwiR2RvdDtcIjoweDEyMCwgXCJHZnI7XCI6WzB4ZDgzNSwweGRkMGFdLFxuICBcIkdnO1wiOjB4MjJkOSwgXCJHb3BmO1wiOlsweGQ4MzUsMHhkZDNlXSxcbiAgXCJHcmVhdGVyRXF1YWw7XCI6MHgyMjY1LCBcIkdyZWF0ZXJFcXVhbExlc3M7XCI6MHgyMmRiLFxuICBcIkdyZWF0ZXJGdWxsRXF1YWw7XCI6MHgyMjY3LCBcIkdyZWF0ZXJHcmVhdGVyO1wiOjB4MmFhMixcbiAgXCJHcmVhdGVyTGVzcztcIjoweDIyNzcsIFwiR3JlYXRlclNsYW50RXF1YWw7XCI6MHgyYTdlLFxuICBcIkdyZWF0ZXJUaWxkZTtcIjoweDIyNzMsIFwiR3NjcjtcIjpbMHhkODM1LDB4ZGNhMl0sXG4gIFwiR3Q7XCI6MHgyMjZiLCBcIkhBUkRjeTtcIjoweDQyYSxcbiAgXCJIYWNlaztcIjoweDJjNywgXCJIYXQ7XCI6MHg1ZSxcbiAgXCJIY2lyYztcIjoweDEyNCwgXCJIZnI7XCI6MHgyMTBjLFxuICBcIkhpbGJlcnRTcGFjZTtcIjoweDIxMGIsIFwiSG9wZjtcIjoweDIxMGQsXG4gIFwiSG9yaXpvbnRhbExpbmU7XCI6MHgyNTAwLCBcIkhzY3I7XCI6MHgyMTBiLFxuICBcIkhzdHJvaztcIjoweDEyNiwgXCJIdW1wRG93bkh1bXA7XCI6MHgyMjRlLFxuICBcIkh1bXBFcXVhbDtcIjoweDIyNGYsIFwiSUVjeTtcIjoweDQxNSxcbiAgXCJJSmxpZztcIjoweDEzMiwgXCJJT2N5O1wiOjB4NDAxLFxuICBcIklhY3V0ZVwiOjB4Y2QsIFwiSWFjdXRlO1wiOjB4Y2QsXG4gIFwiSWNpcmNcIjoweGNlLCBcIkljaXJjO1wiOjB4Y2UsXG4gIFwiSWN5O1wiOjB4NDE4LCBcIklkb3Q7XCI6MHgxMzAsXG4gIFwiSWZyO1wiOjB4MjExMSwgXCJJZ3JhdmVcIjoweGNjLFxuICBcIklncmF2ZTtcIjoweGNjLCBcIkltO1wiOjB4MjExMSxcbiAgXCJJbWFjcjtcIjoweDEyYSwgXCJJbWFnaW5hcnlJO1wiOjB4MjE0OCxcbiAgXCJJbXBsaWVzO1wiOjB4MjFkMiwgXCJJbnQ7XCI6MHgyMjJjLFxuICBcIkludGVncmFsO1wiOjB4MjIyYiwgXCJJbnRlcnNlY3Rpb247XCI6MHgyMmMyLFxuICBcIkludmlzaWJsZUNvbW1hO1wiOjB4MjA2MywgXCJJbnZpc2libGVUaW1lcztcIjoweDIwNjIsXG4gIFwiSW9nb247XCI6MHgxMmUsIFwiSW9wZjtcIjpbMHhkODM1LDB4ZGQ0MF0sXG4gIFwiSW90YTtcIjoweDM5OSwgXCJJc2NyO1wiOjB4MjExMCxcbiAgXCJJdGlsZGU7XCI6MHgxMjgsIFwiSXVrY3k7XCI6MHg0MDYsXG4gIFwiSXVtbFwiOjB4Y2YsIFwiSXVtbDtcIjoweGNmLFxuICBcIkpjaXJjO1wiOjB4MTM0LCBcIkpjeTtcIjoweDQxOSxcbiAgXCJKZnI7XCI6WzB4ZDgzNSwweGRkMGRdLCBcIkpvcGY7XCI6WzB4ZDgzNSwweGRkNDFdLFxuICBcIkpzY3I7XCI6WzB4ZDgzNSwweGRjYTVdLCBcIkpzZXJjeTtcIjoweDQwOCxcbiAgXCJKdWtjeTtcIjoweDQwNCwgXCJLSGN5O1wiOjB4NDI1LFxuICBcIktKY3k7XCI6MHg0MGMsIFwiS2FwcGE7XCI6MHgzOWEsXG4gIFwiS2NlZGlsO1wiOjB4MTM2LCBcIktjeTtcIjoweDQxYSxcbiAgXCJLZnI7XCI6WzB4ZDgzNSwweGRkMGVdLCBcIktvcGY7XCI6WzB4ZDgzNSwweGRkNDJdLFxuICBcIktzY3I7XCI6WzB4ZDgzNSwweGRjYTZdLCBcIkxKY3k7XCI6MHg0MDksXG4gIFwiTFRcIjoweDNjLCBcIkxUO1wiOjB4M2MsXG4gIFwiTGFjdXRlO1wiOjB4MTM5LCBcIkxhbWJkYTtcIjoweDM5YixcbiAgXCJMYW5nO1wiOjB4MjdlYSwgXCJMYXBsYWNldHJmO1wiOjB4MjExMixcbiAgXCJMYXJyO1wiOjB4MjE5ZSwgXCJMY2Fyb247XCI6MHgxM2QsXG4gIFwiTGNlZGlsO1wiOjB4MTNiLCBcIkxjeTtcIjoweDQxYixcbiAgXCJMZWZ0QW5nbGVCcmFja2V0O1wiOjB4MjdlOCwgXCJMZWZ0QXJyb3c7XCI6MHgyMTkwLFxuICBcIkxlZnRBcnJvd0JhcjtcIjoweDIxZTQsIFwiTGVmdEFycm93UmlnaHRBcnJvdztcIjoweDIxYzYsXG4gIFwiTGVmdENlaWxpbmc7XCI6MHgyMzA4LCBcIkxlZnREb3VibGVCcmFja2V0O1wiOjB4MjdlNixcbiAgXCJMZWZ0RG93blRlZVZlY3RvcjtcIjoweDI5NjEsIFwiTGVmdERvd25WZWN0b3I7XCI6MHgyMWMzLFxuICBcIkxlZnREb3duVmVjdG9yQmFyO1wiOjB4Mjk1OSwgXCJMZWZ0Rmxvb3I7XCI6MHgyMzBhLFxuICBcIkxlZnRSaWdodEFycm93O1wiOjB4MjE5NCwgXCJMZWZ0UmlnaHRWZWN0b3I7XCI6MHgyOTRlLFxuICBcIkxlZnRUZWU7XCI6MHgyMmEzLCBcIkxlZnRUZWVBcnJvdztcIjoweDIxYTQsXG4gIFwiTGVmdFRlZVZlY3RvcjtcIjoweDI5NWEsIFwiTGVmdFRyaWFuZ2xlO1wiOjB4MjJiMixcbiAgXCJMZWZ0VHJpYW5nbGVCYXI7XCI6MHgyOWNmLCBcIkxlZnRUcmlhbmdsZUVxdWFsO1wiOjB4MjJiNCxcbiAgXCJMZWZ0VXBEb3duVmVjdG9yO1wiOjB4Mjk1MSwgXCJMZWZ0VXBUZWVWZWN0b3I7XCI6MHgyOTYwLFxuICBcIkxlZnRVcFZlY3RvcjtcIjoweDIxYmYsIFwiTGVmdFVwVmVjdG9yQmFyO1wiOjB4Mjk1OCxcbiAgXCJMZWZ0VmVjdG9yO1wiOjB4MjFiYywgXCJMZWZ0VmVjdG9yQmFyO1wiOjB4Mjk1MixcbiAgXCJMZWZ0YXJyb3c7XCI6MHgyMWQwLCBcIkxlZnRyaWdodGFycm93O1wiOjB4MjFkNCxcbiAgXCJMZXNzRXF1YWxHcmVhdGVyO1wiOjB4MjJkYSwgXCJMZXNzRnVsbEVxdWFsO1wiOjB4MjI2NixcbiAgXCJMZXNzR3JlYXRlcjtcIjoweDIyNzYsIFwiTGVzc0xlc3M7XCI6MHgyYWExLFxuICBcIkxlc3NTbGFudEVxdWFsO1wiOjB4MmE3ZCwgXCJMZXNzVGlsZGU7XCI6MHgyMjcyLFxuICBcIkxmcjtcIjpbMHhkODM1LDB4ZGQwZl0sIFwiTGw7XCI6MHgyMmQ4LFxuICBcIkxsZWZ0YXJyb3c7XCI6MHgyMWRhLCBcIkxtaWRvdDtcIjoweDEzZixcbiAgXCJMb25nTGVmdEFycm93O1wiOjB4MjdmNSwgXCJMb25nTGVmdFJpZ2h0QXJyb3c7XCI6MHgyN2Y3LFxuICBcIkxvbmdSaWdodEFycm93O1wiOjB4MjdmNiwgXCJMb25nbGVmdGFycm93O1wiOjB4MjdmOCxcbiAgXCJMb25nbGVmdHJpZ2h0YXJyb3c7XCI6MHgyN2ZhLCBcIkxvbmdyaWdodGFycm93O1wiOjB4MjdmOSxcbiAgXCJMb3BmO1wiOlsweGQ4MzUsMHhkZDQzXSwgXCJMb3dlckxlZnRBcnJvdztcIjoweDIxOTksXG4gIFwiTG93ZXJSaWdodEFycm93O1wiOjB4MjE5OCwgXCJMc2NyO1wiOjB4MjExMixcbiAgXCJMc2g7XCI6MHgyMWIwLCBcIkxzdHJvaztcIjoweDE0MSxcbiAgXCJMdDtcIjoweDIyNmEsIFwiTWFwO1wiOjB4MjkwNSxcbiAgXCJNY3k7XCI6MHg0MWMsIFwiTWVkaXVtU3BhY2U7XCI6MHgyMDVmLFxuICBcIk1lbGxpbnRyZjtcIjoweDIxMzMsIFwiTWZyO1wiOlsweGQ4MzUsMHhkZDEwXSxcbiAgXCJNaW51c1BsdXM7XCI6MHgyMjEzLCBcIk1vcGY7XCI6WzB4ZDgzNSwweGRkNDRdLFxuICBcIk1zY3I7XCI6MHgyMTMzLCBcIk11O1wiOjB4MzljLFxuICBcIk5KY3k7XCI6MHg0MGEsIFwiTmFjdXRlO1wiOjB4MTQzLFxuICBcIk5jYXJvbjtcIjoweDE0NywgXCJOY2VkaWw7XCI6MHgxNDUsXG4gIFwiTmN5O1wiOjB4NDFkLCBcIk5lZ2F0aXZlTWVkaXVtU3BhY2U7XCI6MHgyMDBiLFxuICBcIk5lZ2F0aXZlVGhpY2tTcGFjZTtcIjoweDIwMGIsIFwiTmVnYXRpdmVUaGluU3BhY2U7XCI6MHgyMDBiLFxuICBcIk5lZ2F0aXZlVmVyeVRoaW5TcGFjZTtcIjoweDIwMGIsIFwiTmVzdGVkR3JlYXRlckdyZWF0ZXI7XCI6MHgyMjZiLFxuICBcIk5lc3RlZExlc3NMZXNzO1wiOjB4MjI2YSwgXCJOZXdMaW5lO1wiOjB4YSxcbiAgXCJOZnI7XCI6WzB4ZDgzNSwweGRkMTFdLCBcIk5vQnJlYWs7XCI6MHgyMDYwLFxuICBcIk5vbkJyZWFraW5nU3BhY2U7XCI6MHhhMCwgXCJOb3BmO1wiOjB4MjExNSxcbiAgXCJOb3Q7XCI6MHgyYWVjLCBcIk5vdENvbmdydWVudDtcIjoweDIyNjIsXG4gIFwiTm90Q3VwQ2FwO1wiOjB4MjI2ZCwgXCJOb3REb3VibGVWZXJ0aWNhbEJhcjtcIjoweDIyMjYsXG4gIFwiTm90RWxlbWVudDtcIjoweDIyMDksIFwiTm90RXF1YWw7XCI6MHgyMjYwLFxuICBcIk5vdEVxdWFsVGlsZGU7XCI6WzB4MjI0MiwweDMzOF0sIFwiTm90RXhpc3RzO1wiOjB4MjIwNCxcbiAgXCJOb3RHcmVhdGVyO1wiOjB4MjI2ZiwgXCJOb3RHcmVhdGVyRXF1YWw7XCI6MHgyMjcxLFxuICBcIk5vdEdyZWF0ZXJGdWxsRXF1YWw7XCI6WzB4MjI2NywweDMzOF0sIFwiTm90R3JlYXRlckdyZWF0ZXI7XCI6WzB4MjI2YiwweDMzOF0sXG4gIFwiTm90R3JlYXRlckxlc3M7XCI6MHgyMjc5LCBcIk5vdEdyZWF0ZXJTbGFudEVxdWFsO1wiOlsweDJhN2UsMHgzMzhdLFxuICBcIk5vdEdyZWF0ZXJUaWxkZTtcIjoweDIyNzUsIFwiTm90SHVtcERvd25IdW1wO1wiOlsweDIyNGUsMHgzMzhdLFxuICBcIk5vdEh1bXBFcXVhbDtcIjpbMHgyMjRmLDB4MzM4XSwgXCJOb3RMZWZ0VHJpYW5nbGU7XCI6MHgyMmVhLFxuICBcIk5vdExlZnRUcmlhbmdsZUJhcjtcIjpbMHgyOWNmLDB4MzM4XSwgXCJOb3RMZWZ0VHJpYW5nbGVFcXVhbDtcIjoweDIyZWMsXG4gIFwiTm90TGVzcztcIjoweDIyNmUsIFwiTm90TGVzc0VxdWFsO1wiOjB4MjI3MCxcbiAgXCJOb3RMZXNzR3JlYXRlcjtcIjoweDIyNzgsIFwiTm90TGVzc0xlc3M7XCI6WzB4MjI2YSwweDMzOF0sXG4gIFwiTm90TGVzc1NsYW50RXF1YWw7XCI6WzB4MmE3ZCwweDMzOF0sIFwiTm90TGVzc1RpbGRlO1wiOjB4MjI3NCxcbiAgXCJOb3ROZXN0ZWRHcmVhdGVyR3JlYXRlcjtcIjpbMHgyYWEyLDB4MzM4XSwgXCJOb3ROZXN0ZWRMZXNzTGVzcztcIjpbMHgyYWExLDB4MzM4XSxcbiAgXCJOb3RQcmVjZWRlcztcIjoweDIyODAsIFwiTm90UHJlY2VkZXNFcXVhbDtcIjpbMHgyYWFmLDB4MzM4XSxcbiAgXCJOb3RQcmVjZWRlc1NsYW50RXF1YWw7XCI6MHgyMmUwLCBcIk5vdFJldmVyc2VFbGVtZW50O1wiOjB4MjIwYyxcbiAgXCJOb3RSaWdodFRyaWFuZ2xlO1wiOjB4MjJlYiwgXCJOb3RSaWdodFRyaWFuZ2xlQmFyO1wiOlsweDI5ZDAsMHgzMzhdLFxuICBcIk5vdFJpZ2h0VHJpYW5nbGVFcXVhbDtcIjoweDIyZWQsIFwiTm90U3F1YXJlU3Vic2V0O1wiOlsweDIyOGYsMHgzMzhdLFxuICBcIk5vdFNxdWFyZVN1YnNldEVxdWFsO1wiOjB4MjJlMiwgXCJOb3RTcXVhcmVTdXBlcnNldDtcIjpbMHgyMjkwLDB4MzM4XSxcbiAgXCJOb3RTcXVhcmVTdXBlcnNldEVxdWFsO1wiOjB4MjJlMywgXCJOb3RTdWJzZXQ7XCI6WzB4MjI4MiwweDIwZDJdLFxuICBcIk5vdFN1YnNldEVxdWFsO1wiOjB4MjI4OCwgXCJOb3RTdWNjZWVkcztcIjoweDIyODEsXG4gIFwiTm90U3VjY2VlZHNFcXVhbDtcIjpbMHgyYWIwLDB4MzM4XSwgXCJOb3RTdWNjZWVkc1NsYW50RXF1YWw7XCI6MHgyMmUxLFxuICBcIk5vdFN1Y2NlZWRzVGlsZGU7XCI6WzB4MjI3ZiwweDMzOF0sIFwiTm90U3VwZXJzZXQ7XCI6WzB4MjI4MywweDIwZDJdLFxuICBcIk5vdFN1cGVyc2V0RXF1YWw7XCI6MHgyMjg5LCBcIk5vdFRpbGRlO1wiOjB4MjI0MSxcbiAgXCJOb3RUaWxkZUVxdWFsO1wiOjB4MjI0NCwgXCJOb3RUaWxkZUZ1bGxFcXVhbDtcIjoweDIyNDcsXG4gIFwiTm90VGlsZGVUaWxkZTtcIjoweDIyNDksIFwiTm90VmVydGljYWxCYXI7XCI6MHgyMjI0LFxuICBcIk5zY3I7XCI6WzB4ZDgzNSwweGRjYTldLCBcIk50aWxkZVwiOjB4ZDEsXG4gIFwiTnRpbGRlO1wiOjB4ZDEsIFwiTnU7XCI6MHgzOWQsXG4gIFwiT0VsaWc7XCI6MHgxNTIsIFwiT2FjdXRlXCI6MHhkMyxcbiAgXCJPYWN1dGU7XCI6MHhkMywgXCJPY2lyY1wiOjB4ZDQsXG4gIFwiT2NpcmM7XCI6MHhkNCwgXCJPY3k7XCI6MHg0MWUsXG4gIFwiT2RibGFjO1wiOjB4MTUwLCBcIk9mcjtcIjpbMHhkODM1LDB4ZGQxMl0sXG4gIFwiT2dyYXZlXCI6MHhkMiwgXCJPZ3JhdmU7XCI6MHhkMixcbiAgXCJPbWFjcjtcIjoweDE0YywgXCJPbWVnYTtcIjoweDNhOSxcbiAgXCJPbWljcm9uO1wiOjB4MzlmLCBcIk9vcGY7XCI6WzB4ZDgzNSwweGRkNDZdLFxuICBcIk9wZW5DdXJseURvdWJsZVF1b3RlO1wiOjB4MjAxYywgXCJPcGVuQ3VybHlRdW90ZTtcIjoweDIwMTgsXG4gIFwiT3I7XCI6MHgyYTU0LCBcIk9zY3I7XCI6WzB4ZDgzNSwweGRjYWFdLFxuICBcIk9zbGFzaFwiOjB4ZDgsIFwiT3NsYXNoO1wiOjB4ZDgsXG4gIFwiT3RpbGRlXCI6MHhkNSwgXCJPdGlsZGU7XCI6MHhkNSxcbiAgXCJPdGltZXM7XCI6MHgyYTM3LCBcIk91bWxcIjoweGQ2LFxuICBcIk91bWw7XCI6MHhkNiwgXCJPdmVyQmFyO1wiOjB4MjAzZSxcbiAgXCJPdmVyQnJhY2U7XCI6MHgyM2RlLCBcIk92ZXJCcmFja2V0O1wiOjB4MjNiNCxcbiAgXCJPdmVyUGFyZW50aGVzaXM7XCI6MHgyM2RjLCBcIlBhcnRpYWxEO1wiOjB4MjIwMixcbiAgXCJQY3k7XCI6MHg0MWYsIFwiUGZyO1wiOlsweGQ4MzUsMHhkZDEzXSxcbiAgXCJQaGk7XCI6MHgzYTYsIFwiUGk7XCI6MHgzYTAsXG4gIFwiUGx1c01pbnVzO1wiOjB4YjEsIFwiUG9pbmNhcmVwbGFuZTtcIjoweDIxMGMsXG4gIFwiUG9wZjtcIjoweDIxMTksIFwiUHI7XCI6MHgyYWJiLFxuICBcIlByZWNlZGVzO1wiOjB4MjI3YSwgXCJQcmVjZWRlc0VxdWFsO1wiOjB4MmFhZixcbiAgXCJQcmVjZWRlc1NsYW50RXF1YWw7XCI6MHgyMjdjLCBcIlByZWNlZGVzVGlsZGU7XCI6MHgyMjdlLFxuICBcIlByaW1lO1wiOjB4MjAzMywgXCJQcm9kdWN0O1wiOjB4MjIwZixcbiAgXCJQcm9wb3J0aW9uO1wiOjB4MjIzNywgXCJQcm9wb3J0aW9uYWw7XCI6MHgyMjFkLFxuICBcIlBzY3I7XCI6WzB4ZDgzNSwweGRjYWJdLCBcIlBzaTtcIjoweDNhOCxcbiAgXCJRVU9UXCI6MHgyMiwgXCJRVU9UO1wiOjB4MjIsXG4gIFwiUWZyO1wiOlsweGQ4MzUsMHhkZDE0XSwgXCJRb3BmO1wiOjB4MjExYSxcbiAgXCJRc2NyO1wiOlsweGQ4MzUsMHhkY2FjXSwgXCJSQmFycjtcIjoweDI5MTAsXG4gIFwiUkVHXCI6MHhhZSwgXCJSRUc7XCI6MHhhZSxcbiAgXCJSYWN1dGU7XCI6MHgxNTQsIFwiUmFuZztcIjoweDI3ZWIsXG4gIFwiUmFycjtcIjoweDIxYTAsIFwiUmFycnRsO1wiOjB4MjkxNixcbiAgXCJSY2Fyb247XCI6MHgxNTgsIFwiUmNlZGlsO1wiOjB4MTU2LFxuICBcIlJjeTtcIjoweDQyMCwgXCJSZTtcIjoweDIxMWMsXG4gIFwiUmV2ZXJzZUVsZW1lbnQ7XCI6MHgyMjBiLCBcIlJldmVyc2VFcXVpbGlicml1bTtcIjoweDIxY2IsXG4gIFwiUmV2ZXJzZVVwRXF1aWxpYnJpdW07XCI6MHgyOTZmLCBcIlJmcjtcIjoweDIxMWMsXG4gIFwiUmhvO1wiOjB4M2ExLCBcIlJpZ2h0QW5nbGVCcmFja2V0O1wiOjB4MjdlOSxcbiAgXCJSaWdodEFycm93O1wiOjB4MjE5MiwgXCJSaWdodEFycm93QmFyO1wiOjB4MjFlNSxcbiAgXCJSaWdodEFycm93TGVmdEFycm93O1wiOjB4MjFjNCwgXCJSaWdodENlaWxpbmc7XCI6MHgyMzA5LFxuICBcIlJpZ2h0RG91YmxlQnJhY2tldDtcIjoweDI3ZTcsIFwiUmlnaHREb3duVGVlVmVjdG9yO1wiOjB4Mjk1ZCxcbiAgXCJSaWdodERvd25WZWN0b3I7XCI6MHgyMWMyLCBcIlJpZ2h0RG93blZlY3RvckJhcjtcIjoweDI5NTUsXG4gIFwiUmlnaHRGbG9vcjtcIjoweDIzMGIsIFwiUmlnaHRUZWU7XCI6MHgyMmEyLFxuICBcIlJpZ2h0VGVlQXJyb3c7XCI6MHgyMWE2LCBcIlJpZ2h0VGVlVmVjdG9yO1wiOjB4Mjk1YixcbiAgXCJSaWdodFRyaWFuZ2xlO1wiOjB4MjJiMywgXCJSaWdodFRyaWFuZ2xlQmFyO1wiOjB4MjlkMCxcbiAgXCJSaWdodFRyaWFuZ2xlRXF1YWw7XCI6MHgyMmI1LCBcIlJpZ2h0VXBEb3duVmVjdG9yO1wiOjB4Mjk0ZixcbiAgXCJSaWdodFVwVGVlVmVjdG9yO1wiOjB4Mjk1YywgXCJSaWdodFVwVmVjdG9yO1wiOjB4MjFiZSxcbiAgXCJSaWdodFVwVmVjdG9yQmFyO1wiOjB4Mjk1NCwgXCJSaWdodFZlY3RvcjtcIjoweDIxYzAsXG4gIFwiUmlnaHRWZWN0b3JCYXI7XCI6MHgyOTUzLCBcIlJpZ2h0YXJyb3c7XCI6MHgyMWQyLFxuICBcIlJvcGY7XCI6MHgyMTFkLCBcIlJvdW5kSW1wbGllcztcIjoweDI5NzAsXG4gIFwiUnJpZ2h0YXJyb3c7XCI6MHgyMWRiLCBcIlJzY3I7XCI6MHgyMTFiLFxuICBcIlJzaDtcIjoweDIxYjEsIFwiUnVsZURlbGF5ZWQ7XCI6MHgyOWY0LFxuICBcIlNIQ0hjeTtcIjoweDQyOSwgXCJTSGN5O1wiOjB4NDI4LFxuICBcIlNPRlRjeTtcIjoweDQyYywgXCJTYWN1dGU7XCI6MHgxNWEsXG4gIFwiU2M7XCI6MHgyYWJjLCBcIlNjYXJvbjtcIjoweDE2MCxcbiAgXCJTY2VkaWw7XCI6MHgxNWUsIFwiU2NpcmM7XCI6MHgxNWMsXG4gIFwiU2N5O1wiOjB4NDIxLCBcIlNmcjtcIjpbMHhkODM1LDB4ZGQxNl0sXG4gIFwiU2hvcnREb3duQXJyb3c7XCI6MHgyMTkzLCBcIlNob3J0TGVmdEFycm93O1wiOjB4MjE5MCxcbiAgXCJTaG9ydFJpZ2h0QXJyb3c7XCI6MHgyMTkyLCBcIlNob3J0VXBBcnJvdztcIjoweDIxOTEsXG4gIFwiU2lnbWE7XCI6MHgzYTMsIFwiU21hbGxDaXJjbGU7XCI6MHgyMjE4LFxuICBcIlNvcGY7XCI6WzB4ZDgzNSwweGRkNGFdLCBcIlNxcnQ7XCI6MHgyMjFhLFxuICBcIlNxdWFyZTtcIjoweDI1YTEsIFwiU3F1YXJlSW50ZXJzZWN0aW9uO1wiOjB4MjI5MyxcbiAgXCJTcXVhcmVTdWJzZXQ7XCI6MHgyMjhmLCBcIlNxdWFyZVN1YnNldEVxdWFsO1wiOjB4MjI5MSxcbiAgXCJTcXVhcmVTdXBlcnNldDtcIjoweDIyOTAsIFwiU3F1YXJlU3VwZXJzZXRFcXVhbDtcIjoweDIyOTIsXG4gIFwiU3F1YXJlVW5pb247XCI6MHgyMjk0LCBcIlNzY3I7XCI6WzB4ZDgzNSwweGRjYWVdLFxuICBcIlN0YXI7XCI6MHgyMmM2LCBcIlN1YjtcIjoweDIyZDAsXG4gIFwiU3Vic2V0O1wiOjB4MjJkMCwgXCJTdWJzZXRFcXVhbDtcIjoweDIyODYsXG4gIFwiU3VjY2VlZHM7XCI6MHgyMjdiLCBcIlN1Y2NlZWRzRXF1YWw7XCI6MHgyYWIwLFxuICBcIlN1Y2NlZWRzU2xhbnRFcXVhbDtcIjoweDIyN2QsIFwiU3VjY2VlZHNUaWxkZTtcIjoweDIyN2YsXG4gIFwiU3VjaFRoYXQ7XCI6MHgyMjBiLCBcIlN1bTtcIjoweDIyMTEsXG4gIFwiU3VwO1wiOjB4MjJkMSwgXCJTdXBlcnNldDtcIjoweDIyODMsXG4gIFwiU3VwZXJzZXRFcXVhbDtcIjoweDIyODcsIFwiU3Vwc2V0O1wiOjB4MjJkMSxcbiAgXCJUSE9STlwiOjB4ZGUsIFwiVEhPUk47XCI6MHhkZSxcbiAgXCJUUkFERTtcIjoweDIxMjIsIFwiVFNIY3k7XCI6MHg0MGIsXG4gIFwiVFNjeTtcIjoweDQyNiwgXCJUYWI7XCI6MHg5LFxuICBcIlRhdTtcIjoweDNhNCwgXCJUY2Fyb247XCI6MHgxNjQsXG4gIFwiVGNlZGlsO1wiOjB4MTYyLCBcIlRjeTtcIjoweDQyMixcbiAgXCJUZnI7XCI6WzB4ZDgzNSwweGRkMTddLCBcIlRoZXJlZm9yZTtcIjoweDIyMzQsXG4gIFwiVGhldGE7XCI6MHgzOTgsIFwiVGhpY2tTcGFjZTtcIjpbMHgyMDVmLDB4MjAwYV0sXG4gIFwiVGhpblNwYWNlO1wiOjB4MjAwOSwgXCJUaWxkZTtcIjoweDIyM2MsXG4gIFwiVGlsZGVFcXVhbDtcIjoweDIyNDMsIFwiVGlsZGVGdWxsRXF1YWw7XCI6MHgyMjQ1LFxuICBcIlRpbGRlVGlsZGU7XCI6MHgyMjQ4LCBcIlRvcGY7XCI6WzB4ZDgzNSwweGRkNGJdLFxuICBcIlRyaXBsZURvdDtcIjoweDIwZGIsIFwiVHNjcjtcIjpbMHhkODM1LDB4ZGNhZl0sXG4gIFwiVHN0cm9rO1wiOjB4MTY2LCBcIlVhY3V0ZVwiOjB4ZGEsXG4gIFwiVWFjdXRlO1wiOjB4ZGEsIFwiVWFycjtcIjoweDIxOWYsXG4gIFwiVWFycm9jaXI7XCI6MHgyOTQ5LCBcIlVicmN5O1wiOjB4NDBlLFxuICBcIlVicmV2ZTtcIjoweDE2YywgXCJVY2lyY1wiOjB4ZGIsXG4gIFwiVWNpcmM7XCI6MHhkYiwgXCJVY3k7XCI6MHg0MjMsXG4gIFwiVWRibGFjO1wiOjB4MTcwLCBcIlVmcjtcIjpbMHhkODM1LDB4ZGQxOF0sXG4gIFwiVWdyYXZlXCI6MHhkOSwgXCJVZ3JhdmU7XCI6MHhkOSxcbiAgXCJVbWFjcjtcIjoweDE2YSwgXCJVbmRlckJhcjtcIjoweDVmLFxuICBcIlVuZGVyQnJhY2U7XCI6MHgyM2RmLCBcIlVuZGVyQnJhY2tldDtcIjoweDIzYjUsXG4gIFwiVW5kZXJQYXJlbnRoZXNpcztcIjoweDIzZGQsIFwiVW5pb247XCI6MHgyMmMzLFxuICBcIlVuaW9uUGx1cztcIjoweDIyOGUsIFwiVW9nb247XCI6MHgxNzIsXG4gIFwiVW9wZjtcIjpbMHhkODM1LDB4ZGQ0Y10sIFwiVXBBcnJvdztcIjoweDIxOTEsXG4gIFwiVXBBcnJvd0JhcjtcIjoweDI5MTIsIFwiVXBBcnJvd0Rvd25BcnJvdztcIjoweDIxYzUsXG4gIFwiVXBEb3duQXJyb3c7XCI6MHgyMTk1LCBcIlVwRXF1aWxpYnJpdW07XCI6MHgyOTZlLFxuICBcIlVwVGVlO1wiOjB4MjJhNSwgXCJVcFRlZUFycm93O1wiOjB4MjFhNSxcbiAgXCJVcGFycm93O1wiOjB4MjFkMSwgXCJVcGRvd25hcnJvdztcIjoweDIxZDUsXG4gIFwiVXBwZXJMZWZ0QXJyb3c7XCI6MHgyMTk2LCBcIlVwcGVyUmlnaHRBcnJvdztcIjoweDIxOTcsXG4gIFwiVXBzaTtcIjoweDNkMiwgXCJVcHNpbG9uO1wiOjB4M2E1LFxuICBcIlVyaW5nO1wiOjB4MTZlLCBcIlVzY3I7XCI6WzB4ZDgzNSwweGRjYjBdLFxuICBcIlV0aWxkZTtcIjoweDE2OCwgXCJVdW1sXCI6MHhkYyxcbiAgXCJVdW1sO1wiOjB4ZGMsIFwiVkRhc2g7XCI6MHgyMmFiLFxuICBcIlZiYXI7XCI6MHgyYWViLCBcIlZjeTtcIjoweDQxMixcbiAgXCJWZGFzaDtcIjoweDIyYTksIFwiVmRhc2hsO1wiOjB4MmFlNixcbiAgXCJWZWU7XCI6MHgyMmMxLCBcIlZlcmJhcjtcIjoweDIwMTYsXG4gIFwiVmVydDtcIjoweDIwMTYsIFwiVmVydGljYWxCYXI7XCI6MHgyMjIzLFxuICBcIlZlcnRpY2FsTGluZTtcIjoweDdjLCBcIlZlcnRpY2FsU2VwYXJhdG9yO1wiOjB4Mjc1OCxcbiAgXCJWZXJ0aWNhbFRpbGRlO1wiOjB4MjI0MCwgXCJWZXJ5VGhpblNwYWNlO1wiOjB4MjAwYSxcbiAgXCJWZnI7XCI6WzB4ZDgzNSwweGRkMTldLCBcIlZvcGY7XCI6WzB4ZDgzNSwweGRkNGRdLFxuICBcIlZzY3I7XCI6WzB4ZDgzNSwweGRjYjFdLCBcIlZ2ZGFzaDtcIjoweDIyYWEsXG4gIFwiV2NpcmM7XCI6MHgxNzQsIFwiV2VkZ2U7XCI6MHgyMmMwLFxuICBcIldmcjtcIjpbMHhkODM1LDB4ZGQxYV0sIFwiV29wZjtcIjpbMHhkODM1LDB4ZGQ0ZV0sXG4gIFwiV3NjcjtcIjpbMHhkODM1LDB4ZGNiMl0sIFwiWGZyO1wiOlsweGQ4MzUsMHhkZDFiXSxcbiAgXCJYaTtcIjoweDM5ZSwgXCJYb3BmO1wiOlsweGQ4MzUsMHhkZDRmXSxcbiAgXCJYc2NyO1wiOlsweGQ4MzUsMHhkY2IzXSwgXCJZQWN5O1wiOjB4NDJmLFxuICBcIllJY3k7XCI6MHg0MDcsIFwiWVVjeTtcIjoweDQyZSxcbiAgXCJZYWN1dGVcIjoweGRkLCBcIllhY3V0ZTtcIjoweGRkLFxuICBcIlljaXJjO1wiOjB4MTc2LCBcIlljeTtcIjoweDQyYixcbiAgXCJZZnI7XCI6WzB4ZDgzNSwweGRkMWNdLCBcIllvcGY7XCI6WzB4ZDgzNSwweGRkNTBdLFxuICBcIllzY3I7XCI6WzB4ZDgzNSwweGRjYjRdLCBcIll1bWw7XCI6MHgxNzgsXG4gIFwiWkhjeTtcIjoweDQxNiwgXCJaYWN1dGU7XCI6MHgxNzksXG4gIFwiWmNhcm9uO1wiOjB4MTdkLCBcIlpjeTtcIjoweDQxNyxcbiAgXCJaZG90O1wiOjB4MTdiLCBcIlplcm9XaWR0aFNwYWNlO1wiOjB4MjAwYixcbiAgXCJaZXRhO1wiOjB4Mzk2LCBcIlpmcjtcIjoweDIxMjgsXG4gIFwiWm9wZjtcIjoweDIxMjQsIFwiWnNjcjtcIjpbMHhkODM1LDB4ZGNiNV0sXG4gIFwiYWFjdXRlXCI6MHhlMSwgXCJhYWN1dGU7XCI6MHhlMSxcbiAgXCJhYnJldmU7XCI6MHgxMDMsIFwiYWM7XCI6MHgyMjNlLFxuICBcImFjRTtcIjpbMHgyMjNlLDB4MzMzXSwgXCJhY2Q7XCI6MHgyMjNmLFxuICBcImFjaXJjXCI6MHhlMiwgXCJhY2lyYztcIjoweGUyLFxuICBcImFjdXRlXCI6MHhiNCwgXCJhY3V0ZTtcIjoweGI0LFxuICBcImFjeTtcIjoweDQzMCwgXCJhZWxpZ1wiOjB4ZTYsXG4gIFwiYWVsaWc7XCI6MHhlNiwgXCJhZjtcIjoweDIwNjEsXG4gIFwiYWZyO1wiOlsweGQ4MzUsMHhkZDFlXSwgXCJhZ3JhdmVcIjoweGUwLFxuICBcImFncmF2ZTtcIjoweGUwLCBcImFsZWZzeW07XCI6MHgyMTM1LFxuICBcImFsZXBoO1wiOjB4MjEzNSwgXCJhbHBoYTtcIjoweDNiMSxcbiAgXCJhbWFjcjtcIjoweDEwMSwgXCJhbWFsZztcIjoweDJhM2YsXG4gIFwiYW1wXCI6MHgyNiwgXCJhbXA7XCI6MHgyNixcbiAgXCJhbmQ7XCI6MHgyMjI3LCBcImFuZGFuZDtcIjoweDJhNTUsXG4gIFwiYW5kZDtcIjoweDJhNWMsIFwiYW5kc2xvcGU7XCI6MHgyYTU4LFxuICBcImFuZHY7XCI6MHgyYTVhLCBcImFuZztcIjoweDIyMjAsXG4gIFwiYW5nZTtcIjoweDI5YTQsIFwiYW5nbGU7XCI6MHgyMjIwLFxuICBcImFuZ21zZDtcIjoweDIyMjEsIFwiYW5nbXNkYWE7XCI6MHgyOWE4LFxuICBcImFuZ21zZGFiO1wiOjB4MjlhOSwgXCJhbmdtc2RhYztcIjoweDI5YWEsXG4gIFwiYW5nbXNkYWQ7XCI6MHgyOWFiLCBcImFuZ21zZGFlO1wiOjB4MjlhYyxcbiAgXCJhbmdtc2RhZjtcIjoweDI5YWQsIFwiYW5nbXNkYWc7XCI6MHgyOWFlLFxuICBcImFuZ21zZGFoO1wiOjB4MjlhZiwgXCJhbmdydDtcIjoweDIyMWYsXG4gIFwiYW5ncnR2YjtcIjoweDIyYmUsIFwiYW5ncnR2YmQ7XCI6MHgyOTlkLFxuICBcImFuZ3NwaDtcIjoweDIyMjIsIFwiYW5nc3Q7XCI6MHhjNSxcbiAgXCJhbmd6YXJyO1wiOjB4MjM3YywgXCJhb2dvbjtcIjoweDEwNSxcbiAgXCJhb3BmO1wiOlsweGQ4MzUsMHhkZDUyXSwgXCJhcDtcIjoweDIyNDgsXG4gIFwiYXBFO1wiOjB4MmE3MCwgXCJhcGFjaXI7XCI6MHgyYTZmLFxuICBcImFwZTtcIjoweDIyNGEsIFwiYXBpZDtcIjoweDIyNGIsXG4gIFwiYXBvcztcIjoweDI3LCBcImFwcHJveDtcIjoweDIyNDgsXG4gIFwiYXBwcm94ZXE7XCI6MHgyMjRhLCBcImFyaW5nXCI6MHhlNSxcbiAgXCJhcmluZztcIjoweGU1LCBcImFzY3I7XCI6WzB4ZDgzNSwweGRjYjZdLFxuICBcImFzdDtcIjoweDJhLCBcImFzeW1wO1wiOjB4MjI0OCxcbiAgXCJhc3ltcGVxO1wiOjB4MjI0ZCwgXCJhdGlsZGVcIjoweGUzLFxuICBcImF0aWxkZTtcIjoweGUzLCBcImF1bWxcIjoweGU0LFxuICBcImF1bWw7XCI6MHhlNCwgXCJhd2NvbmludDtcIjoweDIyMzMsXG4gIFwiYXdpbnQ7XCI6MHgyYTExLCBcImJOb3Q7XCI6MHgyYWVkLFxuICBcImJhY2tjb25nO1wiOjB4MjI0YywgXCJiYWNrZXBzaWxvbjtcIjoweDNmNixcbiAgXCJiYWNrcHJpbWU7XCI6MHgyMDM1LCBcImJhY2tzaW07XCI6MHgyMjNkLFxuICBcImJhY2tzaW1lcTtcIjoweDIyY2QsIFwiYmFydmVlO1wiOjB4MjJiZCxcbiAgXCJiYXJ3ZWQ7XCI6MHgyMzA1LCBcImJhcndlZGdlO1wiOjB4MjMwNSxcbiAgXCJiYnJrO1wiOjB4MjNiNSwgXCJiYnJrdGJyaztcIjoweDIzYjYsXG4gIFwiYmNvbmc7XCI6MHgyMjRjLCBcImJjeTtcIjoweDQzMSxcbiAgXCJiZHF1bztcIjoweDIwMWUsIFwiYmVjYXVzO1wiOjB4MjIzNSxcbiAgXCJiZWNhdXNlO1wiOjB4MjIzNSwgXCJiZW1wdHl2O1wiOjB4MjliMCxcbiAgXCJiZXBzaTtcIjoweDNmNiwgXCJiZXJub3U7XCI6MHgyMTJjLFxuICBcImJldGE7XCI6MHgzYjIsIFwiYmV0aDtcIjoweDIxMzYsXG4gIFwiYmV0d2VlbjtcIjoweDIyNmMsIFwiYmZyO1wiOlsweGQ4MzUsMHhkZDFmXSxcbiAgXCJiaWdjYXA7XCI6MHgyMmMyLCBcImJpZ2NpcmM7XCI6MHgyNWVmLFxuICBcImJpZ2N1cDtcIjoweDIyYzMsIFwiYmlnb2RvdDtcIjoweDJhMDAsXG4gIFwiYmlnb3BsdXM7XCI6MHgyYTAxLCBcImJpZ290aW1lcztcIjoweDJhMDIsXG4gIFwiYmlnc3FjdXA7XCI6MHgyYTA2LCBcImJpZ3N0YXI7XCI6MHgyNjA1LFxuICBcImJpZ3RyaWFuZ2xlZG93bjtcIjoweDI1YmQsIFwiYmlndHJpYW5nbGV1cDtcIjoweDI1YjMsXG4gIFwiYmlndXBsdXM7XCI6MHgyYTA0LCBcImJpZ3ZlZTtcIjoweDIyYzEsXG4gIFwiYmlnd2VkZ2U7XCI6MHgyMmMwLCBcImJrYXJvdztcIjoweDI5MGQsXG4gIFwiYmxhY2tsb3plbmdlO1wiOjB4MjllYiwgXCJibGFja3NxdWFyZTtcIjoweDI1YWEsXG4gIFwiYmxhY2t0cmlhbmdsZTtcIjoweDI1YjQsIFwiYmxhY2t0cmlhbmdsZWRvd247XCI6MHgyNWJlLFxuICBcImJsYWNrdHJpYW5nbGVsZWZ0O1wiOjB4MjVjMiwgXCJibGFja3RyaWFuZ2xlcmlnaHQ7XCI6MHgyNWI4LFxuICBcImJsYW5rO1wiOjB4MjQyMywgXCJibGsxMjtcIjoweDI1OTIsXG4gIFwiYmxrMTQ7XCI6MHgyNTkxLCBcImJsazM0O1wiOjB4MjU5MyxcbiAgXCJibG9jaztcIjoweDI1ODgsIFwiYm5lO1wiOlsweDNkLDB4MjBlNV0sXG4gIFwiYm5lcXVpdjtcIjpbMHgyMjYxLDB4MjBlNV0sIFwiYm5vdDtcIjoweDIzMTAsXG4gIFwiYm9wZjtcIjpbMHhkODM1LDB4ZGQ1M10sIFwiYm90O1wiOjB4MjJhNSxcbiAgXCJib3R0b207XCI6MHgyMmE1LCBcImJvd3RpZTtcIjoweDIyYzgsXG4gIFwiYm94REw7XCI6MHgyNTU3LCBcImJveERSO1wiOjB4MjU1NCxcbiAgXCJib3hEbDtcIjoweDI1NTYsIFwiYm94RHI7XCI6MHgyNTUzLFxuICBcImJveEg7XCI6MHgyNTUwLCBcImJveEhEO1wiOjB4MjU2NixcbiAgXCJib3hIVTtcIjoweDI1NjksIFwiYm94SGQ7XCI6MHgyNTY0LFxuICBcImJveEh1O1wiOjB4MjU2NywgXCJib3hVTDtcIjoweDI1NWQsXG4gIFwiYm94VVI7XCI6MHgyNTVhLCBcImJveFVsO1wiOjB4MjU1YyxcbiAgXCJib3hVcjtcIjoweDI1NTksIFwiYm94VjtcIjoweDI1NTEsXG4gIFwiYm94Vkg7XCI6MHgyNTZjLCBcImJveFZMO1wiOjB4MjU2MyxcbiAgXCJib3hWUjtcIjoweDI1NjAsIFwiYm94Vmg7XCI6MHgyNTZiLFxuICBcImJveFZsO1wiOjB4MjU2MiwgXCJib3hWcjtcIjoweDI1NWYsXG4gIFwiYm94Ym94O1wiOjB4MjljOSwgXCJib3hkTDtcIjoweDI1NTUsXG4gIFwiYm94ZFI7XCI6MHgyNTUyLCBcImJveGRsO1wiOjB4MjUxMCxcbiAgXCJib3hkcjtcIjoweDI1MGMsIFwiYm94aDtcIjoweDI1MDAsXG4gIFwiYm94aEQ7XCI6MHgyNTY1LCBcImJveGhVO1wiOjB4MjU2OCxcbiAgXCJib3hoZDtcIjoweDI1MmMsIFwiYm94aHU7XCI6MHgyNTM0LFxuICBcImJveG1pbnVzO1wiOjB4MjI5ZiwgXCJib3hwbHVzO1wiOjB4MjI5ZSxcbiAgXCJib3h0aW1lcztcIjoweDIyYTAsIFwiYm94dUw7XCI6MHgyNTViLFxuICBcImJveHVSO1wiOjB4MjU1OCwgXCJib3h1bDtcIjoweDI1MTgsXG4gIFwiYm94dXI7XCI6MHgyNTE0LCBcImJveHY7XCI6MHgyNTAyLFxuICBcImJveHZIO1wiOjB4MjU2YSwgXCJib3h2TDtcIjoweDI1NjEsXG4gIFwiYm94dlI7XCI6MHgyNTVlLCBcImJveHZoO1wiOjB4MjUzYyxcbiAgXCJib3h2bDtcIjoweDI1MjQsIFwiYm94dnI7XCI6MHgyNTFjLFxuICBcImJwcmltZTtcIjoweDIwMzUsIFwiYnJldmU7XCI6MHgyZDgsXG4gIFwiYnJ2YmFyXCI6MHhhNiwgXCJicnZiYXI7XCI6MHhhNixcbiAgXCJic2NyO1wiOlsweGQ4MzUsMHhkY2I3XSwgXCJic2VtaTtcIjoweDIwNGYsXG4gIFwiYnNpbTtcIjoweDIyM2QsIFwiYnNpbWU7XCI6MHgyMmNkLFxuICBcImJzb2w7XCI6MHg1YywgXCJic29sYjtcIjoweDI5YzUsXG4gIFwiYnNvbGhzdWI7XCI6MHgyN2M4LCBcImJ1bGw7XCI6MHgyMDIyLFxuICBcImJ1bGxldDtcIjoweDIwMjIsIFwiYnVtcDtcIjoweDIyNGUsXG4gIFwiYnVtcEU7XCI6MHgyYWFlLCBcImJ1bXBlO1wiOjB4MjI0ZixcbiAgXCJidW1wZXE7XCI6MHgyMjRmLCBcImNhY3V0ZTtcIjoweDEwNyxcbiAgXCJjYXA7XCI6MHgyMjI5LCBcImNhcGFuZDtcIjoweDJhNDQsXG4gIFwiY2FwYnJjdXA7XCI6MHgyYTQ5LCBcImNhcGNhcDtcIjoweDJhNGIsXG4gIFwiY2FwY3VwO1wiOjB4MmE0NywgXCJjYXBkb3Q7XCI6MHgyYTQwLFxuICBcImNhcHM7XCI6WzB4MjIyOSwweGZlMDBdLCBcImNhcmV0O1wiOjB4MjA0MSxcbiAgXCJjYXJvbjtcIjoweDJjNywgXCJjY2FwcztcIjoweDJhNGQsXG4gIFwiY2Nhcm9uO1wiOjB4MTBkLCBcImNjZWRpbFwiOjB4ZTcsXG4gIFwiY2NlZGlsO1wiOjB4ZTcsIFwiY2NpcmM7XCI6MHgxMDksXG4gIFwiY2N1cHM7XCI6MHgyYTRjLCBcImNjdXBzc207XCI6MHgyYTUwLFxuICBcImNkb3Q7XCI6MHgxMGIsIFwiY2VkaWxcIjoweGI4LFxuICBcImNlZGlsO1wiOjB4YjgsIFwiY2VtcHR5djtcIjoweDI5YjIsXG4gIFwiY2VudFwiOjB4YTIsIFwiY2VudDtcIjoweGEyLFxuICBcImNlbnRlcmRvdDtcIjoweGI3LCBcImNmcjtcIjpbMHhkODM1LDB4ZGQyMF0sXG4gIFwiY2hjeTtcIjoweDQ0NywgXCJjaGVjaztcIjoweDI3MTMsXG4gIFwiY2hlY2ttYXJrO1wiOjB4MjcxMywgXCJjaGk7XCI6MHgzYzcsXG4gIFwiY2lyO1wiOjB4MjVjYiwgXCJjaXJFO1wiOjB4MjljMyxcbiAgXCJjaXJjO1wiOjB4MmM2LCBcImNpcmNlcTtcIjoweDIyNTcsXG4gIFwiY2lyY2xlYXJyb3dsZWZ0O1wiOjB4MjFiYSwgXCJjaXJjbGVhcnJvd3JpZ2h0O1wiOjB4MjFiYixcbiAgXCJjaXJjbGVkUjtcIjoweGFlLCBcImNpcmNsZWRTO1wiOjB4MjRjOCxcbiAgXCJjaXJjbGVkYXN0O1wiOjB4MjI5YiwgXCJjaXJjbGVkY2lyYztcIjoweDIyOWEsXG4gIFwiY2lyY2xlZGRhc2g7XCI6MHgyMjlkLCBcImNpcmU7XCI6MHgyMjU3LFxuICBcImNpcmZuaW50O1wiOjB4MmExMCwgXCJjaXJtaWQ7XCI6MHgyYWVmLFxuICBcImNpcnNjaXI7XCI6MHgyOWMyLCBcImNsdWJzO1wiOjB4MjY2MyxcbiAgXCJjbHVic3VpdDtcIjoweDI2NjMsIFwiY29sb247XCI6MHgzYSxcbiAgXCJjb2xvbmU7XCI6MHgyMjU0LCBcImNvbG9uZXE7XCI6MHgyMjU0LFxuICBcImNvbW1hO1wiOjB4MmMsIFwiY29tbWF0O1wiOjB4NDAsXG4gIFwiY29tcDtcIjoweDIyMDEsIFwiY29tcGZuO1wiOjB4MjIxOCxcbiAgXCJjb21wbGVtZW50O1wiOjB4MjIwMSwgXCJjb21wbGV4ZXM7XCI6MHgyMTAyLFxuICBcImNvbmc7XCI6MHgyMjQ1LCBcImNvbmdkb3Q7XCI6MHgyYTZkLFxuICBcImNvbmludDtcIjoweDIyMmUsIFwiY29wZjtcIjpbMHhkODM1LDB4ZGQ1NF0sXG4gIFwiY29wcm9kO1wiOjB4MjIxMCwgXCJjb3B5XCI6MHhhOSxcbiAgXCJjb3B5O1wiOjB4YTksIFwiY29weXNyO1wiOjB4MjExNyxcbiAgXCJjcmFycjtcIjoweDIxYjUsIFwiY3Jvc3M7XCI6MHgyNzE3LFxuICBcImNzY3I7XCI6WzB4ZDgzNSwweGRjYjhdLCBcImNzdWI7XCI6MHgyYWNmLFxuICBcImNzdWJlO1wiOjB4MmFkMSwgXCJjc3VwO1wiOjB4MmFkMCxcbiAgXCJjc3VwZTtcIjoweDJhZDIsIFwiY3Rkb3Q7XCI6MHgyMmVmLFxuICBcImN1ZGFycmw7XCI6MHgyOTM4LCBcImN1ZGFycnI7XCI6MHgyOTM1LFxuICBcImN1ZXByO1wiOjB4MjJkZSwgXCJjdWVzYztcIjoweDIyZGYsXG4gIFwiY3VsYXJyO1wiOjB4MjFiNiwgXCJjdWxhcnJwO1wiOjB4MjkzZCxcbiAgXCJjdXA7XCI6MHgyMjJhLCBcImN1cGJyY2FwO1wiOjB4MmE0OCxcbiAgXCJjdXBjYXA7XCI6MHgyYTQ2LCBcImN1cGN1cDtcIjoweDJhNGEsXG4gIFwiY3VwZG90O1wiOjB4MjI4ZCwgXCJjdXBvcjtcIjoweDJhNDUsXG4gIFwiY3VwcztcIjpbMHgyMjJhLDB4ZmUwMF0sIFwiY3VyYXJyO1wiOjB4MjFiNyxcbiAgXCJjdXJhcnJtO1wiOjB4MjkzYywgXCJjdXJseWVxcHJlYztcIjoweDIyZGUsXG4gIFwiY3VybHllcXN1Y2M7XCI6MHgyMmRmLCBcImN1cmx5dmVlO1wiOjB4MjJjZSxcbiAgXCJjdXJseXdlZGdlO1wiOjB4MjJjZiwgXCJjdXJyZW5cIjoweGE0LFxuICBcImN1cnJlbjtcIjoweGE0LCBcImN1cnZlYXJyb3dsZWZ0O1wiOjB4MjFiNixcbiAgXCJjdXJ2ZWFycm93cmlnaHQ7XCI6MHgyMWI3LCBcImN1dmVlO1wiOjB4MjJjZSxcbiAgXCJjdXdlZDtcIjoweDIyY2YsIFwiY3djb25pbnQ7XCI6MHgyMjMyLFxuICBcImN3aW50O1wiOjB4MjIzMSwgXCJjeWxjdHk7XCI6MHgyMzJkLFxuICBcImRBcnI7XCI6MHgyMWQzLCBcImRIYXI7XCI6MHgyOTY1LFxuICBcImRhZ2dlcjtcIjoweDIwMjAsIFwiZGFsZXRoO1wiOjB4MjEzOCxcbiAgXCJkYXJyO1wiOjB4MjE5MywgXCJkYXNoO1wiOjB4MjAxMCxcbiAgXCJkYXNodjtcIjoweDIyYTMsIFwiZGJrYXJvdztcIjoweDI5MGYsXG4gIFwiZGJsYWM7XCI6MHgyZGQsIFwiZGNhcm9uO1wiOjB4MTBmLFxuICBcImRjeTtcIjoweDQzNCwgXCJkZDtcIjoweDIxNDYsXG4gIFwiZGRhZ2dlcjtcIjoweDIwMjEsIFwiZGRhcnI7XCI6MHgyMWNhLFxuICBcImRkb3RzZXE7XCI6MHgyYTc3LCBcImRlZ1wiOjB4YjAsXG4gIFwiZGVnO1wiOjB4YjAsIFwiZGVsdGE7XCI6MHgzYjQsXG4gIFwiZGVtcHR5djtcIjoweDI5YjEsIFwiZGZpc2h0O1wiOjB4Mjk3ZixcbiAgXCJkZnI7XCI6WzB4ZDgzNSwweGRkMjFdLCBcImRoYXJsO1wiOjB4MjFjMyxcbiAgXCJkaGFycjtcIjoweDIxYzIsIFwiZGlhbTtcIjoweDIyYzQsXG4gIFwiZGlhbW9uZDtcIjoweDIyYzQsIFwiZGlhbW9uZHN1aXQ7XCI6MHgyNjY2LFxuICBcImRpYW1zO1wiOjB4MjY2NiwgXCJkaWU7XCI6MHhhOCxcbiAgXCJkaWdhbW1hO1wiOjB4M2RkLCBcImRpc2luO1wiOjB4MjJmMixcbiAgXCJkaXY7XCI6MHhmNywgXCJkaXZpZGVcIjoweGY3LFxuICBcImRpdmlkZTtcIjoweGY3LCBcImRpdmlkZW9udGltZXM7XCI6MHgyMmM3LFxuICBcImRpdm9ueDtcIjoweDIyYzcsIFwiZGpjeTtcIjoweDQ1MixcbiAgXCJkbGNvcm47XCI6MHgyMzFlLCBcImRsY3JvcDtcIjoweDIzMGQsXG4gIFwiZG9sbGFyO1wiOjB4MjQsIFwiZG9wZjtcIjpbMHhkODM1LDB4ZGQ1NV0sXG4gIFwiZG90O1wiOjB4MmQ5LCBcImRvdGVxO1wiOjB4MjI1MCxcbiAgXCJkb3RlcWRvdDtcIjoweDIyNTEsIFwiZG90bWludXM7XCI6MHgyMjM4LFxuICBcImRvdHBsdXM7XCI6MHgyMjE0LCBcImRvdHNxdWFyZTtcIjoweDIyYTEsXG4gIFwiZG91YmxlYmFyd2VkZ2U7XCI6MHgyMzA2LCBcImRvd25hcnJvdztcIjoweDIxOTMsXG4gIFwiZG93bmRvd25hcnJvd3M7XCI6MHgyMWNhLCBcImRvd25oYXJwb29ubGVmdDtcIjoweDIxYzMsXG4gIFwiZG93bmhhcnBvb25yaWdodDtcIjoweDIxYzIsIFwiZHJia2Fyb3c7XCI6MHgyOTEwLFxuICBcImRyY29ybjtcIjoweDIzMWYsIFwiZHJjcm9wO1wiOjB4MjMwYyxcbiAgXCJkc2NyO1wiOlsweGQ4MzUsMHhkY2I5XSwgXCJkc2N5O1wiOjB4NDU1LFxuICBcImRzb2w7XCI6MHgyOWY2LCBcImRzdHJvaztcIjoweDExMSxcbiAgXCJkdGRvdDtcIjoweDIyZjEsIFwiZHRyaTtcIjoweDI1YmYsXG4gIFwiZHRyaWY7XCI6MHgyNWJlLCBcImR1YXJyO1wiOjB4MjFmNSxcbiAgXCJkdWhhcjtcIjoweDI5NmYsIFwiZHdhbmdsZTtcIjoweDI5YTYsXG4gIFwiZHpjeTtcIjoweDQ1ZiwgXCJkemlncmFycjtcIjoweDI3ZmYsXG4gIFwiZUREb3Q7XCI6MHgyYTc3LCBcImVEb3Q7XCI6MHgyMjUxLFxuICBcImVhY3V0ZVwiOjB4ZTksIFwiZWFjdXRlO1wiOjB4ZTksXG4gIFwiZWFzdGVyO1wiOjB4MmE2ZSwgXCJlY2Fyb247XCI6MHgxMWIsXG4gIFwiZWNpcjtcIjoweDIyNTYsIFwiZWNpcmNcIjoweGVhLFxuICBcImVjaXJjO1wiOjB4ZWEsIFwiZWNvbG9uO1wiOjB4MjI1NSxcbiAgXCJlY3k7XCI6MHg0NGQsIFwiZWRvdDtcIjoweDExNyxcbiAgXCJlZTtcIjoweDIxNDcsIFwiZWZEb3Q7XCI6MHgyMjUyLFxuICBcImVmcjtcIjpbMHhkODM1LDB4ZGQyMl0sIFwiZWc7XCI6MHgyYTlhLFxuICBcImVncmF2ZVwiOjB4ZTgsIFwiZWdyYXZlO1wiOjB4ZTgsXG4gIFwiZWdzO1wiOjB4MmE5NiwgXCJlZ3Nkb3Q7XCI6MHgyYTk4LFxuICBcImVsO1wiOjB4MmE5OSwgXCJlbGludGVycztcIjoweDIzZTcsXG4gIFwiZWxsO1wiOjB4MjExMywgXCJlbHM7XCI6MHgyYTk1LFxuICBcImVsc2RvdDtcIjoweDJhOTcsIFwiZW1hY3I7XCI6MHgxMTMsXG4gIFwiZW1wdHk7XCI6MHgyMjA1LCBcImVtcHR5c2V0O1wiOjB4MjIwNSxcbiAgXCJlbXB0eXY7XCI6MHgyMjA1LCBcImVtc3AxMztcIjoweDIwMDQsXG4gIFwiZW1zcDE0O1wiOjB4MjAwNSwgXCJlbXNwO1wiOjB4MjAwMyxcbiAgXCJlbmc7XCI6MHgxNGIsIFwiZW5zcDtcIjoweDIwMDIsXG4gIFwiZW9nb247XCI6MHgxMTksIFwiZW9wZjtcIjpbMHhkODM1LDB4ZGQ1Nl0sXG4gIFwiZXBhcjtcIjoweDIyZDUsIFwiZXBhcnNsO1wiOjB4MjllMyxcbiAgXCJlcGx1cztcIjoweDJhNzEsIFwiZXBzaTtcIjoweDNiNSxcbiAgXCJlcHNpbG9uO1wiOjB4M2I1LCBcImVwc2l2O1wiOjB4M2Y1LFxuICBcImVxY2lyYztcIjoweDIyNTYsIFwiZXFjb2xvbjtcIjoweDIyNTUsXG4gIFwiZXFzaW07XCI6MHgyMjQyLCBcImVxc2xhbnRndHI7XCI6MHgyYTk2LFxuICBcImVxc2xhbnRsZXNzO1wiOjB4MmE5NSwgXCJlcXVhbHM7XCI6MHgzZCxcbiAgXCJlcXVlc3Q7XCI6MHgyMjVmLCBcImVxdWl2O1wiOjB4MjI2MSxcbiAgXCJlcXVpdkREO1wiOjB4MmE3OCwgXCJlcXZwYXJzbDtcIjoweDI5ZTUsXG4gIFwiZXJEb3Q7XCI6MHgyMjUzLCBcImVyYXJyO1wiOjB4Mjk3MSxcbiAgXCJlc2NyO1wiOjB4MjEyZiwgXCJlc2RvdDtcIjoweDIyNTAsXG4gIFwiZXNpbTtcIjoweDIyNDIsIFwiZXRhO1wiOjB4M2I3LFxuICBcImV0aFwiOjB4ZjAsIFwiZXRoO1wiOjB4ZjAsXG4gIFwiZXVtbFwiOjB4ZWIsIFwiZXVtbDtcIjoweGViLFxuICBcImV1cm87XCI6MHgyMGFjLCBcImV4Y2w7XCI6MHgyMSxcbiAgXCJleGlzdDtcIjoweDIyMDMsIFwiZXhwZWN0YXRpb247XCI6MHgyMTMwLFxuICBcImV4cG9uZW50aWFsZTtcIjoweDIxNDcsIFwiZmFsbGluZ2RvdHNlcTtcIjoweDIyNTIsXG4gIFwiZmN5O1wiOjB4NDQ0LCBcImZlbWFsZTtcIjoweDI2NDAsXG4gIFwiZmZpbGlnO1wiOjB4ZmIwMywgXCJmZmxpZztcIjoweGZiMDAsXG4gIFwiZmZsbGlnO1wiOjB4ZmIwNCwgXCJmZnI7XCI6WzB4ZDgzNSwweGRkMjNdLFxuICBcImZpbGlnO1wiOjB4ZmIwMSwgXCJmamxpZztcIjpbMHg2NiwweDZhXSxcbiAgXCJmbGF0O1wiOjB4MjY2ZCwgXCJmbGxpZztcIjoweGZiMDIsXG4gIFwiZmx0bnM7XCI6MHgyNWIxLCBcImZub2Y7XCI6MHgxOTIsXG4gIFwiZm9wZjtcIjpbMHhkODM1LDB4ZGQ1N10sIFwiZm9yYWxsO1wiOjB4MjIwMCxcbiAgXCJmb3JrO1wiOjB4MjJkNCwgXCJmb3JrdjtcIjoweDJhZDksXG4gIFwiZnBhcnRpbnQ7XCI6MHgyYTBkLCBcImZyYWMxMlwiOjB4YmQsXG4gIFwiZnJhYzEyO1wiOjB4YmQsIFwiZnJhYzEzO1wiOjB4MjE1MyxcbiAgXCJmcmFjMTRcIjoweGJjLCBcImZyYWMxNDtcIjoweGJjLFxuICBcImZyYWMxNTtcIjoweDIxNTUsIFwiZnJhYzE2O1wiOjB4MjE1OSxcbiAgXCJmcmFjMTg7XCI6MHgyMTViLCBcImZyYWMyMztcIjoweDIxNTQsXG4gIFwiZnJhYzI1O1wiOjB4MjE1NiwgXCJmcmFjMzRcIjoweGJlLFxuICBcImZyYWMzNDtcIjoweGJlLCBcImZyYWMzNTtcIjoweDIxNTcsXG4gIFwiZnJhYzM4O1wiOjB4MjE1YywgXCJmcmFjNDU7XCI6MHgyMTU4LFxuICBcImZyYWM1NjtcIjoweDIxNWEsIFwiZnJhYzU4O1wiOjB4MjE1ZCxcbiAgXCJmcmFjNzg7XCI6MHgyMTVlLCBcImZyYXNsO1wiOjB4MjA0NCxcbiAgXCJmcm93bjtcIjoweDIzMjIsIFwiZnNjcjtcIjpbMHhkODM1LDB4ZGNiYl0sXG4gIFwiZ0U7XCI6MHgyMjY3LCBcImdFbDtcIjoweDJhOGMsXG4gIFwiZ2FjdXRlO1wiOjB4MWY1LCBcImdhbW1hO1wiOjB4M2IzLFxuICBcImdhbW1hZDtcIjoweDNkZCwgXCJnYXA7XCI6MHgyYTg2LFxuICBcImdicmV2ZTtcIjoweDExZiwgXCJnY2lyYztcIjoweDExZCxcbiAgXCJnY3k7XCI6MHg0MzMsIFwiZ2RvdDtcIjoweDEyMSxcbiAgXCJnZTtcIjoweDIyNjUsIFwiZ2VsO1wiOjB4MjJkYixcbiAgXCJnZXE7XCI6MHgyMjY1LCBcImdlcXE7XCI6MHgyMjY3LFxuICBcImdlcXNsYW50O1wiOjB4MmE3ZSwgXCJnZXM7XCI6MHgyYTdlLFxuICBcImdlc2NjO1wiOjB4MmFhOSwgXCJnZXNkb3Q7XCI6MHgyYTgwLFxuICBcImdlc2RvdG87XCI6MHgyYTgyLCBcImdlc2RvdG9sO1wiOjB4MmE4NCxcbiAgXCJnZXNsO1wiOlsweDIyZGIsMHhmZTAwXSwgXCJnZXNsZXM7XCI6MHgyYTk0LFxuICBcImdmcjtcIjpbMHhkODM1LDB4ZGQyNF0sIFwiZ2c7XCI6MHgyMjZiLFxuICBcImdnZztcIjoweDIyZDksIFwiZ2ltZWw7XCI6MHgyMTM3LFxuICBcImdqY3k7XCI6MHg0NTMsIFwiZ2w7XCI6MHgyMjc3LFxuICBcImdsRTtcIjoweDJhOTIsIFwiZ2xhO1wiOjB4MmFhNSxcbiAgXCJnbGo7XCI6MHgyYWE0LCBcImduRTtcIjoweDIyNjksXG4gIFwiZ25hcDtcIjoweDJhOGEsIFwiZ25hcHByb3g7XCI6MHgyYThhLFxuICBcImduZTtcIjoweDJhODgsIFwiZ25lcTtcIjoweDJhODgsXG4gIFwiZ25lcXE7XCI6MHgyMjY5LCBcImduc2ltO1wiOjB4MjJlNyxcbiAgXCJnb3BmO1wiOlsweGQ4MzUsMHhkZDU4XSwgXCJncmF2ZTtcIjoweDYwLFxuICBcImdzY3I7XCI6MHgyMTBhLCBcImdzaW07XCI6MHgyMjczLFxuICBcImdzaW1lO1wiOjB4MmE4ZSwgXCJnc2ltbDtcIjoweDJhOTAsXG4gIFwiZ3RcIjoweDNlLCBcImd0O1wiOjB4M2UsXG4gIFwiZ3RjYztcIjoweDJhYTcsIFwiZ3RjaXI7XCI6MHgyYTdhLFxuICBcImd0ZG90O1wiOjB4MjJkNywgXCJndGxQYXI7XCI6MHgyOTk1LFxuICBcImd0cXVlc3Q7XCI6MHgyYTdjLCBcImd0cmFwcHJveDtcIjoweDJhODYsXG4gIFwiZ3RyYXJyO1wiOjB4Mjk3OCwgXCJndHJkb3Q7XCI6MHgyMmQ3LFxuICBcImd0cmVxbGVzcztcIjoweDIyZGIsIFwiZ3RyZXFxbGVzcztcIjoweDJhOGMsXG4gIFwiZ3RybGVzcztcIjoweDIyNzcsIFwiZ3Ryc2ltO1wiOjB4MjI3MyxcbiAgXCJndmVydG5lcXE7XCI6WzB4MjI2OSwweGZlMDBdLCBcImd2bkU7XCI6WzB4MjI2OSwweGZlMDBdLFxuICBcImhBcnI7XCI6MHgyMWQ0LCBcImhhaXJzcDtcIjoweDIwMGEsXG4gIFwiaGFsZjtcIjoweGJkLCBcImhhbWlsdDtcIjoweDIxMGIsXG4gIFwiaGFyZGN5O1wiOjB4NDRhLCBcImhhcnI7XCI6MHgyMTk0LFxuICBcImhhcnJjaXI7XCI6MHgyOTQ4LCBcImhhcnJ3O1wiOjB4MjFhZCxcbiAgXCJoYmFyO1wiOjB4MjEwZiwgXCJoY2lyYztcIjoweDEyNSxcbiAgXCJoZWFydHM7XCI6MHgyNjY1LCBcImhlYXJ0c3VpdDtcIjoweDI2NjUsXG4gIFwiaGVsbGlwO1wiOjB4MjAyNiwgXCJoZXJjb247XCI6MHgyMmI5LFxuICBcImhmcjtcIjpbMHhkODM1LDB4ZGQyNV0sIFwiaGtzZWFyb3c7XCI6MHgyOTI1LFxuICBcImhrc3dhcm93O1wiOjB4MjkyNiwgXCJob2FycjtcIjoweDIxZmYsXG4gIFwiaG9tdGh0O1wiOjB4MjIzYiwgXCJob29rbGVmdGFycm93O1wiOjB4MjFhOSxcbiAgXCJob29rcmlnaHRhcnJvdztcIjoweDIxYWEsIFwiaG9wZjtcIjpbMHhkODM1LDB4ZGQ1OV0sXG4gIFwiaG9yYmFyO1wiOjB4MjAxNSwgXCJoc2NyO1wiOlsweGQ4MzUsMHhkY2JkXSxcbiAgXCJoc2xhc2g7XCI6MHgyMTBmLCBcImhzdHJvaztcIjoweDEyNyxcbiAgXCJoeWJ1bGw7XCI6MHgyMDQzLCBcImh5cGhlbjtcIjoweDIwMTAsXG4gIFwiaWFjdXRlXCI6MHhlZCwgXCJpYWN1dGU7XCI6MHhlZCxcbiAgXCJpYztcIjoweDIwNjMsIFwiaWNpcmNcIjoweGVlLFxuICBcImljaXJjO1wiOjB4ZWUsIFwiaWN5O1wiOjB4NDM4LFxuICBcImllY3k7XCI6MHg0MzUsIFwiaWV4Y2xcIjoweGExLFxuICBcImlleGNsO1wiOjB4YTEsIFwiaWZmO1wiOjB4MjFkNCxcbiAgXCJpZnI7XCI6WzB4ZDgzNSwweGRkMjZdLCBcImlncmF2ZVwiOjB4ZWMsXG4gIFwiaWdyYXZlO1wiOjB4ZWMsIFwiaWk7XCI6MHgyMTQ4LFxuICBcImlpaWludDtcIjoweDJhMGMsIFwiaWlpbnQ7XCI6MHgyMjJkLFxuICBcImlpbmZpbjtcIjoweDI5ZGMsIFwiaWlvdGE7XCI6MHgyMTI5LFxuICBcImlqbGlnO1wiOjB4MTMzLCBcImltYWNyO1wiOjB4MTJiLFxuICBcImltYWdlO1wiOjB4MjExMSwgXCJpbWFnbGluZTtcIjoweDIxMTAsXG4gIFwiaW1hZ3BhcnQ7XCI6MHgyMTExLCBcImltYXRoO1wiOjB4MTMxLFxuICBcImltb2Y7XCI6MHgyMmI3LCBcImltcGVkO1wiOjB4MWI1LFxuICBcImluO1wiOjB4MjIwOCwgXCJpbmNhcmU7XCI6MHgyMTA1LFxuICBcImluZmluO1wiOjB4MjIxZSwgXCJpbmZpbnRpZTtcIjoweDI5ZGQsXG4gIFwiaW5vZG90O1wiOjB4MTMxLCBcImludDtcIjoweDIyMmIsXG4gIFwiaW50Y2FsO1wiOjB4MjJiYSwgXCJpbnRlZ2VycztcIjoweDIxMjQsXG4gIFwiaW50ZXJjYWw7XCI6MHgyMmJhLCBcImludGxhcmhrO1wiOjB4MmExNyxcbiAgXCJpbnRwcm9kO1wiOjB4MmEzYywgXCJpb2N5O1wiOjB4NDUxLFxuICBcImlvZ29uO1wiOjB4MTJmLCBcImlvcGY7XCI6WzB4ZDgzNSwweGRkNWFdLFxuICBcImlvdGE7XCI6MHgzYjksIFwiaXByb2Q7XCI6MHgyYTNjLFxuICBcImlxdWVzdFwiOjB4YmYsIFwiaXF1ZXN0O1wiOjB4YmYsXG4gIFwiaXNjcjtcIjpbMHhkODM1LDB4ZGNiZV0sIFwiaXNpbjtcIjoweDIyMDgsXG4gIFwiaXNpbkU7XCI6MHgyMmY5LCBcImlzaW5kb3Q7XCI6MHgyMmY1LFxuICBcImlzaW5zO1wiOjB4MjJmNCwgXCJpc2luc3Y7XCI6MHgyMmYzLFxuICBcImlzaW52O1wiOjB4MjIwOCwgXCJpdDtcIjoweDIwNjIsXG4gIFwiaXRpbGRlO1wiOjB4MTI5LCBcIml1a2N5O1wiOjB4NDU2LFxuICBcIml1bWxcIjoweGVmLCBcIml1bWw7XCI6MHhlZixcbiAgXCJqY2lyYztcIjoweDEzNSwgXCJqY3k7XCI6MHg0MzksXG4gIFwiamZyO1wiOlsweGQ4MzUsMHhkZDI3XSwgXCJqbWF0aDtcIjoweDIzNyxcbiAgXCJqb3BmO1wiOlsweGQ4MzUsMHhkZDViXSwgXCJqc2NyO1wiOlsweGQ4MzUsMHhkY2JmXSxcbiAgXCJqc2VyY3k7XCI6MHg0NTgsIFwianVrY3k7XCI6MHg0NTQsXG4gIFwia2FwcGE7XCI6MHgzYmEsIFwia2FwcGF2O1wiOjB4M2YwLFxuICBcImtjZWRpbDtcIjoweDEzNywgXCJrY3k7XCI6MHg0M2EsXG4gIFwia2ZyO1wiOlsweGQ4MzUsMHhkZDI4XSwgXCJrZ3JlZW47XCI6MHgxMzgsXG4gIFwia2hjeTtcIjoweDQ0NSwgXCJramN5O1wiOjB4NDVjLFxuICBcImtvcGY7XCI6WzB4ZDgzNSwweGRkNWNdLCBcImtzY3I7XCI6WzB4ZDgzNSwweGRjYzBdLFxuICBcImxBYXJyO1wiOjB4MjFkYSwgXCJsQXJyO1wiOjB4MjFkMCxcbiAgXCJsQXRhaWw7XCI6MHgyOTFiLCBcImxCYXJyO1wiOjB4MjkwZSxcbiAgXCJsRTtcIjoweDIyNjYsIFwibEVnO1wiOjB4MmE4YixcbiAgXCJsSGFyO1wiOjB4Mjk2MiwgXCJsYWN1dGU7XCI6MHgxM2EsXG4gIFwibGFlbXB0eXY7XCI6MHgyOWI0LCBcImxhZ3JhbjtcIjoweDIxMTIsXG4gIFwibGFtYmRhO1wiOjB4M2JiLCBcImxhbmc7XCI6MHgyN2U4LFxuICBcImxhbmdkO1wiOjB4Mjk5MSwgXCJsYW5nbGU7XCI6MHgyN2U4LFxuICBcImxhcDtcIjoweDJhODUsIFwibGFxdW9cIjoweGFiLFxuICBcImxhcXVvO1wiOjB4YWIsIFwibGFycjtcIjoweDIxOTAsXG4gIFwibGFycmI7XCI6MHgyMWU0LCBcImxhcnJiZnM7XCI6MHgyOTFmLFxuICBcImxhcnJmcztcIjoweDI5MWQsIFwibGFycmhrO1wiOjB4MjFhOSxcbiAgXCJsYXJybHA7XCI6MHgyMWFiLCBcImxhcnJwbDtcIjoweDI5MzksXG4gIFwibGFycnNpbTtcIjoweDI5NzMsIFwibGFycnRsO1wiOjB4MjFhMixcbiAgXCJsYXQ7XCI6MHgyYWFiLCBcImxhdGFpbDtcIjoweDI5MTksXG4gIFwibGF0ZTtcIjoweDJhYWQsIFwibGF0ZXM7XCI6WzB4MmFhZCwweGZlMDBdLFxuICBcImxiYXJyO1wiOjB4MjkwYywgXCJsYmJyaztcIjoweDI3NzIsXG4gIFwibGJyYWNlO1wiOjB4N2IsIFwibGJyYWNrO1wiOjB4NWIsXG4gIFwibGJya2U7XCI6MHgyOThiLCBcImxicmtzbGQ7XCI6MHgyOThmLFxuICBcImxicmtzbHU7XCI6MHgyOThkLCBcImxjYXJvbjtcIjoweDEzZSxcbiAgXCJsY2VkaWw7XCI6MHgxM2MsIFwibGNlaWw7XCI6MHgyMzA4LFxuICBcImxjdWI7XCI6MHg3YiwgXCJsY3k7XCI6MHg0M2IsXG4gIFwibGRjYTtcIjoweDI5MzYsIFwibGRxdW87XCI6MHgyMDFjLFxuICBcImxkcXVvcjtcIjoweDIwMWUsIFwibGRyZGhhcjtcIjoweDI5NjcsXG4gIFwibGRydXNoYXI7XCI6MHgyOTRiLCBcImxkc2g7XCI6MHgyMWIyLFxuICBcImxlO1wiOjB4MjI2NCwgXCJsZWZ0YXJyb3c7XCI6MHgyMTkwLFxuICBcImxlZnRhcnJvd3RhaWw7XCI6MHgyMWEyLCBcImxlZnRoYXJwb29uZG93bjtcIjoweDIxYmQsXG4gIFwibGVmdGhhcnBvb251cDtcIjoweDIxYmMsIFwibGVmdGxlZnRhcnJvd3M7XCI6MHgyMWM3LFxuICBcImxlZnRyaWdodGFycm93O1wiOjB4MjE5NCwgXCJsZWZ0cmlnaHRhcnJvd3M7XCI6MHgyMWM2LFxuICBcImxlZnRyaWdodGhhcnBvb25zO1wiOjB4MjFjYiwgXCJsZWZ0cmlnaHRzcXVpZ2Fycm93O1wiOjB4MjFhZCxcbiAgXCJsZWZ0dGhyZWV0aW1lcztcIjoweDIyY2IsIFwibGVnO1wiOjB4MjJkYSxcbiAgXCJsZXE7XCI6MHgyMjY0LCBcImxlcXE7XCI6MHgyMjY2LFxuICBcImxlcXNsYW50O1wiOjB4MmE3ZCwgXCJsZXM7XCI6MHgyYTdkLFxuICBcImxlc2NjO1wiOjB4MmFhOCwgXCJsZXNkb3Q7XCI6MHgyYTdmLFxuICBcImxlc2RvdG87XCI6MHgyYTgxLCBcImxlc2RvdG9yO1wiOjB4MmE4MyxcbiAgXCJsZXNnO1wiOlsweDIyZGEsMHhmZTAwXSwgXCJsZXNnZXM7XCI6MHgyYTkzLFxuICBcImxlc3NhcHByb3g7XCI6MHgyYTg1LCBcImxlc3Nkb3Q7XCI6MHgyMmQ2LFxuICBcImxlc3NlcWd0cjtcIjoweDIyZGEsIFwibGVzc2VxcWd0cjtcIjoweDJhOGIsXG4gIFwibGVzc2d0cjtcIjoweDIyNzYsIFwibGVzc3NpbTtcIjoweDIyNzIsXG4gIFwibGZpc2h0O1wiOjB4Mjk3YywgXCJsZmxvb3I7XCI6MHgyMzBhLFxuICBcImxmcjtcIjpbMHhkODM1LDB4ZGQyOV0sIFwibGc7XCI6MHgyMjc2LFxuICBcImxnRTtcIjoweDJhOTEsIFwibGhhcmQ7XCI6MHgyMWJkLFxuICBcImxoYXJ1O1wiOjB4MjFiYywgXCJsaGFydWw7XCI6MHgyOTZhLFxuICBcImxoYmxrO1wiOjB4MjU4NCwgXCJsamN5O1wiOjB4NDU5LFxuICBcImxsO1wiOjB4MjI2YSwgXCJsbGFycjtcIjoweDIxYzcsXG4gIFwibGxjb3JuZXI7XCI6MHgyMzFlLCBcImxsaGFyZDtcIjoweDI5NmIsXG4gIFwibGx0cmk7XCI6MHgyNWZhLCBcImxtaWRvdDtcIjoweDE0MCxcbiAgXCJsbW91c3Q7XCI6MHgyM2IwLCBcImxtb3VzdGFjaGU7XCI6MHgyM2IwLFxuICBcImxuRTtcIjoweDIyNjgsIFwibG5hcDtcIjoweDJhODksXG4gIFwibG5hcHByb3g7XCI6MHgyYTg5LCBcImxuZTtcIjoweDJhODcsXG4gIFwibG5lcTtcIjoweDJhODcsIFwibG5lcXE7XCI6MHgyMjY4LFxuICBcImxuc2ltO1wiOjB4MjJlNiwgXCJsb2FuZztcIjoweDI3ZWMsXG4gIFwibG9hcnI7XCI6MHgyMWZkLCBcImxvYnJrO1wiOjB4MjdlNixcbiAgXCJsb25nbGVmdGFycm93O1wiOjB4MjdmNSwgXCJsb25nbGVmdHJpZ2h0YXJyb3c7XCI6MHgyN2Y3LFxuICBcImxvbmdtYXBzdG87XCI6MHgyN2ZjLCBcImxvbmdyaWdodGFycm93O1wiOjB4MjdmNixcbiAgXCJsb29wYXJyb3dsZWZ0O1wiOjB4MjFhYiwgXCJsb29wYXJyb3dyaWdodDtcIjoweDIxYWMsXG4gIFwibG9wYXI7XCI6MHgyOTg1LCBcImxvcGY7XCI6WzB4ZDgzNSwweGRkNWRdLFxuICBcImxvcGx1cztcIjoweDJhMmQsIFwibG90aW1lcztcIjoweDJhMzQsXG4gIFwibG93YXN0O1wiOjB4MjIxNywgXCJsb3diYXI7XCI6MHg1ZixcbiAgXCJsb3o7XCI6MHgyNWNhLCBcImxvemVuZ2U7XCI6MHgyNWNhLFxuICBcImxvemY7XCI6MHgyOWViLCBcImxwYXI7XCI6MHgyOCxcbiAgXCJscGFybHQ7XCI6MHgyOTkzLCBcImxyYXJyO1wiOjB4MjFjNixcbiAgXCJscmNvcm5lcjtcIjoweDIzMWYsIFwibHJoYXI7XCI6MHgyMWNiLFxuICBcImxyaGFyZDtcIjoweDI5NmQsIFwibHJtO1wiOjB4MjAwZSxcbiAgXCJscnRyaTtcIjoweDIyYmYsIFwibHNhcXVvO1wiOjB4MjAzOSxcbiAgXCJsc2NyO1wiOlsweGQ4MzUsMHhkY2MxXSwgXCJsc2g7XCI6MHgyMWIwLFxuICBcImxzaW07XCI6MHgyMjcyLCBcImxzaW1lO1wiOjB4MmE4ZCxcbiAgXCJsc2ltZztcIjoweDJhOGYsIFwibHNxYjtcIjoweDViLFxuICBcImxzcXVvO1wiOjB4MjAxOCwgXCJsc3F1b3I7XCI6MHgyMDFhLFxuICBcImxzdHJvaztcIjoweDE0MiwgXCJsdFwiOjB4M2MsXG4gIFwibHQ7XCI6MHgzYywgXCJsdGNjO1wiOjB4MmFhNixcbiAgXCJsdGNpcjtcIjoweDJhNzksIFwibHRkb3Q7XCI6MHgyMmQ2LFxuICBcImx0aHJlZTtcIjoweDIyY2IsIFwibHRpbWVzO1wiOjB4MjJjOSxcbiAgXCJsdGxhcnI7XCI6MHgyOTc2LCBcImx0cXVlc3Q7XCI6MHgyYTdiLFxuICBcImx0clBhcjtcIjoweDI5OTYsIFwibHRyaTtcIjoweDI1YzMsXG4gIFwibHRyaWU7XCI6MHgyMmI0LCBcImx0cmlmO1wiOjB4MjVjMixcbiAgXCJsdXJkc2hhcjtcIjoweDI5NGEsIFwibHVydWhhcjtcIjoweDI5NjYsXG4gIFwibHZlcnRuZXFxO1wiOlsweDIyNjgsMHhmZTAwXSwgXCJsdm5FO1wiOlsweDIyNjgsMHhmZTAwXSxcbiAgXCJtRERvdDtcIjoweDIyM2EsIFwibWFjclwiOjB4YWYsXG4gIFwibWFjcjtcIjoweGFmLCBcIm1hbGU7XCI6MHgyNjQyLFxuICBcIm1hbHQ7XCI6MHgyNzIwLCBcIm1hbHRlc2U7XCI6MHgyNzIwLFxuICBcIm1hcDtcIjoweDIxYTYsIFwibWFwc3RvO1wiOjB4MjFhNixcbiAgXCJtYXBzdG9kb3duO1wiOjB4MjFhNywgXCJtYXBzdG9sZWZ0O1wiOjB4MjFhNCxcbiAgXCJtYXBzdG91cDtcIjoweDIxYTUsIFwibWFya2VyO1wiOjB4MjVhZSxcbiAgXCJtY29tbWE7XCI6MHgyYTI5LCBcIm1jeTtcIjoweDQzYyxcbiAgXCJtZGFzaDtcIjoweDIwMTQsIFwibWVhc3VyZWRhbmdsZTtcIjoweDIyMjEsXG4gIFwibWZyO1wiOlsweGQ4MzUsMHhkZDJhXSwgXCJtaG87XCI6MHgyMTI3LFxuICBcIm1pY3JvXCI6MHhiNSwgXCJtaWNybztcIjoweGI1LFxuICBcIm1pZDtcIjoweDIyMjMsIFwibWlkYXN0O1wiOjB4MmEsXG4gIFwibWlkY2lyO1wiOjB4MmFmMCwgXCJtaWRkb3RcIjoweGI3LFxuICBcIm1pZGRvdDtcIjoweGI3LCBcIm1pbnVzO1wiOjB4MjIxMixcbiAgXCJtaW51c2I7XCI6MHgyMjlmLCBcIm1pbnVzZDtcIjoweDIyMzgsXG4gIFwibWludXNkdTtcIjoweDJhMmEsIFwibWxjcDtcIjoweDJhZGIsXG4gIFwibWxkcjtcIjoweDIwMjYsIFwibW5wbHVzO1wiOjB4MjIxMyxcbiAgXCJtb2RlbHM7XCI6MHgyMmE3LCBcIm1vcGY7XCI6WzB4ZDgzNSwweGRkNWVdLFxuICBcIm1wO1wiOjB4MjIxMywgXCJtc2NyO1wiOlsweGQ4MzUsMHhkY2MyXSxcbiAgXCJtc3Rwb3M7XCI6MHgyMjNlLCBcIm11O1wiOjB4M2JjLFxuICBcIm11bHRpbWFwO1wiOjB4MjJiOCwgXCJtdW1hcDtcIjoweDIyYjgsXG4gIFwibkdnO1wiOlsweDIyZDksMHgzMzhdLCBcIm5HdDtcIjpbMHgyMjZiLDB4MjBkMl0sXG4gIFwibkd0djtcIjpbMHgyMjZiLDB4MzM4XSwgXCJuTGVmdGFycm93O1wiOjB4MjFjZCxcbiAgXCJuTGVmdHJpZ2h0YXJyb3c7XCI6MHgyMWNlLCBcIm5MbDtcIjpbMHgyMmQ4LDB4MzM4XSxcbiAgXCJuTHQ7XCI6WzB4MjI2YSwweDIwZDJdLCBcIm5MdHY7XCI6WzB4MjI2YSwweDMzOF0sXG4gIFwiblJpZ2h0YXJyb3c7XCI6MHgyMWNmLCBcIm5WRGFzaDtcIjoweDIyYWYsXG4gIFwiblZkYXNoO1wiOjB4MjJhZSwgXCJuYWJsYTtcIjoweDIyMDcsXG4gIFwibmFjdXRlO1wiOjB4MTQ0LCBcIm5hbmc7XCI6WzB4MjIyMCwweDIwZDJdLFxuICBcIm5hcDtcIjoweDIyNDksIFwibmFwRTtcIjpbMHgyYTcwLDB4MzM4XSxcbiAgXCJuYXBpZDtcIjpbMHgyMjRiLDB4MzM4XSwgXCJuYXBvcztcIjoweDE0OSxcbiAgXCJuYXBwcm94O1wiOjB4MjI0OSwgXCJuYXR1cjtcIjoweDI2NmUsXG4gIFwibmF0dXJhbDtcIjoweDI2NmUsIFwibmF0dXJhbHM7XCI6MHgyMTE1LFxuICBcIm5ic3BcIjoweGEwLCBcIm5ic3A7XCI6MHhhMCxcbiAgXCJuYnVtcDtcIjpbMHgyMjRlLDB4MzM4XSwgXCJuYnVtcGU7XCI6WzB4MjI0ZiwweDMzOF0sXG4gIFwibmNhcDtcIjoweDJhNDMsIFwibmNhcm9uO1wiOjB4MTQ4LFxuICBcIm5jZWRpbDtcIjoweDE0NiwgXCJuY29uZztcIjoweDIyNDcsXG4gIFwibmNvbmdkb3Q7XCI6WzB4MmE2ZCwweDMzOF0sIFwibmN1cDtcIjoweDJhNDIsXG4gIFwibmN5O1wiOjB4NDNkLCBcIm5kYXNoO1wiOjB4MjAxMyxcbiAgXCJuZTtcIjoweDIyNjAsIFwibmVBcnI7XCI6MHgyMWQ3LFxuICBcIm5lYXJoaztcIjoweDI5MjQsIFwibmVhcnI7XCI6MHgyMTk3LFxuICBcIm5lYXJyb3c7XCI6MHgyMTk3LCBcIm5lZG90O1wiOlsweDIyNTAsMHgzMzhdLFxuICBcIm5lcXVpdjtcIjoweDIyNjIsIFwibmVzZWFyO1wiOjB4MjkyOCxcbiAgXCJuZXNpbTtcIjpbMHgyMjQyLDB4MzM4XSwgXCJuZXhpc3Q7XCI6MHgyMjA0LFxuICBcIm5leGlzdHM7XCI6MHgyMjA0LCBcIm5mcjtcIjpbMHhkODM1LDB4ZGQyYl0sXG4gIFwibmdFO1wiOlsweDIyNjcsMHgzMzhdLCBcIm5nZTtcIjoweDIyNzEsXG4gIFwibmdlcTtcIjoweDIyNzEsIFwibmdlcXE7XCI6WzB4MjI2NywweDMzOF0sXG4gIFwibmdlcXNsYW50O1wiOlsweDJhN2UsMHgzMzhdLCBcIm5nZXM7XCI6WzB4MmE3ZSwweDMzOF0sXG4gIFwibmdzaW07XCI6MHgyMjc1LCBcIm5ndDtcIjoweDIyNmYsXG4gIFwibmd0cjtcIjoweDIyNmYsIFwibmhBcnI7XCI6MHgyMWNlLFxuICBcIm5oYXJyO1wiOjB4MjFhZSwgXCJuaHBhcjtcIjoweDJhZjIsXG4gIFwibmk7XCI6MHgyMjBiLCBcIm5pcztcIjoweDIyZmMsXG4gIFwibmlzZDtcIjoweDIyZmEsIFwibml2O1wiOjB4MjIwYixcbiAgXCJuamN5O1wiOjB4NDVhLCBcIm5sQXJyO1wiOjB4MjFjZCxcbiAgXCJubEU7XCI6WzB4MjI2NiwweDMzOF0sIFwibmxhcnI7XCI6MHgyMTlhLFxuICBcIm5sZHI7XCI6MHgyMDI1LCBcIm5sZTtcIjoweDIyNzAsXG4gIFwibmxlZnRhcnJvdztcIjoweDIxOWEsIFwibmxlZnRyaWdodGFycm93O1wiOjB4MjFhZSxcbiAgXCJubGVxO1wiOjB4MjI3MCwgXCJubGVxcTtcIjpbMHgyMjY2LDB4MzM4XSxcbiAgXCJubGVxc2xhbnQ7XCI6WzB4MmE3ZCwweDMzOF0sIFwibmxlcztcIjpbMHgyYTdkLDB4MzM4XSxcbiAgXCJubGVzcztcIjoweDIyNmUsIFwibmxzaW07XCI6MHgyMjc0LFxuICBcIm5sdDtcIjoweDIyNmUsIFwibmx0cmk7XCI6MHgyMmVhLFxuICBcIm5sdHJpZTtcIjoweDIyZWMsIFwibm1pZDtcIjoweDIyMjQsXG4gIFwibm9wZjtcIjpbMHhkODM1LDB4ZGQ1Zl0sIFwibm90XCI6MHhhYyxcbiAgXCJub3Q7XCI6MHhhYywgXCJub3RpbjtcIjoweDIyMDksXG4gIFwibm90aW5FO1wiOlsweDIyZjksMHgzMzhdLCBcIm5vdGluZG90O1wiOlsweDIyZjUsMHgzMzhdLFxuICBcIm5vdGludmE7XCI6MHgyMjA5LCBcIm5vdGludmI7XCI6MHgyMmY3LFxuICBcIm5vdGludmM7XCI6MHgyMmY2LCBcIm5vdG5pO1wiOjB4MjIwYyxcbiAgXCJub3RuaXZhO1wiOjB4MjIwYywgXCJub3RuaXZiO1wiOjB4MjJmZSxcbiAgXCJub3RuaXZjO1wiOjB4MjJmZCwgXCJucGFyO1wiOjB4MjIyNixcbiAgXCJucGFyYWxsZWw7XCI6MHgyMjI2LCBcIm5wYXJzbDtcIjpbMHgyYWZkLDB4MjBlNV0sXG4gIFwibnBhcnQ7XCI6WzB4MjIwMiwweDMzOF0sIFwibnBvbGludDtcIjoweDJhMTQsXG4gIFwibnByO1wiOjB4MjI4MCwgXCJucHJjdWU7XCI6MHgyMmUwLFxuICBcIm5wcmU7XCI6WzB4MmFhZiwweDMzOF0sIFwibnByZWM7XCI6MHgyMjgwLFxuICBcIm5wcmVjZXE7XCI6WzB4MmFhZiwweDMzOF0sIFwibnJBcnI7XCI6MHgyMWNmLFxuICBcIm5yYXJyO1wiOjB4MjE5YiwgXCJucmFycmM7XCI6WzB4MjkzMywweDMzOF0sXG4gIFwibnJhcnJ3O1wiOlsweDIxOWQsMHgzMzhdLCBcIm5yaWdodGFycm93O1wiOjB4MjE5YixcbiAgXCJucnRyaTtcIjoweDIyZWIsIFwibnJ0cmllO1wiOjB4MjJlZCxcbiAgXCJuc2M7XCI6MHgyMjgxLCBcIm5zY2N1ZTtcIjoweDIyZTEsXG4gIFwibnNjZTtcIjpbMHgyYWIwLDB4MzM4XSwgXCJuc2NyO1wiOlsweGQ4MzUsMHhkY2MzXSxcbiAgXCJuc2hvcnRtaWQ7XCI6MHgyMjI0LCBcIm5zaG9ydHBhcmFsbGVsO1wiOjB4MjIyNixcbiAgXCJuc2ltO1wiOjB4MjI0MSwgXCJuc2ltZTtcIjoweDIyNDQsXG4gIFwibnNpbWVxO1wiOjB4MjI0NCwgXCJuc21pZDtcIjoweDIyMjQsXG4gIFwibnNwYXI7XCI6MHgyMjI2LCBcIm5zcXN1YmU7XCI6MHgyMmUyLFxuICBcIm5zcXN1cGU7XCI6MHgyMmUzLCBcIm5zdWI7XCI6MHgyMjg0LFxuICBcIm5zdWJFO1wiOlsweDJhYzUsMHgzMzhdLCBcIm5zdWJlO1wiOjB4MjI4OCxcbiAgXCJuc3Vic2V0O1wiOlsweDIyODIsMHgyMGQyXSwgXCJuc3Vic2V0ZXE7XCI6MHgyMjg4LFxuICBcIm5zdWJzZXRlcXE7XCI6WzB4MmFjNSwweDMzOF0sIFwibnN1Y2M7XCI6MHgyMjgxLFxuICBcIm5zdWNjZXE7XCI6WzB4MmFiMCwweDMzOF0sIFwibnN1cDtcIjoweDIyODUsXG4gIFwibnN1cEU7XCI6WzB4MmFjNiwweDMzOF0sIFwibnN1cGU7XCI6MHgyMjg5LFxuICBcIm5zdXBzZXQ7XCI6WzB4MjI4MywweDIwZDJdLCBcIm5zdXBzZXRlcTtcIjoweDIyODksXG4gIFwibnN1cHNldGVxcTtcIjpbMHgyYWM2LDB4MzM4XSwgXCJudGdsO1wiOjB4MjI3OSxcbiAgXCJudGlsZGVcIjoweGYxLCBcIm50aWxkZTtcIjoweGYxLFxuICBcIm50bGc7XCI6MHgyMjc4LCBcIm50cmlhbmdsZWxlZnQ7XCI6MHgyMmVhLFxuICBcIm50cmlhbmdsZWxlZnRlcTtcIjoweDIyZWMsIFwibnRyaWFuZ2xlcmlnaHQ7XCI6MHgyMmViLFxuICBcIm50cmlhbmdsZXJpZ2h0ZXE7XCI6MHgyMmVkLCBcIm51O1wiOjB4M2JkLFxuICBcIm51bTtcIjoweDIzLCBcIm51bWVybztcIjoweDIxMTYsXG4gIFwibnVtc3A7XCI6MHgyMDA3LCBcIm52RGFzaDtcIjoweDIyYWQsXG4gIFwibnZIYXJyO1wiOjB4MjkwNCwgXCJudmFwO1wiOlsweDIyNGQsMHgyMGQyXSxcbiAgXCJudmRhc2g7XCI6MHgyMmFjLCBcIm52Z2U7XCI6WzB4MjI2NSwweDIwZDJdLFxuICBcIm52Z3Q7XCI6WzB4M2UsMHgyMGQyXSwgXCJudmluZmluO1wiOjB4MjlkZSxcbiAgXCJudmxBcnI7XCI6MHgyOTAyLCBcIm52bGU7XCI6WzB4MjI2NCwweDIwZDJdLFxuICBcIm52bHQ7XCI6WzB4M2MsMHgyMGQyXSwgXCJudmx0cmllO1wiOlsweDIyYjQsMHgyMGQyXSxcbiAgXCJudnJBcnI7XCI6MHgyOTAzLCBcIm52cnRyaWU7XCI6WzB4MjJiNSwweDIwZDJdLFxuICBcIm52c2ltO1wiOlsweDIyM2MsMHgyMGQyXSwgXCJud0FycjtcIjoweDIxZDYsXG4gIFwibndhcmhrO1wiOjB4MjkyMywgXCJud2FycjtcIjoweDIxOTYsXG4gIFwibndhcnJvdztcIjoweDIxOTYsIFwibnduZWFyO1wiOjB4MjkyNyxcbiAgXCJvUztcIjoweDI0YzgsIFwib2FjdXRlXCI6MHhmMyxcbiAgXCJvYWN1dGU7XCI6MHhmMywgXCJvYXN0O1wiOjB4MjI5YixcbiAgXCJvY2lyO1wiOjB4MjI5YSwgXCJvY2lyY1wiOjB4ZjQsXG4gIFwib2NpcmM7XCI6MHhmNCwgXCJvY3k7XCI6MHg0M2UsXG4gIFwib2Rhc2g7XCI6MHgyMjlkLCBcIm9kYmxhYztcIjoweDE1MSxcbiAgXCJvZGl2O1wiOjB4MmEzOCwgXCJvZG90O1wiOjB4MjI5OSxcbiAgXCJvZHNvbGQ7XCI6MHgyOWJjLCBcIm9lbGlnO1wiOjB4MTUzLFxuICBcIm9mY2lyO1wiOjB4MjliZiwgXCJvZnI7XCI6WzB4ZDgzNSwweGRkMmNdLFxuICBcIm9nb247XCI6MHgyZGIsIFwib2dyYXZlXCI6MHhmMixcbiAgXCJvZ3JhdmU7XCI6MHhmMiwgXCJvZ3Q7XCI6MHgyOWMxLFxuICBcIm9oYmFyO1wiOjB4MjliNSwgXCJvaG07XCI6MHgzYTksXG4gIFwib2ludDtcIjoweDIyMmUsIFwib2xhcnI7XCI6MHgyMWJhLFxuICBcIm9sY2lyO1wiOjB4MjliZSwgXCJvbGNyb3NzO1wiOjB4MjliYixcbiAgXCJvbGluZTtcIjoweDIwM2UsIFwib2x0O1wiOjB4MjljMCxcbiAgXCJvbWFjcjtcIjoweDE0ZCwgXCJvbWVnYTtcIjoweDNjOSxcbiAgXCJvbWljcm9uO1wiOjB4M2JmLCBcIm9taWQ7XCI6MHgyOWI2LFxuICBcIm9taW51cztcIjoweDIyOTYsIFwib29wZjtcIjpbMHhkODM1LDB4ZGQ2MF0sXG4gIFwib3BhcjtcIjoweDI5YjcsIFwib3BlcnA7XCI6MHgyOWI5LFxuICBcIm9wbHVzO1wiOjB4MjI5NSwgXCJvcjtcIjoweDIyMjgsXG4gIFwib3JhcnI7XCI6MHgyMWJiLCBcIm9yZDtcIjoweDJhNWQsXG4gIFwib3JkZXI7XCI6MHgyMTM0LCBcIm9yZGVyb2Y7XCI6MHgyMTM0LFxuICBcIm9yZGZcIjoweGFhLCBcIm9yZGY7XCI6MHhhYSxcbiAgXCJvcmRtXCI6MHhiYSwgXCJvcmRtO1wiOjB4YmEsXG4gIFwib3JpZ29mO1wiOjB4MjJiNiwgXCJvcm9yO1wiOjB4MmE1NixcbiAgXCJvcnNsb3BlO1wiOjB4MmE1NywgXCJvcnY7XCI6MHgyYTViLFxuICBcIm9zY3I7XCI6MHgyMTM0LCBcIm9zbGFzaFwiOjB4ZjgsXG4gIFwib3NsYXNoO1wiOjB4ZjgsIFwib3NvbDtcIjoweDIyOTgsXG4gIFwib3RpbGRlXCI6MHhmNSwgXCJvdGlsZGU7XCI6MHhmNSxcbiAgXCJvdGltZXM7XCI6MHgyMjk3LCBcIm90aW1lc2FzO1wiOjB4MmEzNixcbiAgXCJvdW1sXCI6MHhmNiwgXCJvdW1sO1wiOjB4ZjYsXG4gIFwib3ZiYXI7XCI6MHgyMzNkLCBcInBhcjtcIjoweDIyMjUsXG4gIFwicGFyYVwiOjB4YjYsIFwicGFyYTtcIjoweGI2LFxuICBcInBhcmFsbGVsO1wiOjB4MjIyNSwgXCJwYXJzaW07XCI6MHgyYWYzLFxuICBcInBhcnNsO1wiOjB4MmFmZCwgXCJwYXJ0O1wiOjB4MjIwMixcbiAgXCJwY3k7XCI6MHg0M2YsIFwicGVyY250O1wiOjB4MjUsXG4gIFwicGVyaW9kO1wiOjB4MmUsIFwicGVybWlsO1wiOjB4MjAzMCxcbiAgXCJwZXJwO1wiOjB4MjJhNSwgXCJwZXJ0ZW5rO1wiOjB4MjAzMSxcbiAgXCJwZnI7XCI6WzB4ZDgzNSwweGRkMmRdLCBcInBoaTtcIjoweDNjNixcbiAgXCJwaGl2O1wiOjB4M2Q1LCBcInBobW1hdDtcIjoweDIxMzMsXG4gIFwicGhvbmU7XCI6MHgyNjBlLCBcInBpO1wiOjB4M2MwLFxuICBcInBpdGNoZm9yaztcIjoweDIyZDQsIFwicGl2O1wiOjB4M2Q2LFxuICBcInBsYW5jaztcIjoweDIxMGYsIFwicGxhbmNraDtcIjoweDIxMGUsXG4gIFwicGxhbmt2O1wiOjB4MjEwZiwgXCJwbHVzO1wiOjB4MmIsXG4gIFwicGx1c2FjaXI7XCI6MHgyYTIzLCBcInBsdXNiO1wiOjB4MjI5ZSxcbiAgXCJwbHVzY2lyO1wiOjB4MmEyMiwgXCJwbHVzZG87XCI6MHgyMjE0LFxuICBcInBsdXNkdTtcIjoweDJhMjUsIFwicGx1c2U7XCI6MHgyYTcyLFxuICBcInBsdXNtblwiOjB4YjEsIFwicGx1c21uO1wiOjB4YjEsXG4gIFwicGx1c3NpbTtcIjoweDJhMjYsIFwicGx1c3R3bztcIjoweDJhMjcsXG4gIFwicG07XCI6MHhiMSwgXCJwb2ludGludDtcIjoweDJhMTUsXG4gIFwicG9wZjtcIjpbMHhkODM1LDB4ZGQ2MV0sIFwicG91bmRcIjoweGEzLFxuICBcInBvdW5kO1wiOjB4YTMsIFwicHI7XCI6MHgyMjdhLFxuICBcInByRTtcIjoweDJhYjMsIFwicHJhcDtcIjoweDJhYjcsXG4gIFwicHJjdWU7XCI6MHgyMjdjLCBcInByZTtcIjoweDJhYWYsXG4gIFwicHJlYztcIjoweDIyN2EsIFwicHJlY2FwcHJveDtcIjoweDJhYjcsXG4gIFwicHJlY2N1cmx5ZXE7XCI6MHgyMjdjLCBcInByZWNlcTtcIjoweDJhYWYsXG4gIFwicHJlY25hcHByb3g7XCI6MHgyYWI5LCBcInByZWNuZXFxO1wiOjB4MmFiNSxcbiAgXCJwcmVjbnNpbTtcIjoweDIyZTgsIFwicHJlY3NpbTtcIjoweDIyN2UsXG4gIFwicHJpbWU7XCI6MHgyMDMyLCBcInByaW1lcztcIjoweDIxMTksXG4gIFwicHJuRTtcIjoweDJhYjUsIFwicHJuYXA7XCI6MHgyYWI5LFxuICBcInBybnNpbTtcIjoweDIyZTgsIFwicHJvZDtcIjoweDIyMGYsXG4gIFwicHJvZmFsYXI7XCI6MHgyMzJlLCBcInByb2ZsaW5lO1wiOjB4MjMxMixcbiAgXCJwcm9mc3VyZjtcIjoweDIzMTMsIFwicHJvcDtcIjoweDIyMWQsXG4gIFwicHJvcHRvO1wiOjB4MjIxZCwgXCJwcnNpbTtcIjoweDIyN2UsXG4gIFwicHJ1cmVsO1wiOjB4MjJiMCwgXCJwc2NyO1wiOlsweGQ4MzUsMHhkY2M1XSxcbiAgXCJwc2k7XCI6MHgzYzgsIFwicHVuY3NwO1wiOjB4MjAwOCxcbiAgXCJxZnI7XCI6WzB4ZDgzNSwweGRkMmVdLCBcInFpbnQ7XCI6MHgyYTBjLFxuICBcInFvcGY7XCI6WzB4ZDgzNSwweGRkNjJdLCBcInFwcmltZTtcIjoweDIwNTcsXG4gIFwicXNjcjtcIjpbMHhkODM1LDB4ZGNjNl0sIFwicXVhdGVybmlvbnM7XCI6MHgyMTBkLFxuICBcInF1YXRpbnQ7XCI6MHgyYTE2LCBcInF1ZXN0O1wiOjB4M2YsXG4gIFwicXVlc3RlcTtcIjoweDIyNWYsIFwicXVvdFwiOjB4MjIsXG4gIFwicXVvdDtcIjoweDIyLCBcInJBYXJyO1wiOjB4MjFkYixcbiAgXCJyQXJyO1wiOjB4MjFkMiwgXCJyQXRhaWw7XCI6MHgyOTFjLFxuICBcInJCYXJyO1wiOjB4MjkwZiwgXCJySGFyO1wiOjB4Mjk2NCxcbiAgXCJyYWNlO1wiOlsweDIyM2QsMHgzMzFdLCBcInJhY3V0ZTtcIjoweDE1NSxcbiAgXCJyYWRpYztcIjoweDIyMWEsIFwicmFlbXB0eXY7XCI6MHgyOWIzLFxuICBcInJhbmc7XCI6MHgyN2U5LCBcInJhbmdkO1wiOjB4Mjk5MixcbiAgXCJyYW5nZTtcIjoweDI5YTUsIFwicmFuZ2xlO1wiOjB4MjdlOSxcbiAgXCJyYXF1b1wiOjB4YmIsIFwicmFxdW87XCI6MHhiYixcbiAgXCJyYXJyO1wiOjB4MjE5MiwgXCJyYXJyYXA7XCI6MHgyOTc1LFxuICBcInJhcnJiO1wiOjB4MjFlNSwgXCJyYXJyYmZzO1wiOjB4MjkyMCxcbiAgXCJyYXJyYztcIjoweDI5MzMsIFwicmFycmZzO1wiOjB4MjkxZSxcbiAgXCJyYXJyaGs7XCI6MHgyMWFhLCBcInJhcnJscDtcIjoweDIxYWMsXG4gIFwicmFycnBsO1wiOjB4Mjk0NSwgXCJyYXJyc2ltO1wiOjB4Mjk3NCxcbiAgXCJyYXJydGw7XCI6MHgyMWEzLCBcInJhcnJ3O1wiOjB4MjE5ZCxcbiAgXCJyYXRhaWw7XCI6MHgyOTFhLCBcInJhdGlvO1wiOjB4MjIzNixcbiAgXCJyYXRpb25hbHM7XCI6MHgyMTFhLCBcInJiYXJyO1wiOjB4MjkwZCxcbiAgXCJyYmJyaztcIjoweDI3NzMsIFwicmJyYWNlO1wiOjB4N2QsXG4gIFwicmJyYWNrO1wiOjB4NWQsIFwicmJya2U7XCI6MHgyOThjLFxuICBcInJicmtzbGQ7XCI6MHgyOThlLCBcInJicmtzbHU7XCI6MHgyOTkwLFxuICBcInJjYXJvbjtcIjoweDE1OSwgXCJyY2VkaWw7XCI6MHgxNTcsXG4gIFwicmNlaWw7XCI6MHgyMzA5LCBcInJjdWI7XCI6MHg3ZCxcbiAgXCJyY3k7XCI6MHg0NDAsIFwicmRjYTtcIjoweDI5MzcsXG4gIFwicmRsZGhhcjtcIjoweDI5NjksIFwicmRxdW87XCI6MHgyMDFkLFxuICBcInJkcXVvcjtcIjoweDIwMWQsIFwicmRzaDtcIjoweDIxYjMsXG4gIFwicmVhbDtcIjoweDIxMWMsIFwicmVhbGluZTtcIjoweDIxMWIsXG4gIFwicmVhbHBhcnQ7XCI6MHgyMTFjLCBcInJlYWxzO1wiOjB4MjExZCxcbiAgXCJyZWN0O1wiOjB4MjVhZCwgXCJyZWdcIjoweGFlLFxuICBcInJlZztcIjoweGFlLCBcInJmaXNodDtcIjoweDI5N2QsXG4gIFwicmZsb29yO1wiOjB4MjMwYiwgXCJyZnI7XCI6WzB4ZDgzNSwweGRkMmZdLFxuICBcInJoYXJkO1wiOjB4MjFjMSwgXCJyaGFydTtcIjoweDIxYzAsXG4gIFwicmhhcnVsO1wiOjB4Mjk2YywgXCJyaG87XCI6MHgzYzEsXG4gIFwicmhvdjtcIjoweDNmMSwgXCJyaWdodGFycm93O1wiOjB4MjE5MixcbiAgXCJyaWdodGFycm93dGFpbDtcIjoweDIxYTMsIFwicmlnaHRoYXJwb29uZG93bjtcIjoweDIxYzEsXG4gIFwicmlnaHRoYXJwb29udXA7XCI6MHgyMWMwLCBcInJpZ2h0bGVmdGFycm93cztcIjoweDIxYzQsXG4gIFwicmlnaHRsZWZ0aGFycG9vbnM7XCI6MHgyMWNjLCBcInJpZ2h0cmlnaHRhcnJvd3M7XCI6MHgyMWM5LFxuICBcInJpZ2h0c3F1aWdhcnJvdztcIjoweDIxOWQsIFwicmlnaHR0aHJlZXRpbWVzO1wiOjB4MjJjYyxcbiAgXCJyaW5nO1wiOjB4MmRhLCBcInJpc2luZ2RvdHNlcTtcIjoweDIyNTMsXG4gIFwicmxhcnI7XCI6MHgyMWM0LCBcInJsaGFyO1wiOjB4MjFjYyxcbiAgXCJybG07XCI6MHgyMDBmLCBcInJtb3VzdDtcIjoweDIzYjEsXG4gIFwicm1vdXN0YWNoZTtcIjoweDIzYjEsIFwicm5taWQ7XCI6MHgyYWVlLFxuICBcInJvYW5nO1wiOjB4MjdlZCwgXCJyb2FycjtcIjoweDIxZmUsXG4gIFwicm9icms7XCI6MHgyN2U3LCBcInJvcGFyO1wiOjB4Mjk4NixcbiAgXCJyb3BmO1wiOlsweGQ4MzUsMHhkZDYzXSwgXCJyb3BsdXM7XCI6MHgyYTJlLFxuICBcInJvdGltZXM7XCI6MHgyYTM1LCBcInJwYXI7XCI6MHgyOSxcbiAgXCJycGFyZ3Q7XCI6MHgyOTk0LCBcInJwcG9saW50O1wiOjB4MmExMixcbiAgXCJycmFycjtcIjoweDIxYzksIFwicnNhcXVvO1wiOjB4MjAzYSxcbiAgXCJyc2NyO1wiOlsweGQ4MzUsMHhkY2M3XSwgXCJyc2g7XCI6MHgyMWIxLFxuICBcInJzcWI7XCI6MHg1ZCwgXCJyc3F1bztcIjoweDIwMTksXG4gIFwicnNxdW9yO1wiOjB4MjAxOSwgXCJydGhyZWU7XCI6MHgyMmNjLFxuICBcInJ0aW1lcztcIjoweDIyY2EsIFwicnRyaTtcIjoweDI1YjksXG4gIFwicnRyaWU7XCI6MHgyMmI1LCBcInJ0cmlmO1wiOjB4MjViOCxcbiAgXCJydHJpbHRyaTtcIjoweDI5Y2UsIFwicnVsdWhhcjtcIjoweDI5NjgsXG4gIFwicng7XCI6MHgyMTFlLCBcInNhY3V0ZTtcIjoweDE1YixcbiAgXCJzYnF1bztcIjoweDIwMWEsIFwic2M7XCI6MHgyMjdiLFxuICBcInNjRTtcIjoweDJhYjQsIFwic2NhcDtcIjoweDJhYjgsXG4gIFwic2Nhcm9uO1wiOjB4MTYxLCBcInNjY3VlO1wiOjB4MjI3ZCxcbiAgXCJzY2U7XCI6MHgyYWIwLCBcInNjZWRpbDtcIjoweDE1ZixcbiAgXCJzY2lyYztcIjoweDE1ZCwgXCJzY25FO1wiOjB4MmFiNixcbiAgXCJzY25hcDtcIjoweDJhYmEsIFwic2Nuc2ltO1wiOjB4MjJlOSxcbiAgXCJzY3BvbGludDtcIjoweDJhMTMsIFwic2NzaW07XCI6MHgyMjdmLFxuICBcInNjeTtcIjoweDQ0MSwgXCJzZG90O1wiOjB4MjJjNSxcbiAgXCJzZG90YjtcIjoweDIyYTEsIFwic2RvdGU7XCI6MHgyYTY2LFxuICBcInNlQXJyO1wiOjB4MjFkOCwgXCJzZWFyaGs7XCI6MHgyOTI1LFxuICBcInNlYXJyO1wiOjB4MjE5OCwgXCJzZWFycm93O1wiOjB4MjE5OCxcbiAgXCJzZWN0XCI6MHhhNywgXCJzZWN0O1wiOjB4YTcsXG4gIFwic2VtaTtcIjoweDNiLCBcInNlc3dhcjtcIjoweDI5MjksXG4gIFwic2V0bWludXM7XCI6MHgyMjE2LCBcInNldG1uO1wiOjB4MjIxNixcbiAgXCJzZXh0O1wiOjB4MjczNiwgXCJzZnI7XCI6WzB4ZDgzNSwweGRkMzBdLFxuICBcInNmcm93bjtcIjoweDIzMjIsIFwic2hhcnA7XCI6MHgyNjZmLFxuICBcInNoY2hjeTtcIjoweDQ0OSwgXCJzaGN5O1wiOjB4NDQ4LFxuICBcInNob3J0bWlkO1wiOjB4MjIyMywgXCJzaG9ydHBhcmFsbGVsO1wiOjB4MjIyNSxcbiAgXCJzaHlcIjoweGFkLCBcInNoeTtcIjoweGFkLFxuICBcInNpZ21hO1wiOjB4M2MzLCBcInNpZ21hZjtcIjoweDNjMixcbiAgXCJzaWdtYXY7XCI6MHgzYzIsIFwic2ltO1wiOjB4MjIzYyxcbiAgXCJzaW1kb3Q7XCI6MHgyYTZhLCBcInNpbWU7XCI6MHgyMjQzLFxuICBcInNpbWVxO1wiOjB4MjI0MywgXCJzaW1nO1wiOjB4MmE5ZSxcbiAgXCJzaW1nRTtcIjoweDJhYTAsIFwic2ltbDtcIjoweDJhOWQsXG4gIFwic2ltbEU7XCI6MHgyYTlmLCBcInNpbW5lO1wiOjB4MjI0NixcbiAgXCJzaW1wbHVzO1wiOjB4MmEyNCwgXCJzaW1yYXJyO1wiOjB4Mjk3MixcbiAgXCJzbGFycjtcIjoweDIxOTAsIFwic21hbGxzZXRtaW51cztcIjoweDIyMTYsXG4gIFwic21hc2hwO1wiOjB4MmEzMywgXCJzbWVwYXJzbDtcIjoweDI5ZTQsXG4gIFwic21pZDtcIjoweDIyMjMsIFwic21pbGU7XCI6MHgyMzIzLFxuICBcInNtdDtcIjoweDJhYWEsIFwic210ZTtcIjoweDJhYWMsXG4gIFwic210ZXM7XCI6WzB4MmFhYywweGZlMDBdLCBcInNvZnRjeTtcIjoweDQ0YyxcbiAgXCJzb2w7XCI6MHgyZiwgXCJzb2xiO1wiOjB4MjljNCxcbiAgXCJzb2xiYXI7XCI6MHgyMzNmLCBcInNvcGY7XCI6WzB4ZDgzNSwweGRkNjRdLFxuICBcInNwYWRlcztcIjoweDI2NjAsIFwic3BhZGVzdWl0O1wiOjB4MjY2MCxcbiAgXCJzcGFyO1wiOjB4MjIyNSwgXCJzcWNhcDtcIjoweDIyOTMsXG4gIFwic3FjYXBzO1wiOlsweDIyOTMsMHhmZTAwXSwgXCJzcWN1cDtcIjoweDIyOTQsXG4gIFwic3FjdXBzO1wiOlsweDIyOTQsMHhmZTAwXSwgXCJzcXN1YjtcIjoweDIyOGYsXG4gIFwic3FzdWJlO1wiOjB4MjI5MSwgXCJzcXN1YnNldDtcIjoweDIyOGYsXG4gIFwic3FzdWJzZXRlcTtcIjoweDIyOTEsIFwic3FzdXA7XCI6MHgyMjkwLFxuICBcInNxc3VwZTtcIjoweDIyOTIsIFwic3FzdXBzZXQ7XCI6MHgyMjkwLFxuICBcInNxc3Vwc2V0ZXE7XCI6MHgyMjkyLCBcInNxdTtcIjoweDI1YTEsXG4gIFwic3F1YXJlO1wiOjB4MjVhMSwgXCJzcXVhcmY7XCI6MHgyNWFhLFxuICBcInNxdWY7XCI6MHgyNWFhLCBcInNyYXJyO1wiOjB4MjE5MixcbiAgXCJzc2NyO1wiOlsweGQ4MzUsMHhkY2M4XSwgXCJzc2V0bW47XCI6MHgyMjE2LFxuICBcInNzbWlsZTtcIjoweDIzMjMsIFwic3N0YXJmO1wiOjB4MjJjNixcbiAgXCJzdGFyO1wiOjB4MjYwNiwgXCJzdGFyZjtcIjoweDI2MDUsXG4gIFwic3RyYWlnaHRlcHNpbG9uO1wiOjB4M2Y1LCBcInN0cmFpZ2h0cGhpO1wiOjB4M2Q1LFxuICBcInN0cm5zO1wiOjB4YWYsIFwic3ViO1wiOjB4MjI4MixcbiAgXCJzdWJFO1wiOjB4MmFjNSwgXCJzdWJkb3Q7XCI6MHgyYWJkLFxuICBcInN1YmU7XCI6MHgyMjg2LCBcInN1YmVkb3Q7XCI6MHgyYWMzLFxuICBcInN1Ym11bHQ7XCI6MHgyYWMxLCBcInN1Ym5FO1wiOjB4MmFjYixcbiAgXCJzdWJuZTtcIjoweDIyOGEsIFwic3VicGx1cztcIjoweDJhYmYsXG4gIFwic3VicmFycjtcIjoweDI5NzksIFwic3Vic2V0O1wiOjB4MjI4MixcbiAgXCJzdWJzZXRlcTtcIjoweDIyODYsIFwic3Vic2V0ZXFxO1wiOjB4MmFjNSxcbiAgXCJzdWJzZXRuZXE7XCI6MHgyMjhhLCBcInN1YnNldG5lcXE7XCI6MHgyYWNiLFxuICBcInN1YnNpbTtcIjoweDJhYzcsIFwic3Vic3ViO1wiOjB4MmFkNSxcbiAgXCJzdWJzdXA7XCI6MHgyYWQzLCBcInN1Y2M7XCI6MHgyMjdiLFxuICBcInN1Y2NhcHByb3g7XCI6MHgyYWI4LCBcInN1Y2NjdXJseWVxO1wiOjB4MjI3ZCxcbiAgXCJzdWNjZXE7XCI6MHgyYWIwLCBcInN1Y2NuYXBwcm94O1wiOjB4MmFiYSxcbiAgXCJzdWNjbmVxcTtcIjoweDJhYjYsIFwic3VjY25zaW07XCI6MHgyMmU5LFxuICBcInN1Y2NzaW07XCI6MHgyMjdmLCBcInN1bTtcIjoweDIyMTEsXG4gIFwic3VuZztcIjoweDI2NmEsIFwic3VwMVwiOjB4YjksXG4gIFwic3VwMTtcIjoweGI5LCBcInN1cDJcIjoweGIyLFxuICBcInN1cDI7XCI6MHhiMiwgXCJzdXAzXCI6MHhiMyxcbiAgXCJzdXAzO1wiOjB4YjMsIFwic3VwO1wiOjB4MjI4MyxcbiAgXCJzdXBFO1wiOjB4MmFjNiwgXCJzdXBkb3Q7XCI6MHgyYWJlLFxuICBcInN1cGRzdWI7XCI6MHgyYWQ4LCBcInN1cGU7XCI6MHgyMjg3LFxuICBcInN1cGVkb3Q7XCI6MHgyYWM0LCBcInN1cGhzb2w7XCI6MHgyN2M5LFxuICBcInN1cGhzdWI7XCI6MHgyYWQ3LCBcInN1cGxhcnI7XCI6MHgyOTdiLFxuICBcInN1cG11bHQ7XCI6MHgyYWMyLCBcInN1cG5FO1wiOjB4MmFjYyxcbiAgXCJzdXBuZTtcIjoweDIyOGIsIFwic3VwcGx1cztcIjoweDJhYzAsXG4gIFwic3Vwc2V0O1wiOjB4MjI4MywgXCJzdXBzZXRlcTtcIjoweDIyODcsXG4gIFwic3Vwc2V0ZXFxO1wiOjB4MmFjNiwgXCJzdXBzZXRuZXE7XCI6MHgyMjhiLFxuICBcInN1cHNldG5lcXE7XCI6MHgyYWNjLCBcInN1cHNpbTtcIjoweDJhYzgsXG4gIFwic3Vwc3ViO1wiOjB4MmFkNCwgXCJzdXBzdXA7XCI6MHgyYWQ2LFxuICBcInN3QXJyO1wiOjB4MjFkOSwgXCJzd2FyaGs7XCI6MHgyOTI2LFxuICBcInN3YXJyO1wiOjB4MjE5OSwgXCJzd2Fycm93O1wiOjB4MjE5OSxcbiAgXCJzd253YXI7XCI6MHgyOTJhLCBcInN6bGlnXCI6MHhkZixcbiAgXCJzemxpZztcIjoweGRmLCBcInRhcmdldDtcIjoweDIzMTYsXG4gIFwidGF1O1wiOjB4M2M0LCBcInRicms7XCI6MHgyM2I0LFxuICBcInRjYXJvbjtcIjoweDE2NSwgXCJ0Y2VkaWw7XCI6MHgxNjMsXG4gIFwidGN5O1wiOjB4NDQyLCBcInRkb3Q7XCI6MHgyMGRiLFxuICBcInRlbHJlYztcIjoweDIzMTUsIFwidGZyO1wiOlsweGQ4MzUsMHhkZDMxXSxcbiAgXCJ0aGVyZTQ7XCI6MHgyMjM0LCBcInRoZXJlZm9yZTtcIjoweDIyMzQsXG4gIFwidGhldGE7XCI6MHgzYjgsIFwidGhldGFzeW07XCI6MHgzZDEsXG4gIFwidGhldGF2O1wiOjB4M2QxLCBcInRoaWNrYXBwcm94O1wiOjB4MjI0OCxcbiAgXCJ0aGlja3NpbTtcIjoweDIyM2MsIFwidGhpbnNwO1wiOjB4MjAwOSxcbiAgXCJ0aGthcDtcIjoweDIyNDgsIFwidGhrc2ltO1wiOjB4MjIzYyxcbiAgXCJ0aG9yblwiOjB4ZmUsIFwidGhvcm47XCI6MHhmZSxcbiAgXCJ0aWxkZTtcIjoweDJkYywgXCJ0aW1lc1wiOjB4ZDcsXG4gIFwidGltZXM7XCI6MHhkNywgXCJ0aW1lc2I7XCI6MHgyMmEwLFxuICBcInRpbWVzYmFyO1wiOjB4MmEzMSwgXCJ0aW1lc2Q7XCI6MHgyYTMwLFxuICBcInRpbnQ7XCI6MHgyMjJkLCBcInRvZWE7XCI6MHgyOTI4LFxuICBcInRvcDtcIjoweDIyYTQsIFwidG9wYm90O1wiOjB4MjMzNixcbiAgXCJ0b3BjaXI7XCI6MHgyYWYxLCBcInRvcGY7XCI6WzB4ZDgzNSwweGRkNjVdLFxuICBcInRvcGZvcms7XCI6MHgyYWRhLCBcInRvc2E7XCI6MHgyOTI5LFxuICBcInRwcmltZTtcIjoweDIwMzQsIFwidHJhZGU7XCI6MHgyMTIyLFxuICBcInRyaWFuZ2xlO1wiOjB4MjViNSwgXCJ0cmlhbmdsZWRvd247XCI6MHgyNWJmLFxuICBcInRyaWFuZ2xlbGVmdDtcIjoweDI1YzMsIFwidHJpYW5nbGVsZWZ0ZXE7XCI6MHgyMmI0LFxuICBcInRyaWFuZ2xlcTtcIjoweDIyNWMsIFwidHJpYW5nbGVyaWdodDtcIjoweDI1YjksXG4gIFwidHJpYW5nbGVyaWdodGVxO1wiOjB4MjJiNSwgXCJ0cmlkb3Q7XCI6MHgyNWVjLFxuICBcInRyaWU7XCI6MHgyMjVjLCBcInRyaW1pbnVzO1wiOjB4MmEzYSxcbiAgXCJ0cmlwbHVzO1wiOjB4MmEzOSwgXCJ0cmlzYjtcIjoweDI5Y2QsXG4gIFwidHJpdGltZTtcIjoweDJhM2IsIFwidHJwZXppdW07XCI6MHgyM2UyLFxuICBcInRzY3I7XCI6WzB4ZDgzNSwweGRjYzldLCBcInRzY3k7XCI6MHg0NDYsXG4gIFwidHNoY3k7XCI6MHg0NWIsIFwidHN0cm9rO1wiOjB4MTY3LFxuICBcInR3aXh0O1wiOjB4MjI2YywgXCJ0d29oZWFkbGVmdGFycm93O1wiOjB4MjE5ZSxcbiAgXCJ0d29oZWFkcmlnaHRhcnJvdztcIjoweDIxYTAsIFwidUFycjtcIjoweDIxZDEsXG4gIFwidUhhcjtcIjoweDI5NjMsIFwidWFjdXRlXCI6MHhmYSxcbiAgXCJ1YWN1dGU7XCI6MHhmYSwgXCJ1YXJyO1wiOjB4MjE5MSxcbiAgXCJ1YnJjeTtcIjoweDQ1ZSwgXCJ1YnJldmU7XCI6MHgxNmQsXG4gIFwidWNpcmNcIjoweGZiLCBcInVjaXJjO1wiOjB4ZmIsXG4gIFwidWN5O1wiOjB4NDQzLCBcInVkYXJyO1wiOjB4MjFjNSxcbiAgXCJ1ZGJsYWM7XCI6MHgxNzEsIFwidWRoYXI7XCI6MHgyOTZlLFxuICBcInVmaXNodDtcIjoweDI5N2UsIFwidWZyO1wiOlsweGQ4MzUsMHhkZDMyXSxcbiAgXCJ1Z3JhdmVcIjoweGY5LCBcInVncmF2ZTtcIjoweGY5LFxuICBcInVoYXJsO1wiOjB4MjFiZiwgXCJ1aGFycjtcIjoweDIxYmUsXG4gIFwidWhibGs7XCI6MHgyNTgwLCBcInVsY29ybjtcIjoweDIzMWMsXG4gIFwidWxjb3JuZXI7XCI6MHgyMzFjLCBcInVsY3JvcDtcIjoweDIzMGYsXG4gIFwidWx0cmk7XCI6MHgyNWY4LCBcInVtYWNyO1wiOjB4MTZiLFxuICBcInVtbFwiOjB4YTgsIFwidW1sO1wiOjB4YTgsXG4gIFwidW9nb247XCI6MHgxNzMsIFwidW9wZjtcIjpbMHhkODM1LDB4ZGQ2Nl0sXG4gIFwidXBhcnJvdztcIjoweDIxOTEsIFwidXBkb3duYXJyb3c7XCI6MHgyMTk1LFxuICBcInVwaGFycG9vbmxlZnQ7XCI6MHgyMWJmLCBcInVwaGFycG9vbnJpZ2h0O1wiOjB4MjFiZSxcbiAgXCJ1cGx1cztcIjoweDIyOGUsIFwidXBzaTtcIjoweDNjNSxcbiAgXCJ1cHNpaDtcIjoweDNkMiwgXCJ1cHNpbG9uO1wiOjB4M2M1LFxuICBcInVwdXBhcnJvd3M7XCI6MHgyMWM4LCBcInVyY29ybjtcIjoweDIzMWQsXG4gIFwidXJjb3JuZXI7XCI6MHgyMzFkLCBcInVyY3JvcDtcIjoweDIzMGUsXG4gIFwidXJpbmc7XCI6MHgxNmYsIFwidXJ0cmk7XCI6MHgyNWY5LFxuICBcInVzY3I7XCI6WzB4ZDgzNSwweGRjY2FdLCBcInV0ZG90O1wiOjB4MjJmMCxcbiAgXCJ1dGlsZGU7XCI6MHgxNjksIFwidXRyaTtcIjoweDI1YjUsXG4gIFwidXRyaWY7XCI6MHgyNWI0LCBcInV1YXJyO1wiOjB4MjFjOCxcbiAgXCJ1dW1sXCI6MHhmYywgXCJ1dW1sO1wiOjB4ZmMsXG4gIFwidXdhbmdsZTtcIjoweDI5YTcsIFwidkFycjtcIjoweDIxZDUsXG4gIFwidkJhcjtcIjoweDJhZTgsIFwidkJhcnY7XCI6MHgyYWU5LFxuICBcInZEYXNoO1wiOjB4MjJhOCwgXCJ2YW5ncnQ7XCI6MHgyOTljLFxuICBcInZhcmVwc2lsb247XCI6MHgzZjUsIFwidmFya2FwcGE7XCI6MHgzZjAsXG4gIFwidmFybm90aGluZztcIjoweDIyMDUsIFwidmFycGhpO1wiOjB4M2Q1LFxuICBcInZhcnBpO1wiOjB4M2Q2LCBcInZhcnByb3B0bztcIjoweDIyMWQsXG4gIFwidmFycjtcIjoweDIxOTUsIFwidmFycmhvO1wiOjB4M2YxLFxuICBcInZhcnNpZ21hO1wiOjB4M2MyLCBcInZhcnN1YnNldG5lcTtcIjpbMHgyMjhhLDB4ZmUwMF0sXG4gIFwidmFyc3Vic2V0bmVxcTtcIjpbMHgyYWNiLDB4ZmUwMF0sIFwidmFyc3Vwc2V0bmVxO1wiOlsweDIyOGIsMHhmZTAwXSxcbiAgXCJ2YXJzdXBzZXRuZXFxO1wiOlsweDJhY2MsMHhmZTAwXSwgXCJ2YXJ0aGV0YTtcIjoweDNkMSxcbiAgXCJ2YXJ0cmlhbmdsZWxlZnQ7XCI6MHgyMmIyLCBcInZhcnRyaWFuZ2xlcmlnaHQ7XCI6MHgyMmIzLFxuICBcInZjeTtcIjoweDQzMiwgXCJ2ZGFzaDtcIjoweDIyYTIsXG4gIFwidmVlO1wiOjB4MjIyOCwgXCJ2ZWViYXI7XCI6MHgyMmJiLFxuICBcInZlZWVxO1wiOjB4MjI1YSwgXCJ2ZWxsaXA7XCI6MHgyMmVlLFxuICBcInZlcmJhcjtcIjoweDdjLCBcInZlcnQ7XCI6MHg3YyxcbiAgXCJ2ZnI7XCI6WzB4ZDgzNSwweGRkMzNdLCBcInZsdHJpO1wiOjB4MjJiMixcbiAgXCJ2bnN1YjtcIjpbMHgyMjgyLDB4MjBkMl0sIFwidm5zdXA7XCI6WzB4MjI4MywweDIwZDJdLFxuICBcInZvcGY7XCI6WzB4ZDgzNSwweGRkNjddLCBcInZwcm9wO1wiOjB4MjIxZCxcbiAgXCJ2cnRyaTtcIjoweDIyYjMsIFwidnNjcjtcIjpbMHhkODM1LDB4ZGNjYl0sXG4gIFwidnN1Ym5FO1wiOlsweDJhY2IsMHhmZTAwXSwgXCJ2c3VibmU7XCI6WzB4MjI4YSwweGZlMDBdLFxuICBcInZzdXBuRTtcIjpbMHgyYWNjLDB4ZmUwMF0sIFwidnN1cG5lO1wiOlsweDIyOGIsMHhmZTAwXSxcbiAgXCJ2emlnemFnO1wiOjB4Mjk5YSwgXCJ3Y2lyYztcIjoweDE3NSxcbiAgXCJ3ZWRiYXI7XCI6MHgyYTVmLCBcIndlZGdlO1wiOjB4MjIyNyxcbiAgXCJ3ZWRnZXE7XCI6MHgyMjU5LCBcIndlaWVycDtcIjoweDIxMTgsXG4gIFwid2ZyO1wiOlsweGQ4MzUsMHhkZDM0XSwgXCJ3b3BmO1wiOlsweGQ4MzUsMHhkZDY4XSxcbiAgXCJ3cDtcIjoweDIxMTgsIFwid3I7XCI6MHgyMjQwLFxuICBcIndyZWF0aDtcIjoweDIyNDAsIFwid3NjcjtcIjpbMHhkODM1LDB4ZGNjY10sXG4gIFwieGNhcDtcIjoweDIyYzIsIFwieGNpcmM7XCI6MHgyNWVmLFxuICBcInhjdXA7XCI6MHgyMmMzLCBcInhkdHJpO1wiOjB4MjViZCxcbiAgXCJ4ZnI7XCI6WzB4ZDgzNSwweGRkMzVdLCBcInhoQXJyO1wiOjB4MjdmYSxcbiAgXCJ4aGFycjtcIjoweDI3ZjcsIFwieGk7XCI6MHgzYmUsXG4gIFwieGxBcnI7XCI6MHgyN2Y4LCBcInhsYXJyO1wiOjB4MjdmNSxcbiAgXCJ4bWFwO1wiOjB4MjdmYywgXCJ4bmlzO1wiOjB4MjJmYixcbiAgXCJ4b2RvdDtcIjoweDJhMDAsIFwieG9wZjtcIjpbMHhkODM1LDB4ZGQ2OV0sXG4gIFwieG9wbHVzO1wiOjB4MmEwMSwgXCJ4b3RpbWU7XCI6MHgyYTAyLFxuICBcInhyQXJyO1wiOjB4MjdmOSwgXCJ4cmFycjtcIjoweDI3ZjYsXG4gIFwieHNjcjtcIjpbMHhkODM1LDB4ZGNjZF0sIFwieHNxY3VwO1wiOjB4MmEwNixcbiAgXCJ4dXBsdXM7XCI6MHgyYTA0LCBcInh1dHJpO1wiOjB4MjViMyxcbiAgXCJ4dmVlO1wiOjB4MjJjMSwgXCJ4d2VkZ2U7XCI6MHgyMmMwLFxuICBcInlhY3V0ZVwiOjB4ZmQsIFwieWFjdXRlO1wiOjB4ZmQsXG4gIFwieWFjeTtcIjoweDQ0ZiwgXCJ5Y2lyYztcIjoweDE3NyxcbiAgXCJ5Y3k7XCI6MHg0NGIsIFwieWVuXCI6MHhhNSxcbiAgXCJ5ZW47XCI6MHhhNSwgXCJ5ZnI7XCI6WzB4ZDgzNSwweGRkMzZdLFxuICBcInlpY3k7XCI6MHg0NTcsIFwieW9wZjtcIjpbMHhkODM1LDB4ZGQ2YV0sXG4gIFwieXNjcjtcIjpbMHhkODM1LDB4ZGNjZV0sIFwieXVjeTtcIjoweDQ0ZSxcbiAgXCJ5dW1sXCI6MHhmZiwgXCJ5dW1sO1wiOjB4ZmYsXG4gIFwiemFjdXRlO1wiOjB4MTdhLCBcInpjYXJvbjtcIjoweDE3ZSxcbiAgXCJ6Y3k7XCI6MHg0MzcsIFwiemRvdDtcIjoweDE3YyxcbiAgXCJ6ZWV0cmY7XCI6MHgyMTI4LCBcInpldGE7XCI6MHgzYjYsXG4gIFwiemZyO1wiOlsweGQ4MzUsMHhkZDM3XSwgXCJ6aGN5O1wiOjB4NDM2LFxuICBcInppZ3JhcnI7XCI6MHgyMWRkLCBcInpvcGY7XCI6WzB4ZDgzNSwweGRkNmJdLFxuICBcInpzY3I7XCI6WzB4ZDgzNSwweGRjY2ZdLCBcInp3ajtcIjoweDIwMGQsXG4gIFwienduajtcIjoweDIwMGMsXG59O1xuLypcbiAqIFRoaXMgcmVnZXhwIGlzIGdlbmVyYXRlZCB3aXRoIHRlc3QvdG9vbHMvdXBkYXRlLWVudGl0aWVzLmpzXG4gKiBJdCB3aWxsIGFsd2F5cyBtYXRjaCBhdCBsZWFzdCBvbmUgY2hhcmFjdGVyIC0tIGJ1dCBub3RlIHRoYXQgdGhlcmVcbiAqIGFyZSBubyBlbnRpdGllcyB3aG9zZSBuYW1lcyBhcmUgYSBzaW5nbGUgY2hhcmFjdGVyIGxvbmcuXG4gKi9cbnZhciBOQU1FRENIQVJSRUYgPSAvKEEoPzpFbGlnOz98TVA7P3xhY3V0ZTs/fGJyZXZlO3xjKD86aXJjOz98eTspfGZyO3xncmF2ZTs/fGxwaGE7fG1hY3I7fG5kO3xvKD86Z29uO3xwZjspfHBwbHlGdW5jdGlvbjt8cmluZzs/fHMoPzpjcjt8c2lnbjspfHRpbGRlOz98dW1sOz8pfEIoPzphKD86Y2tzbGFzaDt8cig/OnY7fHdlZDspKXxjeTt8ZSg/OmNhdXNlO3xybm91bGxpczt8dGE7KXxmcjt8b3BmO3xyZXZlO3xzY3I7fHVtcGVxOyl8Qyg/OkhjeTt8T1BZOz98YSg/OmN1dGU7fHAoPzo7fGl0YWxEaWZmZXJlbnRpYWxEOyl8eWxleXM7KXxjKD86YXJvbjt8ZWRpbDs/fGlyYzt8b25pbnQ7KXxkb3Q7fGUoPzpkaWxsYTt8bnRlckRvdDspfGZyO3xoaTt8aXJjbGUoPzpEb3Q7fE1pbnVzO3xQbHVzO3xUaW1lczspfGxvKD86Y2t3aXNlQ29udG91ckludGVncmFsO3xzZUN1cmx5KD86RG91YmxlUXVvdGU7fFF1b3RlOykpfG8oPzpsb24oPzo7fGU7KXxuKD86Z3J1ZW50O3xpbnQ7fHRvdXJJbnRlZ3JhbDspfHAoPzpmO3xyb2R1Y3Q7KXx1bnRlckNsb2Nrd2lzZUNvbnRvdXJJbnRlZ3JhbDspfHJvc3M7fHNjcjt8dXAoPzo7fENhcDspKXxEKD86RCg/Ojt8b3RyYWhkOyl8SmN5O3xTY3k7fFpjeTt8YSg/OmdnZXI7fHJyO3xzaHY7KXxjKD86YXJvbjt8eTspfGVsKD86O3x0YTspfGZyO3xpKD86YSg/OmNyaXRpY2FsKD86QWN1dGU7fERvKD86dDt8dWJsZUFjdXRlOyl8R3JhdmU7fFRpbGRlOyl8bW9uZDspfGZmZXJlbnRpYWxEOyl8byg/OnBmO3x0KD86O3xEb3Q7fEVxdWFsOyl8dWJsZSg/OkNvbnRvdXJJbnRlZ3JhbDt8RG8oPzp0O3x3bkFycm93Oyl8TCg/OmVmdCg/OkFycm93O3xSaWdodEFycm93O3xUZWU7KXxvbmcoPzpMZWZ0KD86QXJyb3c7fFJpZ2h0QXJyb3c7KXxSaWdodEFycm93OykpfFJpZ2h0KD86QXJyb3c7fFRlZTspfFVwKD86QXJyb3c7fERvd25BcnJvdzspfFZlcnRpY2FsQmFyOyl8d24oPzpBcnJvdyg/Ojt8QmFyO3xVcEFycm93Oyl8QnJldmU7fExlZnQoPzpSaWdodFZlY3Rvcjt8VGVlVmVjdG9yO3xWZWN0b3IoPzo7fEJhcjspKXxSaWdodCg/OlRlZVZlY3Rvcjt8VmVjdG9yKD86O3xCYXI7KSl8VGVlKD86O3xBcnJvdzspfGFycm93OykpfHMoPzpjcjt8dHJvazspKXxFKD86Tkc7fFRIOz98YWN1dGU7P3xjKD86YXJvbjt8aXJjOz98eTspfGRvdDt8ZnI7fGdyYXZlOz98bGVtZW50O3xtKD86YWNyO3xwdHkoPzpTbWFsbFNxdWFyZTt8VmVyeVNtYWxsU3F1YXJlOykpfG8oPzpnb247fHBmOyl8cHNpbG9uO3xxdSg/OmFsKD86O3xUaWxkZTspfGlsaWJyaXVtOyl8cyg/OmNyO3xpbTspfHRhO3x1bWw7P3x4KD86aXN0czt8cG9uZW50aWFsRTspKXxGKD86Y3k7fGZyO3xpbGxlZCg/OlNtYWxsU3F1YXJlO3xWZXJ5U21hbGxTcXVhcmU7KXxvKD86cGY7fHJBbGw7fHVyaWVydHJmOyl8c2NyOyl8Ryg/OkpjeTt8VDs/fGFtbWEoPzo7fGQ7KXxicmV2ZTt8Yyg/OmVkaWw7fGlyYzt8eTspfGRvdDt8ZnI7fGc7fG9wZjt8cmVhdGVyKD86RXF1YWwoPzo7fExlc3M7KXxGdWxsRXF1YWw7fEdyZWF0ZXI7fExlc3M7fFNsYW50RXF1YWw7fFRpbGRlOyl8c2NyO3x0Oyl8SCg/OkFSRGN5O3xhKD86Y2VrO3x0Oyl8Y2lyYzt8ZnI7fGlsYmVydFNwYWNlO3xvKD86cGY7fHJpem9udGFsTGluZTspfHMoPzpjcjt8dHJvazspfHVtcCg/OkRvd25IdW1wO3xFcXVhbDspKXxJKD86RWN5O3xKbGlnO3xPY3k7fGFjdXRlOz98Yyg/OmlyYzs/fHk7KXxkb3Q7fGZyO3xncmF2ZTs/fG0oPzo7fGEoPzpjcjt8Z2luYXJ5STspfHBsaWVzOyl8big/OnQoPzo7fGUoPzpncmFsO3xyc2VjdGlvbjspKXx2aXNpYmxlKD86Q29tbWE7fFRpbWVzOykpfG8oPzpnb247fHBmO3x0YTspfHNjcjt8dGlsZGU7fHUoPzprY3k7fG1sOz8pKXxKKD86Yyg/OmlyYzt8eTspfGZyO3xvcGY7fHMoPzpjcjt8ZXJjeTspfHVrY3k7KXxLKD86SGN5O3xKY3k7fGFwcGE7fGMoPzplZGlsO3x5Oyl8ZnI7fG9wZjt8c2NyOyl8TCg/OkpjeTt8VDs/fGEoPzpjdXRlO3xtYmRhO3xuZzt8cGxhY2V0cmY7fHJyOyl8Yyg/OmFyb247fGVkaWw7fHk7KXxlKD86ZnQoPzpBKD86bmdsZUJyYWNrZXQ7fHJyb3coPzo7fEJhcjt8UmlnaHRBcnJvdzspKXxDZWlsaW5nO3xEbyg/OnVibGVCcmFja2V0O3x3big/OlRlZVZlY3Rvcjt8VmVjdG9yKD86O3xCYXI7KSkpfEZsb29yO3xSaWdodCg/OkFycm93O3xWZWN0b3I7KXxUKD86ZWUoPzo7fEFycm93O3xWZWN0b3I7KXxyaWFuZ2xlKD86O3xCYXI7fEVxdWFsOykpfFVwKD86RG93blZlY3Rvcjt8VGVlVmVjdG9yO3xWZWN0b3IoPzo7fEJhcjspKXxWZWN0b3IoPzo7fEJhcjspfGFycm93O3xyaWdodGFycm93Oyl8c3MoPzpFcXVhbEdyZWF0ZXI7fEZ1bGxFcXVhbDt8R3JlYXRlcjt8TGVzczt8U2xhbnRFcXVhbDt8VGlsZGU7KSl8ZnI7fGwoPzo7fGVmdGFycm93Oyl8bWlkb3Q7fG8oPzpuZyg/OkxlZnQoPzpBcnJvdzt8UmlnaHRBcnJvdzspfFJpZ2h0QXJyb3c7fGxlZnQoPzphcnJvdzt8cmlnaHRhcnJvdzspfHJpZ2h0YXJyb3c7KXxwZjt8d2VyKD86TGVmdEFycm93O3xSaWdodEFycm93OykpfHMoPzpjcjt8aDt8dHJvazspfHQ7KXxNKD86YXA7fGN5O3xlKD86ZGl1bVNwYWNlO3xsbGludHJmOyl8ZnI7fGludXNQbHVzO3xvcGY7fHNjcjt8dTspfE4oPzpKY3k7fGFjdXRlO3xjKD86YXJvbjt8ZWRpbDt8eTspfGUoPzpnYXRpdmUoPzpNZWRpdW1TcGFjZTt8VGhpKD86Y2tTcGFjZTt8blNwYWNlOyl8VmVyeVRoaW5TcGFjZTspfHN0ZWQoPzpHcmVhdGVyR3JlYXRlcjt8TGVzc0xlc3M7KXx3TGluZTspfGZyO3xvKD86QnJlYWs7fG5CcmVha2luZ1NwYWNlO3xwZjt8dCg/Ojt8Qyg/Om9uZ3J1ZW50O3x1cENhcDspfERvdWJsZVZlcnRpY2FsQmFyO3xFKD86bGVtZW50O3xxdWFsKD86O3xUaWxkZTspfHhpc3RzOyl8R3JlYXRlcig/Ojt8RXF1YWw7fEZ1bGxFcXVhbDt8R3JlYXRlcjt8TGVzczt8U2xhbnRFcXVhbDt8VGlsZGU7KXxIdW1wKD86RG93bkh1bXA7fEVxdWFsOyl8TGUoPzpmdFRyaWFuZ2xlKD86O3xCYXI7fEVxdWFsOyl8c3MoPzo7fEVxdWFsO3xHcmVhdGVyO3xMZXNzO3xTbGFudEVxdWFsO3xUaWxkZTspKXxOZXN0ZWQoPzpHcmVhdGVyR3JlYXRlcjt8TGVzc0xlc3M7KXxQcmVjZWRlcyg/Ojt8RXF1YWw7fFNsYW50RXF1YWw7KXxSKD86ZXZlcnNlRWxlbWVudDt8aWdodFRyaWFuZ2xlKD86O3xCYXI7fEVxdWFsOykpfFMoPzpxdWFyZVN1KD86YnNldCg/Ojt8RXF1YWw7KXxwZXJzZXQoPzo7fEVxdWFsOykpfHUoPzpic2V0KD86O3xFcXVhbDspfGNjZWVkcyg/Ojt8RXF1YWw7fFNsYW50RXF1YWw7fFRpbGRlOyl8cGVyc2V0KD86O3xFcXVhbDspKSl8VGlsZGUoPzo7fEVxdWFsO3xGdWxsRXF1YWw7fFRpbGRlOyl8VmVydGljYWxCYXI7KSl8c2NyO3x0aWxkZTs/fHU7KXxPKD86RWxpZzt8YWN1dGU7P3xjKD86aXJjOz98eTspfGRibGFjO3xmcjt8Z3JhdmU7P3xtKD86YWNyO3xlZ2E7fGljcm9uOyl8b3BmO3xwZW5DdXJseSg/OkRvdWJsZVF1b3RlO3xRdW90ZTspfHI7fHMoPzpjcjt8bGFzaDs/KXx0aSg/OmxkZTs/fG1lczspfHVtbDs/fHZlcig/OkIoPzphcjt8cmFjKD86ZTt8a2V0OykpfFBhcmVudGhlc2lzOykpfFAoPzphcnRpYWxEO3xjeTt8ZnI7fGhpO3xpO3xsdXNNaW51czt8byg/OmluY2FyZXBsYW5lO3xwZjspfHIoPzo7fGVjZWRlcyg/Ojt8RXF1YWw7fFNsYW50RXF1YWw7fFRpbGRlOyl8aW1lO3xvKD86ZHVjdDt8cG9ydGlvbig/Ojt8YWw7KSkpfHMoPzpjcjt8aTspKXxRKD86VU9UOz98ZnI7fG9wZjt8c2NyOyl8Uig/OkJhcnI7fEVHOz98YSg/OmN1dGU7fG5nO3xycig/Ojt8dGw7KSl8Yyg/OmFyb247fGVkaWw7fHk7KXxlKD86O3x2ZXJzZSg/OkUoPzpsZW1lbnQ7fHF1aWxpYnJpdW07KXxVcEVxdWlsaWJyaXVtOykpfGZyO3xobzt8aWdodCg/OkEoPzpuZ2xlQnJhY2tldDt8cnJvdyg/Ojt8QmFyO3xMZWZ0QXJyb3c7KSl8Q2VpbGluZzt8RG8oPzp1YmxlQnJhY2tldDt8d24oPzpUZWVWZWN0b3I7fFZlY3Rvcig/Ojt8QmFyOykpKXxGbG9vcjt8VCg/OmVlKD86O3xBcnJvdzt8VmVjdG9yOyl8cmlhbmdsZSg/Ojt8QmFyO3xFcXVhbDspKXxVcCg/OkRvd25WZWN0b3I7fFRlZVZlY3Rvcjt8VmVjdG9yKD86O3xCYXI7KSl8VmVjdG9yKD86O3xCYXI7KXxhcnJvdzspfG8oPzpwZjt8dW5kSW1wbGllczspfHJpZ2h0YXJyb3c7fHMoPzpjcjt8aDspfHVsZURlbGF5ZWQ7KXxTKD86SCg/OkNIY3k7fGN5Oyl8T0ZUY3k7fGFjdXRlO3xjKD86O3xhcm9uO3xlZGlsO3xpcmM7fHk7KXxmcjt8aG9ydCg/OkRvd25BcnJvdzt8TGVmdEFycm93O3xSaWdodEFycm93O3xVcEFycm93Oyl8aWdtYTt8bWFsbENpcmNsZTt8b3BmO3xxKD86cnQ7fHVhcmUoPzo7fEludGVyc2VjdGlvbjt8U3UoPzpic2V0KD86O3xFcXVhbDspfHBlcnNldCg/Ojt8RXF1YWw7KSl8VW5pb247KSl8c2NyO3x0YXI7fHUoPzpiKD86O3xzZXQoPzo7fEVxdWFsOykpfGMoPzpjZWVkcyg/Ojt8RXF1YWw7fFNsYW50RXF1YWw7fFRpbGRlOyl8aFRoYXQ7KXxtO3xwKD86O3xlcnNldCg/Ojt8RXF1YWw7KXxzZXQ7KSkpfFQoPzpIT1JOOz98UkFERTt8Uyg/OkhjeTt8Y3k7KXxhKD86Yjt8dTspfGMoPzphcm9uO3xlZGlsO3x5Oyl8ZnI7fGgoPzplKD86cmVmb3JlO3x0YTspfGkoPzpja1NwYWNlO3xuU3BhY2U7KSl8aWxkZSg/Ojt8RXF1YWw7fEZ1bGxFcXVhbDt8VGlsZGU7KXxvcGY7fHJpcGxlRG90O3xzKD86Y3I7fHRyb2s7KSl8VSg/OmEoPzpjdXRlOz98cnIoPzo7fG9jaXI7KSl8YnIoPzpjeTt8ZXZlOyl8Yyg/OmlyYzs/fHk7KXxkYmxhYzt8ZnI7fGdyYXZlOz98bWFjcjt8big/OmRlcig/OkIoPzphcjt8cmFjKD86ZTt8a2V0OykpfFBhcmVudGhlc2lzOyl8aW9uKD86O3xQbHVzOykpfG8oPzpnb247fHBmOyl8cCg/OkFycm93KD86O3xCYXI7fERvd25BcnJvdzspfERvd25BcnJvdzt8RXF1aWxpYnJpdW07fFRlZSg/Ojt8QXJyb3c7KXxhcnJvdzt8ZG93bmFycm93O3xwZXIoPzpMZWZ0QXJyb3c7fFJpZ2h0QXJyb3c7KXxzaSg/Ojt8bG9uOykpfHJpbmc7fHNjcjt8dGlsZGU7fHVtbDs/KXxWKD86RGFzaDt8YmFyO3xjeTt8ZGFzaCg/Ojt8bDspfGUoPzplO3xyKD86YmFyO3x0KD86O3xpY2FsKD86QmFyO3xMaW5lO3xTZXBhcmF0b3I7fFRpbGRlOykpfHlUaGluU3BhY2U7KSl8ZnI7fG9wZjt8c2NyO3x2ZGFzaDspfFcoPzpjaXJjO3xlZGdlO3xmcjt8b3BmO3xzY3I7KXxYKD86ZnI7fGk7fG9wZjt8c2NyOyl8WSg/OkFjeTt8SWN5O3xVY3k7fGFjdXRlOz98Yyg/OmlyYzt8eTspfGZyO3xvcGY7fHNjcjt8dW1sOyl8Wig/OkhjeTt8YWN1dGU7fGMoPzphcm9uO3x5Oyl8ZG90O3xlKD86cm9XaWR0aFNwYWNlO3x0YTspfGZyO3xvcGY7fHNjcjspfGEoPzphY3V0ZTs/fGJyZXZlO3xjKD86O3xFO3xkO3xpcmM7P3x1dGU7P3x5Oyl8ZWxpZzs/fGYoPzo7fHI7KXxncmF2ZTs/fGwoPzplKD86ZnN5bTt8cGg7KXxwaGE7KXxtKD86YSg/OmNyO3xsZzspfHA7Pyl8big/OmQoPzo7fGFuZDt8ZDt8c2xvcGU7fHY7KXxnKD86O3xlO3xsZTt8bXNkKD86O3xhKD86YTt8Yjt8Yzt8ZDt8ZTt8Zjt8Zzt8aDspKXxydCg/Ojt8dmIoPzo7fGQ7KSl8cyg/OnBoO3x0Oyl8emFycjspKXxvKD86Z29uO3xwZjspfHAoPzo7fEU7fGFjaXI7fGU7fGlkO3xvczt8cHJveCg/Ojt8ZXE7KSl8cmluZzs/fHMoPzpjcjt8dDt8eW1wKD86O3xlcTspKXx0aWxkZTs/fHVtbDs/fHcoPzpjb25pbnQ7fGludDspKXxiKD86Tm90O3xhKD86Y2soPzpjb25nO3xlcHNpbG9uO3xwcmltZTt8c2ltKD86O3xlcTspKXxyKD86dmVlO3x3ZWQoPzo7fGdlOykpKXxicmsoPzo7fHRicms7KXxjKD86b25nO3x5Oyl8ZHF1bzt8ZSg/OmNhdXMoPzo7fGU7KXxtcHR5djt8cHNpO3xybm91O3x0KD86YTt8aDt8d2VlbjspKXxmcjt8aWcoPzpjKD86YXA7fGlyYzt8dXA7KXxvKD86ZG90O3xwbHVzO3x0aW1lczspfHMoPzpxY3VwO3x0YXI7KXx0cmlhbmdsZSg/OmRvd247fHVwOyl8dXBsdXM7fHZlZTt8d2VkZ2U7KXxrYXJvdzt8bCg/OmEoPzpjayg/OmxvemVuZ2U7fHNxdWFyZTt8dHJpYW5nbGUoPzo7fGRvd247fGxlZnQ7fHJpZ2h0OykpfG5rOyl8ayg/OjEoPzoyO3w0Oyl8MzQ7KXxvY2s7KXxuKD86ZSg/Ojt8cXVpdjspfG90Oyl8byg/OnBmO3x0KD86O3x0b207KXx3dGllO3x4KD86RCg/Okw7fFI7fGw7fHI7KXxIKD86O3xEO3xVO3xkO3x1Oyl8VSg/Okw7fFI7fGw7fHI7KXxWKD86O3xIO3xMO3xSO3xoO3xsO3xyOyl8Ym94O3xkKD86TDt8Ujt8bDt8cjspfGgoPzo7fEQ7fFU7fGQ7fHU7KXxtaW51czt8cGx1czt8dGltZXM7fHUoPzpMO3xSO3xsO3xyOyl8dig/Ojt8SDt8TDt8Ujt8aDt8bDt8cjspKSl8cHJpbWU7fHIoPzpldmU7fHZiYXI7Pyl8cyg/OmNyO3xlbWk7fGltKD86O3xlOyl8b2woPzo7fGI7fGhzdWI7KSl8dSg/OmxsKD86O3xldDspfG1wKD86O3xFO3xlKD86O3xxOykpKSl8Yyg/OmEoPzpjdXRlO3xwKD86O3xhbmQ7fGJyY3VwO3xjKD86YXA7fHVwOyl8ZG90O3xzOyl8cig/OmV0O3xvbjspKXxjKD86YSg/OnBzO3xyb247KXxlZGlsOz98aXJjO3x1cHMoPzo7fHNtOykpfGRvdDt8ZSg/OmRpbDs/fG1wdHl2O3xudCg/Ojt8ZXJkb3Q7fCkpfGZyO3xoKD86Y3k7fGVjayg/Ojt8bWFyazspfGk7KXxpcig/Ojt8RTt8Yyg/Ojt8ZXE7fGxlKD86YXJyb3coPzpsZWZ0O3xyaWdodDspfGQoPzpSO3xTO3xhc3Q7fGNpcmM7fGRhc2g7KSkpfGU7fGZuaW50O3xtaWQ7fHNjaXI7KXxsdWJzKD86O3x1aXQ7KXxvKD86bG9uKD86O3xlKD86O3xxOykpfG0oPzptYSg/Ojt8dDspfHAoPzo7fGZuO3xsZSg/Om1lbnQ7fHhlczspKSl8big/OmcoPzo7fGRvdDspfGludDspfHAoPzpmO3xyb2Q7fHkoPzo7fHNyO3wpKSl8cig/OmFycjt8b3NzOyl8cyg/OmNyO3x1KD86Yig/Ojt8ZTspfHAoPzo7fGU7KSkpfHRkb3Q7fHUoPzpkYXJyKD86bDt8cjspfGUoPzpwcjt8c2M7KXxsYXJyKD86O3xwOyl8cCg/Ojt8YnJjYXA7fGMoPzphcDt8dXA7KXxkb3Q7fG9yO3xzOyl8cig/OmFycig/Ojt8bTspfGx5KD86ZXEoPzpwcmVjO3xzdWNjOyl8dmVlO3x3ZWRnZTspfHJlbjs/fHZlYXJyb3coPzpsZWZ0O3xyaWdodDspKXx2ZWU7fHdlZDspfHcoPzpjb25pbnQ7fGludDspfHlsY3R5Oyl8ZCg/OkFycjt8SGFyO3xhKD86Z2dlcjt8bGV0aDt8cnI7fHNoKD86O3x2OykpfGIoPzprYXJvdzt8bGFjOyl8Yyg/OmFyb247fHk7KXxkKD86O3xhKD86Z2dlcjt8cnI7KXxvdHNlcTspfGUoPzpnOz98bHRhO3xtcHR5djspfGYoPzppc2h0O3xyOyl8aGFyKD86bDt8cjspfGkoPzphbSg/Ojt8b25kKD86O3xzdWl0Oyl8czspfGU7fGdhbW1hO3xzaW47fHYoPzo7fGlkZSg/Ojt8b250aW1lczt8KXxvbng7KSl8amN5O3xsYyg/Om9ybjt8cm9wOyl8byg/OmxsYXI7fHBmO3x0KD86O3xlcSg/Ojt8ZG90Oyl8bWludXM7fHBsdXM7fHNxdWFyZTspfHVibGViYXJ3ZWRnZTt8d24oPzphcnJvdzt8ZG93bmFycm93czt8aGFycG9vbig/OmxlZnQ7fHJpZ2h0OykpKXxyKD86Ymthcm93O3xjKD86b3JuO3xyb3A7KSl8cyg/OmMoPzpyO3x5Oyl8b2w7fHRyb2s7KXx0KD86ZG90O3xyaSg/Ojt8ZjspKXx1KD86YXJyO3xoYXI7KXx3YW5nbGU7fHooPzpjeTt8aWdyYXJyOykpfGUoPzpEKD86RG90O3xvdDspfGEoPzpjdXRlOz98c3RlcjspfGMoPzphcm9uO3xpcig/Ojt8Yzs/KXxvbG9uO3x5Oyl8ZG90O3xlO3xmKD86RG90O3xyOyl8Zyg/Ojt8cmF2ZTs/fHMoPzo7fGRvdDspKXxsKD86O3xpbnRlcnM7fGw7fHMoPzo7fGRvdDspKXxtKD86YWNyO3xwdHkoPzo7fHNldDt8djspfHNwKD86MSg/OjM7fDQ7KXw7KSl8big/Omc7fHNwOyl8byg/Omdvbjt8cGY7KXxwKD86YXIoPzo7fHNsOyl8bHVzO3xzaSg/Ojt8bG9uO3x2OykpfHEoPzpjKD86aXJjO3xvbG9uOyl8cyg/OmltO3xsYW50KD86Z3RyO3xsZXNzOykpfHUoPzphbHM7fGVzdDt8aXYoPzo7fEREOykpfHZwYXJzbDspfHIoPzpEb3Q7fGFycjspfHMoPzpjcjt8ZG90O3xpbTspfHQoPzphO3xoOz8pfHUoPzptbDs/fHJvOyl8eCg/OmNsO3xpc3Q7fHAoPzplY3RhdGlvbjt8b25lbnRpYWxlOykpKXxmKD86YWxsaW5nZG90c2VxO3xjeTt8ZW1hbGU7fGYoPzppbGlnO3xsKD86aWc7fGxpZzspfHI7KXxpbGlnO3xqbGlnO3xsKD86YXQ7fGxpZzt8dG5zOyl8bm9mO3xvKD86cGY7fHIoPzphbGw7fGsoPzo7fHY7KSkpfHBhcnRpbnQ7fHIoPzphKD86Yyg/OjEoPzoyOz98Mzt8NDs/fDU7fDY7fDg7KXwyKD86Mzt8NTspfDMoPzo0Oz98NTt8ODspfDQ1O3w1KD86Njt8ODspfDc4Oyl8c2w7KXxvd247KXxzY3I7KXxnKD86RSg/Ojt8bDspfGEoPzpjdXRlO3xtbWEoPzo7fGQ7KXxwOyl8YnJldmU7fGMoPzppcmM7fHk7KXxkb3Q7fGUoPzo7fGw7fHEoPzo7fHE7fHNsYW50Oyl8cyg/Ojt8Y2M7fGRvdCg/Ojt8byg/Ojt8bDspKXxsKD86O3xlczspKSl8ZnI7fGcoPzo7fGc7KXxpbWVsO3xqY3k7fGwoPzo7fEU7fGE7fGo7KXxuKD86RTt8YXAoPzo7fHByb3g7KXxlKD86O3xxKD86O3xxOykpfHNpbTspfG9wZjt8cmF2ZTt8cyg/OmNyO3xpbSg/Ojt8ZTt8bDspKXx0KD86O3xjKD86Yzt8aXI7KXxkb3Q7fGxQYXI7fHF1ZXN0O3xyKD86YSg/OnBwcm94O3xycjspfGRvdDt8ZXEoPzpsZXNzO3xxbGVzczspfGxlc3M7fHNpbTspfCl8dig/OmVydG5lcXE7fG5FOykpfGgoPzpBcnI7fGEoPzppcnNwO3xsZjt8bWlsdDt8cig/OmRjeTt8cig/Ojt8Y2lyO3x3OykpKXxiYXI7fGNpcmM7fGUoPzphcnRzKD86O3x1aXQ7KXxsbGlwO3xyY29uOyl8ZnI7fGtzKD86ZWFyb3c7fHdhcm93Oyl8byg/OmFycjt8bXRodDt8b2soPzpsZWZ0YXJyb3c7fHJpZ2h0YXJyb3c7KXxwZjt8cmJhcjspfHMoPzpjcjt8bGFzaDt8dHJvazspfHkoPzpidWxsO3xwaGVuOykpfGkoPzphY3V0ZTs/fGMoPzo7fGlyYzs/fHk7KXxlKD86Y3k7fHhjbDs/KXxmKD86Zjt8cjspfGdyYXZlOz98aSg/Ojt8aSg/OmludDt8bnQ7KXxuZmluO3xvdGE7KXxqbGlnO3xtKD86YSg/OmNyO3xnKD86ZTt8bGluZTt8cGFydDspfHRoOyl8b2Y7fHBlZDspfG4oPzo7fGNhcmU7fGZpbig/Ojt8dGllOyl8b2RvdDt8dCg/Ojt8Y2FsO3xlKD86Z2Vyczt8cmNhbDspfGxhcmhrO3xwcm9kOykpfG8oPzpjeTt8Z29uO3xwZjt8dGE7KXxwcm9kO3xxdWVzdDs/fHMoPzpjcjt8aW4oPzo7fEU7fGRvdDt8cyg/Ojt8djspfHY7KSl8dCg/Ojt8aWxkZTspfHUoPzprY3k7fG1sOz8pKXxqKD86Yyg/OmlyYzt8eTspfGZyO3xtYXRoO3xvcGY7fHMoPzpjcjt8ZXJjeTspfHVrY3k7KXxrKD86YXBwYSg/Ojt8djspfGMoPzplZGlsO3x5Oyl8ZnI7fGdyZWVuO3xoY3k7fGpjeTt8b3BmO3xzY3I7KXxsKD86QSg/OmFycjt8cnI7fHRhaWw7KXxCYXJyO3xFKD86O3xnOyl8SGFyO3xhKD86Y3V0ZTt8ZW1wdHl2O3xncmFuO3xtYmRhO3xuZyg/Ojt8ZDt8bGU7KXxwO3xxdW87P3xycig/Ojt8Yig/Ojt8ZnM7KXxmczt8aGs7fGxwO3xwbDt8c2ltO3x0bDspfHQoPzo7fGFpbDt8ZSg/Ojt8czspKSl8Yig/OmFycjt8YnJrO3xyKD86YWMoPzplO3xrOyl8ayg/OmU7fHNsKD86ZDt8dTspKSkpfGMoPzphcm9uO3xlKD86ZGlsO3xpbDspfHViO3x5Oyl8ZCg/OmNhO3xxdW8oPzo7fHI7KXxyKD86ZGhhcjt8dXNoYXI7KXxzaDspfGUoPzo7fGZ0KD86YXJyb3coPzo7fHRhaWw7KXxoYXJwb29uKD86ZG93bjt8dXA7KXxsZWZ0YXJyb3dzO3xyaWdodCg/OmFycm93KD86O3xzOyl8aGFycG9vbnM7fHNxdWlnYXJyb3c7KXx0aHJlZXRpbWVzOyl8Zzt8cSg/Ojt8cTt8c2xhbnQ7KXxzKD86O3xjYzt8ZG90KD86O3xvKD86O3xyOykpfGcoPzo7fGVzOyl8cyg/OmFwcHJveDt8ZG90O3xlcSg/Omd0cjt8cWd0cjspfGd0cjt8c2ltOykpKXxmKD86aXNodDt8bG9vcjt8cjspfGcoPzo7fEU7KXxoKD86YXIoPzpkO3x1KD86O3xsOykpfGJsazspfGpjeTt8bCg/Ojt8YXJyO3xjb3JuZXI7fGhhcmQ7fHRyaTspfG0oPzppZG90O3xvdXN0KD86O3xhY2hlOykpfG4oPzpFO3xhcCg/Ojt8cHJveDspfGUoPzo7fHEoPzo7fHE7KSl8c2ltOyl8byg/OmEoPzpuZzt8cnI7KXxicms7fG5nKD86bGVmdCg/OmFycm93O3xyaWdodGFycm93Oyl8bWFwc3RvO3xyaWdodGFycm93Oyl8b3BhcnJvdyg/OmxlZnQ7fHJpZ2h0Oyl8cCg/OmFyO3xmO3xsdXM7KXx0aW1lczt8dyg/OmFzdDt8YmFyOyl8eig/Ojt8ZW5nZTt8ZjspKXxwYXIoPzo7fGx0Oyl8cig/OmFycjt8Y29ybmVyO3xoYXIoPzo7fGQ7KXxtO3x0cmk7KXxzKD86YXF1bzt8Y3I7fGg7fGltKD86O3xlO3xnOyl8cSg/OmI7fHVvKD86O3xyOykpfHRyb2s7KXx0KD86O3xjKD86Yzt8aXI7KXxkb3Q7fGhyZWU7fGltZXM7fGxhcnI7fHF1ZXN0O3xyKD86UGFyO3xpKD86O3xlO3xmOykpfCl8dXIoPzpkc2hhcjt8dWhhcjspfHYoPzplcnRuZXFxO3xuRTspKXxtKD86RERvdDt8YSg/OmNyOz98bCg/OmU7fHQoPzo7fGVzZTspKXxwKD86O3xzdG8oPzo7fGRvd247fGxlZnQ7fHVwOykpfHJrZXI7KXxjKD86b21tYTt8eTspfGRhc2g7fGVhc3VyZWRhbmdsZTt8ZnI7fGhvO3xpKD86Y3JvOz98ZCg/Ojt8YXN0O3xjaXI7fGRvdDs/KXxudXMoPzo7fGI7fGQoPzo7fHU7KSkpfGwoPzpjcDt8ZHI7KXxucGx1czt8byg/OmRlbHM7fHBmOyl8cDt8cyg/OmNyO3x0cG9zOyl8dSg/Ojt8bHRpbWFwO3xtYXA7KSl8big/OkcoPzpnO3x0KD86O3x2OykpfEwoPzplZnQoPzphcnJvdzt8cmlnaHRhcnJvdzspfGw7fHQoPzo7fHY7KSl8UmlnaHRhcnJvdzt8Vig/OkRhc2g7fGRhc2g7KXxhKD86YmxhO3xjdXRlO3xuZzt8cCg/Ojt8RTt8aWQ7fG9zO3xwcm94Oyl8dHVyKD86O3xhbCg/Ojt8czspKSl8Yig/OnNwOz98dW1wKD86O3xlOykpfGMoPzphKD86cDt8cm9uOyl8ZWRpbDt8b25nKD86O3xkb3Q7KXx1cDt8eTspfGRhc2g7fGUoPzo7fEFycjt8YXIoPzpoazt8cig/Ojt8b3c7KSl8ZG90O3xxdWl2O3xzKD86ZWFyO3xpbTspfHhpc3QoPzo7fHM7KSl8ZnI7fGcoPzpFO3xlKD86O3xxKD86O3xxO3xzbGFudDspfHM7KXxzaW07fHQoPzo7fHI7KSl8aCg/OkFycjt8YXJyO3xwYXI7KXxpKD86O3xzKD86O3xkOyl8djspfGpjeTt8bCg/OkFycjt8RTt8YXJyO3xkcjt8ZSg/Ojt8ZnQoPzphcnJvdzt8cmlnaHRhcnJvdzspfHEoPzo7fHE7fHNsYW50Oyl8cyg/Ojt8czspKXxzaW07fHQoPzo7fHJpKD86O3xlOykpKXxtaWQ7fG8oPzpwZjt8dCg/Ojt8aW4oPzo7fEU7fGRvdDt8dig/OmE7fGI7fGM7KSl8bmkoPzo7fHYoPzphO3xiO3xjOykpfCkpfHAoPzphcig/Ojt8YWxsZWw7fHNsO3x0Oyl8b2xpbnQ7fHIoPzo7fGN1ZTt8ZSg/Ojt8Yyg/Ojt8ZXE7KSkpKXxyKD86QXJyO3xhcnIoPzo7fGM7fHc7KXxpZ2h0YXJyb3c7fHRyaSg/Ojt8ZTspKXxzKD86Yyg/Ojt8Y3VlO3xlO3xyOyl8aG9ydCg/Om1pZDt8cGFyYWxsZWw7KXxpbSg/Ojt8ZSg/Ojt8cTspKXxtaWQ7fHBhcjt8cXN1KD86YmU7fHBlOyl8dSg/OmIoPzo7fEU7fGU7fHNldCg/Ojt8ZXEoPzo7fHE7KSkpfGNjKD86O3xlcTspfHAoPzo7fEU7fGU7fHNldCg/Ojt8ZXEoPzo7fHE7KSkpKSl8dCg/OmdsO3xpbGRlOz98bGc7fHJpYW5nbGUoPzpsZWZ0KD86O3xlcTspfHJpZ2h0KD86O3xlcTspKSl8dSg/Ojt8bSg/Ojt8ZXJvO3xzcDspKXx2KD86RGFzaDt8SGFycjt8YXA7fGRhc2g7fGcoPzplO3x0Oyl8aW5maW47fGwoPzpBcnI7fGU7fHQoPzo7fHJpZTspKXxyKD86QXJyO3x0cmllOyl8c2ltOyl8dyg/OkFycjt8YXIoPzpoazt8cig/Ojt8b3c7KSl8bmVhcjspKXxvKD86Uzt8YSg/OmN1dGU7P3xzdDspfGMoPzppcig/Ojt8Yzs/KXx5Oyl8ZCg/OmFzaDt8YmxhYzt8aXY7fG90O3xzb2xkOyl8ZWxpZzt8Zig/OmNpcjt8cjspfGcoPzpvbjt8cmF2ZTs/fHQ7KXxoKD86YmFyO3xtOyl8aW50O3xsKD86YXJyO3xjKD86aXI7fHJvc3M7KXxpbmU7fHQ7KXxtKD86YWNyO3xlZ2E7fGkoPzpjcm9uO3xkO3xudXM7KSl8b3BmO3xwKD86YXI7fGVycDt8bHVzOyl8cig/Ojt8YXJyO3xkKD86O3xlcig/Ojt8b2Y7KXxmOz98bTs/KXxpZ29mO3xvcjt8c2xvcGU7fHY7KXxzKD86Y3I7fGxhc2g7P3xvbDspfHRpKD86bGRlOz98bWVzKD86O3xhczspKXx1bWw7P3x2YmFyOyl8cCg/OmFyKD86O3xhKD86O3xsbGVsO3wpfHMoPzppbTt8bDspfHQ7KXxjeTt8ZXIoPzpjbnQ7fGlvZDt8bWlsO3xwO3x0ZW5rOyl8ZnI7fGgoPzppKD86O3x2Oyl8bW1hdDt8b25lOyl8aSg/Ojt8dGNoZm9yazt8djspfGwoPzphbig/OmNrKD86O3xoOyl8a3Y7KXx1cyg/Ojt8YWNpcjt8Yjt8Y2lyO3xkKD86bzt8dTspfGU7fG1uOz98c2ltO3x0d287KSl8bTt8byg/OmludGludDt8cGY7fHVuZDs/KXxyKD86O3xFO3xhcDt8Y3VlO3xlKD86O3xjKD86O3xhcHByb3g7fGN1cmx5ZXE7fGVxO3xuKD86YXBwcm94O3xlcXE7fHNpbTspfHNpbTspKXxpbWUoPzo7fHM7KXxuKD86RTt8YXA7fHNpbTspfG8oPzpkO3xmKD86YWxhcjt8bGluZTt8c3VyZjspfHAoPzo7fHRvOykpfHNpbTt8dXJlbDspfHMoPzpjcjt8aTspfHVuY3NwOyl8cSg/OmZyO3xpbnQ7fG9wZjt8cHJpbWU7fHNjcjt8dSg/OmF0KD86ZXJuaW9uczt8aW50Oyl8ZXN0KD86O3xlcTspfG90Oz8pKXxyKD86QSg/OmFycjt8cnI7fHRhaWw7KXxCYXJyO3xIYXI7fGEoPzpjKD86ZTt8dXRlOyl8ZGljO3xlbXB0eXY7fG5nKD86O3xkO3xlO3xsZTspfHF1bzs/fHJyKD86O3xhcDt8Yig/Ojt8ZnM7KXxjO3xmczt8aGs7fGxwO3xwbDt8c2ltO3x0bDt8dzspfHQoPzphaWw7fGlvKD86O3xuYWxzOykpKXxiKD86YXJyO3xicms7fHIoPzphYyg/OmU7fGs7KXxrKD86ZTt8c2woPzpkO3x1OykpKSl8Yyg/OmFyb247fGUoPzpkaWw7fGlsOyl8dWI7fHk7KXxkKD86Y2E7fGxkaGFyO3xxdW8oPzo7fHI7KXxzaDspfGUoPzphbCg/Ojt8aW5lO3xwYXJ0O3xzOyl8Y3Q7fGc7Pyl8Zig/OmlzaHQ7fGxvb3I7fHI7KXxoKD86YXIoPzpkO3x1KD86O3xsOykpfG8oPzo7fHY7KSl8aSg/OmdodCg/OmFycm93KD86O3x0YWlsOyl8aGFycG9vbig/OmRvd247fHVwOyl8bGVmdCg/OmFycm93czt8aGFycG9vbnM7KXxyaWdodGFycm93czt8c3F1aWdhcnJvdzt8dGhyZWV0aW1lczspfG5nO3xzaW5nZG90c2VxOyl8bCg/OmFycjt8aGFyO3xtOyl8bW91c3QoPzo7fGFjaGU7KXxubWlkO3xvKD86YSg/Om5nO3xycjspfGJyazt8cCg/OmFyO3xmO3xsdXM7KXx0aW1lczspfHAoPzphcig/Ojt8Z3Q7KXxwb2xpbnQ7KXxyYXJyO3xzKD86YXF1bzt8Y3I7fGg7fHEoPzpiO3x1byg/Ojt8cjspKSl8dCg/OmhyZWU7fGltZXM7fHJpKD86O3xlO3xmO3xsdHJpOykpfHVsdWhhcjt8eDspfHMoPzphY3V0ZTt8YnF1bzt8Yyg/Ojt8RTt8YSg/OnA7fHJvbjspfGN1ZTt8ZSg/Ojt8ZGlsOyl8aXJjO3xuKD86RTt8YXA7fHNpbTspfHBvbGludDt8c2ltO3x5Oyl8ZG90KD86O3xiO3xlOyl8ZSg/OkFycjt8YXIoPzpoazt8cig/Ojt8b3c7KSl8Y3Q7P3xtaTt8c3dhcjt8dG0oPzppbnVzO3xuOyl8eHQ7KXxmcig/Ojt8b3duOyl8aCg/OmFycDt8Yyg/OmhjeTt8eTspfG9ydCg/Om1pZDt8cGFyYWxsZWw7KXx5Oz8pfGkoPzpnbWEoPzo7fGY7fHY7KXxtKD86O3xkb3Q7fGUoPzo7fHE7KXxnKD86O3xFOyl8bCg/Ojt8RTspfG5lO3xwbHVzO3xyYXJyOykpfGxhcnI7fG0oPzphKD86bGxzZXRtaW51czt8c2hwOyl8ZXBhcnNsO3xpKD86ZDt8bGU7KXx0KD86O3xlKD86O3xzOykpKXxvKD86ZnRjeTt8bCg/Ojt8Yig/Ojt8YXI7KSl8cGY7KXxwYSg/OmRlcyg/Ojt8dWl0Oyl8cjspfHEoPzpjKD86YXAoPzo7fHM7KXx1cCg/Ojt8czspKXxzdSg/OmIoPzo7fGU7fHNldCg/Ojt8ZXE7KSl8cCg/Ojt8ZTt8c2V0KD86O3xlcTspKSl8dSg/Ojt8YXIoPzplO3xmOyl8ZjspKXxyYXJyO3xzKD86Y3I7fGV0bW47fG1pbGU7fHRhcmY7KXx0KD86YXIoPzo7fGY7KXxyKD86YWlnaHQoPzplcHNpbG9uO3xwaGk7KXxuczspKXx1KD86Yig/Ojt8RTt8ZG90O3xlKD86O3xkb3Q7KXxtdWx0O3xuKD86RTt8ZTspfHBsdXM7fHJhcnI7fHMoPzpldCg/Ojt8ZXEoPzo7fHE7KXxuZXEoPzo7fHE7KSl8aW07fHUoPzpiO3xwOykpKXxjYyg/Ojt8YXBwcm94O3xjdXJseWVxO3xlcTt8big/OmFwcHJveDt8ZXFxO3xzaW07KXxzaW07KXxtO3xuZzt8cCg/OjE7P3wyOz98Mzs/fDt8RTt8ZCg/Om90O3xzdWI7KXxlKD86O3xkb3Q7KXxocyg/Om9sO3x1YjspfGxhcnI7fG11bHQ7fG4oPzpFO3xlOyl8cGx1czt8cyg/OmV0KD86O3xlcSg/Ojt8cTspfG5lcSg/Ojt8cTspKXxpbTt8dSg/OmI7fHA7KSkpKXx3KD86QXJyO3xhcig/OmhrO3xyKD86O3xvdzspKXxud2FyOyl8emxpZzs/KXx0KD86YSg/OnJnZXQ7fHU7KXxicms7fGMoPzphcm9uO3xlZGlsO3x5Oyl8ZG90O3xlbHJlYzt8ZnI7fGgoPzplKD86cmUoPzo0O3xmb3JlOyl8dGEoPzo7fHN5bTt8djspKXxpKD86Y2soPzphcHByb3g7fHNpbTspfG5zcDspfGsoPzphcDt8c2ltOyl8b3JuOz8pfGkoPzpsZGU7fG1lcyg/Ojt8Yig/Ojt8YXI7KXxkO3wpfG50Oyl8byg/OmVhO3xwKD86O3xib3Q7fGNpcjt8Zig/Ojt8b3JrOykpfHNhOyl8cHJpbWU7fHIoPzphZGU7fGkoPzphbmdsZSg/Ojt8ZG93bjt8bGVmdCg/Ojt8ZXE7KXxxO3xyaWdodCg/Ojt8ZXE7KSl8ZG90O3xlO3xtaW51czt8cGx1czt8c2I7fHRpbWU7KXxwZXppdW07KXxzKD86Yyg/OnI7fHk7KXxoY3k7fHRyb2s7KXx3KD86aXh0O3xvaGVhZCg/OmxlZnRhcnJvdzt8cmlnaHRhcnJvdzspKSl8dSg/OkFycjt8SGFyO3xhKD86Y3V0ZTs/fHJyOyl8YnIoPzpjeTt8ZXZlOyl8Yyg/OmlyYzs/fHk7KXxkKD86YXJyO3xibGFjO3xoYXI7KXxmKD86aXNodDt8cjspfGdyYXZlOz98aCg/OmFyKD86bDt8cjspfGJsazspfGwoPzpjKD86b3JuKD86O3xlcjspfHJvcDspfHRyaTspfG0oPzphY3I7fGw7Pyl8byg/Omdvbjt8cGY7KXxwKD86YXJyb3c7fGRvd25hcnJvdzt8aGFycG9vbig/OmxlZnQ7fHJpZ2h0Oyl8bHVzO3xzaSg/Ojt8aDt8bG9uOyl8dXBhcnJvd3M7KXxyKD86Yyg/Om9ybig/Ojt8ZXI7KXxyb3A7KXxpbmc7fHRyaTspfHNjcjt8dCg/OmRvdDt8aWxkZTt8cmkoPzo7fGY7KSl8dSg/OmFycjt8bWw7Pyl8d2FuZ2xlOyl8dig/OkFycjt8QmFyKD86O3x2Oyl8RGFzaDt8YSg/Om5ncnQ7fHIoPzplcHNpbG9uO3xrYXBwYTt8bm90aGluZzt8cCg/OmhpO3xpO3xyb3B0bzspfHIoPzo7fGhvOyl8cyg/OmlnbWE7fHUoPzpic2V0bmVxKD86O3xxOyl8cHNldG5lcSg/Ojt8cTspKSl8dCg/OmhldGE7fHJpYW5nbGUoPzpsZWZ0O3xyaWdodDspKSkpfGN5O3xkYXNoO3xlKD86ZSg/Ojt8YmFyO3xlcTspfGxsaXA7fHIoPzpiYXI7fHQ7KSl8ZnI7fGx0cmk7fG5zdSg/OmI7fHA7KXxvcGY7fHByb3A7fHJ0cmk7fHMoPzpjcjt8dSg/OmJuKD86RTt8ZTspfHBuKD86RTt8ZTspKSl8emlnemFnOyl8dyg/OmNpcmM7fGUoPzpkKD86YmFyO3xnZSg/Ojt8cTspKXxpZXJwOyl8ZnI7fG9wZjt8cDt8cig/Ojt8ZWF0aDspfHNjcjspfHgoPzpjKD86YXA7fGlyYzt8dXA7KXxkdHJpO3xmcjt8aCg/OkFycjt8YXJyOyl8aTt8bCg/OkFycjt8YXJyOyl8bWFwO3xuaXM7fG8oPzpkb3Q7fHAoPzpmO3xsdXM7KXx0aW1lOyl8cig/OkFycjt8YXJyOyl8cyg/OmNyO3xxY3VwOyl8dSg/OnBsdXM7fHRyaTspfHZlZTt8d2VkZ2U7KXx5KD86YWMoPzp1dGU7P3x5Oyl8Yyg/OmlyYzt8eTspfGVuOz98ZnI7fGljeTt8b3BmO3xzY3I7fHUoPzpjeTt8bWw7PykpfHooPzphY3V0ZTt8Yyg/OmFyb247fHk7KXxkb3Q7fGUoPzpldHJmO3x0YTspfGZyO3xoY3k7fGlncmFycjt8b3BmO3xzY3I7fHcoPzpqO3xuajspKSl8W1xcc1xcU10vZztcblxudmFyIE5BTUVEQ0hBUlJFRl9NQVhMRU4gPSAzMjtcblxuLy8gUmVndWxhciBleHByZXNzaW9uIGNvbnN0YW50cyB1c2VkIGJ5IHRoZSB0b2tlbml6ZXIgYW5kIHBhcnNlclxuXG4vLyBOb3RlIHRoYXQgXFxyIGlzIGluY2x1ZGVkIGluIGFsbCBvZiB0aGVzZSByZWdleHBzIGJlY2F1c2UgaXQgd2lsbCBuZWVkXG4vLyB0byBiZSBjb252ZXJ0ZWQgdG8gTEYgYnkgdGhlIHNjYW5DaGFycygpIGZ1bmN0aW9uLlxudmFyIERCTFFVT1RFQVRUUlZBTCA9IC9bXlxcclwiJlxcdTAwMDBdKy9nO1xudmFyIFNJTkdMRVFVT1RFQVRUUlZBTCA9IC9bXlxccicmXFx1MDAwMF0rL2c7XG52YXIgVU5RVU9URURBVFRSVkFMID0gL1teXFxyXFx0XFxuXFxmICY+XFx1MDAwMF0rL2c7XG52YXIgVEFHTkFNRSA9IC9bXlxcclxcdFxcblxcZiBcXC8+QS1aXFx1MDAwMF0rL2c7XG52YXIgQVRUUk5BTUUgPSAvW15cXHJcXHRcXG5cXGYgXFwvPT5BLVpcXHUwMDAwXSsvZztcblxudmFyIENEQVRBVEVYVCA9IC9bXlxcXVxcclxcdTAwMDBcXHVmZmZmXSovZztcbnZhciBEQVRBVEVYVCA9IC9bXiY8XFxyXFx1MDAwMFxcdWZmZmZdKi9nO1xudmFyIFJBV1RFWFQgPSAvW148XFxyXFx1MDAwMFxcdWZmZmZdKi9nO1xudmFyIFBMQUlOVEVYVCA9IC9bXlxcclxcdTAwMDBcXHVmZmZmXSovZztcbi8vIFNpbmNlIHdlIGRvbid0IGhhdmUgdGhlICdzdGlja3kgdGFnJywgYWRkICd8LicgdG8gdGhlIGVuZCBvZiBTSU1QTEVUQUdcbi8vIGFuZCBTSU1QTEVBVFRSIHNvIHRoYXQgd2UgYXJlIGd1YXJhbnRlZWQgdG8gYWx3YXlzIG1hdGNoLiAgVGhpcyBwcmV2ZW50c1xuLy8gdXMgZnJvbSBzY2FubmluZyBwYXN0IHRoZSBsYXN0SW5kZXggc2V0LiAoTm90ZSB0aGF0IHRoZSBkZXNpcmVkIG1hdGNoZXNcbi8vIGFyZSBhbHdheXMgZ3JlYXRlciB0aGFuIDEgY2hhciBsb25nLCBzbyBsb25nZXN0LW1hdGNoIHdpbGwgZW5zdXJlIHRoYXQgLlxuLy8gaXMgbm90IG1hdGNoZWQgdW5sZXNzIHRoZSBkZXNpcmVkIG1hdGNoIGZhaWxzLilcbnZhciBTSU1QTEVUQUcgPSAvKD86KFxcLyk/KFthLXpdKyk+KXxbXFxzXFxTXS9nO1xudmFyIFNJTVBMRUFUVFIgPSAvKD86KFstYS16XSspWyBcXHRcXG5cXGZdKj1bIFxcdFxcblxcZl0qKCdbXicmXFxyXFx1MDAwMF0qJ3xcIlteXCImXFxyXFx1MDAwMF0qXCJ8W15cXHRcXG5cXHJcXGYgXCImJ1xcdTAwMDA+XVteJj4gXFx0XFxuXFxyXFxmXFx1MDAwMF0qWyBcXHRcXG5cXGZdKSl8W1xcc1xcU10vZztcblxudmFyIE5PTldTID0gL1teXFx4MDlcXHgwQVxceDBDXFx4MERcXHgyMF0vO1xudmFyIEFMTE5PTldTID0gL1teXFx4MDlcXHgwQVxceDBDXFx4MERcXHgyMF0vZzsgLy8gbGlrZSBhYm92ZSwgd2l0aCBnIGZsYWdcbnZhciBOT05XU05PTk5VTCA9IC9bXlxceDAwXFx4MDlcXHgwQVxceDBDXFx4MERcXHgyMF0vOyAvLyBkb24ndCBhbGxvdyBOVUwgZWl0aGVyXG52YXIgTEVBRElOR1dTID0gL15bXFx4MDlcXHgwQVxceDBDXFx4MERcXHgyMF0rLztcbnZhciBOVUxDSEFSUyA9IC9cXHgwMC9nO1xuXG4vKioqXG4gKiBUaGVzZSBhcmUgdXRpbGl0eSBmdW5jdGlvbnMgdGhhdCBkb24ndCB1c2UgYW55IG9mIHRoZSBwYXJzZXInc1xuICogaW50ZXJuYWwgc3RhdGUuXG4gKi9cbmZ1bmN0aW9uIGJ1ZjJzdHIoYnVmKSB7XG4gIHZhciBDSFVOS1NJWkU9MTYzODQ7XG4gIGlmIChidWYubGVuZ3RoIDwgQ0hVTktTSVpFKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBidWYpO1xuICB9XG4gIC8vIHNwZWNpYWwgY2FzZSBmb3IgbGFyZ2Ugc3RyaW5ncywgdG8gYXZvaWQgYnVzdGluZyB0aGUgc3RhY2suXG4gIHZhciByZXN1bHQgPSAnJztcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBidWYubGVuZ3RoOyBpICs9IENIVU5LU0laRSkge1xuICAgIHJlc3VsdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgYnVmLnNsaWNlKGksIGkrQ0hVTktTSVpFKSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gc3RyMmJ1ZihzKSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgZm9yICh2YXIgaT0wOyBpPHMubGVuZ3RoOyBpKyspIHtcbiAgICByZXN1bHRbaV0gPSBzLmNoYXJDb2RlQXQoaSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLy8gRGV0ZXJtaW5lIHdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgYSBtZW1iZXIgb2YgdGhlIHNldC5cbi8vIFRoZSBzZXQgaXMgYW4gb2JqZWN0IHRoYXQgbWFwcyBuYW1lc3BhY2VzIHRvIG9iamVjdHMuIFRoZSBvYmplY3RzXG4vLyB0aGVuIG1hcCBsb2NhbCB0YWduYW1lcyB0byB0aGUgdmFsdWUgdHJ1ZSBpZiB0aGF0IHRhZyBpcyBwYXJ0IG9mIHRoZSBzZXRcbmZ1bmN0aW9uIGlzQShlbHQsIHNldCkge1xuICBpZiAodHlwZW9mIHNldCA9PT0gJ3N0cmluZycpIHtcbiAgICAvLyBjb252ZW5pZW5jZSBjYXNlIGZvciB0ZXN0aW5nIGEgcGFydGljdWxhciBIVE1MIGVsZW1lbnRcbiAgICByZXR1cm4gZWx0Lm5hbWVzcGFjZVVSSSA9PT0gTkFNRVNQQUNFLkhUTUwgJiZcbiAgICAgIGVsdC5sb2NhbE5hbWUgPT09IHNldDtcbiAgfVxuICB2YXIgdGFnbmFtZXMgPSBzZXRbZWx0Lm5hbWVzcGFjZVVSSV07XG4gIHJldHVybiB0YWduYW1lcyAmJiB0YWduYW1lc1tlbHQubG9jYWxOYW1lXTtcbn1cblxuZnVuY3Rpb24gaXNNYXRobWxUZXh0SW50ZWdyYXRpb25Qb2ludChuKSB7XG4gIHJldHVybiBpc0EobiwgbWF0aG1sVGV4dEludGVncmF0aW9uUG9pbnRTZXQpO1xufVxuXG5mdW5jdGlvbiBpc0hUTUxJbnRlZ3JhdGlvblBvaW50KG4pIHtcbiAgaWYgKGlzQShuLCBodG1sSW50ZWdyYXRpb25Qb2ludFNldCkpIHJldHVybiB0cnVlO1xuICBpZiAobi5uYW1lc3BhY2VVUkkgPT09IE5BTUVTUEFDRS5NQVRITUwgJiZcbiAgICBuLmxvY2FsTmFtZSA9PT0gXCJhbm5vdGF0aW9uLXhtbFwiKSB7XG4gICAgdmFyIGVuY29kaW5nID0gbi5nZXRBdHRyaWJ1dGUoXCJlbmNvZGluZ1wiKTtcbiAgICBpZiAoZW5jb2RpbmcpIGVuY29kaW5nID0gZW5jb2RpbmcudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAoZW5jb2RpbmcgPT09IFwidGV4dC9odG1sXCIgfHxcbiAgICAgIGVuY29kaW5nID09PSBcImFwcGxpY2F0aW9uL3hodG1sK3htbFwiKVxuICAgICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBhZGp1c3RTVkdUYWdOYW1lKG5hbWUpIHtcbiAgaWYgKG5hbWUgaW4gc3ZnVGFnTmFtZUFkanVzdG1lbnRzKVxuICAgIHJldHVybiBzdmdUYWdOYW1lQWRqdXN0bWVudHNbbmFtZV07XG4gIGVsc2VcbiAgICByZXR1cm4gbmFtZTtcbn1cblxuZnVuY3Rpb24gYWRqdXN0U1ZHQXR0cmlidXRlcyhhdHRycykge1xuICBmb3IodmFyIGkgPSAwLCBuID0gYXR0cnMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgaWYgKGF0dHJzW2ldWzBdIGluIHN2Z0F0dHJBZGp1c3RtZW50cykge1xuICAgICAgYXR0cnNbaV1bMF0gPSBzdmdBdHRyQWRqdXN0bWVudHNbYXR0cnNbaV1bMF1dO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhZGp1c3RNYXRoTUxBdHRyaWJ1dGVzKGF0dHJzKSB7XG4gIGZvcih2YXIgaSA9IDAsIG4gPSBhdHRycy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICBpZiAoYXR0cnNbaV1bMF0gPT09IFwiZGVmaW5pdGlvbnVybFwiKSB7XG4gICAgICBhdHRyc1tpXVswXSA9IFwiZGVmaW5pdGlvblVSTFwiO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFkanVzdEZvcmVpZ25BdHRyaWJ1dGVzKGF0dHJzKSB7XG4gIGZvcih2YXIgaSA9IDAsIG4gPSBhdHRycy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICBpZiAoYXR0cnNbaV1bMF0gaW4gZm9yZWlnbkF0dHJpYnV0ZXMpIHtcbiAgICAgIC8vIEF0dHJpYnV0ZXMgd2l0aCBuYW1lc3BhY2VzIGdldCBhIDNyZCBlbGVtZW50OlxuICAgICAgLy8gW1FuYW1lLCB2YWx1ZSwgbmFtZXNwYWNlXVxuICAgICAgYXR0cnNbaV0ucHVzaChmb3JlaWduQXR0cmlidXRlc1thdHRyc1tpXVswXV0pO1xuICAgIH1cbiAgfVxufVxuXG4vLyBGb3IgZWFjaCBhdHRyaWJ1dGUgaW4gYXR0cnMsIGlmIGVsdCBkb2Vzbid0IGhhdmUgYW4gYXR0cmlidXRlXG4vLyBieSB0aGF0IG5hbWUsIGFkZCB0aGUgYXR0cmlidXRlIHRvIGVsdFxuLy8gWFhYOiBJJ20gaWdub3JpbmcgbmFtZXNwYWNlcyBmb3Igbm93XG5mdW5jdGlvbiB0cmFuc2ZlckF0dHJpYnV0ZXMoYXR0cnMsIGVsdCkge1xuICBmb3IodmFyIGkgPSAwLCBuID0gYXR0cnMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgdmFyIG5hbWUgPSBhdHRyc1tpXVswXSwgdmFsdWUgPSBhdHRyc1tpXVsxXTtcbiAgICBpZiAoZWx0Lmhhc0F0dHJpYnV0ZShuYW1lKSkgY29udGludWU7XG4gICAgZWx0Ll9zZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpO1xuICB9XG59XG5cbi8qKipcbiAqIFRoZSBFbGVtZW50U3RhY2sgY2xhc3NcbiAqL1xuSFRNTFBhcnNlci5FbGVtZW50U3RhY2sgPSBmdW5jdGlvbiBFbGVtZW50U3RhY2soKSB7XG4gIHRoaXMuZWxlbWVudHMgPSBbXTtcbiAgdGhpcy50b3AgPSBudWxsOyAvLyBzdGFjay50b3AgaXMgdGhlIFwiY3VycmVudCBub2RlXCIgaW4gdGhlIHNwZWNcbn07XG5cbi8qXG4vLyBUaGlzIGlzIGZvciBkZWJ1Z2dpbmcgb25seVxuSFRNTFBhcnNlci5FbGVtZW50U3RhY2sucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oZSkge1xuICByZXR1cm4gXCJTVEFDSzogXCIgK1xuICB0aGlzLmVsZW1lbnRzLm1hcChmdW5jdGlvbihlKSB7cmV0dXJuIGUubG9jYWxOYW1lO30pLmpvaW4oXCItXCIpO1xufVxuKi9cblxuSFRNTFBhcnNlci5FbGVtZW50U3RhY2sucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbihlKSB7XG4gIHRoaXMuZWxlbWVudHMucHVzaChlKTtcbiAgdGhpcy50b3AgPSBlO1xufTtcblxuSFRNTFBhcnNlci5FbGVtZW50U3RhY2sucHJvdG90eXBlLnBvcCA9IGZ1bmN0aW9uKGUpIHtcbiAgdGhpcy5lbGVtZW50cy5wb3AoKTtcbiAgdGhpcy50b3AgPSB0aGlzLmVsZW1lbnRzW3RoaXMuZWxlbWVudHMubGVuZ3RoLTFdO1xufTtcblxuLy8gUG9wIGVsZW1lbnRzIG9mZiB0aGUgc3RhY2sgdXAgdG8gYW5kIGluY2x1ZGluZyB0aGUgZmlyc3Rcbi8vIGVsZW1lbnQgd2l0aCB0aGUgc3BlY2lmaWVkIChIVE1MKSB0YWduYW1lXG5IVE1MUGFyc2VyLkVsZW1lbnRTdGFjay5wcm90b3R5cGUucG9wVGFnID0gZnVuY3Rpb24odGFnKSB7XG4gIGZvcih2YXIgaSA9IHRoaXMuZWxlbWVudHMubGVuZ3RoLTE7IGkgPiAwOyBpLS0pIHtcbiAgICB2YXIgZSA9IHRoaXMuZWxlbWVudHNbaV07XG4gICAgaWYgKGlzQShlLCB0YWcpKSBicmVhaztcbiAgfVxuICB0aGlzLmVsZW1lbnRzLmxlbmd0aCA9IGk7XG4gIHRoaXMudG9wID0gdGhpcy5lbGVtZW50c1tpLTFdO1xufTtcblxuLy8gUG9wIGVsZW1lbnRzIG9mZiB0aGUgc3RhY2sgdXAgdG8gYW5kIGluY2x1ZGluZyB0aGUgZmlyc3Rcbi8vIGVsZW1lbnQgdGhhdCBpcyBhbiBpbnN0YW5jZSBvZiB0aGUgc3BlY2lmaWVkIHR5cGVcbkhUTUxQYXJzZXIuRWxlbWVudFN0YWNrLnByb3RvdHlwZS5wb3BFbGVtZW50VHlwZSA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgZm9yKHZhciBpID0gdGhpcy5lbGVtZW50cy5sZW5ndGgtMTsgaSA+IDA7IGktLSkge1xuICAgIGlmICh0aGlzLmVsZW1lbnRzW2ldIGluc3RhbmNlb2YgdHlwZSkgYnJlYWs7XG4gIH1cbiAgdGhpcy5lbGVtZW50cy5sZW5ndGggPSBpO1xuICB0aGlzLnRvcCA9IHRoaXMuZWxlbWVudHNbaS0xXTtcbn07XG5cbi8vIFBvcCBlbGVtZW50cyBvZmYgdGhlIHN0YWNrIHVwIHRvIGFuZCBpbmNsdWRpbmcgdGhlIGVsZW1lbnQgZS5cbi8vIE5vdGUgdGhhdCB0aGlzIGlzIHZlcnkgZGlmZmVyZW50IGZyb20gcmVtb3ZlRWxlbWVudCgpXG4vLyBUaGlzIHJlcXVpcmVzIHRoYXQgZSBpcyBvbiB0aGUgc3RhY2suXG5IVE1MUGFyc2VyLkVsZW1lbnRTdGFjay5wcm90b3R5cGUucG9wRWxlbWVudCA9IGZ1bmN0aW9uKGUpIHtcbiAgZm9yKHZhciBpID0gdGhpcy5lbGVtZW50cy5sZW5ndGgtMTsgaSA+IDA7IGktLSkge1xuICAgIGlmICh0aGlzLmVsZW1lbnRzW2ldID09PSBlKSBicmVhaztcbiAgfVxuICB0aGlzLmVsZW1lbnRzLmxlbmd0aCA9IGk7XG4gIHRoaXMudG9wID0gdGhpcy5lbGVtZW50c1tpLTFdO1xufTtcblxuLy8gUmVtb3ZlIGEgc3BlY2lmaWMgZWxlbWVudCBmcm9tIHRoZSBzdGFjay5cbi8vIERvIG5vdGhpbmcgaWYgdGhlIGVsZW1lbnQgaXMgbm90IG9uIHRoZSBzdGFja1xuSFRNTFBhcnNlci5FbGVtZW50U3RhY2sucHJvdG90eXBlLnJlbW92ZUVsZW1lbnQgPSBmdW5jdGlvbihlKSB7XG4gIGlmICh0aGlzLnRvcCA9PT0gZSkgdGhpcy5wb3AoKTtcbiAgZWxzZSB7XG4gICAgdmFyIGlkeCA9IHRoaXMuZWxlbWVudHMubGFzdEluZGV4T2YoZSk7XG4gICAgaWYgKGlkeCAhPT0gLTEpXG4gICAgICB0aGlzLmVsZW1lbnRzLnNwbGljZShpZHgsIDEpO1xuICB9XG59O1xuXG5IVE1MUGFyc2VyLkVsZW1lbnRTdGFjay5wcm90b3R5cGUuY2xlYXJUb0NvbnRleHQgPSBmdW5jdGlvbihzZXQpIHtcbiAgLy8gTm90ZSB0aGF0IHdlIGRvbid0IGxvb3AgdG8gMC4gTmV2ZXIgcG9wIHRoZSA8aHRtbD4gZWx0IG9mZi5cbiAgZm9yKHZhciBpID0gdGhpcy5lbGVtZW50cy5sZW5ndGgtMTsgaSA+IDA7IGktLSkge1xuICAgIGlmIChpc0EodGhpcy5lbGVtZW50c1tpXSwgc2V0KSkgYnJlYWs7XG4gIH1cbiAgdGhpcy5lbGVtZW50cy5sZW5ndGggPSBpKzE7XG4gIHRoaXMudG9wID0gdGhpcy5lbGVtZW50c1tpXTtcbn07XG5cbkhUTUxQYXJzZXIuRWxlbWVudFN0YWNrLnByb3RvdHlwZS5jb250YWlucyA9IGZ1bmN0aW9uKHRhZykge1xuICByZXR1cm4gdGhpcy5pblNwZWNpZmljU2NvcGUodGFnLCBPYmplY3QuY3JlYXRlKG51bGwpKTtcbn07XG5cbkhUTUxQYXJzZXIuRWxlbWVudFN0YWNrLnByb3RvdHlwZS5pblNwZWNpZmljU2NvcGUgPSBmdW5jdGlvbih0YWcsIHNldCkge1xuICBmb3IodmFyIGkgPSB0aGlzLmVsZW1lbnRzLmxlbmd0aC0xOyBpID49IDA7IGktLSkge1xuICAgIHZhciBlbHQgPSB0aGlzLmVsZW1lbnRzW2ldO1xuICAgIGlmIChpc0EoZWx0LCB0YWcpKSByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoaXNBKGVsdCwgc2V0KSkgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8vIExpa2UgdGhlIGFib3ZlLCBidXQgZm9yIGEgc3BlY2lmaWMgZWxlbWVudCwgbm90IGEgdGFnbmFtZVxuSFRNTFBhcnNlci5FbGVtZW50U3RhY2sucHJvdG90eXBlLmVsZW1lbnRJblNwZWNpZmljU2NvcGUgPSBmdW5jdGlvbih0YXJnZXQsIHNldCkge1xuICBmb3IodmFyIGkgPSB0aGlzLmVsZW1lbnRzLmxlbmd0aC0xOyBpID49IDA7IGktLSkge1xuICAgIHZhciBlbHQgPSB0aGlzLmVsZW1lbnRzW2ldO1xuICAgIGlmIChlbHQgPT09IHRhcmdldCkgcmV0dXJuIHRydWU7XG4gICAgaWYgKGlzQShlbHQsIHNldCkpIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vLyBMaWtlIHRoZSBhYm92ZSwgYnV0IGZvciBhbiBlbGVtZW50IGludGVyZmFjZSwgbm90IGEgdGFnbmFtZVxuSFRNTFBhcnNlci5FbGVtZW50U3RhY2sucHJvdG90eXBlLmVsZW1lbnRUeXBlSW5TcGVjaWZpY1Njb3BlID0gZnVuY3Rpb24odGFyZ2V0LCBzZXQpIHtcbiAgZm9yKHZhciBpID0gdGhpcy5lbGVtZW50cy5sZW5ndGgtMTsgaSA+PSAwOyBpLS0pIHtcbiAgICB2YXIgZWx0ID0gdGhpcy5lbGVtZW50c1tpXTtcbiAgICBpZiAoZWx0IGluc3RhbmNlb2YgdGFyZ2V0KSByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoaXNBKGVsdCwgc2V0KSkgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbkhUTUxQYXJzZXIuRWxlbWVudFN0YWNrLnByb3RvdHlwZS5pblNjb3BlID0gZnVuY3Rpb24odGFnKSB7XG4gIHJldHVybiB0aGlzLmluU3BlY2lmaWNTY29wZSh0YWcsIGluU2NvcGVTZXQpO1xufTtcblxuSFRNTFBhcnNlci5FbGVtZW50U3RhY2sucHJvdG90eXBlLmVsZW1lbnRJblNjb3BlID0gZnVuY3Rpb24oZSkge1xuICByZXR1cm4gdGhpcy5lbGVtZW50SW5TcGVjaWZpY1Njb3BlKGUsIGluU2NvcGVTZXQpO1xufTtcblxuSFRNTFBhcnNlci5FbGVtZW50U3RhY2sucHJvdG90eXBlLmVsZW1lbnRUeXBlSW5TY29wZSA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgcmV0dXJuIHRoaXMuZWxlbWVudFR5cGVJblNwZWNpZmljU2NvcGUodHlwZSwgaW5TY29wZVNldCk7XG59O1xuXG5IVE1MUGFyc2VyLkVsZW1lbnRTdGFjay5wcm90b3R5cGUuaW5CdXR0b25TY29wZSA9IGZ1bmN0aW9uKHRhZykge1xuICByZXR1cm4gdGhpcy5pblNwZWNpZmljU2NvcGUodGFnLCBpbkJ1dHRvblNjb3BlU2V0KTtcbn07XG5cbkhUTUxQYXJzZXIuRWxlbWVudFN0YWNrLnByb3RvdHlwZS5pbkxpc3RJdGVtU2NvcGUgPSBmdW5jdGlvbih0YWcpIHtcbiAgcmV0dXJuIHRoaXMuaW5TcGVjaWZpY1Njb3BlKHRhZywgaW5MaXN0SXRlbVNjb3BlU2V0KTtcbn07XG5cbkhUTUxQYXJzZXIuRWxlbWVudFN0YWNrLnByb3RvdHlwZS5pblRhYmxlU2NvcGUgPSBmdW5jdGlvbih0YWcpIHtcbiAgcmV0dXJuIHRoaXMuaW5TcGVjaWZpY1Njb3BlKHRhZywgaW5UYWJsZVNjb3BlU2V0KTtcbn07XG5cbkhUTUxQYXJzZXIuRWxlbWVudFN0YWNrLnByb3RvdHlwZS5pblNlbGVjdFNjb3BlID0gZnVuY3Rpb24odGFnKSB7XG4gIC8vIENhbid0IGltcGxlbWVudCB0aGlzIG9uZSB3aXRoIGluU3BlY2lmaWNTY29wZSwgc2luY2UgaXQgaW52b2x2ZXNcbiAgLy8gYSBzZXQgZGVmaW5lZCBieSBpbnZlcnRpbmcgYW5vdGhlciBzZXQuIFNvIGltcGxlbWVudCBtYW51YWxseS5cbiAgZm9yKHZhciBpID0gdGhpcy5lbGVtZW50cy5sZW5ndGgtMTsgaSA+PSAwOyBpLS0pIHtcbiAgICB2YXIgZWx0ID0gdGhpcy5lbGVtZW50c1tpXTtcbiAgICBpZiAoZWx0Lm5hbWVzcGFjZVVSSSAhPT0gTkFNRVNQQUNFLkhUTUwpIHJldHVybiBmYWxzZTtcbiAgICB2YXIgbG9jYWxuYW1lID0gZWx0LmxvY2FsTmFtZTtcbiAgICBpZiAobG9jYWxuYW1lID09PSB0YWcpIHJldHVybiB0cnVlO1xuICAgIGlmIChsb2NhbG5hbWUgIT09IFwib3B0Z3JvdXBcIiAmJiBsb2NhbG5hbWUgIT09IFwib3B0aW9uXCIpXG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuSFRNTFBhcnNlci5FbGVtZW50U3RhY2sucHJvdG90eXBlLmdlbmVyYXRlSW1wbGllZEVuZFRhZ3MgPSBmdW5jdGlvbihidXRub3QsIHRob3JvdWdoKSB7XG4gIHZhciBlbmRUYWdTZXQgPSB0aG9yb3VnaCA/IHRob3JvdWdoSW1wbGllZEVuZFRhZ3NTZXQgOiBpbXBsaWVkRW5kVGFnc1NldDtcbiAgZm9yKHZhciBpID0gdGhpcy5lbGVtZW50cy5sZW5ndGgtMTsgaSA+PSAwOyBpLS0pIHtcbiAgICB2YXIgZSA9IHRoaXMuZWxlbWVudHNbaV07XG4gICAgaWYgKGJ1dG5vdCAmJiBpc0EoZSwgYnV0bm90KSkgYnJlYWs7XG4gICAgaWYgKCFpc0EodGhpcy5lbGVtZW50c1tpXSwgZW5kVGFnU2V0KSkgYnJlYWs7XG4gIH1cblxuICB0aGlzLmVsZW1lbnRzLmxlbmd0aCA9IGkrMTtcbiAgdGhpcy50b3AgPSB0aGlzLmVsZW1lbnRzW2ldO1xufTtcblxuLyoqKlxuICogVGhlIEFjdGl2ZUZvcm1hdHRpbmdFbGVtZW50cyBjbGFzc1xuICovXG5IVE1MUGFyc2VyLkFjdGl2ZUZvcm1hdHRpbmdFbGVtZW50cyA9IGZ1bmN0aW9uIEFGRSgpIHtcbiAgdGhpcy5saXN0ID0gW107IC8vIGVsZW1lbnRzXG4gIHRoaXMuYXR0cnMgPSBbXTsgLy8gYXR0cmlidXRlIHRva2VucyBmb3IgY2xvbmluZ1xufTtcblxuSFRNTFBhcnNlci5BY3RpdmVGb3JtYXR0aW5nRWxlbWVudHMucHJvdG90eXBlLk1BUktFUiA9IHsgbG9jYWxOYW1lOiBcInxcIiB9O1xuXG4vKlxuLy8gRm9yIGRlYnVnZ2luZ1xuSFRNTFBhcnNlci5BY3RpdmVGb3JtYXR0aW5nRWxlbWVudHMucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBcIkFGRTogXCIgK1xuICB0aGlzLmxpc3QubWFwKGZ1bmN0aW9uKGUpIHsgcmV0dXJuIGUubG9jYWxOYW1lOyB9KS5qb2luKFwiLVwiKTtcbn1cbiovXG5cbkhUTUxQYXJzZXIuQWN0aXZlRm9ybWF0dGluZ0VsZW1lbnRzLnByb3RvdHlwZS5pbnNlcnRNYXJrZXIgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5saXN0LnB1c2godGhpcy5NQVJLRVIpO1xuICB0aGlzLmF0dHJzLnB1c2godGhpcy5NQVJLRVIpO1xufTtcblxuSFRNTFBhcnNlci5BY3RpdmVGb3JtYXR0aW5nRWxlbWVudHMucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbihlbHQsIGF0dHJzKSB7XG4gIC8vIFNjYW4gYmFja3dhcmRzOiBpZiB0aGVyZSBhcmUgYWxyZWFkeSAzIGNvcGllcyBvZiB0aGlzIGVsZW1lbnRcbiAgLy8gYmVmb3JlIHdlIGVuY291bnRlciBhIG1hcmtlciwgdGhlbiBkcm9wIHRoZSBsYXN0IG9uZVxuICB2YXIgY291bnQgPSAwO1xuICBmb3IodmFyIGkgPSB0aGlzLmxpc3QubGVuZ3RoLTE7IGkgPj0gMDsgaS0tKSB7XG4gICAgaWYgKHRoaXMubGlzdFtpXSA9PT0gdGhpcy5NQVJLRVIpIGJyZWFrO1xuICAgIC8vIGVxdWFsKCkgaXMgZGVmaW5lZCBiZWxvd1xuICAgIGlmIChlcXVhbChlbHQsIHRoaXMubGlzdFtpXSwgdGhpcy5hdHRyc1tpXSkpIHtcbiAgICAgIGNvdW50Kys7XG4gICAgICBpZiAoY291bnQgPT09IDMpIHtcbiAgICAgICAgdGhpcy5saXN0LnNwbGljZShpLCAxKTtcbiAgICAgICAgdGhpcy5hdHRycy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG5cbiAgLy8gTm93IHB1c2ggdGhlIGVsZW1lbnQgb250byB0aGUgbGlzdFxuICB0aGlzLmxpc3QucHVzaChlbHQpO1xuXG4gIC8vIENvcHkgdGhlIGF0dHJpYnV0ZXMgYW5kIHB1c2ggdGhvc2Ugb24sIHRvb1xuICB2YXIgYXR0cmNvcHkgPSBbXTtcbiAgZm9yKHZhciBpaSA9IDA7IGlpIDwgYXR0cnMubGVuZ3RoOyBpaSsrKSB7XG4gICAgYXR0cmNvcHlbaWldID0gYXR0cnNbaWldO1xuICB9XG5cbiAgdGhpcy5hdHRycy5wdXNoKGF0dHJjb3B5KTtcblxuICAvLyBUaGlzIGZ1bmN0aW9uIGRlZmluZXMgZXF1YWxpdHkgb2YgdHdvIGVsZW1lbnRzIGZvciB0aGUgcHVycG9zZXNcbiAgLy8gb2YgdGhlIEFGRSBsaXN0LiAgTm90ZSB0aGF0IGl0IGNvbXBhcmVzIHRoZSBuZXcgZWxlbWVudHNcbiAgLy8gYXR0cmlidXRlcyB0byB0aGUgc2F2ZWQgYXJyYXkgb2YgYXR0cmlidXRlcyBhc3NvY2lhdGVkIHdpdGhcbiAgLy8gdGhlIG9sZCBlbGVtZW50IGJlY2F1c2UgYSBzY3JpcHQgY291bGQgaGF2ZSBjaGFuZ2VkIHRoZVxuICAvLyBvbGQgZWxlbWVudCdzIHNldCBvZiBhdHRyaWJ1dGVzXG4gIGZ1bmN0aW9uIGVxdWFsKG5ld2VsdCwgb2xkZWx0LCBvbGRhdHRycykge1xuICAgIGlmIChuZXdlbHQubG9jYWxOYW1lICE9PSBvbGRlbHQubG9jYWxOYW1lKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKG5ld2VsdC5fbnVtYXR0cnMgIT09IG9sZGF0dHJzLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICAgIGZvcih2YXIgaSA9IDAsIG4gPSBvbGRhdHRycy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgIHZhciBvbGRuYW1lID0gb2xkYXR0cnNbaV1bMF07XG4gICAgICB2YXIgb2xkdmFsID0gb2xkYXR0cnNbaV1bMV07XG4gICAgICBpZiAoIW5ld2VsdC5oYXNBdHRyaWJ1dGUob2xkbmFtZSkpIHJldHVybiBmYWxzZTtcbiAgICAgIGlmIChuZXdlbHQuZ2V0QXR0cmlidXRlKG9sZG5hbWUpICE9PSBvbGR2YWwpIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn07XG5cbkhUTUxQYXJzZXIuQWN0aXZlRm9ybWF0dGluZ0VsZW1lbnRzLnByb3RvdHlwZS5jbGVhclRvTWFya2VyID0gZnVuY3Rpb24oKSB7XG4gIGZvcih2YXIgaSA9IHRoaXMubGlzdC5sZW5ndGgtMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBpZiAodGhpcy5saXN0W2ldID09PSB0aGlzLk1BUktFUikgYnJlYWs7XG4gIH1cbiAgaWYgKGkgPCAwKSBpID0gMDtcbiAgdGhpcy5saXN0Lmxlbmd0aCA9IGk7XG4gIHRoaXMuYXR0cnMubGVuZ3RoID0gaTtcbn07XG5cbi8vIEZpbmQgYW5kIHJldHVybiB0aGUgbGFzdCBlbGVtZW50IHdpdGggdGhlIHNwZWNpZmllZCB0YWcgYmV0d2VlbiB0aGVcbi8vIGVuZCBvZiB0aGUgbGlzdCBhbmQgdGhlIGxhc3QgbWFya2VyIG9uIHRoZSBsaXN0LlxuLy8gVXNlZCB3aGVuIHBhcnNpbmcgPGE+IGluX2JvZHlfbW9kZSgpXG5IVE1MUGFyc2VyLkFjdGl2ZUZvcm1hdHRpbmdFbGVtZW50cy5wcm90b3R5cGUuZmluZEVsZW1lbnRCeVRhZyA9IGZ1bmN0aW9uKHRhZykge1xuICBmb3IodmFyIGkgPSB0aGlzLmxpc3QubGVuZ3RoLTE7IGkgPj0gMDsgaS0tKSB7XG4gICAgdmFyIGVsdCA9IHRoaXMubGlzdFtpXTtcbiAgICBpZiAoZWx0ID09PSB0aGlzLk1BUktFUikgYnJlYWs7XG4gICAgaWYgKGVsdC5sb2NhbE5hbWUgPT09IHRhZykgcmV0dXJuIGVsdDtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn07XG5cbkhUTUxQYXJzZXIuQWN0aXZlRm9ybWF0dGluZ0VsZW1lbnRzLnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24oZSkge1xuICByZXR1cm4gdGhpcy5saXN0Lmxhc3RJbmRleE9mKGUpO1xufTtcblxuLy8gRmluZCB0aGUgZWxlbWVudCBlIGluIHRoZSBsaXN0IGFuZCByZW1vdmUgaXRcbi8vIFVzZWQgd2hlbiBwYXJzaW5nIDxhPiBpbl9ib2R5KClcbkhUTUxQYXJzZXIuQWN0aXZlRm9ybWF0dGluZ0VsZW1lbnRzLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbihlKSB7XG4gIHZhciBpZHggPSB0aGlzLmxpc3QubGFzdEluZGV4T2YoZSk7XG4gIGlmIChpZHggIT09IC0xKSB7XG4gICAgdGhpcy5saXN0LnNwbGljZShpZHgsIDEpO1xuICAgIHRoaXMuYXR0cnMuc3BsaWNlKGlkeCwgMSk7XG4gIH1cbn07XG5cbi8vIEZpbmQgZWxlbWVudCBhIGluIHRoZSBsaXN0IGFuZCByZXBsYWNlIGl0IHdpdGggZWxlbWVudCBiXG4vLyBYWFg6IERvIEkgbmVlZCB0byBoYW5kbGUgYXR0cmlidXRlcyBoZXJlP1xuSFRNTFBhcnNlci5BY3RpdmVGb3JtYXR0aW5nRWxlbWVudHMucHJvdG90eXBlLnJlcGxhY2UgPSBmdW5jdGlvbihhLCBiLCBhdHRycykge1xuICB2YXIgaWR4ID0gdGhpcy5saXN0Lmxhc3RJbmRleE9mKGEpO1xuICBpZiAoaWR4ICE9PSAtMSkge1xuICAgIHRoaXMubGlzdFtpZHhdID0gYjtcbiAgICB0aGlzLmF0dHJzW2lkeF0gPSBhdHRycztcbiAgfVxufTtcblxuLy8gRmluZCBhIGluIHRoZSBsaXN0IGFuZCBpbnNlcnQgYiBhZnRlciBpdFxuLy8gVGhpcyBpcyBvbmx5IHVzZWQgZm9yIGluc2VydCBhIGJvb2ttYXJrIG9iamVjdCwgc28gdGhlXG4vLyBhdHRycyBhcnJheSBkb2Vzbid0IHJlYWxseSBtYXR0ZXJcbkhUTUxQYXJzZXIuQWN0aXZlRm9ybWF0dGluZ0VsZW1lbnRzLnByb3RvdHlwZS5pbnNlcnRBZnRlciA9IGZ1bmN0aW9uKGEsYikge1xuICB2YXIgaWR4ID0gdGhpcy5saXN0Lmxhc3RJbmRleE9mKGEpO1xuICBpZiAoaWR4ICE9PSAtMSkge1xuICAgIHRoaXMubGlzdC5zcGxpY2UoaWR4LCAwLCBiKTtcbiAgICB0aGlzLmF0dHJzLnNwbGljZShpZHgsIDAsIGIpO1xuICB9XG59O1xuXG5cblxuXG4vKioqXG4gKiBUaGlzIGlzIHRoZSBwYXJzZXIgZmFjdG9yeSBmdW5jdGlvbi4gSXQgaXMgdGhlIHJldHVybiB2YWx1ZSBvZlxuICogdGhlIG91dGVyIGNsb3N1cmUgdGhhdCBpdCBpcyBkZWZpbmVkIHdpdGhpbi4gIE1vc3Qgb2YgdGhlIHBhcnNlclxuICogaW1wbGVtZW50YXRpb24gZGV0YWlscyBhcmUgaW5zaWRlIHRoaXMgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIEhUTUxQYXJzZXIoYWRkcmVzcywgZnJhZ21lbnRDb250ZXh0LCBvcHRpb25zKSB7XG4gIC8qKipcbiAgICogVGhlc2UgYXJlIHRoZSBwYXJzZXIncyBzdGF0ZSB2YXJpYWJsZXNcbiAgICovXG4gIC8vIFNjYW5uZXIgc3RhdGVcbiAgdmFyIGNoYXJzID0gbnVsbDtcbiAgdmFyIG51bWNoYXJzID0gMDsgLy8gTGVuZ3RoIG9mIGNoYXJzXG4gIHZhciBuZXh0Y2hhciA9IDA7IC8vIEluZGV4IG9mIG5leHQgY2hhclxuICB2YXIgaW5wdXRfY29tcGxldGUgPSBmYWxzZTsgLy8gQmVjb21lcyB0cnVlIHdoZW4gZW5kKCkgY2FsbGVkLlxuICB2YXIgc2Nhbm5lcl9za2lwX25ld2xpbmUgPSBmYWxzZTsgLy8gSWYgcHJldmlvdXMgY2hhciB3YXMgQ1JcbiAgdmFyIHJlZW50cmFudF9pbnZvY2F0aW9ucyA9IDA7XG4gIHZhciBzYXZlZF9zY2FubmVyX3N0YXRlID0gW107XG4gIHZhciBsZWZ0b3ZlcnMgPSBcIlwiO1xuICB2YXIgZmlyc3RfYmF0Y2ggPSB0cnVlO1xuICB2YXIgcGF1c2VkID0gMDsgLy8gQmVjb21lcyBub24temVybyB3aGlsZSBsb2FkaW5nIHNjcmlwdHNcblxuXG4gIC8vIFRva2VuaXplciBzdGF0ZVxuICB2YXIgdG9rZW5pemVyID0gZGF0YV9zdGF0ZTsgLy8gQ3VycmVudCB0b2tlbml6ZXIgc3RhdGVcbiAgdmFyIHJldHVybl9zdGF0ZTtcbiAgdmFyIGNoYXJhY3Rlcl9yZWZlcmVuY2VfY29kZTtcbiAgdmFyIHRhZ25hbWVidWYgPSBcIlwiO1xuICB2YXIgbGFzdHRhZ25hbWUgPSBcIlwiOyAvLyBob2xkcyB0aGUgdGFyZ2V0IGVuZCB0YWcgZm9yIHRleHQgc3RhdGVzXG4gIHZhciB0ZW1wYnVmID0gW107XG4gIHZhciBhdHRybmFtZWJ1ZiA9IFwiXCI7XG4gIHZhciBhdHRydmFsdWVidWYgPSBcIlwiO1xuICB2YXIgY29tbWVudGJ1ZiA9IFtdO1xuICB2YXIgZG9jdHlwZW5hbWVidWYgPSBbXTtcbiAgdmFyIGRvY3R5cGVwdWJsaWNidWYgPSBbXTtcbiAgdmFyIGRvY3R5cGVzeXN0ZW1idWYgPSBbXTtcbiAgdmFyIGF0dHJpYnV0ZXMgPSBbXTtcbiAgdmFyIGlzX2VuZF90YWcgPSBmYWxzZTtcblxuICAvLyBUcmVlIGJ1aWxkZXIgc3RhdGVcbiAgdmFyIHBhcnNlciA9IGluaXRpYWxfbW9kZTsgLy8gQ3VycmVudCBpbnNlcnRpb24gbW9kZVxuICB2YXIgb3JpZ2luYWxJbnNlcnRpb25Nb2RlID0gbnVsbDsgLy8gQSBzYXZlZCBpbnNlcnRpb24gbW9kZVxuICB2YXIgdGVtcGxhdGVJbnNlcnRpb25Nb2RlcyA9IFtdOyAvLyBTdGFjayBvZiB0ZW1wbGF0ZSBpbnNlcnRpb24gbW9kZXMuXG4gIHZhciBzdGFjayA9IG5ldyBIVE1MUGFyc2VyLkVsZW1lbnRTdGFjaygpOyAvLyBTdGFjayBvZiBvcGVuIGVsZW1lbnRzXG4gIHZhciBhZmUgPSBuZXcgSFRNTFBhcnNlci5BY3RpdmVGb3JtYXR0aW5nRWxlbWVudHMoKTsgLy8gbWlzLW5lc3RlZCB0YWdzXG4gIHZhciBmcmFnbWVudCA9IChmcmFnbWVudENvbnRleHQhPT11bmRlZmluZWQpOyAvLyBGb3IgaW5uZXJIVE1MLCBldGMuXG4gIHZhciBoZWFkX2VsZW1lbnRfcG9pbnRlciA9IG51bGw7XG4gIHZhciBmb3JtX2VsZW1lbnRfcG9pbnRlciA9IG51bGw7XG4gIHZhciBzY3JpcHRpbmdfZW5hYmxlZCA9IHRydWU7XG4gIGlmIChmcmFnbWVudENvbnRleHQpIHtcblx0c2NyaXB0aW5nX2VuYWJsZWQgPSBmcmFnbWVudENvbnRleHQub3duZXJEb2N1bWVudC5fc2NyaXB0aW5nX2VuYWJsZWQ7XG4gIH1cbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5zY3JpcHRpbmdfZW5hYmxlZCA9PT0gZmFsc2UpXG4gICAgc2NyaXB0aW5nX2VuYWJsZWQgPSBmYWxzZTtcbiAgdmFyIGZyYW1lc2V0X29rID0gdHJ1ZTtcbiAgdmFyIGZvcmNlX3F1aXJrcyA9IGZhbHNlO1xuICB2YXIgcGVuZGluZ190YWJsZV90ZXh0O1xuICB2YXIgdGV4dF9pbnRlZ3JhdGlvbl9tb2RlOyAvLyBYWFggYSBzcGVjIGJ1ZyB3b3JrYXJvdW5kP1xuXG4gIC8vIEEgc2luZ2xlIHJ1biBvZiBjaGFyYWN0ZXJzLCBidWZmZXJlZCB1cCB0byBiZSBzZW50IHRvXG4gIC8vIHRoZSBwYXJzZXIgYXMgYSBzaW5nbGUgc3RyaW5nLlxuICB2YXIgdGV4dHJ1biA9IFtdO1xuICB2YXIgdGV4dEluY2x1ZGVzTlVMID0gZmFsc2U7XG4gIHZhciBpZ25vcmVfbGluZWZlZWQgPSBmYWxzZTtcblxuICAvKioqXG4gICAqIFRoaXMgaXMgdGhlIHBhcnNlciBvYmplY3QgdGhhdCB3aWxsIGJlIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhpc1xuICAgKiBmYWN0b3J5IGZ1bmN0aW9uLCB3aGljaCBpcyBzb21lIDUwMDAgbGluZXMgYmVsb3cuXG4gICAqIE5vdGUgdGhhdCB0aGUgdmFyaWFibGUgXCJwYXJzZXJcIiBpcyB0aGUgY3VycmVudCBzdGF0ZSBvZiB0aGVcbiAgICogcGFyc2VyJ3Mgc3RhdGUgbWFjaGluZS4gIFRoaXMgdmFyaWFibGUgXCJodG1scGFyc2VyXCIgaXMgdGhlXG4gICAqIHJldHVybiB2YWx1ZSBhbmQgZGVmaW5lcyB0aGUgcHVibGljIEFQSSBvZiB0aGUgcGFyc2VyXG4gICAqL1xuICB2YXIgaHRtbHBhcnNlciA9IHtcbiAgICBkb2N1bWVudDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZG9jO1xuICAgIH0sXG5cbiAgICAvLyBJbnRlcm5hbCBmdW5jdGlvbiB1c2VkIGZyb20gSFRNTFNjcmlwdEVsZW1lbnQgdG8gcGF1c2UgdGhlXG4gICAgLy8gcGFyc2VyIHdoaWxlIGEgc2NyaXB0IGlzIGJlaW5nIGxvYWRlZCBmcm9tIHRoZSBuZXR3b3JrXG4gICAgcGF1c2U6IGZ1bmN0aW9uKCkge1xuICAgICAgLy8gcHJpbnQoXCJwYXVzaW5nIHBhcnNlclwiKTtcbiAgICAgIHBhdXNlZCsrO1xuICAgIH0sXG5cbiAgICAvLyBDYWxsZWQgd2hlbiBhIHNjcmlwdCBmaW5pc2hlcyBsb2FkaW5nXG4gICAgcmVzdW1lOiBmdW5jdGlvbigpIHtcbiAgICAgIC8vIHByaW50KFwicmVzdW1pbmcgcGFyc2VyXCIpO1xuICAgICAgcGF1c2VkLS07XG4gICAgICAvLyBYWFg6IGFkZGVkIHRoaXMgdG8gZm9yY2UgYSByZXN1bXB0aW9uLlxuICAgICAgLy8gSXMgdGhpcyB0aGUgcmlnaHQgdGhpbmcgdG8gZG8/XG4gICAgICB0aGlzLnBhcnNlKFwiXCIpO1xuICAgIH0sXG5cbiAgICAvLyBQYXJzZSB0aGUgSFRNTCB0ZXh0IHMuXG4gICAgLy8gVGhlIHNlY29uZCBhcmd1bWVudCBzaG91bGQgYmUgdHJ1ZSBpZiB0aGVyZSBpcyBubyBtb3JlXG4gICAgLy8gdGV4dCB0byBiZSBwYXJzZWQsIGFuZCBzaG91bGQgYmUgZmFsc2Ugb3Igb21pdHRlZCBvdGhlcndpc2UuXG4gICAgLy8gVGhlIHNlY29uZCBhcmd1bWVudCBtdXN0IG5vdCBiZSBzZXQgZm9yIHJlY3Vyc2l2ZSBpbnZvY2F0aW9uc1xuICAgIC8vIGZyb20gZG9jdW1lbnQud3JpdGUoKVxuICAgIHBhcnNlOiBmdW5jdGlvbihzLCBlbmQpIHtcblxuICAgICAgLy8gSWYgd2UncmUgcGF1c2VkLCByZW1lbWJlciB0aGUgdGV4dCB0byBwYXJzZSwgYnV0XG4gICAgICAvLyBkb24ndCBwYXJzZSBpdCBub3cuXG4gICAgICBpZiAocGF1c2VkID4gMCkge1xuICAgICAgICBsZWZ0b3ZlcnMgKz0gcztcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG5cbiAgICAgIGlmIChyZWVudHJhbnRfaW52b2NhdGlvbnMgPT09IDApIHtcbiAgICAgICAgLy8gQSBub3JtYWwsIHRvcC1sZXZlbCBpbnZvY2F0aW9uXG4gICAgICAgIGlmIChsZWZ0b3ZlcnMpIHtcbiAgICAgICAgICBzID0gbGVmdG92ZXJzICsgcztcbiAgICAgICAgICBsZWZ0b3ZlcnMgPSBcIlwiO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQWRkIGEgc3BlY2lhbCBtYXJrZXIgY2hhcmFjdGVyIHRvIHRoZSBlbmQgb2ZcbiAgICAgICAgLy8gdGhlIGJ1ZmZlci4gIElmIHRoZSBzY2FubmVyIGlzIGF0IHRoZSBlbmQgb2ZcbiAgICAgICAgLy8gdGhlIGJ1ZmZlciBhbmQgaW5wdXRfY29tcGxldGUgaXMgc2V0LCB0aGVuIHRoaXNcbiAgICAgICAgLy8gY2hhcmFjdGVyIHdpbGwgdHJhbnNmb3JtIGludG8gYW4gRU9GIHRva2VuLlxuICAgICAgICAvLyBIYXZpbmcgYW4gYWN0dWFsIGNoYXJhY3RlciB0aGF0IHJlcHJlc2VudHMgRU9GXG4gICAgICAgIC8vIGluIHRoZSBjaGFyYWN0ZXIgYnVmZmVyIG1ha2VzIGxvb2thaGVhZCByZWdleHBcbiAgICAgICAgLy8gbWF0Y2hpbmcgd29yayBtb3JlIGVhc2lseSwgYW5kIHRoaXMgaXNcbiAgICAgICAgLy8gaW1wb3J0YW50IGZvciBjaGFyYWN0ZXIgcmVmZXJlbmNlcy5cbiAgICAgICAgaWYgKGVuZCkge1xuICAgICAgICAgIHMgKz0gXCJcXHVGRkZGXCI7XG4gICAgICAgICAgaW5wdXRfY29tcGxldGUgPSB0cnVlOyAvLyBNYWtlcyBzY2FuQ2hhcnMoKSBzZW5kIEVPRlxuICAgICAgICB9XG5cbiAgICAgICAgY2hhcnMgPSBzO1xuICAgICAgICBudW1jaGFycyA9IHMubGVuZ3RoO1xuICAgICAgICBuZXh0Y2hhciA9IDA7XG5cbiAgICAgICAgaWYgKGZpcnN0X2JhdGNoKSB7XG4gICAgICAgICAgLy8gV2Ugc2tpcCBhIGxlYWRpbmcgQnl0ZSBPcmRlciBNYXJrIChcXHVGRUZGKVxuICAgICAgICAgIC8vIG9uIGZpcnN0IGJhdGNoIG9mIHRleHQgd2UncmUgZ2l2ZW5cbiAgICAgICAgICBmaXJzdF9iYXRjaCA9IGZhbHNlO1xuICAgICAgICAgIGlmIChjaGFycy5jaGFyQ29kZUF0KDApID09PSAweEZFRkYpIG5leHRjaGFyID0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlZW50cmFudF9pbnZvY2F0aW9ucysrO1xuICAgICAgICBzY2FuQ2hhcnMoKTtcbiAgICAgICAgbGVmdG92ZXJzID0gY2hhcnMuc3Vic3RyaW5nKG5leHRjaGFyLCBudW1jaGFycyk7XG4gICAgICAgIHJlZW50cmFudF9pbnZvY2F0aW9ucy0tO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIC8vIFRoaXMgaXMgdGhlIHJlLWVudHJhbnQgY2FzZSwgd2hpY2ggd2UgaGF2ZSB0b1xuICAgICAgICAvLyBoYW5kbGUgYSBsaXR0bGUgZGlmZmVyZW50bHkuXG4gICAgICAgIHJlZW50cmFudF9pbnZvY2F0aW9ucysrO1xuXG4gICAgICAgIC8vIFNhdmUgY3VycmVudCBzY2FubmVyIHN0YXRlXG4gICAgICAgIHNhdmVkX3NjYW5uZXJfc3RhdGUucHVzaChjaGFycywgbnVtY2hhcnMsIG5leHRjaGFyKTtcblxuICAgICAgICAvLyBTZXQgbmV3IHNjYW5uZXIgc3RhdGVcbiAgICAgICAgY2hhcnMgPSBzO1xuICAgICAgICBudW1jaGFycyA9IHMubGVuZ3RoO1xuICAgICAgICBuZXh0Y2hhciA9IDA7XG5cbiAgICAgICAgLy8gTm93IHNjYW4gYXMgbWFueSBvZiB0aGVzZSBuZXcgY2hhcnMgYXMgd2UgY2FuXG4gICAgICAgIHNjYW5DaGFycygpO1xuXG4gICAgICAgIGxlZnRvdmVycyA9IGNoYXJzLnN1YnN0cmluZyhuZXh0Y2hhciwgbnVtY2hhcnMpO1xuXG4gICAgICAgIC8vIHJlc3RvcmUgb2xkIHNjYW5uZXIgc3RhdGVcbiAgICAgICAgbmV4dGNoYXIgPSBzYXZlZF9zY2FubmVyX3N0YXRlLnBvcCgpO1xuICAgICAgICBudW1jaGFycyA9IHNhdmVkX3NjYW5uZXJfc3RhdGUucG9wKCk7XG4gICAgICAgIGNoYXJzID0gc2F2ZWRfc2Nhbm5lcl9zdGF0ZS5wb3AoKTtcblxuICAgICAgICAvLyBJZiB0aGVyZSB3ZXJlIGxlZnRvdmVyIGNoYXJzIGZyb20gdGhpcyBpbnZvY2F0aW9uXG4gICAgICAgIC8vIGluc2VydCB0aGVtIGludG8gdGhlIHBlbmRpbmcgaW52b2NhdGlvbidzIGJ1ZmZlclxuICAgICAgICAvLyBhbmQgdHJpbSBhbHJlYWR5IHByb2Nlc3NlZCBjaGFycyBhdCB0aGUgc2FtZSB0aW1lXG4gICAgICAgIGlmIChsZWZ0b3ZlcnMpIHtcbiAgICAgICAgICBjaGFycyA9IGxlZnRvdmVycyArIGNoYXJzLnN1YnN0cmluZyhuZXh0Y2hhcik7XG4gICAgICAgICAgbnVtY2hhcnMgPSBjaGFycy5sZW5ndGg7XG4gICAgICAgICAgbmV4dGNoYXIgPSAwO1xuICAgICAgICAgIGxlZnRvdmVycyA9IFwiXCI7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEZWNyZW1lbnQgdGhlIGNvdW50ZXJcbiAgICAgICAgcmVlbnRyYW50X2ludm9jYXRpb25zLS07XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG5cbiAgLy8gVGhpcyBpcyB0aGUgZG9jdW1lbnQgd2UnbGwgYmUgYnVpbGRpbmcgdXBcbiAgdmFyIGRvYyA9IG5ldyBEb2N1bWVudCh0cnVlLCBhZGRyZXNzKTtcblxuICAvLyBUaGUgZG9jdW1lbnQgbmVlZHMgdG8ga25vdyBhYm91dCB0aGUgcGFyc2VyLCBmb3IgZG9jdW1lbnQud3JpdGUoKS5cbiAgLy8gVGhpcyBfcGFyc2VyIHByb3BlcnR5IHdpbGwgYmUgZGVsZXRlZCB3aGVuIHdlJ3JlIGRvbmUgcGFyc2luZy5cbiAgZG9jLl9wYXJzZXIgPSBodG1scGFyc2VyO1xuXG4gIC8vIFhYWCBJIHRoaW5rIHRoYXQgYW55IGRvY3VtZW50IHdlIHVzZSB0aGlzIHBhcnNlciBvbiBzaG91bGQgc3VwcG9ydFxuICAvLyBzY3JpcHRzLiBCdXQgSSBtYXkgbmVlZCB0byBjb25maWd1cmUgdGhhdCB0aHJvdWdoIGEgcGFyc2VyIHBhcmFtZXRlclxuICAvLyBPbmx5IGRvY3VtZW50cyB3aXRoIHdpbmRvd3MgKFwiYnJvd3NpbmcgY29udGV4dHNcIiB0byBiZSBwcmVjaXNlKVxuICAvLyBhbGxvdyBzY3JpcHRpbmcuXG4gIGRvYy5fc2NyaXB0aW5nX2VuYWJsZWQgPSBzY3JpcHRpbmdfZW5hYmxlZDtcblxuXG4gIC8qKipcbiAgICogVGhlIGFjdHVhbCBjb2RlIG9mIHRoZSBIVE1MUGFyc2VyKCkgZmFjdG9yeSBmdW5jdGlvbiBiZWdpbnMgaGVyZS5cbiAgICovXG5cbiAgaWYgKGZyYWdtZW50Q29udGV4dCkgeyAvLyBmb3IgaW5uZXJIVE1MIHBhcnNpbmdcbiAgICBpZiAoZnJhZ21lbnRDb250ZXh0Lm93bmVyRG9jdW1lbnQuX3F1aXJrcylcbiAgICAgIGRvYy5fcXVpcmtzID0gdHJ1ZTtcbiAgICBpZiAoZnJhZ21lbnRDb250ZXh0Lm93bmVyRG9jdW1lbnQuX2xpbWl0ZWRRdWlya3MpXG4gICAgICBkb2MuX2xpbWl0ZWRRdWlya3MgPSB0cnVlO1xuXG4gICAgLy8gU2V0IHRoZSBpbml0aWFsIHRva2VuaXplciBzdGF0ZVxuICAgIGlmIChmcmFnbWVudENvbnRleHQubmFtZXNwYWNlVVJJID09PSBOQU1FU1BBQ0UuSFRNTCkge1xuICAgICAgc3dpdGNoKGZyYWdtZW50Q29udGV4dC5sb2NhbE5hbWUpIHtcbiAgICAgIGNhc2UgXCJ0aXRsZVwiOlxuICAgICAgY2FzZSBcInRleHRhcmVhXCI6XG4gICAgICAgIHRva2VuaXplciA9IHJjZGF0YV9zdGF0ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwic3R5bGVcIjpcbiAgICAgIGNhc2UgXCJ4bXBcIjpcbiAgICAgIGNhc2UgXCJpZnJhbWVcIjpcbiAgICAgIGNhc2UgXCJub2VtYmVkXCI6XG4gICAgICBjYXNlIFwibm9mcmFtZXNcIjpcbiAgICAgIGNhc2UgXCJzY3JpcHRcIjpcbiAgICAgIGNhc2UgXCJwbGFpbnRleHRcIjpcbiAgICAgICAgdG9rZW5pemVyID0gcGxhaW50ZXh0X3N0YXRlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJub3NjcmlwdFwiOlxuICAgICAgICBpZiAoc2NyaXB0aW5nX2VuYWJsZWQpXG4gICAgICAgICAgdG9rZW5pemVyID0gcGxhaW50ZXh0X3N0YXRlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciByb290ID0gZG9jLmNyZWF0ZUVsZW1lbnQoXCJodG1sXCIpO1xuICAgIGRvYy5fYXBwZW5kQ2hpbGQocm9vdCk7XG4gICAgc3RhY2sucHVzaChyb290KTtcbiAgICBpZiAoZnJhZ21lbnRDb250ZXh0IGluc3RhbmNlb2YgaW1wbC5IVE1MVGVtcGxhdGVFbGVtZW50KSB7XG4gICAgICB0ZW1wbGF0ZUluc2VydGlvbk1vZGVzLnB1c2goaW5fdGVtcGxhdGVfbW9kZSk7XG4gICAgfVxuICAgIHJlc2V0SW5zZXJ0aW9uTW9kZSgpO1xuXG4gICAgZm9yKHZhciBlID0gZnJhZ21lbnRDb250ZXh0OyBlICE9PSBudWxsOyBlID0gZS5wYXJlbnRFbGVtZW50KSB7XG4gICAgICBpZiAoZSBpbnN0YW5jZW9mIGltcGwuSFRNTEZvcm1FbGVtZW50KSB7XG4gICAgICAgIGZvcm1fZWxlbWVudF9wb2ludGVyID0gZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqKlxuICAgKiBTY2FubmVyIGZ1bmN0aW9uc1xuICAgKi9cbiAgLy8gTG9vcCB0aHJvdWdoIHRoZSBjaGFyYWN0ZXJzIGluIGNoYXJzLCBhbmQgcGFzcyB0aGVtIG9uZSBhdCBhIHRpbWVcbiAgLy8gdG8gdGhlIHRva2VuaXplciBGU00uIFJldHVybiB3aGVuIG5vIG1vcmUgY2hhcmFjdGVycyBjYW4gYmUgcHJvY2Vzc2VkXG4gIC8vIChUaGlzIG1heSBsZWF2ZSAxIG9yIG1vcmUgY2hhcmFjdGVycyBpbiB0aGUgYnVmZmVyOiBsaWtlIGEgQ1JcbiAgLy8gd2FpdGluZyB0byBzZWUgaWYgdGhlIG5leHQgY2hhciBpcyBMRiwgb3IgZm9yIHN0YXRlcyB0aGF0IHJlcXVpcmVcbiAgLy8gbG9va2FoZWFkLi4uKVxuICBmdW5jdGlvbiBzY2FuQ2hhcnMoKSB7XG4gICAgdmFyIGNvZGVwb2ludCwgcywgcGF0dGVybiwgZW9mO1xuXG4gICAgd2hpbGUobmV4dGNoYXIgPCBudW1jaGFycykge1xuXG4gICAgICAvLyBJZiB3ZSBqdXN0IHRva2VuaXplZCBhIDwvc2NyaXB0PiB0YWcsIHRoZW4gdGhlIHBhdXNlZCBmbGFnXG4gICAgICAvLyBtYXkgaGF2ZSBiZWVuIHNldCB0byB0ZWxsIHVzIHRvIHN0b3AgdG9rZW5pemluZyB3aGlsZVxuICAgICAgLy8gdGhlIHNjcmlwdCBpcyBsb2FkaW5nXG4gICAgICBpZiAocGF1c2VkID4gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cblxuICAgICAgc3dpdGNoKHR5cGVvZiB0b2tlbml6ZXIubG9va2FoZWFkKSB7XG4gICAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgICBjb2RlcG9pbnQgPSBjaGFycy5jaGFyQ29kZUF0KG5leHRjaGFyKyspO1xuICAgICAgICBpZiAoc2Nhbm5lcl9za2lwX25ld2xpbmUpIHtcbiAgICAgICAgICBzY2FubmVyX3NraXBfbmV3bGluZSA9IGZhbHNlO1xuICAgICAgICAgIGlmIChjb2RlcG9pbnQgPT09IDB4MDAwQSkge1xuICAgICAgICAgICAgbmV4dGNoYXIrKztcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2goY29kZXBvaW50KSB7XG4gICAgICAgIGNhc2UgMHgwMDBEOlxuICAgICAgICAgIC8vIENSIGFsd2F5cyB0dXJucyBpbnRvIExGLCBidXQgaWYgdGhlIG5leHQgY2hhcmFjdGVyXG4gICAgICAgICAgLy8gaXMgTEYsIHRoZW4gdGhhdCBzZWNvbmQgTEYgaXMgc2tpcHBlZC5cbiAgICAgICAgICBpZiAobmV4dGNoYXIgPCBudW1jaGFycykge1xuICAgICAgICAgICAgaWYgKGNoYXJzLmNoYXJDb2RlQXQobmV4dGNoYXIpID09PSAweDAwMEEpXG4gICAgICAgICAgICAgIG5leHRjaGFyKys7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gV2UgZG9uJ3Qga25vdyB0aGUgbmV4dCBjaGFyIHJpZ2h0IG5vdywgc28gd2VcbiAgICAgICAgICAgIC8vIGNhbid0IGNoZWNrIGlmIGl0IGlzIGEgTEYuICBTbyBzZXQgYSBmbGFnXG4gICAgICAgICAgICBzY2FubmVyX3NraXBfbmV3bGluZSA9IHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gSW4gZWl0aGVyIGNhc2UsIGVtaXQgYSBMRlxuICAgICAgICAgIHRva2VuaXplcigweDAwMEEpO1xuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMHhGRkZGOlxuICAgICAgICAgIGlmIChpbnB1dF9jb21wbGV0ZSAmJiBuZXh0Y2hhciA9PT0gbnVtY2hhcnMpIHtcbiAgICAgICAgICAgIHRva2VuaXplcihFT0YpOyAvLyBjb2RlcG9pbnQgd2lsbCBiZSAweEZGRkYgaGVyZVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0b2tlbml6ZXIoY29kZXBvaW50KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgY29kZXBvaW50ID0gY2hhcnMuY2hhckNvZGVBdChuZXh0Y2hhcik7XG5cbiAgICAgICAgLy8gVGhlIG9ubHkgdG9rZW5pemVyIHN0YXRlcyB0aGF0IHJlcXVpcmUgZml4ZWQgbG9va2FoZWFkXG4gICAgICAgIC8vIG9ubHkgY29uc3VtZSBhbHBoYW51bSBjaGFyYWN0ZXJzLCBzbyB3ZSBkb24ndCBoYXZlXG4gICAgICAgIC8vIHRvIHdvcnJ5IGFib3V0IENSIGFuZCBMRiBpbiB0aGlzIGNhc2VcblxuICAgICAgICAvLyB0b2tlbml6ZXIgd2FudHMgbiBjaGFycyBvZiBsb29rYWhlYWRcbiAgICAgICAgdmFyIG4gPSB0b2tlbml6ZXIubG9va2FoZWFkO1xuICAgICAgICB2YXIgbmVlZHNTdHJpbmcgPSB0cnVlO1xuICAgICAgICBpZiAobiA8IDApIHtcbiAgICAgICAgICBuZWVkc1N0cmluZyA9IGZhbHNlO1xuICAgICAgICAgIG4gPSAtbjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChuIDwgbnVtY2hhcnMgLSBuZXh0Y2hhcikge1xuICAgICAgICAgIC8vIElmIHdlIGNhbiBsb29rIGFoZWFkIHRoYXQgZmFyXG4gICAgICAgICAgcyA9IG5lZWRzU3RyaW5nID8gY2hhcnMuc3Vic3RyaW5nKG5leHRjaGFyLCBuZXh0Y2hhcituKSA6IG51bGw7XG4gICAgICAgICAgZW9mID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7IC8vIGlmIHdlIGRvbid0IGhhdmUgdGhhdCBtYW55IGNoYXJhY3RlcnNcbiAgICAgICAgICBpZiAoaW5wdXRfY29tcGxldGUpIHsgLy8gSWYgbm8gbW9yZSBhcmUgY29taW5nXG4gICAgICAgICAgICAvLyBKdXN0IHJldHVybiB3aGF0IHdlIGhhdmVcbiAgICAgICAgICAgIHMgPSBuZWVkc1N0cmluZyA/IGNoYXJzLnN1YnN0cmluZyhuZXh0Y2hhciwgbnVtY2hhcnMpIDogbnVsbDtcbiAgICAgICAgICAgIGVvZiA9IHRydWU7XG4gICAgICAgICAgICBpZiAoY29kZXBvaW50ID09PSAweEZGRkYgJiYgbmV4dGNoYXIgPT09IG51bWNoYXJzLTEpXG4gICAgICAgICAgICAgIGNvZGVwb2ludCA9IEVPRjtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBSZXR1cm4gbm93IGFuZCB3YWl0IGZvciBtb3JlIGNoYXJzIGxhdGVyXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRva2VuaXplcihjb2RlcG9pbnQsIHMsIGVvZik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgY29kZXBvaW50ID0gY2hhcnMuY2hhckNvZGVBdChuZXh0Y2hhcik7XG5cbiAgICAgICAgLy8gdG9rZW5pemVyIHdhbnRzIGNoYXJhY3RlcnMgdXAgdG8gYSBtYXRjaGluZyBzdHJpbmdcbiAgICAgICAgcGF0dGVybiA9IHRva2VuaXplci5sb29rYWhlYWQ7XG4gICAgICAgIHZhciBwb3MgPSBjaGFycy5pbmRleE9mKHBhdHRlcm4sIG5leHRjaGFyKTtcbiAgICAgICAgaWYgKHBvcyAhPT0gLTEpIHtcbiAgICAgICAgICBzID0gY2hhcnMuc3Vic3RyaW5nKG5leHRjaGFyLCBwb3MgKyBwYXR0ZXJuLmxlbmd0aCk7XG4gICAgICAgICAgZW9mID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7ICAvLyBObyBtYXRjaFxuICAgICAgICAgIC8vIElmIG1vcmUgY2hhcmFjdGVycyBjb21pbmcsIHdhaXQgZm9yIHRoZW1cbiAgICAgICAgICBpZiAoIWlucHV0X2NvbXBsZXRlKSByZXR1cm47XG5cbiAgICAgICAgICAvLyBPdGhlcndpc2UsIHdlJ3ZlIGdvdCB0byByZXR1cm4gd2hhdCB3ZSd2ZSBnb3RcbiAgICAgICAgICBzID0gY2hhcnMuc3Vic3RyaW5nKG5leHRjaGFyLCBudW1jaGFycyk7XG4gICAgICAgICAgaWYgKGNvZGVwb2ludCA9PT0gMHhGRkZGICYmIG5leHRjaGFyID09PSBudW1jaGFycy0xKVxuICAgICAgICAgICAgY29kZXBvaW50ID0gRU9GO1xuICAgICAgICAgIGVvZiA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUaGUgdG9rZW5pemVyIHN0YXRlcyB0aGF0IHJlcXVpcmUgdGhpcyBraW5kIG9mXG4gICAgICAgIC8vIGxvb2thaGVhZCBoYXZlIHRvIGJlIGNhcmVmdWwgdG8gaGFuZGxlIENSIGNoYXJhY3RlcnNcbiAgICAgICAgLy8gY29ycmVjdGx5XG4gICAgICAgIHRva2VuaXplcihjb2RlcG9pbnQsIHMsIGVvZik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG5cbiAgLyoqKlxuICAgKiBUb2tlbml6ZXIgdXRpbGl0eSBmdW5jdGlvbnNcbiAgICovXG4gIGZ1bmN0aW9uIGFkZEF0dHJpYnV0ZShuYW1lLHZhbHVlKSB7XG4gICAgLy8gTWFrZSBzdXJlIHRoZXJlIGlzbid0IGFscmVhZHkgYW4gYXR0cmlidXRlIHdpdGggdGhpcyBuYW1lXG4gICAgLy8gSWYgdGhlcmUgaXMsIGlnbm9yZSB0aGlzIG9uZS5cbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgYXR0cmlidXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGF0dHJpYnV0ZXNbaV1bMF0gPT09IG5hbWUpIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgYXR0cmlidXRlcy5wdXNoKFtuYW1lLCB2YWx1ZV0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGF0dHJpYnV0ZXMucHVzaChbbmFtZV0pO1xuICAgIH1cbiAgfVxuXG4gIC8vIFNob3J0Y3V0IGZvciBzaW1wbGUgYXR0cmlidXRlc1xuICBmdW5jdGlvbiBoYW5kbGVTaW1wbGVBdHRyaWJ1dGUoKSB7XG4gICAgU0lNUExFQVRUUi5sYXN0SW5kZXggPSBuZXh0Y2hhci0xO1xuICAgIHZhciBtYXRjaGVkID0gU0lNUExFQVRUUi5leGVjKGNoYXJzKTtcbiAgICBpZiAoIW1hdGNoZWQpIHRocm93IG5ldyBFcnJvcihcInNob3VsZCBuZXZlciBoYXBwZW5cIik7XG4gICAgdmFyIG5hbWUgPSBtYXRjaGVkWzFdO1xuICAgIGlmICghbmFtZSkgcmV0dXJuIGZhbHNlO1xuICAgIHZhciB2YWx1ZSA9IG1hdGNoZWRbMl07XG4gICAgdmFyIGxlbiA9IHZhbHVlLmxlbmd0aDtcbiAgICBzd2l0Y2godmFsdWVbMF0pIHtcbiAgICBjYXNlICdcIic6XG4gICAgY2FzZSBcIidcIjpcbiAgICAgIHZhbHVlID0gdmFsdWUuc3Vic3RyaW5nKDEsIGxlbi0xKTtcbiAgICAgIG5leHRjaGFyICs9IChtYXRjaGVkWzBdLmxlbmd0aC0xKTtcbiAgICAgIHRva2VuaXplciA9IGFmdGVyX2F0dHJpYnV0ZV92YWx1ZV9xdW90ZWRfc3RhdGU7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdG9rZW5pemVyID0gYmVmb3JlX2F0dHJpYnV0ZV9uYW1lX3N0YXRlO1xuICAgICAgbmV4dGNoYXIgKz0gKG1hdGNoZWRbMF0ubGVuZ3RoLTEpO1xuICAgICAgdmFsdWUgPSB2YWx1ZS5zdWJzdHJpbmcoMCwgbGVuLTEpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLy8gTWFrZSBzdXJlIHRoZXJlIGlzbid0IGFscmVhZHkgYW4gYXR0cmlidXRlIHdpdGggdGhpcyBuYW1lXG4gICAgLy8gSWYgdGhlcmUgaXMsIGlnbm9yZSB0aGlzIG9uZS5cbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgYXR0cmlidXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGF0dHJpYnV0ZXNbaV1bMF0gPT09IG5hbWUpIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGF0dHJpYnV0ZXMucHVzaChbbmFtZSwgdmFsdWVdKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGJlZ2luVGFnTmFtZSgpIHtcbiAgICBpc19lbmRfdGFnID0gZmFsc2U7XG4gICAgdGFnbmFtZWJ1ZiA9IFwiXCI7XG4gICAgYXR0cmlidXRlcy5sZW5ndGggPSAwO1xuICB9XG4gIGZ1bmN0aW9uIGJlZ2luRW5kVGFnTmFtZSgpIHtcbiAgICBpc19lbmRfdGFnID0gdHJ1ZTtcbiAgICB0YWduYW1lYnVmID0gXCJcIjtcbiAgICBhdHRyaWJ1dGVzLmxlbmd0aCA9IDA7XG4gIH1cblxuICBmdW5jdGlvbiBiZWdpblRlbXBCdWYoKSB7IHRlbXBidWYubGVuZ3RoID0gMDsgfVxuICBmdW5jdGlvbiBiZWdpbkF0dHJOYW1lKCkgeyBhdHRybmFtZWJ1ZiA9IFwiXCI7IH1cbiAgZnVuY3Rpb24gYmVnaW5BdHRyVmFsdWUoKSB7IGF0dHJ2YWx1ZWJ1ZiA9IFwiXCI7IH1cbiAgZnVuY3Rpb24gYmVnaW5Db21tZW50KCkgeyBjb21tZW50YnVmLmxlbmd0aCA9IDA7IH1cbiAgZnVuY3Rpb24gYmVnaW5Eb2N0eXBlKCkge1xuICAgIGRvY3R5cGVuYW1lYnVmLmxlbmd0aCA9IDA7XG4gICAgZG9jdHlwZXB1YmxpY2J1ZiA9IG51bGw7XG4gICAgZG9jdHlwZXN5c3RlbWJ1ZiA9IG51bGw7XG4gIH1cbiAgZnVuY3Rpb24gYmVnaW5Eb2N0eXBlUHVibGljSWQoKSB7IGRvY3R5cGVwdWJsaWNidWYgPSBbXTsgfVxuICBmdW5jdGlvbiBiZWdpbkRvY3R5cGVTeXN0ZW1JZCgpIHsgZG9jdHlwZXN5c3RlbWJ1ZiA9IFtdOyB9XG4gIGZ1bmN0aW9uIGZvcmNlcXVpcmtzKCkgeyBmb3JjZV9xdWlya3MgPSB0cnVlOyB9XG4gIGZ1bmN0aW9uIGNkYXRhQWxsb3dlZCgpIHtcbiAgICByZXR1cm4gc3RhY2sudG9wICYmXG4gICAgICBzdGFjay50b3AubmFtZXNwYWNlVVJJICE9PSBcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWxcIjtcbiAgfVxuXG4gIC8vIFJldHVybiB0cnVlIGlmIHRoZSBjb2RlcG9pbnRzIGluIHRoZSBzcGVjaWZpZWQgYnVmZmVyIG1hdGNoIHRoZVxuICAvLyBjaGFyYWN0ZXJzIG9mIGxhc3R0YWduYW1lXG4gIGZ1bmN0aW9uIGFwcHJvcHJpYXRlRW5kVGFnKGJ1Zikge1xuICAgIHJldHVybiBsYXN0dGFnbmFtZSA9PT0gYnVmO1xuICB9XG5cbiAgZnVuY3Rpb24gZmx1c2hUZXh0KCkge1xuICAgIGlmICh0ZXh0cnVuLmxlbmd0aCA+IDApIHtcbiAgICAgIHZhciBzID0gYnVmMnN0cih0ZXh0cnVuKTtcbiAgICAgIHRleHRydW4ubGVuZ3RoID0gMDtcblxuICAgICAgaWYgKGlnbm9yZV9saW5lZmVlZCkge1xuICAgICAgICBpZ25vcmVfbGluZWZlZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKHNbMF0gPT09IFwiXFxuXCIpIHMgPSBzLnN1YnN0cmluZygxKTtcbiAgICAgICAgaWYgKHMubGVuZ3RoID09PSAwKSByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGluc2VydFRva2VuKFRFWFQsIHMpO1xuICAgICAgdGV4dEluY2x1ZGVzTlVMID0gZmFsc2U7XG4gICAgfVxuICAgIGlnbm9yZV9saW5lZmVlZCA9IGZhbHNlO1xuICB9XG5cbiAgLy8gQ29uc3VtZSBjaGFycyBtYXRjaGVkIGJ5IHRoZSBwYXR0ZXJuIGFuZCByZXR1cm4gdGhlbSBhcyBhIHN0cmluZy4gU3RhcnRzXG4gIC8vIG1hdGNoaW5nIGF0IHRoZSBjdXJyZW50IHBvc2l0aW9uLCBzbyB1c2VycyBzaG91bGQgZHJvcCB0aGUgY3VycmVudCBjaGFyXG4gIC8vIG90aGVyd2lzZS5cbiAgZnVuY3Rpb24gZ2V0TWF0Y2hpbmdDaGFycyhwYXR0ZXJuKSB7XG4gICAgcGF0dGVybi5sYXN0SW5kZXggPSBuZXh0Y2hhciAtIDE7XG4gICAgdmFyIG1hdGNoID0gcGF0dGVybi5leGVjKGNoYXJzKTtcbiAgICBpZiAobWF0Y2ggJiYgbWF0Y2guaW5kZXggPT09IG5leHRjaGFyIC0gMSkge1xuICAgICAgbWF0Y2ggPSBtYXRjaFswXTtcbiAgICAgIG5leHRjaGFyICs9IG1hdGNoLmxlbmd0aCAtIDE7XG4gICAgICAvKiBDYXJlZnVsISAgTWFrZSBzdXJlIHdlIGhhdmVuJ3QgbWF0Y2hlZCB0aGUgRU9GIGNoYXJhY3RlciEgKi9cbiAgICAgIGlmIChpbnB1dF9jb21wbGV0ZSAmJiBuZXh0Y2hhciA9PT0gbnVtY2hhcnMpIHtcbiAgICAgICAgLy8gT29wcywgYmFja3VwIG9uZS5cbiAgICAgICAgbWF0Y2ggPSBtYXRjaC5zbGljZSgwLCAtMSk7XG4gICAgICAgIG5leHRjaGFyLS07XG4gICAgICB9XG4gICAgICByZXR1cm4gbWF0Y2g7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcInNob3VsZCBuZXZlciBoYXBwZW5cIik7XG4gICAgfVxuICB9XG5cbiAgLy8gZW1pdCBhIHN0cmluZyBvZiBjaGFycyB0aGF0IG1hdGNoIGEgcmVnZXhwXG4gIC8vIFJldHVybnMgZmFsc2UgaWYgbm8gY2hhcnMgbWF0Y2hlZC5cbiAgZnVuY3Rpb24gZW1pdENoYXJzV2hpbGUocGF0dGVybikge1xuICAgIHBhdHRlcm4ubGFzdEluZGV4ID0gbmV4dGNoYXItMTtcbiAgICB2YXIgbWF0Y2ggPSBwYXR0ZXJuLmV4ZWMoY2hhcnMpWzBdO1xuICAgIGlmICghbWF0Y2gpIHJldHVybiBmYWxzZTtcbiAgICBlbWl0Q2hhclN0cmluZyhtYXRjaCk7XG4gICAgbmV4dGNoYXIgKz0gbWF0Y2gubGVuZ3RoIC0gMTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIFRoaXMgaXMgdXNlZCBieSBDREFUQSBzZWN0aW9uc1xuICBmdW5jdGlvbiBlbWl0Q2hhclN0cmluZyhzKSB7XG4gICAgaWYgKHRleHRydW4ubGVuZ3RoID4gMCkgZmx1c2hUZXh0KCk7XG5cbiAgICBpZiAoaWdub3JlX2xpbmVmZWVkKSB7XG4gICAgICBpZ25vcmVfbGluZWZlZWQgPSBmYWxzZTtcbiAgICAgIGlmIChzWzBdID09PSBcIlxcblwiKSBzID0gcy5zdWJzdHJpbmcoMSk7XG4gICAgICBpZiAocy5sZW5ndGggPT09IDApIHJldHVybjtcbiAgICB9XG5cbiAgICBpbnNlcnRUb2tlbihURVhULCBzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGVtaXRUYWcoKSB7XG4gICAgaWYgKGlzX2VuZF90YWcpIGluc2VydFRva2VuKEVORFRBRywgdGFnbmFtZWJ1Zik7XG4gICAgZWxzZSB7XG4gICAgICAvLyBSZW1lbWJlciB0aGUgbGFzdCBvcGVuIHRhZyB3ZSBlbWl0dGVkXG4gICAgICB2YXIgdGFnbmFtZSA9IHRhZ25hbWVidWY7XG4gICAgICB0YWduYW1lYnVmID0gXCJcIjtcbiAgICAgIGxhc3R0YWduYW1lID0gdGFnbmFtZTtcbiAgICAgIGluc2VydFRva2VuKFRBRywgdGFnbmFtZSwgYXR0cmlidXRlcyk7XG4gICAgfVxuICB9XG5cblxuICAvLyBBIHNob3J0Y3V0OiBsb29rIGFoZWFkIGFuZCBpZiB0aGlzIGlzIGEgb3BlbiBvciBjbG9zZSB0YWdcbiAgLy8gaW4gbG93ZXJjYXNlIHdpdGggbm8gc3BhY2VzIGFuZCBubyBhdHRyaWJ1dGVzLCBqdXN0IGVtaXQgaXQgbm93LlxuICBmdW5jdGlvbiBlbWl0U2ltcGxlVGFnKCkge1xuICAgIFNJTVBMRVRBRy5sYXN0SW5kZXggPSBuZXh0Y2hhcjtcbiAgICB2YXIgbWF0Y2hlZCA9IFNJTVBMRVRBRy5leGVjKGNoYXJzKTtcbiAgICBpZiAoIW1hdGNoZWQpIHRocm93IG5ldyBFcnJvcihcInNob3VsZCBuZXZlciBoYXBwZW5cIik7XG4gICAgdmFyIHRhZ25hbWUgPSBtYXRjaGVkWzJdO1xuICAgIGlmICghdGFnbmFtZSkgcmV0dXJuIGZhbHNlO1xuICAgIHZhciBlbmR0YWcgPSBtYXRjaGVkWzFdO1xuICAgIGlmIChlbmR0YWcpIHtcbiAgICAgIG5leHRjaGFyICs9ICh0YWduYW1lLmxlbmd0aCsyKTtcbiAgICAgIGluc2VydFRva2VuKEVORFRBRywgdGFnbmFtZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgbmV4dGNoYXIgKz0gKHRhZ25hbWUubGVuZ3RoKzEpO1xuICAgICAgbGFzdHRhZ25hbWUgPSB0YWduYW1lO1xuICAgICAgaW5zZXJ0VG9rZW4oVEFHLCB0YWduYW1lLCBOT0FUVFJTKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBmdW5jdGlvbiBlbWl0U2VsZkNsb3NpbmdUYWcoKSB7XG4gICAgaWYgKGlzX2VuZF90YWcpIGluc2VydFRva2VuKEVORFRBRywgdGFnbmFtZWJ1ZiwgbnVsbCwgdHJ1ZSk7XG4gICAgZWxzZSB7XG4gICAgICBpbnNlcnRUb2tlbihUQUcsIHRhZ25hbWVidWYsIGF0dHJpYnV0ZXMsIHRydWUpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGVtaXREb2N0eXBlKCkge1xuICAgIGluc2VydFRva2VuKERPQ1RZUEUsXG4gICAgICAgICAgYnVmMnN0cihkb2N0eXBlbmFtZWJ1ZiksXG4gICAgICAgICAgZG9jdHlwZXB1YmxpY2J1ZiA/IGJ1ZjJzdHIoZG9jdHlwZXB1YmxpY2J1ZikgOiB1bmRlZmluZWQsXG4gICAgICAgICAgZG9jdHlwZXN5c3RlbWJ1ZiA/IGJ1ZjJzdHIoZG9jdHlwZXN5c3RlbWJ1ZikgOiB1bmRlZmluZWQpO1xuICB9XG5cbiAgZnVuY3Rpb24gZW1pdEVPRigpIHtcbiAgICBmbHVzaFRleHQoKTtcbiAgICBwYXJzZXIoRU9GKTsgLy8gRU9GIG5ldmVyIGdvZXMgdG8gaW5zZXJ0Rm9yZWlnbkNvbnRlbnQoKVxuICAgIGRvYy5tb2RjbG9jayA9IDE7IC8vIFN0YXJ0IHRyYWNraW5nIG1vZGlmaWNhdGlvbnNcbiAgfVxuXG4gIC8vIEluc2VydCBhIHRva2VuLCBlaXRoZXIgdXNpbmcgdGhlIGN1cnJlbnQgcGFyc2VyIGluc2VydGlvbiBtb2RlXG4gIC8vIChmb3IgSFRNTCBzdHVmZikgb3IgdXNpbmcgdGhlIGluc2VydEZvcmVpZ25Ub2tlbigpIG1ldGhvZC5cbiAgdmFyIGluc2VydFRva2VuID0gaHRtbHBhcnNlci5pbnNlcnRUb2tlbiA9IGZ1bmN0aW9uIGluc2VydFRva2VuKHQsIHZhbHVlLCBhcmczLCBhcmc0KSB7XG4gICAgZmx1c2hUZXh0KCk7XG4gICAgdmFyIGN1cnJlbnQgPSBzdGFjay50b3A7XG5cbiAgICBpZiAoIWN1cnJlbnQgfHwgY3VycmVudC5uYW1lc3BhY2VVUkkgPT09IE5BTUVTUEFDRS5IVE1MKSB7XG4gICAgICAvLyBUaGlzIGlzIHRoZSBjb21tb24gY2FzZVxuICAgICAgcGFyc2VyKHQsIHZhbHVlLCBhcmczLCBhcmc0KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAvLyBPdGhlcndpc2Ugd2UgbWF5IG5lZWQgdG8gaW5zZXJ0IHRoaXMgdG9rZW4gYXMgZm9yZWlnbiBjb250ZW50XG4gICAgICBpZiAodCAhPT0gVEFHICYmIHQgIT09IFRFWFQpIHtcbiAgICAgICAgaW5zZXJ0Rm9yZWlnblRva2VuKHQsIHZhbHVlLCBhcmczLCBhcmc0KTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAvLyBCdXQgaW4gc29tZSBjYXNlcyB3ZSB0cmVhdCBpdCBhcyByZWd1bGFyIGNvbnRlbnRcbiAgICAgICAgaWYgKChpc01hdGhtbFRleHRJbnRlZ3JhdGlvblBvaW50KGN1cnJlbnQpICYmXG4gICAgICAgICAgICh0ID09PSBURVhUIHx8XG4gICAgICAgICAgICAodCA9PT0gVEFHICYmXG4gICAgICAgICAgICAgdmFsdWUgIT09IFwibWdseXBoXCIgJiYgdmFsdWUgIT09IFwibWFsaWdubWFya1wiKSkpIHx8XG4gICAgICAgICAgKHQgPT09IFRBRyAmJlxuICAgICAgICAgICB2YWx1ZSA9PT0gXCJzdmdcIiAmJlxuICAgICAgICAgICBjdXJyZW50Lm5hbWVzcGFjZVVSSSA9PT0gTkFNRVNQQUNFLk1BVEhNTCAmJlxuICAgICAgICAgICBjdXJyZW50LmxvY2FsTmFtZSA9PT0gXCJhbm5vdGF0aW9uLXhtbFwiKSB8fFxuICAgICAgICAgIGlzSFRNTEludGVncmF0aW9uUG9pbnQoY3VycmVudCkpIHtcblxuICAgICAgICAgIC8vIFhYWDogdGhlIHRleHRfaW50ZWdyYXRpb25fbW9kZSBzdHVmZiBpcyBhblxuICAgICAgICAgIC8vIGF0dGVtcHRlZCBidWcgd29ya2Fyb3VuZCBvZiBtaW5lXG4gICAgICAgICAgdGV4dF9pbnRlZ3JhdGlvbl9tb2RlID0gdHJ1ZTtcbiAgICAgICAgICBwYXJzZXIodCwgdmFsdWUsIGFyZzMsIGFyZzQpO1xuICAgICAgICAgIHRleHRfaW50ZWdyYXRpb25fbW9kZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIE90aGVyd2lzZSBpdCBpcyBmb3JlaWduIGNvbnRlbnRcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgaW5zZXJ0Rm9yZWlnblRva2VuKHQsIHZhbHVlLCBhcmczLCBhcmc0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuXG4gIC8qKipcbiAgICogVHJlZSBidWlsZGluZyB1dGlsaXR5IGZ1bmN0aW9uc1xuICAgKi9cbiAgZnVuY3Rpb24gaW5zZXJ0Q29tbWVudChkYXRhKSB7XG4gICAgdmFyIHBhcmVudCA9IHN0YWNrLnRvcDtcbiAgICBpZiAoZm9zdGVyX3BhcmVudF9tb2RlICYmIGlzQShwYXJlbnQsIHRhYmxlc2VjdGlvbnJvd1NldCkpIHtcbiAgICAgIGZvc3RlclBhcmVudChmdW5jdGlvbihkb2MpIHsgcmV0dXJuIGRvYy5jcmVhdGVDb21tZW50KGRhdGEpOyB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gXCJJZiB0aGUgYWRqdXN0ZWQgaW5zZXJ0aW9uIGxvY2F0aW9uIGlzIGluc2lkZSBhIHRlbXBsYXRlIGVsZW1lbnQsXG4gICAgICAvLyBsZXQgaXQgaW5zdGVhZCBiZSBpbnNpZGUgdGhlIHRlbXBsYXRlIGVsZW1lbnQncyB0ZW1wbGF0ZSBjb250ZW50c1wiXG4gICAgICBpZiAocGFyZW50IGluc3RhbmNlb2YgaW1wbC5IVE1MVGVtcGxhdGVFbGVtZW50KSB7XG4gICAgICAgIHBhcmVudCA9IHBhcmVudC5jb250ZW50O1xuICAgICAgfVxuICAgICAgcGFyZW50Ll9hcHBlbmRDaGlsZChwYXJlbnQub3duZXJEb2N1bWVudC5jcmVhdGVDb21tZW50KGRhdGEpKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbnNlcnRUZXh0KHMpIHtcbiAgICB2YXIgcGFyZW50ID0gc3RhY2sudG9wO1xuICAgIGlmIChmb3N0ZXJfcGFyZW50X21vZGUgJiYgaXNBKHBhcmVudCwgdGFibGVzZWN0aW9ucm93U2V0KSkge1xuICAgICAgZm9zdGVyUGFyZW50KGZ1bmN0aW9uKGRvYykgeyByZXR1cm4gZG9jLmNyZWF0ZVRleHROb2RlKHMpOyB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gXCJJZiB0aGUgYWRqdXN0ZWQgaW5zZXJ0aW9uIGxvY2F0aW9uIGlzIGluc2lkZSBhIHRlbXBsYXRlIGVsZW1lbnQsXG4gICAgICAvLyBsZXQgaXQgaW5zdGVhZCBiZSBpbnNpZGUgdGhlIHRlbXBsYXRlIGVsZW1lbnQncyB0ZW1wbGF0ZSBjb250ZW50c1wiXG4gICAgICBpZiAocGFyZW50IGluc3RhbmNlb2YgaW1wbC5IVE1MVGVtcGxhdGVFbGVtZW50KSB7XG4gICAgICAgIHBhcmVudCA9IHBhcmVudC5jb250ZW50O1xuICAgICAgfVxuICAgICAgLy8gXCJJZiB0aGVyZSBpcyBhIFRleHQgbm9kZSBpbW1lZGlhdGVseSBiZWZvcmUgdGhlIGFkanVzdGVkIGluc2VydGlvblxuICAgICAgLy8gbG9jYXRpb24sIHRoZW4gYXBwZW5kIGRhdGEgdG8gdGhhdCBUZXh0IG5vZGUncyBkYXRhLlwiXG4gICAgICB2YXIgbGFzdENoaWxkID0gcGFyZW50Lmxhc3RDaGlsZDtcbiAgICAgIGlmIChsYXN0Q2hpbGQgJiYgbGFzdENoaWxkLm5vZGVUeXBlID09PSBOb2RlLlRFWFRfTk9ERSkge1xuICAgICAgICBsYXN0Q2hpbGQuYXBwZW5kRGF0YShzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcmVudC5fYXBwZW5kQ2hpbGQocGFyZW50Lm93bmVyRG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUocykpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUhUTUxFbHQoZG9jLCBuYW1lLCBhdHRycykge1xuICAgIC8vIENyZWF0ZSB0aGUgZWxlbWVudCB0aGlzIHdheSwgcmF0aGVyIHRoYW4gd2l0aFxuICAgIC8vIGRvYy5jcmVhdGVFbGVtZW50IGJlY2F1c2UgY3JlYXRlRWxlbWVudCgpIGRvZXMgZXJyb3JcbiAgICAvLyBjaGVja2luZyBvbiB0aGUgZWxlbWVudCBuYW1lIHRoYXQgd2UgbmVlZCB0byBhdm9pZCBoZXJlLlxuICAgIHZhciBlbHQgPSBodG1sLmNyZWF0ZUVsZW1lbnQoZG9jLCBuYW1lLCBudWxsKTtcblxuICAgIGlmIChhdHRycykge1xuICAgICAgZm9yKHZhciBpID0gMCwgbiA9IGF0dHJzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAvLyBVc2UgdGhlIF8gdmVyc2lvbiB0byBhdm9pZCB0ZXN0aW5nIHRoZSB2YWxpZGl0eVxuICAgICAgICAvLyBvZiB0aGUgYXR0cmlidXRlIG5hbWVcbiAgICAgICAgZWx0Ll9zZXRBdHRyaWJ1dGUoYXR0cnNbaV1bMF0sIGF0dHJzW2ldWzFdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gWFhYXG4gICAgLy8gSWYgdGhlIGVsZW1lbnQgaXMgYSByZXNldHRhYmxlIGZvcm0gZWxlbWVudCxcbiAgICAvLyBydW4gaXRzIHJlc2V0IGFsZ29yaXRobSBub3dcbiAgICAvLyBYWFhcbiAgICAvLyBoYW5kbGUgY2FzZSB3aGVyZSBmb3JtLWVsZW1lbnQtcG9pbnRlciBpcyBub3QgbnVsbFxuICAgIHJldHVybiBlbHQ7XG4gIH1cblxuICAvLyBUaGUgaW5fdGFibGUgaW5zZXJ0aW9uIG1vZGUgdHVybnMgb24gdGhpcyBmbGFnLCBhbmQgdGhhdCBtYWtlc1xuICAvLyBpbnNlcnRIVE1MRWxlbWVudCB1c2UgdGhlIGZvc3RlciBwYXJlbnRpbmcgYWxnb3JpdGhtIGZvciBlbGVtZW50c1xuICAvLyB0YWdzIGluc2lkZSBhIHRhYmxlXG4gIHZhciBmb3N0ZXJfcGFyZW50X21vZGUgPSBmYWxzZTtcblxuICBmdW5jdGlvbiBpbnNlcnRIVE1MRWxlbWVudChuYW1lLCBhdHRycykge1xuICAgIHZhciBlbHQgPSBpbnNlcnRFbGVtZW50KGZ1bmN0aW9uKGRvYykge1xuICAgICAgcmV0dXJuIGNyZWF0ZUhUTUxFbHQoZG9jLCBuYW1lLCBhdHRycyk7XG4gICAgfSk7XG5cbiAgICAvLyBYWFhcbiAgICAvLyBJZiB0aGlzIGlzIGEgZm9ybSBlbGVtZW50LCBzZXQgaXRzIGZvcm0gYXR0cmlidXRlIHByb3BlcnR5IGhlcmVcbiAgICBpZiAoaXNBKGVsdCwgZm9ybWFzc29jaWF0ZWRTZXQpKSB7XG4gICAgICBlbHQuX2Zvcm0gPSBmb3JtX2VsZW1lbnRfcG9pbnRlcjtcbiAgICB9XG5cbiAgICByZXR1cm4gZWx0O1xuICB9XG5cbiAgLy8gSW5zZXJ0IHRoZSBlbGVtZW50IGludG8gdGhlIG9wZW4gZWxlbWVudCBvciBmb3N0ZXIgcGFyZW50IGl0XG4gIGZ1bmN0aW9uIGluc2VydEVsZW1lbnQoZWx0RnVuYykge1xuICAgIHZhciBlbHQ7XG4gICAgaWYgKGZvc3Rlcl9wYXJlbnRfbW9kZSAmJiBpc0Eoc3RhY2sudG9wLCB0YWJsZXNlY3Rpb25yb3dTZXQpKSB7XG4gICAgICBlbHQgPSBmb3N0ZXJQYXJlbnQoZWx0RnVuYyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHN0YWNrLnRvcCBpbnN0YW5jZW9mIGltcGwuSFRNTFRlbXBsYXRlRWxlbWVudCkge1xuICAgICAgLy8gXCJJZiB0aGUgYWRqdXN0ZWQgaW5zZXJ0aW9uIGxvY2F0aW9uIGlzIGluc2lkZSBhIHRlbXBsYXRlIGVsZW1lbnQsXG4gICAgICAvLyBsZXQgaXQgaW5zdGVhZCBiZSBpbnNpZGUgdGhlIHRlbXBsYXRlIGVsZW1lbnQncyB0ZW1wbGF0ZSBjb250ZW50c1wiXG4gICAgICBlbHQgPSBlbHRGdW5jKHN0YWNrLnRvcC5jb250ZW50Lm93bmVyRG9jdW1lbnQpO1xuICAgICAgc3RhY2sudG9wLmNvbnRlbnQuX2FwcGVuZENoaWxkKGVsdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsdCA9IGVsdEZ1bmMoc3RhY2sudG9wLm93bmVyRG9jdW1lbnQpO1xuICAgICAgc3RhY2sudG9wLl9hcHBlbmRDaGlsZChlbHQpO1xuICAgIH1cblxuICAgIHN0YWNrLnB1c2goZWx0KTtcbiAgICByZXR1cm4gZWx0O1xuICB9XG5cbiAgZnVuY3Rpb24gaW5zZXJ0Rm9yZWlnbkVsZW1lbnQobmFtZSwgYXR0cnMsIG5zKSB7XG4gICAgcmV0dXJuIGluc2VydEVsZW1lbnQoZnVuY3Rpb24oZG9jKSB7XG4gICAgICB2YXIgZWx0ID0gZG9jLmNyZWF0ZUVsZW1lbnROUyhucywgbmFtZSk7XG4gICAgICBpZiAoYXR0cnMpIHtcbiAgICAgICAgZm9yKHZhciBpID0gMCwgbiA9IGF0dHJzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgIHZhciBhdHRyID0gYXR0cnNbaV07XG4gICAgICAgICAgaWYgKGF0dHIubGVuZ3RoID09PSAyKVxuICAgICAgICAgICAgZWx0Ll9zZXRBdHRyaWJ1dGUoYXR0clswXSwgYXR0clsxXSk7XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBlbHQuX3NldEF0dHJpYnV0ZU5TKGF0dHJbMl0sIGF0dHJbMF0sIGF0dHJbMV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGVsdDtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGxhc3RFbGVtZW50T2ZUeXBlKHR5cGUpIHtcbiAgICBmb3IodmFyIGkgPSBzdGFjay5lbGVtZW50cy5sZW5ndGgtMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGlmIChzdGFjay5lbGVtZW50c1tpXSBpbnN0YW5jZW9mIHR5cGUpIHtcbiAgICAgICAgcmV0dXJuIGk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvc3RlclBhcmVudChlbHRGdW5jKSB7XG4gICAgdmFyIHBhcmVudCwgYmVmb3JlLCBsYXN0VGFibGUgPSAtMSwgbGFzdFRlbXBsYXRlID0gLTEsIGVsdDtcblxuICAgIGxhc3RUYWJsZSA9IGxhc3RFbGVtZW50T2ZUeXBlKGltcGwuSFRNTFRhYmxlRWxlbWVudCk7XG4gICAgbGFzdFRlbXBsYXRlID0gbGFzdEVsZW1lbnRPZlR5cGUoaW1wbC5IVE1MVGVtcGxhdGVFbGVtZW50KTtcblxuICAgIGlmIChsYXN0VGVtcGxhdGUgPj0gMCAmJiAobGFzdFRhYmxlIDwgMCB8fCBsYXN0VGVtcGxhdGUgPiBsYXN0VGFibGUpKSB7XG4gICAgICBwYXJlbnQgPSBzdGFjay5lbGVtZW50c1tsYXN0VGVtcGxhdGVdO1xuICAgIH0gZWxzZSBpZiAobGFzdFRhYmxlID49IDApIHtcbiAgICAgIHBhcmVudCA9IHN0YWNrLmVsZW1lbnRzW2xhc3RUYWJsZV0ucGFyZW50Tm9kZTtcbiAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgYmVmb3JlID0gc3RhY2suZWxlbWVudHNbbGFzdFRhYmxlXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcmVudCA9IHN0YWNrLmVsZW1lbnRzW2xhc3RUYWJsZSAtIDFdO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXBhcmVudCkgcGFyZW50ID0gc3RhY2suZWxlbWVudHNbMF07IC8vIHRoZSBgaHRtbGAgZWxlbWVudC5cblxuICAgIC8vIFwiSWYgdGhlIGFkanVzdGVkIGluc2VydGlvbiBsb2NhdGlvbiBpcyBpbnNpZGUgYSB0ZW1wbGF0ZSBlbGVtZW50LFxuICAgIC8vIGxldCBpdCBpbnN0ZWFkIGJlIGluc2lkZSB0aGUgdGVtcGxhdGUgZWxlbWVudCdzIHRlbXBsYXRlIGNvbnRlbnRzXCJcbiAgICBpZiAocGFyZW50IGluc3RhbmNlb2YgaW1wbC5IVE1MVGVtcGxhdGVFbGVtZW50KSB7XG4gICAgICBwYXJlbnQgPSBwYXJlbnQuY29udGVudDtcbiAgICB9XG4gICAgLy8gQ3JlYXRlIGVsZW1lbnQgaW4gdGhlIGFwcHJvcHJpYXRlIGRvY3VtZW50LlxuICAgIGVsdCA9IGVsdEZ1bmMocGFyZW50Lm93bmVyRG9jdW1lbnQpO1xuXG4gICAgaWYgKGVsdC5ub2RlVHlwZSA9PT0gTm9kZS5URVhUX05PREUpIHtcbiAgICAgIHZhciBwcmV2O1xuICAgICAgaWYgKGJlZm9yZSkgcHJldiA9IGJlZm9yZS5wcmV2aW91c1NpYmxpbmc7XG4gICAgICBlbHNlIHByZXYgPSBwYXJlbnQubGFzdENoaWxkO1xuICAgICAgaWYgKHByZXYgJiYgcHJldi5ub2RlVHlwZSA9PT0gTm9kZS5URVhUX05PREUpIHtcbiAgICAgICAgcHJldi5hcHBlbmREYXRhKGVsdC5kYXRhKTtcbiAgICAgICAgcmV0dXJuIGVsdDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGJlZm9yZSlcbiAgICAgIHBhcmVudC5pbnNlcnRCZWZvcmUoZWx0LCBiZWZvcmUpO1xuICAgIGVsc2VcbiAgICAgIHBhcmVudC5fYXBwZW5kQ2hpbGQoZWx0KTtcbiAgICByZXR1cm4gZWx0O1xuICB9XG5cblxuICBmdW5jdGlvbiByZXNldEluc2VydGlvbk1vZGUoKSB7XG4gICAgdmFyIGxhc3QgPSBmYWxzZTtcbiAgICBmb3IodmFyIGkgPSBzdGFjay5lbGVtZW50cy5sZW5ndGgtMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciBub2RlID0gc3RhY2suZWxlbWVudHNbaV07XG4gICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICBsYXN0ID0gdHJ1ZTtcbiAgICAgICAgaWYgKGZyYWdtZW50KSB7XG4gICAgICAgICAgbm9kZSA9IGZyYWdtZW50Q29udGV4dDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG5vZGUubmFtZXNwYWNlVVJJID09PSBOQU1FU1BBQ0UuSFRNTCkge1xuICAgICAgICB2YXIgdGFnID0gbm9kZS5sb2NhbE5hbWU7XG4gICAgICAgIHN3aXRjaCh0YWcpIHtcbiAgICAgICAgY2FzZSBcInNlbGVjdFwiOlxuICAgICAgICAgIGZvcih2YXIgaiA9IGk7IGogPiAwOyApIHtcbiAgICAgICAgICAgIHZhciBhbmNlc3RvciA9IHN0YWNrLmVsZW1lbnRzWy0tal07XG4gICAgICAgICAgICBpZiAoYW5jZXN0b3IgaW5zdGFuY2VvZiBpbXBsLkhUTUxUZW1wbGF0ZUVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGFuY2VzdG9yIGluc3RhbmNlb2YgaW1wbC5IVE1MVGFibGVFbGVtZW50KSB7XG4gICAgICAgICAgICAgIHBhcnNlciA9IGluX3NlbGVjdF9pbl90YWJsZV9tb2RlO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHBhcnNlciA9IGluX3NlbGVjdF9tb2RlO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY2FzZSBcInRyXCI6XG4gICAgICAgICAgcGFyc2VyID0gaW5fcm93X21vZGU7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjYXNlIFwidGJvZHlcIjpcbiAgICAgICAgY2FzZSBcInRmb290XCI6XG4gICAgICAgIGNhc2UgXCJ0aGVhZFwiOlxuICAgICAgICAgIHBhcnNlciA9IGluX3RhYmxlX2JvZHlfbW9kZTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNhc2UgXCJjYXB0aW9uXCI6XG4gICAgICAgICAgcGFyc2VyID0gaW5fY2FwdGlvbl9tb2RlO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY2FzZSBcImNvbGdyb3VwXCI6XG4gICAgICAgICAgcGFyc2VyID0gaW5fY29sdW1uX2dyb3VwX21vZGU7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjYXNlIFwidGFibGVcIjpcbiAgICAgICAgICBwYXJzZXIgPSBpbl90YWJsZV9tb2RlO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY2FzZSBcInRlbXBsYXRlXCI6XG4gICAgICAgICAgcGFyc2VyID0gdGVtcGxhdGVJbnNlcnRpb25Nb2Rlc1t0ZW1wbGF0ZUluc2VydGlvbk1vZGVzLmxlbmd0aC0xXTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNhc2UgXCJib2R5XCI6XG4gICAgICAgICAgcGFyc2VyID0gaW5fYm9keV9tb2RlO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY2FzZSBcImZyYW1lc2V0XCI6XG4gICAgICAgICAgcGFyc2VyID0gaW5fZnJhbWVzZXRfbW9kZTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNhc2UgXCJodG1sXCI6XG4gICAgICAgICAgaWYgKGhlYWRfZWxlbWVudF9wb2ludGVyID09PSBudWxsKSB7XG4gICAgICAgICAgICBwYXJzZXIgPSBiZWZvcmVfaGVhZF9tb2RlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYXJzZXIgPSBhZnRlcl9oZWFkX21vZGU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBpZiAoIWxhc3QpIHtcbiAgICAgICAgICAgIGlmICh0YWcgPT09IFwiaGVhZFwiKSB7XG4gICAgICAgICAgICAgIHBhcnNlciA9IGluX2hlYWRfbW9kZTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRhZyA9PT0gXCJ0ZFwiIHx8IHRhZyA9PT0gXCJ0aFwiKSB7XG4gICAgICAgICAgICAgIHBhcnNlciA9IGluX2NlbGxfbW9kZTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGxhc3QpIHtcbiAgICAgICAgcGFyc2VyID0gaW5fYm9keV9tb2RlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICB9XG5cblxuICBmdW5jdGlvbiBwYXJzZVJhd1RleHQobmFtZSwgYXR0cnMpIHtcbiAgICBpbnNlcnRIVE1MRWxlbWVudChuYW1lLCBhdHRycyk7XG4gICAgdG9rZW5pemVyID0gcmF3dGV4dF9zdGF0ZTtcbiAgICBvcmlnaW5hbEluc2VydGlvbk1vZGUgPSBwYXJzZXI7XG4gICAgcGFyc2VyID0gdGV4dF9tb2RlO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VSQ0RBVEEobmFtZSwgYXR0cnMpIHtcbiAgICBpbnNlcnRIVE1MRWxlbWVudChuYW1lLCBhdHRycyk7XG4gICAgdG9rZW5pemVyID0gcmNkYXRhX3N0YXRlO1xuICAgIG9yaWdpbmFsSW5zZXJ0aW9uTW9kZSA9IHBhcnNlcjtcbiAgICBwYXJzZXIgPSB0ZXh0X21vZGU7XG4gIH1cblxuICAvLyBNYWtlIGEgY29weSBvZiBlbGVtZW50IGkgb24gdGhlIGxpc3Qgb2YgYWN0aXZlIGZvcm1hdHRpbmdcbiAgLy8gZWxlbWVudHMsIHVzaW5nIGl0cyBvcmlnaW5hbCBhdHRyaWJ1dGVzLCBub3QgY3VycmVudFxuICAvLyBhdHRyaWJ1dGVzICh3aGljaCBtYXkgaGF2ZSBiZWVuIG1vZGlmaWVkIGJ5IGEgc2NyaXB0KVxuICBmdW5jdGlvbiBhZmVjbG9uZShkb2MsIGkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZWx0OiBjcmVhdGVIVE1MRWx0KGRvYywgYWZlLmxpc3RbaV0ubG9jYWxOYW1lLCBhZmUuYXR0cnNbaV0pLFxuICAgICAgYXR0cnM6IGFmZS5hdHRyc1tpXSxcbiAgICB9O1xuICB9XG5cblxuICBmdW5jdGlvbiBhZmVyZWNvbnN0cnVjdCgpIHtcbiAgICBpZiAoYWZlLmxpc3QubGVuZ3RoID09PSAwKSByZXR1cm47XG4gICAgdmFyIGVudHJ5ID0gYWZlLmxpc3RbYWZlLmxpc3QubGVuZ3RoLTFdO1xuICAgIC8vIElmIHRoZSBsYXN0IGlzIGEgbWFya2VyICwgZG8gbm90aGluZ1xuICAgIGlmIChlbnRyeSA9PT0gYWZlLk1BUktFUikgcmV0dXJuO1xuICAgIC8vIE9yIGlmIGl0IGlzIGFuIG9wZW4gZWxlbWVudCwgZG8gbm90aGluZ1xuICAgIGlmIChzdGFjay5lbGVtZW50cy5sYXN0SW5kZXhPZihlbnRyeSkgIT09IC0xKSByZXR1cm47XG5cbiAgICAvLyBMb29wIGJhY2t3YXJkIHRocm91Z2ggdGhlIGxpc3QgdW50aWwgd2UgZmluZCBhIG1hcmtlciBvciBhblxuICAgIC8vIG9wZW4gZWxlbWVudCwgYW5kIHRoZW4gbW92ZSBmb3J3YXJkIG9uZSBmcm9tIHRoZXJlLlxuICAgIGZvcih2YXIgaSA9IGFmZS5saXN0Lmxlbmd0aC0yOyBpID49IDA7IGktLSkge1xuICAgICAgZW50cnkgPSBhZmUubGlzdFtpXTtcbiAgICAgIGlmIChlbnRyeSA9PT0gYWZlLk1BUktFUikgYnJlYWs7XG4gICAgICBpZiAoc3RhY2suZWxlbWVudHMubGFzdEluZGV4T2YoZW50cnkpICE9PSAtMSkgYnJlYWs7XG4gICAgfVxuXG4gICAgLy8gTm93IGxvb3AgZm9yd2FyZCwgc3RhcnRpbmcgZnJvbSB0aGUgZWxlbWVudCBhZnRlciB0aGUgY3VycmVudFxuICAgIC8vIG9uZSwgcmVjcmVhdGluZyBmb3JtYXR0aW5nIGVsZW1lbnRzIGFuZCBwdXNoaW5nIHRoZW0gYmFjayBvbnRvXG4gICAgLy8gdGhlIGxpc3Qgb2Ygb3BlbiBlbGVtZW50c1xuICAgIGZvcihpID0gaSsxOyBpIDwgYWZlLmxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBuZXdlbHQgPSBpbnNlcnRFbGVtZW50KGZ1bmN0aW9uKGRvYykgeyByZXR1cm4gYWZlY2xvbmUoZG9jLCBpKS5lbHQ7IH0pO1xuICAgICAgYWZlLmxpc3RbaV0gPSBuZXdlbHQ7XG4gICAgfVxuICB9XG5cbiAgLy8gVXNlZCBieSB0aGUgYWRvcHRpb25BZ2VuY3koKSBmdW5jdGlvblxuICB2YXIgQk9PS01BUksgPSB7bG9jYWxOYW1lOlwiQk1cIn07XG5cbiAgZnVuY3Rpb24gYWRvcHRpb25BZ2VuY3kodGFnKSB7XG4gICAgLy8gSWYgdGhlIGN1cnJlbnQgbm9kZSBpcyBhbiBIVE1MIGVsZW1lbnQgd2hvc2UgdGFnIG5hbWUgaXMgc3ViamVjdCxcbiAgICAvLyBhbmQgdGhlIGN1cnJlbnQgbm9kZSBpcyBub3QgaW4gdGhlIGxpc3Qgb2YgYWN0aXZlIGZvcm1hdHRpbmdcbiAgICAvLyBlbGVtZW50cywgdGhlbiBwb3AgdGhlIGN1cnJlbnQgbm9kZSBvZmYgdGhlIHN0YWNrIG9mIG9wZW5cbiAgICAvLyBlbGVtZW50cyBhbmQgYWJvcnQgdGhlc2Ugc3RlcHMuXG4gICAgaWYgKGlzQShzdGFjay50b3AsIHRhZykgJiYgYWZlLmluZGV4T2Yoc3RhY2sudG9wKSA9PT0gLTEpIHtcbiAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgcmV0dXJuIHRydWU7IC8vIG5vIG1vcmUgaGFuZGxpbmcgcmVxdWlyZWRcbiAgICB9XG5cbiAgICAvLyBMZXQgb3V0ZXIgbG9vcCBjb3VudGVyIGJlIHplcm8uXG4gICAgdmFyIG91dGVyID0gMDtcblxuICAgIC8vIE91dGVyIGxvb3A6IElmIG91dGVyIGxvb3AgY291bnRlciBpcyBncmVhdGVyIHRoYW4gb3JcbiAgICAvLyBlcXVhbCB0byBlaWdodCwgdGhlbiBhYm9ydCB0aGVzZSBzdGVwcy5cbiAgICB3aGlsZShvdXRlciA8IDgpIHtcbiAgICAgIC8vIEluY3JlbWVudCBvdXRlciBsb29wIGNvdW50ZXIgYnkgb25lLlxuICAgICAgb3V0ZXIrKztcblxuICAgICAgLy8gTGV0IHRoZSBmb3JtYXR0aW5nIGVsZW1lbnQgYmUgdGhlIGxhc3QgZWxlbWVudCBpbiB0aGUgbGlzdFxuICAgICAgLy8gb2YgYWN0aXZlIGZvcm1hdHRpbmcgZWxlbWVudHMgdGhhdDogaXMgYmV0d2VlbiB0aGUgZW5kIG9mXG4gICAgICAvLyB0aGUgbGlzdCBhbmQgdGhlIGxhc3Qgc2NvcGUgbWFya2VyIGluIHRoZSBsaXN0LCBpZiBhbnksIG9yXG4gICAgICAvLyB0aGUgc3RhcnQgb2YgdGhlIGxpc3Qgb3RoZXJ3aXNlLCBhbmQgaGFzIHRoZSBzYW1lIHRhZyBuYW1lXG4gICAgICAvLyBhcyB0aGUgdG9rZW4uXG4gICAgICB2YXIgZm10ZWx0ID0gYWZlLmZpbmRFbGVtZW50QnlUYWcodGFnKTtcblxuICAgICAgLy8gSWYgdGhlcmUgaXMgbm8gc3VjaCBub2RlLCB0aGVuIGFib3J0IHRoZXNlIHN0ZXBzIGFuZCBpbnN0ZWFkXG4gICAgICAvLyBhY3QgYXMgZGVzY3JpYmVkIGluIHRoZSBcImFueSBvdGhlciBlbmQgdGFnXCIgZW50cnkgYmVsb3cuXG4gICAgICBpZiAoIWZtdGVsdCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7IC8vIGZhbHNlIG1lYW5zIGhhbmRsZSBieSB0aGUgZGVmYXVsdCBjYXNlXG4gICAgICB9XG5cbiAgICAgIC8vIE90aGVyd2lzZSwgaWYgdGhlcmUgaXMgc3VjaCBhIG5vZGUsIGJ1dCB0aGF0IG5vZGUgaXMgbm90IGluXG4gICAgICAvLyB0aGUgc3RhY2sgb2Ygb3BlbiBlbGVtZW50cywgdGhlbiB0aGlzIGlzIGEgcGFyc2UgZXJyb3I7XG4gICAgICAvLyByZW1vdmUgdGhlIGVsZW1lbnQgZnJvbSB0aGUgbGlzdCwgYW5kIGFib3J0IHRoZXNlIHN0ZXBzLlxuICAgICAgdmFyIGluZGV4ID0gc3RhY2suZWxlbWVudHMubGFzdEluZGV4T2YoZm10ZWx0KTtcbiAgICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgICAgYWZlLnJlbW92ZShmbXRlbHQpO1xuICAgICAgICByZXR1cm4gdHJ1ZTsgICAvLyB0cnVlIG1lYW5zIG5vIG1vcmUgaGFuZGxpbmcgcmVxdWlyZWRcbiAgICAgIH1cblxuICAgICAgLy8gT3RoZXJ3aXNlLCBpZiB0aGVyZSBpcyBzdWNoIGEgbm9kZSwgYW5kIHRoYXQgbm9kZSBpcyBhbHNvIGluXG4gICAgICAvLyB0aGUgc3RhY2sgb2Ygb3BlbiBlbGVtZW50cywgYnV0IHRoZSBlbGVtZW50IGlzIG5vdCBpbiBzY29wZSxcbiAgICAgIC8vIHRoZW4gdGhpcyBpcyBhIHBhcnNlIGVycm9yOyBpZ25vcmUgdGhlIHRva2VuLCBhbmQgYWJvcnRcbiAgICAgIC8vIHRoZXNlIHN0ZXBzLlxuICAgICAgaWYgKCFzdGFjay5lbGVtZW50SW5TY29wZShmbXRlbHQpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBMZXQgdGhlIGZ1cnRoZXN0IGJsb2NrIGJlIHRoZSB0b3Btb3N0IG5vZGUgaW4gdGhlIHN0YWNrIG9mXG4gICAgICAvLyBvcGVuIGVsZW1lbnRzIHRoYXQgaXMgbG93ZXIgaW4gdGhlIHN0YWNrIHRoYW4gdGhlIGZvcm1hdHRpbmdcbiAgICAgIC8vIGVsZW1lbnQsIGFuZCBpcyBhbiBlbGVtZW50IGluIHRoZSBzcGVjaWFsIGNhdGVnb3J5LiBUaGVyZVxuICAgICAgLy8gbWlnaHQgbm90IGJlIG9uZS5cbiAgICAgIHZhciBmdXJ0aGVzdGJsb2NrID0gbnVsbCwgZnVydGhlc3RibG9ja2luZGV4O1xuICAgICAgZm9yKHZhciBpID0gaW5kZXgrMTsgaSA8IHN0YWNrLmVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChpc0Eoc3RhY2suZWxlbWVudHNbaV0sIHNwZWNpYWxTZXQpKSB7XG4gICAgICAgICAgZnVydGhlc3RibG9jayA9IHN0YWNrLmVsZW1lbnRzW2ldO1xuICAgICAgICAgIGZ1cnRoZXN0YmxvY2tpbmRleCA9IGk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gSWYgdGhlcmUgaXMgbm8gZnVydGhlc3QgYmxvY2ssIHRoZW4gdGhlIFVBIG11c3Qgc2tpcCB0aGVcbiAgICAgIC8vIHN1YnNlcXVlbnQgc3RlcHMgYW5kIGluc3RlYWQganVzdCBwb3AgYWxsIHRoZSBub2RlcyBmcm9tIHRoZVxuICAgICAgLy8gYm90dG9tIG9mIHRoZSBzdGFjayBvZiBvcGVuIGVsZW1lbnRzLCBmcm9tIHRoZSBjdXJyZW50IG5vZGVcbiAgICAgIC8vIHVwIHRvIGFuZCBpbmNsdWRpbmcgdGhlIGZvcm1hdHRpbmcgZWxlbWVudCwgYW5kIHJlbW92ZSB0aGVcbiAgICAgIC8vIGZvcm1hdHRpbmcgZWxlbWVudCBmcm9tIHRoZSBsaXN0IG9mIGFjdGl2ZSBmb3JtYXR0aW5nXG4gICAgICAvLyBlbGVtZW50cy5cbiAgICAgIGlmICghZnVydGhlc3RibG9jaykge1xuICAgICAgICBzdGFjay5wb3BFbGVtZW50KGZtdGVsdCk7XG4gICAgICAgIGFmZS5yZW1vdmUoZm10ZWx0KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgLy8gTGV0IHRoZSBjb21tb24gYW5jZXN0b3IgYmUgdGhlIGVsZW1lbnQgaW1tZWRpYXRlbHkgYWJvdmVcbiAgICAgICAgLy8gdGhlIGZvcm1hdHRpbmcgZWxlbWVudCBpbiB0aGUgc3RhY2sgb2Ygb3BlbiBlbGVtZW50cy5cbiAgICAgICAgdmFyIGFuY2VzdG9yID0gc3RhY2suZWxlbWVudHNbaW5kZXgtMV07XG5cbiAgICAgICAgLy8gTGV0IGEgYm9va21hcmsgbm90ZSB0aGUgcG9zaXRpb24gb2YgdGhlIGZvcm1hdHRpbmdcbiAgICAgICAgLy8gZWxlbWVudCBpbiB0aGUgbGlzdCBvZiBhY3RpdmUgZm9ybWF0dGluZyBlbGVtZW50c1xuICAgICAgICAvLyByZWxhdGl2ZSB0byB0aGUgZWxlbWVudHMgb24gZWl0aGVyIHNpZGUgb2YgaXQgaW4gdGhlXG4gICAgICAgIC8vIGxpc3QuXG4gICAgICAgIGFmZS5pbnNlcnRBZnRlcihmbXRlbHQsIEJPT0tNQVJLKTtcblxuICAgICAgICAvLyBMZXQgbm9kZSBhbmQgbGFzdCBub2RlIGJlIHRoZSBmdXJ0aGVzdCBibG9jay5cbiAgICAgICAgdmFyIG5vZGUgPSBmdXJ0aGVzdGJsb2NrO1xuICAgICAgICB2YXIgbGFzdG5vZGUgPSBmdXJ0aGVzdGJsb2NrO1xuICAgICAgICB2YXIgbm9kZWluZGV4ID0gZnVydGhlc3RibG9ja2luZGV4O1xuICAgICAgICB2YXIgbm9kZWFmZWluZGV4O1xuXG4gICAgICAgIC8vIExldCBpbm5lciBsb29wIGNvdW50ZXIgYmUgemVyby5cbiAgICAgICAgdmFyIGlubmVyID0gMDtcblxuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuXG4gICAgICAgICAgLy8gSW5jcmVtZW50IGlubmVyIGxvb3AgY291bnRlciBieSBvbmUuXG4gICAgICAgICAgaW5uZXIrKztcblxuICAgICAgICAgIC8vIExldCBub2RlIGJlIHRoZSBlbGVtZW50IGltbWVkaWF0ZWx5IGFib3ZlIG5vZGUgaW5cbiAgICAgICAgICAvLyB0aGUgc3RhY2sgb2Ygb3BlbiBlbGVtZW50cywgb3IgaWYgbm9kZSBpcyBubyBsb25nZXJcbiAgICAgICAgICAvLyBpbiB0aGUgc3RhY2sgb2Ygb3BlbiBlbGVtZW50cyAoZS5nLiBiZWNhdXNlIGl0IGdvdFxuICAgICAgICAgIC8vIHJlbW92ZWQgYnkgdGhpcyBhbGdvcml0aG0pLCB0aGUgZWxlbWVudCB0aGF0IHdhc1xuICAgICAgICAgIC8vIGltbWVkaWF0ZWx5IGFib3ZlIG5vZGUgaW4gdGhlIHN0YWNrIG9mIG9wZW4gZWxlbWVudHNcbiAgICAgICAgICAvLyBiZWZvcmUgbm9kZSB3YXMgcmVtb3ZlZC5cbiAgICAgICAgICBub2RlID0gc3RhY2suZWxlbWVudHNbLS1ub2RlaW5kZXhdO1xuXG4gICAgICAgICAgLy8gSWYgbm9kZSBpcyB0aGUgZm9ybWF0dGluZyBlbGVtZW50LCB0aGVuIGdvXG4gICAgICAgICAgLy8gdG8gdGhlIG5leHQgc3RlcCBpbiB0aGUgb3ZlcmFsbCBhbGdvcml0aG0uXG4gICAgICAgICAgaWYgKG5vZGUgPT09IGZtdGVsdCkgYnJlYWs7XG5cbiAgICAgICAgICAvLyBJZiB0aGUgaW5uZXIgbG9vcCBjb3VudGVyIGlzIGdyZWF0ZXIgdGhhbiB0aHJlZSBhbmQgbm9kZVxuICAgICAgICAgIC8vIGlzIGluIHRoZSBsaXN0IG9mIGFjdGl2ZSBmb3JtYXR0aW5nIGVsZW1lbnRzLCB0aGVuIHJlbW92ZVxuICAgICAgICAgIC8vIG5vZGUgZnJvbSB0aGUgbGlzdCBvZiBhY3RpdmUgZm9ybWF0dGluZyBlbGVtZW50cy5cbiAgICAgICAgICBub2RlYWZlaW5kZXggPSBhZmUuaW5kZXhPZihub2RlKTtcbiAgICAgICAgICBpZiAoaW5uZXIgPiAzICYmIG5vZGVhZmVpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgIGFmZS5yZW1vdmUobm9kZSk7XG4gICAgICAgICAgICBub2RlYWZlaW5kZXggPSAtMTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBJZiBub2RlIGlzIG5vdCBpbiB0aGUgbGlzdCBvZiBhY3RpdmUgZm9ybWF0dGluZ1xuICAgICAgICAgIC8vIGVsZW1lbnRzLCB0aGVuIHJlbW92ZSBub2RlIGZyb20gdGhlIHN0YWNrIG9mIG9wZW5cbiAgICAgICAgICAvLyBlbGVtZW50cyBhbmQgdGhlbiBnbyBiYWNrIHRvIHRoZSBzdGVwIGxhYmVsZWQgaW5uZXJcbiAgICAgICAgICAvLyBsb29wLlxuICAgICAgICAgIGlmIChub2RlYWZlaW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICBzdGFjay5yZW1vdmVFbGVtZW50KG5vZGUpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gQ3JlYXRlIGFuIGVsZW1lbnQgZm9yIHRoZSB0b2tlbiBmb3Igd2hpY2ggdGhlXG4gICAgICAgICAgLy8gZWxlbWVudCBub2RlIHdhcyBjcmVhdGVkIHdpdGggY29tbW9uIGFuY2VzdG9yIGFzXG4gICAgICAgICAgLy8gdGhlIGludGVuZGVkIHBhcmVudCwgcmVwbGFjZSB0aGUgZW50cnkgZm9yIG5vZGVcbiAgICAgICAgICAvLyBpbiB0aGUgbGlzdCBvZiBhY3RpdmUgZm9ybWF0dGluZyBlbGVtZW50cyB3aXRoIGFuXG4gICAgICAgICAgLy8gZW50cnkgZm9yIHRoZSBuZXcgZWxlbWVudCwgcmVwbGFjZSB0aGUgZW50cnkgZm9yXG4gICAgICAgICAgLy8gbm9kZSBpbiB0aGUgc3RhY2sgb2Ygb3BlbiBlbGVtZW50cyB3aXRoIGFuIGVudHJ5IGZvclxuICAgICAgICAgIC8vIHRoZSBuZXcgZWxlbWVudCwgYW5kIGxldCBub2RlIGJlIHRoZSBuZXcgZWxlbWVudC5cbiAgICAgICAgICB2YXIgbmV3ZWx0ID0gYWZlY2xvbmUoYW5jZXN0b3Iub3duZXJEb2N1bWVudCwgbm9kZWFmZWluZGV4KTtcbiAgICAgICAgICBhZmUucmVwbGFjZShub2RlLCBuZXdlbHQuZWx0LCBuZXdlbHQuYXR0cnMpO1xuICAgICAgICAgIHN0YWNrLmVsZW1lbnRzW25vZGVpbmRleF0gPSBuZXdlbHQuZWx0O1xuICAgICAgICAgIG5vZGUgPSBuZXdlbHQuZWx0O1xuXG4gICAgICAgICAgLy8gSWYgbGFzdCBub2RlIGlzIHRoZSBmdXJ0aGVzdCBibG9jaywgdGhlbiBtb3ZlIHRoZVxuICAgICAgICAgIC8vIGFmb3JlbWVudGlvbmVkIGJvb2ttYXJrIHRvIGJlIGltbWVkaWF0ZWx5IGFmdGVyIHRoZVxuICAgICAgICAgIC8vIG5ldyBub2RlIGluIHRoZSBsaXN0IG9mIGFjdGl2ZSBmb3JtYXR0aW5nIGVsZW1lbnRzLlxuICAgICAgICAgIGlmIChsYXN0bm9kZSA9PT0gZnVydGhlc3RibG9jaykge1xuICAgICAgICAgICAgYWZlLnJlbW92ZShCT09LTUFSSyk7XG4gICAgICAgICAgICBhZmUuaW5zZXJ0QWZ0ZXIobmV3ZWx0LmVsdCwgQk9PS01BUkspO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIEluc2VydCBsYXN0IG5vZGUgaW50byBub2RlLCBmaXJzdCByZW1vdmluZyBpdCBmcm9tXG4gICAgICAgICAgLy8gaXRzIHByZXZpb3VzIHBhcmVudCBub2RlIGlmIGFueS5cbiAgICAgICAgICBub2RlLl9hcHBlbmRDaGlsZChsYXN0bm9kZSk7XG5cbiAgICAgICAgICAvLyBMZXQgbGFzdCBub2RlIGJlIG5vZGUuXG4gICAgICAgICAgbGFzdG5vZGUgPSBub2RlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgdGhlIGNvbW1vbiBhbmNlc3RvciBub2RlIGlzIGEgdGFibGUsIHRib2R5LCB0Zm9vdCxcbiAgICAgICAgLy8gdGhlYWQsIG9yIHRyIGVsZW1lbnQsIHRoZW4sIGZvc3RlciBwYXJlbnQgd2hhdGV2ZXIgbGFzdFxuICAgICAgICAvLyBub2RlIGVuZGVkIHVwIGJlaW5nIGluIHRoZSBwcmV2aW91cyBzdGVwLCBmaXJzdCByZW1vdmluZ1xuICAgICAgICAvLyBpdCBmcm9tIGl0cyBwcmV2aW91cyBwYXJlbnQgbm9kZSBpZiBhbnkuXG4gICAgICAgIGlmIChmb3N0ZXJfcGFyZW50X21vZGUgJiYgaXNBKGFuY2VzdG9yLCB0YWJsZXNlY3Rpb25yb3dTZXQpKSB7XG4gICAgICAgICAgZm9zdGVyUGFyZW50KGZ1bmN0aW9uKCkgeyByZXR1cm4gbGFzdG5vZGU7IH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIE90aGVyd2lzZSwgYXBwZW5kIHdoYXRldmVyIGxhc3Qgbm9kZSBlbmRlZCB1cCBiZWluZyBpblxuICAgICAgICAvLyB0aGUgcHJldmlvdXMgc3RlcCB0byB0aGUgY29tbW9uIGFuY2VzdG9yIG5vZGUsIGZpcnN0XG4gICAgICAgIC8vIHJlbW92aW5nIGl0IGZyb20gaXRzIHByZXZpb3VzIHBhcmVudCBub2RlIGlmIGFueS5cbiAgICAgICAgZWxzZSBpZiAoYW5jZXN0b3IgaW5zdGFuY2VvZiBpbXBsLkhUTUxUZW1wbGF0ZUVsZW1lbnQpIHtcbiAgICAgICAgICBhbmNlc3Rvci5jb250ZW50Ll9hcHBlbmRDaGlsZChsYXN0bm9kZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYW5jZXN0b3IuX2FwcGVuZENoaWxkKGxhc3Rub2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENyZWF0ZSBhbiBlbGVtZW50IGZvciB0aGUgdG9rZW4gZm9yIHdoaWNoIHRoZVxuICAgICAgICAvLyBmb3JtYXR0aW5nIGVsZW1lbnQgd2FzIGNyZWF0ZWQsIHdpdGggZnVydGhlc3QgYmxvY2tcbiAgICAgICAgLy8gYXMgdGhlIGludGVuZGVkIHBhcmVudC5cbiAgICAgICAgdmFyIG5ld2VsdDIgPSBhZmVjbG9uZShmdXJ0aGVzdGJsb2NrLm93bmVyRG9jdW1lbnQsIGFmZS5pbmRleE9mKGZtdGVsdCkpO1xuXG4gICAgICAgIC8vIFRha2UgYWxsIG9mIHRoZSBjaGlsZCBub2RlcyBvZiB0aGUgZnVydGhlc3QgYmxvY2sgYW5kXG4gICAgICAgIC8vIGFwcGVuZCB0aGVtIHRvIHRoZSBlbGVtZW50IGNyZWF0ZWQgaW4gdGhlIGxhc3Qgc3RlcC5cbiAgICAgICAgd2hpbGUoZnVydGhlc3RibG9jay5oYXNDaGlsZE5vZGVzKCkpIHtcbiAgICAgICAgICBuZXdlbHQyLmVsdC5fYXBwZW5kQ2hpbGQoZnVydGhlc3RibG9jay5maXJzdENoaWxkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFwcGVuZCB0aGF0IG5ldyBlbGVtZW50IHRvIHRoZSBmdXJ0aGVzdCBibG9jay5cbiAgICAgICAgZnVydGhlc3RibG9jay5fYXBwZW5kQ2hpbGQobmV3ZWx0Mi5lbHQpO1xuXG4gICAgICAgIC8vIFJlbW92ZSB0aGUgZm9ybWF0dGluZyBlbGVtZW50IGZyb20gdGhlIGxpc3Qgb2YgYWN0aXZlXG4gICAgICAgIC8vIGZvcm1hdHRpbmcgZWxlbWVudHMsIGFuZCBpbnNlcnQgdGhlIG5ldyBlbGVtZW50IGludG8gdGhlXG4gICAgICAgIC8vIGxpc3Qgb2YgYWN0aXZlIGZvcm1hdHRpbmcgZWxlbWVudHMgYXQgdGhlIHBvc2l0aW9uIG9mXG4gICAgICAgIC8vIHRoZSBhZm9yZW1lbnRpb25lZCBib29rbWFyay5cbiAgICAgICAgYWZlLnJlbW92ZShmbXRlbHQpO1xuICAgICAgICBhZmUucmVwbGFjZShCT09LTUFSSywgbmV3ZWx0Mi5lbHQsIG5ld2VsdDIuYXR0cnMpO1xuXG4gICAgICAgIC8vIFJlbW92ZSB0aGUgZm9ybWF0dGluZyBlbGVtZW50IGZyb20gdGhlIHN0YWNrIG9mIG9wZW5cbiAgICAgICAgLy8gZWxlbWVudHMsIGFuZCBpbnNlcnQgdGhlIG5ldyBlbGVtZW50IGludG8gdGhlIHN0YWNrIG9mXG4gICAgICAgIC8vIG9wZW4gZWxlbWVudHMgaW1tZWRpYXRlbHkgYmVsb3cgdGhlIHBvc2l0aW9uIG9mIHRoZVxuICAgICAgICAvLyBmdXJ0aGVzdCBibG9jayBpbiB0aGF0IHN0YWNrLlxuICAgICAgICBzdGFjay5yZW1vdmVFbGVtZW50KGZtdGVsdCk7XG4gICAgICAgIHZhciBwb3MgPSBzdGFjay5lbGVtZW50cy5sYXN0SW5kZXhPZihmdXJ0aGVzdGJsb2NrKTtcbiAgICAgICAgc3RhY2suZWxlbWVudHMuc3BsaWNlKHBvcysxLCAwLCBuZXdlbHQyLmVsdCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvLyBXZSBkbyB0aGlzIHdoZW4gd2UgZ2V0IC9zY3JpcHQgaW4gaW5fdGV4dF9tb2RlXG4gIGZ1bmN0aW9uIGhhbmRsZVNjcmlwdEVuZCgpIHtcbiAgICAvLyBYWFg6XG4gICAgLy8gVGhpcyBpcyBqdXN0IGEgc3R1YiBpbXBsZW1lbnRhdGlvbiByaWdodCBub3cgYW5kIGRvZXNuJ3QgcnVuIHNjcmlwdHMuXG4gICAgLy8gR2V0dGluZyB0aGlzIG1ldGhvZCByaWdodCBpbnZvbHZlcyB0aGUgZXZlbnQgbG9vcCwgVVJMIHJlc29sdXRpb25cbiAgICAvLyBzY3JpcHQgZmV0Y2hpbmcgZXRjLiBGb3Igbm93IEkganVzdCB3YW50IHRvIGJlIGFibGUgdG8gcGFyc2VcbiAgICAvLyBkb2N1bWVudHMgYW5kIHRlc3QgdGhlIHBhcnNlci5cblxuICAgIC8vdmFyIHNjcmlwdCA9IHN0YWNrLnRvcDtcbiAgICBzdGFjay5wb3AoKTtcbiAgICBwYXJzZXIgPSBvcmlnaW5hbEluc2VydGlvbk1vZGU7XG4gICAgLy9zY3JpcHQuX3ByZXBhcmUoKTtcbiAgICByZXR1cm47XG5cbiAgICAvLyBYWFg6IGhlcmUgaXMgd2hhdCB0aGlzIG1ldGhvZCBpcyBzdXBwb3NlZCB0byBkb1xuXG4gICAgLy8gUHJvdmlkZSBhIHN0YWJsZSBzdGF0ZS5cblxuICAgIC8vIExldCBzY3JpcHQgYmUgdGhlIGN1cnJlbnQgbm9kZSAod2hpY2ggd2lsbCBiZSBhIHNjcmlwdFxuICAgIC8vIGVsZW1lbnQpLlxuXG4gICAgLy8gUG9wIHRoZSBjdXJyZW50IG5vZGUgb2ZmIHRoZSBzdGFjayBvZiBvcGVuIGVsZW1lbnRzLlxuXG4gICAgLy8gU3dpdGNoIHRoZSBpbnNlcnRpb24gbW9kZSB0byB0aGUgb3JpZ2luYWwgaW5zZXJ0aW9uIG1vZGUuXG5cbiAgICAvLyBMZXQgdGhlIG9sZCBpbnNlcnRpb24gcG9pbnQgaGF2ZSB0aGUgc2FtZSB2YWx1ZSBhcyB0aGUgY3VycmVudFxuICAgIC8vIGluc2VydGlvbiBwb2ludC4gTGV0IHRoZSBpbnNlcnRpb24gcG9pbnQgYmUganVzdCBiZWZvcmUgdGhlXG4gICAgLy8gbmV4dCBpbnB1dCBjaGFyYWN0ZXIuXG5cbiAgICAvLyBJbmNyZW1lbnQgdGhlIHBhcnNlcidzIHNjcmlwdCBuZXN0aW5nIGxldmVsIGJ5IG9uZS5cblxuICAgIC8vIFByZXBhcmUgdGhlIHNjcmlwdC4gVGhpcyBtaWdodCBjYXVzZSBzb21lIHNjcmlwdCB0byBleGVjdXRlLFxuICAgIC8vIHdoaWNoIG1pZ2h0IGNhdXNlIG5ldyBjaGFyYWN0ZXJzIHRvIGJlIGluc2VydGVkIGludG8gdGhlXG4gICAgLy8gdG9rZW5pemVyLCBhbmQgbWlnaHQgY2F1c2UgdGhlIHRva2VuaXplciB0byBvdXRwdXQgbW9yZSB0b2tlbnMsXG4gICAgLy8gcmVzdWx0aW5nIGluIGEgcmVlbnRyYW50IGludm9jYXRpb24gb2YgdGhlIHBhcnNlci5cblxuICAgIC8vIERlY3JlbWVudCB0aGUgcGFyc2VyJ3Mgc2NyaXB0IG5lc3RpbmcgbGV2ZWwgYnkgb25lLiBJZiB0aGVcbiAgICAvLyBwYXJzZXIncyBzY3JpcHQgbmVzdGluZyBsZXZlbCBpcyB6ZXJvLCB0aGVuIHNldCB0aGUgcGFyc2VyXG4gICAgLy8gcGF1c2UgZmxhZyB0byBmYWxzZS5cblxuICAgIC8vIExldCB0aGUgaW5zZXJ0aW9uIHBvaW50IGhhdmUgdGhlIHZhbHVlIG9mIHRoZSBvbGQgaW5zZXJ0aW9uXG4gICAgLy8gcG9pbnQuIChJbiBvdGhlciB3b3JkcywgcmVzdG9yZSB0aGUgaW5zZXJ0aW9uIHBvaW50IHRvIGl0c1xuICAgIC8vIHByZXZpb3VzIHZhbHVlLiBUaGlzIHZhbHVlIG1pZ2h0IGJlIHRoZSBcInVuZGVmaW5lZFwiIHZhbHVlLilcblxuICAgIC8vIEF0IHRoaXMgc3RhZ2UsIGlmIHRoZXJlIGlzIGEgcGVuZGluZyBwYXJzaW5nLWJsb2NraW5nIHNjcmlwdCxcbiAgICAvLyB0aGVuOlxuXG4gICAgLy8gSWYgdGhlIHNjcmlwdCBuZXN0aW5nIGxldmVsIGlzIG5vdCB6ZXJvOlxuXG4gICAgLy8gICBTZXQgdGhlIHBhcnNlciBwYXVzZSBmbGFnIHRvIHRydWUsIGFuZCBhYm9ydCB0aGUgcHJvY2Vzc2luZ1xuICAgIC8vICAgb2YgYW55IG5lc3RlZCBpbnZvY2F0aW9ucyBvZiB0aGUgdG9rZW5pemVyLCB5aWVsZGluZ1xuICAgIC8vICAgY29udHJvbCBiYWNrIHRvIHRoZSBjYWxsZXIuIChUb2tlbml6YXRpb24gd2lsbCByZXN1bWUgd2hlblxuICAgIC8vICAgdGhlIGNhbGxlciByZXR1cm5zIHRvIHRoZSBcIm91dGVyXCIgdHJlZSBjb25zdHJ1Y3Rpb24gc3RhZ2UuKVxuXG4gICAgLy8gICBUaGUgdHJlZSBjb25zdHJ1Y3Rpb24gc3RhZ2Ugb2YgdGhpcyBwYXJ0aWN1bGFyIHBhcnNlciBpc1xuICAgIC8vICAgYmVpbmcgY2FsbGVkIHJlZW50cmFudGx5LCBzYXkgZnJvbSBhIGNhbGwgdG9cbiAgICAvLyAgIGRvY3VtZW50LndyaXRlKCkuXG5cbiAgICAvLyBPdGhlcndpc2U6XG5cbiAgICAvLyAgICAgUnVuIHRoZXNlIHN0ZXBzOlxuXG4gICAgLy8gICAgICAgTGV0IHRoZSBzY3JpcHQgYmUgdGhlIHBlbmRpbmcgcGFyc2luZy1ibG9ja2luZ1xuICAgIC8vICAgICAgIHNjcmlwdC4gVGhlcmUgaXMgbm8gbG9uZ2VyIGEgcGVuZGluZ1xuICAgIC8vICAgICAgIHBhcnNpbmctYmxvY2tpbmcgc2NyaXB0LlxuXG4gICAgLy8gICAgICAgQmxvY2sgdGhlIHRva2VuaXplciBmb3IgdGhpcyBpbnN0YW5jZSBvZiB0aGUgSFRNTFxuICAgIC8vICAgICAgIHBhcnNlciwgc3VjaCB0aGF0IHRoZSBldmVudCBsb29wIHdpbGwgbm90IHJ1biB0YXNrc1xuICAgIC8vICAgICAgIHRoYXQgaW52b2tlIHRoZSB0b2tlbml6ZXIuXG5cbiAgICAvLyAgICAgICBJZiB0aGUgcGFyc2VyJ3MgRG9jdW1lbnQgaGFzIGEgc3R5bGUgc2hlZXQgdGhhdCBpc1xuICAgIC8vICAgICAgIGJsb2NraW5nIHNjcmlwdHMgb3IgdGhlIHNjcmlwdCdzIFwicmVhZHkgdG8gYmVcbiAgICAvLyAgICAgICBwYXJzZXItZXhlY3V0ZWRcIiBmbGFnIGlzIG5vdCBzZXQ6IHNwaW4gdGhlIGV2ZW50XG4gICAgLy8gICAgICAgbG9vcCB1bnRpbCB0aGUgcGFyc2VyJ3MgRG9jdW1lbnQgaGFzIG5vIHN0eWxlIHNoZWV0XG4gICAgLy8gICAgICAgdGhhdCBpcyBibG9ja2luZyBzY3JpcHRzIGFuZCB0aGUgc2NyaXB0J3MgXCJyZWFkeSB0b1xuICAgIC8vICAgICAgIGJlIHBhcnNlci1leGVjdXRlZFwiIGZsYWcgaXMgc2V0LlxuXG4gICAgLy8gICAgICAgVW5ibG9jayB0aGUgdG9rZW5pemVyIGZvciB0aGlzIGluc3RhbmNlIG9mIHRoZSBIVE1MXG4gICAgLy8gICAgICAgcGFyc2VyLCBzdWNoIHRoYXQgdGFza3MgdGhhdCBpbnZva2UgdGhlIHRva2VuaXplclxuICAgIC8vICAgICAgIGNhbiBhZ2FpbiBiZSBydW4uXG5cbiAgICAvLyAgICAgICBMZXQgdGhlIGluc2VydGlvbiBwb2ludCBiZSBqdXN0IGJlZm9yZSB0aGUgbmV4dFxuICAgIC8vICAgICAgIGlucHV0IGNoYXJhY3Rlci5cblxuICAgIC8vICAgICAgIEluY3JlbWVudCB0aGUgcGFyc2VyJ3Mgc2NyaXB0IG5lc3RpbmcgbGV2ZWwgYnkgb25lXG4gICAgLy8gICAgICAgKGl0IHNob3VsZCBiZSB6ZXJvIGJlZm9yZSB0aGlzIHN0ZXAsIHNvIHRoaXMgc2V0c1xuICAgIC8vICAgICAgIGl0IHRvIG9uZSkuXG5cbiAgICAvLyAgICAgICBFeGVjdXRlIHRoZSBzY3JpcHQuXG5cbiAgICAvLyAgICAgICBEZWNyZW1lbnQgdGhlIHBhcnNlcidzIHNjcmlwdCBuZXN0aW5nIGxldmVsIGJ5XG4gICAgLy8gICAgICAgb25lLiBJZiB0aGUgcGFyc2VyJ3Mgc2NyaXB0IG5lc3RpbmcgbGV2ZWwgaXMgemVyb1xuICAgIC8vICAgICAgICh3aGljaCBpdCBhbHdheXMgc2hvdWxkIGJlIGF0IHRoaXMgcG9pbnQpLCB0aGVuIHNldFxuICAgIC8vICAgICAgIHRoZSBwYXJzZXIgcGF1c2UgZmxhZyB0byBmYWxzZS5cblxuICAgIC8vICAgICAgIExldCB0aGUgaW5zZXJ0aW9uIHBvaW50IGJlIHVuZGVmaW5lZCBhZ2Fpbi5cblxuICAgIC8vICAgICAgIElmIHRoZXJlIGlzIG9uY2UgYWdhaW4gYSBwZW5kaW5nIHBhcnNpbmctYmxvY2tpbmdcbiAgICAvLyAgICAgICBzY3JpcHQsIHRoZW4gcmVwZWF0IHRoZXNlIHN0ZXBzIGZyb20gc3RlcCAxLlxuXG5cbiAgfVxuXG4gIGZ1bmN0aW9uIHN0b3BQYXJzaW5nKCkge1xuICAgIC8vIFhYWCBUaGlzIGlzIGp1c3QgYSB0ZW1wb3JhcnkgaW1wbGVtZW50YXRpb24gdG8gZ2V0IHRoZSBwYXJzZXIgd29ya2luZy5cbiAgICAvLyBBIGZ1bGwgaW1wbGVtZW50YXRpb24gaW52b2x2ZXMgc2NyaXB0cyBhbmQgZXZlbnRzIGFuZCB0aGUgZXZlbnQgbG9vcC5cblxuICAgIC8vIFJlbW92ZSB0aGUgbGluayBmcm9tIGRvY3VtZW50IHRvIHBhcnNlci5cbiAgICAvLyBUaGlzIGlzIGluc3RlYWQgb2YgXCJzZXQgdGhlIGluc2VydGlvbiBwb2ludCB0byB1bmRlZmluZWRcIi5cbiAgICAvLyBJdCBtZWFucyB0aGF0IGRvY3VtZW50LndyaXRlKCkgY2FuJ3Qgd3JpdGUgaW50byB0aGUgZG9jIGFueW1vcmUuXG4gICAgZGVsZXRlIGRvYy5fcGFyc2VyO1xuXG4gICAgc3RhY2suZWxlbWVudHMubGVuZ3RoID0gMDsgLy8gcG9wIGV2ZXJ5dGhpbmcgb2ZmXG5cbiAgICAvLyBJZiB0aGVyZSBpcyBhIHdpbmRvdyBvYmplY3QgYXNzb2NpYXRlZCB3aXRoIHRoZSBkb2N1bWVudFxuICAgIC8vIHRoZW4gdHJpZ2dlciBhbiBsb2FkIGV2ZW50IG9uIGl0XG4gICAgaWYgKGRvYy5kZWZhdWx0Vmlldykge1xuICAgICAgZG9jLmRlZmF1bHRWaWV3LmRpc3BhdGNoRXZlbnQobmV3IGltcGwuRXZlbnQoXCJsb2FkXCIse30pKTtcbiAgICB9XG5cbiAgfVxuXG4gIC8qKioqXG4gICAqIFRva2VuaXplciBzdGF0ZXNcbiAgICovXG5cbiAgLyoqXG4gICAqIFRoaXMgZmlsZSB3YXMgcGFydGlhbGx5IG1lY2hhbmljYWxseSBnZW5lcmF0ZWQgZnJvbVxuICAgKiBodHRwOi8vd3d3LndoYXR3Zy5vcmcvc3BlY3Mvd2ViLWFwcHMvY3VycmVudC13b3JrL211bHRpcGFnZS90b2tlbml6YXRpb24uaHRtbFxuICAgKlxuICAgKiBBZnRlciBtZWNoYW5pY2FsIGNvbnZlcnNpb24sIGl0IHdhcyBmdXJ0aGVyIGNvbnZlcnRlZCBmcm9tXG4gICAqIHByb3NlIHRvIEpTIGJ5IGhhbmQsIGJ1dCB0aGUgaW50ZW50IGlzIHRoYXQgaXQgaXMgYSB2ZXJ5XG4gICAqIGZhaXRoZnVsIHJlbmRlcmluZyBvZiB0aGUgSFRNTCB0b2tlbml6YXRpb24gc3BlYyBpblxuICAgKiBKYXZhU2NyaXB0LlxuICAgKlxuICAgKiBJdCBpcyBub3QgYSBnb2FsIG9mIHRoaXMgdG9rZW5pemVyIHRvIGRldGVjdCBvciByZXBvcnRcbiAgICogcGFyc2UgZXJyb3JzLlxuICAgKlxuICAgKiBYWFggVGhlIHRva2VuaXplciBpcyBzdXBwb3NlZCB0byB3b3JrIHdpdGggc3RyYWlnaHQgVVRGMzJcbiAgICogY29kZXBvaW50cy4gQnV0IEkgZG9uJ3QgdGhpbmsgaXQgaGFzIGFueSBkZXBlbmRlbmNpZXMgb25cbiAgICogYW55IGNoYXJhY3RlciBvdXRzaWRlIG9mIHRoZSBCTVAgc28gSSB0aGluayBpdCBpcyBzYWZlIHRvXG4gICAqIHBhc3MgaXQgVVRGMTYgY2hhcmFjdGVycy4gSSBkb24ndCB0aGluayBpdCB3aWxsIGV2ZXIgY2hhbmdlXG4gICAqIHN0YXRlIGluIHRoZSBtaWRkbGUgb2YgYSBzdXJyb2dhdGUgcGFpci5cbiAgICovXG5cbiAgLypcbiAgICogRWFjaCBzdGF0ZSBpcyByZXByZXNlbnRlZCBieSBhIGZ1bmN0aW9uLiAgRm9yIG1vc3Qgc3RhdGVzLCB0aGVcbiAgICogc2Nhbm5lciBzaW1wbHkgcGFzc2VzIHRoZSBuZXh0IGNoYXJhY3RlciAoYXMgYW4gaW50ZWdlclxuICAgKiBjb2RlcG9pbnQpIHRvIHRoZSBjdXJyZW50IHN0YXRlIGZ1bmN0aW9uIGFuZCBhdXRvbWF0aWNhbGx5XG4gICAqIGNvbnN1bWVzIHRoZSBjaGFyYWN0ZXIuICBJZiB0aGUgc3RhdGUgZnVuY3Rpb24gY2FuJ3QgcHJvY2Vzc1xuICAgKiB0aGUgY2hhcmFjdGVyIGl0IGNhbiBjYWxsIHB1c2hiYWNrKCkgdG8gcHVzaCBpdCBiYWNrIHRvIHRoZVxuICAgKiBzY2FubmVyLlxuICAgKlxuICAgKiBTb21lIHN0YXRlcyByZXF1aXJlIGxvb2thaGVhZCwgdGhvdWdoLiAgSWYgYSBzdGF0ZSBmdW5jdGlvbiBoYXNcbiAgICogYSBsb29rYWhlYWQgcHJvcGVydHksIHRoZW4gaXQgaXMgaW52b2tlZCBkaWZmZXJlbnRseS4gIEluIHRoaXNcbiAgICogY2FzZSwgdGhlIHNjYW5uZXIgaW52b2tlcyB0aGUgZnVuY3Rpb24gd2l0aCAzIGFyZ3VtZW50czogMSkgdGhlXG4gICAqIG5leHQgY29kZXBvaW50IDIpIGEgc3RyaW5nIG9mIGxvb2thaGVhZCB0ZXh0IDMpIGEgYm9vbGVhbiB0aGF0XG4gICAqIGlzIHRydWUgaWYgdGhlIGxvb2thaGVhZCBnb2VzIGFsbCB0aGUgd2F5IHRvIHRoZSBFT0YuIChYWFhcbiAgICogYWN0dWFsbHkgbWF5YmUgdGhpcyB0aGlyZCBpcyBub3QgbmVjZXNzYXJ5Li4uIHRoZSBsb29rYWhlYWRcbiAgICogY291bGQganVzdCBpbmNsdWRlIFxcdUZGRkY/KVxuICAgKlxuICAgKiBJZiB0aGUgbG9va2FoZWFkIHByb3BlcnR5IG9mIGEgc3RhdGUgZnVuY3Rpb24gaXMgYW4gaW50ZWdlciwgaXRcbiAgICogc3BlY2lmaWVzIHRoZSBudW1iZXIgb2YgY2hhcmFjdGVycyByZXF1aXJlZC4gSWYgaXQgaXMgYSBzdHJpbmcsXG4gICAqIHRoZW4gdGhlIHNjYW5uZXIgd2lsbCBzY2FuIGZvciB0aGF0IHN0cmluZyBhbmQgcmV0dXJuIGFsbFxuICAgKiBjaGFyYWN0ZXJzIHVwIHRvIGFuZCBpbmNsdWRpbmcgdGhhdCBzZXF1ZW5jZSwgb3IgdXAgdG8gRU9GLiAgSWZcbiAgICogdGhlIGxvb2thaGVhZCBwcm9wZXJ0eSBpcyBhIHJlZ2V4cCwgdGhlbiB0aGUgc2Nhbm5lciB3aWxsIG1hdGNoXG4gICAqIHRoZSByZWdleHAgYXQgdGhlIGN1cnJlbnQgcG9pbnQgYW5kIHJldHVybiB0aGUgbWF0Y2hpbmcgc3RyaW5nLlxuICAgKlxuICAgKiBTdGF0ZXMgdGhhdCByZXF1aXJlIGxvb2thaGVhZCBhcmUgcmVzcG9uc2libGUgZm9yIGV4cGxpY2l0bHlcbiAgICogY29uc3VtaW5nIHRoZSBjaGFyYWN0ZXJzIHRoZXkgcHJvY2Vzcy4gVGhleSBkbyB0aGlzIGJ5XG4gICAqIGluY3JlbWVudGluZyBuZXh0Y2hhciBieSB0aGUgbnVtYmVyIG9mIHByb2Nlc3NlZCBjaGFyYWN0ZXJzLlxuICAgKi9cbiAgZnVuY3Rpb24gcmVjb25zdW1lKGMsIG5ld19zdGF0ZSkge1xuICAgIHRva2VuaXplciA9IG5ld19zdGF0ZTtcbiAgICBuZXh0Y2hhci0tOyAvLyBwdXNoYmFja1xuICB9XG5cbiAgZnVuY3Rpb24gZGF0YV9zdGF0ZShjKSB7XG4gICAgc3dpdGNoKGMpIHtcbiAgICBjYXNlIDB4MDAyNjogLy8gQU1QRVJTQU5EXG4gICAgICByZXR1cm5fc3RhdGUgPSBkYXRhX3N0YXRlO1xuICAgICAgdG9rZW5pemVyID0gY2hhcmFjdGVyX3JlZmVyZW5jZV9zdGF0ZTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMHgwMDNDOiAvLyBMRVNTLVRIQU4gU0lHTlxuICAgICAgaWYgKGVtaXRTaW1wbGVUYWcoKSkgLy8gU2hvcnRjdXQgZm9yIDxwPiwgPGRsPiwgPC9kaXY+IGV0Yy5cbiAgICAgICAgYnJlYWs7XG4gICAgICB0b2tlbml6ZXIgPSB0YWdfb3Blbl9zdGF0ZTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMHgwMDAwOiAvLyBOVUxMXG4gICAgICAvLyBVc3VhbGx5IG51bGwgY2hhcmFjdGVycyBlbWl0dGVkIGJ5IHRoZSB0b2tlbml6ZXIgd2lsbCBiZVxuICAgICAgLy8gaWdub3JlZCBieSB0aGUgdHJlZSBidWlsZGVyLCBidXQgc29tZXRpbWVzIHRoZXknbGwgYmVcbiAgICAgIC8vIGNvbnZlcnRlZCB0byBcXHVGRkZELiAgSSBkb24ndCB3YW50IHRvIGhhdmUgdGhlIHNlYXJjaCBldmVyeVxuICAgICAgLy8gc3RyaW5nIGVtaXR0ZWQgdG8gcmVwbGFjZSBOVUxzLCBzbyBJJ2xsIHNldCBhIGZsYWdcbiAgICAgIC8vIGlmIEkndmUgZW1pdHRlZCBhIE5VTC5cbiAgICAgIHRleHRydW4ucHVzaChjKTtcbiAgICAgIHRleHRJbmNsdWRlc05VTCA9IHRydWU7XG4gICAgICBicmVhaztcbiAgICBjYXNlIC0xOiAvLyBFT0ZcbiAgICAgIGVtaXRFT0YoKTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICAvLyBJbnN0ZWFkIG9mIGp1c3QgcHVzaGluZyBhIHNpbmdsZSBjaGFyYWN0ZXIgYW5kIHRoZW5cbiAgICAgIC8vIGNvbWluZyBiYWNrIHRvIHRoZSB2ZXJ5IHNhbWUgcGxhY2UsIGxvb2thaGVhZCBhbmRcbiAgICAgIC8vIGVtaXQgZXZlcnl0aGluZyB3ZSBjYW4gYXQgb25jZS5cbiAgICAgIC8qanNoaW50IC1XMDMwICovXG4gICAgICBlbWl0Q2hhcnNXaGlsZShEQVRBVEVYVCkgfHwgdGV4dHJ1bi5wdXNoKGMpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmNkYXRhX3N0YXRlKGMpIHtcbiAgICAvLyBTYXZlIHRoZSBvcGVuIHRhZyBzbyB3ZSBjYW4gZmluZCBhIG1hdGNoaW5nIGNsb3NlIHRhZ1xuICAgIHN3aXRjaChjKSB7XG4gICAgY2FzZSAweDAwMjY6IC8vIEFNUEVSU0FORFxuICAgICAgcmV0dXJuX3N0YXRlID0gcmNkYXRhX3N0YXRlO1xuICAgICAgdG9rZW5pemVyID0gY2hhcmFjdGVyX3JlZmVyZW5jZV9zdGF0ZTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMHgwMDNDOiAvLyBMRVNTLVRIQU4gU0lHTlxuICAgICAgdG9rZW5pemVyID0gcmNkYXRhX2xlc3NfdGhhbl9zaWduX3N0YXRlO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAweDAwMDA6IC8vIE5VTExcbiAgICAgIHRleHRydW4ucHVzaCgweEZGRkQpOyAvLyBSRVBMQUNFTUVOVCBDSEFSQUNURVJcbiAgICAgIHRleHRJbmNsdWRlc05VTCA9IHRydWU7XG4gICAgICBicmVhaztcbiAgICBjYXNlIC0xOiAvLyBFT0ZcbiAgICAgIGVtaXRFT0YoKTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0ZXh0cnVuLnB1c2goYyk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByYXd0ZXh0X3N0YXRlKGMpIHtcbiAgICBzd2l0Y2goYykge1xuICAgIGNhc2UgMHgwMDNDOiAvLyBMRVNTLVRIQU4gU0lHTlxuICAgICAgdG9rZW5pemVyID0gcmF3dGV4dF9sZXNzX3RoYW5fc2lnbl9zdGF0ZTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMHgwMDAwOiAvLyBOVUxMXG4gICAgICB0ZXh0cnVuLnB1c2goMHhGRkZEKTsgLy8gUkVQTEFDRU1FTlQgQ0hBUkFDVEVSXG4gICAgICBicmVhaztcbiAgICBjYXNlIC0xOiAvLyBFT0ZcbiAgICAgIGVtaXRFT0YoKTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICAvKmpzaGludCAtVzAzMCAqL1xuICAgICAgZW1pdENoYXJzV2hpbGUoUkFXVEVYVCkgfHwgdGV4dHJ1bi5wdXNoKGMpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2NyaXB0X2RhdGFfc3RhdGUoYykge1xuICAgIHN3aXRjaChjKSB7XG4gICAgY2FzZSAweDAwM0M6IC8vIExFU1MtVEhBTiBTSUdOXG4gICAgICB0b2tlbml6ZXIgPSBzY3JpcHRfZGF0YV9sZXNzX3RoYW5fc2lnbl9zdGF0ZTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMHgwMDAwOiAvLyBOVUxMXG4gICAgICB0ZXh0cnVuLnB1c2goMHhGRkZEKTsgLy8gUkVQTEFDRU1FTlQgQ0hBUkFDVEVSXG4gICAgICBicmVhaztcbiAgICBjYXNlIC0xOiAvLyBFT0ZcbiAgICAgIGVtaXRFT0YoKTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICAvKmpzaGludCAtVzAzMCAqL1xuICAgICAgZW1pdENoYXJzV2hpbGUoUkFXVEVYVCkgfHwgdGV4dHJ1bi5wdXNoKGMpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcGxhaW50ZXh0X3N0YXRlKGMpIHtcbiAgICBzd2l0Y2goYykge1xuICAgIGNhc2UgMHgwMDAwOiAvLyBOVUxMXG4gICAgICB0ZXh0cnVuLnB1c2goMHhGRkZEKTsgLy8gUkVQTEFDRU1FTlQgQ0hBUkFDVEVSXG4gICAgICBicmVhaztcbiAgICBjYXNlIC0xOiAvLyBFT0ZcbiAgICAgIGVtaXRFT0YoKTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICAvKmpzaGludCAtVzAzMCAqL1xuICAgICAgZW1pdENoYXJzV2hpbGUoUExBSU5URVhUKSB8fCB0ZXh0cnVuLnB1c2goYyk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB0YWdfb3Blbl9zdGF0ZShjKSB7XG4gICAgc3dpdGNoKGMpIHtcbiAgICBjYXNlIDB4MDAyMTogLy8gRVhDTEFNQVRJT04gTUFSS1xuICAgICAgdG9rZW5pemVyID0gbWFya3VwX2RlY2xhcmF0aW9uX29wZW5fc3RhdGU7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDB4MDAyRjogLy8gU09MSURVU1xuICAgICAgdG9rZW5pemVyID0gZW5kX3RhZ19vcGVuX3N0YXRlO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAweDAwNDE6ICAvLyBbQS1aXVxuICAgIGNhc2UgMHgwMDQyOmNhc2UgMHgwMDQzOmNhc2UgMHgwMDQ0OmNhc2UgMHgwMDQ1OmNhc2UgMHgwMDQ2OlxuICAgIGNhc2UgMHgwMDQ3OmNhc2UgMHgwMDQ4OmNhc2UgMHgwMDQ5OmNhc2UgMHgwMDRBOmNhc2UgMHgwMDRCOlxuICAgIGNhc2UgMHgwMDRDOmNhc2UgMHgwMDREOmNhc2UgMHgwMDRFOmNhc2UgMHgwMDRGOmNhc2UgMHgwMDUwOlxuICAgIGNhc2UgMHgwMDUxOmNhc2UgMHgwMDUyOmNhc2UgMHgwMDUzOmNhc2UgMHgwMDU0OmNhc2UgMHgwMDU1OlxuICAgIGNhc2UgMHgwMDU2OmNhc2UgMHgwMDU3OmNhc2UgMHgwMDU4OmNhc2UgMHgwMDU5OmNhc2UgMHgwMDVBOlxuICAgIGNhc2UgMHgwMDYxOiAgLy8gW2Etel1cbiAgICBjYXNlIDB4MDA2MjpjYXNlIDB4MDA2MzpjYXNlIDB4MDA2NDpjYXNlIDB4MDA2NTpjYXNlIDB4MDA2NjpcbiAgICBjYXNlIDB4MDA2NzpjYXNlIDB4MDA2ODpjYXNlIDB4MDA2OTpjYXNlIDB4MDA2QTpjYXNlIDB4MDA2QjpcbiAgICBjYXNlIDB4MDA2QzpjYXNlIDB4MDA2RDpjYXNlIDB4MDA2RTpjYXNlIDB4MDA2RjpjYXNlIDB4MDA3MDpcbiAgICBjYXNlIDB4MDA3MTpjYXNlIDB4MDA3MjpjYXNlIDB4MDA3MzpjYXNlIDB4MDA3NDpjYXNlIDB4MDA3NTpcbiAgICBjYXNlIDB4MDA3NjpjYXNlIDB4MDA3NzpjYXNlIDB4MDA3ODpjYXNlIDB4MDA3OTpjYXNlIDB4MDA3QTpcbiAgICAgIGJlZ2luVGFnTmFtZSgpO1xuICAgICAgcmVjb25zdW1lKGMsIHRhZ19uYW1lX3N0YXRlKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMHgwMDNGOiAvLyBRVUVTVElPTiBNQVJLXG4gICAgICByZWNvbnN1bWUoYywgYm9ndXNfY29tbWVudF9zdGF0ZSk7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGV4dHJ1bi5wdXNoKDB4MDAzQyk7IC8vIExFU1MtVEhBTiBTSUdOXG4gICAgICByZWNvbnN1bWUoYywgZGF0YV9zdGF0ZSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBlbmRfdGFnX29wZW5fc3RhdGUoYykge1xuICAgIHN3aXRjaChjKSB7XG4gICAgY2FzZSAweDAwNDE6ICAvLyBbQS1aXVxuICAgIGNhc2UgMHgwMDQyOmNhc2UgMHgwMDQzOmNhc2UgMHgwMDQ0OmNhc2UgMHgwMDQ1OmNhc2UgMHgwMDQ2OlxuICAgIGNhc2UgMHgwMDQ3OmNhc2UgMHgwMDQ4OmNhc2UgMHgwMDQ5OmNhc2UgMHgwMDRBOmNhc2UgMHgwMDRCOlxuICAgIGNhc2UgMHgwMDRDOmNhc2UgMHgwMDREOmNhc2UgMHgwMDRFOmNhc2UgMHgwMDRGOmNhc2UgMHgwMDUwOlxuICAgIGNhc2UgMHgwMDUxOmNhc2UgMHgwMDUyOmNhc2UgMHgwMDUzOmNhc2UgMHgwMDU0OmNhc2UgMHgwMDU1OlxuICAgIGNhc2UgMHgwMDU2OmNhc2UgMHgwMDU3OmNhc2UgMHgwMDU4OmNhc2UgMHgwMDU5OmNhc2UgMHgwMDVBOlxuICAgIGNhc2UgMHgwMDYxOiAgLy8gW2Etel1cbiAgICBjYXNlIDB4MDA2MjpjYXNlIDB4MDA2MzpjYXNlIDB4MDA2NDpjYXNlIDB4MDA2NTpjYXNlIDB4MDA2NjpcbiAgICBjYXNlIDB4MDA2NzpjYXNlIDB4MDA2ODpjYXNlIDB4MDA2OTpjYXNlIDB4MDA2QTpjYXNlIDB4MDA2QjpcbiAgICBjYXNlIDB4MDA2QzpjYXNlIDB4MDA2RDpjYXNlIDB4MDA2RTpjYXNlIDB4MDA2RjpjYXNlIDB4MDA3MDpcbiAgICBjYXNlIDB4MDA3MTpjYXNlIDB4MDA3MjpjYXNlIDB4MDA3MzpjYXNlIDB4MDA3NDpjYXNlIDB4MDA3NTpcbiAgICBjYXNlIDB4MDA3NjpjYXNlIDB4MDA3NzpjYXNlIDB4MDA3ODpjYXNlIDB4MDA3OTpjYXNlIDB4MDA3QTpcbiAgICAgIGJlZ2luRW5kVGFnTmFtZSgpO1xuICAgICAgcmVjb25zdW1lKGMsIHRhZ19uYW1lX3N0YXRlKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMHgwMDNFOiAvLyBHUkVBVEVSLVRIQU4gU0lHTlxuICAgICAgdG9rZW5pemVyID0gZGF0YV9zdGF0ZTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgLTE6IC8vIEVPRlxuICAgICAgdGV4dHJ1bi5wdXNoKDB4MDAzQyk7IC8vIExFU1MtVEhBTiBTSUdOXG4gICAgICB0ZXh0cnVuLnB1c2goMHgwMDJGKTsgLy8gU09MSURVU1xuICAgICAgZW1pdEVPRigpO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJlY29uc3VtZShjLCBib2d1c19jb21tZW50X3N0YXRlKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHRhZ19uYW1lX3N0YXRlKGMpIHtcbiAgICBzd2l0Y2goYykge1xuICAgIGNhc2UgMHgwMDA5OiAvLyBDSEFSQUNURVIgVEFCVUxBVElPTiAodGFiKVxuICAgIGNhc2UgMHgwMDBBOiAvLyBMSU5FIEZFRUQgKExGKVxuICAgIGNhc2UgMHgwMDBDOiAvLyBGT1JNIEZFRUQgKEZGKVxuICAgIGNhc2UgMHgwMDIwOiAvLyBTUEFDRVxuICAgICAgdG9rZW5pemVyID0gYmVmb3JlX2F0dHJpYnV0ZV9uYW1lX3N0YXRlO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAweDAwMkY6IC8vIFNPTElEVVNcbiAgICAgIHRva2VuaXplciA9IHNlbGZfY2xvc2luZ19zdGFydF90YWdfc3RhdGU7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDB4MDAzRTogLy8gR1JFQVRFUi1USEFOIFNJR05cbiAgICAgIHRva2VuaXplciA9IGRhdGFfc3RhdGU7XG4gICAgICBlbWl0VGFnKCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDB4MDA0MTogIC8vIFtBLVpdXG4gICAgY2FzZSAweDAwNDI6Y2FzZSAweDAwNDM6Y2FzZSAweDAwNDQ6Y2FzZSAweDAwNDU6Y2FzZSAweDAwNDY6XG4gICAgY2FzZSAweDAwNDc6Y2FzZSAweDAwNDg6Y2FzZSAweDAwNDk6Y2FzZSAweDAwNEE6Y2FzZSAweDAwNEI6XG4gICAgY2FzZSAweDAwNEM6Y2FzZSAweDAwNEQ6Y2FzZSAweDAwNEU6Y2FzZSAweDAwNEY6Y2FzZSAweDAwNTA6XG4gICAgY2FzZSAweDAwNTE6Y2FzZSAweDAwNTI6Y2FzZSAweDAwNTM6Y2FzZSAweDAwNTQ6Y2FzZSAweDAwNTU6XG4gICAgY2FzZSAweDAwNTY6Y2FzZSAweDAwNTc6Y2FzZSAweDAwNTg6Y2FzZSAweDAwNTk6Y2FzZSAweDAwNUE6XG4gICAgICB0YWduYW1lYnVmICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYyArIDB4MDAyMCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDB4MDAwMDogLy8gTlVMTFxuICAgICAgdGFnbmFtZWJ1ZiArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4RkZGRCAvKiBSRVBMQUNFTUVOVCBDSEFSQUNURVIgKi8pO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAtMTogLy8gRU9GXG4gICAgICBlbWl0RU9GKCk7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGFnbmFtZWJ1ZiArPSBnZXRNYXRjaGluZ0NoYXJzKFRBR05BTUUpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmNkYXRhX2xlc3NfdGhhbl9zaWduX3N0YXRlKGMpIHtcbiAgICAvKiBpZGVudGljYWwgdG8gdGhlIFJBV1RFWFQgbGVzcy10aGFuIHNpZ24gc3RhdGUsIGV4Y2VwdCBzL1JBV1RFWFQvUkNEQVRBL2cgKi9cbiAgICBpZiAoYyA9PT0gMHgwMDJGKSB7ICAvLyBTT0xJRFVTXG4gICAgICBiZWdpblRlbXBCdWYoKTtcbiAgICAgIHRva2VuaXplciA9IHJjZGF0YV9lbmRfdGFnX29wZW5fc3RhdGU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGV4dHJ1bi5wdXNoKDB4MDAzQyk7IC8vIExFU1MtVEhBTiBTSUdOXG4gICAgICByZWNvbnN1bWUoYywgcmNkYXRhX3N0YXRlKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByY2RhdGFfZW5kX3RhZ19vcGVuX3N0YXRlKGMpIHtcbiAgICAvKiBpZGVudGljYWwgdG8gdGhlIFJBV1RFWFQgKGFuZCBTY3JpcHQgZGF0YSkgZW5kIHRhZyBvcGVuIHN0YXRlLCBleGNlcHQgcy9SQVdURVhUL1JDREFUQS9nICovXG4gICAgc3dpdGNoKGMpIHtcbiAgICBjYXNlIDB4MDA0MTogIC8vIFtBLVpdXG4gICAgY2FzZSAweDAwNDI6Y2FzZSAweDAwNDM6Y2FzZSAweDAwNDQ6Y2FzZSAweDAwNDU6Y2FzZSAweDAwNDY6XG4gICAgY2FzZSAweDAwNDc6Y2FzZSAweDAwNDg6Y2FzZSAweDAwNDk6Y2FzZSAweDAwNEE6Y2FzZSAweDAwNEI6XG4gICAgY2FzZSAweDAwNEM6Y2FzZSAweDAwNEQ6Y2FzZSAweDAwNEU6Y2FzZSAweDAwNEY6Y2FzZSAweDAwNTA6XG4gICAgY2FzZSAweDAwNTE6Y2FzZSAweDAwNTI6Y2FzZSAweDAwNTM6Y2FzZSAweDAwNTQ6Y2FzZSAweDAwNTU6XG4gICAgY2FzZSAweDAwNTY6Y2FzZSAweDAwNTc6Y2FzZSAweDAwNTg6Y2FzZSAweDAwNTk6Y2FzZSAweDAwNUE6XG4gICAgY2FzZSAweDAwNjE6ICAvLyBbYS16XVxuICAgIGNhc2UgMHgwMDYyOmNhc2UgMHgwMDYzOmNhc2UgMHgwMDY0OmNhc2UgMHgwMDY1OmNhc2UgMHgwMDY2OlxuICAgIGNhc2UgMHgwMDY3OmNhc2UgMHgwMDY4OmNhc2UgMHgwMDY5OmNhc2UgMHgwMDZBOmNhc2UgMHgwMDZCOlxuICAgIGNhc2UgMHgwMDZDOmNhc2UgMHgwMDZEOmNhc2UgMHgwMDZFOmNhc2UgMHgwMDZGOmNhc2UgMHgwMDcwOlxuICAgIGNhc2UgMHgwMDcxOmNhc2UgMHgwMDcyOmNhc2UgMHgwMDczOmNhc2UgMHgwMDc0OmNhc2UgMHgwMDc1OlxuICAgIGNhc2UgMHgwMDc2OmNhc2UgMHgwMDc3OmNhc2UgMHgwMDc4OmNhc2UgMHgwMDc5OmNhc2UgMHgwMDdBOlxuICAgICAgYmVnaW5FbmRUYWdOYW1lKCk7XG4gICAgICByZWNvbnN1bWUoYywgcmNkYXRhX2VuZF90YWdfbmFtZV9zdGF0ZSk7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGV4dHJ1bi5wdXNoKDB4MDAzQyk7IC8vIExFU1MtVEhBTiBTSUdOXG4gICAgICB0ZXh0cnVuLnB1c2goMHgwMDJGKTsgLy8gU09MSURVU1xuICAgICAgcmVjb25zdW1lKGMsIHJjZGF0YV9zdGF0ZSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByY2RhdGFfZW5kX3RhZ19uYW1lX3N0YXRlKGMpIHtcbiAgICAvKiBpZGVudGljYWwgdG8gdGhlIFJBV1RFWFQgKGFuZCBTY3JpcHQgZGF0YSkgZW5kIHRhZyBuYW1lIHN0YXRlLCBleGNlcHQgcy9SQVdURVhUL1JDREFUQS9nICovXG4gICAgc3dpdGNoKGMpIHtcbiAgICBjYXNlIDB4MDAwOTogLy8gQ0hBUkFDVEVSIFRBQlVMQVRJT04gKHRhYilcbiAgICBjYXNlIDB4MDAwQTogLy8gTElORSBGRUVEIChMRilcbiAgICBjYXNlIDB4MDAwQzogLy8gRk9STSBGRUVEIChGRilcbiAgICBjYXNlIDB4MDAyMDogLy8gU1BBQ0VcbiAgICAgIGlmIChhcHByb3ByaWF0ZUVuZFRhZyh0YWduYW1lYnVmKSkge1xuICAgICAgICB0b2tlbml6ZXIgPSBiZWZvcmVfYXR0cmlidXRlX25hbWVfc3RhdGU7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMHgwMDJGOiAvLyBTT0xJRFVTXG4gICAgICBpZiAoYXBwcm9wcmlhdGVFbmRUYWcodGFnbmFtZWJ1ZikpIHtcbiAgICAgICAgdG9rZW5pemVyID0gc2VsZl9jbG9zaW5nX3N0YXJ0X3RhZ19zdGF0ZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAweDAwM0U6IC8vIEdSRUFURVItVEhBTiBTSUdOXG4gICAgICBpZiAoYXBwcm9wcmlhdGVFbmRUYWcodGFnbmFtZWJ1ZikpIHtcbiAgICAgICAgdG9rZW5pemVyID0gZGF0YV9zdGF0ZTtcbiAgICAgICAgZW1pdFRhZygpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlIDB4MDA0MTogIC8vIFtBLVpdXG4gICAgY2FzZSAweDAwNDI6Y2FzZSAweDAwNDM6Y2FzZSAweDAwNDQ6Y2FzZSAweDAwNDU6Y2FzZSAweDAwNDY6XG4gICAgY2FzZSAweDAwNDc6Y2FzZSAweDAwNDg6Y2FzZSAweDAwNDk6Y2FzZSAweDAwNEE6Y2FzZSAweDAwNEI6XG4gICAgY2FzZSAweDAwNEM6Y2FzZSAweDAwNEQ6Y2FzZSAweDAwNEU6Y2FzZSAweDAwNEY6Y2FzZSAweDAwNTA6XG4gICAgY2FzZSAweDAwNTE6Y2FzZSAweDAwNTI6Y2FzZSAweDAwNTM6Y2FzZSAweDAwNTQ6Y2FzZSAweDAwNTU6XG4gICAgY2FzZSAweDAwNTY6Y2FzZSAweDAwNTc6Y2FzZSAweDAwNTg6Y2FzZSAweDAwNTk6Y2FzZSAweDAwNUE6XG5cbiAgICAgIHRhZ25hbWVidWYgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjICsgMHgwMDIwKTtcbiAgICAgIHRlbXBidWYucHVzaChjKTtcbiAgICAgIHJldHVybjtcbiAgICBjYXNlIDB4MDA2MTogIC8vIFthLXpdXG4gICAgY2FzZSAweDAwNjI6Y2FzZSAweDAwNjM6Y2FzZSAweDAwNjQ6Y2FzZSAweDAwNjU6Y2FzZSAweDAwNjY6XG4gICAgY2FzZSAweDAwNjc6Y2FzZSAweDAwNjg6Y2FzZSAweDAwNjk6Y2FzZSAweDAwNkE6Y2FzZSAweDAwNkI6XG4gICAgY2FzZSAweDAwNkM6Y2FzZSAweDAwNkQ6Y2FzZSAweDAwNkU6Y2FzZSAweDAwNkY6Y2FzZSAweDAwNzA6XG4gICAgY2FzZSAweDAwNzE6Y2FzZSAweDAwNzI6Y2FzZSAweDAwNzM6Y2FzZSAweDAwNzQ6Y2FzZSAweDAwNzU6XG4gICAgY2FzZSAweDAwNzY6Y2FzZSAweDAwNzc6Y2FzZSAweDAwNzg6Y2FzZSAweDAwNzk6Y2FzZSAweDAwN0E6XG5cbiAgICAgIHRhZ25hbWVidWYgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjKTtcbiAgICAgIHRlbXBidWYucHVzaChjKTtcbiAgICAgIHJldHVybjtcbiAgICBkZWZhdWx0OlxuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLy8gSWYgd2UgZG9uJ3QgcmV0dXJuIGluIG9uZSBvZiB0aGUgY2FzZXMgYWJvdmUsIHRoZW4gdGhpcyB3YXMgbm90XG4gICAgLy8gYW4gYXBwcm9wcmlhdGVseSBtYXRjaGluZyBjbG9zZSB0YWcsIHNvIGJhY2sgb3V0IGJ5IGVtaXR0aW5nIGFsbFxuICAgIC8vIHRoZSBjaGFyYWN0ZXJzIGFzIHRleHRcbiAgICB0ZXh0cnVuLnB1c2goMHgwMDNDKTsgLy8gTEVTUy1USEFOIFNJR05cbiAgICB0ZXh0cnVuLnB1c2goMHgwMDJGKTsgLy8gU09MSURVU1xuICAgIHB1c2hBbGwodGV4dHJ1biwgdGVtcGJ1Zik7XG4gICAgcmVjb25zdW1lKGMsIHJjZGF0YV9zdGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiByYXd0ZXh0X2xlc3NfdGhhbl9zaWduX3N0YXRlKGMpIHtcbiAgICAvKiBpZGVudGljYWwgdG8gdGhlIFJDREFUQSBsZXNzLXRoYW4gc2lnbiBzdGF0ZSwgZXhjZXB0IHMvUkNEQVRBL1JBV1RFWFQvZ1xuICAgICAqL1xuICAgIGlmIChjID09PSAweDAwMkYpIHsgLy8gU09MSURVU1xuICAgICAgYmVnaW5UZW1wQnVmKCk7XG4gICAgICB0b2tlbml6ZXIgPSByYXd0ZXh0X2VuZF90YWdfb3Blbl9zdGF0ZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0ZXh0cnVuLnB1c2goMHgwMDNDKTsgLy8gTEVTUy1USEFOIFNJR05cbiAgICAgIHJlY29uc3VtZShjLCByYXd0ZXh0X3N0YXRlKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByYXd0ZXh0X2VuZF90YWdfb3Blbl9zdGF0ZShjKSB7XG4gICAgLyogaWRlbnRpY2FsIHRvIHRoZSBSQ0RBVEEgKGFuZCBTY3JpcHQgZGF0YSkgZW5kIHRhZyBvcGVuIHN0YXRlLCBleGNlcHQgcy9SQ0RBVEEvUkFXVEVYVC9nICovXG4gICAgc3dpdGNoKGMpIHtcbiAgICBjYXNlIDB4MDA0MTogIC8vIFtBLVpdXG4gICAgY2FzZSAweDAwNDI6Y2FzZSAweDAwNDM6Y2FzZSAweDAwNDQ6Y2FzZSAweDAwNDU6Y2FzZSAweDAwNDY6XG4gICAgY2FzZSAweDAwNDc6Y2FzZSAweDAwNDg6Y2FzZSAweDAwNDk6Y2FzZSAweDAwNEE6Y2FzZSAweDAwNEI6XG4gICAgY2FzZSAweDAwNEM6Y2FzZSAweDAwNEQ6Y2FzZSAweDAwNEU6Y2FzZSAweDAwNEY6Y2FzZSAweDAwNTA6XG4gICAgY2FzZSAweDAwNTE6Y2FzZSAweDAwNTI6Y2FzZSAweDAwNTM6Y2FzZSAweDAwNTQ6Y2FzZSAweDAwNTU6XG4gICAgY2FzZSAweDAwNTY6Y2FzZSAweDAwNTc6Y2FzZSAweDAwNTg6Y2FzZSAweDAwNTk6Y2FzZSAweDAwNUE6XG4gICAgY2FzZSAweDAwNjE6ICAvLyBbYS16XVxuICAgIGNhc2UgMHgwMDYyOmNhc2UgMHgwMDYzOmNhc2UgMHgwMDY0OmNhc2UgMHgwMDY1OmNhc2UgMHgwMDY2OlxuICAgIGNhc2UgMHgwMDY3OmNhc2UgMHgwMDY4OmNhc2UgMHgwMDY5OmNhc2UgMHgwMDZBOmNhc2UgMHgwMDZCOlxuICAgIGNhc2UgMHgwMDZDOmNhc2UgMHgwMDZEOmNhc2UgMHgwMDZFOmNhc2UgMHgwMDZGOmNhc2UgMHgwMDcwOlxuICAgIGNhc2UgMHgwMDcxOmNhc2UgMHgwMDcyOmNhc2UgMHgwMDczOmNhc2UgMHgwMDc0OmNhc2UgMHgwMDc1OlxuICAgIGNhc2UgMHgwMDc2OmNhc2UgMHgwMDc3OmNhc2UgMHgwMDc4OmNhc2UgMHgwMDc5OmNhc2UgMHgwMDdBOlxuICAgICAgYmVnaW5FbmRUYWdOYW1lKCk7XG4gICAgICByZWNvbnN1bWUoYywgcmF3dGV4dF9lbmRfdGFnX25hbWVfc3RhdGUpO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRleHRydW4ucHVzaCgweDAwM0MpOyAvLyBMRVNTLVRIQU4gU0lHTlxuICAgICAgdGV4dHJ1bi5wdXNoKDB4MDAyRik7IC8vIFNPTElEVVNcbiAgICAgIHJlY29uc3VtZShjLCByYXd0ZXh0X3N0YXRlKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJhd3RleHRfZW5kX3RhZ19uYW1lX3N0YXRlKGMpIHtcbiAgICAvKiBpZGVudGljYWwgdG8gdGhlIFJDREFUQSAoYW5kIFNjcmlwdCBkYXRhKSBlbmQgdGFnIG5hbWUgc3RhdGUsIGV4Y2VwdCBzL1JDREFUQS9SQVdURVhUL2cgKi9cbiAgICBzd2l0Y2goYykge1xuICAgIGNhc2UgMHgwMDA5OiAvLyBDSEFSQUNURVIgVEFCVUxBVElPTiAodGFiKVxuICAgIGNhc2UgMHgwMDBBOiAvLyBMSU5FIEZFRUQgKExGKVxuICAgIGNhc2UgMHgwMDBDOiAvLyBGT1JNIEZFRUQgKEZGKVxuICAgIGNhc2UgMHgwMDIwOiAvLyBTUEFDRVxuICAgICAgaWYgKGFwcHJvcHJpYXRlRW5kVGFnKHRhZ25hbWVidWYpKSB7XG4gICAgICAgIHRva2VuaXplciA9IGJlZm9yZV9hdHRyaWJ1dGVfbmFtZV9zdGF0ZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAweDAwMkY6IC8vIFNPTElEVVNcbiAgICAgIGlmIChhcHByb3ByaWF0ZUVuZFRhZyh0YWduYW1lYnVmKSkge1xuICAgICAgICB0b2tlbml6ZXIgPSBzZWxmX2Nsb3Npbmdfc3RhcnRfdGFnX3N0YXRlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlIDB4MDAzRTogLy8gR1JFQVRFUi1USEFOIFNJR05cbiAgICAgIGlmIChhcHByb3ByaWF0ZUVuZFRhZyh0YWduYW1lYnVmKSkge1xuICAgICAgICB0b2tlbml6ZXIgPSBkYXRhX3N0YXRlO1xuICAgICAgICBlbWl0VGFnKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMHgwMDQxOiAgLy8gW0EtWl1cbiAgICBjYXNlIDB4MDA0MjpjYXNlIDB4MDA0MzpjYXNlIDB4MDA0NDpjYXNlIDB4MDA0NTpjYXNlIDB4MDA0NjpcbiAgICBjYXNlIDB4MDA0NzpjYXNlIDB4MDA0ODpjYXNlIDB4MDA0OTpjYXNlIDB4MDA0QTpjYXNlIDB4MDA0QjpcbiAgICBjYXNlIDB4MDA0QzpjYXNlIDB4MDA0RDpjYXNlIDB4MDA0RTpjYXNlIDB4MDA0RjpjYXNlIDB4MDA1MDpcbiAgICBjYXNlIDB4MDA1MTpjYXNlIDB4MDA1MjpjYXNlIDB4MDA1MzpjYXNlIDB4MDA1NDpjYXNlIDB4MDA1NTpcbiAgICBjYXNlIDB4MDA1NjpjYXNlIDB4MDA1NzpjYXNlIDB4MDA1ODpjYXNlIDB4MDA1OTpjYXNlIDB4MDA1QTpcbiAgICAgIHRhZ25hbWVidWYgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjICsgMHgwMDIwKTtcbiAgICAgIHRlbXBidWYucHVzaChjKTtcbiAgICAgIHJldHVybjtcbiAgICBjYXNlIDB4MDA2MTogIC8vIFthLXpdXG4gICAgY2FzZSAweDAwNjI6Y2FzZSAweDAwNjM6Y2FzZSAweDAwNjQ6Y2FzZSAweDAwNjU6Y2FzZSAweDAwNjY6XG4gICAgY2FzZSAweDAwNjc6Y2FzZSAweDAwNjg6Y2FzZSAweDAwNjk6Y2FzZSAweDAwNkE6Y2FzZSAweDAwNkI6XG4gICAgY2FzZSAweDAwNkM6Y2FzZSAweDAwNkQ6Y2FzZSAweDAwNkU6Y2FzZSAweDAwNkY6Y2FzZSAweDAwNzA6XG4gICAgY2FzZSAweDAwNzE6Y2FzZSAweDAwNzI6Y2FzZSAweDAwNzM6Y2FzZSAweDAwNzQ6Y2FzZSAweDAwNzU6XG4gICAgY2FzZSAweDAwNzY6Y2FzZSAweDAwNzc6Y2FzZSAweDAwNzg6Y2FzZSAweDAwNzk6Y2FzZSAweDAwN0E6XG4gICAgICB0YWduYW1lYnVmICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYyk7XG4gICAgICB0ZW1wYnVmLnB1c2goYyk7XG4gICAgICByZXR1cm47XG4gICAgZGVmYXVsdDpcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8vIElmIHdlIGRvbid0IHJldHVybiBpbiBvbmUgb2YgdGhlIGNhc2VzIGFib3ZlLCB0aGVuIHRoaXMgd2FzIG5vdFxuICAgIC8vIGFuIGFwcHJvcHJpYXRlbHkgbWF0Y2hpbmcgY2xvc2UgdGFnLCBzbyBiYWNrIG91dCBieSBlbWl0dGluZyBhbGxcbiAgICAvLyB0aGUgY2hhcmFjdGVycyBhcyB0ZXh0XG4gICAgdGV4dHJ1bi5wdXNoKDB4MDAzQyk7IC8vIExFU1MtVEhBTiBTSUdOXG4gICAgdGV4dHJ1bi5wdXNoKDB4MDAyRik7IC8vIFNPTElEVVNcbiAgICBwdXNoQWxsKHRleHRydW4sdGVtcGJ1Zik7XG4gICAgcmVjb25zdW1lKGMsIHJhd3RleHRfc3RhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gc2NyaXB0X2RhdGFfbGVzc190aGFuX3NpZ25fc3RhdGUoYykge1xuICAgIHN3aXRjaChjKSB7XG4gICAgY2FzZSAweDAwMkY6IC8vIFNPTElEVVNcbiAgICAgIGJlZ2luVGVtcEJ1ZigpO1xuICAgICAgdG9rZW5pemVyID0gc2NyaXB0X2RhdGFfZW5kX3RhZ19vcGVuX3N0YXRlO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAweDAwMjE6IC8vIEVYQ0xBTUFUSU9OIE1BUktcbiAgICAgIHRva2VuaXplciA9IHNjcmlwdF9kYXRhX2VzY2FwZV9zdGFydF9zdGF0ZTtcbiAgICAgIHRleHRydW4ucHVzaCgweDAwM0MpOyAvLyBMRVNTLVRIQU4gU0lHTlxuICAgICAgdGV4dHJ1bi5wdXNoKDB4MDAyMSk7IC8vIEVYQ0xBTUFUSU9OIE1BUktcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0ZXh0cnVuLnB1c2goMHgwMDNDKTsgLy8gTEVTUy1USEFOIFNJR05cbiAgICAgIHJlY29uc3VtZShjLCBzY3JpcHRfZGF0YV9zdGF0ZSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzY3JpcHRfZGF0YV9lbmRfdGFnX29wZW5fc3RhdGUoYykge1xuICAgIC8qIGlkZW50aWNhbCB0byB0aGUgUkNEQVRBIChhbmQgUkFXVEVYVCkgZW5kIHRhZyBvcGVuIHN0YXRlLCBleGNlcHQgcy9SQ0RBVEEvU2NyaXB0IGRhdGEvZyAqL1xuICAgIHN3aXRjaChjKSB7XG4gICAgY2FzZSAweDAwNDE6ICAvLyBbQS1aXVxuICAgIGNhc2UgMHgwMDQyOmNhc2UgMHgwMDQzOmNhc2UgMHgwMDQ0OmNhc2UgMHgwMDQ1OmNhc2UgMHgwMDQ2OlxuICAgIGNhc2UgMHgwMDQ3OmNhc2UgMHgwMDQ4OmNhc2UgMHgwMDQ5OmNhc2UgMHgwMDRBOmNhc2UgMHgwMDRCOlxuICAgIGNhc2UgMHgwMDRDOmNhc2UgMHgwMDREOmNhc2UgMHgwMDRFOmNhc2UgMHgwMDRGOmNhc2UgMHgwMDUwOlxuICAgIGNhc2UgMHgwMDUxOmNhc2UgMHgwMDUyOmNhc2UgMHgwMDUzOmNhc2UgMHgwMDU0OmNhc2UgMHgwMDU1OlxuICAgIGNhc2UgMHgwMDU2OmNhc2UgMHgwMDU3OmNhc2UgMHgwMDU4OmNhc2UgMHgwMDU5OmNhc2UgMHgwMDVBOlxuICAgIGNhc2UgMHgwMDYxOiAgLy8gW2Etel1cbiAgICBjYXNlIDB4MDA2MjpjYXNlIDB4MDA2MzpjYXNlIDB4MDA2NDpjYXNlIDB4MDA2NTpjYXNlIDB4MDA2NjpcbiAgICBjYXNlIDB4MDA2NzpjYXNlIDB4MDA2ODpjYXNlIDB4MDA2OTpjYXNlIDB4MDA2QTpjYXNlIDB4MDA2QjpcbiAgICBjYXNlIDB4MDA2QzpjYXNlIDB4MDA2RDpjYXNlIDB4MDA2RTpjYXNlIDB4MDA2RjpjYXNlIDB4MDA3MDpcbiAgICBjYXNlIDB4MDA3MTpjYXNlIDB4MDA3MjpjYXNlIDB4MDA3MzpjYXNlIDB4MDA3NDpjYXNlIDB4MDA3NTpcbiAgICBjYXNlIDB4MDA3NjpjYXNlIDB4MDA3NzpjYXNlIDB4MDA3ODpjYXNlIDB4MDA3OTpjYXNlIDB4MDA3QTpcbiAgICAgIGJlZ2luRW5kVGFnTmFtZSgpO1xuICAgICAgcmVjb25zdW1lKGMsIHNjcmlwdF9kYXRhX2VuZF90YWdfbmFtZV9zdGF0ZSk7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGV4dHJ1bi5wdXNoKDB4MDAzQyk7IC8vIExFU1MtVEhBTiBTSUdOXG4gICAgICB0ZXh0cnVuLnB1c2goMHgwMDJGKTsgLy8gU09MSURVU1xuICAgICAgcmVjb25zdW1lKGMsIHNjcmlwdF9kYXRhX3N0YXRlKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNjcmlwdF9kYXRhX2VuZF90YWdfbmFtZV9zdGF0ZShjKSB7XG4gICAgLyogaWRlbnRpY2FsIHRvIHRoZSBSQ0RBVEEgKGFuZCBSQVdURVhUKSBlbmQgdGFnIG5hbWUgc3RhdGUsIGV4Y2VwdCBzL1JDREFUQS9TY3JpcHQgZGF0YS9nICovXG4gICAgc3dpdGNoKGMpIHtcbiAgICBjYXNlIDB4MDAwOTogLy8gQ0hBUkFDVEVSIFRBQlVMQVRJT04gKHRhYilcbiAgICBjYXNlIDB4MDAwQTogLy8gTElORSBGRUVEIChMRilcbiAgICBjYXNlIDB4MDAwQzogLy8gRk9STSBGRUVEIChGRilcbiAgICBjYXNlIDB4MDAyMDogLy8gU1BBQ0VcbiAgICAgIGlmIChhcHByb3ByaWF0ZUVuZFRhZyh0YWduYW1lYnVmKSkge1xuICAgICAgICB0b2tlbml6ZXIgPSBiZWZvcmVfYXR0cmlidXRlX25hbWVfc3RhdGU7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMHgwMDJGOiAvLyBTT0xJRFVTXG4gICAgICBpZiAoYXBwcm9wcmlhdGVFbmRUYWcodGFnbmFtZWJ1ZikpIHtcbiAgICAgICAgdG9rZW5pemVyID0gc2VsZl9jbG9zaW5nX3N0YXJ0X3RhZ19zdGF0ZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAweDAwM0U6IC8vIEdSRUFURVItVEhBTiBTSUdOXG4gICAgICBpZiAoYXBwcm9wcmlhdGVFbmRUYWcodGFnbmFtZWJ1ZikpIHtcbiAgICAgICAgdG9rZW5pemVyID0gZGF0YV9zdGF0ZTtcbiAgICAgICAgZW1pdFRhZygpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlIDB4MDA0MTogIC8vIFtBLVpdXG4gICAgY2FzZSAweDAwNDI6Y2FzZSAweDAwNDM6Y2FzZSAweDAwNDQ6Y2FzZSAweDAwNDU6Y2FzZSAweDAwNDY6XG4gICAgY2FzZSAweDAwNDc6Y2FzZSAweDAwNDg6Y2FzZSAweDAwNDk6Y2FzZSAweDAwNEE6Y2FzZSAweDAwNEI6XG4gICAgY2FzZSAweDAwNEM6Y2FzZSAweDAwNEQ6Y2FzZSAweDAwNEU6Y2FzZSAweDAwNEY6Y2FzZSAweDAwNTA6XG4gICAgY2FzZSAweDAwNTE6Y2FzZSAweDAwNTI6Y2FzZSAweDAwNTM6Y2FzZSAweDAwNTQ6Y2FzZSAweDAwNTU6XG4gICAgY2FzZSAweDAwNTY6Y2FzZSAweDAwNTc6Y2FzZSAweDAwNTg6Y2FzZSAweDAwNTk6Y2FzZSAweDAwNUE6XG5cbiAgICAgIHRhZ25hbWVidWYgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjICsgMHgwMDIwKTtcbiAgICAgIHRlbXBidWYucHVzaChjKTtcbiAgICAgIHJldHVybjtcbiAgICBjYXNlIDB4MDA2MTogIC8vIFthLXpdXG4gICAgY2FzZSAweDAwNjI6Y2FzZSAweDAwNjM6Y2FzZSAweDAwNjQ6Y2FzZSAweDAwNjU6Y2FzZSAweDAwNjY6XG4gICAgY2FzZSAweDAwNjc6Y2FzZSAweDAwNjg6Y2FzZSAweDAwNjk6Y2FzZSAweDAwNkE6Y2FzZSAweDAwNkI6XG4gICAgY2FzZSAweDAwNkM6Y2FzZSAweDAwNkQ6Y2FzZSAweDAwNkU6Y2FzZSAweDAwNkY6Y2FzZSAweDAwNzA6XG4gICAgY2FzZSAweDAwNzE6Y2FzZSAweDAwNzI6Y2FzZSAweDAwNzM6Y2FzZSAweDAwNzQ6Y2FzZSAweDAwNzU6XG4gICAgY2FzZSAweDAwNzY6Y2FzZSAweDAwNzc6Y2FzZSAweDAwNzg6Y2FzZSAweDAwNzk6Y2FzZSAweDAwN0E6XG5cbiAgICAgIHRhZ25hbWVidWYgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjKTtcbiAgICAgIHRlbXBidWYucHVzaChjKTtcbiAgICAgIHJldHVybjtcbiAgICBkZWZhdWx0OlxuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLy8gSWYgd2UgZG9uJ3QgcmV0dXJuIGluIG9uZSBvZiB0aGUgY2FzZXMgYWJvdmUsIHRoZW4gdGhpcyB3YXMgbm90XG4gICAgLy8gYW4gYXBwcm9wcmlhdGVseSBtYXRjaGluZyBjbG9zZSB0YWcsIHNvIGJhY2sgb3V0IGJ5IGVtaXR0aW5nIGFsbFxuICAgIC8vIHRoZSBjaGFyYWN0ZXJzIGFzIHRleHRcbiAgICB0ZXh0cnVuLnB1c2goMHgwMDNDKTsgLy8gTEVTUy1USEFOIFNJR05cbiAgICB0ZXh0cnVuLnB1c2goMHgwMDJGKTsgLy8gU09MSURVU1xuICAgIHB1c2hBbGwodGV4dHJ1bix0ZW1wYnVmKTtcbiAgICByZWNvbnN1bWUoYywgc2NyaXB0X2RhdGFfc3RhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gc2NyaXB0X2RhdGFfZXNjYXBlX3N0YXJ0X3N0YXRlKGMpIHtcbiAgICBpZiAoYyA9PT0gMHgwMDJEKSB7IC8vIEhZUEhFTi1NSU5VU1xuICAgICAgdG9rZW5pemVyID0gc2NyaXB0X2RhdGFfZXNjYXBlX3N0YXJ0X2Rhc2hfc3RhdGU7XG4gICAgICB0ZXh0cnVuLnB1c2goMHgwMDJEKTsgLy8gSFlQSEVOLU1JTlVTXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmVjb25zdW1lKGMsIHNjcmlwdF9kYXRhX3N0YXRlKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzY3JpcHRfZGF0YV9lc2NhcGVfc3RhcnRfZGFzaF9zdGF0ZShjKSB7XG4gICAgaWYgKGMgPT09IDB4MDAyRCkgeyAvLyBIWVBIRU4tTUlOVVNcbiAgICAgIHRva2VuaXplciA9IHNjcmlwdF9kYXRhX2VzY2FwZWRfZGFzaF9kYXNoX3N0YXRlO1xuICAgICAgdGV4dHJ1bi5wdXNoKDB4MDAyRCk7IC8vIEhZUEhFTi1NSU5VU1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHJlY29uc3VtZShjLCBzY3JpcHRfZGF0YV9zdGF0ZSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2NyaXB0X2RhdGFfZXNjYXBlZF9zdGF0ZShjKSB7XG4gICAgc3dpdGNoKGMpIHtcbiAgICBjYXNlIDB4MDAyRDogLy8gSFlQSEVOLU1JTlVTXG4gICAgICB0b2tlbml6ZXIgPSBzY3JpcHRfZGF0YV9lc2NhcGVkX2Rhc2hfc3RhdGU7XG4gICAgICB0ZXh0cnVuLnB1c2goMHgwMDJEKTsgLy8gSFlQSEVOLU1JTlVTXG4gICAgICBicmVhaztcbiAgICBjYXNlIDB4MDAzQzogLy8gTEVTUy1USEFOIFNJR05cbiAgICAgIHRva2VuaXplciA9IHNjcmlwdF9kYXRhX2VzY2FwZWRfbGVzc190aGFuX3NpZ25fc3RhdGU7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDB4MDAwMDogLy8gTlVMTFxuICAgICAgdGV4dHJ1bi5wdXNoKDB4RkZGRCk7IC8vIFJFUExBQ0VNRU5UIENIQVJBQ1RFUlxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAtMTogLy8gRU9GXG4gICAgICBlbWl0RU9GKCk7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGV4dHJ1bi5wdXNoKGMpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2NyaXB0X2RhdGFfZXNjYXBlZF9kYXNoX3N0YXRlKGMpIHtcbiAgICBzd2l0Y2goYykge1xuICAgIGNhc2UgMHgwMDJEOiAvLyBIWVBIRU4tTUlOVVNcbiAgICAgIHRva2VuaXplciA9IHNjcmlwdF9kYXRhX2VzY2FwZWRfZGFzaF9kYXNoX3N0YXRlO1xuICAgICAgdGV4dHJ1bi5wdXNoKDB4MDAyRCk7IC8vIEhZUEhFTi1NSU5VU1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAweDAwM0M6IC8vIExFU1MtVEhBTiBTSUdOXG4gICAgICB0b2tlbml6ZXIgPSBzY3JpcHRfZGF0YV9lc2NhcGVkX2xlc3NfdGhhbl9zaWduX3N0YXRlO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAweDAwMDA6IC8vIE5VTExcbiAgICAgIHRva2VuaXplciA9IHNjcmlwdF9kYXRhX2VzY2FwZWRfc3RhdGU7XG4gICAgICB0ZXh0cnVuLnB1c2goMHhGRkZEKTsgLy8gUkVQTEFDRU1FTlQgQ0hBUkFDVEVSXG4gICAgICBicmVhaztcbiAgICBjYXNlIC0xOiAvLyBFT0ZcbiAgICAgIGVtaXRFT0YoKTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0b2tlbml6ZXIgPSBzY3JpcHRfZGF0YV9lc2NhcGVkX3N0YXRlO1xuICAgICAgdGV4dHJ1bi5wdXNoKGMpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2NyaXB0X2RhdGFfZXNjYXBlZF9kYXNoX2Rhc2hfc3RhdGUoYykge1xuICAgIHN3aXRjaChjKSB7XG4gICAgY2FzZSAweDAwMkQ6IC8vIEhZUEhFTi1NSU5VU1xuICAgICAgdGV4dHJ1bi5wdXNoKDB4MDAyRCk7IC8vIEhZUEhFTi1NSU5VU1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAweDAwM0M6IC8vIExFU1MtVEhBTiBTSUdOXG4gICAgICB0b2tlbml6ZXIgPSBzY3JpcHRfZGF0YV9lc2NhcGVkX2xlc3NfdGhhbl9zaWduX3N0YXRlO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAweDAwM0U6IC8vIEdSRUFURVItVEhBTiBTSUdOXG4gICAgICB0b2tlbml6ZXIgPSBzY3JpcHRfZGF0YV9zdGF0ZTtcbiAgICAgIHRleHRydW4ucHVzaCgweDAwM0UpOyAvLyBHUkVBVEVSLVRIQU4gU0lHTlxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAweDAwMDA6IC8vIE5VTExcbiAgICAgIHRva2VuaXplciA9IHNjcmlwdF9kYXRhX2VzY2FwZWRfc3RhdGU7XG4gICAgICB0ZXh0cnVuLnB1c2goMHhGRkZEKTsgLy8gUkVQTEFDRU1FTlQgQ0hBUkFDVEVSXG4gICAgICBicmVhaztcbiAgICBjYXNlIC0xOiAvLyBFT0ZcbiAgICAgIGVtaXRFT0YoKTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0b2tlbml6ZXIgPSBzY3JpcHRfZGF0YV9lc2NhcGVkX3N0YXRlO1xuICAgICAgdGV4dHJ1bi5wdXNoKGMpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2NyaXB0X2RhdGFfZXNjYXBlZF9sZXNzX3RoYW5fc2lnbl9zdGF0ZShjKSB7XG4gICAgc3dpdGNoKGMpIHtcbiAgICBjYXNlIDB4MDAyRjogLy8gU09MSURVU1xuICAgICAgYmVnaW5UZW1wQnVmKCk7XG4gICAgICB0b2tlbml6ZXIgPSBzY3JpcHRfZGF0YV9lc2NhcGVkX2VuZF90YWdfb3Blbl9zdGF0ZTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMHgwMDQxOiAgLy8gW0EtWl1cbiAgICBjYXNlIDB4MDA0MjpjYXNlIDB4MDA0MzpjYXNlIDB4MDA0NDpjYXNlIDB4MDA0NTpjYXNlIDB4MDA0NjpcbiAgICBjYXNlIDB4MDA0NzpjYXNlIDB4MDA0ODpjYXNlIDB4MDA0OTpjYXNlIDB4MDA0QTpjYXNlIDB4MDA0QjpcbiAgICBjYXNlIDB4MDA0QzpjYXNlIDB4MDA0RDpjYXNlIDB4MDA0RTpjYXNlIDB4MDA0RjpjYXNlIDB4MDA1MDpcbiAgICBjYXNlIDB4MDA1MTpjYXNlIDB4MDA1MjpjYXNlIDB4MDA1MzpjYXNlIDB4MDA1NDpjYXNlIDB4MDA1NTpcbiAgICBjYXNlIDB4MDA1NjpjYXNlIDB4MDA1NzpjYXNlIDB4MDA1ODpjYXNlIDB4MDA1OTpjYXNlIDB4MDA1QTpcbiAgICBjYXNlIDB4MDA2MTogIC8vIFthLXpdXG4gICAgY2FzZSAweDAwNjI6Y2FzZSAweDAwNjM6Y2FzZSAweDAwNjQ6Y2FzZSAweDAwNjU6Y2FzZSAweDAwNjY6XG4gICAgY2FzZSAweDAwNjc6Y2FzZSAweDAwNjg6Y2FzZSAweDAwNjk6Y2FzZSAweDAwNkE6Y2FzZSAweDAwNkI6XG4gICAgY2FzZSAweDAwNkM6Y2FzZSAweDAwNkQ6Y2FzZSAweDAwNkU6Y2FzZSAweDAwNkY6Y2FzZSAweDAwNzA6XG4gICAgY2FzZSAweDAwNzE6Y2FzZSAweDAwNzI6Y2FzZSAweDAwNzM6Y2FzZSAweDAwNzQ6Y2FzZSAweDAwNzU6XG4gICAgY2FzZSAweDAwNzY6Y2FzZSAweDAwNzc6Y2FzZSAweDAwNzg6Y2FzZSAweDAwNzk6Y2FzZSAweDAwN0E6XG4gICAgICBiZWdpblRlbXBCdWYoKTtcbiAgICAgIHRleHRydW4ucHVzaCgweDAwM0MpOyAvLyBMRVNTLVRIQU4gU0lHTlxuICAgICAgcmVjb25zdW1lKGMsIHNjcmlwdF9kYXRhX2RvdWJsZV9lc2NhcGVfc3RhcnRfc3RhdGUpO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRleHRydW4ucHVzaCgweDAwM0MpOyAvLyBMRVNTLVRIQU4gU0lHTlxuICAgICAgcmVjb25zdW1lKGMsIHNjcmlwdF9kYXRhX2VzY2FwZWRfc3RhdGUpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2NyaXB0X2RhdGFfZXNjYXBlZF9lbmRfdGFnX29wZW5fc3RhdGUoYykge1xuICAgIHN3aXRjaChjKSB7XG4gICAgY2FzZSAweDAwNDE6ICAvLyBbQS1aXVxuICAgIGNhc2UgMHgwMDQyOmNhc2UgMHgwMDQzOmNhc2UgMHgwMDQ0OmNhc2UgMHgwMDQ1OmNhc2UgMHgwMDQ2OlxuICAgIGNhc2UgMHgwMDQ3OmNhc2UgMHgwMDQ4OmNhc2UgMHgwMDQ5OmNhc2UgMHgwMDRBOmNhc2UgMHgwMDRCOlxuICAgIGNhc2UgMHgwMDRDOmNhc2UgMHgwMDREOmNhc2UgMHgwMDRFOmNhc2UgMHgwMDRGOmNhc2UgMHgwMDUwOlxuICAgIGNhc2UgMHgwMDUxOmNhc2UgMHgwMDUyOmNhc2UgMHgwMDUzOmNhc2UgMHgwMDU0OmNhc2UgMHgwMDU1OlxuICAgIGNhc2UgMHgwMDU2OmNhc2UgMHgwMDU3OmNhc2UgMHgwMDU4OmNhc2UgMHgwMDU5OmNhc2UgMHgwMDVBOlxuICAgIGNhc2UgMHgwMDYxOiAgLy8gW2Etel1cbiAgICBjYXNlIDB4MDA2MjpjYXNlIDB4MDA2MzpjYXNlIDB4MDA2NDpjYXNlIDB4MDA2NTpjYXNlIDB4MDA2NjpcbiAgICBjYXNlIDB4MDA2NzpjYXNlIDB4MDA2ODpjYXNlIDB4MDA2OTpjYXNlIDB4MDA2QTpjYXNlIDB4MDA2QjpcbiAgICBjYXNlIDB4MDA2QzpjYXNlIDB4MDA2RDpjYXNlIDB4MDA2RTpjYXNlIDB4MDA2RjpjYXNlIDB4MDA3MDpcbiAgICBjYXNlIDB4MDA3MTpjYXNlIDB4MDA3MjpjYXNlIDB4MDA3MzpjYXNlIDB4MDA3NDpjYXNlIDB4MDA3NTpcbiAgICBjYXNlIDB4MDA3NjpjYXNlIDB4MDA3NzpjYXNlIDB4MDA3ODpjYXNlIDB4MDA3OTpjYXNlIDB4MDA3QTpcbiAgICAgIGJlZ2luRW5kVGFnTmFtZSgpO1xuICAgICAgcmVjb25zdW1lKGMsIHNjcmlwdF9kYXRhX2VzY2FwZWRfZW5kX3RhZ19uYW1lX3N0YXRlKTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0ZXh0cnVuLnB1c2goMHgwMDNDKTsgLy8gTEVTUy1USEFOIFNJR05cbiAgICAgIHRleHRydW4ucHVzaCgweDAwMkYpOyAvLyBTT0xJRFVTXG4gICAgICByZWNvbnN1bWUoYywgc2NyaXB0X2RhdGFfZXNjYXBlZF9zdGF0ZSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzY3JpcHRfZGF0YV9lc2NhcGVkX2VuZF90YWdfbmFtZV9zdGF0ZShjKSB7XG4gICAgc3dpdGNoKGMpIHtcbiAgICBjYXNlIDB4MDAwOTogLy8gQ0hBUkFDVEVSIFRBQlVMQVRJT04gKHRhYilcbiAgICBjYXNlIDB4MDAwQTogLy8gTElORSBGRUVEIChMRilcbiAgICBjYXNlIDB4MDAwQzogLy8gRk9STSBGRUVEIChGRilcbiAgICBjYXNlIDB4MDAyMDogLy8gU1BBQ0VcbiAgICAgIGlmIChhcHByb3ByaWF0ZUVuZFRhZyh0YWduYW1lYnVmKSkge1xuICAgICAgICB0b2tlbml6ZXIgPSBiZWZvcmVfYXR0cmlidXRlX25hbWVfc3RhdGU7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMHgwMDJGOiAvLyBTT0xJRFVTXG4gICAgICBpZiAoYXBwcm9wcmlhdGVFbmRUYWcodGFnbmFtZWJ1ZikpIHtcbiAgICAgICAgdG9rZW5pemVyID0gc2VsZl9jbG9zaW5nX3N0YXJ0X3RhZ19zdGF0ZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAweDAwM0U6IC8vIEdSRUFURVItVEhBTiBTSUdOXG4gICAgICBpZiAoYXBwcm9wcmlhdGVFbmRUYWcodGFnbmFtZWJ1ZikpIHtcbiAgICAgICAgdG9rZW5pemVyID0gZGF0YV9zdGF0ZTtcbiAgICAgICAgZW1pdFRhZygpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlIDB4MDA0MTogIC8vIFtBLVpdXG4gICAgY2FzZSAweDAwNDI6Y2FzZSAweDAwNDM6Y2FzZSAweDAwNDQ6Y2FzZSAweDAwNDU6Y2FzZSAweDAwNDY6XG4gICAgY2FzZSAweDAwNDc6Y2FzZSAweDAwNDg6Y2FzZSAweDAwNDk6Y2FzZSAweDAwNEE6Y2FzZSAweDAwNEI6XG4gICAgY2FzZSAweDAwNEM6Y2FzZSAweDAwNEQ6Y2FzZSAweDAwNEU6Y2FzZSAweDAwNEY6Y2FzZSAweDAwNTA6XG4gICAgY2FzZSAweDAwNTE6Y2FzZSAweDAwNTI6Y2FzZSAweDAwNTM6Y2FzZSAweDAwNTQ6Y2FzZSAweDAwNTU6XG4gICAgY2FzZSAweDAwNTY6Y2FzZSAweDAwNTc6Y2FzZSAweDAwNTg6Y2FzZSAweDAwNTk6Y2FzZSAweDAwNUE6XG4gICAgICB0YWduYW1lYnVmICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYyArIDB4MDAyMCk7XG4gICAgICB0ZW1wYnVmLnB1c2goYyk7XG4gICAgICByZXR1cm47XG4gICAgY2FzZSAweDAwNjE6ICAvLyBbYS16XVxuICAgIGNhc2UgMHgwMDYyOmNhc2UgMHgwMDYzOmNhc2UgMHgwMDY0OmNhc2UgMHgwMDY1OmNhc2UgMHgwMDY2OlxuICAgIGNhc2UgMHgwMDY3OmNhc2UgMHgwMDY4OmNhc2UgMHgwMDY5OmNhc2UgMHgwMDZBOmNhc2UgMHgwMDZCOlxuICAgIGNhc2UgMHgwMDZDOmNhc2UgMHgwMDZEOmNhc2UgMHgwMDZFOmNhc2UgMHgwMDZGOmNhc2UgMHgwMDcwOlxuICAgIGNhc2UgMHgwMDcxOmNhc2UgMHgwMDcyOmNhc2UgMHgwMDczOmNhc2UgMHgwMDc0OmNhc2UgMHgwMDc1OlxuICAgIGNhc2UgMHgwMDc2OmNhc2UgMHgwMDc3OmNhc2UgMHgwMDc4OmNhc2UgMHgwMDc5OmNhc2UgMHgwMDdBOlxuICAgICAgdGFnbmFtZWJ1ZiArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGMpO1xuICAgICAgdGVtcGJ1Zi5wdXNoKGMpO1xuICAgICAgcmV0dXJuO1xuICAgIGRlZmF1bHQ6XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvLyBXZSBnZXQgaGVyZSBpbiB0aGUgZGVmYXVsdCBjYXNlLCBhbmQgaWYgdGhlIGNsb3NpbmcgdGFnbmFtZVxuICAgIC8vIGlzIG5vdCBhbiBhcHByb3ByaWF0ZSB0YWduYW1lLlxuICAgIHRleHRydW4ucHVzaCgweDAwM0MpOyAvLyBMRVNTLVRIQU4gU0lHTlxuICAgIHRleHRydW4ucHVzaCgweDAwMkYpOyAvLyBTT0xJRFVTXG4gICAgcHVzaEFsbCh0ZXh0cnVuLHRlbXBidWYpO1xuICAgIHJlY29uc3VtZShjLCBzY3JpcHRfZGF0YV9lc2NhcGVkX3N0YXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNjcmlwdF9kYXRhX2RvdWJsZV9lc2NhcGVfc3RhcnRfc3RhdGUoYykge1xuICAgIHN3aXRjaChjKSB7XG4gICAgY2FzZSAweDAwMDk6IC8vIENIQVJBQ1RFUiBUQUJVTEFUSU9OICh0YWIpXG4gICAgY2FzZSAweDAwMEE6IC8vIExJTkUgRkVFRCAoTEYpXG4gICAgY2FzZSAweDAwMEM6IC8vIEZPUk0gRkVFRCAoRkYpXG4gICAgY2FzZSAweDAwMjA6IC8vIFNQQUNFXG4gICAgY2FzZSAweDAwMkY6IC8vIFNPTElEVVNcbiAgICBjYXNlIDB4MDAzRTogLy8gR1JFQVRFUi1USEFOIFNJR05cbiAgICAgIGlmIChidWYyc3RyKHRlbXBidWYpID09PSBcInNjcmlwdFwiKSB7XG4gICAgICAgIHRva2VuaXplciA9IHNjcmlwdF9kYXRhX2RvdWJsZV9lc2NhcGVkX3N0YXRlO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRva2VuaXplciA9IHNjcmlwdF9kYXRhX2VzY2FwZWRfc3RhdGU7XG4gICAgICB9XG4gICAgICB0ZXh0cnVuLnB1c2goYyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDB4MDA0MTogIC8vIFtBLVpdXG4gICAgY2FzZSAweDAwNDI6Y2FzZSAweDAwNDM6Y2FzZSAweDAwNDQ6Y2FzZSAweDAwNDU6Y2FzZSAweDAwNDY6XG4gICAgY2FzZSAweDAwNDc6Y2FzZSAweDAwNDg6Y2FzZSAweDAwNDk6Y2FzZSAweDAwNEE6Y2FzZSAweDAwNEI6XG4gICAgY2FzZSAweDAwNEM6Y2FzZSAweDAwNEQ6Y2FzZSAweDAwNEU6Y2FzZSAweDAwNEY6Y2FzZSAweDAwNTA6XG4gICAgY2FzZSAweDAwNTE6Y2FzZSAweDAwNTI6Y2FzZSAweDAwNTM6Y2FzZSAweDAwNTQ6Y2FzZSAweDAwNTU6XG4gICAgY2FzZSAweDAwNTY6Y2FzZSAweDAwNTc6Y2FzZSAweDAwNTg6Y2FzZSAweDAwNTk6Y2FzZSAweDAwNUE6XG4gICAgICB0ZW1wYnVmLnB1c2goYyArIDB4MDAyMCk7XG4gICAgICB0ZXh0cnVuLnB1c2goYyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDB4MDA2MTogIC8vIFthLXpdXG4gICAgY2FzZSAweDAwNjI6Y2FzZSAweDAwNjM6Y2FzZSAweDAwNjQ6Y2FzZSAweDAwNjU6Y2FzZSAweDAwNjY6XG4gICAgY2FzZSAweDAwNjc6Y2FzZSAweDAwNjg6Y2FzZSAweDAwNjk6Y2FzZSAweDAwNkE6Y2FzZSAweDAwNkI6XG4gICAgY2FzZSAweDAwNkM6Y2FzZSAweDAwNkQ6Y2FzZSAweDAwNkU6Y2FzZSAweDAwNkY6Y2FzZSAweDAwNzA6XG4gICAgY2FzZSAweDAwNzE6Y2FzZSAweDAwNzI6Y2FzZSAweDAwNzM6Y2FzZSAweDAwNzQ6Y2FzZSAweDAwNzU6XG4gICAgY2FzZSAweDAwNzY6Y2FzZSAweDAwNzc6Y2FzZSAweDAwNzg6Y2FzZSAweDAwNzk6Y2FzZSAweDAwN0E6XG4gICAgICB0ZW1wYnVmLnB1c2goYyk7XG4gICAgICB0ZXh0cnVuLnB1c2goYyk7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgcmVjb25zdW1lKGMsIHNjcmlwdF9kYXRhX2VzY2FwZWRfc3RhdGUpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2NyaXB0X2RhdGFfZG91YmxlX2VzY2FwZWRfc3RhdGUoYykge1xuICAgIHN3aXRjaChjKSB7XG4gICAgY2FzZSAweDAwMkQ6IC8vIEhZUEhFTi1NSU5VU1xuICAgICAgdG9rZW5pemVyID0gc2NyaXB0X2RhdGFfZG91YmxlX2VzY2FwZWRfZGFzaF9zdGF0ZTtcbiAgICAgIHRleHRydW4ucHVzaCgweDAwMkQpOyAvLyBIWVBIRU4tTUlOVVNcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMHgwMDNDOiAvLyBMRVNTLVRIQU4gU0lHTlxuICAgICAgdG9rZW5pemVyID0gc2NyaXB0X2RhdGFfZG91YmxlX2VzY2FwZWRfbGVzc190aGFuX3NpZ25fc3RhdGU7XG4gICAgICB0ZXh0cnVuLnB1c2goMHgwMDNDKTsgLy8gTEVTUy1USEFOIFNJR05cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMHgwMDAwOiAvLyBOVUxMXG4gICAgICB0ZXh0cnVuLnB1c2goMHhGRkZEKTsgLy8gUkVQTEFDRU1FTlQgQ0hBUkFDVEVSXG4gICAgICBicmVhaztcbiAgICBjYXNlIC0xOiAvLyBFT0ZcbiAgICAgIGVtaXRFT0YoKTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0ZXh0cnVuLnB1c2goYyk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzY3JpcHRfZGF0YV9kb3VibGVfZXNjYXBlZF9kYXNoX3N0YXRlKGMpIHtcbiAgICBzd2l0Y2goYykge1xuICAgIGNhc2UgMHgwMDJEOiAvLyBIWVBIRU4tTUlOVVNcbiAgICAgIHRva2VuaXplciA9IHNjcmlwdF9kYXRhX2RvdWJsZV9lc2NhcGVkX2Rhc2hfZGFzaF9zdGF0ZTtcbiAgICAgIHRleHRydW4ucHVzaCgweDAwMkQpOyAvLyBIWVBIRU4tTUlOVVNcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMHgwMDNDOiAvLyBMRVNTLVRIQU4gU0lHTlxuICAgICAgdG9rZW5pemVyID0gc2NyaXB0X2RhdGFfZG91YmxlX2VzY2FwZWRfbGVzc190aGFuX3NpZ25fc3RhdGU7XG4gICAgICB0ZXh0cnVuLnB1c2goMHgwMDNDKTsgLy8gTEVTUy1USEFOIFNJR05cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMHgwMDAwOiAvLyBOVUxMXG4gICAgICB0b2tlbml6ZXIgPSBzY3JpcHRfZGF0YV9kb3VibGVfZXNjYXBlZF9zdGF0ZTtcbiAgICAgIHRleHRydW4ucHVzaCgweEZGRkQpOyAvLyBSRVBMQUNFTUVOVCBDSEFSQUNURVJcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgLTE6IC8vIEVPRlxuICAgICAgZW1pdEVPRigpO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRva2VuaXplciA9IHNjcmlwdF9kYXRhX2RvdWJsZV9lc2NhcGVkX3N0YXRlO1xuICAgICAgdGV4dHJ1bi5wdXNoKGMpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2NyaXB0X2RhdGFfZG91YmxlX2VzY2FwZWRfZGFzaF9kYXNoX3N0YXRlKGMpIHtcbiAgICBzd2l0Y2goYykge1xuICAgIGNhc2UgMHgwMDJEOiAvLyBIWVBIRU4tTUlOVVNcbiAgICAgIHRleHRydW4ucHVzaCgweDAwMkQpOyAvLyBIWVBIRU4tTUlOVVNcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMHgwMDNDOiAvLyBMRVNTLVRIQU4gU0lHTlxuICAgICAgdG9rZW5pemVyID0gc2NyaXB0X2RhdGFfZG91YmxlX2VzY2FwZWRfbGVzc190aGFuX3NpZ25fc3RhdGU7XG4gICAgICB0ZXh0cnVuLnB1c2goMHgwMDNDKTsgLy8gTEVTUy1USEFOIFNJR05cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMHgwMDNFOiAvLyBHUkVBVEVSLVRIQU4gU0lHTlxuICAgICAgdG9rZW5pemVyID0gc2NyaXB0X2RhdGFfc3RhdGU7XG4gICAgICB0ZXh0cnVuLnB1c2goMHgwMDNFKTsgLy8gR1JFQVRFUi1USEFOIFNJR05cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMHgwMDAwOiAvLyBOVUxMXG4gICAgICB0b2tlbml6ZXIgPSBzY3JpcHRfZGF0YV9kb3VibGVfZXNjYXBlZF9zdGF0ZTtcbiAgICAgIHRleHRydW4ucHVzaCgweEZGRkQpOyAvLyBSRVBMQUNFTUVOVCBDSEFSQUNURVJcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgLTE6IC8vIEVPRlxuICAgICAgZW1pdEVPRigpO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRva2VuaXplciA9IHNjcmlwdF9kYXRhX2RvdWJsZV9lc2NhcGVkX3N0YXRlO1xuICAgICAgdGV4dHJ1bi5wdXNoKGMpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2NyaXB0X2RhdGFfZG91YmxlX2VzY2FwZWRfbGVzc190aGFuX3NpZ25fc3RhdGUoYykge1xuICAgIGlmIChjID09PSAweDAwMkYpIHsgLy8gU09MSURVU1xuICAgICAgYmVnaW5UZW1wQnVmKCk7XG4gICAgICB0b2tlbml6ZXIgPSBzY3JpcHRfZGF0YV9kb3VibGVfZXNjYXBlX2VuZF9zdGF0ZTtcbiAgICAgIHRleHRydW4ucHVzaCgweDAwMkYpOyAvLyBTT0xJRFVTXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmVjb25zdW1lKGMsIHNjcmlwdF9kYXRhX2RvdWJsZV9lc2NhcGVkX3N0YXRlKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzY3JpcHRfZGF0YV9kb3VibGVfZXNjYXBlX2VuZF9zdGF0ZShjKSB7XG4gICAgc3dpdGNoKGMpIHtcbiAgICBjYXNlIDB4MDAwOTogLy8gQ0hBUkFDVEVSIFRBQlVMQVRJT04gKHRhYilcbiAgICBjYXNlIDB4MDAwQTogLy8gTElORSBGRUVEIChMRilcbiAgICBjYXNlIDB4MDAwQzogLy8gRk9STSBGRUVEIChGRilcbiAgICBjYXNlIDB4MDAyMDogLy8gU1BBQ0VcbiAgICBjYXNlIDB4MDAyRjogLy8gU09MSURVU1xuICAgIGNhc2UgMHgwMDNFOiAvLyBHUkVBVEVSLVRIQU4gU0lHTlxuICAgICAgaWYgKGJ1ZjJzdHIodGVtcGJ1ZikgPT09IFwic2NyaXB0XCIpIHtcbiAgICAgICAgdG9rZW5pemVyID0gc2NyaXB0X2RhdGFfZXNjYXBlZF9zdGF0ZTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0b2tlbml6ZXIgPSBzY3JpcHRfZGF0YV9kb3VibGVfZXNjYXBlZF9zdGF0ZTtcbiAgICAgIH1cbiAgICAgIHRleHRydW4ucHVzaChjKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMHgwMDQxOiAgLy8gW0EtWl1cbiAgICBjYXNlIDB4MDA0MjpjYXNlIDB4MDA0MzpjYXNlIDB4MDA0NDpjYXNlIDB4MDA0NTpjYXNlIDB4MDA0NjpcbiAgICBjYXNlIDB4MDA0NzpjYXNlIDB4MDA0ODpjYXNlIDB4MDA0OTpjYXNlIDB4MDA0QTpjYXNlIDB4MDA0QjpcbiAgICBjYXNlIDB4MDA0QzpjYXNlIDB4MDA0RDpjYXNlIDB4MDA0RTpjYXNlIDB4MDA0RjpjYXNlIDB4MDA1MDpcbiAgICBjYXNlIDB4MDA1MTpjYXNlIDB4MDA1MjpjYXNlIDB4MDA1MzpjYXNlIDB4MDA1NDpjYXNlIDB4MDA1NTpcbiAgICBjYXNlIDB4MDA1NjpjYXNlIDB4MDA1NzpjYXNlIDB4MDA1ODpjYXNlIDB4MDA1OTpjYXNlIDB4MDA1QTpcbiAgICAgIHRlbXBidWYucHVzaChjICsgMHgwMDIwKTtcbiAgICAgIHRleHRydW4ucHVzaChjKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMHgwMDYxOiAgLy8gW2Etel1cbiAgICBjYXNlIDB4MDA2MjpjYXNlIDB4MDA2MzpjYXNlIDB4MDA2NDpjYXNlIDB4MDA2NTpjYXNlIDB4MDA2NjpcbiAgICBjYXNlIDB4MDA2NzpjYXNlIDB4MDA2ODpjYXNlIDB4MDA2OTpjYXNlIDB4MDA2QTpjYXNlIDB4MDA2QjpcbiAgICBjYXNlIDB4MDA2QzpjYXNlIDB4MDA2RDpjYXNlIDB4MDA2RTpjYXNlIDB4MDA2RjpjYXNlIDB4MDA3MDpcbiAgICBjYXNlIDB4MDA3MTpjYXNlIDB4MDA3MjpjYXNlIDB4MDA3MzpjYXNlIDB4MDA3NDpjYXNlIDB4MDA3NTpcbiAgICBjYXNlIDB4MDA3NjpjYXNlIDB4MDA3NzpjYXNlIDB4MDA3ODpjYXNlIDB4MDA3OTpjYXNlIDB4MDA3QTpcbiAgICAgIHRlbXBidWYucHVzaChjKTtcbiAgICAgIHRleHRydW4ucHVzaChjKTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZWNvbnN1bWUoYywgc2NyaXB0X2RhdGFfZG91YmxlX2VzY2FwZWRfc3RhdGUpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gYmVmb3JlX2F0dHJpYnV0ZV9uYW1lX3N0YXRlKGMpIHtcbiAgICBzd2l0Y2goYykge1xuICAgIGNhc2UgMHgwMDA5OiAvLyBDSEFSQUNURVIgVEFCVUxBVElPTiAodGFiKVxuICAgIGNhc2UgMHgwMDBBOiAvLyBMSU5FIEZFRUQgKExGKVxuICAgIGNhc2UgMHgwMDBDOiAvLyBGT1JNIEZFRUQgKEZGKVxuICAgIGNhc2UgMHgwMDIwOiAvLyBTUEFDRVxuICAgICAgLyogSWdub3JlIHRoZSBjaGFyYWN0ZXIuICovXG4gICAgICBicmVhaztcbiAgICAvLyBGb3IgU09MSURVUywgR1JFQVRFUi1USEFOIFNJR04sIGFuZCBFT0YsIHNwZWMgc2F5cyBcInJlY29uc3VtZSBpblxuICAgIC8vIHRoZSBhZnRlciBhdHRyaWJ1dGUgbmFtZSBzdGF0ZVwiLCBidXQgaW4gb3VyIGltcGxlbWVudGF0aW9uIHRoYXRcbiAgICAvLyBzdGF0ZSBhbHdheXMgaGFzIGFuIGFjdGl2ZSBhdHRyaWJ1dGUgaW4gYXR0cm5hbWVidWYuICBKdXN0IGNsb25lXG4gICAgLy8gdGhlIHJ1bGVzIGhlcmUsIHdpdGhvdXQgdGhlIGFkZEF0dHJpYnV0ZSBidXNpbmVzcy5cbiAgICBjYXNlIDB4MDAyRjogLy8gU09MSURVU1xuICAgICAgdG9rZW5pemVyID0gc2VsZl9jbG9zaW5nX3N0YXJ0X3RhZ19zdGF0ZTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMHgwMDNFOiAvLyBHUkVBVEVSLVRIQU4gU0lHTlxuICAgICAgdG9rZW5pemVyID0gZGF0YV9zdGF0ZTtcbiAgICAgIGVtaXRUYWcoKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgLTE6IC8vIEVPRlxuICAgICAgZW1pdEVPRigpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAweDAwM0Q6IC8vIEVRVUFMUyBTSUdOXG4gICAgICBiZWdpbkF0dHJOYW1lKCk7XG4gICAgICBhdHRybmFtZWJ1ZiArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGMpO1xuICAgICAgdG9rZW5pemVyID0gYXR0cmlidXRlX25hbWVfc3RhdGU7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgaWYgKGhhbmRsZVNpbXBsZUF0dHJpYnV0ZSgpKSBicmVhaztcbiAgICAgIGJlZ2luQXR0ck5hbWUoKTtcbiAgICAgIHJlY29uc3VtZShjLCBhdHRyaWJ1dGVfbmFtZV9zdGF0ZSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICAvLyBiZWdpbkF0dHJOYW1lKCkgbXVzdCBoYXZlIGJlZW4gY2FsbGVkIGJlZm9yZSB0aGlzIHBvaW50XG4gIC8vIFRoZXJlIGlzIGFuIGFjdGl2ZSBhdHRyaWJ1dGUgaW4gYXR0cm5hbWVidWYgKGJ1dCBub3QgYXR0cnZhbHVlYnVmKVxuICBmdW5jdGlvbiBhdHRyaWJ1dGVfbmFtZV9zdGF0ZShjKSB7XG4gICAgc3dpdGNoKGMpIHtcbiAgICBjYXNlIDB4MDAwOTogLy8gQ0hBUkFDVEVSIFRBQlVMQVRJT04gKHRhYilcbiAgICBjYXNlIDB4MDAwQTogLy8gTElORSBGRUVEIChMRilcbiAgICBjYXNlIDB4MDAwQzogLy8gRk9STSBGRUVEIChGRilcbiAgICBjYXNlIDB4MDAyMDogLy8gU1BBQ0VcbiAgICBjYXNlIDB4MDAyRjogLy8gU09MSURVU1xuICAgIGNhc2UgMHgwMDNFOiAvLyBHUkVBVEVSLVRIQU4gU0lHTlxuICAgIGNhc2UgLTE6IC8vIEVPRlxuICAgICAgcmVjb25zdW1lKGMsIGFmdGVyX2F0dHJpYnV0ZV9uYW1lX3N0YXRlKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMHgwMDNEOiAvLyBFUVVBTFMgU0lHTlxuICAgICAgdG9rZW5pemVyID0gYmVmb3JlX2F0dHJpYnV0ZV92YWx1ZV9zdGF0ZTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMHgwMDQxOiAgLy8gW0EtWl1cbiAgICBjYXNlIDB4MDA0MjpjYXNlIDB4MDA0MzpjYXNlIDB4MDA0NDpjYXNlIDB4MDA0NTpjYXNlIDB4MDA0NjpcbiAgICBjYXNlIDB4MDA0NzpjYXNlIDB4MDA0ODpjYXNlIDB4MDA0OTpjYXNlIDB4MDA0QTpjYXNlIDB4MDA0QjpcbiAgICBjYXNlIDB4MDA0QzpjYXNlIDB4MDA0RDpjYXNlIDB4MDA0RTpjYXNlIDB4MDA0RjpjYXNlIDB4MDA1MDpcbiAgICBjYXNlIDB4MDA1MTpjYXNlIDB4MDA1MjpjYXNlIDB4MDA1MzpjYXNlIDB4MDA1NDpjYXNlIDB4MDA1NTpcbiAgICBjYXNlIDB4MDA1NjpjYXNlIDB4MDA1NzpjYXNlIDB4MDA1ODpjYXNlIDB4MDA1OTpjYXNlIDB4MDA1QTpcbiAgICAgIGF0dHJuYW1lYnVmICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYyArIDB4MDAyMCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDB4MDAwMDogLy8gTlVMTFxuICAgICAgYXR0cm5hbWVidWYgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgweEZGRkQgLyogUkVQTEFDRU1FTlQgQ0hBUkFDVEVSICovKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMHgwMDIyOiAvLyBRVU9UQVRJT04gTUFSS1xuICAgIGNhc2UgMHgwMDI3OiAvLyBBUE9TVFJPUEhFXG4gICAgY2FzZSAweDAwM0M6IC8vIExFU1MtVEhBTiBTSUdOXG4gICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgZGVmYXVsdDpcbiAgICAgIGF0dHJuYW1lYnVmICs9IGdldE1hdGNoaW5nQ2hhcnMoQVRUUk5BTUUpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgLy8gVGhlcmUgaXMgYW4gYWN0aXZlIGF0dHJpYnV0ZSBpbiBhdHRybmFtZWJ1ZiwgYnV0IG5vdCB5ZXQgaW4gYXR0cnZhbHVlYnVmLlxuICBmdW5jdGlvbiBhZnRlcl9hdHRyaWJ1dGVfbmFtZV9zdGF0ZShjKSB7XG4gICAgc3dpdGNoKGMpIHtcbiAgICBjYXNlIDB4MDAwOTogLy8gQ0hBUkFDVEVSIFRBQlVMQVRJT04gKHRhYilcbiAgICBjYXNlIDB4MDAwQTogLy8gTElORSBGRUVEIChMRilcbiAgICBjYXNlIDB4MDAwQzogLy8gRk9STSBGRUVEIChGRilcbiAgICBjYXNlIDB4MDAyMDogLy8gU1BBQ0VcbiAgICAgIC8qIElnbm9yZSB0aGUgY2hhcmFjdGVyLiAqL1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAweDAwMkY6IC8vIFNPTElEVVNcbiAgICAgIC8vIEtlZXAgaW4gc3luYyB3aXRoIGJlZm9yZV9hdHRyaWJ1dGVfbmFtZV9zdGF0ZS5cbiAgICAgIGFkZEF0dHJpYnV0ZShhdHRybmFtZWJ1Zik7XG4gICAgICB0b2tlbml6ZXIgPSBzZWxmX2Nsb3Npbmdfc3RhcnRfdGFnX3N0YXRlO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAweDAwM0Q6IC8vIEVRVUFMUyBTSUdOXG4gICAgICB0b2tlbml6ZXIgPSBiZWZvcmVfYXR0cmlidXRlX3ZhbHVlX3N0YXRlO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAweDAwM0U6IC8vIEdSRUFURVItVEhBTiBTSUdOXG4gICAgICAvLyBLZWVwIGluIHN5bmMgd2l0aCBiZWZvcmVfYXR0cmlidXRlX25hbWVfc3RhdGUuXG4gICAgICB0b2tlbml6ZXIgPSBkYXRhX3N0YXRlO1xuICAgICAgYWRkQXR0cmlidXRlKGF0dHJuYW1lYnVmKTtcbiAgICAgIGVtaXRUYWcoKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgLTE6IC8vIEVPRlxuICAgICAgLy8gS2VlcCBpbiBzeW5jIHdpdGggYmVmb3JlX2F0dHJpYnV0ZV9uYW1lX3N0YXRlLlxuICAgICAgYWRkQXR0cmlidXRlKGF0dHJuYW1lYnVmKTtcbiAgICAgIGVtaXRFT0YoKTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBhZGRBdHRyaWJ1dGUoYXR0cm5hbWVidWYpO1xuICAgICAgYmVnaW5BdHRyTmFtZSgpO1xuICAgICAgcmVjb25zdW1lKGMsIGF0dHJpYnV0ZV9uYW1lX3N0YXRlKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGJlZm9yZV9hdHRyaWJ1dGVfdmFsdWVfc3RhdGUoYykge1xuICAgIHN3aXRjaChjKSB7XG4gICAgY2FzZSAweDAwMDk6IC8vIENIQVJBQ1RFUiBUQUJVTEFUSU9OICh0YWIpXG4gICAgY2FzZSAweDAwMEE6IC8vIExJTkUgRkVFRCAoTEYpXG4gICAgY2FzZSAweDAwMEM6IC8vIEZPUk0gRkVFRCAoRkYpXG4gICAgY2FzZSAweDAwMjA6IC8vIFNQQUNFXG4gICAgICAvKiBJZ25vcmUgdGhlIGNoYXJhY3Rlci4gKi9cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMHgwMDIyOiAvLyBRVU9UQVRJT04gTUFSS1xuICAgICAgYmVnaW5BdHRyVmFsdWUoKTtcbiAgICAgIHRva2VuaXplciA9IGF0dHJpYnV0ZV92YWx1ZV9kb3VibGVfcXVvdGVkX3N0YXRlO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAweDAwMjc6IC8vIEFQT1NUUk9QSEVcbiAgICAgIGJlZ2luQXR0clZhbHVlKCk7XG4gICAgICB0b2tlbml6ZXIgPSBhdHRyaWJ1dGVfdmFsdWVfc2luZ2xlX3F1b3RlZF9zdGF0ZTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMHgwMDNFOiAvLyBHUkVBVEVSLVRIQU4gU0lHTlxuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgIGRlZmF1bHQ6XG4gICAgICBiZWdpbkF0dHJWYWx1ZSgpO1xuICAgICAgcmVjb25zdW1lKGMsIGF0dHJpYnV0ZV92YWx1ZV91bnF1b3RlZF9zdGF0ZSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBhdHRyaWJ1dGVfdmFsdWVfZG91YmxlX3F1b3RlZF9zdGF0ZShjKSB7XG4gICAgc3dpdGNoKGMpIHtcbiAgICBjYXNlIDB4MDAyMjogLy8gUVVPVEFUSU9OIE1BUktcbiAgICAgIGFkZEF0dHJpYnV0ZShhdHRybmFtZWJ1ZiwgYXR0cnZhbHVlYnVmKTtcbiAgICAgIHRva2VuaXplciA9IGFmdGVyX2F0dHJpYnV0ZV92YWx1ZV9xdW90ZWRfc3RhdGU7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDB4MDAyNjogLy8gQU1QRVJTQU5EXG4gICAgICByZXR1cm5fc3RhdGUgPSBhdHRyaWJ1dGVfdmFsdWVfZG91YmxlX3F1b3RlZF9zdGF0ZTtcbiAgICAgIHRva2VuaXplciA9IGNoYXJhY3Rlcl9yZWZlcmVuY2Vfc3RhdGU7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDB4MDAwMDogLy8gTlVMTFxuICAgICAgYXR0cnZhbHVlYnVmICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhGRkZEIC8qIFJFUExBQ0VNRU5UIENIQVJBQ1RFUiAqLyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIC0xOiAvLyBFT0ZcbiAgICAgIGVtaXRFT0YoKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMHgwMDBBOiAvLyBMRlxuICAgICAgLy8gdGhpcyBjb3VsZCBiZSBhIGNvbnZlcnRlZCBcXHIsIHNvIGRvbid0IHVzZSBnZXRNYXRjaGluZ0NoYXJzXG4gICAgICBhdHRydmFsdWVidWYgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjKTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBhdHRydmFsdWVidWYgKz0gZ2V0TWF0Y2hpbmdDaGFycyhEQkxRVU9URUFUVFJWQUwpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gYXR0cmlidXRlX3ZhbHVlX3NpbmdsZV9xdW90ZWRfc3RhdGUoYykge1xuICAgIHN3aXRjaChjKSB7XG4gICAgY2FzZSAweDAwMjc6IC8vIEFQT1NUUk9QSEVcbiAgICAgIGFkZEF0dHJpYnV0ZShhdHRybmFtZWJ1ZiwgYXR0cnZhbHVlYnVmKTtcbiAgICAgIHRva2VuaXplciA9IGFmdGVyX2F0dHJpYnV0ZV92YWx1ZV9xdW90ZWRfc3RhdGU7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDB4MDAyNjogLy8gQU1QRVJTQU5EXG4gICAgICByZXR1cm5fc3RhdGUgPSBhdHRyaWJ1dGVfdmFsdWVfc2luZ2xlX3F1b3RlZF9zdGF0ZTtcbiAgICAgIHRva2VuaXplciA9IGNoYXJhY3Rlcl9yZWZlcmVuY2Vfc3RhdGU7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDB4MDAwMDogLy8gTlVMTFxuICAgICAgYXR0cnZhbHVlYnVmICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhGRkZEIC8qIFJFUExBQ0VNRU5UIENIQVJBQ1RFUiAqLyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIC0xOiAvLyBFT0ZcbiAgICAgIGVtaXRFT0YoKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMHgwMDBBOiAvLyBMRlxuICAgICAgLy8gdGhpcyBjb3VsZCBiZSBhIGNvbnZlcnRlZCBcXHIsIHNvIGRvbid0IHVzZSBnZXRNYXRjaGluZ0NoYXJzXG4gICAgICBhdHRydmFsdWVidWYgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjKTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBhdHRydmFsdWVidWYgKz0gZ2V0TWF0Y2hpbmdDaGFycyhTSU5HTEVRVU9URUFUVFJWQUwpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gYXR0cmlidXRlX3ZhbHVlX3VucXVvdGVkX3N0YXRlKGMpIHtcbiAgICBzd2l0Y2goYykge1xuICAgIGNhc2UgMHgwMDA5OiAvLyBDSEFSQUNURVIgVEFCVUxBVElPTiAodGFiKVxuICAgIGNhc2UgMHgwMDBBOiAvLyBMSU5FIEZFRUQgKExGKVxuICAgIGNhc2UgMHgwMDBDOiAvLyBGT1JNIEZFRUQgKEZGKVxuICAgIGNhc2UgMHgwMDIwOiAvLyBTUEFDRVxuICAgICAgYWRkQXR0cmlidXRlKGF0dHJuYW1lYnVmLCBhdHRydmFsdWVidWYpO1xuICAgICAgdG9rZW5pemVyID0gYmVmb3JlX2F0dHJpYnV0ZV9uYW1lX3N0YXRlO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAweDAwMjY6IC8vIEFNUEVSU0FORFxuICAgICAgcmV0dXJuX3N0YXRlID0gYXR0cmlidXRlX3ZhbHVlX3VucXVvdGVkX3N0YXRlO1xuICAgICAgdG9rZW5pemVyID0gY2hhcmFjdGVyX3JlZmVyZW5jZV9zdGF0ZTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMHgwMDNFOiAvLyBHUkVBVEVSLVRIQU4gU0lHTlxuICAgICAgYWRkQXR0cmlidXRlKGF0dHJuYW1lYnVmLCBhdHRydmFsdWVidWYpO1xuICAgICAgdG9rZW5pemVyID0gZGF0YV9zdGF0ZTtcbiAgICAgIGVtaXRUYWcoKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMHgwMDAwOiAvLyBOVUxMXG4gICAgICBhdHRydmFsdWVidWYgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgweEZGRkQgLyogUkVQTEFDRU1FTlQgQ0hBUkFDVEVSICovKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgLTE6IC8vIEVPRlxuICAgICAgbmV4dGNoYXItLTsgLy8gcHVzaGJhY2tcbiAgICAgIHRva2VuaXplciA9IGRhdGFfc3RhdGU7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDB4MDAyMjogLy8gUVVPVEFUSU9OIE1BUktcbiAgICBjYXNlIDB4MDAyNzogLy8gQVBPU1RST1BIRVxuICAgIGNhc2UgMHgwMDNDOiAvLyBMRVNTLVRIQU4gU0lHTlxuICAgIGNhc2UgMHgwMDNEOiAvLyBFUVVBTFMgU0lHTlxuICAgIGNhc2UgMHgwMDYwOiAvLyBHUkFWRSBBQ0NFTlRcbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICBkZWZhdWx0OlxuICAgICAgYXR0cnZhbHVlYnVmICs9IGdldE1hdGNoaW5nQ2hhcnMoVU5RVU9URURBVFRSVkFMKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGFmdGVyX2F0dHJpYnV0ZV92YWx1ZV9xdW90ZWRfc3RhdGUoYykge1xuICAgIHN3aXRjaChjKSB7XG4gICAgY2FzZSAweDAwMDk6IC8vIENIQVJBQ1RFUiBUQUJVTEFUSU9OICh0YWIpXG4gICAgY2FzZSAweDAwMEE6IC8vIExJTkUgRkVFRCAoTEYpXG4gICAgY2FzZSAweDAwMEM6IC8vIEZPUk0gRkVFRCAoRkYpXG4gICAgY2FzZSAweDAwMjA6IC8vIFNQQUNFXG4gICAgICB0b2tlbml6ZXIgPSBiZWZvcmVfYXR0cmlidXRlX25hbWVfc3RhdGU7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDB4MDAyRjogLy8gU09MSURVU1xuICAgICAgdG9rZW5pemVyID0gc2VsZl9jbG9zaW5nX3N0YXJ0X3RhZ19zdGF0ZTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMHgwMDNFOiAvLyBHUkVBVEVSLVRIQU4gU0lHTlxuICAgICAgdG9rZW5pemVyID0gZGF0YV9zdGF0ZTtcbiAgICAgIGVtaXRUYWcoKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgLTE6IC8vIEVPRlxuICAgICAgZW1pdEVPRigpO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJlY29uc3VtZShjLCBiZWZvcmVfYXR0cmlidXRlX25hbWVfc3RhdGUpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2VsZl9jbG9zaW5nX3N0YXJ0X3RhZ19zdGF0ZShjKSB7XG4gICAgc3dpdGNoKGMpIHtcbiAgICBjYXNlIDB4MDAzRTogLy8gR1JFQVRFUi1USEFOIFNJR05cbiAgICAgIC8vIFNldCB0aGUgPGk+c2VsZi1jbG9zaW5nIGZsYWc8L2k+IG9mIHRoZSBjdXJyZW50IHRhZyB0b2tlbi5cbiAgICAgIHRva2VuaXplciA9IGRhdGFfc3RhdGU7XG4gICAgICBlbWl0U2VsZkNsb3NpbmdUYWcodHJ1ZSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIC0xOiAvLyBFT0ZcbiAgICAgIGVtaXRFT0YoKTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZWNvbnN1bWUoYywgYmVmb3JlX2F0dHJpYnV0ZV9uYW1lX3N0YXRlKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGJvZ3VzX2NvbW1lbnRfc3RhdGUoYywgbG9va2FoZWFkLCBlb2YpIHtcbiAgICB2YXIgbGVuID0gbG9va2FoZWFkLmxlbmd0aDtcblxuICAgIGlmIChlb2YpIHtcbiAgICAgIG5leHRjaGFyICs9IGxlbi0xOyAvLyBkb24ndCBjb25zdW1lIHRoZSBlb2ZcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBuZXh0Y2hhciArPSBsZW47XG4gICAgfVxuXG4gICAgdmFyIGNvbW1lbnQgPSBsb29rYWhlYWQuc3Vic3RyaW5nKDAsIGxlbi0xKTtcblxuICAgIGNvbW1lbnQgPSBjb21tZW50LnJlcGxhY2UoL1xcdTAwMDAvZyxcIlxcdUZGRkRcIik7XG4gICAgY29tbWVudCA9IGNvbW1lbnQucmVwbGFjZSgvXFx1MDAwRFxcdTAwMEEvZyxcIlxcdTAwMEFcIik7XG4gICAgY29tbWVudCA9IGNvbW1lbnQucmVwbGFjZSgvXFx1MDAwRC9nLFwiXFx1MDAwQVwiKTtcblxuICAgIGluc2VydFRva2VuKENPTU1FTlQsIGNvbW1lbnQpO1xuICAgIHRva2VuaXplciA9IGRhdGFfc3RhdGU7XG4gIH1cbiAgYm9ndXNfY29tbWVudF9zdGF0ZS5sb29rYWhlYWQgPSBcIj5cIjtcblxuICBmdW5jdGlvbiBtYXJrdXBfZGVjbGFyYXRpb25fb3Blbl9zdGF0ZShjLCBsb29rYWhlYWQsIGVvZikge1xuICAgIGlmIChsb29rYWhlYWRbMF0gPT09IFwiLVwiICYmIGxvb2thaGVhZFsxXSA9PT0gXCItXCIpIHtcbiAgICAgIG5leHRjaGFyICs9IDI7XG4gICAgICBiZWdpbkNvbW1lbnQoKTtcbiAgICAgIHRva2VuaXplciA9IGNvbW1lbnRfc3RhcnRfc3RhdGU7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGxvb2thaGVhZC50b1VwcGVyQ2FzZSgpID09PSBcIkRPQ1RZUEVcIikge1xuICAgICAgbmV4dGNoYXIgKz0gNztcbiAgICAgIHRva2VuaXplciA9IGRvY3R5cGVfc3RhdGU7XG4gICAgfVxuICAgIGVsc2UgaWYgKGxvb2thaGVhZCA9PT0gXCJbQ0RBVEFbXCIgJiYgY2RhdGFBbGxvd2VkKCkpIHtcbiAgICAgIG5leHRjaGFyICs9IDc7XG4gICAgICB0b2tlbml6ZXIgPSBjZGF0YV9zZWN0aW9uX3N0YXRlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRva2VuaXplciA9IGJvZ3VzX2NvbW1lbnRfc3RhdGU7XG4gICAgfVxuICB9XG4gIG1hcmt1cF9kZWNsYXJhdGlvbl9vcGVuX3N0YXRlLmxvb2thaGVhZCA9IDc7XG5cbiAgZnVuY3Rpb24gY29tbWVudF9zdGFydF9zdGF0ZShjKSB7XG4gICAgYmVnaW5Db21tZW50KCk7XG4gICAgc3dpdGNoKGMpIHtcbiAgICBjYXNlIDB4MDAyRDogLy8gSFlQSEVOLU1JTlVTXG4gICAgICB0b2tlbml6ZXIgPSBjb21tZW50X3N0YXJ0X2Rhc2hfc3RhdGU7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDB4MDAzRTogLy8gR1JFQVRFUi1USEFOIFNJR05cbiAgICAgIHRva2VuaXplciA9IGRhdGFfc3RhdGU7XG4gICAgICBpbnNlcnRUb2tlbihDT01NRU5ULCBidWYyc3RyKGNvbW1lbnRidWYpKTtcbiAgICAgIGJyZWFrOyAvKiBzZWUgY29tbWVudCBpbiBjb21tZW50IGVuZCBzdGF0ZSAqL1xuICAgIGRlZmF1bHQ6XG4gICAgICByZWNvbnN1bWUoYywgY29tbWVudF9zdGF0ZSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjb21tZW50X3N0YXJ0X2Rhc2hfc3RhdGUoYykge1xuICAgIHN3aXRjaChjKSB7XG4gICAgY2FzZSAweDAwMkQ6IC8vIEhZUEhFTi1NSU5VU1xuICAgICAgdG9rZW5pemVyID0gY29tbWVudF9lbmRfc3RhdGU7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDB4MDAzRTogLy8gR1JFQVRFUi1USEFOIFNJR05cbiAgICAgIHRva2VuaXplciA9IGRhdGFfc3RhdGU7XG4gICAgICBpbnNlcnRUb2tlbihDT01NRU5ULCBidWYyc3RyKGNvbW1lbnRidWYpKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgLTE6IC8vIEVPRlxuICAgICAgaW5zZXJ0VG9rZW4oQ09NTUVOVCwgYnVmMnN0cihjb21tZW50YnVmKSk7XG4gICAgICBlbWl0RU9GKCk7XG4gICAgICBicmVhazsgLyogc2VlIGNvbW1lbnQgaW4gY29tbWVudCBlbmQgc3RhdGUgKi9cbiAgICBkZWZhdWx0OlxuICAgICAgY29tbWVudGJ1Zi5wdXNoKDB4MDAyRCAvKiBIWVBIRU4tTUlOVVMgKi8pO1xuICAgICAgcmVjb25zdW1lKGMsIGNvbW1lbnRfc3RhdGUpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY29tbWVudF9zdGF0ZShjKSB7XG4gICAgc3dpdGNoKGMpIHtcbiAgICBjYXNlIDB4MDAzQzogLy8gTEVTUy1USEFOIFNJR05cbiAgICAgIGNvbW1lbnRidWYucHVzaChjKTtcbiAgICAgIHRva2VuaXplciA9IGNvbW1lbnRfbGVzc190aGFuX3NpZ25fc3RhdGU7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDB4MDAyRDogLy8gSFlQSEVOLU1JTlVTXG4gICAgICB0b2tlbml6ZXIgPSBjb21tZW50X2VuZF9kYXNoX3N0YXRlO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAweDAwMDA6IC8vIE5VTExcbiAgICAgIGNvbW1lbnRidWYucHVzaCgweEZGRkQgLyogUkVQTEFDRU1FTlQgQ0hBUkFDVEVSICovKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgLTE6IC8vIEVPRlxuICAgICAgaW5zZXJ0VG9rZW4oQ09NTUVOVCwgYnVmMnN0cihjb21tZW50YnVmKSk7XG4gICAgICBlbWl0RU9GKCk7XG4gICAgICBicmVhazsgLyogc2VlIGNvbW1lbnQgaW4gY29tbWVudCBlbmQgc3RhdGUgKi9cbiAgICBkZWZhdWx0OlxuICAgICAgY29tbWVudGJ1Zi5wdXNoKGMpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY29tbWVudF9sZXNzX3RoYW5fc2lnbl9zdGF0ZShjKSB7XG4gICAgc3dpdGNoKGMpIHtcbiAgICBjYXNlIDB4MDAyMTogLy8gRVhDTEFNQVRJT04gTUFSS1xuICAgICAgY29tbWVudGJ1Zi5wdXNoKGMpO1xuICAgICAgdG9rZW5pemVyID0gY29tbWVudF9sZXNzX3RoYW5fc2lnbl9iYW5nX3N0YXRlO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAweDAwM0M6IC8vIExFU1MtVEhBTiBTSUdOXG4gICAgICBjb21tZW50YnVmLnB1c2goYyk7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgcmVjb25zdW1lKGMsIGNvbW1lbnRfc3RhdGUpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY29tbWVudF9sZXNzX3RoYW5fc2lnbl9iYW5nX3N0YXRlKGMpIHtcbiAgICBzd2l0Y2goYykge1xuICAgIGNhc2UgMHgwMDJEOiAvLyBIWVBIRU4tTUlOVVNcbiAgICAgIHRva2VuaXplciA9IGNvbW1lbnRfbGVzc190aGFuX3NpZ25fYmFuZ19kYXNoX3N0YXRlO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJlY29uc3VtZShjLCBjb21tZW50X3N0YXRlKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbW1lbnRfbGVzc190aGFuX3NpZ25fYmFuZ19kYXNoX3N0YXRlKGMpIHtcbiAgICBzd2l0Y2goYykge1xuICAgIGNhc2UgMHgwMDJEOiAvLyBIWVBIRU4tTUlOVVNcbiAgICAgIHRva2VuaXplciA9IGNvbW1lbnRfbGVzc190aGFuX3NpZ25fYmFuZ19kYXNoX2Rhc2hfc3RhdGU7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgcmVjb25zdW1lKGMsIGNvbW1lbnRfZW5kX2Rhc2hfc3RhdGUpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY29tbWVudF9sZXNzX3RoYW5fc2lnbl9iYW5nX2Rhc2hfZGFzaF9zdGF0ZShjKSB7XG4gICAgc3dpdGNoKGMpIHtcbiAgICBjYXNlIDB4MDAzRTogLy8gR1JFQVRFUi1USEFOIFNJR05cbiAgICBjYXNlIC0xOiAvLyBFT0ZcbiAgICAgIHJlY29uc3VtZShjLCBjb21tZW50X2VuZF9zdGF0ZSk7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgLy8gcGFyc2UgZXJyb3JcbiAgICAgIHJlY29uc3VtZShjLCBjb21tZW50X2VuZF9zdGF0ZSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjb21tZW50X2VuZF9kYXNoX3N0YXRlKGMpIHtcbiAgICBzd2l0Y2goYykge1xuICAgIGNhc2UgMHgwMDJEOiAvLyBIWVBIRU4tTUlOVVNcbiAgICAgIHRva2VuaXplciA9IGNvbW1lbnRfZW5kX3N0YXRlO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAtMTogLy8gRU9GXG4gICAgICBpbnNlcnRUb2tlbihDT01NRU5ULCBidWYyc3RyKGNvbW1lbnRidWYpKTtcbiAgICAgIGVtaXRFT0YoKTtcbiAgICAgIGJyZWFrOyAvKiBzZWUgY29tbWVudCBpbiBjb21tZW50IGVuZCBzdGF0ZSAqL1xuICAgIGRlZmF1bHQ6XG4gICAgICBjb21tZW50YnVmLnB1c2goMHgwMDJEIC8qIEhZUEhFTi1NSU5VUyAqLyk7XG4gICAgICByZWNvbnN1bWUoYywgY29tbWVudF9zdGF0ZSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjb21tZW50X2VuZF9zdGF0ZShjKSB7XG4gICAgc3dpdGNoKGMpIHtcbiAgICBjYXNlIDB4MDAzRTogLy8gR1JFQVRFUi1USEFOIFNJR05cbiAgICAgIHRva2VuaXplciA9IGRhdGFfc3RhdGU7XG4gICAgICBpbnNlcnRUb2tlbihDT01NRU5ULCBidWYyc3RyKGNvbW1lbnRidWYpKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMHgwMDIxOiAvLyBFWENMQU1BVElPTiBNQVJLXG4gICAgICB0b2tlbml6ZXIgPSBjb21tZW50X2VuZF9iYW5nX3N0YXRlO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAweDAwMkQ6IC8vIEhZUEhFTi1NSU5VU1xuICAgICAgY29tbWVudGJ1Zi5wdXNoKDB4MDAyRCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIC0xOiAvLyBFT0ZcbiAgICAgIGluc2VydFRva2VuKENPTU1FTlQsIGJ1ZjJzdHIoY29tbWVudGJ1ZikpO1xuICAgICAgZW1pdEVPRigpO1xuICAgICAgYnJlYWs7IC8qIEZvciBzZWN1cml0eSByZWFzb25zOiBvdGhlcndpc2UsIGhvc3RpbGUgdXNlciBjb3VsZCBwdXQgYSBzY3JpcHQgaW4gYSBjb21tZW50IGUuZy4gaW4gYSBibG9nIGNvbW1lbnQgYW5kIHRoZW4gRE9TIHRoZSBzZXJ2ZXIgc28gdGhhdCB0aGUgZW5kIHRhZyBpc24ndCByZWFkLCBhbmQgdGhlbiB0aGUgY29tbWVudGVkIHNjcmlwdCB0YWcgd291bGQgYmUgdHJlYXRlZCBhcyBsaXZlIGNvZGUgKi9cbiAgICBkZWZhdWx0OlxuICAgICAgY29tbWVudGJ1Zi5wdXNoKDB4MDAyRCk7XG4gICAgICBjb21tZW50YnVmLnB1c2goMHgwMDJEKTtcbiAgICAgIHJlY29uc3VtZShjLCBjb21tZW50X3N0YXRlKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbW1lbnRfZW5kX2Jhbmdfc3RhdGUoYykge1xuICAgIHN3aXRjaChjKSB7XG4gICAgY2FzZSAweDAwMkQ6IC8vIEhZUEhFTi1NSU5VU1xuICAgICAgY29tbWVudGJ1Zi5wdXNoKDB4MDAyRCk7XG4gICAgICBjb21tZW50YnVmLnB1c2goMHgwMDJEKTtcbiAgICAgIGNvbW1lbnRidWYucHVzaCgweDAwMjEpO1xuICAgICAgdG9rZW5pemVyID0gY29tbWVudF9lbmRfZGFzaF9zdGF0ZTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMHgwMDNFOiAvLyBHUkVBVEVSLVRIQU4gU0lHTlxuICAgICAgdG9rZW5pemVyID0gZGF0YV9zdGF0ZTtcbiAgICAgIGluc2VydFRva2VuKENPTU1FTlQsIGJ1ZjJzdHIoY29tbWVudGJ1ZikpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAtMTogLy8gRU9GXG4gICAgICBpbnNlcnRUb2tlbihDT01NRU5ULCBidWYyc3RyKGNvbW1lbnRidWYpKTtcbiAgICAgIGVtaXRFT0YoKTtcbiAgICAgIGJyZWFrOyAvKiBzZWUgY29tbWVudCBpbiBjb21tZW50IGVuZCBzdGF0ZSAqL1xuICAgIGRlZmF1bHQ6XG4gICAgICBjb21tZW50YnVmLnB1c2goMHgwMDJEKTtcbiAgICAgIGNvbW1lbnRidWYucHVzaCgweDAwMkQpO1xuICAgICAgY29tbWVudGJ1Zi5wdXNoKDB4MDAyMSk7XG4gICAgICByZWNvbnN1bWUoYywgY29tbWVudF9zdGF0ZSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBkb2N0eXBlX3N0YXRlKGMpIHtcbiAgICBzd2l0Y2goYykge1xuICAgIGNhc2UgMHgwMDA5OiAvLyBDSEFSQUNURVIgVEFCVUxBVElPTiAodGFiKVxuICAgIGNhc2UgMHgwMDBBOiAvLyBMSU5FIEZFRUQgKExGKVxuICAgIGNhc2UgMHgwMDBDOiAvLyBGT1JNIEZFRUQgKEZGKVxuICAgIGNhc2UgMHgwMDIwOiAvLyBTUEFDRVxuICAgICAgdG9rZW5pemVyID0gYmVmb3JlX2RvY3R5cGVfbmFtZV9zdGF0ZTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgLTE6IC8vIEVPRlxuICAgICAgYmVnaW5Eb2N0eXBlKCk7XG4gICAgICBmb3JjZXF1aXJrcygpO1xuICAgICAgZW1pdERvY3R5cGUoKTtcbiAgICAgIGVtaXRFT0YoKTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZWNvbnN1bWUoYywgYmVmb3JlX2RvY3R5cGVfbmFtZV9zdGF0ZSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBiZWZvcmVfZG9jdHlwZV9uYW1lX3N0YXRlKGMpIHtcbiAgICBzd2l0Y2goYykge1xuICAgIGNhc2UgMHgwMDA5OiAvLyBDSEFSQUNURVIgVEFCVUxBVElPTiAodGFiKVxuICAgIGNhc2UgMHgwMDBBOiAvLyBMSU5FIEZFRUQgKExGKVxuICAgIGNhc2UgMHgwMDBDOiAvLyBGT1JNIEZFRUQgKEZGKVxuICAgIGNhc2UgMHgwMDIwOiAvLyBTUEFDRVxuICAgICAgLyogSWdub3JlIHRoZSBjaGFyYWN0ZXIuICovXG4gICAgICBicmVhaztcbiAgICBjYXNlIDB4MDA0MTogIC8vIFtBLVpdXG4gICAgY2FzZSAweDAwNDI6Y2FzZSAweDAwNDM6Y2FzZSAweDAwNDQ6Y2FzZSAweDAwNDU6Y2FzZSAweDAwNDY6XG4gICAgY2FzZSAweDAwNDc6Y2FzZSAweDAwNDg6Y2FzZSAweDAwNDk6Y2FzZSAweDAwNEE6Y2FzZSAweDAwNEI6XG4gICAgY2FzZSAweDAwNEM6Y2FzZSAweDAwNEQ6Y2FzZSAweDAwNEU6Y2FzZSAweDAwNEY6Y2FzZSAweDAwNTA6XG4gICAgY2FzZSAweDAwNTE6Y2FzZSAweDAwNTI6Y2FzZSAweDAwNTM6Y2FzZSAweDAwNTQ6Y2FzZSAweDAwNTU6XG4gICAgY2FzZSAweDAwNTY6Y2FzZSAweDAwNTc6Y2FzZSAweDAwNTg6Y2FzZSAweDAwNTk6Y2FzZSAweDAwNUE6XG4gICAgICBiZWdpbkRvY3R5cGUoKTtcbiAgICAgIGRvY3R5cGVuYW1lYnVmLnB1c2goYyArIDB4MDAyMCk7XG4gICAgICB0b2tlbml6ZXIgPSBkb2N0eXBlX25hbWVfc3RhdGU7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDB4MDAwMDogLy8gTlVMTFxuICAgICAgYmVnaW5Eb2N0eXBlKCk7XG4gICAgICBkb2N0eXBlbmFtZWJ1Zi5wdXNoKDB4RkZGRCk7XG4gICAgICB0b2tlbml6ZXIgPSBkb2N0eXBlX25hbWVfc3RhdGU7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDB4MDAzRTogLy8gR1JFQVRFUi1USEFOIFNJR05cbiAgICAgIGJlZ2luRG9jdHlwZSgpO1xuICAgICAgZm9yY2VxdWlya3MoKTtcbiAgICAgIHRva2VuaXplciA9IGRhdGFfc3RhdGU7XG4gICAgICBlbWl0RG9jdHlwZSgpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAtMTogLy8gRU9GXG4gICAgICBiZWdpbkRvY3R5cGUoKTtcbiAgICAgIGZvcmNlcXVpcmtzKCk7XG4gICAgICBlbWl0RG9jdHlwZSgpO1xuICAgICAgZW1pdEVPRigpO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIGJlZ2luRG9jdHlwZSgpO1xuICAgICAgZG9jdHlwZW5hbWVidWYucHVzaChjKTtcbiAgICAgIHRva2VuaXplciA9IGRvY3R5cGVfbmFtZV9zdGF0ZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGRvY3R5cGVfbmFtZV9zdGF0ZShjKSB7XG4gICAgc3dpdGNoKGMpIHtcbiAgICBjYXNlIDB4MDAwOTogLy8gQ0hBUkFDVEVSIFRBQlVMQVRJT04gKHRhYilcbiAgICBjYXNlIDB4MDAwQTogLy8gTElORSBGRUVEIChMRilcbiAgICBjYXNlIDB4MDAwQzogLy8gRk9STSBGRUVEIChGRilcbiAgICBjYXNlIDB4MDAyMDogLy8gU1BBQ0VcbiAgICAgIHRva2VuaXplciA9IGFmdGVyX2RvY3R5cGVfbmFtZV9zdGF0ZTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMHgwMDNFOiAvLyBHUkVBVEVSLVRIQU4gU0lHTlxuICAgICAgdG9rZW5pemVyID0gZGF0YV9zdGF0ZTtcbiAgICAgIGVtaXREb2N0eXBlKCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDB4MDA0MTogIC8vIFtBLVpdXG4gICAgY2FzZSAweDAwNDI6Y2FzZSAweDAwNDM6Y2FzZSAweDAwNDQ6Y2FzZSAweDAwNDU6Y2FzZSAweDAwNDY6XG4gICAgY2FzZSAweDAwNDc6Y2FzZSAweDAwNDg6Y2FzZSAweDAwNDk6Y2FzZSAweDAwNEE6Y2FzZSAweDAwNEI6XG4gICAgY2FzZSAweDAwNEM6Y2FzZSAweDAwNEQ6Y2FzZSAweDAwNEU6Y2FzZSAweDAwNEY6Y2FzZSAweDAwNTA6XG4gICAgY2FzZSAweDAwNTE6Y2FzZSAweDAwNTI6Y2FzZSAweDAwNTM6Y2FzZSAweDAwNTQ6Y2FzZSAweDAwNTU6XG4gICAgY2FzZSAweDAwNTY6Y2FzZSAweDAwNTc6Y2FzZSAweDAwNTg6Y2FzZSAweDAwNTk6Y2FzZSAweDAwNUE6XG4gICAgICBkb2N0eXBlbmFtZWJ1Zi5wdXNoKGMgKyAweDAwMjApO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAweDAwMDA6IC8vIE5VTExcbiAgICAgIGRvY3R5cGVuYW1lYnVmLnB1c2goMHhGRkZEIC8qIFJFUExBQ0VNRU5UIENIQVJBQ1RFUiAqLyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIC0xOiAvLyBFT0ZcbiAgICAgIGZvcmNlcXVpcmtzKCk7XG4gICAgICBlbWl0RG9jdHlwZSgpO1xuICAgICAgZW1pdEVPRigpO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIGRvY3R5cGVuYW1lYnVmLnB1c2goYyk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBhZnRlcl9kb2N0eXBlX25hbWVfc3RhdGUoYywgbG9va2FoZWFkLCBlb2YpIHtcbiAgICBzd2l0Y2goYykge1xuICAgIGNhc2UgMHgwMDA5OiAvLyBDSEFSQUNURVIgVEFCVUxBVElPTiAodGFiKVxuICAgIGNhc2UgMHgwMDBBOiAvLyBMSU5FIEZFRUQgKExGKVxuICAgIGNhc2UgMHgwMDBDOiAvLyBGT1JNIEZFRUQgKEZGKVxuICAgIGNhc2UgMHgwMDIwOiAvLyBTUEFDRVxuICAgICAgLyogSWdub3JlIHRoZSBjaGFyYWN0ZXIuICovXG4gICAgICBuZXh0Y2hhciArPSAxO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAweDAwM0U6IC8vIEdSRUFURVItVEhBTiBTSUdOXG4gICAgICB0b2tlbml6ZXIgPSBkYXRhX3N0YXRlO1xuICAgICAgbmV4dGNoYXIgKz0gMTtcbiAgICAgIGVtaXREb2N0eXBlKCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIC0xOiAvLyBFT0ZcbiAgICAgIGZvcmNlcXVpcmtzKCk7XG4gICAgICBlbWl0RG9jdHlwZSgpO1xuICAgICAgZW1pdEVPRigpO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIGxvb2thaGVhZCA9IGxvb2thaGVhZC50b1VwcGVyQ2FzZSgpO1xuICAgICAgaWYgKGxvb2thaGVhZCA9PT0gXCJQVUJMSUNcIikge1xuICAgICAgICBuZXh0Y2hhciArPSA2O1xuICAgICAgICB0b2tlbml6ZXIgPSBhZnRlcl9kb2N0eXBlX3B1YmxpY19rZXl3b3JkX3N0YXRlO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAobG9va2FoZWFkID09PSBcIlNZU1RFTVwiKSB7XG4gICAgICAgIG5leHRjaGFyICs9IDY7XG4gICAgICAgIHRva2VuaXplciA9IGFmdGVyX2RvY3R5cGVfc3lzdGVtX2tleXdvcmRfc3RhdGU7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgZm9yY2VxdWlya3MoKTtcbiAgICAgICAgdG9rZW5pemVyID0gYm9ndXNfZG9jdHlwZV9zdGF0ZTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBhZnRlcl9kb2N0eXBlX25hbWVfc3RhdGUubG9va2FoZWFkID0gNjtcblxuICBmdW5jdGlvbiBhZnRlcl9kb2N0eXBlX3B1YmxpY19rZXl3b3JkX3N0YXRlKGMpIHtcbiAgICBzd2l0Y2goYykge1xuICAgIGNhc2UgMHgwMDA5OiAvLyBDSEFSQUNURVIgVEFCVUxBVElPTiAodGFiKVxuICAgIGNhc2UgMHgwMDBBOiAvLyBMSU5FIEZFRUQgKExGKVxuICAgIGNhc2UgMHgwMDBDOiAvLyBGT1JNIEZFRUQgKEZGKVxuICAgIGNhc2UgMHgwMDIwOiAvLyBTUEFDRVxuICAgICAgdG9rZW5pemVyID0gYmVmb3JlX2RvY3R5cGVfcHVibGljX2lkZW50aWZpZXJfc3RhdGU7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDB4MDAyMjogLy8gUVVPVEFUSU9OIE1BUktcbiAgICAgIGJlZ2luRG9jdHlwZVB1YmxpY0lkKCk7XG4gICAgICB0b2tlbml6ZXIgPSBkb2N0eXBlX3B1YmxpY19pZGVudGlmaWVyX2RvdWJsZV9xdW90ZWRfc3RhdGU7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDB4MDAyNzogLy8gQVBPU1RST1BIRVxuICAgICAgYmVnaW5Eb2N0eXBlUHVibGljSWQoKTtcbiAgICAgIHRva2VuaXplciA9IGRvY3R5cGVfcHVibGljX2lkZW50aWZpZXJfc2luZ2xlX3F1b3RlZF9zdGF0ZTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMHgwMDNFOiAvLyBHUkVBVEVSLVRIQU4gU0lHTlxuICAgICAgZm9yY2VxdWlya3MoKTtcbiAgICAgIHRva2VuaXplciA9IGRhdGFfc3RhdGU7XG4gICAgICBlbWl0RG9jdHlwZSgpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAtMTogLy8gRU9GXG4gICAgICBmb3JjZXF1aXJrcygpO1xuICAgICAgZW1pdERvY3R5cGUoKTtcbiAgICAgIGVtaXRFT0YoKTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBmb3JjZXF1aXJrcygpO1xuICAgICAgdG9rZW5pemVyID0gYm9ndXNfZG9jdHlwZV9zdGF0ZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGJlZm9yZV9kb2N0eXBlX3B1YmxpY19pZGVudGlmaWVyX3N0YXRlKGMpIHtcbiAgICBzd2l0Y2goYykge1xuICAgIGNhc2UgMHgwMDA5OiAvLyBDSEFSQUNURVIgVEFCVUxBVElPTiAodGFiKVxuICAgIGNhc2UgMHgwMDBBOiAvLyBMSU5FIEZFRUQgKExGKVxuICAgIGNhc2UgMHgwMDBDOiAvLyBGT1JNIEZFRUQgKEZGKVxuICAgIGNhc2UgMHgwMDIwOiAvLyBTUEFDRVxuICAgICAgLyogSWdub3JlIHRoZSBjaGFyYWN0ZXIuICovXG4gICAgICBicmVhaztcbiAgICBjYXNlIDB4MDAyMjogLy8gUVVPVEFUSU9OIE1BUktcbiAgICAgIGJlZ2luRG9jdHlwZVB1YmxpY0lkKCk7XG4gICAgICB0b2tlbml6ZXIgPSBkb2N0eXBlX3B1YmxpY19pZGVudGlmaWVyX2RvdWJsZV9xdW90ZWRfc3RhdGU7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDB4MDAyNzogLy8gQVBPU1RST1BIRVxuICAgICAgYmVnaW5Eb2N0eXBlUHVibGljSWQoKTtcbiAgICAgIHRva2VuaXplciA9IGRvY3R5cGVfcHVibGljX2lkZW50aWZpZXJfc2luZ2xlX3F1b3RlZF9zdGF0ZTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMHgwMDNFOiAvLyBHUkVBVEVSLVRIQU4gU0lHTlxuICAgICAgZm9yY2VxdWlya3MoKTtcbiAgICAgIHRva2VuaXplciA9IGRhdGFfc3RhdGU7XG4gICAgICBlbWl0RG9jdHlwZSgpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAtMTogLy8gRU9GXG4gICAgICBmb3JjZXF1aXJrcygpO1xuICAgICAgZW1pdERvY3R5cGUoKTtcbiAgICAgIGVtaXRFT0YoKTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBmb3JjZXF1aXJrcygpO1xuICAgICAgdG9rZW5pemVyID0gYm9ndXNfZG9jdHlwZV9zdGF0ZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGRvY3R5cGVfcHVibGljX2lkZW50aWZpZXJfZG91YmxlX3F1b3RlZF9zdGF0ZShjKSB7XG4gICAgc3dpdGNoKGMpIHtcbiAgICBjYXNlIDB4MDAyMjogLy8gUVVPVEFUSU9OIE1BUktcbiAgICAgIHRva2VuaXplciA9IGFmdGVyX2RvY3R5cGVfcHVibGljX2lkZW50aWZpZXJfc3RhdGU7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDB4MDAwMDogLy8gTlVMTFxuICAgICAgZG9jdHlwZXB1YmxpY2J1Zi5wdXNoKDB4RkZGRCAvKiBSRVBMQUNFTUVOVCBDSEFSQUNURVIgKi8pO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAweDAwM0U6IC8vIEdSRUFURVItVEhBTiBTSUdOXG4gICAgICBmb3JjZXF1aXJrcygpO1xuICAgICAgdG9rZW5pemVyID0gZGF0YV9zdGF0ZTtcbiAgICAgIGVtaXREb2N0eXBlKCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIC0xOiAvLyBFT0ZcbiAgICAgIGZvcmNlcXVpcmtzKCk7XG4gICAgICBlbWl0RG9jdHlwZSgpO1xuICAgICAgZW1pdEVPRigpO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIGRvY3R5cGVwdWJsaWNidWYucHVzaChjKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGRvY3R5cGVfcHVibGljX2lkZW50aWZpZXJfc2luZ2xlX3F1b3RlZF9zdGF0ZShjKSB7XG4gICAgc3dpdGNoKGMpIHtcbiAgICBjYXNlIDB4MDAyNzogLy8gQVBPU1RST1BIRVxuICAgICAgdG9rZW5pemVyID0gYWZ0ZXJfZG9jdHlwZV9wdWJsaWNfaWRlbnRpZmllcl9zdGF0ZTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMHgwMDAwOiAvLyBOVUxMXG4gICAgICBkb2N0eXBlcHVibGljYnVmLnB1c2goMHhGRkZEIC8qIFJFUExBQ0VNRU5UIENIQVJBQ1RFUiAqLyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDB4MDAzRTogLy8gR1JFQVRFUi1USEFOIFNJR05cbiAgICAgIGZvcmNlcXVpcmtzKCk7XG4gICAgICB0b2tlbml6ZXIgPSBkYXRhX3N0YXRlO1xuICAgICAgZW1pdERvY3R5cGUoKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgLTE6IC8vIEVPRlxuICAgICAgZm9yY2VxdWlya3MoKTtcbiAgICAgIGVtaXREb2N0eXBlKCk7XG4gICAgICBlbWl0RU9GKCk7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgZG9jdHlwZXB1YmxpY2J1Zi5wdXNoKGMpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gYWZ0ZXJfZG9jdHlwZV9wdWJsaWNfaWRlbnRpZmllcl9zdGF0ZShjKSB7XG4gICAgc3dpdGNoKGMpIHtcbiAgICBjYXNlIDB4MDAwOTogLy8gQ0hBUkFDVEVSIFRBQlVMQVRJT04gKHRhYilcbiAgICBjYXNlIDB4MDAwQTogLy8gTElORSBGRUVEIChMRilcbiAgICBjYXNlIDB4MDAwQzogLy8gRk9STSBGRUVEIChGRilcbiAgICBjYXNlIDB4MDAyMDogLy8gU1BBQ0VcbiAgICAgIHRva2VuaXplciA9IGJldHdlZW5fZG9jdHlwZV9wdWJsaWNfYW5kX3N5c3RlbV9pZGVudGlmaWVyc19zdGF0ZTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMHgwMDNFOiAvLyBHUkVBVEVSLVRIQU4gU0lHTlxuICAgICAgdG9rZW5pemVyID0gZGF0YV9zdGF0ZTtcbiAgICAgIGVtaXREb2N0eXBlKCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDB4MDAyMjogLy8gUVVPVEFUSU9OIE1BUktcbiAgICAgIGJlZ2luRG9jdHlwZVN5c3RlbUlkKCk7XG4gICAgICB0b2tlbml6ZXIgPSBkb2N0eXBlX3N5c3RlbV9pZGVudGlmaWVyX2RvdWJsZV9xdW90ZWRfc3RhdGU7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDB4MDAyNzogLy8gQVBPU1RST1BIRVxuICAgICAgYmVnaW5Eb2N0eXBlU3lzdGVtSWQoKTtcbiAgICAgIHRva2VuaXplciA9IGRvY3R5cGVfc3lzdGVtX2lkZW50aWZpZXJfc2luZ2xlX3F1b3RlZF9zdGF0ZTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgLTE6IC8vIEVPRlxuICAgICAgZm9yY2VxdWlya3MoKTtcbiAgICAgIGVtaXREb2N0eXBlKCk7XG4gICAgICBlbWl0RU9GKCk7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgZm9yY2VxdWlya3MoKTtcbiAgICAgIHRva2VuaXplciA9IGJvZ3VzX2RvY3R5cGVfc3RhdGU7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBiZXR3ZWVuX2RvY3R5cGVfcHVibGljX2FuZF9zeXN0ZW1faWRlbnRpZmllcnNfc3RhdGUoYykge1xuICAgIHN3aXRjaChjKSB7XG4gICAgY2FzZSAweDAwMDk6IC8vIENIQVJBQ1RFUiBUQUJVTEFUSU9OICh0YWIpXG4gICAgY2FzZSAweDAwMEE6IC8vIExJTkUgRkVFRCAoTEYpXG4gICAgY2FzZSAweDAwMEM6IC8vIEZPUk0gRkVFRCAoRkYpXG4gICAgY2FzZSAweDAwMjA6IC8vIFNQQUNFIElnbm9yZSB0aGUgY2hhcmFjdGVyLlxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAweDAwM0U6IC8vIEdSRUFURVItVEhBTiBTSUdOXG4gICAgICB0b2tlbml6ZXIgPSBkYXRhX3N0YXRlO1xuICAgICAgZW1pdERvY3R5cGUoKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMHgwMDIyOiAvLyBRVU9UQVRJT04gTUFSS1xuICAgICAgYmVnaW5Eb2N0eXBlU3lzdGVtSWQoKTtcbiAgICAgIHRva2VuaXplciA9IGRvY3R5cGVfc3lzdGVtX2lkZW50aWZpZXJfZG91YmxlX3F1b3RlZF9zdGF0ZTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMHgwMDI3OiAvLyBBUE9TVFJPUEhFXG4gICAgICBiZWdpbkRvY3R5cGVTeXN0ZW1JZCgpO1xuICAgICAgdG9rZW5pemVyID0gZG9jdHlwZV9zeXN0ZW1faWRlbnRpZmllcl9zaW5nbGVfcXVvdGVkX3N0YXRlO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAtMTogLy8gRU9GXG4gICAgICBmb3JjZXF1aXJrcygpO1xuICAgICAgZW1pdERvY3R5cGUoKTtcbiAgICAgIGVtaXRFT0YoKTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBmb3JjZXF1aXJrcygpO1xuICAgICAgdG9rZW5pemVyID0gYm9ndXNfZG9jdHlwZV9zdGF0ZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGFmdGVyX2RvY3R5cGVfc3lzdGVtX2tleXdvcmRfc3RhdGUoYykge1xuICAgIHN3aXRjaChjKSB7XG4gICAgY2FzZSAweDAwMDk6IC8vIENIQVJBQ1RFUiBUQUJVTEFUSU9OICh0YWIpXG4gICAgY2FzZSAweDAwMEE6IC8vIExJTkUgRkVFRCAoTEYpXG4gICAgY2FzZSAweDAwMEM6IC8vIEZPUk0gRkVFRCAoRkYpXG4gICAgY2FzZSAweDAwMjA6IC8vIFNQQUNFXG4gICAgICB0b2tlbml6ZXIgPSBiZWZvcmVfZG9jdHlwZV9zeXN0ZW1faWRlbnRpZmllcl9zdGF0ZTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMHgwMDIyOiAvLyBRVU9UQVRJT04gTUFSS1xuICAgICAgYmVnaW5Eb2N0eXBlU3lzdGVtSWQoKTtcbiAgICAgIHRva2VuaXplciA9IGRvY3R5cGVfc3lzdGVtX2lkZW50aWZpZXJfZG91YmxlX3F1b3RlZF9zdGF0ZTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMHgwMDI3OiAvLyBBUE9TVFJPUEhFXG4gICAgICBiZWdpbkRvY3R5cGVTeXN0ZW1JZCgpO1xuICAgICAgdG9rZW5pemVyID0gZG9jdHlwZV9zeXN0ZW1faWRlbnRpZmllcl9zaW5nbGVfcXVvdGVkX3N0YXRlO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAweDAwM0U6IC8vIEdSRUFURVItVEhBTiBTSUdOXG4gICAgICBmb3JjZXF1aXJrcygpO1xuICAgICAgdG9rZW5pemVyID0gZGF0YV9zdGF0ZTtcbiAgICAgIGVtaXREb2N0eXBlKCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIC0xOiAvLyBFT0ZcbiAgICAgIGZvcmNlcXVpcmtzKCk7XG4gICAgICBlbWl0RG9jdHlwZSgpO1xuICAgICAgZW1pdEVPRigpO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIGZvcmNlcXVpcmtzKCk7XG4gICAgICB0b2tlbml6ZXIgPSBib2d1c19kb2N0eXBlX3N0YXRlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gYmVmb3JlX2RvY3R5cGVfc3lzdGVtX2lkZW50aWZpZXJfc3RhdGUoYykge1xuICAgIHN3aXRjaChjKSB7XG4gICAgY2FzZSAweDAwMDk6IC8vIENIQVJBQ1RFUiBUQUJVTEFUSU9OICh0YWIpXG4gICAgY2FzZSAweDAwMEE6IC8vIExJTkUgRkVFRCAoTEYpXG4gICAgY2FzZSAweDAwMEM6IC8vIEZPUk0gRkVFRCAoRkYpXG4gICAgY2FzZSAweDAwMjA6IC8vIFNQQUNFIElnbm9yZSB0aGUgY2hhcmFjdGVyLlxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAweDAwMjI6IC8vIFFVT1RBVElPTiBNQVJLXG4gICAgICBiZWdpbkRvY3R5cGVTeXN0ZW1JZCgpO1xuICAgICAgdG9rZW5pemVyID0gZG9jdHlwZV9zeXN0ZW1faWRlbnRpZmllcl9kb3VibGVfcXVvdGVkX3N0YXRlO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAweDAwMjc6IC8vIEFQT1NUUk9QSEVcbiAgICAgIGJlZ2luRG9jdHlwZVN5c3RlbUlkKCk7XG4gICAgICB0b2tlbml6ZXIgPSBkb2N0eXBlX3N5c3RlbV9pZGVudGlmaWVyX3NpbmdsZV9xdW90ZWRfc3RhdGU7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDB4MDAzRTogLy8gR1JFQVRFUi1USEFOIFNJR05cbiAgICAgIGZvcmNlcXVpcmtzKCk7XG4gICAgICB0b2tlbml6ZXIgPSBkYXRhX3N0YXRlO1xuICAgICAgZW1pdERvY3R5cGUoKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgLTE6IC8vIEVPRlxuICAgICAgZm9yY2VxdWlya3MoKTtcbiAgICAgIGVtaXREb2N0eXBlKCk7XG4gICAgICBlbWl0RU9GKCk7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgZm9yY2VxdWlya3MoKTtcbiAgICAgIHRva2VuaXplciA9IGJvZ3VzX2RvY3R5cGVfc3RhdGU7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBkb2N0eXBlX3N5c3RlbV9pZGVudGlmaWVyX2RvdWJsZV9xdW90ZWRfc3RhdGUoYykge1xuICAgIHN3aXRjaChjKSB7XG4gICAgY2FzZSAweDAwMjI6IC8vIFFVT1RBVElPTiBNQVJLXG4gICAgICB0b2tlbml6ZXIgPSBhZnRlcl9kb2N0eXBlX3N5c3RlbV9pZGVudGlmaWVyX3N0YXRlO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAweDAwMDA6IC8vIE5VTExcbiAgICAgIGRvY3R5cGVzeXN0ZW1idWYucHVzaCgweEZGRkQgLyogUkVQTEFDRU1FTlQgQ0hBUkFDVEVSICovKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMHgwMDNFOiAvLyBHUkVBVEVSLVRIQU4gU0lHTlxuICAgICAgZm9yY2VxdWlya3MoKTtcbiAgICAgIHRva2VuaXplciA9IGRhdGFfc3RhdGU7XG4gICAgICBlbWl0RG9jdHlwZSgpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAtMTogLy8gRU9GXG4gICAgICBmb3JjZXF1aXJrcygpO1xuICAgICAgZW1pdERvY3R5cGUoKTtcbiAgICAgIGVtaXRFT0YoKTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBkb2N0eXBlc3lzdGVtYnVmLnB1c2goYyk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBkb2N0eXBlX3N5c3RlbV9pZGVudGlmaWVyX3NpbmdsZV9xdW90ZWRfc3RhdGUoYykge1xuICAgIHN3aXRjaChjKSB7XG4gICAgY2FzZSAweDAwMjc6IC8vIEFQT1NUUk9QSEVcbiAgICAgIHRva2VuaXplciA9IGFmdGVyX2RvY3R5cGVfc3lzdGVtX2lkZW50aWZpZXJfc3RhdGU7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDB4MDAwMDogLy8gTlVMTFxuICAgICAgZG9jdHlwZXN5c3RlbWJ1Zi5wdXNoKDB4RkZGRCAvKiBSRVBMQUNFTUVOVCBDSEFSQUNURVIgKi8pO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAweDAwM0U6IC8vIEdSRUFURVItVEhBTiBTSUdOXG4gICAgICBmb3JjZXF1aXJrcygpO1xuICAgICAgdG9rZW5pemVyID0gZGF0YV9zdGF0ZTtcbiAgICAgIGVtaXREb2N0eXBlKCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIC0xOiAvLyBFT0ZcbiAgICAgIGZvcmNlcXVpcmtzKCk7XG4gICAgICBlbWl0RG9jdHlwZSgpO1xuICAgICAgZW1pdEVPRigpO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIGRvY3R5cGVzeXN0ZW1idWYucHVzaChjKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGFmdGVyX2RvY3R5cGVfc3lzdGVtX2lkZW50aWZpZXJfc3RhdGUoYykge1xuICAgIHN3aXRjaChjKSB7XG4gICAgY2FzZSAweDAwMDk6IC8vIENIQVJBQ1RFUiBUQUJVTEFUSU9OICh0YWIpXG4gICAgY2FzZSAweDAwMEE6IC8vIExJTkUgRkVFRCAoTEYpXG4gICAgY2FzZSAweDAwMEM6IC8vIEZPUk0gRkVFRCAoRkYpXG4gICAgY2FzZSAweDAwMjA6IC8vIFNQQUNFXG4gICAgICAvKiBJZ25vcmUgdGhlIGNoYXJhY3Rlci4gKi9cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMHgwMDNFOiAvLyBHUkVBVEVSLVRIQU4gU0lHTlxuICAgICAgdG9rZW5pemVyID0gZGF0YV9zdGF0ZTtcbiAgICAgIGVtaXREb2N0eXBlKCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIC0xOiAvLyBFT0ZcbiAgICAgIGZvcmNlcXVpcmtzKCk7XG4gICAgICBlbWl0RG9jdHlwZSgpO1xuICAgICAgZW1pdEVPRigpO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRva2VuaXplciA9IGJvZ3VzX2RvY3R5cGVfc3RhdGU7XG4gICAgICAvKiBUaGlzIGRvZXMgKm5vdCogc2V0IHRoZSBET0NUWVBFIHRva2VuJ3MgZm9yY2UtcXVpcmtzIGZsYWcuICovXG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBib2d1c19kb2N0eXBlX3N0YXRlKGMpIHtcbiAgICBzd2l0Y2goYykge1xuICAgIGNhc2UgMHgwMDNFOiAvLyBHUkVBVEVSLVRIQU4gU0lHTlxuICAgICAgdG9rZW5pemVyID0gZGF0YV9zdGF0ZTtcbiAgICAgIGVtaXREb2N0eXBlKCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIC0xOiAvLyBFT0ZcbiAgICAgIGVtaXREb2N0eXBlKCk7XG4gICAgICBlbWl0RU9GKCk7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgLyogSWdub3JlIHRoZSBjaGFyYWN0ZXIuICovXG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjZGF0YV9zZWN0aW9uX3N0YXRlKGMpIHtcbiAgICBzd2l0Y2goYykge1xuICAgIGNhc2UgMHgwMDVEOiAvLyBSSUdIVCBTUVVBUkUgQlJBQ0tFVFxuICAgICAgdG9rZW5pemVyID0gY2RhdGFfc2VjdGlvbl9icmFja2V0X3N0YXRlO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAtMTogLy8gRU9GXG4gICAgICBlbWl0RU9GKCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDB4MDAwMDogLy8gTlVMTFxuICAgICAgdGV4dEluY2x1ZGVzTlVMID0gdHJ1ZTtcbiAgICAgIC8qIGZhbGwgdGhyb3VnaCAqL1xuICAgIGRlZmF1bHQ6XG4gICAgICAvLyBJbnN0ZWFkIG9mIGp1c3QgcHVzaGluZyBhIHNpbmdsZSBjaGFyYWN0ZXIgYW5kIHRoZW5cbiAgICAgIC8vIGNvbWluZyBiYWNrIHRvIHRoZSB2ZXJ5IHNhbWUgcGxhY2UsIGxvb2thaGVhZCBhbmRcbiAgICAgIC8vIGVtaXQgZXZlcnl0aGluZyB3ZSBjYW4gYXQgb25jZS5cbiAgICAgIC8qanNoaW50IC1XMDMwICovXG4gICAgICBlbWl0Q2hhcnNXaGlsZShDREFUQVRFWFQpIHx8IHRleHRydW4ucHVzaChjKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNkYXRhX3NlY3Rpb25fYnJhY2tldF9zdGF0ZShjKSB7XG4gICAgc3dpdGNoKGMpIHtcbiAgICBjYXNlIDB4MDA1RDogLy8gUklHSFQgU1FVQVJFIEJSQUNLRVRcbiAgICAgIHRva2VuaXplciA9IGNkYXRhX3NlY3Rpb25fZW5kX3N0YXRlO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRleHRydW4ucHVzaCgweDAwNUQpO1xuICAgICAgcmVjb25zdW1lKGMsIGNkYXRhX3NlY3Rpb25fc3RhdGUpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY2RhdGFfc2VjdGlvbl9lbmRfc3RhdGUoYykge1xuICAgIHN3aXRjaChjKSB7XG4gICAgY2FzZSAweDAwNUQ6IC8vIFJJR0hUIFNRVUFSRSBCUkFDS0VUXG4gICAgICB0ZXh0cnVuLnB1c2goMHgwMDVEKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMHgwMDNFOiAvLyBHUkVBVEVSLVRIQU4gU0lHTlxuICAgICAgZmx1c2hUZXh0KCk7XG4gICAgICB0b2tlbml6ZXIgPSBkYXRhX3N0YXRlO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRleHRydW4ucHVzaCgweDAwNUQpO1xuICAgICAgdGV4dHJ1bi5wdXNoKDB4MDA1RCk7XG4gICAgICByZWNvbnN1bWUoYywgY2RhdGFfc2VjdGlvbl9zdGF0ZSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjaGFyYWN0ZXJfcmVmZXJlbmNlX3N0YXRlKGMpIHtcbiAgICBiZWdpblRlbXBCdWYoKTtcbiAgICB0ZW1wYnVmLnB1c2goMHgwMDI2KTtcbiAgICBzd2l0Y2goYykge1xuICAgIGNhc2UgMHgwMDA5OiAvLyBUQUJcbiAgICBjYXNlIDB4MDAwQTogLy8gTElORSBGRUVEXG4gICAgY2FzZSAweDAwMEM6IC8vIEZPUk0gRkVFRFxuICAgIGNhc2UgMHgwMDIwOiAvLyBTUEFDRVxuICAgIGNhc2UgMHgwMDNDOiAvLyBMRVNTLVRIQU4gU0lHTlxuICAgIGNhc2UgMHgwMDI2OiAvLyBBTVBFUlNBTkRcbiAgICBjYXNlIC0xOiAvLyBFT0ZcbiAgICAgIHJlY29uc3VtZShjLCBjaGFyYWN0ZXJfcmVmZXJlbmNlX2VuZF9zdGF0ZSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDB4MDAyMzogLy8gTlVNQkVSIFNJR05cbiAgICAgIHRlbXBidWYucHVzaChjKTtcbiAgICAgIHRva2VuaXplciA9IG51bWVyaWNfY2hhcmFjdGVyX3JlZmVyZW5jZV9zdGF0ZTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZWNvbnN1bWUoYywgbmFtZWRfY2hhcmFjdGVyX3JlZmVyZW5jZV9zdGF0ZSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBuYW1lZF9jaGFyYWN0ZXJfcmVmZXJlbmNlX3N0YXRlKGMpIHtcbiAgICBOQU1FRENIQVJSRUYubGFzdEluZGV4ID0gbmV4dGNoYXI7IC8vIHcvIGxvb2thaGVhZCBubyBjaGFyIGhhcyBiZWVuIGNvbnN1bWVkXG4gICAgdmFyIG1hdGNoZWQgPSBOQU1FRENIQVJSRUYuZXhlYyhjaGFycyk7XG4gICAgaWYgKCFtYXRjaGVkKSB0aHJvdyBuZXcgRXJyb3IoXCJzaG91bGQgbmV2ZXIgaGFwcGVuXCIpO1xuICAgIHZhciBuYW1lID0gbWF0Y2hlZFsxXTtcbiAgICBpZiAoIW5hbWUpIHtcbiAgICAgIC8vIElmIG5vIG1hdGNoIGNhbiBiZSBtYWRlLCBzd2l0Y2ggdG8gdGhlIGNoYXJhY3RlciByZWZlcmVuY2UgZW5kIHN0YXRlXG4gICAgICB0b2tlbml6ZXIgPSBjaGFyYWN0ZXJfcmVmZXJlbmNlX2VuZF9zdGF0ZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBDb25zdW1lIHRoZSBtYXRjaGVkIGNoYXJhY3RlcnMgYW5kIGFwcGVuZCB0aGVtIHRvIHRlbXBvcmFyeSBidWZmZXJcbiAgICBuZXh0Y2hhciArPSBuYW1lLmxlbmd0aDtcbiAgICBwdXNoQWxsKHRlbXBidWYsIHN0cjJidWYobmFtZSkpO1xuXG4gICAgc3dpdGNoKHJldHVybl9zdGF0ZSkge1xuICAgIGNhc2UgYXR0cmlidXRlX3ZhbHVlX2RvdWJsZV9xdW90ZWRfc3RhdGU6XG4gICAgY2FzZSBhdHRyaWJ1dGVfdmFsdWVfc2luZ2xlX3F1b3RlZF9zdGF0ZTpcbiAgICBjYXNlIGF0dHJpYnV0ZV92YWx1ZV91bnF1b3RlZF9zdGF0ZTpcbiAgICAgIC8vIElmIHRoZSBjaGFyYWN0ZXIgcmVmZXJlbmNlIHdhcyBjb25zdW1lZCBhcyBwYXJ0IG9mIGFuIGF0dHJpYnV0ZS4uLlxuICAgICAgaWYgKG5hbWVbbmFtZS5sZW5ndGgtMV0gIT09ICc7JykgeyAvLyAuLi5hbmQgdGhlIGxhc3QgY2hhciBpcyBub3QgO1xuICAgICAgICBpZiAoL1s9QS1aYS16MC05XS8udGVzdChjaGFyc1tuZXh0Y2hhcl0pKSB7XG4gICAgICAgICAgdG9rZW5pemVyID0gY2hhcmFjdGVyX3JlZmVyZW5jZV9lbmRfc3RhdGU7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgYmVnaW5UZW1wQnVmKCk7XG4gICAgdmFyIHJ2ID0gbmFtZWRDaGFyUmVmc1tuYW1lXTtcbiAgICBpZiAodHlwZW9mIHJ2ID09PSAnbnVtYmVyJykge1xuICAgICAgdGVtcGJ1Zi5wdXNoKHJ2KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHVzaEFsbCh0ZW1wYnVmLCBydik7XG4gICAgfVxuICAgIHRva2VuaXplciA9IGNoYXJhY3Rlcl9yZWZlcmVuY2VfZW5kX3N0YXRlO1xuICB9XG4gIC8vIFdlIG1pZ2h0IG5lZWQgdG8gcGF1c2UgdG9rZW5pemF0aW9uIHVudGlsIHdlIGhhdmUgZW5vdWdoIGNoYXJhY3RlcnNcbiAgLy8gaW4gdGhlIGJ1ZmZlciBmb3IgbG9uZ2VzdCBwb3NzaWJsZSBjaGFyYWN0ZXIgcmVmZXJlbmNlLlxuICBuYW1lZF9jaGFyYWN0ZXJfcmVmZXJlbmNlX3N0YXRlLmxvb2thaGVhZCA9IC1OQU1FRENIQVJSRUZfTUFYTEVOO1xuXG4gIGZ1bmN0aW9uIG51bWVyaWNfY2hhcmFjdGVyX3JlZmVyZW5jZV9zdGF0ZShjKSB7XG4gICAgY2hhcmFjdGVyX3JlZmVyZW5jZV9jb2RlID0gMDtcbiAgICBzd2l0Y2goYykge1xuICAgIGNhc2UgMHgwMDc4OiAvLyB4XG4gICAgY2FzZSAweDAwNTg6IC8vIFhcbiAgICAgIHRlbXBidWYucHVzaChjKTtcbiAgICAgIHRva2VuaXplciA9IGhleGFkZWNpbWFsX2NoYXJhY3Rlcl9yZWZlcmVuY2Vfc3RhcnRfc3RhdGU7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgcmVjb25zdW1lKGMsIGRlY2ltYWxfY2hhcmFjdGVyX3JlZmVyZW5jZV9zdGFydF9zdGF0ZSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBoZXhhZGVjaW1hbF9jaGFyYWN0ZXJfcmVmZXJlbmNlX3N0YXJ0X3N0YXRlKGMpIHtcbiAgICBzd2l0Y2goYykge1xuICAgIGNhc2UgMHgwMDMwOiBjYXNlIDB4MDAzMTogY2FzZSAweDAwMzI6IGNhc2UgMHgwMDMzOiBjYXNlIDB4MDAzNDpcbiAgICBjYXNlIDB4MDAzNTogY2FzZSAweDAwMzY6IGNhc2UgMHgwMDM3OiBjYXNlIDB4MDAzODogY2FzZSAweDAwMzk6IC8vIFswLTldXG4gICAgY2FzZSAweDAwNDE6IGNhc2UgMHgwMDQyOiBjYXNlIDB4MDA0MzogY2FzZSAweDAwNDQ6IGNhc2UgMHgwMDQ1OlxuICAgIGNhc2UgMHgwMDQ2OiAvLyBbQS1GXVxuICAgIGNhc2UgMHgwMDYxOiBjYXNlIDB4MDA2MjogY2FzZSAweDAwNjM6IGNhc2UgMHgwMDY0OiBjYXNlIDB4MDA2NTpcbiAgICBjYXNlIDB4MDA2NjogLy8gW2EtZl1cbiAgICAgIHJlY29uc3VtZShjLCBoZXhhZGVjaW1hbF9jaGFyYWN0ZXJfcmVmZXJlbmNlX3N0YXRlKTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZWNvbnN1bWUoYywgY2hhcmFjdGVyX3JlZmVyZW5jZV9lbmRfc3RhdGUpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZGVjaW1hbF9jaGFyYWN0ZXJfcmVmZXJlbmNlX3N0YXJ0X3N0YXRlKGMpIHtcbiAgICBzd2l0Y2goYykge1xuICAgIGNhc2UgMHgwMDMwOiBjYXNlIDB4MDAzMTogY2FzZSAweDAwMzI6IGNhc2UgMHgwMDMzOiBjYXNlIDB4MDAzNDpcbiAgICBjYXNlIDB4MDAzNTogY2FzZSAweDAwMzY6IGNhc2UgMHgwMDM3OiBjYXNlIDB4MDAzODogY2FzZSAweDAwMzk6IC8vIFswLTldXG4gICAgICByZWNvbnN1bWUoYywgZGVjaW1hbF9jaGFyYWN0ZXJfcmVmZXJlbmNlX3N0YXRlKTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZWNvbnN1bWUoYywgY2hhcmFjdGVyX3JlZmVyZW5jZV9lbmRfc3RhdGUpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaGV4YWRlY2ltYWxfY2hhcmFjdGVyX3JlZmVyZW5jZV9zdGF0ZShjKSB7XG4gICAgc3dpdGNoKGMpIHtcbiAgICBjYXNlIDB4MDA0MTogY2FzZSAweDAwNDI6IGNhc2UgMHgwMDQzOiBjYXNlIDB4MDA0NDogY2FzZSAweDAwNDU6XG4gICAgY2FzZSAweDAwNDY6IC8vIFtBLUZdXG4gICAgICBjaGFyYWN0ZXJfcmVmZXJlbmNlX2NvZGUgKj0gMTY7XG4gICAgICBjaGFyYWN0ZXJfcmVmZXJlbmNlX2NvZGUgKz0gKGMgLSAweDAwMzcpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAweDAwNjE6IGNhc2UgMHgwMDYyOiBjYXNlIDB4MDA2MzogY2FzZSAweDAwNjQ6IGNhc2UgMHgwMDY1OlxuICAgIGNhc2UgMHgwMDY2OiAvLyBbYS1mXVxuICAgICAgY2hhcmFjdGVyX3JlZmVyZW5jZV9jb2RlICo9IDE2O1xuICAgICAgY2hhcmFjdGVyX3JlZmVyZW5jZV9jb2RlICs9IChjIC0gMHgwMDU3KTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMHgwMDMwOiBjYXNlIDB4MDAzMTogY2FzZSAweDAwMzI6IGNhc2UgMHgwMDMzOiBjYXNlIDB4MDAzNDpcbiAgICBjYXNlIDB4MDAzNTogY2FzZSAweDAwMzY6IGNhc2UgMHgwMDM3OiBjYXNlIDB4MDAzODogY2FzZSAweDAwMzk6IC8vIFswLTldXG4gICAgICBjaGFyYWN0ZXJfcmVmZXJlbmNlX2NvZGUgKj0gMTY7XG4gICAgICBjaGFyYWN0ZXJfcmVmZXJlbmNlX2NvZGUgKz0gKGMgLSAweDAwMzApO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAweDAwM0I6IC8vIFNFTUlDT0xPTlxuICAgICAgdG9rZW5pemVyID0gbnVtZXJpY19jaGFyYWN0ZXJfcmVmZXJlbmNlX2VuZF9zdGF0ZTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZWNvbnN1bWUoYywgbnVtZXJpY19jaGFyYWN0ZXJfcmVmZXJlbmNlX2VuZF9zdGF0ZSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBkZWNpbWFsX2NoYXJhY3Rlcl9yZWZlcmVuY2Vfc3RhdGUoYykge1xuICAgIHN3aXRjaChjKSB7XG4gICAgY2FzZSAweDAwMzA6IGNhc2UgMHgwMDMxOiBjYXNlIDB4MDAzMjogY2FzZSAweDAwMzM6IGNhc2UgMHgwMDM0OlxuICAgIGNhc2UgMHgwMDM1OiBjYXNlIDB4MDAzNjogY2FzZSAweDAwMzc6IGNhc2UgMHgwMDM4OiBjYXNlIDB4MDAzOTogLy8gWzAtOV1cbiAgICAgIGNoYXJhY3Rlcl9yZWZlcmVuY2VfY29kZSAqPSAxMDtcbiAgICAgIGNoYXJhY3Rlcl9yZWZlcmVuY2VfY29kZSArPSAoYyAtIDB4MDAzMCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDB4MDAzQjogLy8gU0VNSUNPTE9OXG4gICAgICB0b2tlbml6ZXIgPSBudW1lcmljX2NoYXJhY3Rlcl9yZWZlcmVuY2VfZW5kX3N0YXRlO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJlY29uc3VtZShjLCBudW1lcmljX2NoYXJhY3Rlcl9yZWZlcmVuY2VfZW5kX3N0YXRlKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG51bWVyaWNfY2hhcmFjdGVyX3JlZmVyZW5jZV9lbmRfc3RhdGUoYykge1xuICAgIGlmIChjaGFyYWN0ZXJfcmVmZXJlbmNlX2NvZGUgaW4gbnVtZXJpY0NoYXJSZWZSZXBsYWNlbWVudHMpIHtcbiAgICAgIGNoYXJhY3Rlcl9yZWZlcmVuY2VfY29kZSA9IG51bWVyaWNDaGFyUmVmUmVwbGFjZW1lbnRzW2NoYXJhY3Rlcl9yZWZlcmVuY2VfY29kZV07XG4gICAgfSBlbHNlIGlmIChjaGFyYWN0ZXJfcmVmZXJlbmNlX2NvZGUgPiAweDEwRkZGRiB8fCAoY2hhcmFjdGVyX3JlZmVyZW5jZV9jb2RlID49IDB4RDgwMCAmJiBjaGFyYWN0ZXJfcmVmZXJlbmNlX2NvZGUgPCAweEUwMDApKSB7XG4gICAgICBjaGFyYWN0ZXJfcmVmZXJlbmNlX2NvZGUgPSAweEZGRkQ7XG4gICAgfVxuXG4gICAgYmVnaW5UZW1wQnVmKCk7XG4gICAgaWYgKGNoYXJhY3Rlcl9yZWZlcmVuY2VfY29kZSA8PSAweEZGRkYpIHtcbiAgICAgIHRlbXBidWYucHVzaChjaGFyYWN0ZXJfcmVmZXJlbmNlX2NvZGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjaGFyYWN0ZXJfcmVmZXJlbmNlX2NvZGUgPSBjaGFyYWN0ZXJfcmVmZXJlbmNlX2NvZGUgLSAweDEwMDAwO1xuICAgICAgLyoganNoaW50IGJpdHdpc2U6IGZhbHNlICovXG4gICAgICB0ZW1wYnVmLnB1c2goMHhEODAwICsgKGNoYXJhY3Rlcl9yZWZlcmVuY2VfY29kZSA+PiAxMCkpO1xuICAgICAgdGVtcGJ1Zi5wdXNoKDB4REMwMCArIChjaGFyYWN0ZXJfcmVmZXJlbmNlX2NvZGUgJiAweDAzRkYpKTtcbiAgICB9XG4gICAgcmVjb25zdW1lKGMsIGNoYXJhY3Rlcl9yZWZlcmVuY2VfZW5kX3N0YXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNoYXJhY3Rlcl9yZWZlcmVuY2VfZW5kX3N0YXRlKGMpIHtcbiAgICBzd2l0Y2gocmV0dXJuX3N0YXRlKSB7XG4gICAgY2FzZSBhdHRyaWJ1dGVfdmFsdWVfZG91YmxlX3F1b3RlZF9zdGF0ZTpcbiAgICBjYXNlIGF0dHJpYnV0ZV92YWx1ZV9zaW5nbGVfcXVvdGVkX3N0YXRlOlxuICAgIGNhc2UgYXR0cmlidXRlX3ZhbHVlX3VucXVvdGVkX3N0YXRlOlxuICAgICAgLy8gYXBwZW5kIGVhY2ggY2hhcmFjdGVyIHRvIHRoZSBjdXJyZW50IGF0dHJpYnV0ZSdzIHZhbHVlXG4gICAgICBhdHRydmFsdWVidWYgKz0gYnVmMnN0cih0ZW1wYnVmKTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBwdXNoQWxsKHRleHRydW4sIHRlbXBidWYpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJlY29uc3VtZShjLCByZXR1cm5fc3RhdGUpO1xuICB9XG5cbiAgLyoqKlxuICAgKiBUaGUgdHJlZSBidWlsZGVyIGluc2VydGlvbiBtb2Rlc1xuICAgKi9cblxuICAvLyAxMS4yLjUuNC4xIFRoZSBcImluaXRpYWxcIiBpbnNlcnRpb24gbW9kZVxuICBmdW5jdGlvbiBpbml0aWFsX21vZGUodCwgdmFsdWUsIGFyZzMsIGFyZzQpIHtcbiAgICBzd2l0Y2godCkge1xuICAgIGNhc2UgMTogLy8gVEVYVFxuICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKExFQURJTkdXUywgXCJcIik7IC8vIElnbm9yZSBzcGFjZXNcbiAgICAgIGlmICh2YWx1ZS5sZW5ndGggPT09IDApIHJldHVybjsgLy8gQXJlIHdlIGRvbmU/XG4gICAgICBicmVhazsgLy8gSGFuZGxlIGFueXRoaW5nIG5vbi1zcGFjZSB0ZXh0IGJlbG93XG4gICAgY2FzZSA0OiAvLyBDT01NRU5UXG4gICAgICBkb2MuX2FwcGVuZENoaWxkKGRvYy5jcmVhdGVDb21tZW50KHZhbHVlKSk7XG4gICAgICByZXR1cm47XG4gICAgY2FzZSA1OiAvLyBET0NUWVBFXG4gICAgICB2YXIgbmFtZSA9IHZhbHVlO1xuICAgICAgdmFyIHB1YmxpY2lkID0gYXJnMztcbiAgICAgIHZhciBzeXN0ZW1pZCA9IGFyZzQ7XG4gICAgICAvLyBVc2UgdGhlIGNvbnN0cnVjdG9yIGRpcmVjdGx5IGluc3RlYWQgb2ZcbiAgICAgIC8vIGltcGxlbWVudGF0aW9uLmNyZWF0ZURvY3VtZW50VHlwZSBiZWNhdXNlIHRoZSBjcmVhdGVcbiAgICAgIC8vIGZ1bmN0aW9uIHRocm93cyBlcnJvcnMgb24gaW52YWxpZCBjaGFyYWN0ZXJzLCBhbmRcbiAgICAgIC8vIHdlIGRvbid0IHdhbnQgdGhlIHBhcnNlciB0byB0aHJvdyB0aGVtLlxuICAgICAgZG9jLmFwcGVuZENoaWxkKG5ldyBEb2N1bWVudFR5cGUobmFtZSxwdWJsaWNpZCwgc3lzdGVtaWQpKTtcblxuICAgICAgLy8gTm90ZSB0aGF0IHRoZXJlIGlzIG5vIHB1YmxpYyBBUEkgZm9yIHNldHRpbmcgcXVpcmtzIG1vZGUgV2UgY2FuXG4gICAgICAvLyBkbyB0aGlzIGhlcmUgYmVjYXVzZSB3ZSBoYXZlIGFjY2VzcyB0byBpbXBsZW1lbnRhdGlvbiBkZXRhaWxzXG4gICAgICBpZiAoZm9yY2VfcXVpcmtzIHx8XG4gICAgICAgIG5hbWUudG9Mb3dlckNhc2UoKSAhPT0gXCJodG1sXCIgfHxcbiAgICAgICAgcXVpcmt5UHVibGljSWRzLnRlc3QocHVibGljaWQpIHx8XG4gICAgICAgIChzeXN0ZW1pZCAmJiBzeXN0ZW1pZC50b0xvd2VyQ2FzZSgpID09PSBxdWlya3lTeXN0ZW1JZCkgfHxcbiAgICAgICAgKHN5c3RlbWlkID09PSB1bmRlZmluZWQgJiZcbiAgICAgICAgIGNvbmRpdGlvbmFsbHlRdWlya3lQdWJsaWNJZHMudGVzdChwdWJsaWNpZCkpKVxuICAgICAgICBkb2MuX3F1aXJrcyA9IHRydWU7XG4gICAgICBlbHNlIGlmIChsaW1pdGVkUXVpcmt5UHVibGljSWRzLnRlc3QocHVibGljaWQpIHx8XG4gICAgICAgICAgIChzeXN0ZW1pZCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICBjb25kaXRpb25hbGx5UXVpcmt5UHVibGljSWRzLnRlc3QocHVibGljaWQpKSlcbiAgICAgICAgZG9jLl9saW1pdGVkUXVpcmtzID0gdHJ1ZTtcbiAgICAgIHBhcnNlciA9IGJlZm9yZV9odG1sX21vZGU7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gdGFncyBvciBub24td2hpdGVzcGFjZSB0ZXh0XG4gICAgZG9jLl9xdWlya3MgPSB0cnVlO1xuICAgIHBhcnNlciA9IGJlZm9yZV9odG1sX21vZGU7XG4gICAgcGFyc2VyKHQsdmFsdWUsYXJnMyxhcmc0KTtcbiAgfVxuXG4gIC8vIDExLjIuNS40LjIgVGhlIFwiYmVmb3JlIGh0bWxcIiBpbnNlcnRpb24gbW9kZVxuICBmdW5jdGlvbiBiZWZvcmVfaHRtbF9tb2RlKHQsdmFsdWUsYXJnMyxhcmc0KSB7XG4gICAgdmFyIGVsdDtcbiAgICBzd2l0Y2godCkge1xuICAgIGNhc2UgMTogLy8gVEVYVFxuICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKExFQURJTkdXUywgXCJcIik7IC8vIElnbm9yZSBzcGFjZXNcbiAgICAgIGlmICh2YWx1ZS5sZW5ndGggPT09IDApIHJldHVybjsgLy8gQXJlIHdlIGRvbmU/XG4gICAgICBicmVhazsgLy8gSGFuZGxlIGFueXRoaW5nIG5vbi1zcGFjZSB0ZXh0IGJlbG93XG4gICAgY2FzZSA1OiAvLyBET0NUWVBFXG4gICAgICAvKiBpZ25vcmUgdGhlIHRva2VuICovXG4gICAgICByZXR1cm47XG4gICAgY2FzZSA0OiAvLyBDT01NRU5UXG4gICAgICBkb2MuX2FwcGVuZENoaWxkKGRvYy5jcmVhdGVDb21tZW50KHZhbHVlKSk7XG4gICAgICByZXR1cm47XG4gICAgY2FzZSAyOiAvLyBUQUdcbiAgICAgIGlmICh2YWx1ZSA9PT0gXCJodG1sXCIpIHtcbiAgICAgICAgZWx0ID0gY3JlYXRlSFRNTEVsdChkb2MsIHZhbHVlLCBhcmczKTtcbiAgICAgICAgc3RhY2sucHVzaChlbHQpO1xuICAgICAgICBkb2MuYXBwZW5kQ2hpbGQoZWx0KTtcbiAgICAgICAgLy8gWFhYOiBoYW5kbGUgYXBwbGljYXRpb24gY2FjaGUgaGVyZVxuICAgICAgICBwYXJzZXIgPSBiZWZvcmVfaGVhZF9tb2RlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlIDM6IC8vIEVORFRBR1xuICAgICAgc3dpdGNoKHZhbHVlKSB7XG4gICAgICBjYXNlIFwiaHRtbFwiOlxuICAgICAgY2FzZSBcImhlYWRcIjpcbiAgICAgIGNhc2UgXCJib2R5XCI6XG4gICAgICBjYXNlIFwiYnJcIjpcbiAgICAgICAgYnJlYWs7ICAvLyBmYWxsIHRocm91Z2ggb24gdGhlc2VcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybjsgLy8gaWdub3JlIG1vc3QgZW5kIHRhZ3NcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBBbnl0aGluZyB0aGF0IGRpZG4ndCBnZXQgaGFuZGxlZCBhYm92ZSBpcyBoYW5kbGVkIGxpa2UgdGhpczpcbiAgICBlbHQgPSBjcmVhdGVIVE1MRWx0KGRvYywgXCJodG1sXCIsIG51bGwpO1xuICAgIHN0YWNrLnB1c2goZWx0KTtcbiAgICBkb2MuYXBwZW5kQ2hpbGQoZWx0KTtcbiAgICAvLyBYWFg6IGhhbmRsZSBhcHBsaWNhdGlvbiBjYWNoZSBoZXJlXG4gICAgcGFyc2VyID0gYmVmb3JlX2hlYWRfbW9kZTtcbiAgICBwYXJzZXIodCx2YWx1ZSxhcmczLGFyZzQpO1xuICB9XG5cbiAgLy8gMTEuMi41LjQuMyBUaGUgXCJiZWZvcmUgaGVhZFwiIGluc2VydGlvbiBtb2RlXG4gIGZ1bmN0aW9uIGJlZm9yZV9oZWFkX21vZGUodCx2YWx1ZSxhcmczLGFyZzQpIHtcbiAgICBzd2l0Y2godCkge1xuICAgIGNhc2UgMTogLy8gVEVYVFxuICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKExFQURJTkdXUywgXCJcIik7ICAvLyBJZ25vcmUgc3BhY2VzXG4gICAgICBpZiAodmFsdWUubGVuZ3RoID09PSAwKSByZXR1cm47IC8vIEFyZSB3ZSBkb25lP1xuICAgICAgYnJlYWs7ICAvLyBIYW5kbGUgYW55dGhpbmcgbm9uLXNwYWNlIHRleHQgYmVsb3dcbiAgICBjYXNlIDU6IC8vIERPQ1RZUEVcbiAgICAgIC8qIGlnbm9yZSB0aGUgdG9rZW4gKi9cbiAgICAgIHJldHVybjtcbiAgICBjYXNlIDQ6IC8vIENPTU1FTlRcbiAgICAgIGluc2VydENvbW1lbnQodmFsdWUpO1xuICAgICAgcmV0dXJuO1xuICAgIGNhc2UgMjogLy8gVEFHXG4gICAgICBzd2l0Y2godmFsdWUpIHtcbiAgICAgIGNhc2UgXCJodG1sXCI6XG4gICAgICAgIGluX2JvZHlfbW9kZSh0LHZhbHVlLGFyZzMsYXJnNCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgXCJoZWFkXCI6XG4gICAgICAgIHZhciBlbHQgPSBpbnNlcnRIVE1MRWxlbWVudCh2YWx1ZSwgYXJnMyk7XG4gICAgICAgIGhlYWRfZWxlbWVudF9wb2ludGVyID0gZWx0O1xuICAgICAgICBwYXJzZXIgPSBpbl9oZWFkX21vZGU7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMzogLy8gRU5EVEFHXG4gICAgICBzd2l0Y2godmFsdWUpIHtcbiAgICAgIGNhc2UgXCJodG1sXCI6XG4gICAgICBjYXNlIFwiaGVhZFwiOlxuICAgICAgY2FzZSBcImJvZHlcIjpcbiAgICAgIGNhc2UgXCJiclwiOlxuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybjsgLy8gaWdub3JlIG1vc3QgZW5kIHRhZ3NcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJZiBub3QgaGFuZGxlZCBleHBsaWNpdGx5IGFib3ZlXG4gICAgYmVmb3JlX2hlYWRfbW9kZShUQUcsIFwiaGVhZFwiLCBudWxsKTsgLy8gY3JlYXRlIGEgaGVhZCB0YWdcbiAgICBwYXJzZXIodCwgdmFsdWUsIGFyZzMsIGFyZzQpOyAvLyB0aGVuIHRyeSBhZ2FpbiB3aXRoIHRoaXMgdG9rZW5cbiAgfVxuXG4gIGZ1bmN0aW9uIGluX2hlYWRfbW9kZSh0LCB2YWx1ZSwgYXJnMywgYXJnNCkge1xuICAgIHN3aXRjaCh0KSB7XG4gICAgY2FzZSAxOiAvLyBURVhUXG4gICAgICB2YXIgd3MgPSB2YWx1ZS5tYXRjaChMRUFESU5HV1MpO1xuICAgICAgaWYgKHdzKSB7XG4gICAgICAgIGluc2VydFRleHQod3NbMF0pO1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLnN1YnN0cmluZyh3c1swXS5sZW5ndGgpO1xuICAgICAgfVxuICAgICAgaWYgKHZhbHVlLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuICAgICAgYnJlYWs7IC8vIEhhbmRsZSBub24td2hpdGVzcGFjZSBiZWxvd1xuICAgIGNhc2UgNDogLy8gQ09NTUVOVFxuICAgICAgaW5zZXJ0Q29tbWVudCh2YWx1ZSk7XG4gICAgICByZXR1cm47XG4gICAgY2FzZSA1OiAvLyBET0NUWVBFXG4gICAgICByZXR1cm47XG4gICAgY2FzZSAyOiAvLyBUQUdcbiAgICAgIHN3aXRjaCh2YWx1ZSkge1xuICAgICAgY2FzZSBcImh0bWxcIjpcbiAgICAgICAgaW5fYm9keV9tb2RlKHQsIHZhbHVlLCBhcmczLCBhcmc0KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSBcIm1ldGFcIjpcbiAgICAgICAgLy8gWFhYOlxuICAgICAgICAvLyBNYXkgbmVlZCB0byBjaGFuZ2UgdGhlIGVuY29kaW5nIGJhc2VkIG9uIHRoaXMgdGFnXG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgXCJiYXNlXCI6XG4gICAgICBjYXNlIFwiYmFzZWZvbnRcIjpcbiAgICAgIGNhc2UgXCJiZ3NvdW5kXCI6XG4gICAgICBjYXNlIFwibGlua1wiOlxuICAgICAgICBpbnNlcnRIVE1MRWxlbWVudCh2YWx1ZSwgYXJnMyk7XG4gICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlIFwidGl0bGVcIjpcbiAgICAgICAgcGFyc2VSQ0RBVEEodmFsdWUsIGFyZzMpO1xuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlIFwibm9zY3JpcHRcIjpcbiAgICAgICAgaWYgKCFzY3JpcHRpbmdfZW5hYmxlZCkge1xuICAgICAgICAgIGluc2VydEhUTUxFbGVtZW50KHZhbHVlLCBhcmczKTtcbiAgICAgICAgICBwYXJzZXIgPSBpbl9oZWFkX25vc2NyaXB0X21vZGU7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIE90aGVyd2lzZSwgaWYgc2NyaXB0aW5nIGlzIGVuYWJsZWQuLi5cbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBcIm5vZnJhbWVzXCI6XG4gICAgICBjYXNlIFwic3R5bGVcIjpcbiAgICAgICAgcGFyc2VSYXdUZXh0KHZhbHVlLGFyZzMpO1xuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlIFwic2NyaXB0XCI6XG4gICAgICAgIGluc2VydEVsZW1lbnQoZnVuY3Rpb24oZG9jKSB7XG4gICAgICAgICAgdmFyIGVsdCA9IGNyZWF0ZUhUTUxFbHQoZG9jLCB2YWx1ZSwgYXJnMyk7XG4gICAgICAgICAgZWx0Ll9wYXJzZXJfaW5zZXJ0ZWQgPSB0cnVlO1xuICAgICAgICAgIGVsdC5fZm9yY2VfYXN5bmMgPSBmYWxzZTtcbiAgICAgICAgICBpZiAoZnJhZ21lbnQpIGVsdC5fYWxyZWFkeV9zdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgICBmbHVzaFRleHQoKTtcbiAgICAgICAgICByZXR1cm4gZWx0O1xuICAgICAgICB9KTtcbiAgICAgICAgdG9rZW5pemVyID0gc2NyaXB0X2RhdGFfc3RhdGU7XG4gICAgICAgIG9yaWdpbmFsSW5zZXJ0aW9uTW9kZSA9IHBhcnNlcjtcbiAgICAgICAgcGFyc2VyID0gdGV4dF9tb2RlO1xuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlIFwidGVtcGxhdGVcIjpcbiAgICAgICAgaW5zZXJ0SFRNTEVsZW1lbnQodmFsdWUsIGFyZzMpO1xuICAgICAgICBhZmUuaW5zZXJ0TWFya2VyKCk7XG4gICAgICAgIGZyYW1lc2V0X29rID0gZmFsc2U7XG4gICAgICAgIHBhcnNlciA9IGluX3RlbXBsYXRlX21vZGU7XG4gICAgICAgIHRlbXBsYXRlSW5zZXJ0aW9uTW9kZXMucHVzaChwYXJzZXIpO1xuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlIFwiaGVhZFwiOlxuICAgICAgICByZXR1cm47IC8vIGlnbm9yZSBpdFxuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAzOiAvLyBFTkRUQUdcbiAgICAgIHN3aXRjaCh2YWx1ZSkge1xuICAgICAgY2FzZSBcImhlYWRcIjpcbiAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgIHBhcnNlciA9IGFmdGVyX2hlYWRfbW9kZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSBcImJvZHlcIjpcbiAgICAgIGNhc2UgXCJodG1sXCI6XG4gICAgICBjYXNlIFwiYnJcIjpcbiAgICAgICAgYnJlYWs7IC8vIGhhbmRsZSB0aGVzZSBhdCB0aGUgYm90dG9tIG9mIHRoZSBmdW5jdGlvblxuICAgICAgY2FzZSBcInRlbXBsYXRlXCI6XG4gICAgICAgIGlmICghc3RhY2suY29udGFpbnMoXCJ0ZW1wbGF0ZVwiKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzdGFjay5nZW5lcmF0ZUltcGxpZWRFbmRUYWdzKG51bGwsIFwidGhvcm91Z2hcIik7XG4gICAgICAgIHN0YWNrLnBvcFRhZyhcInRlbXBsYXRlXCIpO1xuICAgICAgICBhZmUuY2xlYXJUb01hcmtlcigpO1xuICAgICAgICB0ZW1wbGF0ZUluc2VydGlvbk1vZGVzLnBvcCgpO1xuICAgICAgICByZXNldEluc2VydGlvbk1vZGUoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgLy8gaWdub3JlIGFueSBvdGhlciBlbmQgdGFnXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8vIElmIG5vdCBoYW5kbGVkIGFib3ZlXG4gICAgaW5faGVhZF9tb2RlKEVORFRBRywgXCJoZWFkXCIsIG51bGwpOyAgIC8vIHN5bnRoZXRpYyA8L2hlYWQ+XG4gICAgcGFyc2VyKHQsIHZhbHVlLCBhcmczLCBhcmc0KTsgICAvLyBUaGVuIHJlZG8gdGhpcyBvbmVcbiAgfVxuXG4gIC8vIDEzLjIuNS40LjUgVGhlIFwiaW4gaGVhZCBub3NjcmlwdFwiIGluc2VydGlvbiBtb2RlXG4gIGZ1bmN0aW9uIGluX2hlYWRfbm9zY3JpcHRfbW9kZSh0LCB2YWx1ZSwgYXJnMywgYXJnNCkge1xuICAgIHN3aXRjaCh0KSB7XG4gICAgY2FzZSA1OiAvLyBET0NUWVBFXG4gICAgICByZXR1cm47XG4gICAgY2FzZSA0OiAvLyBDT01NRU5UXG4gICAgICBpbl9oZWFkX21vZGUodCwgdmFsdWUpO1xuICAgICAgcmV0dXJuO1xuICAgIGNhc2UgMTogLy8gVEVYVFxuICAgICAgdmFyIHdzID0gdmFsdWUubWF0Y2goTEVBRElOR1dTKTtcbiAgICAgIGlmICh3cykge1xuICAgICAgICBpbl9oZWFkX21vZGUodCwgd3NbMF0pO1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLnN1YnN0cmluZyh3c1swXS5sZW5ndGgpO1xuICAgICAgfVxuICAgICAgaWYgKHZhbHVlLmxlbmd0aCA9PT0gMCkgcmV0dXJuOyAvLyBubyBtb3JlIHRleHRcbiAgICAgIGJyZWFrOyAvLyBIYW5kbGUgbm9uLXdoaXRlc3BhY2UgYmVsb3dcbiAgICBjYXNlIDI6IC8vIFRBR1xuICAgICAgc3dpdGNoKHZhbHVlKSB7XG4gICAgICBjYXNlIFwiaHRtbFwiOlxuICAgICAgICBpbl9ib2R5X21vZGUodCwgdmFsdWUsIGFyZzMsIGFyZzQpO1xuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlIFwiYmFzZWZvbnRcIjpcbiAgICAgIGNhc2UgXCJiZ3NvdW5kXCI6XG4gICAgICBjYXNlIFwibGlua1wiOlxuICAgICAgY2FzZSBcIm1ldGFcIjpcbiAgICAgIGNhc2UgXCJub2ZyYW1lc1wiOlxuICAgICAgY2FzZSBcInN0eWxlXCI6XG4gICAgICAgIGluX2hlYWRfbW9kZSh0LCB2YWx1ZSwgYXJnMyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgXCJoZWFkXCI6XG4gICAgICBjYXNlIFwibm9zY3JpcHRcIjpcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAzOiAvLyBFTkRUQUdcbiAgICAgIHN3aXRjaCh2YWx1ZSkge1xuICAgICAgY2FzZSBcIm5vc2NyaXB0XCI6XG4gICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICBwYXJzZXIgPSBpbl9oZWFkX21vZGU7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgXCJiclwiOlxuICAgICAgICBicmVhazsgIC8vIGdvZXMgdG8gdGhlIG91dGVyIGRlZmF1bHRcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybjsgLy8gaWdub3JlIG90aGVyIGVuZCB0YWdzXG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvLyBJZiBub3QgaGFuZGxlZCBhYm92ZVxuICAgIGluX2hlYWRfbm9zY3JpcHRfbW9kZShFTkRUQUcsIFwibm9zY3JpcHRcIiwgbnVsbCk7XG4gICAgcGFyc2VyKHQsIHZhbHVlLCBhcmczLCBhcmc0KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFmdGVyX2hlYWRfbW9kZSh0LCB2YWx1ZSwgYXJnMywgYXJnNCkge1xuICAgIHN3aXRjaCh0KSB7XG4gICAgY2FzZSAxOiAvLyBURVhUXG4gICAgICB2YXIgd3MgPSB2YWx1ZS5tYXRjaChMRUFESU5HV1MpO1xuICAgICAgaWYgKHdzKSB7XG4gICAgICAgIGluc2VydFRleHQod3NbMF0pO1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLnN1YnN0cmluZyh3c1swXS5sZW5ndGgpO1xuICAgICAgfVxuICAgICAgaWYgKHZhbHVlLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuICAgICAgYnJlYWs7IC8vIEhhbmRsZSBub24td2hpdGVzcGFjZSBiZWxvd1xuICAgIGNhc2UgNDogLy8gQ09NTUVOVFxuICAgICAgaW5zZXJ0Q29tbWVudCh2YWx1ZSk7XG4gICAgICByZXR1cm47XG4gICAgY2FzZSA1OiAvLyBET0NUWVBFXG4gICAgICByZXR1cm47XG4gICAgY2FzZSAyOiAvLyBUQUdcbiAgICAgIHN3aXRjaCh2YWx1ZSkge1xuICAgICAgY2FzZSBcImh0bWxcIjpcbiAgICAgICAgaW5fYm9keV9tb2RlKHQsIHZhbHVlLCBhcmczLCBhcmc0KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSBcImJvZHlcIjpcbiAgICAgICAgaW5zZXJ0SFRNTEVsZW1lbnQodmFsdWUsIGFyZzMpO1xuICAgICAgICBmcmFtZXNldF9vayA9IGZhbHNlO1xuICAgICAgICBwYXJzZXIgPSBpbl9ib2R5X21vZGU7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgXCJmcmFtZXNldFwiOlxuICAgICAgICBpbnNlcnRIVE1MRWxlbWVudCh2YWx1ZSwgYXJnMyk7XG4gICAgICAgIHBhcnNlciA9IGluX2ZyYW1lc2V0X21vZGU7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgXCJiYXNlXCI6XG4gICAgICBjYXNlIFwiYmFzZWZvbnRcIjpcbiAgICAgIGNhc2UgXCJiZ3NvdW5kXCI6XG4gICAgICBjYXNlIFwibGlua1wiOlxuICAgICAgY2FzZSBcIm1ldGFcIjpcbiAgICAgIGNhc2UgXCJub2ZyYW1lc1wiOlxuICAgICAgY2FzZSBcInNjcmlwdFwiOlxuICAgICAgY2FzZSBcInN0eWxlXCI6XG4gICAgICBjYXNlIFwidGVtcGxhdGVcIjpcbiAgICAgIGNhc2UgXCJ0aXRsZVwiOlxuICAgICAgICBzdGFjay5wdXNoKGhlYWRfZWxlbWVudF9wb2ludGVyKTtcbiAgICAgICAgaW5faGVhZF9tb2RlKFRBRywgdmFsdWUsIGFyZzMpO1xuICAgICAgICBzdGFjay5yZW1vdmVFbGVtZW50KGhlYWRfZWxlbWVudF9wb2ludGVyKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSBcImhlYWRcIjpcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAzOiAvLyBFTkRUQUdcbiAgICAgIHN3aXRjaCh2YWx1ZSkge1xuICAgICAgY2FzZSBcInRlbXBsYXRlXCI6XG4gICAgICAgIHJldHVybiBpbl9oZWFkX21vZGUodCwgdmFsdWUsIGFyZzMsIGFyZzQpO1xuICAgICAgY2FzZSBcImJvZHlcIjpcbiAgICAgIGNhc2UgXCJodG1sXCI6XG4gICAgICBjYXNlIFwiYnJcIjpcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm47ICAvLyBpZ25vcmUgYW55IG90aGVyIGVuZCB0YWdcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGFmdGVyX2hlYWRfbW9kZShUQUcsIFwiYm9keVwiLCBudWxsKTtcbiAgICBmcmFtZXNldF9vayA9IHRydWU7XG4gICAgcGFyc2VyKHQsIHZhbHVlLCBhcmczLCBhcmc0KTtcbiAgfVxuXG4gIC8vIDEzLjIuNS40LjcgVGhlIFwiaW4gYm9keVwiIGluc2VydGlvbiBtb2RlXG4gIGZ1bmN0aW9uIGluX2JvZHlfbW9kZSh0LHZhbHVlLGFyZzMsYXJnNCkge1xuICAgIHZhciBib2R5LCBpLCBub2RlLCBlbHQ7XG4gICAgc3dpdGNoKHQpIHtcbiAgICBjYXNlIDE6IC8vIFRFWFRcbiAgICAgIGlmICh0ZXh0SW5jbHVkZXNOVUwpIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKE5VTENIQVJTLCBcIlwiKTtcbiAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gSWYgYW55IG5vbi1zcGFjZSBjaGFyYWN0ZXJzXG4gICAgICBpZiAoZnJhbWVzZXRfb2sgJiYgTk9OV1MudGVzdCh2YWx1ZSkpXG4gICAgICAgIGZyYW1lc2V0X29rID0gZmFsc2U7XG4gICAgICBhZmVyZWNvbnN0cnVjdCgpO1xuICAgICAgaW5zZXJ0VGV4dCh2YWx1ZSk7XG4gICAgICByZXR1cm47XG4gICAgY2FzZSA1OiAvLyBET0NUWVBFXG4gICAgICByZXR1cm47XG4gICAgY2FzZSA0OiAvLyBDT01NRU5UXG4gICAgICBpbnNlcnRDb21tZW50KHZhbHVlKTtcbiAgICAgIHJldHVybjtcbiAgICBjYXNlIC0xOiAvLyBFT0ZcbiAgICAgIGlmICh0ZW1wbGF0ZUluc2VydGlvbk1vZGVzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gaW5fdGVtcGxhdGVfbW9kZSh0KTtcbiAgICAgIH1cbiAgICAgIHN0b3BQYXJzaW5nKCk7XG4gICAgICByZXR1cm47XG4gICAgY2FzZSAyOiAvLyBUQUdcbiAgICAgIHN3aXRjaCh2YWx1ZSkge1xuICAgICAgY2FzZSBcImh0bWxcIjpcbiAgICAgICAgaWYgKHN0YWNrLmNvbnRhaW5zKFwidGVtcGxhdGVcIikpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdHJhbnNmZXJBdHRyaWJ1dGVzKGFyZzMsIHN0YWNrLmVsZW1lbnRzWzBdKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSBcImJhc2VcIjpcbiAgICAgIGNhc2UgXCJiYXNlZm9udFwiOlxuICAgICAgY2FzZSBcImJnc291bmRcIjpcbiAgICAgIGNhc2UgXCJsaW5rXCI6XG4gICAgICBjYXNlIFwibWV0YVwiOlxuICAgICAgY2FzZSBcIm5vZnJhbWVzXCI6XG4gICAgICBjYXNlIFwic2NyaXB0XCI6XG4gICAgICBjYXNlIFwic3R5bGVcIjpcbiAgICAgIGNhc2UgXCJ0ZW1wbGF0ZVwiOlxuICAgICAgY2FzZSBcInRpdGxlXCI6XG4gICAgICAgIGluX2hlYWRfbW9kZShUQUcsIHZhbHVlLCBhcmczKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSBcImJvZHlcIjpcbiAgICAgICAgYm9keSA9IHN0YWNrLmVsZW1lbnRzWzFdO1xuICAgICAgICBpZiAoIWJvZHkgfHwgIShib2R5IGluc3RhbmNlb2YgaW1wbC5IVE1MQm9keUVsZW1lbnQpIHx8XG4gICAgICAgICAgICBzdGFjay5jb250YWlucyhcInRlbXBsYXRlXCIpKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgZnJhbWVzZXRfb2sgPSBmYWxzZTtcbiAgICAgICAgdHJhbnNmZXJBdHRyaWJ1dGVzKGFyZzMsIGJvZHkpO1xuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlIFwiZnJhbWVzZXRcIjpcbiAgICAgICAgaWYgKCFmcmFtZXNldF9vaykgcmV0dXJuO1xuICAgICAgICBib2R5ID0gc3RhY2suZWxlbWVudHNbMV07XG4gICAgICAgIGlmICghYm9keSB8fCAhKGJvZHkgaW5zdGFuY2VvZiBpbXBsLkhUTUxCb2R5RWxlbWVudCkpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoYm9keS5wYXJlbnROb2RlKSBib2R5LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoYm9keSk7XG4gICAgICAgIHdoaWxlKCEoc3RhY2sudG9wIGluc3RhbmNlb2YgaW1wbC5IVE1MSHRtbEVsZW1lbnQpKVxuICAgICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICBpbnNlcnRIVE1MRWxlbWVudCh2YWx1ZSwgYXJnMyk7XG4gICAgICAgIHBhcnNlciA9IGluX2ZyYW1lc2V0X21vZGU7XG4gICAgICAgIHJldHVybjtcblxuICAgICAgY2FzZSBcImFkZHJlc3NcIjpcbiAgICAgIGNhc2UgXCJhcnRpY2xlXCI6XG4gICAgICBjYXNlIFwiYXNpZGVcIjpcbiAgICAgIGNhc2UgXCJibG9ja3F1b3RlXCI6XG4gICAgICBjYXNlIFwiY2VudGVyXCI6XG4gICAgICBjYXNlIFwiZGV0YWlsc1wiOlxuICAgICAgY2FzZSBcImRpYWxvZ1wiOlxuICAgICAgY2FzZSBcImRpclwiOlxuICAgICAgY2FzZSBcImRpdlwiOlxuICAgICAgY2FzZSBcImRsXCI6XG4gICAgICBjYXNlIFwiZmllbGRzZXRcIjpcbiAgICAgIGNhc2UgXCJmaWdjYXB0aW9uXCI6XG4gICAgICBjYXNlIFwiZmlndXJlXCI6XG4gICAgICBjYXNlIFwiZm9vdGVyXCI6XG4gICAgICBjYXNlIFwiaGVhZGVyXCI6XG4gICAgICBjYXNlIFwiaGdyb3VwXCI6XG4gICAgICBjYXNlIFwibWFpblwiOlxuICAgICAgY2FzZSBcIm5hdlwiOlxuICAgICAgY2FzZSBcIm9sXCI6XG4gICAgICBjYXNlIFwicFwiOlxuICAgICAgY2FzZSBcInNlY3Rpb25cIjpcbiAgICAgIGNhc2UgXCJzdW1tYXJ5XCI6XG4gICAgICBjYXNlIFwidWxcIjpcbiAgICAgICAgaWYgKHN0YWNrLmluQnV0dG9uU2NvcGUoXCJwXCIpKSBpbl9ib2R5X21vZGUoRU5EVEFHLCBcInBcIik7XG4gICAgICAgIGluc2VydEhUTUxFbGVtZW50KHZhbHVlLCBhcmczKTtcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgICBjYXNlIFwibWVudVwiOlxuICAgICAgICBpZiAoc3RhY2suaW5CdXR0b25TY29wZShcInBcIikpIGluX2JvZHlfbW9kZShFTkRUQUcsIFwicFwiKTtcbiAgICAgICAgaWYgKGlzQShzdGFjay50b3AsICdtZW51aXRlbScpKSB7XG4gICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgIH1cbiAgICAgICAgaW5zZXJ0SFRNTEVsZW1lbnQodmFsdWUsIGFyZzMpO1xuICAgICAgICByZXR1cm47XG5cbiAgICAgIGNhc2UgXCJoMVwiOlxuICAgICAgY2FzZSBcImgyXCI6XG4gICAgICBjYXNlIFwiaDNcIjpcbiAgICAgIGNhc2UgXCJoNFwiOlxuICAgICAgY2FzZSBcImg1XCI6XG4gICAgICBjYXNlIFwiaDZcIjpcbiAgICAgICAgaWYgKHN0YWNrLmluQnV0dG9uU2NvcGUoXCJwXCIpKSBpbl9ib2R5X21vZGUoRU5EVEFHLCBcInBcIik7XG4gICAgICAgIGlmIChzdGFjay50b3AgaW5zdGFuY2VvZiBpbXBsLkhUTUxIZWFkaW5nRWxlbWVudClcbiAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgaW5zZXJ0SFRNTEVsZW1lbnQodmFsdWUsIGFyZzMpO1xuICAgICAgICByZXR1cm47XG5cbiAgICAgIGNhc2UgXCJwcmVcIjpcbiAgICAgIGNhc2UgXCJsaXN0aW5nXCI6XG4gICAgICAgIGlmIChzdGFjay5pbkJ1dHRvblNjb3BlKFwicFwiKSkgaW5fYm9keV9tb2RlKEVORFRBRywgXCJwXCIpO1xuICAgICAgICBpbnNlcnRIVE1MRWxlbWVudCh2YWx1ZSwgYXJnMyk7XG4gICAgICAgIGlnbm9yZV9saW5lZmVlZCA9IHRydWU7XG4gICAgICAgIGZyYW1lc2V0X29rID0gZmFsc2U7XG4gICAgICAgIHJldHVybjtcblxuICAgICAgY2FzZSBcImZvcm1cIjpcbiAgICAgICAgaWYgKGZvcm1fZWxlbWVudF9wb2ludGVyICYmICFzdGFjay5jb250YWlucyhcInRlbXBsYXRlXCIpKSByZXR1cm47XG4gICAgICAgIGlmIChzdGFjay5pbkJ1dHRvblNjb3BlKFwicFwiKSkgaW5fYm9keV9tb2RlKEVORFRBRywgXCJwXCIpO1xuICAgICAgICBlbHQgPSBpbnNlcnRIVE1MRWxlbWVudCh2YWx1ZSwgYXJnMyk7XG4gICAgICAgIGlmICghc3RhY2suY29udGFpbnMoXCJ0ZW1wbGF0ZVwiKSlcbiAgICAgICAgICBmb3JtX2VsZW1lbnRfcG9pbnRlciA9IGVsdDtcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgICBjYXNlIFwibGlcIjpcbiAgICAgICAgZnJhbWVzZXRfb2sgPSBmYWxzZTtcbiAgICAgICAgZm9yKGkgPSBzdGFjay5lbGVtZW50cy5sZW5ndGgtMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICBub2RlID0gc3RhY2suZWxlbWVudHNbaV07XG4gICAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBpbXBsLkhUTUxMSUVsZW1lbnQpIHtcbiAgICAgICAgICAgIGluX2JvZHlfbW9kZShFTkRUQUcsIFwibGlcIik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzQShub2RlLCBzcGVjaWFsU2V0KSAmJiAhaXNBKG5vZGUsIGFkZHJlc3NkaXZwU2V0KSlcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGFjay5pbkJ1dHRvblNjb3BlKFwicFwiKSkgaW5fYm9keV9tb2RlKEVORFRBRywgXCJwXCIpO1xuICAgICAgICBpbnNlcnRIVE1MRWxlbWVudCh2YWx1ZSwgYXJnMyk7XG4gICAgICAgIHJldHVybjtcblxuICAgICAgY2FzZSBcImRkXCI6XG4gICAgICBjYXNlIFwiZHRcIjpcbiAgICAgICAgZnJhbWVzZXRfb2sgPSBmYWxzZTtcbiAgICAgICAgZm9yKGkgPSBzdGFjay5lbGVtZW50cy5sZW5ndGgtMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICBub2RlID0gc3RhY2suZWxlbWVudHNbaV07XG4gICAgICAgICAgaWYgKGlzQShub2RlLCBkZGR0U2V0KSkge1xuICAgICAgICAgICAgaW5fYm9keV9tb2RlKEVORFRBRywgbm9kZS5sb2NhbE5hbWUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc0Eobm9kZSwgc3BlY2lhbFNldCkgJiYgIWlzQShub2RlLCBhZGRyZXNzZGl2cFNldCkpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhY2suaW5CdXR0b25TY29wZShcInBcIikpIGluX2JvZHlfbW9kZShFTkRUQUcsIFwicFwiKTtcbiAgICAgICAgaW5zZXJ0SFRNTEVsZW1lbnQodmFsdWUsIGFyZzMpO1xuICAgICAgICByZXR1cm47XG5cbiAgICAgIGNhc2UgXCJwbGFpbnRleHRcIjpcbiAgICAgICAgaWYgKHN0YWNrLmluQnV0dG9uU2NvcGUoXCJwXCIpKSBpbl9ib2R5X21vZGUoRU5EVEFHLCBcInBcIik7XG4gICAgICAgIGluc2VydEhUTUxFbGVtZW50KHZhbHVlLCBhcmczKTtcbiAgICAgICAgdG9rZW5pemVyID0gcGxhaW50ZXh0X3N0YXRlO1xuICAgICAgICByZXR1cm47XG5cbiAgICAgIGNhc2UgXCJidXR0b25cIjpcbiAgICAgICAgaWYgKHN0YWNrLmluU2NvcGUoXCJidXR0b25cIikpIHtcbiAgICAgICAgICBpbl9ib2R5X21vZGUoRU5EVEFHLCBcImJ1dHRvblwiKTtcbiAgICAgICAgICBwYXJzZXIodCwgdmFsdWUsIGFyZzMsIGFyZzQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGFmZXJlY29uc3RydWN0KCk7XG4gICAgICAgICAgaW5zZXJ0SFRNTEVsZW1lbnQodmFsdWUsIGFyZzMpO1xuICAgICAgICAgIGZyYW1lc2V0X29rID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuXG4gICAgICBjYXNlIFwiYVwiOlxuICAgICAgICB2YXIgYWN0aXZlRWxlbWVudCA9IGFmZS5maW5kRWxlbWVudEJ5VGFnKFwiYVwiKTtcbiAgICAgICAgaWYgKGFjdGl2ZUVsZW1lbnQpIHtcbiAgICAgICAgICBpbl9ib2R5X21vZGUoRU5EVEFHLCB2YWx1ZSk7XG4gICAgICAgICAgYWZlLnJlbW92ZShhY3RpdmVFbGVtZW50KTtcbiAgICAgICAgICBzdGFjay5yZW1vdmVFbGVtZW50KGFjdGl2ZUVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgXCJiXCI6XG4gICAgICBjYXNlIFwiYmlnXCI6XG4gICAgICBjYXNlIFwiY29kZVwiOlxuICAgICAgY2FzZSBcImVtXCI6XG4gICAgICBjYXNlIFwiZm9udFwiOlxuICAgICAgY2FzZSBcImlcIjpcbiAgICAgIGNhc2UgXCJzXCI6XG4gICAgICBjYXNlIFwic21hbGxcIjpcbiAgICAgIGNhc2UgXCJzdHJpa2VcIjpcbiAgICAgIGNhc2UgXCJzdHJvbmdcIjpcbiAgICAgIGNhc2UgXCJ0dFwiOlxuICAgICAgY2FzZSBcInVcIjpcbiAgICAgICAgYWZlcmVjb25zdHJ1Y3QoKTtcbiAgICAgICAgYWZlLnB1c2goaW5zZXJ0SFRNTEVsZW1lbnQodmFsdWUsYXJnMyksIGFyZzMpO1xuICAgICAgICByZXR1cm47XG5cbiAgICAgIGNhc2UgXCJub2JyXCI6XG4gICAgICAgIGFmZXJlY29uc3RydWN0KCk7XG5cbiAgICAgICAgaWYgKHN0YWNrLmluU2NvcGUodmFsdWUpKSB7XG4gICAgICAgICAgaW5fYm9keV9tb2RlKEVORFRBRywgdmFsdWUpO1xuICAgICAgICAgIGFmZXJlY29uc3RydWN0KCk7XG4gICAgICAgIH1cbiAgICAgICAgYWZlLnB1c2goaW5zZXJ0SFRNTEVsZW1lbnQodmFsdWUsYXJnMyksIGFyZzMpO1xuICAgICAgICByZXR1cm47XG5cbiAgICAgIGNhc2UgXCJhcHBsZXRcIjpcbiAgICAgIGNhc2UgXCJtYXJxdWVlXCI6XG4gICAgICBjYXNlIFwib2JqZWN0XCI6XG4gICAgICAgIGFmZXJlY29uc3RydWN0KCk7XG4gICAgICAgIGluc2VydEhUTUxFbGVtZW50KHZhbHVlLGFyZzMpO1xuICAgICAgICBhZmUuaW5zZXJ0TWFya2VyKCk7XG4gICAgICAgIGZyYW1lc2V0X29rID0gZmFsc2U7XG4gICAgICAgIHJldHVybjtcblxuICAgICAgY2FzZSBcInRhYmxlXCI6XG4gICAgICAgIGlmICghZG9jLl9xdWlya3MgJiYgc3RhY2suaW5CdXR0b25TY29wZShcInBcIikpIHtcbiAgICAgICAgICBpbl9ib2R5X21vZGUoRU5EVEFHLCBcInBcIik7XG4gICAgICAgIH1cbiAgICAgICAgaW5zZXJ0SFRNTEVsZW1lbnQodmFsdWUsYXJnMyk7XG4gICAgICAgIGZyYW1lc2V0X29rID0gZmFsc2U7XG4gICAgICAgIHBhcnNlciA9IGluX3RhYmxlX21vZGU7XG4gICAgICAgIHJldHVybjtcblxuICAgICAgY2FzZSBcImFyZWFcIjpcbiAgICAgIGNhc2UgXCJiclwiOlxuICAgICAgY2FzZSBcImVtYmVkXCI6XG4gICAgICBjYXNlIFwiaW1nXCI6XG4gICAgICBjYXNlIFwia2V5Z2VuXCI6XG4gICAgICBjYXNlIFwid2JyXCI6XG4gICAgICAgIGFmZXJlY29uc3RydWN0KCk7XG4gICAgICAgIGluc2VydEhUTUxFbGVtZW50KHZhbHVlLGFyZzMpO1xuICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgZnJhbWVzZXRfb2sgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgICBjYXNlIFwiaW5wdXRcIjpcbiAgICAgICAgYWZlcmVjb25zdHJ1Y3QoKTtcbiAgICAgICAgZWx0ID0gaW5zZXJ0SFRNTEVsZW1lbnQodmFsdWUsYXJnMyk7XG4gICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICB2YXIgdHlwZSA9IGVsdC5nZXRBdHRyaWJ1dGUoXCJ0eXBlXCIpO1xuICAgICAgICBpZiAoIXR5cGUgfHwgdHlwZS50b0xvd2VyQ2FzZSgpICE9PSBcImhpZGRlblwiKVxuICAgICAgICAgIGZyYW1lc2V0X29rID0gZmFsc2U7XG4gICAgICAgIHJldHVybjtcblxuICAgICAgY2FzZSBcInBhcmFtXCI6XG4gICAgICBjYXNlIFwic291cmNlXCI6XG4gICAgICBjYXNlIFwidHJhY2tcIjpcbiAgICAgICAgaW5zZXJ0SFRNTEVsZW1lbnQodmFsdWUsYXJnMyk7XG4gICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICByZXR1cm47XG5cbiAgICAgIGNhc2UgXCJoclwiOlxuICAgICAgICBpZiAoc3RhY2suaW5CdXR0b25TY29wZShcInBcIikpIGluX2JvZHlfbW9kZShFTkRUQUcsIFwicFwiKTtcbiAgICAgICAgaWYgKGlzQShzdGFjay50b3AsICdtZW51aXRlbScpKSB7XG4gICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgIH1cbiAgICAgICAgaW5zZXJ0SFRNTEVsZW1lbnQodmFsdWUsYXJnMyk7XG4gICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICBmcmFtZXNldF9vayA9IGZhbHNlO1xuICAgICAgICByZXR1cm47XG5cbiAgICAgIGNhc2UgXCJpbWFnZVwiOlxuICAgICAgICBpbl9ib2R5X21vZGUoVEFHLCBcImltZ1wiLCBhcmczLCBhcmc0KTtcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgICBjYXNlIFwidGV4dGFyZWFcIjpcbiAgICAgICAgaW5zZXJ0SFRNTEVsZW1lbnQodmFsdWUsYXJnMyk7XG4gICAgICAgIGlnbm9yZV9saW5lZmVlZCA9IHRydWU7XG4gICAgICAgIGZyYW1lc2V0X29rID0gZmFsc2U7XG4gICAgICAgIHRva2VuaXplciA9IHJjZGF0YV9zdGF0ZTtcbiAgICAgICAgb3JpZ2luYWxJbnNlcnRpb25Nb2RlID0gcGFyc2VyO1xuICAgICAgICBwYXJzZXIgPSB0ZXh0X21vZGU7XG4gICAgICAgIHJldHVybjtcblxuICAgICAgY2FzZSBcInhtcFwiOlxuICAgICAgICBpZiAoc3RhY2suaW5CdXR0b25TY29wZShcInBcIikpIGluX2JvZHlfbW9kZShFTkRUQUcsIFwicFwiKTtcbiAgICAgICAgYWZlcmVjb25zdHJ1Y3QoKTtcbiAgICAgICAgZnJhbWVzZXRfb2sgPSBmYWxzZTtcbiAgICAgICAgcGFyc2VSYXdUZXh0KHZhbHVlLCBhcmczKTtcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgICBjYXNlIFwiaWZyYW1lXCI6XG4gICAgICAgIGZyYW1lc2V0X29rID0gZmFsc2U7XG4gICAgICAgIHBhcnNlUmF3VGV4dCh2YWx1ZSwgYXJnMyk7XG4gICAgICAgIHJldHVybjtcblxuICAgICAgY2FzZSBcIm5vZW1iZWRcIjpcbiAgICAgICAgcGFyc2VSYXdUZXh0KHZhbHVlLGFyZzMpO1xuICAgICAgICByZXR1cm47XG5cbiAgICAgIGNhc2UgXCJub3NjcmlwdFwiOlxuICAgICAgICBpZiAoc2NyaXB0aW5nX2VuYWJsZWQpIHtcbiAgICAgICAgICBwYXJzZVJhd1RleHQodmFsdWUsYXJnMyk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrOyAgLy8gWFhYIE90aGVyd2lzZSB0cmVhdCBpdCBhcyBhbnkgb3RoZXIgb3BlbiB0YWc/XG5cbiAgICAgIGNhc2UgXCJzZWxlY3RcIjpcbiAgICAgICAgYWZlcmVjb25zdHJ1Y3QoKTtcbiAgICAgICAgaW5zZXJ0SFRNTEVsZW1lbnQodmFsdWUsYXJnMyk7XG4gICAgICAgIGZyYW1lc2V0X29rID0gZmFsc2U7XG4gICAgICAgIGlmIChwYXJzZXIgPT09IGluX3RhYmxlX21vZGUgfHxcbiAgICAgICAgICBwYXJzZXIgPT09IGluX2NhcHRpb25fbW9kZSB8fFxuICAgICAgICAgIHBhcnNlciA9PT0gaW5fdGFibGVfYm9keV9tb2RlIHx8XG4gICAgICAgICAgcGFyc2VyID09PSBpbl9yb3dfbW9kZSB8fFxuICAgICAgICAgIHBhcnNlciA9PT0gaW5fY2VsbF9tb2RlKVxuICAgICAgICAgIHBhcnNlciA9IGluX3NlbGVjdF9pbl90YWJsZV9tb2RlO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgcGFyc2VyID0gaW5fc2VsZWN0X21vZGU7XG4gICAgICAgIHJldHVybjtcblxuICAgICAgY2FzZSBcIm9wdGdyb3VwXCI6XG4gICAgICBjYXNlIFwib3B0aW9uXCI6XG4gICAgICAgIGlmIChzdGFjay50b3AgaW5zdGFuY2VvZiBpbXBsLkhUTUxPcHRpb25FbGVtZW50KSB7XG4gICAgICAgICAgaW5fYm9keV9tb2RlKEVORFRBRywgXCJvcHRpb25cIik7XG4gICAgICAgIH1cbiAgICAgICAgYWZlcmVjb25zdHJ1Y3QoKTtcbiAgICAgICAgaW5zZXJ0SFRNTEVsZW1lbnQodmFsdWUsYXJnMyk7XG4gICAgICAgIHJldHVybjtcblxuICAgICAgY2FzZSBcIm1lbnVpdGVtXCI6XG4gICAgICAgIGlmIChpc0Eoc3RhY2sudG9wLCAnbWVudWl0ZW0nKSkge1xuICAgICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICB9XG4gICAgICAgIGFmZXJlY29uc3RydWN0KCk7XG4gICAgICAgIGluc2VydEhUTUxFbGVtZW50KHZhbHVlLCBhcmczKTtcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgICBjYXNlIFwicmJcIjpcbiAgICAgIGNhc2UgXCJydGNcIjpcbiAgICAgICAgaWYgKHN0YWNrLmluU2NvcGUoXCJydWJ5XCIpKSB7XG4gICAgICAgICAgc3RhY2suZ2VuZXJhdGVJbXBsaWVkRW5kVGFncygpO1xuICAgICAgICB9XG4gICAgICAgIGluc2VydEhUTUxFbGVtZW50KHZhbHVlLGFyZzMpO1xuICAgICAgICByZXR1cm47XG5cbiAgICAgIGNhc2UgXCJycFwiOlxuICAgICAgY2FzZSBcInJ0XCI6XG4gICAgICAgIGlmIChzdGFjay5pblNjb3BlKFwicnVieVwiKSkge1xuICAgICAgICAgIHN0YWNrLmdlbmVyYXRlSW1wbGllZEVuZFRhZ3MoXCJydGNcIik7XG4gICAgICAgIH1cbiAgICAgICAgaW5zZXJ0SFRNTEVsZW1lbnQodmFsdWUsYXJnMyk7XG4gICAgICAgIHJldHVybjtcblxuICAgICAgY2FzZSBcIm1hdGhcIjpcbiAgICAgICAgYWZlcmVjb25zdHJ1Y3QoKTtcbiAgICAgICAgYWRqdXN0TWF0aE1MQXR0cmlidXRlcyhhcmczKTtcbiAgICAgICAgYWRqdXN0Rm9yZWlnbkF0dHJpYnV0ZXMoYXJnMyk7XG4gICAgICAgIGluc2VydEZvcmVpZ25FbGVtZW50KHZhbHVlLCBhcmczLCBOQU1FU1BBQ0UuTUFUSE1MKTtcbiAgICAgICAgaWYgKGFyZzQpIC8vIHNlbGYtY2xvc2luZyBmbGFnXG4gICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgIHJldHVybjtcblxuICAgICAgY2FzZSBcInN2Z1wiOlxuICAgICAgICBhZmVyZWNvbnN0cnVjdCgpO1xuICAgICAgICBhZGp1c3RTVkdBdHRyaWJ1dGVzKGFyZzMpO1xuICAgICAgICBhZGp1c3RGb3JlaWduQXR0cmlidXRlcyhhcmczKTtcbiAgICAgICAgaW5zZXJ0Rm9yZWlnbkVsZW1lbnQodmFsdWUsIGFyZzMsIE5BTUVTUEFDRS5TVkcpO1xuICAgICAgICBpZiAoYXJnNCkgLy8gc2VsZi1jbG9zaW5nIGZsYWdcbiAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgICBjYXNlIFwiY2FwdGlvblwiOlxuICAgICAgY2FzZSBcImNvbFwiOlxuICAgICAgY2FzZSBcImNvbGdyb3VwXCI6XG4gICAgICBjYXNlIFwiZnJhbWVcIjpcbiAgICAgIGNhc2UgXCJoZWFkXCI6XG4gICAgICBjYXNlIFwidGJvZHlcIjpcbiAgICAgIGNhc2UgXCJ0ZFwiOlxuICAgICAgY2FzZSBcInRmb290XCI6XG4gICAgICBjYXNlIFwidGhcIjpcbiAgICAgIGNhc2UgXCJ0aGVhZFwiOlxuICAgICAgY2FzZSBcInRyXCI6XG4gICAgICAgIC8vIElnbm9yZSB0YWJsZSB0YWdzIGlmIHdlJ3JlIG5vdCBpbl90YWJsZSBtb2RlXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gSGFuZGxlIGFueSBvdGhlciBzdGFydCB0YWcgaGVyZVxuICAgICAgLy8gKGFuZCBhbHNvIG5vc2NyaXB0IHRhZ3Mgd2hlbiBzY3JpcHRpbmcgaXMgZGlzYWJsZWQpXG4gICAgICBhZmVyZWNvbnN0cnVjdCgpO1xuICAgICAgaW5zZXJ0SFRNTEVsZW1lbnQodmFsdWUsYXJnMyk7XG4gICAgICByZXR1cm47XG5cbiAgICBjYXNlIDM6IC8vIEVORFRBR1xuICAgICAgc3dpdGNoKHZhbHVlKSB7XG4gICAgICBjYXNlIFwidGVtcGxhdGVcIjpcbiAgICAgICAgaW5faGVhZF9tb2RlKEVORFRBRywgdmFsdWUsIGFyZzMpO1xuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlIFwiYm9keVwiOlxuICAgICAgICBpZiAoIXN0YWNrLmluU2NvcGUoXCJib2R5XCIpKSByZXR1cm47XG4gICAgICAgIHBhcnNlciA9IGFmdGVyX2JvZHlfbW9kZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSBcImh0bWxcIjpcbiAgICAgICAgaWYgKCFzdGFjay5pblNjb3BlKFwiYm9keVwiKSkgcmV0dXJuO1xuICAgICAgICBwYXJzZXIgPSBhZnRlcl9ib2R5X21vZGU7XG4gICAgICAgIHBhcnNlcih0LCB2YWx1ZSwgYXJnMyk7XG4gICAgICAgIHJldHVybjtcblxuICAgICAgY2FzZSBcImFkZHJlc3NcIjpcbiAgICAgIGNhc2UgXCJhcnRpY2xlXCI6XG4gICAgICBjYXNlIFwiYXNpZGVcIjpcbiAgICAgIGNhc2UgXCJibG9ja3F1b3RlXCI6XG4gICAgICBjYXNlIFwiYnV0dG9uXCI6XG4gICAgICBjYXNlIFwiY2VudGVyXCI6XG4gICAgICBjYXNlIFwiZGV0YWlsc1wiOlxuICAgICAgY2FzZSBcImRpYWxvZ1wiOlxuICAgICAgY2FzZSBcImRpclwiOlxuICAgICAgY2FzZSBcImRpdlwiOlxuICAgICAgY2FzZSBcImRsXCI6XG4gICAgICBjYXNlIFwiZmllbGRzZXRcIjpcbiAgICAgIGNhc2UgXCJmaWdjYXB0aW9uXCI6XG4gICAgICBjYXNlIFwiZmlndXJlXCI6XG4gICAgICBjYXNlIFwiZm9vdGVyXCI6XG4gICAgICBjYXNlIFwiaGVhZGVyXCI6XG4gICAgICBjYXNlIFwiaGdyb3VwXCI6XG4gICAgICBjYXNlIFwibGlzdGluZ1wiOlxuICAgICAgY2FzZSBcIm1haW5cIjpcbiAgICAgIGNhc2UgXCJtZW51XCI6XG4gICAgICBjYXNlIFwibmF2XCI6XG4gICAgICBjYXNlIFwib2xcIjpcbiAgICAgIGNhc2UgXCJwcmVcIjpcbiAgICAgIGNhc2UgXCJzZWN0aW9uXCI6XG4gICAgICBjYXNlIFwic3VtbWFyeVwiOlxuICAgICAgY2FzZSBcInVsXCI6XG4gICAgICAgIC8vIElnbm9yZSBpZiB0aGVyZSBpcyBub3QgYSBtYXRjaGluZyBvcGVuIHRhZ1xuICAgICAgICBpZiAoIXN0YWNrLmluU2NvcGUodmFsdWUpKSByZXR1cm47XG4gICAgICAgIHN0YWNrLmdlbmVyYXRlSW1wbGllZEVuZFRhZ3MoKTtcbiAgICAgICAgc3RhY2sucG9wVGFnKHZhbHVlKTtcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgICBjYXNlIFwiZm9ybVwiOlxuICAgICAgICBpZiAoIXN0YWNrLmNvbnRhaW5zKFwidGVtcGxhdGVcIikpIHtcbiAgICAgICAgICB2YXIgb3BlbmZvcm0gPSBmb3JtX2VsZW1lbnRfcG9pbnRlcjtcbiAgICAgICAgICBmb3JtX2VsZW1lbnRfcG9pbnRlciA9IG51bGw7XG4gICAgICAgICAgaWYgKCFvcGVuZm9ybSB8fCAhc3RhY2suZWxlbWVudEluU2NvcGUob3BlbmZvcm0pKSByZXR1cm47XG4gICAgICAgICAgc3RhY2suZ2VuZXJhdGVJbXBsaWVkRW5kVGFncygpO1xuICAgICAgICAgIHN0YWNrLnJlbW92ZUVsZW1lbnQob3BlbmZvcm0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICghc3RhY2suaW5TY29wZShcImZvcm1cIikpIHJldHVybjtcbiAgICAgICAgICBzdGFjay5nZW5lcmF0ZUltcGxpZWRFbmRUYWdzKCk7XG4gICAgICAgICAgc3RhY2sucG9wVGFnKFwiZm9ybVwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG5cbiAgICAgIGNhc2UgXCJwXCI6XG4gICAgICAgIGlmICghc3RhY2suaW5CdXR0b25TY29wZSh2YWx1ZSkpIHtcbiAgICAgICAgICBpbl9ib2R5X21vZGUoVEFHLCB2YWx1ZSwgbnVsbCk7XG4gICAgICAgICAgcGFyc2VyKHQsIHZhbHVlLCBhcmczLCBhcmc0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBzdGFjay5nZW5lcmF0ZUltcGxpZWRFbmRUYWdzKHZhbHVlKTtcbiAgICAgICAgICBzdGFjay5wb3BUYWcodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcblxuICAgICAgY2FzZSBcImxpXCI6XG4gICAgICAgIGlmICghc3RhY2suaW5MaXN0SXRlbVNjb3BlKHZhbHVlKSkgcmV0dXJuO1xuICAgICAgICBzdGFjay5nZW5lcmF0ZUltcGxpZWRFbmRUYWdzKHZhbHVlKTtcbiAgICAgICAgc3RhY2sucG9wVGFnKHZhbHVlKTtcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgICBjYXNlIFwiZGRcIjpcbiAgICAgIGNhc2UgXCJkdFwiOlxuICAgICAgICBpZiAoIXN0YWNrLmluU2NvcGUodmFsdWUpKSByZXR1cm47XG4gICAgICAgIHN0YWNrLmdlbmVyYXRlSW1wbGllZEVuZFRhZ3ModmFsdWUpO1xuICAgICAgICBzdGFjay5wb3BUYWcodmFsdWUpO1xuICAgICAgICByZXR1cm47XG5cbiAgICAgIGNhc2UgXCJoMVwiOlxuICAgICAgY2FzZSBcImgyXCI6XG4gICAgICBjYXNlIFwiaDNcIjpcbiAgICAgIGNhc2UgXCJoNFwiOlxuICAgICAgY2FzZSBcImg1XCI6XG4gICAgICBjYXNlIFwiaDZcIjpcbiAgICAgICAgaWYgKCFzdGFjay5lbGVtZW50VHlwZUluU2NvcGUoaW1wbC5IVE1MSGVhZGluZ0VsZW1lbnQpKSByZXR1cm47XG4gICAgICAgIHN0YWNrLmdlbmVyYXRlSW1wbGllZEVuZFRhZ3MoKTtcbiAgICAgICAgc3RhY2sucG9wRWxlbWVudFR5cGUoaW1wbC5IVE1MSGVhZGluZ0VsZW1lbnQpO1xuICAgICAgICByZXR1cm47XG5cbiAgICAgIGNhc2UgXCJzYXJjYXNtXCI6XG4gICAgICAgIC8vIFRha2UgYSBkZWVwIGJyZWF0aCwgYW5kIHRoZW46XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIFwiYVwiOlxuICAgICAgY2FzZSBcImJcIjpcbiAgICAgIGNhc2UgXCJiaWdcIjpcbiAgICAgIGNhc2UgXCJjb2RlXCI6XG4gICAgICBjYXNlIFwiZW1cIjpcbiAgICAgIGNhc2UgXCJmb250XCI6XG4gICAgICBjYXNlIFwiaVwiOlxuICAgICAgY2FzZSBcIm5vYnJcIjpcbiAgICAgIGNhc2UgXCJzXCI6XG4gICAgICBjYXNlIFwic21hbGxcIjpcbiAgICAgIGNhc2UgXCJzdHJpa2VcIjpcbiAgICAgIGNhc2UgXCJzdHJvbmdcIjpcbiAgICAgIGNhc2UgXCJ0dFwiOlxuICAgICAgY2FzZSBcInVcIjpcbiAgICAgICAgdmFyIHJlc3VsdCA9IGFkb3B0aW9uQWdlbmN5KHZhbHVlKTtcbiAgICAgICAgaWYgKHJlc3VsdCkgcmV0dXJuOyAgLy8gSWYgd2UgZGlkIHNvbWV0aGluZyB3ZSdyZSBkb25lXG4gICAgICAgIGJyZWFrOyAgICAgICAgIC8vIEdvIHRvIHRoZSBcImFueSBvdGhlciBlbmQgdGFnXCIgY2FzZVxuXG4gICAgICBjYXNlIFwiYXBwbGV0XCI6XG4gICAgICBjYXNlIFwibWFycXVlZVwiOlxuICAgICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgICBpZiAoIXN0YWNrLmluU2NvcGUodmFsdWUpKSByZXR1cm47XG4gICAgICAgIHN0YWNrLmdlbmVyYXRlSW1wbGllZEVuZFRhZ3MoKTtcbiAgICAgICAgc3RhY2sucG9wVGFnKHZhbHVlKTtcbiAgICAgICAgYWZlLmNsZWFyVG9NYXJrZXIoKTtcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgICBjYXNlIFwiYnJcIjpcbiAgICAgICAgaW5fYm9keV9tb2RlKFRBRywgdmFsdWUsIG51bGwpOyAgLy8gVHVybiA8L2JyPiBpbnRvIDxicj5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBBbnkgb3RoZXIgZW5kIHRhZyBnb2VzIGhlcmVcbiAgICAgIGZvcihpID0gc3RhY2suZWxlbWVudHMubGVuZ3RoLTE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIG5vZGUgPSBzdGFjay5lbGVtZW50c1tpXTtcbiAgICAgICAgaWYgKGlzQShub2RlLCB2YWx1ZSkpIHtcbiAgICAgICAgICBzdGFjay5nZW5lcmF0ZUltcGxpZWRFbmRUYWdzKHZhbHVlKTtcbiAgICAgICAgICBzdGFjay5wb3BFbGVtZW50KG5vZGUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzQShub2RlLCBzcGVjaWFsU2V0KSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdGV4dF9tb2RlKHQsIHZhbHVlLCBhcmczLCBhcmc0KSB7XG4gICAgc3dpdGNoKHQpIHtcbiAgICBjYXNlIDE6IC8vIFRFWFRcbiAgICAgIGluc2VydFRleHQodmFsdWUpO1xuICAgICAgcmV0dXJuO1xuICAgIGNhc2UgLTE6IC8vIEVPRlxuICAgICAgaWYgKHN0YWNrLnRvcCBpbnN0YW5jZW9mIGltcGwuSFRNTFNjcmlwdEVsZW1lbnQpXG4gICAgICAgIHN0YWNrLnRvcC5fYWxyZWFkeV9zdGFydGVkID0gdHJ1ZTtcbiAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgcGFyc2VyID0gb3JpZ2luYWxJbnNlcnRpb25Nb2RlO1xuICAgICAgcGFyc2VyKHQpO1xuICAgICAgcmV0dXJuO1xuICAgIGNhc2UgMzogLy8gRU5EVEFHXG4gICAgICBpZiAodmFsdWUgPT09IFwic2NyaXB0XCIpIHtcbiAgICAgICAgaGFuZGxlU2NyaXB0RW5kKCk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgIHBhcnNlciA9IG9yaWdpbmFsSW5zZXJ0aW9uTW9kZTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICBkZWZhdWx0OlxuICAgICAgLy8gV2Ugc2hvdWxkIG5ldmVyIGdldCBhbnkgb3RoZXIgdG9rZW4gdHlwZXNcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbl90YWJsZV9tb2RlKHQsIHZhbHVlLCBhcmczLCBhcmc0KSB7XG4gICAgZnVuY3Rpb24gZ2V0VHlwZUF0dHIoYXR0cnMpIHtcbiAgICAgIGZvcih2YXIgaSA9IDAsIG4gPSBhdHRycy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgaWYgKGF0dHJzW2ldWzBdID09PSBcInR5cGVcIilcbiAgICAgICAgICByZXR1cm4gYXR0cnNbaV1bMV0udG9Mb3dlckNhc2UoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHN3aXRjaCh0KSB7XG4gICAgY2FzZSAxOiAvLyBURVhUXG4gICAgICAvLyBYWFggdGhlIHRleHRfaW50ZWdyYXRpb25fbW9kZSBzdHVmZiBpc1xuICAgICAgLy8ganVzdCBhIGhhY2sgSSBtYWRlIHVwXG4gICAgICBpZiAodGV4dF9pbnRlZ3JhdGlvbl9tb2RlKSB7XG4gICAgICAgIGluX2JvZHlfbW9kZSh0LCB2YWx1ZSwgYXJnMywgYXJnNCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGlzQShzdGFjay50b3AsIHRhYmxlc2VjdGlvbnJvd1NldCkpIHtcbiAgICAgICAgcGVuZGluZ190YWJsZV90ZXh0ID0gW107XG4gICAgICAgIG9yaWdpbmFsSW5zZXJ0aW9uTW9kZSA9IHBhcnNlcjtcbiAgICAgICAgcGFyc2VyID0gaW5fdGFibGVfdGV4dF9tb2RlO1xuICAgICAgICBwYXJzZXIodCwgdmFsdWUsIGFyZzMsIGFyZzQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlIDQ6IC8vIENPTU1FTlRcbiAgICAgIGluc2VydENvbW1lbnQodmFsdWUpO1xuICAgICAgcmV0dXJuO1xuICAgIGNhc2UgNTogLy8gRE9DVFlQRVxuICAgICAgcmV0dXJuO1xuICAgIGNhc2UgMjogLy8gVEFHXG4gICAgICBzd2l0Y2godmFsdWUpIHtcbiAgICAgIGNhc2UgXCJjYXB0aW9uXCI6XG4gICAgICAgIHN0YWNrLmNsZWFyVG9Db250ZXh0KHRhYmxlQ29udGV4dFNldCk7XG4gICAgICAgIGFmZS5pbnNlcnRNYXJrZXIoKTtcbiAgICAgICAgaW5zZXJ0SFRNTEVsZW1lbnQodmFsdWUsYXJnMyk7XG4gICAgICAgIHBhcnNlciA9IGluX2NhcHRpb25fbW9kZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSBcImNvbGdyb3VwXCI6XG4gICAgICAgIHN0YWNrLmNsZWFyVG9Db250ZXh0KHRhYmxlQ29udGV4dFNldCk7XG4gICAgICAgIGluc2VydEhUTUxFbGVtZW50KHZhbHVlLGFyZzMpO1xuICAgICAgICBwYXJzZXIgPSBpbl9jb2x1bW5fZ3JvdXBfbW9kZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSBcImNvbFwiOlxuICAgICAgICBpbl90YWJsZV9tb2RlKFRBRywgXCJjb2xncm91cFwiLCBudWxsKTtcbiAgICAgICAgcGFyc2VyKHQsIHZhbHVlLCBhcmczLCBhcmc0KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSBcInRib2R5XCI6XG4gICAgICBjYXNlIFwidGZvb3RcIjpcbiAgICAgIGNhc2UgXCJ0aGVhZFwiOlxuICAgICAgICBzdGFjay5jbGVhclRvQ29udGV4dCh0YWJsZUNvbnRleHRTZXQpO1xuICAgICAgICBpbnNlcnRIVE1MRWxlbWVudCh2YWx1ZSxhcmczKTtcbiAgICAgICAgcGFyc2VyID0gaW5fdGFibGVfYm9keV9tb2RlO1xuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlIFwidGRcIjpcbiAgICAgIGNhc2UgXCJ0aFwiOlxuICAgICAgY2FzZSBcInRyXCI6XG4gICAgICAgIGluX3RhYmxlX21vZGUoVEFHLCBcInRib2R5XCIsIG51bGwpO1xuICAgICAgICBwYXJzZXIodCwgdmFsdWUsIGFyZzMsIGFyZzQpO1xuICAgICAgICByZXR1cm47XG5cbiAgICAgIGNhc2UgXCJ0YWJsZVwiOlxuICAgICAgICBpZiAoIXN0YWNrLmluVGFibGVTY29wZSh2YWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm47IC8vIElnbm9yZSB0aGUgdG9rZW5cbiAgICAgICAgfVxuICAgICAgICBpbl90YWJsZV9tb2RlKEVORFRBRywgdmFsdWUpO1xuICAgICAgICBwYXJzZXIodCwgdmFsdWUsIGFyZzMsIGFyZzQpO1xuICAgICAgICByZXR1cm47XG5cbiAgICAgIGNhc2UgXCJzdHlsZVwiOlxuICAgICAgY2FzZSBcInNjcmlwdFwiOlxuICAgICAgY2FzZSBcInRlbXBsYXRlXCI6XG4gICAgICAgIGluX2hlYWRfbW9kZSh0LCB2YWx1ZSwgYXJnMywgYXJnNCk7XG4gICAgICAgIHJldHVybjtcblxuICAgICAgY2FzZSBcImlucHV0XCI6XG4gICAgICAgIHZhciB0eXBlID0gZ2V0VHlwZUF0dHIoYXJnMyk7XG4gICAgICAgIGlmICh0eXBlICE9PSBcImhpZGRlblwiKSBicmVhazsgIC8vIHRvIHRoZSBhbnl0aGluZyBlbHNlIGNhc2VcbiAgICAgICAgaW5zZXJ0SFRNTEVsZW1lbnQodmFsdWUsYXJnMyk7XG4gICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICByZXR1cm47XG5cbiAgICAgIGNhc2UgXCJmb3JtXCI6XG4gICAgICAgIGlmIChmb3JtX2VsZW1lbnRfcG9pbnRlciB8fCBzdGFjay5jb250YWlucyhcInRlbXBsYXRlXCIpKSByZXR1cm47XG4gICAgICAgIGZvcm1fZWxlbWVudF9wb2ludGVyID0gaW5zZXJ0SFRNTEVsZW1lbnQodmFsdWUsIGFyZzMpO1xuICAgICAgICBzdGFjay5wb3BFbGVtZW50KGZvcm1fZWxlbWVudF9wb2ludGVyKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAzOiAvLyBFTkRUQUdcbiAgICAgIHN3aXRjaCh2YWx1ZSkge1xuICAgICAgY2FzZSBcInRhYmxlXCI6XG4gICAgICAgIGlmICghc3RhY2suaW5UYWJsZVNjb3BlKHZhbHVlKSkgcmV0dXJuO1xuICAgICAgICBzdGFjay5wb3BUYWcodmFsdWUpO1xuICAgICAgICByZXNldEluc2VydGlvbk1vZGUoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSBcImJvZHlcIjpcbiAgICAgIGNhc2UgXCJjYXB0aW9uXCI6XG4gICAgICBjYXNlIFwiY29sXCI6XG4gICAgICBjYXNlIFwiY29sZ3JvdXBcIjpcbiAgICAgIGNhc2UgXCJodG1sXCI6XG4gICAgICBjYXNlIFwidGJvZHlcIjpcbiAgICAgIGNhc2UgXCJ0ZFwiOlxuICAgICAgY2FzZSBcInRmb290XCI6XG4gICAgICBjYXNlIFwidGhcIjpcbiAgICAgIGNhc2UgXCJ0aGVhZFwiOlxuICAgICAgY2FzZSBcInRyXCI6XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgXCJ0ZW1wbGF0ZVwiOlxuICAgICAgICBpbl9oZWFkX21vZGUodCwgdmFsdWUsIGFyZzMsIGFyZzQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgLTE6IC8vIEVPRlxuICAgICAgaW5fYm9keV9tb2RlKHQsIHZhbHVlLCBhcmczLCBhcmc0KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBUaGlzIGlzIHRoZSBhbnl0aGluZyBlbHNlIGNhc2VcbiAgICBmb3N0ZXJfcGFyZW50X21vZGUgPSB0cnVlO1xuICAgIGluX2JvZHlfbW9kZSh0LCB2YWx1ZSwgYXJnMywgYXJnNCk7XG4gICAgZm9zdGVyX3BhcmVudF9tb2RlID0gZmFsc2U7XG4gIH1cblxuICBmdW5jdGlvbiBpbl90YWJsZV90ZXh0X21vZGUodCwgdmFsdWUsIGFyZzMsIGFyZzQpIHtcbiAgICBpZiAodCA9PT0gVEVYVCkge1xuICAgICAgaWYgKHRleHRJbmNsdWRlc05VTCkge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoTlVMQ0hBUlMsIFwiXCIpO1xuICAgICAgICBpZiAodmFsdWUubGVuZ3RoID09PSAwKSByZXR1cm47XG4gICAgICB9XG4gICAgICBwZW5kaW5nX3RhYmxlX3RleHQucHVzaCh2YWx1ZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdmFyIHMgPSBwZW5kaW5nX3RhYmxlX3RleHQuam9pbihcIlwiKTtcbiAgICAgIHBlbmRpbmdfdGFibGVfdGV4dC5sZW5ndGggPSAwO1xuICAgICAgaWYgKE5PTldTLnRlc3QocykpIHsgLy8gSWYgYW55IG5vbi13aGl0ZXNwYWNlIGNoYXJhY3RlcnNcbiAgICAgICAgLy8gVGhpcyBtdXN0IGJlIHRoZSBzYW1lIGNvZGUgYXMgdGhlIFwiYW55dGhpbmcgZWxzZVwiXG4gICAgICAgIC8vIGNhc2Ugb2YgdGhlIGluX3RhYmxlIG1vZGUgYWJvdmUuXG4gICAgICAgIGZvc3Rlcl9wYXJlbnRfbW9kZSA9IHRydWU7XG4gICAgICAgIGluX2JvZHlfbW9kZShURVhULCBzKTtcbiAgICAgICAgZm9zdGVyX3BhcmVudF9tb2RlID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgaW5zZXJ0VGV4dChzKTtcbiAgICAgIH1cbiAgICAgIHBhcnNlciA9IG9yaWdpbmFsSW5zZXJ0aW9uTW9kZTtcbiAgICAgIHBhcnNlcih0LCB2YWx1ZSwgYXJnMywgYXJnNCk7XG4gICAgfVxuICB9XG5cblxuICBmdW5jdGlvbiBpbl9jYXB0aW9uX21vZGUodCwgdmFsdWUsIGFyZzMsIGFyZzQpIHtcbiAgICBmdW5jdGlvbiBlbmRfY2FwdGlvbigpIHtcbiAgICAgIGlmICghc3RhY2suaW5UYWJsZVNjb3BlKFwiY2FwdGlvblwiKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgc3RhY2suZ2VuZXJhdGVJbXBsaWVkRW5kVGFncygpO1xuICAgICAgc3RhY2sucG9wVGFnKFwiY2FwdGlvblwiKTtcbiAgICAgIGFmZS5jbGVhclRvTWFya2VyKCk7XG4gICAgICBwYXJzZXIgPSBpbl90YWJsZV9tb2RlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgc3dpdGNoKHQpIHtcbiAgICBjYXNlIDI6IC8vIFRBR1xuICAgICAgc3dpdGNoKHZhbHVlKSB7XG4gICAgICBjYXNlIFwiY2FwdGlvblwiOlxuICAgICAgY2FzZSBcImNvbFwiOlxuICAgICAgY2FzZSBcImNvbGdyb3VwXCI6XG4gICAgICBjYXNlIFwidGJvZHlcIjpcbiAgICAgIGNhc2UgXCJ0ZFwiOlxuICAgICAgY2FzZSBcInRmb290XCI6XG4gICAgICBjYXNlIFwidGhcIjpcbiAgICAgIGNhc2UgXCJ0aGVhZFwiOlxuICAgICAgY2FzZSBcInRyXCI6XG4gICAgICAgIGlmIChlbmRfY2FwdGlvbigpKSBwYXJzZXIodCwgdmFsdWUsIGFyZzMsIGFyZzQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlIDM6IC8vIEVORFRBR1xuICAgICAgc3dpdGNoKHZhbHVlKSB7XG4gICAgICBjYXNlIFwiY2FwdGlvblwiOlxuICAgICAgICBlbmRfY2FwdGlvbigpO1xuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlIFwidGFibGVcIjpcbiAgICAgICAgaWYgKGVuZF9jYXB0aW9uKCkpIHBhcnNlcih0LCB2YWx1ZSwgYXJnMywgYXJnNCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgXCJib2R5XCI6XG4gICAgICBjYXNlIFwiY29sXCI6XG4gICAgICBjYXNlIFwiY29sZ3JvdXBcIjpcbiAgICAgIGNhc2UgXCJodG1sXCI6XG4gICAgICBjYXNlIFwidGJvZHlcIjpcbiAgICAgIGNhc2UgXCJ0ZFwiOlxuICAgICAgY2FzZSBcInRmb290XCI6XG4gICAgICBjYXNlIFwidGhcIjpcbiAgICAgIGNhc2UgXCJ0aGVhZFwiOlxuICAgICAgY2FzZSBcInRyXCI6XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8vIFRoZSBBbnl0aGluZyBFbHNlIGNhc2VcbiAgICBpbl9ib2R5X21vZGUodCwgdmFsdWUsIGFyZzMsIGFyZzQpO1xuICB9XG5cbiAgZnVuY3Rpb24gaW5fY29sdW1uX2dyb3VwX21vZGUodCwgdmFsdWUsIGFyZzMsIGFyZzQpIHtcbiAgICBzd2l0Y2godCkge1xuICAgIGNhc2UgMTogLy8gVEVYVFxuICAgICAgdmFyIHdzID0gdmFsdWUubWF0Y2goTEVBRElOR1dTKTtcbiAgICAgIGlmICh3cykge1xuICAgICAgICBpbnNlcnRUZXh0KHdzWzBdKTtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5zdWJzdHJpbmcod3NbMF0ubGVuZ3RoKTtcbiAgICAgIH1cbiAgICAgIGlmICh2YWx1ZS5sZW5ndGggPT09IDApIHJldHVybjtcbiAgICAgIGJyZWFrOyAvLyBIYW5kbGUgbm9uLXdoaXRlc3BhY2UgYmVsb3dcblxuICAgIGNhc2UgNDogLy8gQ09NTUVOVFxuICAgICAgaW5zZXJ0Q29tbWVudCh2YWx1ZSk7XG4gICAgICByZXR1cm47XG4gICAgY2FzZSA1OiAvLyBET0NUWVBFXG4gICAgICByZXR1cm47XG4gICAgY2FzZSAyOiAvLyBUQUdcbiAgICAgIHN3aXRjaCh2YWx1ZSkge1xuICAgICAgY2FzZSBcImh0bWxcIjpcbiAgICAgICAgaW5fYm9keV9tb2RlKHQsIHZhbHVlLCBhcmczLCBhcmc0KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSBcImNvbFwiOlxuICAgICAgICBpbnNlcnRIVE1MRWxlbWVudCh2YWx1ZSwgYXJnMyk7XG4gICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlIFwidGVtcGxhdGVcIjpcbiAgICAgICAgaW5faGVhZF9tb2RlKHQsIHZhbHVlLCBhcmczLCBhcmc0KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAzOiAvLyBFTkRUQUdcbiAgICAgIHN3aXRjaCh2YWx1ZSkge1xuICAgICAgY2FzZSBcImNvbGdyb3VwXCI6XG4gICAgICAgIGlmICghaXNBKHN0YWNrLnRvcCwgJ2NvbGdyb3VwJykpIHtcbiAgICAgICAgICByZXR1cm47IC8vIElnbm9yZSB0aGUgdG9rZW4uXG4gICAgICAgIH1cbiAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgIHBhcnNlciA9IGluX3RhYmxlX21vZGU7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgXCJjb2xcIjpcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSBcInRlbXBsYXRlXCI6XG4gICAgICAgIGluX2hlYWRfbW9kZSh0LCB2YWx1ZSwgYXJnMywgYXJnNCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgLTE6IC8vIEVPRlxuICAgICAgaW5fYm9keV9tb2RlKHQsIHZhbHVlLCBhcmczLCBhcmc0KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBBbnl0aGluZyBlbHNlXG4gICAgaWYgKCFpc0Eoc3RhY2sudG9wLCAnY29sZ3JvdXAnKSkge1xuICAgICAgcmV0dXJuOyAvLyBJZ25vcmUgdGhlIHRva2VuLlxuICAgIH1cbiAgICBpbl9jb2x1bW5fZ3JvdXBfbW9kZShFTkRUQUcsIFwiY29sZ3JvdXBcIik7XG4gICAgcGFyc2VyKHQsIHZhbHVlLCBhcmczLCBhcmc0KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGluX3RhYmxlX2JvZHlfbW9kZSh0LCB2YWx1ZSwgYXJnMywgYXJnNCkge1xuICAgIGZ1bmN0aW9uIGVuZHNlY3QoKSB7XG4gICAgICBpZiAoIXN0YWNrLmluVGFibGVTY29wZShcInRib2R5XCIpICYmXG4gICAgICAgICFzdGFjay5pblRhYmxlU2NvcGUoXCJ0aGVhZFwiKSAmJlxuICAgICAgICAhc3RhY2suaW5UYWJsZVNjb3BlKFwidGZvb3RcIikpXG4gICAgICAgIHJldHVybjtcbiAgICAgIHN0YWNrLmNsZWFyVG9Db250ZXh0KHRhYmxlQm9keUNvbnRleHRTZXQpO1xuICAgICAgaW5fdGFibGVfYm9keV9tb2RlKEVORFRBRywgc3RhY2sudG9wLmxvY2FsTmFtZSwgbnVsbCk7XG4gICAgICBwYXJzZXIodCwgdmFsdWUsIGFyZzMsIGFyZzQpO1xuICAgIH1cblxuICAgIHN3aXRjaCh0KSB7XG4gICAgY2FzZSAyOiAvLyBUQUdcbiAgICAgIHN3aXRjaCh2YWx1ZSkge1xuICAgICAgY2FzZSBcInRyXCI6XG4gICAgICAgIHN0YWNrLmNsZWFyVG9Db250ZXh0KHRhYmxlQm9keUNvbnRleHRTZXQpO1xuICAgICAgICBpbnNlcnRIVE1MRWxlbWVudCh2YWx1ZSwgYXJnMyk7XG4gICAgICAgIHBhcnNlciA9IGluX3Jvd19tb2RlO1xuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlIFwidGhcIjpcbiAgICAgIGNhc2UgXCJ0ZFwiOlxuICAgICAgICBpbl90YWJsZV9ib2R5X21vZGUoVEFHLCBcInRyXCIsIG51bGwpO1xuICAgICAgICBwYXJzZXIodCwgdmFsdWUsIGFyZzMsIGFyZzQpO1xuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlIFwiY2FwdGlvblwiOlxuICAgICAgY2FzZSBcImNvbFwiOlxuICAgICAgY2FzZSBcImNvbGdyb3VwXCI6XG4gICAgICBjYXNlIFwidGJvZHlcIjpcbiAgICAgIGNhc2UgXCJ0Zm9vdFwiOlxuICAgICAgY2FzZSBcInRoZWFkXCI6XG4gICAgICAgIGVuZHNlY3QoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAzOiAvLyBFTkRUQUdcbiAgICAgIHN3aXRjaCh2YWx1ZSkge1xuICAgICAgY2FzZSBcInRhYmxlXCI6XG4gICAgICAgIGVuZHNlY3QoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSBcInRib2R5XCI6XG4gICAgICBjYXNlIFwidGZvb3RcIjpcbiAgICAgIGNhc2UgXCJ0aGVhZFwiOlxuICAgICAgICBpZiAoc3RhY2suaW5UYWJsZVNjb3BlKHZhbHVlKSkge1xuICAgICAgICAgIHN0YWNrLmNsZWFyVG9Db250ZXh0KHRhYmxlQm9keUNvbnRleHRTZXQpO1xuICAgICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICAgIHBhcnNlciA9IGluX3RhYmxlX21vZGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSBcImJvZHlcIjpcbiAgICAgIGNhc2UgXCJjYXB0aW9uXCI6XG4gICAgICBjYXNlIFwiY29sXCI6XG4gICAgICBjYXNlIFwiY29sZ3JvdXBcIjpcbiAgICAgIGNhc2UgXCJodG1sXCI6XG4gICAgICBjYXNlIFwidGRcIjpcbiAgICAgIGNhc2UgXCJ0aFwiOlxuICAgICAgY2FzZSBcInRyXCI6XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8vIEFueXRoaW5nIGVsc2U6XG4gICAgaW5fdGFibGVfbW9kZSh0LCB2YWx1ZSwgYXJnMywgYXJnNCk7XG4gIH1cblxuICBmdW5jdGlvbiBpbl9yb3dfbW9kZSh0LCB2YWx1ZSwgYXJnMywgYXJnNCkge1xuICAgIGZ1bmN0aW9uIGVuZHJvdygpIHtcbiAgICAgIGlmICghc3RhY2suaW5UYWJsZVNjb3BlKFwidHJcIikpIHJldHVybiBmYWxzZTtcbiAgICAgIHN0YWNrLmNsZWFyVG9Db250ZXh0KHRhYmxlUm93Q29udGV4dFNldCk7XG4gICAgICBzdGFjay5wb3AoKTtcbiAgICAgIHBhcnNlciA9IGluX3RhYmxlX2JvZHlfbW9kZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHN3aXRjaCh0KSB7XG4gICAgY2FzZSAyOiAvLyBUQUdcbiAgICAgIHN3aXRjaCh2YWx1ZSkge1xuICAgICAgY2FzZSBcInRoXCI6XG4gICAgICBjYXNlIFwidGRcIjpcbiAgICAgICAgc3RhY2suY2xlYXJUb0NvbnRleHQodGFibGVSb3dDb250ZXh0U2V0KTtcbiAgICAgICAgaW5zZXJ0SFRNTEVsZW1lbnQodmFsdWUsIGFyZzMpO1xuICAgICAgICBwYXJzZXIgPSBpbl9jZWxsX21vZGU7XG4gICAgICAgIGFmZS5pbnNlcnRNYXJrZXIoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSBcImNhcHRpb25cIjpcbiAgICAgIGNhc2UgXCJjb2xcIjpcbiAgICAgIGNhc2UgXCJjb2xncm91cFwiOlxuICAgICAgY2FzZSBcInRib2R5XCI6XG4gICAgICBjYXNlIFwidGZvb3RcIjpcbiAgICAgIGNhc2UgXCJ0aGVhZFwiOlxuICAgICAgY2FzZSBcInRyXCI6XG4gICAgICAgIGlmIChlbmRyb3coKSkgcGFyc2VyKHQsIHZhbHVlLCBhcmczLCBhcmc0KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAzOiAvLyBFTkRUQUdcbiAgICAgIHN3aXRjaCh2YWx1ZSkge1xuICAgICAgY2FzZSBcInRyXCI6XG4gICAgICAgIGVuZHJvdygpO1xuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlIFwidGFibGVcIjpcbiAgICAgICAgaWYgKGVuZHJvdygpKSBwYXJzZXIodCwgdmFsdWUsIGFyZzMsIGFyZzQpO1xuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlIFwidGJvZHlcIjpcbiAgICAgIGNhc2UgXCJ0Zm9vdFwiOlxuICAgICAgY2FzZSBcInRoZWFkXCI6XG4gICAgICAgIGlmIChzdGFjay5pblRhYmxlU2NvcGUodmFsdWUpKSB7XG4gICAgICAgICAgaWYgKGVuZHJvdygpKSBwYXJzZXIodCwgdmFsdWUsIGFyZzMsIGFyZzQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgXCJib2R5XCI6XG4gICAgICBjYXNlIFwiY2FwdGlvblwiOlxuICAgICAgY2FzZSBcImNvbFwiOlxuICAgICAgY2FzZSBcImNvbGdyb3VwXCI6XG4gICAgICBjYXNlIFwiaHRtbFwiOlxuICAgICAgY2FzZSBcInRkXCI6XG4gICAgICBjYXNlIFwidGhcIjpcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLy8gYW55dGhpbmcgZWxzZVxuICAgIGluX3RhYmxlX21vZGUodCwgdmFsdWUsIGFyZzMsIGFyZzQpO1xuICB9XG5cbiAgZnVuY3Rpb24gaW5fY2VsbF9tb2RlKHQsIHZhbHVlLCBhcmczLCBhcmc0KSB7XG4gICAgc3dpdGNoKHQpIHtcbiAgICBjYXNlIDI6IC8vIFRBR1xuICAgICAgc3dpdGNoKHZhbHVlKSB7XG4gICAgICBjYXNlIFwiY2FwdGlvblwiOlxuICAgICAgY2FzZSBcImNvbFwiOlxuICAgICAgY2FzZSBcImNvbGdyb3VwXCI6XG4gICAgICBjYXNlIFwidGJvZHlcIjpcbiAgICAgIGNhc2UgXCJ0ZFwiOlxuICAgICAgY2FzZSBcInRmb290XCI6XG4gICAgICBjYXNlIFwidGhcIjpcbiAgICAgIGNhc2UgXCJ0aGVhZFwiOlxuICAgICAgY2FzZSBcInRyXCI6XG4gICAgICAgIGlmIChzdGFjay5pblRhYmxlU2NvcGUoXCJ0ZFwiKSkge1xuICAgICAgICAgIGluX2NlbGxfbW9kZShFTkRUQUcsIFwidGRcIik7XG4gICAgICAgICAgcGFyc2VyKHQsIHZhbHVlLCBhcmczLCBhcmc0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzdGFjay5pblRhYmxlU2NvcGUoXCJ0aFwiKSkge1xuICAgICAgICAgIGluX2NlbGxfbW9kZShFTkRUQUcsIFwidGhcIik7XG4gICAgICAgICAgcGFyc2VyKHQsIHZhbHVlLCBhcmczLCBhcmc0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlIDM6IC8vIEVORFRBR1xuICAgICAgc3dpdGNoKHZhbHVlKSB7XG4gICAgICBjYXNlIFwidGRcIjpcbiAgICAgIGNhc2UgXCJ0aFwiOlxuICAgICAgICBpZiAoIXN0YWNrLmluVGFibGVTY29wZSh2YWx1ZSkpIHJldHVybjtcbiAgICAgICAgc3RhY2suZ2VuZXJhdGVJbXBsaWVkRW5kVGFncygpO1xuICAgICAgICBzdGFjay5wb3BUYWcodmFsdWUpO1xuICAgICAgICBhZmUuY2xlYXJUb01hcmtlcigpO1xuICAgICAgICBwYXJzZXIgPSBpbl9yb3dfbW9kZTtcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgICBjYXNlIFwiYm9keVwiOlxuICAgICAgY2FzZSBcImNhcHRpb25cIjpcbiAgICAgIGNhc2UgXCJjb2xcIjpcbiAgICAgIGNhc2UgXCJjb2xncm91cFwiOlxuICAgICAgY2FzZSBcImh0bWxcIjpcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgICBjYXNlIFwidGFibGVcIjpcbiAgICAgIGNhc2UgXCJ0Ym9keVwiOlxuICAgICAgY2FzZSBcInRmb290XCI6XG4gICAgICBjYXNlIFwidGhlYWRcIjpcbiAgICAgIGNhc2UgXCJ0clwiOlxuICAgICAgICBpZiAoIXN0YWNrLmluVGFibGVTY29wZSh2YWx1ZSkpIHJldHVybjtcbiAgICAgICAgaW5fY2VsbF9tb2RlKEVORFRBRywgc3RhY2suaW5UYWJsZVNjb3BlKFwidGRcIikgPyBcInRkXCIgOiBcInRoXCIpO1xuICAgICAgICBwYXJzZXIodCwgdmFsdWUsIGFyZzMsIGFyZzQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvLyBhbnl0aGluZyBlbHNlXG4gICAgaW5fYm9keV9tb2RlKHQsIHZhbHVlLCBhcmczLCBhcmc0KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGluX3NlbGVjdF9tb2RlKHQsIHZhbHVlLCBhcmczLCBhcmc0KSB7XG4gICAgc3dpdGNoKHQpIHtcbiAgICBjYXNlIDE6IC8vIFRFWFRcbiAgICAgIGlmICh0ZXh0SW5jbHVkZXNOVUwpIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKE5VTENIQVJTLCBcIlwiKTtcbiAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaW5zZXJ0VGV4dCh2YWx1ZSk7XG4gICAgICByZXR1cm47XG4gICAgY2FzZSA0OiAvLyBDT01NRU5UXG4gICAgICBpbnNlcnRDb21tZW50KHZhbHVlKTtcbiAgICAgIHJldHVybjtcbiAgICBjYXNlIDU6IC8vIERPQ1RZUEVcbiAgICAgIHJldHVybjtcbiAgICBjYXNlIC0xOiAvLyBFT0ZcbiAgICAgIGluX2JvZHlfbW9kZSh0LCB2YWx1ZSwgYXJnMywgYXJnNCk7XG4gICAgICByZXR1cm47XG4gICAgY2FzZSAyOiAvLyBUQUdcbiAgICAgIHN3aXRjaCh2YWx1ZSkge1xuICAgICAgY2FzZSBcImh0bWxcIjpcbiAgICAgICAgaW5fYm9keV9tb2RlKHQsIHZhbHVlLCBhcmczLCBhcmc0KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSBcIm9wdGlvblwiOlxuICAgICAgICBpZiAoc3RhY2sudG9wIGluc3RhbmNlb2YgaW1wbC5IVE1MT3B0aW9uRWxlbWVudClcbiAgICAgICAgICBpbl9zZWxlY3RfbW9kZShFTkRUQUcsIHZhbHVlKTtcbiAgICAgICAgaW5zZXJ0SFRNTEVsZW1lbnQodmFsdWUsIGFyZzMpO1xuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlIFwib3B0Z3JvdXBcIjpcbiAgICAgICAgaWYgKHN0YWNrLnRvcCBpbnN0YW5jZW9mIGltcGwuSFRNTE9wdGlvbkVsZW1lbnQpXG4gICAgICAgICAgaW5fc2VsZWN0X21vZGUoRU5EVEFHLCBcIm9wdGlvblwiKTtcbiAgICAgICAgaWYgKHN0YWNrLnRvcCBpbnN0YW5jZW9mIGltcGwuSFRNTE9wdEdyb3VwRWxlbWVudClcbiAgICAgICAgICBpbl9zZWxlY3RfbW9kZShFTkRUQUcsIHZhbHVlKTtcbiAgICAgICAgaW5zZXJ0SFRNTEVsZW1lbnQodmFsdWUsIGFyZzMpO1xuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlIFwic2VsZWN0XCI6XG4gICAgICAgIGluX3NlbGVjdF9tb2RlKEVORFRBRywgdmFsdWUpOyAvLyB0cmVhdCBpdCBhcyBhIGNsb3NlIHRhZ1xuICAgICAgICByZXR1cm47XG5cbiAgICAgIGNhc2UgXCJpbnB1dFwiOlxuICAgICAgY2FzZSBcImtleWdlblwiOlxuICAgICAgY2FzZSBcInRleHRhcmVhXCI6XG4gICAgICAgIGlmICghc3RhY2suaW5TZWxlY3RTY29wZShcInNlbGVjdFwiKSkgcmV0dXJuO1xuICAgICAgICBpbl9zZWxlY3RfbW9kZShFTkRUQUcsIFwic2VsZWN0XCIpO1xuICAgICAgICBwYXJzZXIodCwgdmFsdWUsIGFyZzMsIGFyZzQpO1xuICAgICAgICByZXR1cm47XG5cbiAgICAgIGNhc2UgXCJzY3JpcHRcIjpcbiAgICAgIGNhc2UgXCJ0ZW1wbGF0ZVwiOlxuICAgICAgICBpbl9oZWFkX21vZGUodCwgdmFsdWUsIGFyZzMsIGFyZzQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlIDM6IC8vIEVORFRBR1xuICAgICAgc3dpdGNoKHZhbHVlKSB7XG4gICAgICBjYXNlIFwib3B0Z3JvdXBcIjpcbiAgICAgICAgaWYgKHN0YWNrLnRvcCBpbnN0YW5jZW9mIGltcGwuSFRNTE9wdGlvbkVsZW1lbnQgJiZcbiAgICAgICAgICBzdGFjay5lbGVtZW50c1tzdGFjay5lbGVtZW50cy5sZW5ndGgtMl0gaW5zdGFuY2VvZlxuICAgICAgICAgIGltcGwuSFRNTE9wdEdyb3VwRWxlbWVudCkge1xuICAgICAgICAgIGluX3NlbGVjdF9tb2RlKEVORFRBRywgXCJvcHRpb25cIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YWNrLnRvcCBpbnN0YW5jZW9mIGltcGwuSFRNTE9wdEdyb3VwRWxlbWVudClcbiAgICAgICAgICBzdGFjay5wb3AoKTtcblxuICAgICAgICByZXR1cm47XG5cbiAgICAgIGNhc2UgXCJvcHRpb25cIjpcbiAgICAgICAgaWYgKHN0YWNrLnRvcCBpbnN0YW5jZW9mIGltcGwuSFRNTE9wdGlvbkVsZW1lbnQpXG4gICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgIHJldHVybjtcblxuICAgICAgY2FzZSBcInNlbGVjdFwiOlxuICAgICAgICBpZiAoIXN0YWNrLmluU2VsZWN0U2NvcGUodmFsdWUpKSByZXR1cm47XG4gICAgICAgIHN0YWNrLnBvcFRhZyh2YWx1ZSk7XG4gICAgICAgIHJlc2V0SW5zZXJ0aW9uTW9kZSgpO1xuICAgICAgICByZXR1cm47XG5cbiAgICAgIGNhc2UgXCJ0ZW1wbGF0ZVwiOlxuICAgICAgICBpbl9oZWFkX21vZGUodCwgdmFsdWUsIGFyZzMsIGFyZzQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8vIGFueXRoaW5nIGVsc2U6IGp1c3QgaWdub3JlIHRoZSB0b2tlblxuICB9XG5cbiAgZnVuY3Rpb24gaW5fc2VsZWN0X2luX3RhYmxlX21vZGUodCwgdmFsdWUsIGFyZzMsIGFyZzQpIHtcbiAgICBzd2l0Y2godmFsdWUpIHtcbiAgICBjYXNlIFwiY2FwdGlvblwiOlxuICAgIGNhc2UgXCJ0YWJsZVwiOlxuICAgIGNhc2UgXCJ0Ym9keVwiOlxuICAgIGNhc2UgXCJ0Zm9vdFwiOlxuICAgIGNhc2UgXCJ0aGVhZFwiOlxuICAgIGNhc2UgXCJ0clwiOlxuICAgIGNhc2UgXCJ0ZFwiOlxuICAgIGNhc2UgXCJ0aFwiOlxuICAgICAgc3dpdGNoKHQpIHtcbiAgICAgIGNhc2UgMjogLy8gVEFHXG4gICAgICAgIGluX3NlbGVjdF9pbl90YWJsZV9tb2RlKEVORFRBRywgXCJzZWxlY3RcIik7XG4gICAgICAgIHBhcnNlcih0LCB2YWx1ZSwgYXJnMywgYXJnNCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgMzogLy8gRU5EVEFHXG4gICAgICAgIGlmIChzdGFjay5pblRhYmxlU2NvcGUodmFsdWUpKSB7XG4gICAgICAgICAgaW5fc2VsZWN0X2luX3RhYmxlX21vZGUoRU5EVEFHLCBcInNlbGVjdFwiKTtcbiAgICAgICAgICBwYXJzZXIodCwgdmFsdWUsIGFyZzMsIGFyZzQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBhbnl0aGluZyBlbHNlXG4gICAgaW5fc2VsZWN0X21vZGUodCwgdmFsdWUsIGFyZzMsIGFyZzQpO1xuICB9XG5cbiAgZnVuY3Rpb24gaW5fdGVtcGxhdGVfbW9kZSh0LCB2YWx1ZSwgYXJnMywgYXJnNCkge1xuICAgIGZ1bmN0aW9uIHN3aXRjaE1vZGVBbmRSZXByb2Nlc3MobW9kZSkge1xuICAgICAgcGFyc2VyID0gbW9kZTtcbiAgICAgIHRlbXBsYXRlSW5zZXJ0aW9uTW9kZXNbdGVtcGxhdGVJbnNlcnRpb25Nb2Rlcy5sZW5ndGgtMV0gPSBwYXJzZXI7XG4gICAgICBwYXJzZXIodCwgdmFsdWUsIGFyZzMsIGFyZzQpO1xuICAgIH1cbiAgICBzd2l0Y2godCkge1xuICAgIGNhc2UgMTogLy8gVEVYVFxuICAgIGNhc2UgNDogLy8gQ09NTUVOVFxuICAgIGNhc2UgNTogLy8gRE9DVFlQRVxuICAgICAgaW5fYm9keV9tb2RlKHQsIHZhbHVlLCBhcmczLCBhcmc0KTtcbiAgICAgIHJldHVybjtcbiAgICBjYXNlIC0xOiAvLyBFT0ZcbiAgICAgIGlmICghc3RhY2suY29udGFpbnMoXCJ0ZW1wbGF0ZVwiKSkge1xuICAgICAgICBzdG9wUGFyc2luZygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhY2sucG9wVGFnKFwidGVtcGxhdGVcIik7XG4gICAgICAgIGFmZS5jbGVhclRvTWFya2VyKCk7XG4gICAgICAgIHRlbXBsYXRlSW5zZXJ0aW9uTW9kZXMucG9wKCk7XG4gICAgICAgIHJlc2V0SW5zZXJ0aW9uTW9kZSgpO1xuICAgICAgICBwYXJzZXIodCwgdmFsdWUsIGFyZzMsIGFyZzQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIGNhc2UgMjogLy8gVEFHXG4gICAgICBzd2l0Y2godmFsdWUpIHtcbiAgICAgIGNhc2UgXCJiYXNlXCI6XG4gICAgICBjYXNlIFwiYmFzZWZvbnRcIjpcbiAgICAgIGNhc2UgXCJiZ3NvdW5kXCI6XG4gICAgICBjYXNlIFwibGlua1wiOlxuICAgICAgY2FzZSBcIm1ldGFcIjpcbiAgICAgIGNhc2UgXCJub2ZyYW1lc1wiOlxuICAgICAgY2FzZSBcInNjcmlwdFwiOlxuICAgICAgY2FzZSBcInN0eWxlXCI6XG4gICAgICBjYXNlIFwidGVtcGxhdGVcIjpcbiAgICAgIGNhc2UgXCJ0aXRsZVwiOlxuICAgICAgICBpbl9oZWFkX21vZGUodCwgdmFsdWUsIGFyZzMsIGFyZzQpO1xuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlIFwiY2FwdGlvblwiOlxuICAgICAgY2FzZSBcImNvbGdyb3VwXCI6XG4gICAgICBjYXNlIFwidGJvZHlcIjpcbiAgICAgIGNhc2UgXCJ0Zm9vdFwiOlxuICAgICAgY2FzZSBcInRoZWFkXCI6XG4gICAgICAgIHN3aXRjaE1vZGVBbmRSZXByb2Nlc3MoaW5fdGFibGVfbW9kZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgXCJjb2xcIjpcbiAgICAgICAgc3dpdGNoTW9kZUFuZFJlcHJvY2Vzcyhpbl9jb2x1bW5fZ3JvdXBfbW9kZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgXCJ0clwiOlxuICAgICAgICBzd2l0Y2hNb2RlQW5kUmVwcm9jZXNzKGluX3RhYmxlX2JvZHlfbW9kZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgXCJ0ZFwiOlxuICAgICAgY2FzZSBcInRoXCI6XG4gICAgICAgIHN3aXRjaE1vZGVBbmRSZXByb2Nlc3MoaW5fcm93X21vZGUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzd2l0Y2hNb2RlQW5kUmVwcm9jZXNzKGluX2JvZHlfbW9kZSk7XG4gICAgICByZXR1cm47XG4gICAgY2FzZSAzOiAvLyBFTkRUQUdcbiAgICAgIHN3aXRjaCh2YWx1ZSkge1xuICAgICAgY2FzZSBcInRlbXBsYXRlXCI6XG4gICAgICAgIGluX2hlYWRfbW9kZSh0LCB2YWx1ZSwgYXJnMywgYXJnNCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBhZnRlcl9ib2R5X21vZGUodCwgdmFsdWUsIGFyZzMsIGFyZzQpIHtcbiAgICBzd2l0Y2godCkge1xuICAgIGNhc2UgMTogLy8gVEVYVFxuICAgICAgLy8gSWYgYW55IG5vbi1zcGFjZSBjaGFycywgaGFuZGxlIGJlbG93XG4gICAgICBpZiAoTk9OV1MudGVzdCh2YWx1ZSkpIGJyZWFrO1xuICAgICAgaW5fYm9keV9tb2RlKHQsIHZhbHVlKTtcbiAgICAgIHJldHVybjtcbiAgICBjYXNlIDQ6IC8vIENPTU1FTlRcbiAgICAgIC8vIEFwcGVuZCBpdCB0byB0aGUgPGh0bWw+IGVsZW1lbnRcbiAgICAgIHN0YWNrLmVsZW1lbnRzWzBdLl9hcHBlbmRDaGlsZChkb2MuY3JlYXRlQ29tbWVudCh2YWx1ZSkpO1xuICAgICAgcmV0dXJuO1xuICAgIGNhc2UgNTogLy8gRE9DVFlQRVxuICAgICAgcmV0dXJuO1xuICAgIGNhc2UgLTE6IC8vIEVPRlxuICAgICAgc3RvcFBhcnNpbmcoKTtcbiAgICAgIHJldHVybjtcbiAgICBjYXNlIDI6IC8vIFRBR1xuICAgICAgaWYgKHZhbHVlID09PSBcImh0bWxcIikge1xuICAgICAgICBpbl9ib2R5X21vZGUodCwgdmFsdWUsIGFyZzMsIGFyZzQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBicmVhazsgLy8gZm9yIGFueSBvdGhlciB0YWdzXG4gICAgY2FzZSAzOiAvLyBFTkRUQUdcbiAgICAgIGlmICh2YWx1ZSA9PT0gXCJodG1sXCIpIHtcbiAgICAgICAgaWYgKGZyYWdtZW50KSByZXR1cm47XG4gICAgICAgIHBhcnNlciA9IGFmdGVyX2FmdGVyX2JvZHlfbW9kZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgYnJlYWs7IC8vIGZvciBhbnkgb3RoZXIgdGFnc1xuICAgIH1cblxuICAgIC8vIGFueXRoaW5nIGVsc2VcbiAgICBwYXJzZXIgPSBpbl9ib2R5X21vZGU7XG4gICAgcGFyc2VyKHQsIHZhbHVlLCBhcmczLCBhcmc0KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGluX2ZyYW1lc2V0X21vZGUodCwgdmFsdWUsIGFyZzMsIGFyZzQpIHtcbiAgICBzd2l0Y2godCkge1xuICAgIGNhc2UgMTogLy8gVEVYVFxuICAgICAgLy8gSWdub3JlIGFueSBub24tc3BhY2UgY2hhcmFjdGVyc1xuICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKEFMTE5PTldTLCBcIlwiKTtcbiAgICAgIGlmICh2YWx1ZS5sZW5ndGggPiAwKSBpbnNlcnRUZXh0KHZhbHVlKTtcbiAgICAgIHJldHVybjtcbiAgICBjYXNlIDQ6IC8vIENPTU1FTlRcbiAgICAgIGluc2VydENvbW1lbnQodmFsdWUpO1xuICAgICAgcmV0dXJuO1xuICAgIGNhc2UgNTogLy8gRE9DVFlQRVxuICAgICAgcmV0dXJuO1xuICAgIGNhc2UgLTE6IC8vIEVPRlxuICAgICAgc3RvcFBhcnNpbmcoKTtcbiAgICAgIHJldHVybjtcbiAgICBjYXNlIDI6IC8vIFRBR1xuICAgICAgc3dpdGNoKHZhbHVlKSB7XG4gICAgICBjYXNlIFwiaHRtbFwiOlxuICAgICAgICBpbl9ib2R5X21vZGUodCwgdmFsdWUsIGFyZzMsIGFyZzQpO1xuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlIFwiZnJhbWVzZXRcIjpcbiAgICAgICAgaW5zZXJ0SFRNTEVsZW1lbnQodmFsdWUsIGFyZzMpO1xuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlIFwiZnJhbWVcIjpcbiAgICAgICAgaW5zZXJ0SFRNTEVsZW1lbnQodmFsdWUsIGFyZzMpO1xuICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSBcIm5vZnJhbWVzXCI6XG4gICAgICAgIGluX2hlYWRfbW9kZSh0LCB2YWx1ZSwgYXJnMywgYXJnNCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMzogLy8gRU5EVEFHXG4gICAgICBpZiAodmFsdWUgPT09IFwiZnJhbWVzZXRcIikge1xuICAgICAgICBpZiAoZnJhZ21lbnQgJiYgc3RhY2sudG9wIGluc3RhbmNlb2YgaW1wbC5IVE1MSHRtbEVsZW1lbnQpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgaWYgKCFmcmFnbWVudCAmJlxuICAgICAgICAgICEoc3RhY2sudG9wIGluc3RhbmNlb2YgaW1wbC5IVE1MRnJhbWVTZXRFbGVtZW50KSlcbiAgICAgICAgICBwYXJzZXIgPSBhZnRlcl9mcmFtZXNldF9tb2RlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvLyBpZ25vcmUgYW55dGhpbmcgZWxzZVxuICB9XG5cbiAgZnVuY3Rpb24gYWZ0ZXJfZnJhbWVzZXRfbW9kZSh0LCB2YWx1ZSwgYXJnMywgYXJnNCkge1xuICAgIHN3aXRjaCh0KSB7XG4gICAgY2FzZSAxOiAvLyBURVhUXG4gICAgICAvLyBJZ25vcmUgYW55IG5vbi1zcGFjZSBjaGFyYWN0ZXJzXG4gICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoQUxMTk9OV1MsIFwiXCIpO1xuICAgICAgaWYgKHZhbHVlLmxlbmd0aCA+IDApIGluc2VydFRleHQodmFsdWUpO1xuICAgICAgcmV0dXJuO1xuICAgIGNhc2UgNDogLy8gQ09NTUVOVFxuICAgICAgaW5zZXJ0Q29tbWVudCh2YWx1ZSk7XG4gICAgICByZXR1cm47XG4gICAgY2FzZSA1OiAvLyBET0NUWVBFXG4gICAgICByZXR1cm47XG4gICAgY2FzZSAtMTogLy8gRU9GXG4gICAgICBzdG9wUGFyc2luZygpO1xuICAgICAgcmV0dXJuO1xuICAgIGNhc2UgMjogLy8gVEFHXG4gICAgICBzd2l0Y2godmFsdWUpIHtcbiAgICAgIGNhc2UgXCJodG1sXCI6XG4gICAgICAgIGluX2JvZHlfbW9kZSh0LCB2YWx1ZSwgYXJnMywgYXJnNCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgXCJub2ZyYW1lc1wiOlxuICAgICAgICBpbl9oZWFkX21vZGUodCwgdmFsdWUsIGFyZzMsIGFyZzQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlIDM6IC8vIEVORFRBR1xuICAgICAgaWYgKHZhbHVlID09PSBcImh0bWxcIikge1xuICAgICAgICBwYXJzZXIgPSBhZnRlcl9hZnRlcl9mcmFtZXNldF9tb2RlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvLyBpZ25vcmUgYW55dGhpbmcgZWxzZVxuICB9XG5cbiAgZnVuY3Rpb24gYWZ0ZXJfYWZ0ZXJfYm9keV9tb2RlKHQsIHZhbHVlLCBhcmczLCBhcmc0KSB7XG4gICAgc3dpdGNoKHQpIHtcbiAgICBjYXNlIDE6IC8vIFRFWFRcbiAgICAgIC8vIElmIGFueSBub24tc3BhY2UgY2hhcnMsIGhhbmRsZSBiZWxvd1xuICAgICAgaWYgKE5PTldTLnRlc3QodmFsdWUpKSBicmVhaztcbiAgICAgIGluX2JvZHlfbW9kZSh0LCB2YWx1ZSwgYXJnMywgYXJnNCk7XG4gICAgICByZXR1cm47XG4gICAgY2FzZSA0OiAvLyBDT01NRU5UXG4gICAgICBkb2MuX2FwcGVuZENoaWxkKGRvYy5jcmVhdGVDb21tZW50KHZhbHVlKSk7XG4gICAgICByZXR1cm47XG4gICAgY2FzZSA1OiAvLyBET0NUWVBFXG4gICAgICBpbl9ib2R5X21vZGUodCwgdmFsdWUsIGFyZzMsIGFyZzQpO1xuICAgICAgcmV0dXJuO1xuICAgIGNhc2UgLTE6IC8vIEVPRlxuICAgICAgc3RvcFBhcnNpbmcoKTtcbiAgICAgIHJldHVybjtcbiAgICBjYXNlIDI6IC8vIFRBR1xuICAgICAgaWYgKHZhbHVlID09PSBcImh0bWxcIikge1xuICAgICAgICBpbl9ib2R5X21vZGUodCwgdmFsdWUsIGFyZzMsIGFyZzQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvLyBhbnl0aGluZyBlbHNlXG4gICAgcGFyc2VyID0gaW5fYm9keV9tb2RlO1xuICAgIHBhcnNlcih0LCB2YWx1ZSwgYXJnMywgYXJnNCk7XG4gIH1cblxuICBmdW5jdGlvbiBhZnRlcl9hZnRlcl9mcmFtZXNldF9tb2RlKHQsIHZhbHVlLCBhcmczLCBhcmc0KSB7XG4gICAgc3dpdGNoKHQpIHtcbiAgICBjYXNlIDE6IC8vIFRFWFRcbiAgICAgIC8vIElnbm9yZSBhbnkgbm9uLXNwYWNlIGNoYXJhY3RlcnNcbiAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZShBTExOT05XUywgXCJcIik7XG4gICAgICBpZiAodmFsdWUubGVuZ3RoID4gMClcbiAgICAgICAgaW5fYm9keV9tb2RlKHQsIHZhbHVlLCBhcmczLCBhcmc0KTtcbiAgICAgIHJldHVybjtcbiAgICBjYXNlIDQ6IC8vIENPTU1FTlRcbiAgICAgIGRvYy5fYXBwZW5kQ2hpbGQoZG9jLmNyZWF0ZUNvbW1lbnQodmFsdWUpKTtcbiAgICAgIHJldHVybjtcbiAgICBjYXNlIDU6IC8vIERPQ1RZUEVcbiAgICAgIGluX2JvZHlfbW9kZSh0LCB2YWx1ZSwgYXJnMywgYXJnNCk7XG4gICAgICByZXR1cm47XG4gICAgY2FzZSAtMTogLy8gRU9GXG4gICAgICBzdG9wUGFyc2luZygpO1xuICAgICAgcmV0dXJuO1xuICAgIGNhc2UgMjogLy8gVEFHXG4gICAgICBzd2l0Y2godmFsdWUpIHtcbiAgICAgIGNhc2UgXCJodG1sXCI6XG4gICAgICAgIGluX2JvZHlfbW9kZSh0LCB2YWx1ZSwgYXJnMywgYXJnNCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgXCJub2ZyYW1lc1wiOlxuICAgICAgICBpbl9oZWFkX21vZGUodCwgdmFsdWUsIGFyZzMsIGFyZzQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvLyBpZ25vcmUgYW55dGhpbmcgZWxzZVxuICB9XG5cblxuICAvLyAxMy4yLjUuNSBUaGUgcnVsZXMgZm9yIHBhcnNpbmcgdG9rZW5zIGluIGZvcmVpZ24gY29udGVudFxuICAvL1xuICAvLyBUaGlzIGlzIGxpa2Ugb25lIG9mIHRoZSBpbnNlcnRpb24gbW9kZXMgYWJvdmUsIGJ1dCBpc1xuICAvLyBpbnZva2VkIHNvbWV3aGF0IGRpZmZlcmVudGx5IHdoZW4gdGhlIGN1cnJlbnQgdG9rZW4gaXMgbm90IEhUTUwuXG4gIC8vIFNlZSB0aGUgaW5zZXJ0VG9rZW4oKSBmdW5jdGlvbi5cbiAgZnVuY3Rpb24gaW5zZXJ0Rm9yZWlnblRva2VuKHQsIHZhbHVlLCBhcmczLCBhcmc0KSB7XG4gICAgLy8gQSA8Zm9udD4gdGFnIGlzIGFuIEhUTUwgZm9udCB0YWcgaWYgaXQgaGFzIGEgY29sb3IsIGZvbnQsIG9yIHNpemVcbiAgICAvLyBhdHRyaWJ1dGUuICBPdGhlcndpc2Ugd2UgYXNzdW1lIGl0IGlzIGZvcmVpZ24gY29udGVudFxuICAgIGZ1bmN0aW9uIGlzSFRNTEZvbnQoYXR0cnMpIHtcbiAgICAgIGZvcih2YXIgaSA9IDAsIG4gPSBhdHRycy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgc3dpdGNoKGF0dHJzW2ldWzBdKSB7XG4gICAgICAgIGNhc2UgXCJjb2xvclwiOlxuICAgICAgICBjYXNlIFwiZmFjZVwiOlxuICAgICAgICBjYXNlIFwic2l6ZVwiOlxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIGN1cnJlbnQ7XG5cbiAgICBzd2l0Y2godCkge1xuICAgIGNhc2UgMTogLy8gVEVYVFxuICAgICAgLy8gSWYgYW55IG5vbi1zcGFjZSwgbm9uLW51bCBjaGFyYWN0ZXJzXG4gICAgICBpZiAoZnJhbWVzZXRfb2sgJiYgTk9OV1NOT05OVUwudGVzdCh2YWx1ZSkpXG4gICAgICAgIGZyYW1lc2V0X29rID0gZmFsc2U7XG4gICAgICBpZiAodGV4dEluY2x1ZGVzTlVMKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZShOVUxDSEFSUywgXCJcXHVGRkZEXCIpO1xuICAgICAgfVxuICAgICAgaW5zZXJ0VGV4dCh2YWx1ZSk7XG4gICAgICByZXR1cm47XG4gICAgY2FzZSA0OiAvLyBDT01NRU5UXG4gICAgICBpbnNlcnRDb21tZW50KHZhbHVlKTtcbiAgICAgIHJldHVybjtcbiAgICBjYXNlIDU6IC8vIERPQ1RZUEVcbiAgICAgIC8vIGlnbm9yZSBpdFxuICAgICAgcmV0dXJuO1xuICAgIGNhc2UgMjogLy8gVEFHXG4gICAgICBzd2l0Y2godmFsdWUpIHtcbiAgICAgIGNhc2UgXCJmb250XCI6XG4gICAgICAgIGlmICghaXNIVE1MRm9udChhcmczKSkgYnJlYWs7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgXCJiXCI6XG4gICAgICBjYXNlIFwiYmlnXCI6XG4gICAgICBjYXNlIFwiYmxvY2txdW90ZVwiOlxuICAgICAgY2FzZSBcImJvZHlcIjpcbiAgICAgIGNhc2UgXCJiclwiOlxuICAgICAgY2FzZSBcImNlbnRlclwiOlxuICAgICAgY2FzZSBcImNvZGVcIjpcbiAgICAgIGNhc2UgXCJkZFwiOlxuICAgICAgY2FzZSBcImRpdlwiOlxuICAgICAgY2FzZSBcImRsXCI6XG4gICAgICBjYXNlIFwiZHRcIjpcbiAgICAgIGNhc2UgXCJlbVwiOlxuICAgICAgY2FzZSBcImVtYmVkXCI6XG4gICAgICBjYXNlIFwiaDFcIjpcbiAgICAgIGNhc2UgXCJoMlwiOlxuICAgICAgY2FzZSBcImgzXCI6XG4gICAgICBjYXNlIFwiaDRcIjpcbiAgICAgIGNhc2UgXCJoNVwiOlxuICAgICAgY2FzZSBcImg2XCI6XG4gICAgICBjYXNlIFwiaGVhZFwiOlxuICAgICAgY2FzZSBcImhyXCI6XG4gICAgICBjYXNlIFwiaVwiOlxuICAgICAgY2FzZSBcImltZ1wiOlxuICAgICAgY2FzZSBcImxpXCI6XG4gICAgICBjYXNlIFwibGlzdGluZ1wiOlxuICAgICAgY2FzZSBcIm1lbnVcIjpcbiAgICAgIGNhc2UgXCJtZXRhXCI6XG4gICAgICBjYXNlIFwibm9iclwiOlxuICAgICAgY2FzZSBcIm9sXCI6XG4gICAgICBjYXNlIFwicFwiOlxuICAgICAgY2FzZSBcInByZVwiOlxuICAgICAgY2FzZSBcInJ1YnlcIjpcbiAgICAgIGNhc2UgXCJzXCI6XG4gICAgICBjYXNlIFwic21hbGxcIjpcbiAgICAgIGNhc2UgXCJzcGFuXCI6XG4gICAgICBjYXNlIFwic3Ryb25nXCI6XG4gICAgICBjYXNlIFwic3RyaWtlXCI6XG4gICAgICBjYXNlIFwic3ViXCI6XG4gICAgICBjYXNlIFwic3VwXCI6XG4gICAgICBjYXNlIFwidGFibGVcIjpcbiAgICAgIGNhc2UgXCJ0dFwiOlxuICAgICAgY2FzZSBcInVcIjpcbiAgICAgIGNhc2UgXCJ1bFwiOlxuICAgICAgY2FzZSBcInZhclwiOlxuICAgICAgICBpZiAoZnJhZ21lbnQpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBkbyB7XG4gICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgICAgY3VycmVudCA9IHN0YWNrLnRvcDtcbiAgICAgICAgfSB3aGlsZShjdXJyZW50Lm5hbWVzcGFjZVVSSSAhPT0gTkFNRVNQQUNFLkhUTUwgJiZcbiAgICAgICAgICAgICFpc01hdGhtbFRleHRJbnRlZ3JhdGlvblBvaW50KGN1cnJlbnQpICYmXG4gICAgICAgICAgICAhaXNIVE1MSW50ZWdyYXRpb25Qb2ludChjdXJyZW50KSk7XG5cbiAgICAgICAgaW5zZXJ0VG9rZW4odCwgdmFsdWUsIGFyZzMsIGFyZzQpOyAgLy8gcmVwcm9jZXNzXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gQW55IG90aGVyIHN0YXJ0IHRhZyBjYXNlIGdvZXMgaGVyZVxuICAgICAgY3VycmVudCA9IChzdGFjay5lbGVtZW50cy5sZW5ndGg9PT0xICYmIGZyYWdtZW50KSA/IGZyYWdtZW50Q29udGV4dCA6XG4gICAgICAgIHN0YWNrLnRvcDtcbiAgICAgIGlmIChjdXJyZW50Lm5hbWVzcGFjZVVSSSA9PT0gTkFNRVNQQUNFLk1BVEhNTCkge1xuICAgICAgICBhZGp1c3RNYXRoTUxBdHRyaWJ1dGVzKGFyZzMpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoY3VycmVudC5uYW1lc3BhY2VVUkkgPT09IE5BTUVTUEFDRS5TVkcpIHtcbiAgICAgICAgdmFsdWUgPSBhZGp1c3RTVkdUYWdOYW1lKHZhbHVlKTtcbiAgICAgICAgYWRqdXN0U1ZHQXR0cmlidXRlcyhhcmczKTtcbiAgICAgIH1cbiAgICAgIGFkanVzdEZvcmVpZ25BdHRyaWJ1dGVzKGFyZzMpO1xuXG4gICAgICBpbnNlcnRGb3JlaWduRWxlbWVudCh2YWx1ZSwgYXJnMywgY3VycmVudC5uYW1lc3BhY2VVUkkpO1xuICAgICAgaWYgKGFyZzQpIHsgLy8gdGhlIHNlbGYtY2xvc2luZyBmbGFnXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gJ3NjcmlwdCcgJiYgY3VycmVudC5uYW1lc3BhY2VVUkkgPT09IE5BTUVTUEFDRS5TVkcpIHtcbiAgICAgICAgICAvLyBYWFggZGVhbCB3aXRoIFNWRyBzY3JpcHRzIGhlcmVcbiAgICAgICAgfVxuICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcblxuICAgIGNhc2UgMzogLy8gRU5EVEFHXG4gICAgICBjdXJyZW50ID0gc3RhY2sudG9wO1xuICAgICAgaWYgKHZhbHVlID09PSBcInNjcmlwdFwiICYmXG4gICAgICAgIGN1cnJlbnQubmFtZXNwYWNlVVJJID09PSBOQU1FU1BBQ0UuU1ZHICYmXG4gICAgICAgIGN1cnJlbnQubG9jYWxOYW1lID09PSBcInNjcmlwdFwiKSB7XG5cbiAgICAgICAgc3RhY2sucG9wKCk7XG5cbiAgICAgICAgLy8gWFhYXG4gICAgICAgIC8vIERlYWwgd2l0aCBTVkcgc2NyaXB0cyBoZXJlXG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgLy8gVGhlIGFueSBvdGhlciBlbmQgdGFnIGNhc2VcbiAgICAgICAgdmFyIGkgPSBzdGFjay5lbGVtZW50cy5sZW5ndGgtMTtcbiAgICAgICAgdmFyIG5vZGUgPSBzdGFjay5lbGVtZW50c1tpXTtcbiAgICAgICAgZm9yKDs7KSB7XG4gICAgICAgICAgaWYgKG5vZGUubG9jYWxOYW1lLnRvTG93ZXJDYXNlKCkgPT09IHZhbHVlKSB7XG4gICAgICAgICAgICBzdGFjay5wb3BFbGVtZW50KG5vZGUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIG5vZGUgPSBzdGFjay5lbGVtZW50c1stLWldO1xuICAgICAgICAgIC8vIElmIG5vbi1odG1sLCBrZWVwIGxvb3BpbmdcbiAgICAgICAgICBpZiAobm9kZS5uYW1lc3BhY2VVUkkgIT09IE5BTUVTUEFDRS5IVE1MKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgLy8gT3RoZXJ3aXNlIHByb2Nlc3MgdGhlIGVuZCB0YWcgYXMgaHRtbFxuICAgICAgICAgIHBhcnNlcih0LCB2YWx1ZSwgYXJnMywgYXJnNCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cblxuICAvKioqXG4gICAqIEZpbmFsbHksIHRoaXMgaXMgdGhlIGVuZCBvZiB0aGUgSFRNTFBhcnNlcigpIGZhY3RvcnkgZnVuY3Rpb24uXG4gICAqIEl0IHJldHVybnMgdGhlIGh0bWxwYXJzZXIgb2JqZWN0IHdpdGggdGhlIGFwcGVuZCgpIGFuZCBlbmQoKSBtZXRob2RzLlxuICAgKi9cblxuICAvLyBTbmVhayBhbm90aGVyIG1ldGhvZCBpbnRvIHRoZSBodG1scGFyc2VyIG9iamVjdCB0byBhbGxvdyB1cyB0byBydW5cbiAgLy8gdG9rZW5pemVyIHRlc3RzLiAgVGhpcyBjYW4gYmUgY29tbWVudGVkIG91dCBpbiBwcm9kdWN0aW9uIGNvZGUuXG4gIC8vIFRoaXMgaXMgYSBob29rIGZvciB0ZXN0aW5nIHRoZSB0b2tlbml6ZXIuIEl0IGhhcyB0byBiZSBoZXJlXG4gIC8vIGJlY2F1c2UgdGhlIHRva2VuaXplciBkZXRhaWxzIGFyZSBhbGwgaGlkZGVuIGF3YXkgd2l0aGluIHRoZSBjbG9zdXJlLlxuICAvLyBJdCBzaG91bGQgcmV0dXJuIGFuIGFycmF5IG9mIHRva2VucyBnZW5lcmF0ZWQgd2hpbGUgcGFyc2luZyB0aGVcbiAgLy8gaW5wdXQgc3RyaW5nLlxuICBodG1scGFyc2VyLnRlc3RUb2tlbml6ZXIgPSBmdW5jdGlvbihpbnB1dCwgaW5pdGlhbFN0YXRlLCBsYXN0U3RhcnRUYWcsIGNoYXJieWNoYXIpIHtcbiAgICB2YXIgdG9rZW5zID0gW107XG5cbiAgICBzd2l0Y2goaW5pdGlhbFN0YXRlKSB7XG4gICAgY2FzZSBcIlBDREFUQSBzdGF0ZVwiOlxuICAgICAgdG9rZW5pemVyID0gZGF0YV9zdGF0ZTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJSQ0RBVEEgc3RhdGVcIjpcbiAgICAgIHRva2VuaXplciA9IHJjZGF0YV9zdGF0ZTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJSQVdURVhUIHN0YXRlXCI6XG4gICAgICB0b2tlbml6ZXIgPSByYXd0ZXh0X3N0YXRlO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIlBMQUlOVEVYVCBzdGF0ZVwiOlxuICAgICAgdG9rZW5pemVyID0gcGxhaW50ZXh0X3N0YXRlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKGxhc3RTdGFydFRhZykge1xuICAgICAgbGFzdHRhZ25hbWUgPSBsYXN0U3RhcnRUYWc7XG4gICAgfVxuXG4gICAgaW5zZXJ0VG9rZW4gPSBmdW5jdGlvbih0LCB2YWx1ZSwgYXJnMywgYXJnNCkge1xuICAgICAgZmx1c2hUZXh0KCk7XG4gICAgICBzd2l0Y2godCkge1xuICAgICAgY2FzZSAxOiAvLyBURVhUXG4gICAgICAgIGlmICh0b2tlbnMubGVuZ3RoID4gMCAmJlxuICAgICAgICAgIHRva2Vuc1t0b2tlbnMubGVuZ3RoLTFdWzBdID09PSBcIkNoYXJhY3RlclwiKSB7XG4gICAgICAgICAgdG9rZW5zW3Rva2Vucy5sZW5ndGgtMV1bMV0gKz0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB0b2tlbnMucHVzaChbXCJDaGFyYWN0ZXJcIiwgdmFsdWVdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDQ6IC8vIENPTU1FTlRcbiAgICAgICAgdG9rZW5zLnB1c2goW1wiQ29tbWVudFwiLCB2YWx1ZV0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgNTogLy8gRE9DVFlQRVxuICAgICAgICB0b2tlbnMucHVzaChbXCJET0NUWVBFXCIsIHZhbHVlLFxuICAgICAgICAgICAgICAgYXJnMyA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGFyZzMsXG4gICAgICAgICAgICAgICBhcmc0ID09PSB1bmRlZmluZWQgPyBudWxsIDogYXJnNCxcbiAgICAgICAgICAgICAgICFmb3JjZV9xdWlya3NdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI6IC8vIFRBR1xuICAgICAgICB2YXIgYXR0cnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgYXJnMy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIC8vIFhYWDogZG9lcyBhdHRyaWJ1dGUgb3JkZXIgbWF0dGVyP1xuICAgICAgICAgIHZhciBhID0gYXJnM1tpXTtcbiAgICAgICAgICBpZiAoYS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIGF0dHJzW2FbMF1dID0gXCJcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhdHRyc1thWzBdXSA9IGFbMV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciB0b2tlbiA9IFtcIlN0YXJ0VGFnXCIsIHZhbHVlLCBhdHRyc107XG4gICAgICAgIGlmIChhcmc0KSB0b2tlbi5wdXNoKHRydWUpO1xuICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzOiAvLyBFTkRUQUdcbiAgICAgICAgdG9rZW5zLnB1c2goW1wiRW5kVGFnXCIsIHZhbHVlXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAtMTogLy8gRU9GXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBpZiAoIWNoYXJieWNoYXIpIHtcbiAgICAgIHRoaXMucGFyc2UoaW5wdXQsIHRydWUpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBpbnB1dC5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLnBhcnNlKGlucHV0W2ldKTtcbiAgICAgIH1cbiAgICAgIHRoaXMucGFyc2UoXCJcIiwgdHJ1ZSk7XG4gICAgfVxuICAgIHJldHVybiB0b2tlbnM7XG4gIH07XG5cbiAgLy8gUmV0dXJuIHRoZSBwYXJzZXIgb2JqZWN0IGZyb20gdGhlIEhUTUxQYXJzZXIoKSBmYWN0b3J5IGZ1bmN0aW9uXG4gIHJldHVybiBodG1scGFyc2VyO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZG9taW5vL2xpYi9IVE1MUGFyc2VyLmpzXG4vLyBtb2R1bGUgaWQgPSAyOVxuLy8gbW9kdWxlIGNodW5rcyA9IDQiLCJtb2R1bGUuZXhwb3J0cyA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKDIpKSgzODEpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGRlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9Abmd4LXRyYW5zbGF0ZS9jb3JlL2J1bmRsZXMvY29yZS51bWQuanMgZnJvbSBkbGwtcmVmZXJlbmNlIC4vdmVuZG9yXG4vLyBtb2R1bGUgaWQgPSAzMFxuLy8gbW9kdWxlIGNodW5rcyA9IDQiLCJpbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IEh0dHBDbGllbnQgfSBmcm9tICdAYW5ndWxhci9jb21tb24vaHR0cCc7XHJcbmltcG9ydCB7IFJlcXVlc3RNZXRob2QsIFVSTFNlYXJjaFBhcmFtcyB9IGZyb20gJ0Bhbmd1bGFyL2h0dHAnO1xyXG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcy9PYnNlcnZhYmxlJztcclxuaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJ3J4anMvU3ViamVjdCc7XHJcbmltcG9ydCB7IFBMQVRGT1JNX0lELCBJbmplY3QgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgaXNQbGF0Zm9ybUJyb3dzZXIgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xyXG5cclxuaW1wb3J0IHsgVXRpbGl0eVNlcnZpY2UgfSBmcm9tICcuL3V0aWxpdHkuc2VydmljZSc7XHJcbmltcG9ydCB7IERhdGFTZXJ2aWNlT3B0aW9ucyB9IGZyb20gJy4vZGF0YS1zZXJ2aWNlLW9wdGlvbnMnO1xyXG5pbXBvcnQgeyBBdXRoVG9rZW5Nb2RlbCB9IGZyb20gJy4uL21vZGVscy9hdXRoLXRva2Vucy1tb2RlbCc7XHJcblxyXG5ASW5qZWN0YWJsZSgpXHJcbmV4cG9ydCBjbGFzcyBEYXRhU2VydmljZSB7XHJcblxyXG4gICAgLy8gRGVmaW5lIHRoZSBpbnRlcm5hbCBTdWJqZWN0IHdlJ2xsIHVzZSB0byBwdXNoIHRoZSBjb21tYW5kIGNvdW50XHJcbiAgICBwdWJsaWMgcGVuZGluZ0NvbW1hbmRzU3ViamVjdCA9IG5ldyBTdWJqZWN0PG51bWJlcj4oKTtcclxuICAgIHB1YmxpYyBwZW5kaW5nQ29tbWFuZENvdW50ID0gMDtcclxuXHJcbiAgICAvLyBQcm92aWRlIHRoZSAqcHVibGljKiBPYnNlcnZhYmxlIHRoYXQgY2xpZW50cyBjYW4gc3Vic2NyaWJlIHRvXHJcbiAgICBwdWJsaWMgcGVuZGluZ0NvbW1hbmRzJDogT2JzZXJ2YWJsZTxudW1iZXI+O1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyBodHRwOiBIdHRwQ2xpZW50LCBwdWJsaWMgdXM6IFV0aWxpdHlTZXJ2aWNlLCBASW5qZWN0KFBMQVRGT1JNX0lEKSBwcml2YXRlIHBsYXRmb3JtSWQ6IE9iamVjdCkge1xyXG4gICAgICAgIHRoaXMucGVuZGluZ0NvbW1hbmRzJCA9IHRoaXMucGVuZGluZ0NvbW1hbmRzU3ViamVjdC5hc09ic2VydmFibGUoKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBJIHBlcmZvcm0gYSBHRVQgcmVxdWVzdCB0byB0aGUgQVBJLCBhcHBlbmRpbmcgdGhlIGdpdmVuIHBhcmFtc1xyXG4gICAgLy8gYXMgVVJMIHNlYXJjaCBwYXJhbWV0ZXJzLiBSZXR1cm5zIGEgc3RyZWFtLlxyXG4gICAgcHVibGljIGdldDxUPih1cmw6IHN0cmluZywgcGFyYW1zPzogYW55KTogT2JzZXJ2YWJsZTxUPiB7XHJcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IG5ldyBEYXRhU2VydmljZU9wdGlvbnMoKTtcclxuICAgICAgICBvcHRpb25zLm1ldGhvZCA9IFJlcXVlc3RNZXRob2QuR2V0O1xyXG4gICAgICAgIG9wdGlvbnMudXJsID0gdXJsO1xyXG4gICAgICAgIG9wdGlvbnMucGFyYW1zID0gcGFyYW1zO1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3Q8VD4ob3B0aW9ucyk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gSSBwZXJmb3JtIGEgUE9TVCByZXF1ZXN0IHRvIHRoZSBBUEkuIElmIGJvdGggdGhlIHBhcmFtcyBhbmQgZGF0YVxyXG4gICAgLy8gYXJlIHByZXNlbnQsIHRoZSBwYXJhbXMgd2lsbCBiZSBhcHBlbmRlZCBhcyBVUkwgc2VhcmNoIHBhcmFtZXRlcnNcclxuICAgIC8vIGFuZCB0aGUgZGF0YSB3aWxsIGJlIHNlcmlhbGl6ZWQgYXMgYSBKU09OIHBheWxvYWQuIElmIG9ubHkgdGhlXHJcbiAgICAvLyBkYXRhIGlzIHByZXNlbnQsIGl0IHdpbGwgYmUgc2VyaWFsaXplZCBhcyBhIEpTT04gcGF5bG9hZC4gUmV0dXJuc1xyXG4gICAgLy8gYSBzdHJlYW0uXHJcbiAgICBwdWJsaWMgcG9zdDxUPih1cmw6IHN0cmluZywgZGF0YT86IGFueSwgcGFyYW1zPzogYW55KTogT2JzZXJ2YWJsZTxUPiB7XHJcbiAgICAgICAgaWYgKCFkYXRhKSB7XHJcbiAgICAgICAgICAgIGRhdGEgPSBwYXJhbXM7XHJcbiAgICAgICAgICAgIHBhcmFtcyA9IHt9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBvcHRpb25zID0gbmV3IERhdGFTZXJ2aWNlT3B0aW9ucygpO1xyXG4gICAgICAgIG9wdGlvbnMubWV0aG9kID0gUmVxdWVzdE1ldGhvZC5Qb3N0O1xyXG4gICAgICAgIG9wdGlvbnMudXJsID0gdXJsO1xyXG4gICAgICAgIG9wdGlvbnMucGFyYW1zID0gcGFyYW1zO1xyXG4gICAgICAgIG9wdGlvbnMuZGF0YSA9IGRhdGE7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdDxUPihvcHRpb25zKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgcHV0PFQ+KHVybDogc3RyaW5nLCBkYXRhPzogYW55LCBwYXJhbXM/OiBhbnkpOiBPYnNlcnZhYmxlPFQ+IHtcclxuICAgICAgICBpZiAoIWRhdGEpIHtcclxuICAgICAgICAgICAgZGF0YSA9IHBhcmFtcztcclxuICAgICAgICAgICAgcGFyYW1zID0ge307XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBuZXcgRGF0YVNlcnZpY2VPcHRpb25zKCk7XHJcbiAgICAgICAgb3B0aW9ucy5tZXRob2QgPSBSZXF1ZXN0TWV0aG9kLlB1dDtcclxuICAgICAgICBvcHRpb25zLnVybCA9IHVybDtcclxuICAgICAgICBvcHRpb25zLnBhcmFtcyA9IHBhcmFtcztcclxuICAgICAgICBvcHRpb25zLmRhdGEgPSBkYXRhO1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3Q8VD4ob3B0aW9ucyk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGRlbGV0ZTxUPih1cmw6IHN0cmluZyk6IE9ic2VydmFibGU8VD4ge1xyXG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBuZXcgRGF0YVNlcnZpY2VPcHRpb25zKCk7XHJcbiAgICAgICAgb3B0aW9ucy5tZXRob2QgPSBSZXF1ZXN0TWV0aG9kLkRlbGV0ZTtcclxuICAgICAgICBvcHRpb25zLnVybCA9IHVybDtcclxuICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0PFQ+KG9wdGlvbnMpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyByZXF1ZXN0PFQ+KG9wdGlvbnM6IERhdGFTZXJ2aWNlT3B0aW9ucyk6IE9ic2VydmFibGU8VD4ge1xyXG4gICAgICAgIG9wdGlvbnMubWV0aG9kID0gKG9wdGlvbnMubWV0aG9kIHx8IFJlcXVlc3RNZXRob2QuR2V0KTtcclxuICAgICAgICBvcHRpb25zLnVybCA9IChvcHRpb25zLnVybCB8fCAnJyk7XHJcbiAgICAgICAgb3B0aW9ucy5oZWFkZXJzID0gKG9wdGlvbnMuaGVhZGVycyB8fCB7fSk7XHJcbiAgICAgICAgb3B0aW9ucy5wYXJhbXMgPSAob3B0aW9ucy5wYXJhbXMgfHwge30pO1xyXG4gICAgICAgIG9wdGlvbnMuZGF0YSA9IChvcHRpb25zLmRhdGEgfHwge30pO1xyXG5cclxuICAgICAgICB0aGlzLmludGVycG9sYXRlVXJsKG9wdGlvbnMpO1xyXG4gICAgICAgIHRoaXMuYWRkQ29udGVudFR5cGUob3B0aW9ucyk7XHJcbiAgICAgICAgLy8gQ2xpZW50IG9ubHkgY29kZS5cclxuICAgICAgICAvLyBiZWNhdXNlIGl0IHVzZXMgZ2xvYmFsIHdpbmRvdy9kb2N1bWVudHMgc3R1ZmZcclxuICAgICAgICBpZiAoaXNQbGF0Zm9ybUJyb3dzZXIodGhpcy5wbGF0Zm9ybUlkKSkge1xyXG4gICAgICAgICAgICB0aGlzLmFkZFhzcmZUb2tlbihvcHRpb25zKTtcclxuICAgICAgICAgICAgdGhpcy5hZGRBdXRoVG9rZW4ob3B0aW9ucyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCByZXF1ZXN0T3B0aW9ucyA9IHtcclxuICAgICAgICAgICAgbWV0aG9kOiBvcHRpb25zLm1ldGhvZCxcclxuICAgICAgICAgICAgdXJsOiBvcHRpb25zLnVybCxcclxuICAgICAgICAgICAgaGVhZGVyczogb3B0aW9ucy5oZWFkZXJzLFxyXG4gICAgICAgICAgICBzZWFyY2g6IHRoaXMuYnVpbGRVcmxTZWFyY2hQYXJhbXMob3B0aW9ucy5wYXJhbXMpLFxyXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShvcHRpb25zLmRhdGEpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLnBlbmRpbmdDb21tYW5kc1N1YmplY3QubmV4dCgrK3RoaXMucGVuZGluZ0NvbW1hbmRDb3VudCk7XHJcblxyXG4gICAgICAgIGNvbnN0IHN0cmVhbSA9IHRoaXMuaHR0cC5yZXF1ZXN0PFQ+KHRoaXMudG9NZXRob2RTdHJpbmcob3B0aW9ucy5tZXRob2QpLCBvcHRpb25zLnVybCwgcmVxdWVzdE9wdGlvbnMpXHJcbiAgICAgICAgICAgIC5jYXRjaCgoZXJyb3I6IGFueSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVFcnJvcnMoZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIE9ic2VydmFibGUudGhyb3coZXJyb3IpO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAvLyAubWFwKHRoaXMudW53cmFwSHR0cFZhbHVlKVxyXG4gICAgICAgICAgICAuY2F0Y2goKGVycm9yOiBhbnkpID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBPYnNlcnZhYmxlLnRocm93KGVycm9yKTtcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgLmZpbmFsbHkoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nQ29tbWFuZHNTdWJqZWN0Lm5leHQoLS10aGlzLnBlbmRpbmdDb21tYW5kQ291bnQpO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHN0cmVhbTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGFkZENvbnRlbnRUeXBlKG9wdGlvbnM6IERhdGFTZXJ2aWNlT3B0aW9ucyk6IERhdGFTZXJ2aWNlT3B0aW9ucyB7XHJcbiAgICAgICAgLy8gaWYgKG9wdGlvbnMubWV0aG9kICE9PSBSZXF1ZXN0TWV0aG9kLkdldCkge1xyXG4gICAgICAgIG9wdGlvbnMuaGVhZGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbjsgY2hhcnNldD1VVEYtOCc7XHJcbiAgICAgICAgLy8gfVxyXG4gICAgICAgIHJldHVybiBvcHRpb25zO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgYWRkQXV0aFRva2VuKG9wdGlvbnM6IERhdGFTZXJ2aWNlT3B0aW9ucyk6IERhdGFTZXJ2aWNlT3B0aW9ucyB7XHJcbiAgICAgICAgY29uc3QgYXV0aFRva2VuU3RyaW5nID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ2F1dGgtdG9rZW4nKTtcclxuICAgICAgICBpZiAoYXV0aFRva2VuU3RyaW5nKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGF1dGhUb2tlbk1vZGVsOiBBdXRoVG9rZW5Nb2RlbCA9IEpTT04ucGFyc2UoPGFueT5hdXRoVG9rZW5TdHJpbmcpO1xyXG4gICAgICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6d2hpdGVzcGFjZVxyXG4gICAgICAgICAgICBvcHRpb25zLmhlYWRlcnMuQXV0aG9yaXphdGlvbiA9ICdCZWFyZXIgJyArIGF1dGhUb2tlbk1vZGVsLmFjY2Vzc190b2tlbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG9wdGlvbnM7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBleHRyYWN0VmFsdWUoY29sbGVjdGlvbjogYW55LCBrZXk6IHN0cmluZyk6IGFueSB7XHJcbiAgICAgICAgY29uc3QgdmFsdWUgPSBjb2xsZWN0aW9uW2tleV07XHJcbiAgICAgICAgZGVsZXRlIChjb2xsZWN0aW9uW2tleV0pO1xyXG4gICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGFkZFhzcmZUb2tlbihvcHRpb25zOiBEYXRhU2VydmljZU9wdGlvbnMpOiBEYXRhU2VydmljZU9wdGlvbnMge1xyXG4gICAgICAgIGNvbnN0IHhzcmZUb2tlbiA9IHRoaXMuZ2V0WHNyZkNvb2tpZSgpO1xyXG4gICAgICAgIGlmICh4c3JmVG9rZW4pIHtcclxuICAgICAgICAgICAgb3B0aW9ucy5oZWFkZXJzWydYLVhTUkYtVE9LRU4nXSA9IHhzcmZUb2tlbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG9wdGlvbnM7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBnZXRYc3JmQ29va2llKCk6IHN0cmluZyB7XHJcbiAgICAgICAgY29uc3QgbWF0Y2hlcyA9IGRvY3VtZW50LmNvb2tpZS5tYXRjaCgvXFxiWFNSRi1UT0tFTj0oW15cXHM7XSspLyk7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgcmV0dXJuIG1hdGNoZXMgPyBkZWNvZGVVUklDb21wb25lbnQobWF0Y2hlc1sxXSkgOiAnJztcclxuICAgICAgICB9IGNhdGNoIChkZWNvZGVFcnJvcikge1xyXG4gICAgICAgICAgICByZXR1cm4gJyc7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIHByaXZhdGUgYWRkQ29ycyhvcHRpb25zOiBEYXRhU2VydmljZU9wdGlvbnMpOiBEYXRhU2VydmljZU9wdGlvbnMge1xyXG4gICAgLy8gICAgIG9wdGlvbnMuaGVhZGVyc1snQWNjZXNzLUNvbnRyb2wtQWxsb3ctT3JpZ2luJ10gPSAnKic7XHJcbiAgICAvLyAgICAgcmV0dXJuIG9wdGlvbnM7XHJcbiAgICAvLyB9XHJcblxyXG4gICAgcHJpdmF0ZSBidWlsZFVybFNlYXJjaFBhcmFtcyhwYXJhbXM6IGFueSk6IFVSTFNlYXJjaFBhcmFtcyB7XHJcbiAgICAgICAgY29uc3Qgc2VhcmNoUGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpO1xyXG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xyXG4gICAgICAgICAgICBpZiAocGFyYW1zLmhhc093blByb3BlcnR5KGtleSkpIHtcclxuICAgICAgICAgICAgICAgIHNlYXJjaFBhcmFtcy5hcHBlbmQoa2V5LCBwYXJhbXNba2V5XSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHNlYXJjaFBhcmFtcztcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGludGVycG9sYXRlVXJsKG9wdGlvbnM6IERhdGFTZXJ2aWNlT3B0aW9ucyk6IERhdGFTZXJ2aWNlT3B0aW9ucyB7XHJcbiAgICAgICAgb3B0aW9ucy51cmwgPSBvcHRpb25zLnVybC5yZXBsYWNlKC86KFthLXpBLVpdK1tcXHctXSopL2csICgkMCwgdG9rZW4pID0+IHtcclxuICAgICAgICAgICAgLy8gVHJ5IHRvIG1vdmUgbWF0Y2hpbmcgdG9rZW4gZnJvbSB0aGUgcGFyYW1zIGNvbGxlY3Rpb24uXHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnBhcmFtcy5oYXNPd25Qcm9wZXJ0eSh0b2tlbikpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAodGhpcy5leHRyYWN0VmFsdWUob3B0aW9ucy5wYXJhbXMsIHRva2VuKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gVHJ5IHRvIG1vdmUgbWF0Y2hpbmcgdG9rZW4gZnJvbSB0aGUgZGF0YSBjb2xsZWN0aW9uLlxyXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5kYXRhLmhhc093blByb3BlcnR5KHRva2VuKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICh0aGlzLmV4dHJhY3RWYWx1ZShvcHRpb25zLmRhdGEsIHRva2VuKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gSWYgYSBtYXRjaGluZyB2YWx1ZSBjb3VsZG4ndCBiZSBmb3VuZCwganVzdCByZXBsYWNlXHJcbiAgICAgICAgICAgIC8vIHRoZSB0b2tlbiB3aXRoIHRoZSBlbXB0eSBzdHJpbmcuXHJcbiAgICAgICAgICAgIHJldHVybiAoJycpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vIENsZWFuIHVwIGFueSByZXBlYXRpbmcgc2xhc2hlcy5cclxuICAgICAgICBvcHRpb25zLnVybCA9IG9wdGlvbnMudXJsLnJlcGxhY2UoL1xcL3syLH0vZywgJy8nKTtcclxuICAgICAgICAvLyBDbGVhbiB1cCBhbnkgdHJhaWxpbmcgc2xhc2hlcy5cclxuICAgICAgICBvcHRpb25zLnVybCA9IG9wdGlvbnMudXJsLnJlcGxhY2UoL1xcLyskL2csICcnKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIG9wdGlvbnM7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gcHJpdmF0ZSB1bndyYXBIdHRwRXJyb3IoZXJyb3I6IGFueSk6IGFueSB7XHJcbiAgICAvLyAgICAgdHJ5IHtcclxuICAgIC8vICAgICAgICAgcmV0dXJuIChlcnJvci5qc29uKCkpO1xyXG4gICAgLy8gICAgIH0gY2F0Y2ggKGpzb25FcnJvcikge1xyXG4gICAgLy8gICAgICAgICByZXR1cm4gKHtcclxuICAgIC8vICAgICAgICAgICAgIGNvZGU6IC0xLFxyXG4gICAgLy8gICAgICAgICAgICAgbWVzc2FnZTogJ0FuIHVuZXhwZWN0ZWQgZXJyb3Igb2NjdXJyZWQuJ1xyXG4gICAgLy8gICAgICAgICB9KTtcclxuICAgIC8vICAgICB9XHJcbiAgICAvLyB9XHJcbiAgICBwcml2YXRlIGhhbmRsZUVycm9ycyhlcnJvcjogYW55KSB7XHJcbiAgICAgICAgaWYgKGVycm9yLnN0YXR1cyA9PT0gNDAxKSB7XHJcbiAgICAgICAgICAgIHNlc3Npb25TdG9yYWdlLmNsZWFyKCk7XHJcbiAgICAgICAgICAgIHRoaXMudXMubmF2aWdhdGVUb1NpZ25JbigpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoZXJyb3Iuc3RhdHVzID09PSA0MDMpIHtcclxuICAgICAgICAgICAgLy8gRm9yYmlkZGVuXHJcbiAgICAgICAgICAgIHRoaXMudXMubmF2aWdhdGVUb1NpZ25JbigpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHRvTWV0aG9kU3RyaW5nKG1ldGhvZDogUmVxdWVzdE1ldGhvZCk6IHN0cmluZyB7XHJcbiAgICAgICAgc3dpdGNoIChtZXRob2QpIHtcclxuICAgICAgICAgICAgY2FzZSBSZXF1ZXN0TWV0aG9kLkdldDpcclxuICAgICAgICAgICAgICAgIHJldHVybiAnR0VUJztcclxuICAgICAgICAgICAgY2FzZSBSZXF1ZXN0TWV0aG9kLlBvc3Q6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJ1BPU1QnO1xyXG4gICAgICAgICAgICBjYXNlIFJlcXVlc3RNZXRob2QuUHV0OlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuICdQVVQnO1xyXG4gICAgICAgICAgICBjYXNlIFJlcXVlc3RNZXRob2QuRGVsZXRlOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuICdERUxFVEUnO1xyXG4gICAgICAgICAgICBjYXNlIFJlcXVlc3RNZXRob2QuUGF0Y2g6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJ1BBVENIJztcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHJldHVybiAnR0VUJztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2FuZ3VsYXIyLXRlbXBsYXRlLWxvYWRlciEuL0NsaWVudEFwcC9hcHAvY29yZS9zZXJ2aWNlcy9kYXRhLnNlcnZpY2UudHMiLCJleHBvcnQgY2xhc3MgQ29udHJvbEJhc2U8VD57XHJcbiAgICBwdWJsaWMgdmFsdWU6IFQgfCB1bmRlZmluZWQ7XHJcbiAgICBwdWJsaWMga2V5OiBzdHJpbmc7XHJcbiAgICBwdWJsaWMgbGFiZWw6IHN0cmluZztcclxuICAgIHB1YmxpYyBwbGFjZWhvbGRlcjogc3RyaW5nO1xyXG4gICAgcHVibGljIHJlcXVpcmVkOiBib29sZWFuO1xyXG4gICAgcHVibGljIG1pbmxlbmd0aDogbnVtYmVyIHwgdW5kZWZpbmVkO1xyXG4gICAgcHVibGljIG1heGxlbmd0aDogbnVtYmVyIHwgdW5kZWZpbmVkO1xyXG4gICAgcHVibGljIG9yZGVyOiBudW1iZXI7XHJcbiAgICBwdWJsaWMgdHlwZTogc3RyaW5nO1xyXG4gICAgcHVibGljIGNsYXNzOiBzdHJpbmc7XHJcbiAgICBwdWJsaWMgb3B0aW9uczogYW55XHJcblxyXG4gICAgY29uc3RydWN0b3Iob3B0aW9uczoge1xyXG4gICAgICAgIHZhbHVlPzogVCxcclxuICAgICAgICBrZXk/OiBzdHJpbmcsXHJcbiAgICAgICAgbGFiZWw/OiBzdHJpbmcsXHJcbiAgICAgICAgcGxhY2Vob2xkZXI/OiBzdHJpbmcsXHJcbiAgICAgICAgcmVxdWlyZWQ/OiBib29sZWFuLFxyXG4gICAgICAgIG1pbmxlbmd0aD86IG51bWJlcixcclxuICAgICAgICBtYXhsZW5ndGg/OiBudW1iZXIsXHJcbiAgICAgICAgb3JkZXI/OiBudW1iZXIsXHJcbiAgICAgICAgdHlwZT86IHN0cmluZyxcclxuICAgICAgICBjbGFzcz86IHN0cmluZztcclxuICAgIH0gPSB7fSkge1xyXG4gICAgICAgIHRoaXMudmFsdWUgPSBvcHRpb25zLnZhbHVlO1xyXG4gICAgICAgIHRoaXMua2V5ID0gb3B0aW9ucy5rZXkgfHwgJyc7XHJcbiAgICAgICAgdGhpcy5sYWJlbCA9IG9wdGlvbnMubGFiZWwgfHwgJyc7XHJcbiAgICAgICAgdGhpcy5wbGFjZWhvbGRlciA9IG9wdGlvbnMucGxhY2Vob2xkZXIgfHwgJyc7XHJcbiAgICAgICAgdGhpcy5yZXF1aXJlZCA9ICEhb3B0aW9ucy5yZXF1aXJlZDtcclxuICAgICAgICB0aGlzLm1pbmxlbmd0aCA9IG9wdGlvbnMubWlubGVuZ3RoO1xyXG4gICAgICAgIHRoaXMubWF4bGVuZ3RoID0gb3B0aW9ucy5tYXhsZW5ndGg7XHJcbiAgICAgICAgdGhpcy5vcmRlciA9IG9wdGlvbnMub3JkZXIgPT09IHVuZGVmaW5lZCA/IDEgOiBvcHRpb25zLm9yZGVyO1xyXG4gICAgICAgIHRoaXMudHlwZSA9IG9wdGlvbnMudHlwZSB8fCAnJztcclxuICAgICAgICB0aGlzLmNsYXNzID0gb3B0aW9ucy5jbGFzcyB8fCAnJztcclxuICAgIH1cclxufVxyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvYW5ndWxhcjItdGVtcGxhdGUtbG9hZGVyIS4vQ2xpZW50QXBwL2FwcC9zaGFyZWQvZm9ybXMvY29udHJvbC1iYXNlLnRzIiwiaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBSZWdpc3Rlck1vZGVsIH0gZnJvbSAnLi4vbW9kZWxzL3JlZ2lzdGVyLW1vZGVsJztcclxuaW1wb3J0IHsgSHR0cEhlYWRlcnMsIEh0dHBDbGllbnQgfSBmcm9tICdAYW5ndWxhci9jb21tb24vaHR0cCc7XHJcblxyXG5pbXBvcnQgeyBMb2dpbk1vZGVsIH0gZnJvbSAnLi4vbW9kZWxzL2xvZ2luLW1vZGVsJztcclxuaW1wb3J0IHsgVXRpbGl0eVNlcnZpY2UgfSBmcm9tICcuLi8uLi9jb3JlL3NlcnZpY2VzL3V0aWxpdHkuc2VydmljZSc7XHJcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICdyeGpzL09ic2VydmFibGUnO1xyXG5pbXBvcnQgeyBBdXRoVG9rZW5Nb2RlbCB9IGZyb20gJy4uL21vZGVscy9hdXRoLXRva2Vucy1tb2RlbCc7XHJcbmltcG9ydCB7IEp3dEhlbHBlciB9IGZyb20gJ2FuZ3VsYXIyLWp3dCc7XHJcbmltcG9ydCB7IFByb2ZpbGVNb2RlbCB9IGZyb20gJy4uL21vZGVscy9wcm9maWxlLW1vZGVsJztcclxuXHJcbkBJbmplY3RhYmxlKClcclxuZXhwb3J0IGNsYXNzIEFjY291bnRTZXJ2aWNlIHtcclxuICAgIHByaXZhdGUgdG9rZW5LZXkgPSAnYXV0aC10b2tlbic7XHJcbiAgICBwdWJsaWMgand0SGVscGVyOiBKd3RIZWxwZXIgPSBuZXcgSnd0SGVscGVyKCk7XHJcblxyXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBodHRwOiBIdHRwQ2xpZW50LCBwcml2YXRlIHV0aWxpdHlTZXJ2aWNlOiBVdGlsaXR5U2VydmljZSkgeyB9XHJcblxyXG4gICAgcHVibGljIGdldCBpc0xvZ2dlZEluKCk6IGJvb2xlYW4ge1xyXG4gICAgICAgIGlmICh0aGlzLmFjY2Vzc1Rva2VuKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAhdGhpcy5qd3RIZWxwZXIuaXNUb2tlbkV4cGlyZWQodGhpcy5hY2Nlc3NUb2tlbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIHB1YmxpYyBnZXQgdXNlcigpOiBQcm9maWxlTW9kZWwgfCB1bmRlZmluZWQge1xyXG4gICAgICAgIGlmICh0aGlzLmFjY2Vzc1Rva2VuKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmp3dEhlbHBlci5kZWNvZGVUb2tlbih0aGlzLmFjY2Vzc1Rva2VuKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgbG9naW4odXNlcjogTG9naW5Nb2RlbCk6IE9ic2VydmFibGU8YW55PiB7XHJcbiAgICAgICAgLy8gZGF0YSBjYW4gYmUgYW55IHNpbmNlIGl0IGNhbiBlaXRoZXIgYmUgYSByZWZyZXNoIHRva2VucyBvciBsb2dpbiBkZXRhaWxzXHJcbiAgICAgICAgLy8gVGhlIHJlcXVlc3QgZm9yIHRva2VucyBtdXN0IGJlIHgtd3d3LWZvcm0tdXJsZW5jb2RlZFxyXG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSBuZXcgSHR0cEhlYWRlcnMoeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcgfSk7XHJcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHsgaGVhZGVycyB9O1xyXG4gICAgICAgIE9iamVjdC5hc3NpZ24odXNlciwge1xyXG4gICAgICAgICAgICBncmFudF90eXBlOiAncGFzc3dvcmQnLFxyXG4gICAgICAgICAgICAvLyBvZmZsaW5lX2FjY2VzcyBpcyByZXF1aXJlZCBmb3IgYSByZWZyZXNoIHRva2VuXHJcbiAgICAgICAgICAgIHNjb3BlOiBbJ29wZW5pZCBvZmZsaW5lX2FjY2VzcyBjbGllbnRfaWQgcHJvZmlsZSBlbWFpbCByb2xlcyddXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLmh0dHAucG9zdCgnL2Nvbm5lY3QvdG9rZW4nLCB0aGlzLmVuY29kZU9iamVjdFRvUGFyYW1zKHVzZXIpLCBvcHRpb25zKVxyXG4gICAgICAgICAgICAubWFwKCh0b2tlbnM6IEF1dGhUb2tlbk1vZGVsKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpO1xyXG4gICAgICAgICAgICAgICAgdG9rZW5zLmV4cGlyYXRpb25fZGF0ZSA9IG5ldyBEYXRlKG5vdy5nZXRUaW1lKCkgKyAodG9rZW5zLmV4cGlyZXNfaW4gPyAodG9rZW5zLmV4cGlyZXNfaW4gKiAxMDAwKSA6IDApKS5nZXRUaW1lKCkudG9TdHJpbmcoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBjb25zdCBwcm9maWxlID0gdGhpcy5qd3RIZWxwZXIuZGVjb2RlVG9rZW4odG9rZW5zLmlkX3Rva2VuID8gdG9rZW5zLmlkX3Rva2VuIDogJycpIGFzIFByb2ZpbGVNb2RlbDtcclxuXHJcbiAgICAgICAgICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSh0aGlzLnRva2VuS2V5LCBKU09OLnN0cmluZ2lmeSh0b2tlbnMpKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgcmVnaXN0ZXIoZGF0YTogUmVnaXN0ZXJNb2RlbCk6IE9ic2VydmFibGU8YW55PiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaHR0cC5wb3N0KCdhcGkvYWNjb3VudC9yZWdpc3RlcicsIGRhdGEpXHJcbiAgICAgICAgICAgIC5jYXRjaCgocmVzOiBhbnkpID0+IE9ic2VydmFibGUudGhyb3cocmVzLmpzb24oKSkpO1xyXG4gICAgfVxyXG4gICAgcHVibGljIGxvZ291dCgpIHtcclxuICAgICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSh0aGlzLnRva2VuS2V5KTtcclxuICAgICAgICB0aGlzLnV0aWxpdHlTZXJ2aWNlLm5hdmlnYXRlVG9TaWduSW4oKTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGVuY29kZU9iamVjdFRvUGFyYW1zKG9iajogYW55KTogc3RyaW5nIHtcclxuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMob2JqKVxyXG4gICAgICAgICAgICAubWFwKGtleSA9PiBlbmNvZGVVUklDb21wb25lbnQoa2V5KSArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudChvYmpba2V5XSkpXHJcbiAgICAgICAgICAgIC5qb2luKCcmJyk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBnZXQgYWNjZXNzVG9rZW4oKTogc3RyaW5nIHtcclxuICAgICAgICBsZXQgdG9rZW4gPSAnJztcclxuICAgICAgICBjb25zdCB0aWNrZXQgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSh0aGlzLnRva2VuS2V5KTtcclxuICAgICAgICBpZiAodGlja2V0KSB7XHJcbiAgICAgICAgICAgIHRva2VuID0gSlNPTi5wYXJzZSg8YW55PnRpY2tldCkuaWRfdG9rZW47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0b2tlbjtcclxuICAgIH1cclxuXHJcbn1cclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2FuZ3VsYXIyLXRlbXBsYXRlLWxvYWRlciEuL0NsaWVudEFwcC9hcHAvY29yZS9zZXJ2aWNlcy9hY2NvdW50LnNlcnZpY2UudHMiLCIvKipcbiAqIEBsaWNlbnNlIEFuZ3VsYXIgdjUuMC4wLWJldGEuN1xuICogKGMpIDIwMTAtMjAxNyBHb29nbGUsIEluYy4gaHR0cHM6Ly9hbmd1bGFyLmlvL1xuICogTGljZW5zZTogTUlUXG4gKi9cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG5cdHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cywgcmVxdWlyZSgnQGFuZ3VsYXIvY29yZScpLCByZXF1aXJlKCdAYW5ndWxhci9wbGF0Zm9ybS1icm93c2VyJyksIHJlcXVpcmUoJ0Bhbmd1bGFyL2FuaW1hdGlvbnMvYnJvd3NlcicpLCByZXF1aXJlKCdAYW5ndWxhci9jb21tb24nKSwgcmVxdWlyZSgnQGFuZ3VsYXIvY29tbW9uL2h0dHAnKSwgcmVxdWlyZSgnQGFuZ3VsYXIvaHR0cCcpLCByZXF1aXJlKCdAYW5ndWxhci9wbGF0Zm9ybS1icm93c2VyLWR5bmFtaWMnKSwgcmVxdWlyZSgnQGFuZ3VsYXIvcGxhdGZvcm0tYnJvd3Nlci9hbmltYXRpb25zJyksIHJlcXVpcmUoJ3J4anMvT2JzZXJ2YWJsZScpLCByZXF1aXJlKCdyeGpzL1N1YmplY3QnKSwgcmVxdWlyZSgndXJsJyksIHJlcXVpcmUoJ0Bhbmd1bGFyL2NvbXBpbGVyJyksIHJlcXVpcmUoJ3J4anMvb3BlcmF0b3IvZmlsdGVyJyksIHJlcXVpcmUoJ3J4anMvb3BlcmF0b3IvZmlyc3QnKSwgcmVxdWlyZSgncnhqcy9vcGVyYXRvci90b1Byb21pc2UnKSkgOlxuXHR0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJywgJ0Bhbmd1bGFyL2NvcmUnLCAnQGFuZ3VsYXIvcGxhdGZvcm0tYnJvd3NlcicsICdAYW5ndWxhci9hbmltYXRpb25zL2Jyb3dzZXInLCAnQGFuZ3VsYXIvY29tbW9uJywgJ0Bhbmd1bGFyL2NvbW1vbi9odHRwJywgJ0Bhbmd1bGFyL2h0dHAnLCAnQGFuZ3VsYXIvcGxhdGZvcm0tYnJvd3Nlci1keW5hbWljJywgJ0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXIvYW5pbWF0aW9ucycsICdyeGpzL09ic2VydmFibGUnLCAncnhqcy9TdWJqZWN0JywgJ3VybCcsICdAYW5ndWxhci9jb21waWxlcicsICdyeGpzL29wZXJhdG9yL2ZpbHRlcicsICdyeGpzL29wZXJhdG9yL2ZpcnN0JywgJ3J4anMvb3BlcmF0b3IvdG9Qcm9taXNlJ10sIGZhY3RvcnkpIDpcblx0KGZhY3RvcnkoKGdsb2JhbC5uZyA9IGdsb2JhbC5uZyB8fCB7fSwgZ2xvYmFsLm5nLnBsYXRmb3JtU2VydmVyID0ge30pLGdsb2JhbC5uZy5jb3JlLGdsb2JhbC5uZy5wbGF0Zm9ybUJyb3dzZXIsZ2xvYmFsLl9hbmd1bGFyX2FuaW1hdGlvbnNfYnJvd3NlcixnbG9iYWwubmcuY29tbW9uLGdsb2JhbC5fYW5ndWxhcl9jb21tb25faHR0cCxnbG9iYWwuX2FuZ3VsYXJfaHR0cCxnbG9iYWwuX2FuZ3VsYXJfcGxhdGZvcm1Ccm93c2VyRHluYW1pYyxnbG9iYWwuX2FuZ3VsYXJfcGxhdGZvcm1Ccm93c2VyX2FuaW1hdGlvbnMsZ2xvYmFsLlJ4LGdsb2JhbC5SeCxnbG9iYWwudXJsLGdsb2JhbC5uZy5jb21waWxlcixnbG9iYWwuUnguT2JzZXJ2YWJsZS5wcm90b3R5cGUsZ2xvYmFsLlJ4Lk9ic2VydmFibGUucHJvdG90eXBlLGdsb2JhbC5SeC5PYnNlcnZhYmxlLnByb3RvdHlwZSkpO1xufSh0aGlzLCAoZnVuY3Rpb24gKGV4cG9ydHMsX2FuZ3VsYXJfY29yZSxfYW5ndWxhcl9wbGF0Zm9ybUJyb3dzZXIsX2FuZ3VsYXJfYW5pbWF0aW9uc19icm93c2VyLF9hbmd1bGFyX2NvbW1vbixfYW5ndWxhcl9jb21tb25faHR0cCxfYW5ndWxhcl9odHRwLF9hbmd1bGFyX3BsYXRmb3JtQnJvd3NlckR5bmFtaWMsX2FuZ3VsYXJfcGxhdGZvcm1Ccm93c2VyX2FuaW1hdGlvbnMscnhqc19PYnNlcnZhYmxlLHJ4anNfU3ViamVjdCx1cmwsX2FuZ3VsYXJfY29tcGlsZXIscnhqc19vcGVyYXRvcl9maWx0ZXIscnhqc19vcGVyYXRvcl9maXJzdCxyeGpzX29wZXJhdG9yX3RvUHJvbWlzZSkgeyAndXNlIHN0cmljdCc7XG5cbi8qISAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlXHJcbnRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlXHJcbkxpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcblxyXG5USElTIENPREUgSVMgUFJPVklERUQgT04gQU4gKkFTIElTKiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbktJTkQsIEVJVEhFUiBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBXSVRIT1VUIExJTUlUQVRJT04gQU5ZIElNUExJRURcclxuV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIFRJVExFLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSxcclxuTUVSQ0hBTlRBQkxJVFkgT1IgTk9OLUlORlJJTkdFTUVOVC5cclxuXHJcblNlZSB0aGUgQXBhY2hlIFZlcnNpb24gMi4wIExpY2Vuc2UgZm9yIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9uc1xyXG5hbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcbi8qIGdsb2JhbCBSZWZsZWN0LCBQcm9taXNlICovXHJcblxyXG52YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XHJcblxyXG5mdW5jdGlvbiBfX2V4dGVuZHMoZCwgYikge1xyXG4gICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG59XG5cbi8qKlxuICogQGxpY2Vuc2UgQW5ndWxhciB2NS4wLjAtYmV0YS43XG4gKiAoYykgMjAxMC0yMDE3IEdvb2dsZSwgSW5jLiBodHRwczovL2FuZ3VsYXIuaW8vXG4gKiBMaWNlbnNlOiBNSVRcbiAqL1xuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IGFkZGVkIGJ5IHRzaWNrbGVcbiAqIEBzdXBwcmVzcyB7Y2hlY2tUeXBlc30gY2hlY2tlZCBieSB0c2NcbiAqL1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xudmFyIGRvbWlubyA9IHJlcXVpcmUoJ2RvbWlubycpO1xuLyoqXG4gKiBAcGFyYW0gez99IG1ldGhvZE5hbWVcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIF9ub3RJbXBsZW1lbnRlZChtZXRob2ROYW1lKSB7XG4gICAgcmV0dXJuIG5ldyBFcnJvcignVGhpcyBtZXRob2QgaXMgbm90IGltcGxlbWVudGVkIGluIERvbWlub0FkYXB0ZXI6ICcgKyBtZXRob2ROYW1lKTtcbn1cbi8qKlxuICogUGFyc2VzIGEgZG9jdW1lbnQgc3RyaW5nIHRvIGEgRG9jdW1lbnQgb2JqZWN0LlxuICogQHBhcmFtIHs/fSBodG1sXG4gKiBAcGFyYW0gez89fSB1cmxcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIHBhcnNlRG9jdW1lbnQoaHRtbCwgdXJsJCQxKSB7XG4gICAgaWYgKHVybCQkMSA9PT0gdm9pZCAwKSB7IHVybCQkMSA9ICcvJzsgfVxuICAgIHZhciAvKiogQHR5cGUgez99ICovIHdpbmRvdyA9IGRvbWluby5jcmVhdGVXaW5kb3coaHRtbCwgdXJsJCQxKTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkb2MgPSB3aW5kb3cuZG9jdW1lbnQ7XG4gICAgcmV0dXJuIGRvYztcbn1cbi8qKlxuICogU2VyaWFsaXplcyBhIGRvY3VtZW50IHRvIHN0cmluZy5cbiAqIEBwYXJhbSB7P30gZG9jXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBzZXJpYWxpemVEb2N1bWVudChkb2MpIHtcbiAgICByZXR1cm4gKC8qKiBAdHlwZSB7P30gKi8gKGRvYykpLnNlcmlhbGl6ZSgpO1xufVxuLyoqXG4gKiBET00gQWRhcHRlciBmb3IgdGhlIHNlcnZlciBwbGF0Zm9ybSBiYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vZmduYXNzL2RvbWluby5cbiAqL1xudmFyIERvbWlub0FkYXB0ZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhEb21pbm9BZGFwdGVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIERvbWlub0FkYXB0ZXIoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBEb21pbm9BZGFwdGVyLm1ha2VDdXJyZW50ID0gLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoKSB7IF9hbmd1bGFyX3BsYXRmb3JtQnJvd3Nlci7JtXNldFJvb3REb21BZGFwdGVyKG5ldyBEb21pbm9BZGFwdGVyKCkpOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZXJyb3JcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIERvbWlub0FkYXB0ZXIucHJvdG90eXBlLmxvZ0Vycm9yID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBlcnJvclxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKGVycm9yKSB7IGNvbnNvbGUuZXJyb3IoZXJyb3IpOyB9O1xuICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1jb25zb2xlXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBlcnJvclxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRG9taW5vQWRhcHRlci5wcm90b3R5cGUubG9nID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBlcnJvclxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKGVycm9yKSB7IGNvbnNvbGUubG9nKGVycm9yKTsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVycm9yXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBEb21pbm9BZGFwdGVyLnByb3RvdHlwZS5sb2dHcm91cCA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gZXJyb3JcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChlcnJvcikgeyBjb25zb2xlLmVycm9yKGVycm9yKTsgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIERvbWlub0FkYXB0ZXIucHJvdG90eXBlLmxvZ0dyb3VwRW5kID0gLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoKSB7IH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBEb21pbm9BZGFwdGVyLnByb3RvdHlwZS5zdXBwb3J0c0RPTUV2ZW50cyA9IC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKCkgeyByZXR1cm4gZmFsc2U7IH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBEb21pbm9BZGFwdGVyLnByb3RvdHlwZS5zdXBwb3J0c05hdGl2ZVNoYWRvd0RPTSA9IC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKCkgeyByZXR1cm4gZmFsc2U7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBub2RlQVxuICAgICAqIEBwYXJhbSB7P30gbm9kZUJcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIERvbWlub0FkYXB0ZXIucHJvdG90eXBlLmNvbnRhaW5zID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBub2RlQVxuICAgICAqIEBwYXJhbSB7P30gbm9kZUJcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChub2RlQSwgbm9kZUIpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaW5uZXIgPSBub2RlQjtcbiAgICAgICAgd2hpbGUgKGlubmVyKSB7XG4gICAgICAgICAgICBpZiAoaW5uZXIgPT09IG5vZGVBKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgaW5uZXIgPSBpbm5lci5wYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBEb21pbm9BZGFwdGVyLnByb3RvdHlwZS5jcmVhdGVIdG1sRG9jdW1lbnQgPSAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlRG9jdW1lbnQoJzxodG1sPjxoZWFkPjx0aXRsZT5mYWtlVGl0bGU8L3RpdGxlPjwvaGVhZD48Ym9keT48L2JvZHk+PC9odG1sPicpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBEb21pbm9BZGFwdGVyLnByb3RvdHlwZS5nZXREZWZhdWx0RG9jdW1lbnQgPSAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFEb21pbm9BZGFwdGVyLmRlZmF1bHREb2MpIHtcbiAgICAgICAgICAgIERvbWlub0FkYXB0ZXIuZGVmYXVsdERvYyA9IGRvbWluby5jcmVhdGVEb2N1bWVudCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBEb21pbm9BZGFwdGVyLmRlZmF1bHREb2M7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsXG4gICAgICogQHBhcmFtIHs/PX0gZG9jXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBEb21pbm9BZGFwdGVyLnByb3RvdHlwZS5jcmVhdGVTaGFkb3dSb290ID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbFxuICAgICAqIEBwYXJhbSB7Pz19IGRvY1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKGVsLCBkb2MpIHtcbiAgICAgICAgaWYgKGRvYyA9PT0gdm9pZCAwKSB7IGRvYyA9IGRvY3VtZW50OyB9XG4gICAgICAgIGVsLnNoYWRvd1Jvb3QgPSBkb2MuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICAgICAgICBlbC5zaGFkb3dSb290LnBhcmVudCA9IGVsO1xuICAgICAgICByZXR1cm4gZWwuc2hhZG93Um9vdDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZWxcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIERvbWlub0FkYXB0ZXIucHJvdG90eXBlLmdldFNoYWRvd1Jvb3QgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoZWwpIHsgcmV0dXJuIGVsLnNoYWRvd1Jvb3Q7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBub2RlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBEb21pbm9BZGFwdGVyLnByb3RvdHlwZS5pc1RleHROb2RlID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBub2RlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gbm9kZS5ub2RlVHlwZSA9PT0gRG9taW5vQWRhcHRlci5kZWZhdWx0RG9jLlRFWFRfTk9ERTsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5vZGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIERvbWlub0FkYXB0ZXIucHJvdG90eXBlLmlzQ29tbWVudE5vZGUgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IG5vZGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHJldHVybiBub2RlLm5vZGVUeXBlID09PSBEb21pbm9BZGFwdGVyLmRlZmF1bHREb2MuQ09NTUVOVF9OT0RFO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBub2RlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBEb21pbm9BZGFwdGVyLnByb3RvdHlwZS5pc0VsZW1lbnROb2RlID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBub2RlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICByZXR1cm4gbm9kZSA/IG5vZGUubm9kZVR5cGUgPT09IERvbWlub0FkYXB0ZXIuZGVmYXVsdERvYy5FTEVNRU5UX05PREUgOiBmYWxzZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbm9kZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRG9taW5vQWRhcHRlci5wcm90b3R5cGUuaGFzU2hhZG93Um9vdCA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gbm9kZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIG5vZGUuc2hhZG93Um9vdCAhPSBudWxsOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbm9kZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRG9taW5vQWRhcHRlci5wcm90b3R5cGUuaXNTaGFkb3dSb290ID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBub2RlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gdGhpcy5nZXRTaGFkb3dSb290KG5vZGUpID09IG5vZGU7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbFxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRG9taW5vQWRhcHRlci5wcm90b3R5cGUuZ2V0UHJvcGVydHkgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoZWwsIG5hbWUpIHtcbiAgICAgICAgaWYgKG5hbWUgPT09ICdocmVmJykge1xuICAgICAgICAgICAgLy8gRG9taW5vIHRyaWVzIHRwIHJlc29sdmUgaHJlZi1zIHdoaWNoIHdlIGRvIG5vdCB3YW50LiBKdXN0IHJldHVybiB0aGVcbiAgICAgICAgICAgIC8vIGF0cmlidXRlIHZhbHVlLlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QXR0cmlidXRlKGVsLCAnaHJlZicpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5hbWUgPT09ICdpbm5lclRleHQnKSB7XG4gICAgICAgICAgICAvLyBEb21pbm8gZG9lcyBub3Qgc3VwcG9ydCBpbm5lclRleHQuIEp1c3QgbWFwIGl0IHRvIHRleHRDb250ZW50LlxuICAgICAgICAgICAgcmV0dXJuIGVsLnRleHRDb250ZW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoLyoqIEB0eXBlIHs/fSAqLyAoZWwpKVtuYW1lXTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZWxcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBEb21pbm9BZGFwdGVyLnByb3RvdHlwZS5zZXRQcm9wZXJ0eSA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gZWxcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoZWwsIG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIGlmIChuYW1lID09PSAnaHJlZicpIHtcbiAgICAgICAgICAgIC8vIEV2ZW50aG91Z2ggdGhlIHNlcnZlciByZW5kZXJlciByZWZsZWN0cyBhbnkgcHJvcGVydGllcyB0byBhdHRyaWJ1dGVzXG4gICAgICAgICAgICAvLyBtYXAgJ2hyZWYnIHRvIGF0cmlidXRlIGp1c3QgdG8gaGFuZGxlIHdoZW4gc2V0UHJvcGVydHkgaXMgZGlyZWN0bHkgY2FsbGVkLlxuICAgICAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoZWwsICdocmVmJywgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5hbWUgPT09ICdpbm5lclRleHQnKSB7XG4gICAgICAgICAgICAvLyBEb21pbm8gZG9lcyBub3Qgc3VwcG9ydCBpbm5lclRleHQuIEp1c3QgbWFwIGl0IHRvIHRleHRDb250ZW50LlxuICAgICAgICAgICAgZWwudGV4dENvbnRlbnQgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICAoLyoqIEB0eXBlIHs/fSAqLyAoZWwpKVtuYW1lXSA9IHZhbHVlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBkb2NcbiAgICAgKiBAcGFyYW0gez99IHRhcmdldFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRG9taW5vQWRhcHRlci5wcm90b3R5cGUuZ2V0R2xvYmFsRXZlbnRUYXJnZXQgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IGRvY1xuICAgICAqIEBwYXJhbSB7P30gdGFyZ2V0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoZG9jLCB0YXJnZXQpIHtcbiAgICAgICAgaWYgKHRhcmdldCA9PT0gJ3dpbmRvdycpIHtcbiAgICAgICAgICAgIHJldHVybiBkb2MuZGVmYXVsdFZpZXc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRhcmdldCA9PT0gJ2RvY3VtZW50Jykge1xuICAgICAgICAgICAgcmV0dXJuIGRvYztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGFyZ2V0ID09PSAnYm9keScpIHtcbiAgICAgICAgICAgIHJldHVybiBkb2MuYm9keTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZG9jXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBEb21pbm9BZGFwdGVyLnByb3RvdHlwZS5nZXRCYXNlSHJlZiA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gZG9jXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoZG9jKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGJhc2UgPSB0aGlzLnF1ZXJ5U2VsZWN0b3IoZG9jLmRvY3VtZW50RWxlbWVudCwgJ2Jhc2UnKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaHJlZiA9ICcnO1xuICAgICAgICBpZiAoYmFzZSkge1xuICAgICAgICAgICAgaHJlZiA9IHRoaXMuZ2V0SHJlZihiYXNlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUT0RPKGFseGh1Yik6IE5lZWQgcmVsYXRpdmUgcGF0aCBsb2dpYyBmcm9tIEJyb3dzZXJEb21BZGFwdGVyIGhlcmU/XG4gICAgICAgIHJldHVybiBocmVmO1xuICAgIH07XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIC8qKlxuICAgICAqIFxcQGludGVybmFsXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBEb21pbm9BZGFwdGVyLnByb3RvdHlwZS5fcmVhZFN0eWxlQXR0cmlidXRlID0gLyoqXG4gICAgICogXFxAaW50ZXJuYWxcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0eWxlTWFwID0ge307XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0eWxlQXR0cmlidXRlID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3N0eWxlJyk7XG4gICAgICAgIGlmIChzdHlsZUF0dHJpYnV0ZSkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3R5bGVMaXN0ID0gc3R5bGVBdHRyaWJ1dGUuc3BsaXQoLzsrL2cpO1xuICAgICAgICAgICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBpID0gMDsgaSA8IHN0eWxlTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChzdHlsZUxpc3RbaV0ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdHlsZSA9IC8qKiBAdHlwZSB7P30gKi8gKHN0eWxlTGlzdFtpXSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNvbG9uID0gc3R5bGUuaW5kZXhPZignOicpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29sb24gPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIENTUyBzdHlsZTogXCIgKyBzdHlsZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgKC8qKiBAdHlwZSB7P30gKi8gKHN0eWxlTWFwKSlbc3R5bGUuc3Vic3RyKDAsIGNvbG9uKS50cmltKCldID0gc3R5bGUuc3Vic3RyKGNvbG9uICsgMSkudHJpbSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3R5bGVNYXA7XG4gICAgfTtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgLyoqXG4gICAgICogXFxAaW50ZXJuYWxcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0gez99IHN0eWxlTWFwXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBEb21pbm9BZGFwdGVyLnByb3RvdHlwZS5fd3JpdGVTdHlsZUF0dHJpYnV0ZSA9IC8qKlxuICAgICAqIFxcQGludGVybmFsXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XG4gICAgICogQHBhcmFtIHs/fSBzdHlsZU1hcFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKGVsZW1lbnQsIHN0eWxlTWFwKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0eWxlQXR0clZhbHVlID0gJyc7XG4gICAgICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8ga2V5IGluIHN0eWxlTWFwKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBuZXdWYWx1ZSA9IHN0eWxlTWFwW2tleV07XG4gICAgICAgICAgICBpZiAobmV3VmFsdWUpIHtcbiAgICAgICAgICAgICAgICBzdHlsZUF0dHJWYWx1ZSArPSBrZXkgKyAnOicgKyBzdHlsZU1hcFtrZXldICsgJzsnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdzdHlsZScsIHN0eWxlQXR0clZhbHVlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFxuICAgICAqIEBwYXJhbSB7P30gc3R5bGVOYW1lXG4gICAgICogQHBhcmFtIHs/PX0gc3R5bGVWYWx1ZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRG9taW5vQWRhcHRlci5wcm90b3R5cGUuc2V0U3R5bGUgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0gez99IHN0eWxlTmFtZVxuICAgICAqIEBwYXJhbSB7Pz19IHN0eWxlVmFsdWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChlbGVtZW50LCBzdHlsZU5hbWUsIHN0eWxlVmFsdWUpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3R5bGVNYXAgPSB0aGlzLl9yZWFkU3R5bGVBdHRyaWJ1dGUoZWxlbWVudCk7XG4gICAgICAgICgvKiogQHR5cGUgez99ICovIChzdHlsZU1hcCkpW3N0eWxlTmFtZV0gPSBzdHlsZVZhbHVlO1xuICAgICAgICB0aGlzLl93cml0ZVN0eWxlQXR0cmlidXRlKGVsZW1lbnQsIHN0eWxlTWFwKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFxuICAgICAqIEBwYXJhbSB7P30gc3R5bGVOYW1lXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBEb21pbm9BZGFwdGVyLnByb3RvdHlwZS5yZW1vdmVTdHlsZSA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFxuICAgICAqIEBwYXJhbSB7P30gc3R5bGVOYW1lXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoZWxlbWVudCwgc3R5bGVOYW1lKSB7IHRoaXMuc2V0U3R5bGUoZWxlbWVudCwgc3R5bGVOYW1lLCBudWxsKTsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0gez99IHN0eWxlTmFtZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRG9taW5vQWRhcHRlci5wcm90b3R5cGUuZ2V0U3R5bGUgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0gez99IHN0eWxlTmFtZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKGVsZW1lbnQsIHN0eWxlTmFtZSkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdHlsZU1hcCA9IHRoaXMuX3JlYWRTdHlsZUF0dHJpYnV0ZShlbGVtZW50KTtcbiAgICAgICAgcmV0dXJuIHN0eWxlTWFwLmhhc093blByb3BlcnR5KHN0eWxlTmFtZSkgPyAoLyoqIEB0eXBlIHs/fSAqLyAoc3R5bGVNYXApKVtzdHlsZU5hbWVdIDogJyc7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0gez99IHN0eWxlTmFtZVxuICAgICAqIEBwYXJhbSB7Pz19IHN0eWxlVmFsdWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIERvbWlub0FkYXB0ZXIucHJvdG90eXBlLmhhc1N0eWxlID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XG4gICAgICogQHBhcmFtIHs/fSBzdHlsZU5hbWVcbiAgICAgKiBAcGFyYW0gez89fSBzdHlsZVZhbHVlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoZWxlbWVudCwgc3R5bGVOYW1lLCBzdHlsZVZhbHVlKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHZhbHVlID0gdGhpcy5nZXRTdHlsZShlbGVtZW50LCBzdHlsZU5hbWUpIHx8ICcnO1xuICAgICAgICByZXR1cm4gc3R5bGVWYWx1ZSA/IHZhbHVlID09IHN0eWxlVmFsdWUgOiB2YWx1ZS5sZW5ndGggPiAwO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbFxuICAgICAqIEBwYXJhbSB7P30gZXZ0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBEb21pbm9BZGFwdGVyLnByb3RvdHlwZS5kaXNwYXRjaEV2ZW50ID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbFxuICAgICAqIEBwYXJhbSB7P30gZXZ0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoZWwsIGV2dCkge1xuICAgICAgICBlbC5kaXNwYXRjaEV2ZW50KGV2dCk7XG4gICAgICAgIC8vIERpc3BhdGNoIHRoZSBldmVudCB0byB0aGUgd2luZG93IGFsc28uXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGRvYyA9IGVsLm93bmVyRG9jdW1lbnQgfHwgZWw7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHdpbiA9ICgvKiogQHR5cGUgez99ICovIChkb2MpKS5kZWZhdWx0VmlldztcbiAgICAgICAgaWYgKHdpbikge1xuICAgICAgICAgICAgd2luLmRpc3BhdGNoRXZlbnQoZXZ0KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBEb21pbm9BZGFwdGVyLnByb3RvdHlwZS5nZXRIaXN0b3J5ID0gLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoKSB7IHRocm93IF9ub3RJbXBsZW1lbnRlZCgnZ2V0SGlzdG9yeScpOyB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRG9taW5vQWRhcHRlci5wcm90b3R5cGUuZ2V0TG9jYXRpb24gPSAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uICgpIHsgdGhyb3cgX25vdEltcGxlbWVudGVkKCdnZXRMb2NhdGlvbicpOyB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRG9taW5vQWRhcHRlci5wcm90b3R5cGUuZ2V0VXNlckFnZW50ID0gLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoKSB7IHJldHVybiAnRmFrZSB1c2VyIGFnZW50JzsgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIERvbWlub0FkYXB0ZXIucHJvdG90eXBlLnN1cHBvcnRzV2ViQW5pbWF0aW9uID0gLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoKSB7IHJldHVybiBmYWxzZTsgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIERvbWlub0FkYXB0ZXIucHJvdG90eXBlLnBlcmZvcm1hbmNlTm93ID0gLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoKSB7IHJldHVybiBEYXRlLm5vdygpOyB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRG9taW5vQWRhcHRlci5wcm90b3R5cGUuZ2V0QW5pbWF0aW9uUHJlZml4ID0gLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoKSB7IHJldHVybiAnJzsgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIERvbWlub0FkYXB0ZXIucHJvdG90eXBlLmdldFRyYW5zaXRpb25FbmQgPSAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uICgpIHsgcmV0dXJuICd0cmFuc2l0aW9uZW5kJzsgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIERvbWlub0FkYXB0ZXIucHJvdG90eXBlLnN1cHBvcnRzQW5pbWF0aW9uID0gLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoKSB7IHJldHVybiB0cnVlOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZWxcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIERvbWlub0FkYXB0ZXIucHJvdG90eXBlLmdldERpc3RyaWJ1dGVkTm9kZXMgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoZWwpIHsgdGhyb3cgX25vdEltcGxlbWVudGVkKCdnZXREaXN0cmlidXRlZE5vZGVzJyk7IH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBEb21pbm9BZGFwdGVyLnByb3RvdHlwZS5zdXBwb3J0c0Nvb2tpZXMgPSAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZhbHNlOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRG9taW5vQWRhcHRlci5wcm90b3R5cGUuZ2V0Q29va2llID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAobmFtZSkgeyB0aHJvdyBfbm90SW1wbGVtZW50ZWQoJ2dldENvb2tpZScpOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIERvbWlub0FkYXB0ZXIucHJvdG90eXBlLnNldENvb2tpZSA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkgeyB0aHJvdyBfbm90SW1wbGVtZW50ZWQoJ3NldENvb2tpZScpOyB9O1xuICAgIHJldHVybiBEb21pbm9BZGFwdGVyO1xufShfYW5ndWxhcl9wbGF0Zm9ybUJyb3dzZXIuybVCcm93c2VyRG9tQWRhcHRlcikpO1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgYWRkZWQgYnkgdHNpY2tsZVxuICogQHN1cHByZXNzIHtjaGVja1R5cGVzfSBjaGVja2VkIGJ5IHRzY1xuICovXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vKipcbiAqIFJlcHJlc2VudGF0aW9uIG9mIHRoZSBjdXJyZW50IHBsYXRmb3JtIHN0YXRlLlxuICpcbiAqIFxcQGV4cGVyaW1lbnRhbFxuICovXG52YXIgUGxhdGZvcm1TdGF0ZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUGxhdGZvcm1TdGF0ZShfZG9jKSB7XG4gICAgICAgIHRoaXMuX2RvYyA9IF9kb2M7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIHBsYXRmb3JtIHRvIHN0cmluZy5cbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSBwbGF0Zm9ybSB0byBzdHJpbmcuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBQbGF0Zm9ybVN0YXRlLnByb3RvdHlwZS5yZW5kZXJUb1N0cmluZyA9IC8qKlxuICAgICAqIFJlbmRlcnMgdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIHBsYXRmb3JtIHRvIHN0cmluZy5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNlcmlhbGl6ZURvY3VtZW50KHRoaXMuX2RvYyk7IH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY3VycmVudCBET00gc3RhdGUuXG4gICAgICovXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY3VycmVudCBET00gc3RhdGUuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBQbGF0Zm9ybVN0YXRlLnByb3RvdHlwZS5nZXREb2N1bWVudCA9IC8qKlxuICAgICAqIFJldHVybnMgdGhlIGN1cnJlbnQgRE9NIHN0YXRlLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZG9jOyB9O1xuICAgIFBsYXRmb3JtU3RhdGUuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdGFibGUgfSxcbiAgICBdO1xuICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgIFBsYXRmb3JtU3RhdGUuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgICAgIHsgdHlwZTogdW5kZWZpbmVkLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdCwgYXJnczogW19hbmd1bGFyX3BsYXRmb3JtQnJvd3Nlci5ET0NVTUVOVCxdIH0sXSB9LFxuICAgIF07IH07XG4gICAgcmV0dXJuIFBsYXRmb3JtU3RhdGU7XG59KCkpO1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgYWRkZWQgYnkgdHNpY2tsZVxuICogQHN1cHByZXNzIHtjaGVja1R5cGVzfSBjaGVja2VkIGJ5IHRzY1xuICovXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgeGhyMiA9IHJlcXVpcmUoJ3hocjInKTtcbnZhciBpc0Fic29sdXRlVXJsID0gL15bYS16QS1aXFwtXFwrLl0rOlxcL1xcLy87XG4vKipcbiAqIEBwYXJhbSB7P30gdXJsXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZVJlcXVlc3RVcmwodXJsJCQxKSB7XG4gICAgaWYgKCFpc0Fic29sdXRlVXJsLnRlc3QodXJsJCQxKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVUkxzIHJlcXVlc3RlZCB2aWEgSHR0cCBvbiB0aGUgc2VydmVyIG11c3QgYmUgYWJzb2x1dGUuIFVSTDogXCIgKyB1cmwkJDEpO1xuICAgIH1cbn1cbnZhciBTZXJ2ZXJYaHIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNlcnZlclhocigpIHtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTZXJ2ZXJYaHIucHJvdG90eXBlLmJ1aWxkID0gLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgeGhyMi5YTUxIdHRwUmVxdWVzdCgpOyB9O1xuICAgIFNlcnZlclhoci5kZWNvcmF0b3JzID0gW1xuICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5qZWN0YWJsZSB9LFxuICAgIF07XG4gICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgU2VydmVyWGhyLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH07XG4gICAgcmV0dXJuIFNlcnZlclhocjtcbn0oKSk7XG52YXIgU2VydmVyWHNyZlN0cmF0ZWd5ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTZXJ2ZXJYc3JmU3RyYXRlZ3koKSB7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcmVxXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTZXJ2ZXJYc3JmU3RyYXRlZ3kucHJvdG90eXBlLmNvbmZpZ3VyZVJlcXVlc3QgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IHJlcVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKHJlcSkgeyB9O1xuICAgIFNlcnZlclhzcmZTdHJhdGVneS5kZWNvcmF0b3JzID0gW1xuICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5qZWN0YWJsZSB9LFxuICAgIF07XG4gICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgU2VydmVyWHNyZlN0cmF0ZWd5LmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH07XG4gICAgcmV0dXJuIFNlcnZlclhzcmZTdHJhdGVneTtcbn0oKSk7XG4vKipcbiAqIEBhYnN0cmFjdFxuICovXG52YXIgWm9uZU1hY3JvVGFza1dyYXBwZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFpvbmVNYWNyb1Rhc2tXcmFwcGVyKCkge1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHJlcXVlc3RcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFpvbmVNYWNyb1Rhc2tXcmFwcGVyLnByb3RvdHlwZS53cmFwID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSByZXF1ZXN0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAocmVxdWVzdCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gbmV3IHJ4anNfT2JzZXJ2YWJsZS5PYnNlcnZhYmxlKGZ1bmN0aW9uIChvYnNlcnZlcikge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdGFzayA9IC8qKiBAdHlwZSB7P30gKi8gKChudWxsKSk7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzY2hlZHVsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN1YiA9IG51bGw7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzYXZlZFJlc3VsdCA9IG51bGw7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzYXZlZEVycm9yID0gbnVsbDtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHNjaGVkdWxlVGFzayA9IGZ1bmN0aW9uIChfdGFzaykge1xuICAgICAgICAgICAgICAgIHRhc2sgPSBfdGFzaztcbiAgICAgICAgICAgICAgICBzY2hlZHVsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGRlbGVnYXRlID0gX3RoaXMuZGVsZWdhdGUocmVxdWVzdCk7XG4gICAgICAgICAgICAgICAgc3ViID0gZGVsZWdhdGUuc3Vic2NyaWJlKGZ1bmN0aW9uIChyZXMpIHsgcmV0dXJuIHNhdmVkUmVzdWx0ID0gcmVzOyB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghc2NoZWR1bGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FuIGh0dHAgb2JzZXJ2YWJsZSB3YXMgY29tcGxldGVkIHR3aWNlLiBUaGlzIHNob3VsZG5cXCd0IGhhcHBlbiwgcGxlYXNlIGZpbGUgYSBidWcuJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc2F2ZWRFcnJvciA9IGVycjtcbiAgICAgICAgICAgICAgICAgICAgc2NoZWR1bGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHRhc2suaW52b2tlKCk7XG4gICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXNjaGVkdWxlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBbiBodHRwIG9ic2VydmFibGUgd2FzIGNvbXBsZXRlZCB0d2ljZS4gVGhpcyBzaG91bGRuXFwndCBoYXBwZW4sIHBsZWFzZSBmaWxlIGEgYnVnLicpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHNjaGVkdWxlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB0YXNrLmludm9rZSgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNhbmNlbFRhc2sgPSBmdW5jdGlvbiAoX3Rhc2spIHtcbiAgICAgICAgICAgICAgICBpZiAoIXNjaGVkdWxlZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNjaGVkdWxlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGlmIChzdWIpIHtcbiAgICAgICAgICAgICAgICAgICAgc3ViLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICAgICAgICAgIHN1YiA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG9uQ29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNhdmVkRXJyb3IgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgb2JzZXJ2ZXIuZXJyb3Ioc2F2ZWRFcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBvYnNlcnZlci5uZXh0KHNhdmVkUmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgb2JzZXJ2ZXIuY29tcGxldGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gTW9ja0JhY2tlbmQgZm9yIEh0dHAgaXMgc3luY2hyb25vdXMsIHdoaWNoIG1lYW5zIHRoYXQgaWYgc2NoZWR1bGVUYXNrIGlzIGJ5XG4gICAgICAgICAgICAvLyBzY2hlZHVsZU1hY3JvVGFzaywgdGhlIHJlcXVlc3Qgd2lsbCBoaXQgTW9ja0JhY2tlbmQgYW5kIHRoZSByZXNwb25zZSB3aWxsIGJlXG4gICAgICAgICAgICAvLyBzZW50LCBjYXVzaW5nIHRhc2suaW52b2tlKCkgdG8gYmUgY2FsbGVkLlxuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gX3Rhc2sgPSBab25lLmN1cnJlbnQuc2NoZWR1bGVNYWNyb1Rhc2soJ1pvbmVNYWNyb1Rhc2tXcmFwcGVyLnN1YnNjcmliZScsIG9uQ29tcGxldGUsIHt9LCBmdW5jdGlvbiAoKSB7IHJldHVybiBudWxsOyB9LCBjYW5jZWxUYXNrKTtcbiAgICAgICAgICAgIHNjaGVkdWxlVGFzayhfdGFzayk7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmIChzY2hlZHVsZWQgJiYgdGFzaykge1xuICAgICAgICAgICAgICAgICAgICB0YXNrLnpvbmUuY2FuY2VsVGFzayh0YXNrKTtcbiAgICAgICAgICAgICAgICAgICAgc2NoZWR1bGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzdWIpIHtcbiAgICAgICAgICAgICAgICAgICAgc3ViLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICAgICAgICAgIHN1YiA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gWm9uZU1hY3JvVGFza1dyYXBwZXI7XG59KCkpO1xudmFyIFpvbmVNYWNyb1Rhc2tDb25uZWN0aW9uID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoWm9uZU1hY3JvVGFza0Nvbm5lY3Rpb24sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gWm9uZU1hY3JvVGFza0Nvbm5lY3Rpb24ocmVxdWVzdCwgYmFja2VuZCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5yZXF1ZXN0ID0gcmVxdWVzdDtcbiAgICAgICAgX3RoaXMuYmFja2VuZCA9IGJhY2tlbmQ7XG4gICAgICAgIHZhbGlkYXRlUmVxdWVzdFVybChyZXF1ZXN0LnVybCk7XG4gICAgICAgIF90aGlzLnJlc3BvbnNlID0gX3RoaXMud3JhcChyZXF1ZXN0KTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHJlcXVlc3RcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFpvbmVNYWNyb1Rhc2tDb25uZWN0aW9uLnByb3RvdHlwZS5kZWxlZ2F0ZSA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gcmVxdWVzdFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKHJlcXVlc3QpIHtcbiAgICAgICAgdGhpcy5sYXN0Q29ubmVjdGlvbiA9IHRoaXMuYmFja2VuZC5jcmVhdGVDb25uZWN0aW9uKHJlcXVlc3QpO1xuICAgICAgICByZXR1cm4gLyoqIEB0eXBlIHs/fSAqLyAodGhpcy5sYXN0Q29ubmVjdGlvbi5yZXNwb25zZSk7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoWm9uZU1hY3JvVGFza0Nvbm5lY3Rpb24ucHJvdG90eXBlLCBcInJlYWR5U3RhdGVcIiwge1xuICAgICAgICBnZXQ6IC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICEhdGhpcy5sYXN0Q29ubmVjdGlvbiA/IHRoaXMubGFzdENvbm5lY3Rpb24ucmVhZHlTdGF0ZSA6IF9hbmd1bGFyX2h0dHAuUmVhZHlTdGF0ZS5VbnNlbnQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBab25lTWFjcm9UYXNrQ29ubmVjdGlvbjtcbn0oWm9uZU1hY3JvVGFza1dyYXBwZXIpKTtcbnZhciBab25lTWFjcm9UYXNrQmFja2VuZCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gWm9uZU1hY3JvVGFza0JhY2tlbmQoYmFja2VuZCkge1xuICAgICAgICB0aGlzLmJhY2tlbmQgPSBiYWNrZW5kO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHJlcXVlc3RcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFpvbmVNYWNyb1Rhc2tCYWNrZW5kLnByb3RvdHlwZS5jcmVhdGVDb25uZWN0aW9uID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSByZXF1ZXN0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAocmVxdWVzdCkge1xuICAgICAgICByZXR1cm4gbmV3IFpvbmVNYWNyb1Rhc2tDb25uZWN0aW9uKHJlcXVlc3QsIHRoaXMuYmFja2VuZCk7XG4gICAgfTtcbiAgICByZXR1cm4gWm9uZU1hY3JvVGFza0JhY2tlbmQ7XG59KCkpO1xudmFyIFpvbmVDbGllbnRCYWNrZW5kID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoWm9uZUNsaWVudEJhY2tlbmQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gWm9uZUNsaWVudEJhY2tlbmQoYmFja2VuZCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5iYWNrZW5kID0gYmFja2VuZDtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHJlcXVlc3RcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFpvbmVDbGllbnRCYWNrZW5kLnByb3RvdHlwZS5oYW5kbGUgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IHJlcXVlc3RcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChyZXF1ZXN0KSB7IHJldHVybiB0aGlzLndyYXAocmVxdWVzdCk7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSByZXF1ZXN0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBab25lQ2xpZW50QmFja2VuZC5wcm90b3R5cGUuZGVsZWdhdGUgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IHJlcXVlc3RcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChyZXF1ZXN0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJhY2tlbmQuaGFuZGxlKHJlcXVlc3QpO1xuICAgIH07XG4gICAgcmV0dXJuIFpvbmVDbGllbnRCYWNrZW5kO1xufShab25lTWFjcm9UYXNrV3JhcHBlcikpO1xuLyoqXG4gKiBAcGFyYW0gez99IHhockJhY2tlbmRcbiAqIEBwYXJhbSB7P30gb3B0aW9uc1xuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gaHR0cEZhY3RvcnkoeGhyQmFja2VuZCwgb3B0aW9ucykge1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIG1hY3JvQmFja2VuZCA9IG5ldyBab25lTWFjcm9UYXNrQmFja2VuZCh4aHJCYWNrZW5kKTtcbiAgICByZXR1cm4gbmV3IF9hbmd1bGFyX2h0dHAuSHR0cChtYWNyb0JhY2tlbmQsIG9wdGlvbnMpO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IGJhY2tlbmRcbiAqIEBwYXJhbSB7P30gaW50ZXJjZXB0b3JzXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiB6b25lV3JhcHBlZEludGVyY2VwdGluZ0hhbmRsZXIoYmFja2VuZCwgaW50ZXJjZXB0b3JzKSB7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVhbEJhY2tlbmQgPSBfYW5ndWxhcl9jb21tb25faHR0cC7JtWludGVyY2VwdGluZ0hhbmRsZXIoYmFja2VuZCwgaW50ZXJjZXB0b3JzKTtcbiAgICByZXR1cm4gbmV3IFpvbmVDbGllbnRCYWNrZW5kKHJlYWxCYWNrZW5kKTtcbn1cbnZhciBTRVJWRVJfSFRUUF9QUk9WSURFUlMgPSBbXG4gICAgeyBwcm92aWRlOiBfYW5ndWxhcl9odHRwLkh0dHAsIHVzZUZhY3Rvcnk6IGh0dHBGYWN0b3J5LCBkZXBzOiBbX2FuZ3VsYXJfaHR0cC5YSFJCYWNrZW5kLCBfYW5ndWxhcl9odHRwLlJlcXVlc3RPcHRpb25zXSB9LFxuICAgIHsgcHJvdmlkZTogX2FuZ3VsYXJfaHR0cC5Ccm93c2VyWGhyLCB1c2VDbGFzczogU2VydmVyWGhyIH0sIHsgcHJvdmlkZTogX2FuZ3VsYXJfaHR0cC5YU1JGU3RyYXRlZ3ksIHVzZUNsYXNzOiBTZXJ2ZXJYc3JmU3RyYXRlZ3kgfSxcbiAgICB7IHByb3ZpZGU6IF9hbmd1bGFyX2NvbW1vbl9odHRwLlhockZhY3RvcnksIHVzZUNsYXNzOiBTZXJ2ZXJYaHIgfSwge1xuICAgICAgICBwcm92aWRlOiBfYW5ndWxhcl9jb21tb25faHR0cC5IdHRwSGFuZGxlcixcbiAgICAgICAgdXNlRmFjdG9yeTogem9uZVdyYXBwZWRJbnRlcmNlcHRpbmdIYW5kbGVyLFxuICAgICAgICBkZXBzOiBbX2FuZ3VsYXJfY29tbW9uX2h0dHAuSHR0cEJhY2tlbmQsIFtuZXcgX2FuZ3VsYXJfY29yZS5PcHRpb25hbCgpLCBfYW5ndWxhcl9jb21tb25faHR0cC5IVFRQX0lOVEVSQ0VQVE9SU11dXG4gICAgfVxuXTtcblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IGFkZGVkIGJ5IHRzaWNrbGVcbiAqIEBzdXBwcmVzcyB7Y2hlY2tUeXBlc30gY2hlY2tlZCBieSB0c2NcbiAqL1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLyoqXG4gKiBDb25maWcgb2JqZWN0IHBhc3NlZCB0byBpbml0aWFsaXplIHRoZSBwbGF0Zm9ybS5cbiAqXG4gKiBcXEBleHBlcmltZW50YWxcbiAqIEByZWNvcmRcbiAqL1xuXG4vKipcbiAqIFRoZSBESSB0b2tlbiBmb3Igc2V0dGluZyB0aGUgaW5pdGlhbCBjb25maWcgZm9yIHRoZSBwbGF0Zm9ybS5cbiAqXG4gKiBcXEBleHBlcmltZW50YWxcbiAqL1xudmFyIElOSVRJQUxfQ09ORklHID0gbmV3IF9hbmd1bGFyX2NvcmUuSW5qZWN0aW9uVG9rZW4oJ1NlcnZlci5JTklUSUFMX0NPTkZJRycpO1xuLyoqXG4gKiBBIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBleGVjdXRlZCB3aGVuIGNhbGxpbmcgYHJlbmRlck1vZHVsZUZhY3RvcnlgIG9yIGByZW5kZXJNb2R1bGVgIGp1c3RcbiAqIGJlZm9yZSBjdXJyZW50IHBsYXRmb3JtIHN0YXRlIGlzIHJlbmRlcmVkIHRvIHN0cmluZy5cbiAqXG4gKiBcXEBleHBlcmltZW50YWxcbiAqL1xudmFyIEJFRk9SRV9BUFBfU0VSSUFMSVpFRCA9IG5ldyBfYW5ndWxhcl9jb3JlLkluamVjdGlvblRva2VuKCdTZXJ2ZXIuUkVOREVSX01PRFVMRV9IT09LJyk7XG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBhZGRlZCBieSB0c2lja2xlXG4gKiBAc3VwcHJlc3Mge2NoZWNrVHlwZXN9IGNoZWNrZWQgYnkgdHNjXG4gKi9cbi8qKlxuICogQHBhcmFtIHs/fSB1cmxTdHJcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIHBhcnNlVXJsKHVybFN0cikge1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIHBhcnNlZFVybCA9IHVybC5wYXJzZSh1cmxTdHIpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHBhdGhuYW1lOiBwYXJzZWRVcmwucGF0aG5hbWUgfHwgJycsXG4gICAgICAgIHNlYXJjaDogcGFyc2VkVXJsLnNlYXJjaCB8fCAnJyxcbiAgICAgICAgaGFzaDogcGFyc2VkVXJsLmhhc2ggfHwgJycsXG4gICAgfTtcbn1cbi8qKlxuICogU2VydmVyLXNpZGUgaW1wbGVtZW50YXRpb24gb2YgVVJMIHN0YXRlLiBJbXBsZW1lbnRzIGBwYXRobmFtZWAsIGBzZWFyY2hgLCBhbmQgYGhhc2hgXG4gKiBidXQgbm90IHRoZSBzdGF0ZSBzdGFjay5cbiAqL1xudmFyIFNlcnZlclBsYXRmb3JtTG9jYXRpb24gPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNlcnZlclBsYXRmb3JtTG9jYXRpb24oX2RvYywgX2NvbmZpZykge1xuICAgICAgICB0aGlzLl9kb2MgPSBfZG9jO1xuICAgICAgICB0aGlzLl9wYXRoID0gJy8nO1xuICAgICAgICB0aGlzLl9zZWFyY2ggPSAnJztcbiAgICAgICAgdGhpcy5faGFzaCA9ICcnO1xuICAgICAgICB0aGlzLl9oYXNoVXBkYXRlID0gbmV3IHJ4anNfU3ViamVjdC5TdWJqZWN0KCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNvbmZpZyA9IC8qKiBAdHlwZSB7P30gKi8gKF9jb25maWcpO1xuICAgICAgICBpZiAoISFjb25maWcgJiYgISFjb25maWcudXJsKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwYXJzZWRVcmwgPSBwYXJzZVVybChjb25maWcudXJsKTtcbiAgICAgICAgICAgIHRoaXMuX3BhdGggPSBwYXJzZWRVcmwucGF0aG5hbWU7XG4gICAgICAgICAgICB0aGlzLl9zZWFyY2ggPSBwYXJzZWRVcmwuc2VhcmNoO1xuICAgICAgICAgICAgdGhpcy5faGFzaCA9IHBhcnNlZFVybC5oYXNoO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU2VydmVyUGxhdGZvcm1Mb2NhdGlvbi5wcm90b3R5cGUuZ2V0QmFzZUhyZWZGcm9tRE9NID0gLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoKSB7IHJldHVybiAvKiogQHR5cGUgez99ICovICgoX2FuZ3VsYXJfcGxhdGZvcm1Ccm93c2VyLsm1Z2V0RE9NKCkuZ2V0QmFzZUhyZWYodGhpcy5fZG9jKSkpOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZm5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFNlcnZlclBsYXRmb3JtTG9jYXRpb24ucHJvdG90eXBlLm9uUG9wU3RhdGUgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IGZuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgLy8gTm8tb3A6IGEgc3RhdGUgc3RhY2sgaXMgbm90IGltcGxlbWVudGVkLCBzb1xuICAgICAgICAvLyBubyBldmVudHMgd2lsbCBldmVyIGNvbWUuXG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGZuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTZXJ2ZXJQbGF0Zm9ybUxvY2F0aW9uLnByb3RvdHlwZS5vbkhhc2hDaGFuZ2UgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IGZuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoZm4pIHsgdGhpcy5faGFzaFVwZGF0ZS5zdWJzY3JpYmUoZm4pOyB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTZXJ2ZXJQbGF0Zm9ybUxvY2F0aW9uLnByb3RvdHlwZSwgXCJwYXRobmFtZVwiLCB7XG4gICAgICAgIGdldDogLyoqXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9wYXRoOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU2VydmVyUGxhdGZvcm1Mb2NhdGlvbi5wcm90b3R5cGUsIFwic2VhcmNoXCIsIHtcbiAgICAgICAgZ2V0OiAvKipcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3NlYXJjaDsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNlcnZlclBsYXRmb3JtTG9jYXRpb24ucHJvdG90eXBlLCBcImhhc2hcIiwge1xuICAgICAgICBnZXQ6IC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5faGFzaDsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNlcnZlclBsYXRmb3JtTG9jYXRpb24ucHJvdG90eXBlLCBcInVybFwiLCB7XG4gICAgICAgIGdldDogLyoqXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiAoKSB7IHJldHVybiBcIlwiICsgdGhpcy5wYXRobmFtZSArIHRoaXMuc2VhcmNoICsgdGhpcy5oYXNoOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICogQHBhcmFtIHs/fSBvbGRVcmxcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFNlcnZlclBsYXRmb3JtTG9jYXRpb24ucHJvdG90eXBlLnNldEhhc2ggPSAvKipcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICogQHBhcmFtIHs/fSBvbGRVcmxcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uICh2YWx1ZSwgb2xkVXJsKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLl9oYXNoID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgLy8gRG9uJ3QgZmlyZSBldmVudHMgaWYgdGhlIGhhc2ggaGFzIG5vdCBjaGFuZ2VkLlxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2hhc2ggPSB2YWx1ZTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbmV3VXJsID0gdGhpcy51cmw7XG4gICAgICAgIHNjaGVkdWxlTWljcm9UYXNrKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLl9oYXNoVXBkYXRlLm5leHQoLyoqIEB0eXBlIHs/fSAqLyAoeyB0eXBlOiAnaGFzaGNoYW5nZScsIG9sZFVybDogb2xkVXJsLCBuZXdVcmw6IG5ld1VybCB9KSk7IH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzdGF0ZVxuICAgICAqIEBwYXJhbSB7P30gdGl0bGVcbiAgICAgKiBAcGFyYW0gez99IG5ld1VybFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU2VydmVyUGxhdGZvcm1Mb2NhdGlvbi5wcm90b3R5cGUucmVwbGFjZVN0YXRlID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBzdGF0ZVxuICAgICAqIEBwYXJhbSB7P30gdGl0bGVcbiAgICAgKiBAcGFyYW0gez99IG5ld1VybFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKHN0YXRlLCB0aXRsZSwgbmV3VXJsKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG9sZFVybCA9IHRoaXMudXJsO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwYXJzZWRVcmwgPSBwYXJzZVVybChuZXdVcmwpO1xuICAgICAgICB0aGlzLl9wYXRoID0gcGFyc2VkVXJsLnBhdGhuYW1lO1xuICAgICAgICB0aGlzLl9zZWFyY2ggPSBwYXJzZWRVcmwuc2VhcmNoO1xuICAgICAgICB0aGlzLnNldEhhc2gocGFyc2VkVXJsLmhhc2gsIG9sZFVybCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN0YXRlXG4gICAgICogQHBhcmFtIHs/fSB0aXRsZVxuICAgICAqIEBwYXJhbSB7P30gbmV3VXJsXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTZXJ2ZXJQbGF0Zm9ybUxvY2F0aW9uLnByb3RvdHlwZS5wdXNoU3RhdGUgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IHN0YXRlXG4gICAgICogQHBhcmFtIHs/fSB0aXRsZVxuICAgICAqIEBwYXJhbSB7P30gbmV3VXJsXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoc3RhdGUsIHRpdGxlLCBuZXdVcmwpIHtcbiAgICAgICAgdGhpcy5yZXBsYWNlU3RhdGUoc3RhdGUsIHRpdGxlLCBuZXdVcmwpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTZXJ2ZXJQbGF0Zm9ybUxvY2F0aW9uLnByb3RvdHlwZS5mb3J3YXJkID0gLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoKSB7IHRocm93IG5ldyBFcnJvcignTm90IGltcGxlbWVudGVkJyk7IH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTZXJ2ZXJQbGF0Zm9ybUxvY2F0aW9uLnByb3RvdHlwZS5iYWNrID0gLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoKSB7IHRocm93IG5ldyBFcnJvcignTm90IGltcGxlbWVudGVkJyk7IH07XG4gICAgU2VydmVyUGxhdGZvcm1Mb2NhdGlvbi5kZWNvcmF0b3JzID0gW1xuICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5qZWN0YWJsZSB9LFxuICAgIF07XG4gICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgU2VydmVyUGxhdGZvcm1Mb2NhdGlvbi5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICAgICAgeyB0eXBlOiB1bmRlZmluZWQsIGRlY29yYXRvcnM6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5qZWN0LCBhcmdzOiBbX2FuZ3VsYXJfcGxhdGZvcm1Ccm93c2VyLkRPQ1VNRU5ULF0gfSxdIH0sXG4gICAgICAgIHsgdHlwZTogdW5kZWZpbmVkLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLk9wdGlvbmFsIH0sIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3QsIGFyZ3M6IFtJTklUSUFMX0NPTkZJRyxdIH0sXSB9LFxuICAgIF07IH07XG4gICAgcmV0dXJuIFNlcnZlclBsYXRmb3JtTG9jYXRpb247XG59KCkpO1xuLyoqXG4gKiBAcGFyYW0gez99IGZuXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBzY2hlZHVsZU1pY3JvVGFzayhmbikge1xuICAgIFpvbmUuY3VycmVudC5zY2hlZHVsZU1pY3JvVGFzaygnc2NoZWR1bGVNaWNyb3Rhc2snLCBmbik7XG59XG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBhZGRlZCBieSB0c2lja2xlXG4gKiBAc3VwcHJlc3Mge2NoZWNrVHlwZXN9IGNoZWNrZWQgYnkgdHNjXG4gKi9cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBFTVBUWV9BUlJBWSA9IFtdO1xudmFyIFNlcnZlclJlbmRlcmVyRmFjdG9yeTIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNlcnZlclJlbmRlcmVyRmFjdG9yeTIobmdab25lLCBkb2N1bWVudCwgc2hhcmVkU3R5bGVzSG9zdCkge1xuICAgICAgICB0aGlzLm5nWm9uZSA9IG5nWm9uZTtcbiAgICAgICAgdGhpcy5kb2N1bWVudCA9IGRvY3VtZW50O1xuICAgICAgICB0aGlzLnNoYXJlZFN0eWxlc0hvc3QgPSBzaGFyZWRTdHlsZXNIb3N0O1xuICAgICAgICB0aGlzLnJlbmRlcmVyQnlDb21wSWQgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuc2NoZW1hID0gbmV3IF9hbmd1bGFyX2NvbXBpbGVyLkRvbUVsZW1lbnRTY2hlbWFSZWdpc3RyeSgpO1xuICAgICAgICB0aGlzLmRlZmF1bHRSZW5kZXJlciA9IG5ldyBEZWZhdWx0U2VydmVyUmVuZGVyZXIyKGRvY3VtZW50LCBuZ1pvbmUsIHRoaXMuc2NoZW1hKTtcbiAgICB9XG4gICAgXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XG4gICAgICogQHBhcmFtIHs/fSB0eXBlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTZXJ2ZXJSZW5kZXJlckZhY3RvcnkyLnByb3RvdHlwZS5jcmVhdGVSZW5kZXJlciA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFxuICAgICAqIEBwYXJhbSB7P30gdHlwZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKGVsZW1lbnQsIHR5cGUpIHtcbiAgICAgICAgaWYgKCFlbGVtZW50IHx8ICF0eXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kZWZhdWx0UmVuZGVyZXI7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoICh0eXBlLmVuY2Fwc3VsYXRpb24pIHtcbiAgICAgICAgICAgIGNhc2UgX2FuZ3VsYXJfY29yZS5WaWV3RW5jYXBzdWxhdGlvbi5OYXRpdmU6XG4gICAgICAgICAgICBjYXNlIF9hbmd1bGFyX2NvcmUuVmlld0VuY2Fwc3VsYXRpb24uRW11bGF0ZWQ6IHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZW5kZXJlciA9IHRoaXMucmVuZGVyZXJCeUNvbXBJZC5nZXQodHlwZS5pZCk7XG4gICAgICAgICAgICAgICAgaWYgKCFyZW5kZXJlcikge1xuICAgICAgICAgICAgICAgICAgICByZW5kZXJlciA9IG5ldyBFbXVsYXRlZEVuY2Fwc3VsYXRpb25TZXJ2ZXJSZW5kZXJlcjIodGhpcy5kb2N1bWVudCwgdGhpcy5uZ1pvbmUsIHRoaXMuc2hhcmVkU3R5bGVzSG9zdCwgdGhpcy5zY2hlbWEsIHR5cGUpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyQnlDb21wSWQuc2V0KHR5cGUuaWQsIHJlbmRlcmVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKC8qKiBAdHlwZSB7P30gKi8gKHJlbmRlcmVyKSkuYXBwbHlUb0hvc3QoZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlbmRlcmVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBfYW5ndWxhcl9jb3JlLlZpZXdFbmNhcHN1bGF0aW9uLk5hdGl2ZTpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05hdGl2ZSBlbmNhcHN1bGF0aW9uIGlzIG5vdCBzdXBwb3J0ZWQgb24gdGhlIHNlcnZlciEnKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMucmVuZGVyZXJCeUNvbXBJZC5oYXModHlwZS5pZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3R5bGVzID0gX2FuZ3VsYXJfcGxhdGZvcm1Ccm93c2VyLsm1ZmxhdHRlblN0eWxlcyh0eXBlLmlkLCB0eXBlLnN0eWxlcywgW10pO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNoYXJlZFN0eWxlc0hvc3QuYWRkU3R5bGVzKHN0eWxlcyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyZXJCeUNvbXBJZC5zZXQodHlwZS5pZCwgdGhpcy5kZWZhdWx0UmVuZGVyZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kZWZhdWx0UmVuZGVyZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU2VydmVyUmVuZGVyZXJGYWN0b3J5Mi5wcm90b3R5cGUuYmVnaW4gPSAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uICgpIHsgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFNlcnZlclJlbmRlcmVyRmFjdG9yeTIucHJvdG90eXBlLmVuZCA9IC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKCkgeyB9O1xuICAgIFNlcnZlclJlbmRlcmVyRmFjdG9yeTIuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdGFibGUgfSxcbiAgICBdO1xuICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgIFNlcnZlclJlbmRlcmVyRmFjdG9yeTIuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5OZ1pvbmUsIH0sXG4gICAgICAgIHsgdHlwZTogdW5kZWZpbmVkLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdCwgYXJnczogW19hbmd1bGFyX3BsYXRmb3JtQnJvd3Nlci5ET0NVTUVOVCxdIH0sXSB9LFxuICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX3BsYXRmb3JtQnJvd3Nlci7JtVNoYXJlZFN0eWxlc0hvc3QsIH0sXG4gICAgXTsgfTtcbiAgICByZXR1cm4gU2VydmVyUmVuZGVyZXJGYWN0b3J5Mjtcbn0oKSk7XG52YXIgRGVmYXVsdFNlcnZlclJlbmRlcmVyMiA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRGVmYXVsdFNlcnZlclJlbmRlcmVyMihkb2N1bWVudCwgbmdab25lLCBzY2hlbWEpIHtcbiAgICAgICAgdGhpcy5kb2N1bWVudCA9IGRvY3VtZW50O1xuICAgICAgICB0aGlzLm5nWm9uZSA9IG5nWm9uZTtcbiAgICAgICAgdGhpcy5zY2hlbWEgPSBzY2hlbWE7XG4gICAgICAgIHRoaXMuZGF0YSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRGVmYXVsdFNlcnZlclJlbmRlcmVyMi5wcm90b3R5cGUuZGVzdHJveSA9IC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKCkgeyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEBwYXJhbSB7Pz19IG5hbWVzcGFjZVxuICAgICAqIEBwYXJhbSB7Pz19IGRlYnVnSW5mb1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRGVmYXVsdFNlcnZlclJlbmRlcmVyMi5wcm90b3R5cGUuY3JlYXRlRWxlbWVudCA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEBwYXJhbSB7Pz19IG5hbWVzcGFjZVxuICAgICAqIEBwYXJhbSB7Pz19IGRlYnVnSW5mb1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKG5hbWUsIG5hbWVzcGFjZSwgZGVidWdJbmZvKSB7XG4gICAgICAgIGlmIChuYW1lc3BhY2UpIHtcbiAgICAgICAgICAgIHJldHVybiBfYW5ndWxhcl9wbGF0Zm9ybUJyb3dzZXIuybVnZXRET00oKS5jcmVhdGVFbGVtZW50TlMoX2FuZ3VsYXJfcGxhdGZvcm1Ccm93c2VyLsm1TkFNRVNQQUNFX1VSSVNbbmFtZXNwYWNlXSwgbmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9hbmd1bGFyX3BsYXRmb3JtQnJvd3Nlci7JtWdldERPTSgpLmNyZWF0ZUVsZW1lbnQobmFtZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICogQHBhcmFtIHs/PX0gZGVidWdJbmZvXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBEZWZhdWx0U2VydmVyUmVuZGVyZXIyLnByb3RvdHlwZS5jcmVhdGVDb21tZW50ID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Pz19IGRlYnVnSW5mb1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKHZhbHVlLCBkZWJ1Z0luZm8pIHsgcmV0dXJuIF9hbmd1bGFyX3BsYXRmb3JtQnJvd3Nlci7JtWdldERPTSgpLmNyZWF0ZUNvbW1lbnQodmFsdWUpOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgKiBAcGFyYW0gez89fSBkZWJ1Z0luZm9cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIERlZmF1bHRTZXJ2ZXJSZW5kZXJlcjIucHJvdG90eXBlLmNyZWF0ZVRleHQgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICogQHBhcmFtIHs/PX0gZGVidWdJbmZvXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAodmFsdWUsIGRlYnVnSW5mbykgeyByZXR1cm4gX2FuZ3VsYXJfcGxhdGZvcm1Ccm93c2VyLsm1Z2V0RE9NKCkuY3JlYXRlVGV4dE5vZGUodmFsdWUpOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcGFyZW50XG4gICAgICogQHBhcmFtIHs/fSBuZXdDaGlsZFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRGVmYXVsdFNlcnZlclJlbmRlcmVyMi5wcm90b3R5cGUuYXBwZW5kQ2hpbGQgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IHBhcmVudFxuICAgICAqIEBwYXJhbSB7P30gbmV3Q2hpbGRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChwYXJlbnQsIG5ld0NoaWxkKSB7IF9hbmd1bGFyX3BsYXRmb3JtQnJvd3Nlci7JtWdldERPTSgpLmFwcGVuZENoaWxkKHBhcmVudCwgbmV3Q2hpbGQpOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcGFyZW50XG4gICAgICogQHBhcmFtIHs/fSBuZXdDaGlsZFxuICAgICAqIEBwYXJhbSB7P30gcmVmQ2hpbGRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIERlZmF1bHRTZXJ2ZXJSZW5kZXJlcjIucHJvdG90eXBlLmluc2VydEJlZm9yZSA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gcGFyZW50XG4gICAgICogQHBhcmFtIHs/fSBuZXdDaGlsZFxuICAgICAqIEBwYXJhbSB7P30gcmVmQ2hpbGRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChwYXJlbnQsIG5ld0NoaWxkLCByZWZDaGlsZCkge1xuICAgICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgICAgICBfYW5ndWxhcl9wbGF0Zm9ybUJyb3dzZXIuybVnZXRET00oKS5pbnNlcnRCZWZvcmUocGFyZW50LCByZWZDaGlsZCwgbmV3Q2hpbGQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHBhcmVudFxuICAgICAqIEBwYXJhbSB7P30gb2xkQ2hpbGRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIERlZmF1bHRTZXJ2ZXJSZW5kZXJlcjIucHJvdG90eXBlLnJlbW92ZUNoaWxkID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBwYXJlbnRcbiAgICAgKiBAcGFyYW0gez99IG9sZENoaWxkXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAocGFyZW50LCBvbGRDaGlsZCkge1xuICAgICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgICAgICBfYW5ndWxhcl9wbGF0Zm9ybUJyb3dzZXIuybVnZXRET00oKS5yZW1vdmVDaGlsZChwYXJlbnQsIG9sZENoaWxkKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzZWxlY3Rvck9yTm9kZVxuICAgICAqIEBwYXJhbSB7Pz19IGRlYnVnSW5mb1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRGVmYXVsdFNlcnZlclJlbmRlcmVyMi5wcm90b3R5cGUuc2VsZWN0Um9vdEVsZW1lbnQgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IHNlbGVjdG9yT3JOb2RlXG4gICAgICogQHBhcmFtIHs/PX0gZGVidWdJbmZvXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoc2VsZWN0b3JPck5vZGUsIGRlYnVnSW5mbykge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlbDtcbiAgICAgICAgaWYgKHR5cGVvZiBzZWxlY3Rvck9yTm9kZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGVsID0gX2FuZ3VsYXJfcGxhdGZvcm1Ccm93c2VyLsm1Z2V0RE9NKCkucXVlcnlTZWxlY3Rvcih0aGlzLmRvY3VtZW50LCBzZWxlY3Rvck9yTm9kZSk7XG4gICAgICAgICAgICBpZiAoIWVsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIHNlbGVjdG9yIFxcXCJcIiArIHNlbGVjdG9yT3JOb2RlICsgXCJcXFwiIGRpZCBub3QgbWF0Y2ggYW55IGVsZW1lbnRzXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZWwgPSBzZWxlY3Rvck9yTm9kZTtcbiAgICAgICAgfVxuICAgICAgICBfYW5ndWxhcl9wbGF0Zm9ybUJyb3dzZXIuybVnZXRET00oKS5jbGVhck5vZGVzKGVsKTtcbiAgICAgICAgcmV0dXJuIGVsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBub2RlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBEZWZhdWx0U2VydmVyUmVuZGVyZXIyLnByb3RvdHlwZS5wYXJlbnROb2RlID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBub2RlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gX2FuZ3VsYXJfcGxhdGZvcm1Ccm93c2VyLsm1Z2V0RE9NKCkucGFyZW50RWxlbWVudChub2RlKTsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5vZGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIERlZmF1bHRTZXJ2ZXJSZW5kZXJlcjIucHJvdG90eXBlLm5leHRTaWJsaW5nID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBub2RlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gX2FuZ3VsYXJfcGxhdGZvcm1Ccm93c2VyLsm1Z2V0RE9NKCkubmV4dFNpYmxpbmcobm9kZSk7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbFxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgKiBAcGFyYW0gez89fSBuYW1lc3BhY2VcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIERlZmF1bHRTZXJ2ZXJSZW5kZXJlcjIucHJvdG90eXBlLnNldEF0dHJpYnV0ZSA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gZWxcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICogQHBhcmFtIHs/PX0gbmFtZXNwYWNlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoZWwsIG5hbWUsIHZhbHVlLCBuYW1lc3BhY2UpIHtcbiAgICAgICAgaWYgKG5hbWVzcGFjZSkge1xuICAgICAgICAgICAgX2FuZ3VsYXJfcGxhdGZvcm1Ccm93c2VyLsm1Z2V0RE9NKCkuc2V0QXR0cmlidXRlTlMoZWwsIF9hbmd1bGFyX3BsYXRmb3JtQnJvd3Nlci7JtU5BTUVTUEFDRV9VUklTW25hbWVzcGFjZV0sIG5hbWVzcGFjZSArICc6JyArIG5hbWUsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIF9hbmd1bGFyX3BsYXRmb3JtQnJvd3Nlci7JtWdldERPTSgpLnNldEF0dHJpYnV0ZShlbCwgbmFtZSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHBhcmFtIHs/PX0gbmFtZXNwYWNlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBEZWZhdWx0U2VydmVyUmVuZGVyZXIyLnByb3RvdHlwZS5yZW1vdmVBdHRyaWJ1dGUgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHBhcmFtIHs/PX0gbmFtZXNwYWNlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoZWwsIG5hbWUsIG5hbWVzcGFjZSkge1xuICAgICAgICBpZiAobmFtZXNwYWNlKSB7XG4gICAgICAgICAgICBfYW5ndWxhcl9wbGF0Zm9ybUJyb3dzZXIuybVnZXRET00oKS5yZW1vdmVBdHRyaWJ1dGVOUyhlbCwgX2FuZ3VsYXJfcGxhdGZvcm1Ccm93c2VyLsm1TkFNRVNQQUNFX1VSSVNbbmFtZXNwYWNlXSwgbmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBfYW5ndWxhcl9wbGF0Zm9ybUJyb3dzZXIuybVnZXRET00oKS5yZW1vdmVBdHRyaWJ1dGUoZWwsIG5hbWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBEZWZhdWx0U2VydmVyUmVuZGVyZXIyLnByb3RvdHlwZS5hZGRDbGFzcyA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gZWxcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChlbCwgbmFtZSkgeyBfYW5ndWxhcl9wbGF0Zm9ybUJyb3dzZXIuybVnZXRET00oKS5hZGRDbGFzcyhlbCwgbmFtZSk7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbFxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRGVmYXVsdFNlcnZlclJlbmRlcmVyMi5wcm90b3R5cGUucmVtb3ZlQ2xhc3MgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoZWwsIG5hbWUpIHsgX2FuZ3VsYXJfcGxhdGZvcm1Ccm93c2VyLsm1Z2V0RE9NKCkucmVtb3ZlQ2xhc3MoZWwsIG5hbWUpOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZWxcbiAgICAgKiBAcGFyYW0gez99IHN0eWxlXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7P30gZmxhZ3NcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIERlZmF1bHRTZXJ2ZXJSZW5kZXJlcjIucHJvdG90eXBlLnNldFN0eWxlID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbFxuICAgICAqIEBwYXJhbSB7P30gc3R5bGVcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICogQHBhcmFtIHs/fSBmbGFnc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKGVsLCBzdHlsZSwgdmFsdWUsIGZsYWdzKSB7XG4gICAgICAgIF9hbmd1bGFyX3BsYXRmb3JtQnJvd3Nlci7JtWdldERPTSgpLnNldFN0eWxlKGVsLCBzdHlsZSwgdmFsdWUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbFxuICAgICAqIEBwYXJhbSB7P30gc3R5bGVcbiAgICAgKiBAcGFyYW0gez99IGZsYWdzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBEZWZhdWx0U2VydmVyUmVuZGVyZXIyLnByb3RvdHlwZS5yZW1vdmVTdHlsZSA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gZWxcbiAgICAgKiBAcGFyYW0gez99IHN0eWxlXG4gICAgICogQHBhcmFtIHs/fSBmbGFnc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKGVsLCBzdHlsZSwgZmxhZ3MpIHtcbiAgICAgICAgX2FuZ3VsYXJfcGxhdGZvcm1Ccm93c2VyLsm1Z2V0RE9NKCkucmVtb3ZlU3R5bGUoZWwsIHN0eWxlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdGFnTmFtZVxuICAgICAqIEBwYXJhbSB7P30gcHJvcGVydHlOYW1lXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBEZWZhdWx0U2VydmVyUmVuZGVyZXIyLnByb3RvdHlwZS5faXNTYWZlVG9SZWZsZWN0UHJvcGVydHkgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IHRhZ05hbWVcbiAgICAgKiBAcGFyYW0gez99IHByb3BlcnR5TmFtZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKHRhZ05hbWUsIHByb3BlcnR5TmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zY2hlbWEuc2VjdXJpdHlDb250ZXh0KHRhZ05hbWUsIHByb3BlcnR5TmFtZSwgdHJ1ZSkgPT09XG4gICAgICAgICAgICB0aGlzLnNjaGVtYS5zZWN1cml0eUNvbnRleHQodGFnTmFtZSwgcHJvcGVydHlOYW1lLCBmYWxzZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRGVmYXVsdFNlcnZlclJlbmRlcmVyMi5wcm90b3R5cGUuc2V0UHJvcGVydHkgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKGVsLCBuYW1lLCB2YWx1ZSkge1xuICAgICAgICBjaGVja05vU3ludGhldGljUHJvcChuYW1lLCAncHJvcGVydHknKTtcbiAgICAgICAgX2FuZ3VsYXJfcGxhdGZvcm1Ccm93c2VyLsm1Z2V0RE9NKCkuc2V0UHJvcGVydHkoZWwsIG5hbWUsIHZhbHVlKTtcbiAgICAgICAgLy8gTWlycm9yIHByb3BlcnR5IHZhbHVlcyBmb3Iga25vd24gSFRNTCBlbGVtZW50IHByb3BlcnRpZXMgaW4gdGhlIGF0dHJpYnV0ZXMuXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRhZ05hbWUgPSAoLyoqIEB0eXBlIHs/fSAqLyAoZWwudGFnTmFtZSkpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmICh2YWx1ZSAhPSBudWxsICYmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInIHx8IHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJykgJiZcbiAgICAgICAgICAgIHRoaXMuc2NoZW1hLmhhc0VsZW1lbnQodGFnTmFtZSwgRU1QVFlfQVJSQVkpICYmXG4gICAgICAgICAgICB0aGlzLnNjaGVtYS5oYXNQcm9wZXJ0eSh0YWdOYW1lLCBuYW1lLCBFTVBUWV9BUlJBWSkgJiZcbiAgICAgICAgICAgIHRoaXMuX2lzU2FmZVRvUmVmbGVjdFByb3BlcnR5KHRhZ05hbWUsIG5hbWUpKSB7XG4gICAgICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZShlbCwgbmFtZSwgdmFsdWUudG9TdHJpbmcoKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbm9kZVxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIERlZmF1bHRTZXJ2ZXJSZW5kZXJlcjIucHJvdG90eXBlLnNldFZhbHVlID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBub2RlXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKG5vZGUsIHZhbHVlKSB7IF9hbmd1bGFyX3BsYXRmb3JtQnJvd3Nlci7JtWdldERPTSgpLnNldFRleHQobm9kZSwgdmFsdWUpOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdGFyZ2V0XG4gICAgICogQHBhcmFtIHs/fSBldmVudE5hbWVcbiAgICAgKiBAcGFyYW0gez99IGNhbGxiYWNrXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBEZWZhdWx0U2VydmVyUmVuZGVyZXIyLnByb3RvdHlwZS5saXN0ZW4gPSAvKipcbiAgICAgKiBAcGFyYW0gez99IHRhcmdldFxuICAgICAqIEBwYXJhbSB7P30gZXZlbnROYW1lXG4gICAgICogQHBhcmFtIHs/fSBjYWxsYmFja1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKHRhcmdldCwgZXZlbnROYW1lLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvLyBOb3RlOiBXZSBhcmUgbm90IHVzaW5nIHRoZSBFdmVudHNQbHVnaW4gaGVyZSBhcyB0aGlzIGlzIG5vdCBuZWVkZWRcbiAgICAgICAgLy8gdG8gcnVuIG91ciB0ZXN0cy5cbiAgICAgICAgY2hlY2tOb1N5bnRoZXRpY1Byb3AoZXZlbnROYW1lLCAnbGlzdGVuZXInKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZWwgPSB0eXBlb2YgdGFyZ2V0ID09PSAnc3RyaW5nJyA/IF9hbmd1bGFyX3BsYXRmb3JtQnJvd3Nlci7JtWdldERPTSgpLmdldEdsb2JhbEV2ZW50VGFyZ2V0KHRoaXMuZG9jdW1lbnQsIHRhcmdldCkgOiB0YXJnZXQ7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG91dHNpZGVIYW5kbGVyID0gZnVuY3Rpb24gKGV2ZW50KSB7IHJldHVybiBfdGhpcy5uZ1pvbmUucnVuR3VhcmRlZChmdW5jdGlvbiAoKSB7IHJldHVybiBjYWxsYmFjayhldmVudCk7IH0pOyB9O1xuICAgICAgICByZXR1cm4gdGhpcy5uZ1pvbmUucnVuT3V0c2lkZUFuZ3VsYXIoZnVuY3Rpb24gKCkgeyByZXR1cm4gLyoqIEB0eXBlIHs/fSAqLyAoX2FuZ3VsYXJfcGxhdGZvcm1Ccm93c2VyLsm1Z2V0RE9NKCkub25BbmRDYW5jZWwoZWwsIGV2ZW50TmFtZSwgb3V0c2lkZUhhbmRsZXIpKTsgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gRGVmYXVsdFNlcnZlclJlbmRlcmVyMjtcbn0oKSk7XG52YXIgQVRfQ0hBUkNPREUgPSAnQCcuY2hhckNvZGVBdCgwKTtcbi8qKlxuICogQHBhcmFtIHs/fSBuYW1lXG4gKiBAcGFyYW0gez99IG5hbWVLaW5kXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBjaGVja05vU3ludGhldGljUHJvcChuYW1lLCBuYW1lS2luZCkge1xuICAgIGlmIChuYW1lLmNoYXJDb2RlQXQoMCkgPT09IEFUX0NIQVJDT0RFKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZvdW5kIHRoZSBzeW50aGV0aWMgXCIgKyBuYW1lS2luZCArIFwiIFwiICsgbmFtZSArIFwiLiBQbGVhc2UgaW5jbHVkZSBlaXRoZXIgXFxcIkJyb3dzZXJBbmltYXRpb25zTW9kdWxlXFxcIiBvciBcXFwiTm9vcEFuaW1hdGlvbnNNb2R1bGVcXFwiIGluIHlvdXIgYXBwbGljYXRpb24uXCIpO1xuICAgIH1cbn1cbnZhciBFbXVsYXRlZEVuY2Fwc3VsYXRpb25TZXJ2ZXJSZW5kZXJlcjIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhFbXVsYXRlZEVuY2Fwc3VsYXRpb25TZXJ2ZXJSZW5kZXJlcjIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRW11bGF0ZWRFbmNhcHN1bGF0aW9uU2VydmVyUmVuZGVyZXIyKGRvY3VtZW50LCBuZ1pvbmUsIHNoYXJlZFN0eWxlc0hvc3QsIHNjaGVtYSwgY29tcG9uZW50KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGRvY3VtZW50LCBuZ1pvbmUsIHNjaGVtYSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuY29tcG9uZW50ID0gY29tcG9uZW50O1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdHlsZXMgPSBfYW5ndWxhcl9wbGF0Zm9ybUJyb3dzZXIuybVmbGF0dGVuU3R5bGVzKGNvbXBvbmVudC5pZCwgY29tcG9uZW50LnN0eWxlcywgW10pO1xuICAgICAgICBzaGFyZWRTdHlsZXNIb3N0LmFkZFN0eWxlcyhzdHlsZXMpO1xuICAgICAgICBfdGhpcy5jb250ZW50QXR0ciA9IF9hbmd1bGFyX3BsYXRmb3JtQnJvd3Nlci7JtXNoaW1Db250ZW50QXR0cmlidXRlKGNvbXBvbmVudC5pZCk7XG4gICAgICAgIF90aGlzLmhvc3RBdHRyID0gX2FuZ3VsYXJfcGxhdGZvcm1Ccm93c2VyLsm1c2hpbUhvc3RBdHRyaWJ1dGUoY29tcG9uZW50LmlkKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEVtdWxhdGVkRW5jYXBzdWxhdGlvblNlcnZlclJlbmRlcmVyMi5wcm90b3R5cGUuYXBwbHlUb0hvc3QgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChlbGVtZW50KSB7IF9zdXBlci5wcm90b3R5cGUuc2V0QXR0cmlidXRlLmNhbGwodGhpcywgZWxlbWVudCwgdGhpcy5ob3N0QXR0ciwgJycpOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcGFyZW50XG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBFbXVsYXRlZEVuY2Fwc3VsYXRpb25TZXJ2ZXJSZW5kZXJlcjIucHJvdG90eXBlLmNyZWF0ZUVsZW1lbnQgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IHBhcmVudFxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKHBhcmVudCwgbmFtZSkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlbCA9IF9zdXBlci5wcm90b3R5cGUuY3JlYXRlRWxlbWVudC5jYWxsKHRoaXMsIHBhcmVudCwgbmFtZSk7XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuc2V0QXR0cmlidXRlLmNhbGwodGhpcywgZWwsIHRoaXMuY29udGVudEF0dHIsICcnKTtcbiAgICAgICAgcmV0dXJuIGVsO1xuICAgIH07XG4gICAgcmV0dXJuIEVtdWxhdGVkRW5jYXBzdWxhdGlvblNlcnZlclJlbmRlcmVyMjtcbn0oRGVmYXVsdFNlcnZlclJlbmRlcmVyMikpO1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgYWRkZWQgYnkgdHNpY2tsZVxuICogQHN1cHByZXNzIHtjaGVja1R5cGVzfSBjaGVja2VkIGJ5IHRzY1xuICovXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgU2VydmVyU3R5bGVzSG9zdCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFNlcnZlclN0eWxlc0hvc3QsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU2VydmVyU3R5bGVzSG9zdChkb2MsIHRyYW5zaXRpb25JZCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5kb2MgPSBkb2M7XG4gICAgICAgIF90aGlzLnRyYW5zaXRpb25JZCA9IHRyYW5zaXRpb25JZDtcbiAgICAgICAgX3RoaXMuaGVhZCA9IG51bGw7XG4gICAgICAgIF90aGlzLmhlYWQgPSBfYW5ndWxhcl9wbGF0Zm9ybUJyb3dzZXIuybVnZXRET00oKS5nZXRFbGVtZW50c0J5VGFnTmFtZShkb2MsICdoZWFkJylbMF07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzdHlsZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU2VydmVyU3R5bGVzSG9zdC5wcm90b3R5cGUuX2FkZFN0eWxlID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBzdHlsZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKHN0eWxlKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGFkYXB0ZXIgPSBfYW5ndWxhcl9wbGF0Zm9ybUJyb3dzZXIuybVnZXRET00oKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZWwgPSBhZGFwdGVyLmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gICAgICAgIGFkYXB0ZXIuc2V0VGV4dChlbCwgc3R5bGUpO1xuICAgICAgICBpZiAoISF0aGlzLnRyYW5zaXRpb25JZCkge1xuICAgICAgICAgICAgYWRhcHRlci5zZXRBdHRyaWJ1dGUoZWwsICduZy10cmFuc2l0aW9uJywgdGhpcy50cmFuc2l0aW9uSWQpO1xuICAgICAgICB9XG4gICAgICAgIGFkYXB0ZXIuYXBwZW5kQ2hpbGQodGhpcy5oZWFkLCBlbCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFkZGl0aW9uc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU2VydmVyU3R5bGVzSG9zdC5wcm90b3R5cGUub25TdHlsZXNBZGRlZCA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gYWRkaXRpb25zXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoYWRkaXRpb25zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGFkZGl0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChzdHlsZSkgeyByZXR1cm4gX3RoaXMuX2FkZFN0eWxlKHN0eWxlKTsgfSk7XG4gICAgfTtcbiAgICBTZXJ2ZXJTdHlsZXNIb3N0LmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3RhYmxlIH0sXG4gICAgXTtcbiAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICBTZXJ2ZXJTdHlsZXNIb3N0LmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgICAgICB7IHR5cGU6IHVuZGVmaW5lZCwgZGVjb3JhdG9yczogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3QsIGFyZ3M6IFtfYW5ndWxhcl9wbGF0Zm9ybUJyb3dzZXIuRE9DVU1FTlQsXSB9LF0gfSxcbiAgICAgICAgeyB0eXBlOiB1bmRlZmluZWQsIGRlY29yYXRvcnM6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuT3B0aW9uYWwgfSwgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdCwgYXJnczogW19hbmd1bGFyX3BsYXRmb3JtQnJvd3Nlci7JtVRSQU5TSVRJT05fSUQsXSB9LF0gfSxcbiAgICBdOyB9O1xuICAgIHJldHVybiBTZXJ2ZXJTdHlsZXNIb3N0O1xufShfYW5ndWxhcl9wbGF0Zm9ybUJyb3dzZXIuybVTaGFyZWRTdHlsZXNIb3N0KSk7XG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBhZGRlZCBieSB0c2lja2xlXG4gKiBAc3VwcHJlc3Mge2NoZWNrVHlwZXN9IGNoZWNrZWQgYnkgdHNjXG4gKi9cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBJTlRFUk5BTF9TRVJWRVJfUExBVEZPUk1fUFJPVklERVJTID0gW1xuICAgIHsgcHJvdmlkZTogX2FuZ3VsYXJfcGxhdGZvcm1Ccm93c2VyLkRPQ1VNRU5ULCB1c2VGYWN0b3J5OiBfZG9jdW1lbnQsIGRlcHM6IFtfYW5ndWxhcl9jb3JlLkluamVjdG9yXSB9LFxuICAgIHsgcHJvdmlkZTogX2FuZ3VsYXJfY29yZS5QTEFURk9STV9JRCwgdXNlVmFsdWU6IF9hbmd1bGFyX2NvbW1vbi7JtVBMQVRGT1JNX1NFUlZFUl9JRCB9LFxuICAgIHsgcHJvdmlkZTogX2FuZ3VsYXJfY29yZS5QTEFURk9STV9JTklUSUFMSVpFUiwgdXNlRmFjdG9yeTogaW5pdERvbWlub0FkYXB0ZXIsIG11bHRpOiB0cnVlLCBkZXBzOiBbX2FuZ3VsYXJfY29yZS5JbmplY3Rvcl0gfSwge1xuICAgICAgICBwcm92aWRlOiBfYW5ndWxhcl9jb21tb24uUGxhdGZvcm1Mb2NhdGlvbixcbiAgICAgICAgdXNlQ2xhc3M6IFNlcnZlclBsYXRmb3JtTG9jYXRpb24sXG4gICAgICAgIGRlcHM6IFtfYW5ndWxhcl9wbGF0Zm9ybUJyb3dzZXIuRE9DVU1FTlQsIFtfYW5ndWxhcl9jb3JlLk9wdGlvbmFsLCBJTklUSUFMX0NPTkZJR11dXG4gICAgfSxcbiAgICB7IHByb3ZpZGU6IFBsYXRmb3JtU3RhdGUsIGRlcHM6IFtfYW5ndWxhcl9wbGF0Zm9ybUJyb3dzZXIuRE9DVU1FTlRdIH0sXG4gICAgLy8gQWRkIHNwZWNpYWwgcHJvdmlkZXIgdGhhdCBhbGxvd3MgbXVsdGlwbGUgaW5zdGFuY2VzIG9mIHBsYXRmb3JtU2VydmVyKiB0byBiZSBjcmVhdGVkLlxuICAgIHsgcHJvdmlkZTogX2FuZ3VsYXJfY29yZS7JtUFMTE9XX01VTFRJUExFX1BMQVRGT1JNUywgdXNlVmFsdWU6IHRydWUgfVxuXTtcbi8qKlxuICogQHBhcmFtIHs/fSBpbmplY3RvclxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gaW5pdERvbWlub0FkYXB0ZXIoaW5qZWN0b3IpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkgeyBEb21pbm9BZGFwdGVyLm1ha2VDdXJyZW50KCk7IH07XG59XG4vKipcbiAqIEBwYXJhbSB7P30gcmVuZGVyZXJcbiAqIEBwYXJhbSB7P30gZW5naW5lXG4gKiBAcGFyYW0gez99IHpvbmVcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGluc3RhbnRpYXRlU2VydmVyUmVuZGVyZXJGYWN0b3J5KHJlbmRlcmVyLCBlbmdpbmUsIHpvbmUpIHtcbiAgICByZXR1cm4gbmV3IF9hbmd1bGFyX3BsYXRmb3JtQnJvd3Nlcl9hbmltYXRpb25zLsm1QW5pbWF0aW9uUmVuZGVyZXJGYWN0b3J5KHJlbmRlcmVyLCBlbmdpbmUsIHpvbmUpO1xufVxudmFyIFNFUlZFUl9SRU5ERVJfUFJPVklERVJTID0gW1xuICAgIFNlcnZlclJlbmRlcmVyRmFjdG9yeTIsXG4gICAge1xuICAgICAgICBwcm92aWRlOiBfYW5ndWxhcl9jb3JlLlJlbmRlcmVyRmFjdG9yeTIsXG4gICAgICAgIHVzZUZhY3Rvcnk6IGluc3RhbnRpYXRlU2VydmVyUmVuZGVyZXJGYWN0b3J5LFxuICAgICAgICBkZXBzOiBbU2VydmVyUmVuZGVyZXJGYWN0b3J5MiwgX2FuZ3VsYXJfYW5pbWF0aW9uc19icm93c2VyLsm1QW5pbWF0aW9uRW5naW5lLCBfYW5ndWxhcl9jb3JlLk5nWm9uZV1cbiAgICB9LFxuICAgIFNlcnZlclN0eWxlc0hvc3QsXG4gICAgeyBwcm92aWRlOiBfYW5ndWxhcl9wbGF0Zm9ybUJyb3dzZXIuybVTaGFyZWRTdHlsZXNIb3N0LCB1c2VFeGlzdGluZzogU2VydmVyU3R5bGVzSG9zdCB9LFxuXTtcbi8qKlxuICogVGhlIG5nIG1vZHVsZSBmb3IgdGhlIHNlcnZlci5cbiAqXG4gKiBcXEBleHBlcmltZW50YWxcbiAqL1xudmFyIFNlcnZlck1vZHVsZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU2VydmVyTW9kdWxlKCkge1xuICAgIH1cbiAgICBTZXJ2ZXJNb2R1bGUuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLk5nTW9kdWxlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICBleHBvcnRzOiBbX2FuZ3VsYXJfcGxhdGZvcm1Ccm93c2VyLkJyb3dzZXJNb2R1bGVdLFxuICAgICAgICAgICAgICAgICAgICBpbXBvcnRzOiBbX2FuZ3VsYXJfaHR0cC5IdHRwTW9kdWxlLCBfYW5ndWxhcl9jb21tb25faHR0cC5IdHRwQ2xpZW50TW9kdWxlLCBfYW5ndWxhcl9wbGF0Zm9ybUJyb3dzZXJfYW5pbWF0aW9ucy5Ob29wQW5pbWF0aW9uc01vZHVsZV0sXG4gICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICAgICAgICAgICAgICAgICAgU0VSVkVSX1JFTkRFUl9QUk9WSURFUlMsXG4gICAgICAgICAgICAgICAgICAgICAgICBTRVJWRVJfSFRUUF9QUk9WSURFUlMsXG4gICAgICAgICAgICAgICAgICAgICAgICB7IHByb3ZpZGU6IF9hbmd1bGFyX2NvcmUuVGVzdGFiaWxpdHksIHVzZVZhbHVlOiBudWxsIH0sXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSxdIH0sXG4gICAgXTtcbiAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICBTZXJ2ZXJNb2R1bGUuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXTsgfTtcbiAgICByZXR1cm4gU2VydmVyTW9kdWxlO1xufSgpKTtcbi8qKlxuICogQHBhcmFtIHs/fSBpbmplY3RvclxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gX2RvY3VtZW50KGluamVjdG9yKSB7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY29uZmlnID0gaW5qZWN0b3IuZ2V0KElOSVRJQUxfQ09ORklHLCBudWxsKTtcbiAgICBpZiAoY29uZmlnICYmIGNvbmZpZy5kb2N1bWVudCkge1xuICAgICAgICByZXR1cm4gcGFyc2VEb2N1bWVudChjb25maWcuZG9jdW1lbnQsIGNvbmZpZy51cmwpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIF9hbmd1bGFyX3BsYXRmb3JtQnJvd3Nlci7JtWdldERPTSgpLmNyZWF0ZUh0bWxEb2N1bWVudCgpO1xuICAgIH1cbn1cbi8qKlxuICogXFxAZXhwZXJpbWVudGFsXG4gKi9cbnZhciBwbGF0Zm9ybVNlcnZlciA9IF9hbmd1bGFyX2NvcmUuY3JlYXRlUGxhdGZvcm1GYWN0b3J5KF9hbmd1bGFyX2NvcmUucGxhdGZvcm1Db3JlLCAnc2VydmVyJywgSU5URVJOQUxfU0VSVkVSX1BMQVRGT1JNX1BST1ZJREVSUyk7XG4vKipcbiAqIFRoZSBzZXJ2ZXIgcGxhdGZvcm0gdGhhdCBzdXBwb3J0cyB0aGUgcnVudGltZSBjb21waWxlci5cbiAqXG4gKiBcXEBleHBlcmltZW50YWxcbiAqL1xudmFyIHBsYXRmb3JtRHluYW1pY1NlcnZlciA9IF9hbmd1bGFyX2NvcmUuY3JlYXRlUGxhdGZvcm1GYWN0b3J5KF9hbmd1bGFyX3BsYXRmb3JtQnJvd3NlckR5bmFtaWMuybVwbGF0Zm9ybUNvcmVEeW5hbWljLCAnc2VydmVyRHluYW1pYycsIElOVEVSTkFMX1NFUlZFUl9QTEFURk9STV9QUk9WSURFUlMpO1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgYWRkZWQgYnkgdHNpY2tsZVxuICogQHN1cHByZXNzIHtjaGVja1R5cGVzfSBjaGVja2VkIGJ5IHRzY1xuICovXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vKipcbiAqIEBwYXJhbSB7P30gcGxhdGZvcm1GYWN0b3J5XG4gKiBAcGFyYW0gez99IG9wdGlvbnNcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIF9nZXRQbGF0Zm9ybShwbGF0Zm9ybUZhY3RvcnksIG9wdGlvbnMpIHtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBleHRyYVByb3ZpZGVycyA9IG9wdGlvbnMuZXh0cmFQcm92aWRlcnMgPyBvcHRpb25zLmV4dHJhUHJvdmlkZXJzIDogW107XG4gICAgcmV0dXJuIHBsYXRmb3JtRmFjdG9yeShbXG4gICAgICAgIHsgcHJvdmlkZTogSU5JVElBTF9DT05GSUcsIHVzZVZhbHVlOiB7IGRvY3VtZW50OiBvcHRpb25zLmRvY3VtZW50LCB1cmw6IG9wdGlvbnMudXJsIH0gfSxcbiAgICAgICAgZXh0cmFQcm92aWRlcnNcbiAgICBdKTtcbn1cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7P30gcGxhdGZvcm1cbiAqIEBwYXJhbSB7P30gbW9kdWxlUmVmUHJvbWlzZVxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gX3JlbmRlcihwbGF0Zm9ybSwgbW9kdWxlUmVmUHJvbWlzZSkge1xuICAgIHJldHVybiBtb2R1bGVSZWZQcm9taXNlLnRoZW4oZnVuY3Rpb24gKG1vZHVsZVJlZikge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0cmFuc2l0aW9uSWQgPSBtb2R1bGVSZWYuaW5qZWN0b3IuZ2V0KF9hbmd1bGFyX3BsYXRmb3JtQnJvd3Nlci7JtVRSQU5TSVRJT05fSUQsIG51bGwpO1xuICAgICAgICBpZiAoIXRyYW5zaXRpb25JZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwicmVuZGVyTW9kdWxlW0ZhY3RvcnldKCkgcmVxdWlyZXMgdGhlIHVzZSBvZiBCcm93c2VyTW9kdWxlLndpdGhTZXJ2ZXJUcmFuc2l0aW9uKCkgdG8gZW5zdXJlXFxudGhlIHNlcnZlci1yZW5kZXJlZCBhcHAgY2FuIGJlIHByb3Blcmx5IGJvb3RzdHJhcHBlZCBpbnRvIGEgY2xpZW50IGFwcC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYXBwbGljYXRpb25SZWYgPSBtb2R1bGVSZWYuaW5qZWN0b3IuZ2V0KF9hbmd1bGFyX2NvcmUuQXBwbGljYXRpb25SZWYpO1xuICAgICAgICByZXR1cm4gcnhqc19vcGVyYXRvcl90b1Byb21pc2UudG9Qcm9taXNlXG4gICAgICAgICAgICAuY2FsbChyeGpzX29wZXJhdG9yX2ZpcnN0LmZpcnN0LmNhbGwocnhqc19vcGVyYXRvcl9maWx0ZXIuZmlsdGVyLmNhbGwoYXBwbGljYXRpb25SZWYuaXNTdGFibGUsIGZ1bmN0aW9uIChpc1N0YWJsZSkgeyByZXR1cm4gaXNTdGFibGU7IH0pKSlcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBsYXRmb3JtU3RhdGUgPSBwbGF0Zm9ybS5pbmplY3Rvci5nZXQoUGxhdGZvcm1TdGF0ZSk7XG4gICAgICAgICAgICAvLyBSdW4gYW55IEJFRk9SRV9BUFBfU0VSSUFMSVpFRCBjYWxsYmFja3MganVzdCBiZWZvcmUgcmVuZGVyaW5nIHRvIHN0cmluZy5cbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNhbGxiYWNrcyA9IG1vZHVsZVJlZi5pbmplY3Rvci5nZXQoQkVGT1JFX0FQUF9TRVJJQUxJWkVELCBudWxsKTtcbiAgICAgICAgICAgIGlmIChjYWxsYmFja3MpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIGNhbGxiYWNrc18xID0gY2FsbGJhY2tzOyBfaSA8IGNhbGxiYWNrc18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2FsbGJhY2sgPSBjYWxsYmFja3NfMVtfaV07XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoICgvKiogQHR5cGUgez99ICovIGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElnbm9yZSBleGNlcHRpb25zLlxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdJZ25vcmluZyBCRUZPUkVfQVBQX1NFUklBTElaRUQgRXhjZXB0aW9uOiAnLCBlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG91dHB1dCA9IHBsYXRmb3JtU3RhdGUucmVuZGVyVG9TdHJpbmcoKTtcbiAgICAgICAgICAgIHBsYXRmb3JtLmRlc3Ryb3koKTtcbiAgICAgICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuLyoqXG4gKiBSZW5kZXJzIGEgTW9kdWxlIHRvIHN0cmluZy5cbiAqXG4gKiBgZG9jdW1lbnRgIGlzIHRoZSBmdWxsIGRvY3VtZW50IEhUTUwgb2YgdGhlIHBhZ2UgdG8gcmVuZGVyLCBhcyBhIHN0cmluZy5cbiAqIGB1cmxgIGlzIHRoZSBVUkwgZm9yIHRoZSBjdXJyZW50IHJlbmRlciByZXF1ZXN0LlxuICogYGV4dHJhUHJvdmlkZXJzYCBhcmUgdGhlIHBsYXRmb3JtIGxldmVsIHByb3ZpZGVycyBmb3IgdGhlIGN1cnJlbnQgcmVuZGVyIHJlcXVlc3QuXG4gKlxuICogRG8gbm90IHVzZSB0aGlzIGluIGEgcHJvZHVjdGlvbiBzZXJ2ZXIgZW52aXJvbm1lbnQuIFVzZSBwcmUtY29tcGlsZWQge1xcQGxpbmsgTmdNb2R1bGVGYWN0b3J5fSB3aXRoXG4gKiB7XFxAbGluayByZW5kZXJNb2R1bGVGYWN0b3J5fSBpbnN0ZWFkLlxuICpcbiAqIFxcQGV4cGVyaW1lbnRhbFxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7P30gbW9kdWxlXG4gKiBAcGFyYW0gez99IG9wdGlvbnNcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIHJlbmRlck1vZHVsZShtb2R1bGUsIG9wdGlvbnMpIHtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwbGF0Zm9ybSA9IF9nZXRQbGF0Zm9ybShwbGF0Zm9ybUR5bmFtaWNTZXJ2ZXIsIG9wdGlvbnMpO1xuICAgIHJldHVybiBfcmVuZGVyKHBsYXRmb3JtLCBwbGF0Zm9ybS5ib290c3RyYXBNb2R1bGUobW9kdWxlKSk7XG59XG4vKipcbiAqIFJlbmRlcnMgYSB7XFxAbGluayBOZ01vZHVsZUZhY3Rvcnl9IHRvIHN0cmluZy5cbiAqXG4gKiBgZG9jdW1lbnRgIGlzIHRoZSBmdWxsIGRvY3VtZW50IEhUTUwgb2YgdGhlIHBhZ2UgdG8gcmVuZGVyLCBhcyBhIHN0cmluZy5cbiAqIGB1cmxgIGlzIHRoZSBVUkwgZm9yIHRoZSBjdXJyZW50IHJlbmRlciByZXF1ZXN0LlxuICogYGV4dHJhUHJvdmlkZXJzYCBhcmUgdGhlIHBsYXRmb3JtIGxldmVsIHByb3ZpZGVycyBmb3IgdGhlIGN1cnJlbnQgcmVuZGVyIHJlcXVlc3QuXG4gKlxuICogXFxAZXhwZXJpbWVudGFsXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHs/fSBtb2R1bGVGYWN0b3J5XG4gKiBAcGFyYW0gez99IG9wdGlvbnNcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIHJlbmRlck1vZHVsZUZhY3RvcnkobW9kdWxlRmFjdG9yeSwgb3B0aW9ucykge1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIHBsYXRmb3JtID0gX2dldFBsYXRmb3JtKHBsYXRmb3JtU2VydmVyLCBvcHRpb25zKTtcbiAgICByZXR1cm4gX3JlbmRlcihwbGF0Zm9ybSwgcGxhdGZvcm0uYm9vdHN0cmFwTW9kdWxlRmFjdG9yeShtb2R1bGVGYWN0b3J5KSk7XG59XG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBhZGRlZCBieSB0c2lja2xlXG4gKiBAc3VwcHJlc3Mge2NoZWNrVHlwZXN9IGNoZWNrZWQgYnkgdHNjXG4gKi9cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IGFkZGVkIGJ5IHRzaWNrbGVcbiAqIEBzdXBwcmVzcyB7Y2hlY2tUeXBlc30gY2hlY2tlZCBieSB0c2NcbiAqL1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLyoqXG4gKiBAbW9kdWxlXG4gKiBAZGVzY3JpcHRpb25cbiAqIEVudHJ5IHBvaW50IGZvciBhbGwgcHVibGljIEFQSXMgb2YgdGhlIGNvbW1vbiBwYWNrYWdlLlxuICovXG4vKipcbiAqIFxcQHN0YWJsZVxuICovXG52YXIgVkVSU0lPTiA9IG5ldyBfYW5ndWxhcl9jb3JlLlZlcnNpb24oJzUuMC4wLWJldGEuNycpO1xuXG5leHBvcnRzLlBsYXRmb3JtU3RhdGUgPSBQbGF0Zm9ybVN0YXRlO1xuZXhwb3J0cy5TZXJ2ZXJNb2R1bGUgPSBTZXJ2ZXJNb2R1bGU7XG5leHBvcnRzLnBsYXRmb3JtRHluYW1pY1NlcnZlciA9IHBsYXRmb3JtRHluYW1pY1NlcnZlcjtcbmV4cG9ydHMucGxhdGZvcm1TZXJ2ZXIgPSBwbGF0Zm9ybVNlcnZlcjtcbmV4cG9ydHMuQkVGT1JFX0FQUF9TRVJJQUxJWkVEID0gQkVGT1JFX0FQUF9TRVJJQUxJWkVEO1xuZXhwb3J0cy5JTklUSUFMX0NPTkZJRyA9IElOSVRJQUxfQ09ORklHO1xuZXhwb3J0cy5yZW5kZXJNb2R1bGUgPSByZW5kZXJNb2R1bGU7XG5leHBvcnRzLnJlbmRlck1vZHVsZUZhY3RvcnkgPSByZW5kZXJNb2R1bGVGYWN0b3J5O1xuZXhwb3J0cy5WRVJTSU9OID0gVkVSU0lPTjtcbmV4cG9ydHMuybVJTlRFUk5BTF9TRVJWRVJfUExBVEZPUk1fUFJPVklERVJTID0gSU5URVJOQUxfU0VSVkVSX1BMQVRGT1JNX1BST1ZJREVSUztcbmV4cG9ydHMuybVTRVJWRVJfUkVOREVSX1BST1ZJREVSUyA9IFNFUlZFUl9SRU5ERVJfUFJPVklERVJTO1xuZXhwb3J0cy7JtVNlcnZlclJlbmRlcmVyRmFjdG9yeTIgPSBTZXJ2ZXJSZW5kZXJlckZhY3RvcnkyO1xuZXhwb3J0cy7JtWcgPSBTRVJWRVJfSFRUUF9QUk9WSURFUlM7XG5leHBvcnRzLsm1YyA9IFNlcnZlclhocjtcbmV4cG9ydHMuybVkID0gU2VydmVyWHNyZlN0cmF0ZWd5O1xuZXhwb3J0cy7JtWUgPSBodHRwRmFjdG9yeTtcbmV4cG9ydHMuybVmID0gem9uZVdyYXBwZWRJbnRlcmNlcHRpbmdIYW5kbGVyO1xuZXhwb3J0cy7JtWEgPSBpbnN0YW50aWF0ZVNlcnZlclJlbmRlcmVyRmFjdG9yeTtcbmV4cG9ydHMuybViID0gU2VydmVyU3R5bGVzSG9zdDtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxufSkpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBsYXRmb3JtLXNlcnZlci51bWQuanMubWFwXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AYW5ndWxhci9wbGF0Zm9ybS1zZXJ2ZXIvYnVuZGxlcy9wbGF0Zm9ybS1zZXJ2ZXIudW1kLmpzXG4vLyBtb2R1bGUgaWQgPSAzNFxuLy8gbW9kdWxlIGNodW5rcyA9IDQiLCIvKipcbiAqIEBsaWNlbnNlIEFuZ3VsYXIgdjUuMC4wLWJldGEuN1xuICogKGMpIDIwMTAtMjAxNyBHb29nbGUsIEluYy4gaHR0cHM6Ly9hbmd1bGFyLmlvL1xuICogTGljZW5zZTogTUlUXG4gKi9cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG5cdHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cywgcmVxdWlyZSgnQGFuZ3VsYXIvYW5pbWF0aW9ucycpKSA6XG5cdHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ2V4cG9ydHMnLCAnQGFuZ3VsYXIvYW5pbWF0aW9ucyddLCBmYWN0b3J5KSA6XG5cdChmYWN0b3J5KChnbG9iYWwubmcgPSBnbG9iYWwubmcgfHwge30sIGdsb2JhbC5uZy5hbmltYXRpb25zID0gZ2xvYmFsLm5nLmFuaW1hdGlvbnMgfHwge30sIGdsb2JhbC5uZy5hbmltYXRpb25zLmJyb3dzZXIgPSB7fSksZ2xvYmFsLm5nLmFuaW1hdGlvbnMpKTtcbn0odGhpcywgKGZ1bmN0aW9uIChleHBvcnRzLF9hbmd1bGFyX2FuaW1hdGlvbnMpIHsgJ3VzZSBzdHJpY3QnO1xuXG4vKiEgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZVxyXG50aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZVxyXG5MaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG5cclxuVEhJUyBDT0RFIElTIFBST1ZJREVEIE9OIEFOICpBUyBJUyogQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG5LSU5ELCBFSVRIRVIgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgV0lUSE9VVCBMSU1JVEFUSU9OIEFOWSBJTVBMSUVEXHJcbldBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBUSVRMRSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UsXHJcbk1FUkNIQU5UQUJMSVRZIE9SIE5PTi1JTkZSSU5HRU1FTlQuXHJcblxyXG5TZWUgdGhlIEFwYWNoZSBWZXJzaW9uIDIuMCBMaWNlbnNlIGZvciBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnNcclxuYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG4vKiBnbG9iYWwgUmVmbGVjdCwgUHJvbWlzZSAqL1xyXG5cclxudmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xyXG5cclxuZnVuY3Rpb24gX19leHRlbmRzKGQsIGIpIHtcclxuICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxufVxyXG5cclxudmFyIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiBfX2Fzc2lnbih0KSB7XHJcbiAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xyXG4gICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSkgdFtwXSA9IHNbcF07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdDtcclxufTtcblxuLyoqXG4gKiBAbGljZW5zZSBBbmd1bGFyIHY1LjAuMC1iZXRhLjdcbiAqIChjKSAyMDEwLTIwMTcgR29vZ2xlLCBJbmMuIGh0dHBzOi8vYW5ndWxhci5pby9cbiAqIExpY2Vuc2U6IE1JVFxuICovXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgYWRkZWQgYnkgdHNpY2tsZVxuICogQHN1cHByZXNzIHtjaGVja1R5cGVzfSBjaGVja2VkIGJ5IHRzY1xuICovXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vKipcbiAqIEBwYXJhbSB7P30gcGxheWVyc1xuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gb3B0aW1pemVHcm91cFBsYXllcihwbGF5ZXJzKSB7XG4gICAgc3dpdGNoIChwbGF5ZXJzLmxlbmd0aCkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICByZXR1cm4gbmV3IF9hbmd1bGFyX2FuaW1hdGlvbnMuTm9vcEFuaW1hdGlvblBsYXllcigpO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICByZXR1cm4gcGxheWVyc1swXTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBuZXcgX2FuZ3VsYXJfYW5pbWF0aW9ucy7JtUFuaW1hdGlvbkdyb3VwUGxheWVyKHBsYXllcnMpO1xuICAgIH1cbn1cbi8qKlxuICogQHBhcmFtIHs/fSBkcml2ZXJcbiAqIEBwYXJhbSB7P30gbm9ybWFsaXplclxuICogQHBhcmFtIHs/fSBlbGVtZW50XG4gKiBAcGFyYW0gez99IGtleWZyYW1lc1xuICogQHBhcmFtIHs/PX0gcHJlU3R5bGVzXG4gKiBAcGFyYW0gez89fSBwb3N0U3R5bGVzXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBub3JtYWxpemVLZXlmcmFtZXMoZHJpdmVyLCBub3JtYWxpemVyLCBlbGVtZW50LCBrZXlmcmFtZXMsIHByZVN0eWxlcywgcG9zdFN0eWxlcykge1xuICAgIGlmIChwcmVTdHlsZXMgPT09IHZvaWQgMCkgeyBwcmVTdHlsZXMgPSB7fTsgfVxuICAgIGlmIChwb3N0U3R5bGVzID09PSB2b2lkIDApIHsgcG9zdFN0eWxlcyA9IHt9OyB9XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZXJyb3JzID0gW107XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbm9ybWFsaXplZEtleWZyYW1lcyA9IFtdO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIHByZXZpb3VzT2Zmc2V0ID0gLTE7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcHJldmlvdXNLZXlmcmFtZSA9IG51bGw7XG4gICAga2V5ZnJhbWVzLmZvckVhY2goZnVuY3Rpb24gKGtmKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG9mZnNldCA9IC8qKiBAdHlwZSB7P30gKi8gKGtmWydvZmZzZXQnXSk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGlzU2FtZU9mZnNldCA9IG9mZnNldCA9PSBwcmV2aW91c09mZnNldDtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbm9ybWFsaXplZEtleWZyYW1lID0gKGlzU2FtZU9mZnNldCAmJiBwcmV2aW91c0tleWZyYW1lKSB8fCB7fTtcbiAgICAgICAgT2JqZWN0LmtleXMoa2YpLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5vcm1hbGl6ZWRQcm9wID0gcHJvcDtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5vcm1hbGl6ZWRWYWx1ZSA9IGtmW3Byb3BdO1xuICAgICAgICAgICAgaWYgKHByb3AgIT09ICdvZmZzZXQnKSB7XG4gICAgICAgICAgICAgICAgbm9ybWFsaXplZFByb3AgPSBub3JtYWxpemVyLm5vcm1hbGl6ZVByb3BlcnR5TmFtZShub3JtYWxpemVkUHJvcCwgZXJyb3JzKTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKG5vcm1hbGl6ZWRWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIF9hbmd1bGFyX2FuaW1hdGlvbnMuybVQUkVfU1RZTEU6XG4gICAgICAgICAgICAgICAgICAgICAgICBub3JtYWxpemVkVmFsdWUgPSBwcmVTdHlsZXNbcHJvcF07XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBfYW5ndWxhcl9hbmltYXRpb25zLkFVVE9fU1RZTEU6XG4gICAgICAgICAgICAgICAgICAgICAgICBub3JtYWxpemVkVmFsdWUgPSBwb3N0U3R5bGVzW3Byb3BdO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBub3JtYWxpemVkVmFsdWUgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vcm1hbGl6ZXIubm9ybWFsaXplU3R5bGVWYWx1ZShwcm9wLCBub3JtYWxpemVkUHJvcCwgbm9ybWFsaXplZFZhbHVlLCBlcnJvcnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm9ybWFsaXplZEtleWZyYW1lW25vcm1hbGl6ZWRQcm9wXSA9IG5vcm1hbGl6ZWRWYWx1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghaXNTYW1lT2Zmc2V0KSB7XG4gICAgICAgICAgICBub3JtYWxpemVkS2V5ZnJhbWVzLnB1c2gobm9ybWFsaXplZEtleWZyYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBwcmV2aW91c0tleWZyYW1lID0gbm9ybWFsaXplZEtleWZyYW1lO1xuICAgICAgICBwcmV2aW91c09mZnNldCA9IG9mZnNldDtcbiAgICB9KTtcbiAgICBpZiAoZXJyb3JzLmxlbmd0aCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBMSU5FX1NUQVJUID0gJ1xcbiAtICc7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byBhbmltYXRlIGR1ZSB0byB0aGUgZm9sbG93aW5nIGVycm9yczpcIiArIExJTkVfU1RBUlQgKyBlcnJvcnMuam9pbihMSU5FX1NUQVJUKSk7XG4gICAgfVxuICAgIHJldHVybiBub3JtYWxpemVkS2V5ZnJhbWVzO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IHBsYXllclxuICogQHBhcmFtIHs/fSBldmVudE5hbWVcbiAqIEBwYXJhbSB7P30gZXZlbnRcbiAqIEBwYXJhbSB7P30gY2FsbGJhY2tcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGxpc3Rlbk9uUGxheWVyKHBsYXllciwgZXZlbnROYW1lLCBldmVudCwgY2FsbGJhY2spIHtcbiAgICBzd2l0Y2ggKGV2ZW50TmFtZSkge1xuICAgICAgICBjYXNlICdzdGFydCc6XG4gICAgICAgICAgICBwbGF5ZXIub25TdGFydChmdW5jdGlvbiAoKSB7IHJldHVybiBjYWxsYmFjayhldmVudCAmJiBjb3B5QW5pbWF0aW9uRXZlbnQoZXZlbnQsICdzdGFydCcsIHBsYXllci50b3RhbFRpbWUpKTsgfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnZG9uZSc6XG4gICAgICAgICAgICBwbGF5ZXIub25Eb25lKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNhbGxiYWNrKGV2ZW50ICYmIGNvcHlBbmltYXRpb25FdmVudChldmVudCwgJ2RvbmUnLCBwbGF5ZXIudG90YWxUaW1lKSk7IH0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2Rlc3Ryb3knOlxuICAgICAgICAgICAgcGxheWVyLm9uRGVzdHJveShmdW5jdGlvbiAoKSB7IHJldHVybiBjYWxsYmFjayhldmVudCAmJiBjb3B5QW5pbWF0aW9uRXZlbnQoZXZlbnQsICdkZXN0cm95JywgcGxheWVyLnRvdGFsVGltZSkpOyB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbn1cbi8qKlxuICogQHBhcmFtIHs/fSBlXG4gKiBAcGFyYW0gez89fSBwaGFzZU5hbWVcbiAqIEBwYXJhbSB7Pz19IHRvdGFsVGltZVxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gY29weUFuaW1hdGlvbkV2ZW50KGUsIHBoYXNlTmFtZSwgdG90YWxUaW1lKSB7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZXZlbnQgPSBtYWtlQW5pbWF0aW9uRXZlbnQoZS5lbGVtZW50LCBlLnRyaWdnZXJOYW1lLCBlLmZyb21TdGF0ZSwgZS50b1N0YXRlLCBwaGFzZU5hbWUgfHwgZS5waGFzZU5hbWUsIHRvdGFsVGltZSA9PSB1bmRlZmluZWQgPyBlLnRvdGFsVGltZSA6IHRvdGFsVGltZSk7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZGF0YSA9ICgvKiogQHR5cGUgez99ICovIChlKSlbJ19kYXRhJ107XG4gICAgaWYgKGRhdGEgIT0gbnVsbCkge1xuICAgICAgICAoLyoqIEB0eXBlIHs/fSAqLyAoZXZlbnQpKVsnX2RhdGEnXSA9IGRhdGE7XG4gICAgfVxuICAgIHJldHVybiBldmVudDtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBlbGVtZW50XG4gKiBAcGFyYW0gez99IHRyaWdnZXJOYW1lXG4gKiBAcGFyYW0gez99IGZyb21TdGF0ZVxuICogQHBhcmFtIHs/fSB0b1N0YXRlXG4gKiBAcGFyYW0gez89fSBwaGFzZU5hbWVcbiAqIEBwYXJhbSB7Pz19IHRvdGFsVGltZVxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gbWFrZUFuaW1hdGlvbkV2ZW50KGVsZW1lbnQsIHRyaWdnZXJOYW1lLCBmcm9tU3RhdGUsIHRvU3RhdGUsIHBoYXNlTmFtZSwgdG90YWxUaW1lKSB7XG4gICAgaWYgKHBoYXNlTmFtZSA9PT0gdm9pZCAwKSB7IHBoYXNlTmFtZSA9ICcnOyB9XG4gICAgaWYgKHRvdGFsVGltZSA9PT0gdm9pZCAwKSB7IHRvdGFsVGltZSA9IDA7IH1cbiAgICByZXR1cm4geyBlbGVtZW50OiBlbGVtZW50LCB0cmlnZ2VyTmFtZTogdHJpZ2dlck5hbWUsIGZyb21TdGF0ZTogZnJvbVN0YXRlLCB0b1N0YXRlOiB0b1N0YXRlLCBwaGFzZU5hbWU6IHBoYXNlTmFtZSwgdG90YWxUaW1lOiB0b3RhbFRpbWUgfTtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBtYXBcbiAqIEBwYXJhbSB7P30ga2V5XG4gKiBAcGFyYW0gez99IGRlZmF1bHRWYWx1ZVxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gZ2V0T3JTZXRBc0luTWFwKG1hcCwga2V5LCBkZWZhdWx0VmFsdWUpIHtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2YWx1ZTtcbiAgICBpZiAobWFwIGluc3RhbmNlb2YgTWFwKSB7XG4gICAgICAgIHZhbHVlID0gbWFwLmdldChrZXkpO1xuICAgICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgICAgICBtYXAuc2V0KGtleSwgdmFsdWUgPSBkZWZhdWx0VmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2YWx1ZSA9IG1hcFtrZXldO1xuICAgICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IG1hcFtrZXldID0gZGVmYXVsdFZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBjb21tYW5kXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBwYXJzZVRpbWVsaW5lQ29tbWFuZChjb21tYW5kKSB7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc2VwYXJhdG9yUG9zID0gY29tbWFuZC5pbmRleE9mKCc6Jyk7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaWQgPSBjb21tYW5kLnN1YnN0cmluZygxLCBzZXBhcmF0b3JQb3MpO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIGFjdGlvbiA9IGNvbW1hbmQuc3Vic3RyKHNlcGFyYXRvclBvcyArIDEpO1xuICAgIHJldHVybiBbaWQsIGFjdGlvbl07XG59XG52YXIgX2NvbnRhaW5zID0gZnVuY3Rpb24gKGVsbTEsIGVsbTIpIHsgcmV0dXJuIGZhbHNlOyB9O1xudmFyIF9tYXRjaGVzID0gZnVuY3Rpb24gKGVsZW1lbnQsIHNlbGVjdG9yKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcbnZhciBfcXVlcnkgPSBmdW5jdGlvbiAoZWxlbWVudCwgc2VsZWN0b3IsIG11bHRpKSB7XG4gICAgcmV0dXJuIFtdO1xufTtcbmlmICh0eXBlb2YgRWxlbWVudCAhPSAndW5kZWZpbmVkJykge1xuICAgIC8vIHRoaXMgaXMgd2VsbCBzdXBwb3J0ZWQgaW4gYWxsIGJyb3dzZXJzXG4gICAgX2NvbnRhaW5zID0gZnVuY3Rpb24gKGVsbTEsIGVsbTIpIHsgcmV0dXJuIC8qKiBAdHlwZSB7P30gKi8gKGVsbTEuY29udGFpbnMoZWxtMikpOyB9O1xuICAgIGlmIChFbGVtZW50LnByb3RvdHlwZS5tYXRjaGVzKSB7XG4gICAgICAgIF9tYXRjaGVzID0gZnVuY3Rpb24gKGVsZW1lbnQsIHNlbGVjdG9yKSB7IHJldHVybiBlbGVtZW50Lm1hdGNoZXMoc2VsZWN0b3IpOyB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcHJvdG8gPSAvKiogQHR5cGUgez99ICovIChFbGVtZW50LnByb3RvdHlwZSk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGZuXzEgPSBwcm90by5tYXRjaGVzU2VsZWN0b3IgfHwgcHJvdG8ubW96TWF0Y2hlc1NlbGVjdG9yIHx8IHByb3RvLm1zTWF0Y2hlc1NlbGVjdG9yIHx8XG4gICAgICAgICAgICBwcm90by5vTWF0Y2hlc1NlbGVjdG9yIHx8IHByb3RvLndlYmtpdE1hdGNoZXNTZWxlY3RvcjtcbiAgICAgICAgaWYgKGZuXzEpIHtcbiAgICAgICAgICAgIF9tYXRjaGVzID0gZnVuY3Rpb24gKGVsZW1lbnQsIHNlbGVjdG9yKSB7IHJldHVybiBmbl8xLmFwcGx5KGVsZW1lbnQsIFtzZWxlY3Rvcl0pOyB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIF9xdWVyeSA9IGZ1bmN0aW9uIChlbGVtZW50LCBzZWxlY3RvciwgbXVsdGkpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVzdWx0cyA9IFtdO1xuICAgICAgICBpZiAobXVsdGkpIHtcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaC5hcHBseShyZXN1bHRzLCBlbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVsbSA9IGVsZW1lbnQucXVlcnlTZWxlY3RvcihzZWxlY3Rvcik7XG4gICAgICAgICAgICBpZiAoZWxtKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGVsbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfTtcbn1cbnZhciBfQ0FDSEVEX0JPRFkgPSBudWxsO1xuLyoqXG4gKiBAcGFyYW0gez99IHByb3BcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlU3R5bGVQcm9wZXJ0eShwcm9wKSB7XG4gICAgaWYgKCFfQ0FDSEVEX0JPRFkpIHtcbiAgICAgICAgX0NBQ0hFRF9CT0RZID0gZ2V0Qm9keU5vZGUoKSB8fCB7fTtcbiAgICB9XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7P30gKi8gKChfQ0FDSEVEX0JPRFkpKS5zdHlsZSA/IHByb3AgaW4gLyoqIEB0eXBlIHs/fSAqLyAoKF9DQUNIRURfQk9EWSkpLnN0eWxlIDogdHJ1ZTtcbn1cbi8qKlxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gZ2V0Qm9keU5vZGUoKSB7XG4gICAgaWYgKHR5cGVvZiBkb2N1bWVudCAhPSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gZG9jdW1lbnQuYm9keTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG52YXIgbWF0Y2hlc0VsZW1lbnQgPSBfbWF0Y2hlcztcbnZhciBjb250YWluc0VsZW1lbnQgPSBfY29udGFpbnM7XG52YXIgaW52b2tlUXVlcnkgPSBfcXVlcnk7XG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBhZGRlZCBieSB0c2lja2xlXG4gKiBAc3VwcHJlc3Mge2NoZWNrVHlwZXN9IGNoZWNrZWQgYnkgdHNjXG4gKi9cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8qKlxuICogXFxAZXhwZXJpbWVudGFsXG4gKi9cbnZhciBOb29wQW5pbWF0aW9uRHJpdmVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBOb29wQW5pbWF0aW9uRHJpdmVyKCkge1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHByb3BcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE5vb3BBbmltYXRpb25Ecml2ZXIucHJvdG90eXBlLnZhbGlkYXRlU3R5bGVQcm9wZXJ0eSA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gcHJvcFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKHByb3ApIHsgcmV0dXJuIHZhbGlkYXRlU3R5bGVQcm9wZXJ0eShwcm9wKTsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0gez99IHNlbGVjdG9yXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBOb29wQW5pbWF0aW9uRHJpdmVyLnByb3RvdHlwZS5tYXRjaGVzRWxlbWVudCA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFxuICAgICAqIEBwYXJhbSB7P30gc2VsZWN0b3JcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChlbGVtZW50LCBzZWxlY3Rvcikge1xuICAgICAgICByZXR1cm4gbWF0Y2hlc0VsZW1lbnQoZWxlbWVudCwgc2VsZWN0b3IpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbG0xXG4gICAgICogQHBhcmFtIHs/fSBlbG0yXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBOb29wQW5pbWF0aW9uRHJpdmVyLnByb3RvdHlwZS5jb250YWluc0VsZW1lbnQgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsbTFcbiAgICAgKiBAcGFyYW0gez99IGVsbTJcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChlbG0xLCBlbG0yKSB7IHJldHVybiBjb250YWluc0VsZW1lbnQoZWxtMSwgZWxtMik7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XG4gICAgICogQHBhcmFtIHs/fSBzZWxlY3RvclxuICAgICAqIEBwYXJhbSB7P30gbXVsdGlcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE5vb3BBbmltYXRpb25Ecml2ZXIucHJvdG90eXBlLnF1ZXJ5ID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XG4gICAgICogQHBhcmFtIHs/fSBzZWxlY3RvclxuICAgICAqIEBwYXJhbSB7P30gbXVsdGlcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChlbGVtZW50LCBzZWxlY3RvciwgbXVsdGkpIHtcbiAgICAgICAgcmV0dXJuIGludm9rZVF1ZXJ5KGVsZW1lbnQsIHNlbGVjdG9yLCBtdWx0aSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0gez99IHByb3BcbiAgICAgKiBAcGFyYW0gez89fSBkZWZhdWx0VmFsdWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE5vb3BBbmltYXRpb25Ecml2ZXIucHJvdG90eXBlLmNvbXB1dGVTdHlsZSA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFxuICAgICAqIEBwYXJhbSB7P30gcHJvcFxuICAgICAqIEBwYXJhbSB7Pz19IGRlZmF1bHRWYWx1ZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKGVsZW1lbnQsIHByb3AsIGRlZmF1bHRWYWx1ZSkge1xuICAgICAgICByZXR1cm4gZGVmYXVsdFZhbHVlIHx8ICcnO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XG4gICAgICogQHBhcmFtIHs/fSBrZXlmcmFtZXNcbiAgICAgKiBAcGFyYW0gez99IGR1cmF0aW9uXG4gICAgICogQHBhcmFtIHs/fSBkZWxheVxuICAgICAqIEBwYXJhbSB7P30gZWFzaW5nXG4gICAgICogQHBhcmFtIHs/PX0gcHJldmlvdXNQbGF5ZXJzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBOb29wQW5pbWF0aW9uRHJpdmVyLnByb3RvdHlwZS5hbmltYXRlID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XG4gICAgICogQHBhcmFtIHs/fSBrZXlmcmFtZXNcbiAgICAgKiBAcGFyYW0gez99IGR1cmF0aW9uXG4gICAgICogQHBhcmFtIHs/fSBkZWxheVxuICAgICAqIEBwYXJhbSB7P30gZWFzaW5nXG4gICAgICogQHBhcmFtIHs/PX0gcHJldmlvdXNQbGF5ZXJzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoZWxlbWVudCwga2V5ZnJhbWVzLCBkdXJhdGlvbiwgZGVsYXksIGVhc2luZywgcHJldmlvdXNQbGF5ZXJzKSB7XG4gICAgICAgIGlmIChwcmV2aW91c1BsYXllcnMgPT09IHZvaWQgMCkgeyBwcmV2aW91c1BsYXllcnMgPSBbXTsgfVxuICAgICAgICByZXR1cm4gbmV3IF9hbmd1bGFyX2FuaW1hdGlvbnMuTm9vcEFuaW1hdGlvblBsYXllcigpO1xuICAgIH07XG4gICAgcmV0dXJuIE5vb3BBbmltYXRpb25Ecml2ZXI7XG59KCkpO1xuLyoqXG4gKiBcXEBleHBlcmltZW50YWxcbiAqIEBhYnN0cmFjdFxuICovXG52YXIgQW5pbWF0aW9uRHJpdmVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBbmltYXRpb25Ecml2ZXIoKSB7XG4gICAgfVxuICAgIEFuaW1hdGlvbkRyaXZlci5OT09QID0gbmV3IE5vb3BBbmltYXRpb25Ecml2ZXIoKTtcbiAgICByZXR1cm4gQW5pbWF0aW9uRHJpdmVyO1xufSgpKTtcblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IGFkZGVkIGJ5IHRzaWNrbGVcbiAqIEBzdXBwcmVzcyB7Y2hlY2tUeXBlc30gY2hlY2tlZCBieSB0c2NcbiAqL1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xudmFyIE9ORV9TRUNPTkQgPSAxMDAwO1xudmFyIFNVQlNUSVRVVElPTl9FWFBSX1NUQVJUID0gJ3t7JztcbnZhciBTVUJTVElUVVRJT05fRVhQUl9FTkQgPSAnfX0nO1xudmFyIEVOVEVSX0NMQVNTTkFNRSA9ICduZy1lbnRlcic7XG52YXIgTEVBVkVfQ0xBU1NOQU1FID0gJ25nLWxlYXZlJztcbnZhciBFTlRFUl9TRUxFQ1RPUiA9ICcubmctZW50ZXInO1xudmFyIExFQVZFX1NFTEVDVE9SID0gJy5uZy1sZWF2ZSc7XG52YXIgTkdfVFJJR0dFUl9DTEFTU05BTUUgPSAnbmctdHJpZ2dlcic7XG52YXIgTkdfVFJJR0dFUl9TRUxFQ1RPUiA9ICcubmctdHJpZ2dlcic7XG52YXIgTkdfQU5JTUFUSU5HX0NMQVNTTkFNRSA9ICduZy1hbmltYXRpbmcnO1xudmFyIE5HX0FOSU1BVElOR19TRUxFQ1RPUiA9ICcubmctYW5pbWF0aW5nJztcbi8qKlxuICogQHBhcmFtIHs/fSB2YWx1ZVxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZVRpbWluZ1ZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJylcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIG1hdGNoZXMgPSAoLyoqIEB0eXBlIHs/fSAqLyAodmFsdWUpKS5tYXRjaCgvXigtP1tcXC5cXGRdKykobT9zKS8pO1xuICAgIGlmICghbWF0Y2hlcyB8fCBtYXRjaGVzLmxlbmd0aCA8IDIpXG4gICAgICAgIHJldHVybiAwO1xuICAgIHJldHVybiBfY29udmVydFRpbWVWYWx1ZVRvTVMocGFyc2VGbG9hdChtYXRjaGVzWzFdKSwgbWF0Y2hlc1syXSk7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gdmFsdWVcbiAqIEBwYXJhbSB7P30gdW5pdFxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gX2NvbnZlcnRUaW1lVmFsdWVUb01TKHZhbHVlLCB1bml0KSB7XG4gICAgc3dpdGNoICh1bml0KSB7XG4gICAgICAgIGNhc2UgJ3MnOlxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlICogT05FX1NFQ09ORDtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIC8vIG1zIG9yIHNvbWV0aGluZyBlbHNlXG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxufVxuLyoqXG4gKiBAcGFyYW0gez99IHRpbWluZ3NcbiAqIEBwYXJhbSB7P30gZXJyb3JzXG4gKiBAcGFyYW0gez89fSBhbGxvd05lZ2F0aXZlVmFsdWVzXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiByZXNvbHZlVGltaW5nKHRpbWluZ3MsIGVycm9ycywgYWxsb3dOZWdhdGl2ZVZhbHVlcykge1xuICAgIHJldHVybiB0aW1pbmdzLmhhc093blByb3BlcnR5KCdkdXJhdGlvbicpID8gLyoqIEB0eXBlIHs/fSAqLyAodGltaW5ncykgOlxuICAgICAgICBwYXJzZVRpbWVFeHByZXNzaW9uKC8qKiBAdHlwZSB7P30gKi8gKHRpbWluZ3MpLCBlcnJvcnMsIGFsbG93TmVnYXRpdmVWYWx1ZXMpO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IGV4cFxuICogQHBhcmFtIHs/fSBlcnJvcnNcbiAqIEBwYXJhbSB7Pz19IGFsbG93TmVnYXRpdmVWYWx1ZXNcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIHBhcnNlVGltZUV4cHJlc3Npb24oZXhwLCBlcnJvcnMsIGFsbG93TmVnYXRpdmVWYWx1ZXMpIHtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZWdleCA9IC9eKC0/W1xcLlxcZF0rKShtP3MpKD86XFxzKygtP1tcXC5cXGRdKykobT9zKSk/KD86XFxzKyhbLWEtel0rKD86XFwoLis/XFwpKT8pKT8kL2k7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZHVyYXRpb247XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZGVsYXkgPSAwO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIGVhc2luZyA9ICcnO1xuICAgIGlmICh0eXBlb2YgZXhwID09PSAnc3RyaW5nJykge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBtYXRjaGVzID0gZXhwLm1hdGNoKHJlZ2V4KTtcbiAgICAgICAgaWYgKG1hdGNoZXMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGVycm9ycy5wdXNoKFwiVGhlIHByb3ZpZGVkIHRpbWluZyB2YWx1ZSBcXFwiXCIgKyBleHAgKyBcIlxcXCIgaXMgaW52YWxpZC5cIik7XG4gICAgICAgICAgICByZXR1cm4geyBkdXJhdGlvbjogMCwgZGVsYXk6IDAsIGVhc2luZzogJycgfTtcbiAgICAgICAgfVxuICAgICAgICBkdXJhdGlvbiA9IF9jb252ZXJ0VGltZVZhbHVlVG9NUyhwYXJzZUZsb2F0KG1hdGNoZXNbMV0pLCBtYXRjaGVzWzJdKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZGVsYXlNYXRjaCA9IG1hdGNoZXNbM107XG4gICAgICAgIGlmIChkZWxheU1hdGNoICE9IG51bGwpIHtcbiAgICAgICAgICAgIGRlbGF5ID0gX2NvbnZlcnRUaW1lVmFsdWVUb01TKE1hdGguZmxvb3IocGFyc2VGbG9hdChkZWxheU1hdGNoKSksIG1hdGNoZXNbNF0pO1xuICAgICAgICB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVhc2luZ1ZhbCA9IG1hdGNoZXNbNV07XG4gICAgICAgIGlmIChlYXNpbmdWYWwpIHtcbiAgICAgICAgICAgIGVhc2luZyA9IGVhc2luZ1ZhbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZHVyYXRpb24gPSAvKiogQHR5cGUgez99ICovIChleHApO1xuICAgIH1cbiAgICBpZiAoIWFsbG93TmVnYXRpdmVWYWx1ZXMpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY29udGFpbnNFcnJvcnMgPSBmYWxzZTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3RhcnRJbmRleCA9IGVycm9ycy5sZW5ndGg7XG4gICAgICAgIGlmIChkdXJhdGlvbiA8IDApIHtcbiAgICAgICAgICAgIGVycm9ycy5wdXNoKFwiRHVyYXRpb24gdmFsdWVzIGJlbG93IDAgYXJlIG5vdCBhbGxvd2VkIGZvciB0aGlzIGFuaW1hdGlvbiBzdGVwLlwiKTtcbiAgICAgICAgICAgIGNvbnRhaW5zRXJyb3JzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVsYXkgPCAwKSB7XG4gICAgICAgICAgICBlcnJvcnMucHVzaChcIkRlbGF5IHZhbHVlcyBiZWxvdyAwIGFyZSBub3QgYWxsb3dlZCBmb3IgdGhpcyBhbmltYXRpb24gc3RlcC5cIik7XG4gICAgICAgICAgICBjb250YWluc0Vycm9ycyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbnRhaW5zRXJyb3JzKSB7XG4gICAgICAgICAgICBlcnJvcnMuc3BsaWNlKHN0YXJ0SW5kZXgsIDAsIFwiVGhlIHByb3ZpZGVkIHRpbWluZyB2YWx1ZSBcXFwiXCIgKyBleHAgKyBcIlxcXCIgaXMgaW52YWxpZC5cIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgZHVyYXRpb246IGR1cmF0aW9uLCBkZWxheTogZGVsYXksIGVhc2luZzogZWFzaW5nIH07XG59XG4vKipcbiAqIEBwYXJhbSB7P30gb2JqXG4gKiBAcGFyYW0gez89fSBkZXN0aW5hdGlvblxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gY29weU9iaihvYmosIGRlc3RpbmF0aW9uKSB7XG4gICAgaWYgKGRlc3RpbmF0aW9uID09PSB2b2lkIDApIHsgZGVzdGluYXRpb24gPSB7fTsgfVxuICAgIE9iamVjdC5rZXlzKG9iaikuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkgeyBkZXN0aW5hdGlvbltwcm9wXSA9IG9ialtwcm9wXTsgfSk7XG4gICAgcmV0dXJuIGRlc3RpbmF0aW9uO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IHN0eWxlc1xuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplU3R5bGVzKHN0eWxlcykge1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIG5vcm1hbGl6ZWRTdHlsZXMgPSB7fTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShzdHlsZXMpKSB7XG4gICAgICAgIHN0eWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChkYXRhKSB7IHJldHVybiBjb3B5U3R5bGVzKGRhdGEsIGZhbHNlLCBub3JtYWxpemVkU3R5bGVzKTsgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb3B5U3R5bGVzKHN0eWxlcywgZmFsc2UsIG5vcm1hbGl6ZWRTdHlsZXMpO1xuICAgIH1cbiAgICByZXR1cm4gbm9ybWFsaXplZFN0eWxlcztcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBzdHlsZXNcbiAqIEBwYXJhbSB7P30gcmVhZFByb3RvdHlwZVxuICogQHBhcmFtIHs/PX0gZGVzdGluYXRpb25cbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGNvcHlTdHlsZXMoc3R5bGVzLCByZWFkUHJvdG90eXBlLCBkZXN0aW5hdGlvbikge1xuICAgIGlmIChkZXN0aW5hdGlvbiA9PT0gdm9pZCAwKSB7IGRlc3RpbmF0aW9uID0ge307IH1cbiAgICBpZiAocmVhZFByb3RvdHlwZSkge1xuICAgICAgICAvLyB3ZSBtYWtlIHVzZSBvZiBhIGZvci1pbiBsb29wIHNvIHRoYXQgdGhlXG4gICAgICAgIC8vIHByb3RvdHlwaWNhbGx5IGluaGVyaXRlZCBwcm9wZXJ0aWVzIGFyZVxuICAgICAgICAvLyByZXZlYWxlZCBmcm9tIHRoZSBiYWNrRmlsbCBtYXBcbiAgICAgICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBwcm9wIGluIHN0eWxlcykge1xuICAgICAgICAgICAgZGVzdGluYXRpb25bcHJvcF0gPSBzdHlsZXNbcHJvcF07XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvcHlPYmooc3R5bGVzLCBkZXN0aW5hdGlvbik7XG4gICAgfVxuICAgIHJldHVybiBkZXN0aW5hdGlvbjtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBlbGVtZW50XG4gKiBAcGFyYW0gez99IHN0eWxlc1xuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gc2V0U3R5bGVzKGVsZW1lbnQsIHN0eWxlcykge1xuICAgIGlmIChlbGVtZW50WydzdHlsZSddKSB7XG4gICAgICAgIE9iamVjdC5rZXlzKHN0eWxlcykuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY2FtZWxQcm9wID0gZGFzaENhc2VUb0NhbWVsQ2FzZShwcm9wKTtcbiAgICAgICAgICAgIGVsZW1lbnQuc3R5bGVbY2FtZWxQcm9wXSA9IHN0eWxlc1twcm9wXTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqXG4gKiBAcGFyYW0gez99IGVsZW1lbnRcbiAqIEBwYXJhbSB7P30gc3R5bGVzXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBlcmFzZVN0eWxlcyhlbGVtZW50LCBzdHlsZXMpIHtcbiAgICBpZiAoZWxlbWVudFsnc3R5bGUnXSkge1xuICAgICAgICBPYmplY3Qua2V5cyhzdHlsZXMpLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNhbWVsUHJvcCA9IGRhc2hDYXNlVG9DYW1lbENhc2UocHJvcCk7XG4gICAgICAgICAgICBlbGVtZW50LnN0eWxlW2NhbWVsUHJvcF0gPSAnJztcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqXG4gKiBAcGFyYW0gez99IHN0ZXBzXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBub3JtYWxpemVBbmltYXRpb25FbnRyeShzdGVwcykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHN0ZXBzKSkge1xuICAgICAgICBpZiAoc3RlcHMubGVuZ3RoID09IDEpXG4gICAgICAgICAgICByZXR1cm4gc3RlcHNbMF07XG4gICAgICAgIHJldHVybiBfYW5ndWxhcl9hbmltYXRpb25zLnNlcXVlbmNlKHN0ZXBzKTtcbiAgICB9XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7P30gKi8gKHN0ZXBzKTtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSB2YWx1ZVxuICogQHBhcmFtIHs/fSBvcHRpb25zXG4gKiBAcGFyYW0gez99IGVycm9yc1xuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVTdHlsZVBhcmFtcyh2YWx1ZSwgb3B0aW9ucywgZXJyb3JzKSB7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGFyYW1zID0gb3B0aW9ucy5wYXJhbXMgfHwge307XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbWF0Y2hlcyA9IGV4dHJhY3RTdHlsZVBhcmFtcyh2YWx1ZSk7XG4gICAgaWYgKG1hdGNoZXMubGVuZ3RoKSB7XG4gICAgICAgIG1hdGNoZXMuZm9yRWFjaChmdW5jdGlvbiAodmFyTmFtZSkge1xuICAgICAgICAgICAgaWYgKCFwYXJhbXMuaGFzT3duUHJvcGVydHkodmFyTmFtZSkpIHtcbiAgICAgICAgICAgICAgICBlcnJvcnMucHVzaChcIlVuYWJsZSB0byByZXNvbHZlIHRoZSBsb2NhbCBhbmltYXRpb24gcGFyYW0gXCIgKyB2YXJOYW1lICsgXCIgaW4gdGhlIGdpdmVuIGxpc3Qgb2YgdmFsdWVzXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59XG52YXIgUEFSQU1fUkVHRVggPSBuZXcgUmVnRXhwKFNVQlNUSVRVVElPTl9FWFBSX1NUQVJUICsgXCJcXFxccyooLis/KVxcXFxzKlwiICsgU1VCU1RJVFVUSU9OX0VYUFJfRU5ELCAnZycpO1xuLyoqXG4gKiBAcGFyYW0gez99IHZhbHVlXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBleHRyYWN0U3R5bGVQYXJhbXModmFsdWUpIHtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwYXJhbXMgPSBbXTtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2YWwgPSB2YWx1ZS50b1N0cmluZygpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBtYXRjaCA9IHZvaWQgMDtcbiAgICAgICAgd2hpbGUgKG1hdGNoID0gUEFSQU1fUkVHRVguZXhlYyh2YWwpKSB7XG4gICAgICAgICAgICBwYXJhbXMucHVzaCgvKiogQHR5cGUgez99ICovIChtYXRjaFsxXSkpO1xuICAgICAgICB9XG4gICAgICAgIFBBUkFNX1JFR0VYLmxhc3RJbmRleCA9IDA7XG4gICAgfVxuICAgIHJldHVybiBwYXJhbXM7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gdmFsdWVcbiAqIEBwYXJhbSB7P30gcGFyYW1zXG4gKiBAcGFyYW0gez99IGVycm9yc1xuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gaW50ZXJwb2xhdGVQYXJhbXModmFsdWUsIHBhcmFtcywgZXJyb3JzKSB7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gb3JpZ2luYWwgPSB2YWx1ZS50b1N0cmluZygpO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0ciA9IG9yaWdpbmFsLnJlcGxhY2UoUEFSQU1fUkVHRVgsIGZ1bmN0aW9uIChfLCB2YXJOYW1lKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGxvY2FsVmFsID0gcGFyYW1zW3Zhck5hbWVdO1xuICAgICAgICAvLyB0aGlzIG1lYW5zIHRoYXQgdGhlIHZhbHVlIHdhcyBuZXZlciBvdmVyaWRkZW4gYnkgdGhlIGRhdGEgcGFzc2VkIGluIGJ5IHRoZSB1c2VyXG4gICAgICAgIGlmICghcGFyYW1zLmhhc093blByb3BlcnR5KHZhck5hbWUpKSB7XG4gICAgICAgICAgICBlcnJvcnMucHVzaChcIlBsZWFzZSBwcm92aWRlIGEgdmFsdWUgZm9yIHRoZSBhbmltYXRpb24gcGFyYW0gXCIgKyB2YXJOYW1lKTtcbiAgICAgICAgICAgIGxvY2FsVmFsID0gJyc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxvY2FsVmFsLnRvU3RyaW5nKCk7XG4gICAgfSk7XG4gICAgLy8gd2UgZG8gdGhpcyB0byBhc3NlcnQgdGhhdCBudW1lcmljIHZhbHVlcyBzdGF5IGFzIHRoZXkgYXJlXG4gICAgcmV0dXJuIHN0ciA9PSBvcmlnaW5hbCA/IHZhbHVlIDogc3RyO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IGl0ZXJhdG9yXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBpdGVyYXRvclRvQXJyYXkoaXRlcmF0b3IpIHtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBhcnIgPSBbXTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpdGVtID0gaXRlcmF0b3IubmV4dCgpO1xuICAgIHdoaWxlICghaXRlbS5kb25lKSB7XG4gICAgICAgIGFyci5wdXNoKGl0ZW0udmFsdWUpO1xuICAgICAgICBpdGVtID0gaXRlcmF0b3IubmV4dCgpO1xuICAgIH1cbiAgICByZXR1cm4gYXJyO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IHNvdXJjZVxuICogQHBhcmFtIHs/fSBkZXN0aW5hdGlvblxuICogQHJldHVybiB7P31cbiAqL1xuXG52YXIgREFTSF9DQVNFX1JFR0VYUCA9IC8tKyhbYS16MC05XSkvZztcbi8qKlxuICogQHBhcmFtIHs/fSBpbnB1dFxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gZGFzaENhc2VUb0NhbWVsQ2FzZShpbnB1dCkge1xuICAgIHJldHVybiBpbnB1dC5yZXBsYWNlKERBU0hfQ0FTRV9SRUdFWFAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG0gPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIG1bX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbVsxXS50b1VwcGVyQ2FzZSgpO1xuICAgIH0pO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IGR1cmF0aW9uXG4gKiBAcGFyYW0gez99IGRlbGF5XG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBhbGxvd1ByZXZpb3VzUGxheWVyU3R5bGVzTWVyZ2UoZHVyYXRpb24sIGRlbGF5KSB7XG4gICAgcmV0dXJuIGR1cmF0aW9uID09PSAwIHx8IGRlbGF5ID09PSAwO1xufVxuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgYWRkZWQgYnkgdHNpY2tsZVxuICogQHN1cHByZXNzIHtjaGVja1R5cGVzfSBjaGVja2VkIGJ5IHRzY1xuICovXG52YXIgRU1QVFlfQU5JTUFUSU9OX09QVElPTlMgPSB7fTtcbi8qKlxuICogQHJlY29yZFxuICovXG5cbi8qKlxuICogQGFic3RyYWN0XG4gKi9cbnZhciBBc3QgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEFzdCgpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gRU1QVFlfQU5JTUFUSU9OX09QVElPTlM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBc3QucHJvdG90eXBlLCBcInBhcmFtc1wiLCB7XG4gICAgICAgIGdldDogLyoqXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLm9wdGlvbnNbJ3BhcmFtcyddIHx8IG51bGw7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBBc3Q7XG59KCkpO1xudmFyIFRyaWdnZXJBc3QgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhUcmlnZ2VyQXN0LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRyaWdnZXJBc3QobmFtZSwgc3RhdGVzLCB0cmFuc2l0aW9ucykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgX3RoaXMuc3RhdGVzID0gc3RhdGVzO1xuICAgICAgICBfdGhpcy50cmFuc2l0aW9ucyA9IHRyYW5zaXRpb25zO1xuICAgICAgICBfdGhpcy5xdWVyeUNvdW50ID0gMDtcbiAgICAgICAgX3RoaXMuZGVwQ291bnQgPSAwO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmlzaXRvclxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVHJpZ2dlckFzdC5wcm90b3R5cGUudmlzaXQgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IHZpc2l0b3JcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7IHJldHVybiB2aXNpdG9yLnZpc2l0VHJpZ2dlcih0aGlzLCBjb250ZXh0KTsgfTtcbiAgICByZXR1cm4gVHJpZ2dlckFzdDtcbn0oQXN0KSk7XG52YXIgU3RhdGVBc3QgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTdGF0ZUFzdCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTdGF0ZUFzdChuYW1lLCBzdHlsZSQkMSkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgX3RoaXMuc3R5bGUgPSBzdHlsZSQkMTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZpc2l0b3JcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFN0YXRlQXN0LnByb3RvdHlwZS52aXNpdCA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmlzaXRvclxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHsgcmV0dXJuIHZpc2l0b3IudmlzaXRTdGF0ZSh0aGlzLCBjb250ZXh0KTsgfTtcbiAgICByZXR1cm4gU3RhdGVBc3Q7XG59KEFzdCkpO1xudmFyIFRyYW5zaXRpb25Bc3QgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhUcmFuc2l0aW9uQXN0LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRyYW5zaXRpb25Bc3QobWF0Y2hlcnMsIGFuaW1hdGlvbikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5tYXRjaGVycyA9IG1hdGNoZXJzO1xuICAgICAgICBfdGhpcy5hbmltYXRpb24gPSBhbmltYXRpb247XG4gICAgICAgIF90aGlzLnF1ZXJ5Q291bnQgPSAwO1xuICAgICAgICBfdGhpcy5kZXBDb3VudCA9IDA7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2aXNpdG9yXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUcmFuc2l0aW9uQXN0LnByb3RvdHlwZS52aXNpdCA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmlzaXRvclxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHsgcmV0dXJuIHZpc2l0b3IudmlzaXRUcmFuc2l0aW9uKHRoaXMsIGNvbnRleHQpOyB9O1xuICAgIHJldHVybiBUcmFuc2l0aW9uQXN0O1xufShBc3QpKTtcbnZhciBTZXF1ZW5jZUFzdCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFNlcXVlbmNlQXN0LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFNlcXVlbmNlQXN0KHN0ZXBzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnN0ZXBzID0gc3RlcHM7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2aXNpdG9yXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTZXF1ZW5jZUFzdC5wcm90b3R5cGUudmlzaXQgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IHZpc2l0b3JcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7IHJldHVybiB2aXNpdG9yLnZpc2l0U2VxdWVuY2UodGhpcywgY29udGV4dCk7IH07XG4gICAgcmV0dXJuIFNlcXVlbmNlQXN0O1xufShBc3QpKTtcbnZhciBHcm91cEFzdCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEdyb3VwQXN0LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEdyb3VwQXN0KHN0ZXBzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnN0ZXBzID0gc3RlcHM7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2aXNpdG9yXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBHcm91cEFzdC5wcm90b3R5cGUudmlzaXQgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IHZpc2l0b3JcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7IHJldHVybiB2aXNpdG9yLnZpc2l0R3JvdXAodGhpcywgY29udGV4dCk7IH07XG4gICAgcmV0dXJuIEdyb3VwQXN0O1xufShBc3QpKTtcbnZhciBBbmltYXRlQXN0ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQW5pbWF0ZUFzdCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBbmltYXRlQXN0KHRpbWluZ3MsIHN0eWxlJCQxKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnRpbWluZ3MgPSB0aW1pbmdzO1xuICAgICAgICBfdGhpcy5zdHlsZSA9IHN0eWxlJCQxO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmlzaXRvclxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQW5pbWF0ZUFzdC5wcm90b3R5cGUudmlzaXQgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IHZpc2l0b3JcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7IHJldHVybiB2aXNpdG9yLnZpc2l0QW5pbWF0ZSh0aGlzLCBjb250ZXh0KTsgfTtcbiAgICByZXR1cm4gQW5pbWF0ZUFzdDtcbn0oQXN0KSk7XG52YXIgU3R5bGVBc3QgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTdHlsZUFzdCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTdHlsZUFzdChzdHlsZXMsIGVhc2luZywgb2Zmc2V0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnN0eWxlcyA9IHN0eWxlcztcbiAgICAgICAgX3RoaXMuZWFzaW5nID0gZWFzaW5nO1xuICAgICAgICBfdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgIF90aGlzLmlzRW1wdHlTdGVwID0gZmFsc2U7XG4gICAgICAgIF90aGlzLmNvbnRhaW5zRHluYW1pY1N0eWxlcyA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmlzaXRvclxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU3R5bGVBc3QucHJvdG90eXBlLnZpc2l0ID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSB2aXNpdG9yXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkgeyByZXR1cm4gdmlzaXRvci52aXNpdFN0eWxlKHRoaXMsIGNvbnRleHQpOyB9O1xuICAgIHJldHVybiBTdHlsZUFzdDtcbn0oQXN0KSk7XG52YXIgS2V5ZnJhbWVzQXN0ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoS2V5ZnJhbWVzQXN0LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEtleWZyYW1lc0FzdChzdHlsZXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuc3R5bGVzID0gc3R5bGVzO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmlzaXRvclxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgS2V5ZnJhbWVzQXN0LnByb3RvdHlwZS52aXNpdCA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmlzaXRvclxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHsgcmV0dXJuIHZpc2l0b3IudmlzaXRLZXlmcmFtZXModGhpcywgY29udGV4dCk7IH07XG4gICAgcmV0dXJuIEtleWZyYW1lc0FzdDtcbn0oQXN0KSk7XG52YXIgUmVmZXJlbmNlQXN0ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUmVmZXJlbmNlQXN0LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFJlZmVyZW5jZUFzdChhbmltYXRpb24pIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuYW5pbWF0aW9uID0gYW5pbWF0aW9uO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmlzaXRvclxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUmVmZXJlbmNlQXN0LnByb3RvdHlwZS52aXNpdCA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmlzaXRvclxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHsgcmV0dXJuIHZpc2l0b3IudmlzaXRSZWZlcmVuY2UodGhpcywgY29udGV4dCk7IH07XG4gICAgcmV0dXJuIFJlZmVyZW5jZUFzdDtcbn0oQXN0KSk7XG52YXIgQW5pbWF0ZUNoaWxkQXN0ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQW5pbWF0ZUNoaWxkQXN0LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEFuaW1hdGVDaGlsZEFzdCgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmlzaXRvclxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQW5pbWF0ZUNoaWxkQXN0LnByb3RvdHlwZS52aXNpdCA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmlzaXRvclxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHsgcmV0dXJuIHZpc2l0b3IudmlzaXRBbmltYXRlQ2hpbGQodGhpcywgY29udGV4dCk7IH07XG4gICAgcmV0dXJuIEFuaW1hdGVDaGlsZEFzdDtcbn0oQXN0KSk7XG52YXIgQW5pbWF0ZVJlZkFzdCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEFuaW1hdGVSZWZBc3QsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQW5pbWF0ZVJlZkFzdChhbmltYXRpb24pIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuYW5pbWF0aW9uID0gYW5pbWF0aW9uO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmlzaXRvclxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQW5pbWF0ZVJlZkFzdC5wcm90b3R5cGUudmlzaXQgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IHZpc2l0b3JcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7IHJldHVybiB2aXNpdG9yLnZpc2l0QW5pbWF0ZVJlZih0aGlzLCBjb250ZXh0KTsgfTtcbiAgICByZXR1cm4gQW5pbWF0ZVJlZkFzdDtcbn0oQXN0KSk7XG52YXIgUXVlcnlBc3QgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhRdWVyeUFzdCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBRdWVyeUFzdChzZWxlY3RvciwgbGltaXQsIG9wdGlvbmFsLCBpbmNsdWRlU2VsZiwgYW5pbWF0aW9uKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnNlbGVjdG9yID0gc2VsZWN0b3I7XG4gICAgICAgIF90aGlzLmxpbWl0ID0gbGltaXQ7XG4gICAgICAgIF90aGlzLm9wdGlvbmFsID0gb3B0aW9uYWw7XG4gICAgICAgIF90aGlzLmluY2x1ZGVTZWxmID0gaW5jbHVkZVNlbGY7XG4gICAgICAgIF90aGlzLmFuaW1hdGlvbiA9IGFuaW1hdGlvbjtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZpc2l0b3JcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFF1ZXJ5QXN0LnByb3RvdHlwZS52aXNpdCA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmlzaXRvclxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHsgcmV0dXJuIHZpc2l0b3IudmlzaXRRdWVyeSh0aGlzLCBjb250ZXh0KTsgfTtcbiAgICByZXR1cm4gUXVlcnlBc3Q7XG59KEFzdCkpO1xudmFyIFN0YWdnZXJBc3QgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTdGFnZ2VyQXN0LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFN0YWdnZXJBc3QodGltaW5ncywgYW5pbWF0aW9uKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnRpbWluZ3MgPSB0aW1pbmdzO1xuICAgICAgICBfdGhpcy5hbmltYXRpb24gPSBhbmltYXRpb247XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2aXNpdG9yXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTdGFnZ2VyQXN0LnByb3RvdHlwZS52aXNpdCA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmlzaXRvclxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHsgcmV0dXJuIHZpc2l0b3IudmlzaXRTdGFnZ2VyKHRoaXMsIGNvbnRleHQpOyB9O1xuICAgIHJldHVybiBTdGFnZ2VyQXN0O1xufShBc3QpKTtcbnZhciBUaW1pbmdBc3QgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhUaW1pbmdBc3QsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVGltaW5nQXN0KGR1cmF0aW9uLCBkZWxheSwgZWFzaW5nKSB7XG4gICAgICAgIGlmIChkZWxheSA9PT0gdm9pZCAwKSB7IGRlbGF5ID0gMDsgfVxuICAgICAgICBpZiAoZWFzaW5nID09PSB2b2lkIDApIHsgZWFzaW5nID0gbnVsbDsgfVxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5kdXJhdGlvbiA9IGR1cmF0aW9uO1xuICAgICAgICBfdGhpcy5kZWxheSA9IGRlbGF5O1xuICAgICAgICBfdGhpcy5lYXNpbmcgPSBlYXNpbmc7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2aXNpdG9yXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUaW1pbmdBc3QucHJvdG90eXBlLnZpc2l0ID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSB2aXNpdG9yXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkgeyByZXR1cm4gdmlzaXRvci52aXNpdFRpbWluZyh0aGlzLCBjb250ZXh0KTsgfTtcbiAgICByZXR1cm4gVGltaW5nQXN0O1xufShBc3QpKTtcbnZhciBEeW5hbWljVGltaW5nQXN0ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRHluYW1pY1RpbWluZ0FzdCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBEeW5hbWljVGltaW5nQXN0KHZhbHVlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIDAsIDAsICcnKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmlzaXRvclxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRHluYW1pY1RpbWluZ0FzdC5wcm90b3R5cGUudmlzaXQgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IHZpc2l0b3JcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7IHJldHVybiB2aXNpdG9yLnZpc2l0VGltaW5nKHRoaXMsIGNvbnRleHQpOyB9O1xuICAgIHJldHVybiBEeW5hbWljVGltaW5nQXN0O1xufShUaW1pbmdBc3QpKTtcblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IGFkZGVkIGJ5IHRzaWNrbGVcbiAqIEBzdXBwcmVzcyB7Y2hlY2tUeXBlc30gY2hlY2tlZCBieSB0c2NcbiAqL1xuLyoqXG4gKiBAcmVjb3JkXG4gKi9cblxuLyoqXG4gKiBAcGFyYW0gez99IHZpc2l0b3JcbiAqIEBwYXJhbSB7P30gbm9kZVxuICogQHBhcmFtIHs/fSBjb250ZXh0XG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiB2aXNpdEFuaW1hdGlvbk5vZGUodmlzaXRvciwgbm9kZSwgY29udGV4dCkge1xuICAgIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgICAgIGNhc2UgNyAvKiBUcmlnZ2VyICovOlxuICAgICAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRUcmlnZ2VyKC8qKiBAdHlwZSB7P30gKi8gKG5vZGUpLCBjb250ZXh0KTtcbiAgICAgICAgY2FzZSAwIC8qIFN0YXRlICovOlxuICAgICAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRTdGF0ZSgvKiogQHR5cGUgez99ICovIChub2RlKSwgY29udGV4dCk7XG4gICAgICAgIGNhc2UgMSAvKiBUcmFuc2l0aW9uICovOlxuICAgICAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRUcmFuc2l0aW9uKC8qKiBAdHlwZSB7P30gKi8gKG5vZGUpLCBjb250ZXh0KTtcbiAgICAgICAgY2FzZSAyIC8qIFNlcXVlbmNlICovOlxuICAgICAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRTZXF1ZW5jZSgvKiogQHR5cGUgez99ICovIChub2RlKSwgY29udGV4dCk7XG4gICAgICAgIGNhc2UgMyAvKiBHcm91cCAqLzpcbiAgICAgICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0R3JvdXAoLyoqIEB0eXBlIHs/fSAqLyAobm9kZSksIGNvbnRleHQpO1xuICAgICAgICBjYXNlIDQgLyogQW5pbWF0ZSAqLzpcbiAgICAgICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0QW5pbWF0ZSgvKiogQHR5cGUgez99ICovIChub2RlKSwgY29udGV4dCk7XG4gICAgICAgIGNhc2UgNSAvKiBLZXlmcmFtZXMgKi86XG4gICAgICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEtleWZyYW1lcygvKiogQHR5cGUgez99ICovIChub2RlKSwgY29udGV4dCk7XG4gICAgICAgIGNhc2UgNiAvKiBTdHlsZSAqLzpcbiAgICAgICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0U3R5bGUoLyoqIEB0eXBlIHs/fSAqLyAobm9kZSksIGNvbnRleHQpO1xuICAgICAgICBjYXNlIDggLyogUmVmZXJlbmNlICovOlxuICAgICAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRSZWZlcmVuY2UoLyoqIEB0eXBlIHs/fSAqLyAobm9kZSksIGNvbnRleHQpO1xuICAgICAgICBjYXNlIDkgLyogQW5pbWF0ZUNoaWxkICovOlxuICAgICAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRBbmltYXRlQ2hpbGQoLyoqIEB0eXBlIHs/fSAqLyAobm9kZSksIGNvbnRleHQpO1xuICAgICAgICBjYXNlIDEwIC8qIEFuaW1hdGVSZWYgKi86XG4gICAgICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEFuaW1hdGVSZWYoLyoqIEB0eXBlIHs/fSAqLyAobm9kZSksIGNvbnRleHQpO1xuICAgICAgICBjYXNlIDExIC8qIFF1ZXJ5ICovOlxuICAgICAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRRdWVyeSgvKiogQHR5cGUgez99ICovIChub2RlKSwgY29udGV4dCk7XG4gICAgICAgIGNhc2UgMTIgLyogU3RhZ2dlciAqLzpcbiAgICAgICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0U3RhZ2dlcigvKiogQHR5cGUgez99ICovIChub2RlKSwgY29udGV4dCk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gcmVzb2x2ZSBhbmltYXRpb24gbWV0YWRhdGEgbm9kZSAjXCIgKyBub2RlLnR5cGUpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IGFkZGVkIGJ5IHRzaWNrbGVcbiAqIEBzdXBwcmVzcyB7Y2hlY2tUeXBlc30gY2hlY2tlZCBieSB0c2NcbiAqL1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xudmFyIEFOWV9TVEFURSA9ICcqJztcbi8qKlxuICogQHBhcmFtIHs/fSB0cmFuc2l0aW9uVmFsdWVcbiAqIEBwYXJhbSB7P30gZXJyb3JzXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBwYXJzZVRyYW5zaXRpb25FeHByKHRyYW5zaXRpb25WYWx1ZSwgZXJyb3JzKSB7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZXhwcmVzc2lvbnMgPSBbXTtcbiAgICBpZiAodHlwZW9mIHRyYW5zaXRpb25WYWx1ZSA9PSAnc3RyaW5nJykge1xuICAgICAgICAoLyoqIEB0eXBlIHs/fSAqLyAodHJhbnNpdGlvblZhbHVlKSlcbiAgICAgICAgICAgIC5zcGxpdCgvXFxzKixcXHMqLylcbiAgICAgICAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uIChzdHIpIHsgcmV0dXJuIHBhcnNlSW5uZXJUcmFuc2l0aW9uU3RyKHN0ciwgZXhwcmVzc2lvbnMsIGVycm9ycyk7IH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZXhwcmVzc2lvbnMucHVzaCgvKiogQHR5cGUgez99ICovICh0cmFuc2l0aW9uVmFsdWUpKTtcbiAgICB9XG4gICAgcmV0dXJuIGV4cHJlc3Npb25zO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IGV2ZW50U3RyXG4gKiBAcGFyYW0gez99IGV4cHJlc3Npb25zXG4gKiBAcGFyYW0gez99IGVycm9yc1xuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gcGFyc2VJbm5lclRyYW5zaXRpb25TdHIoZXZlbnRTdHIsIGV4cHJlc3Npb25zLCBlcnJvcnMpIHtcbiAgICBpZiAoZXZlbnRTdHJbMF0gPT0gJzonKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlc3VsdCA9IHBhcnNlQW5pbWF0aW9uQWxpYXMoZXZlbnRTdHIsIGVycm9ycyk7XG4gICAgICAgIGlmICh0eXBlb2YgcmVzdWx0ID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGV4cHJlc3Npb25zLnB1c2gocmVzdWx0KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBldmVudFN0ciA9IC8qKiBAdHlwZSB7P30gKi8gKHJlc3VsdCk7XG4gICAgfVxuICAgIHZhciAvKiogQHR5cGUgez99ICovIG1hdGNoID0gZXZlbnRTdHIubWF0Y2goL14oXFwqfFstXFx3XSspXFxzKig8P1s9LV0+KVxccyooXFwqfFstXFx3XSspJC8pO1xuICAgIGlmIChtYXRjaCA9PSBudWxsIHx8IG1hdGNoLmxlbmd0aCA8IDQpIHtcbiAgICAgICAgZXJyb3JzLnB1c2goXCJUaGUgcHJvdmlkZWQgdHJhbnNpdGlvbiBleHByZXNzaW9uIFxcXCJcIiArIGV2ZW50U3RyICsgXCJcXFwiIGlzIG5vdCBzdXBwb3J0ZWRcIik7XG4gICAgICAgIHJldHVybiBleHByZXNzaW9ucztcbiAgICB9XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZnJvbVN0YXRlID0gbWF0Y2hbMV07XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc2VwYXJhdG9yID0gbWF0Y2hbMl07XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdG9TdGF0ZSA9IG1hdGNoWzNdO1xuICAgIGV4cHJlc3Npb25zLnB1c2gobWFrZUxhbWJkYUZyb21TdGF0ZXMoZnJvbVN0YXRlLCB0b1N0YXRlKSk7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaXNGdWxsQW55U3RhdGVFeHByID0gZnJvbVN0YXRlID09IEFOWV9TVEFURSAmJiB0b1N0YXRlID09IEFOWV9TVEFURTtcbiAgICBpZiAoc2VwYXJhdG9yWzBdID09ICc8JyAmJiAhaXNGdWxsQW55U3RhdGVFeHByKSB7XG4gICAgICAgIGV4cHJlc3Npb25zLnB1c2gobWFrZUxhbWJkYUZyb21TdGF0ZXModG9TdGF0ZSwgZnJvbVN0YXRlKSk7XG4gICAgfVxufVxuLyoqXG4gKiBAcGFyYW0gez99IGFsaWFzXG4gKiBAcGFyYW0gez99IGVycm9yc1xuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gcGFyc2VBbmltYXRpb25BbGlhcyhhbGlhcywgZXJyb3JzKSB7XG4gICAgc3dpdGNoIChhbGlhcykge1xuICAgICAgICBjYXNlICc6ZW50ZXInOlxuICAgICAgICAgICAgcmV0dXJuICd2b2lkID0+IConO1xuICAgICAgICBjYXNlICc6bGVhdmUnOlxuICAgICAgICAgICAgcmV0dXJuICcqID0+IHZvaWQnO1xuICAgICAgICBjYXNlICc6aW5jcmVtZW50JzpcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZnJvbVN0YXRlLCB0b1N0YXRlKSB7IHJldHVybiBwYXJzZUZsb2F0KHRvU3RhdGUpID4gcGFyc2VGbG9hdChmcm9tU3RhdGUpOyB9O1xuICAgICAgICBjYXNlICc6ZGVjcmVtZW50JzpcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZnJvbVN0YXRlLCB0b1N0YXRlKSB7IHJldHVybiBwYXJzZUZsb2F0KHRvU3RhdGUpIDwgcGFyc2VGbG9hdChmcm9tU3RhdGUpOyB9O1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgZXJyb3JzLnB1c2goXCJUaGUgdHJhbnNpdGlvbiBhbGlhcyB2YWx1ZSBcXFwiXCIgKyBhbGlhcyArIFwiXFxcIiBpcyBub3Qgc3VwcG9ydGVkXCIpO1xuICAgICAgICAgICAgcmV0dXJuICcqID0+IConO1xuICAgIH1cbn1cbi8qKlxuICogQHBhcmFtIHs/fSBsaHNcbiAqIEBwYXJhbSB7P30gcmhzXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBtYWtlTGFtYmRhRnJvbVN0YXRlcyhsaHMsIHJocykge1xuICAgIHJldHVybiBmdW5jdGlvbiAoZnJvbVN0YXRlLCB0b1N0YXRlKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGxoc01hdGNoID0gbGhzID09IEFOWV9TVEFURSB8fCBsaHMgPT0gZnJvbVN0YXRlO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByaHNNYXRjaCA9IHJocyA9PSBBTllfU1RBVEUgfHwgcmhzID09IHRvU3RhdGU7XG4gICAgICAgIGlmICghbGhzTWF0Y2ggJiYgdHlwZW9mIGZyb21TdGF0ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICBsaHNNYXRjaCA9IGZyb21TdGF0ZSA/IGxocyA9PT0gJ3RydWUnIDogbGhzID09PSAnZmFsc2UnO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcmhzTWF0Y2ggJiYgdHlwZW9mIHRvU3RhdGUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgcmhzTWF0Y2ggPSB0b1N0YXRlID8gcmhzID09PSAndHJ1ZScgOiByaHMgPT09ICdmYWxzZSc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxoc01hdGNoICYmIHJoc01hdGNoO1xuICAgIH07XG59XG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBhZGRlZCBieSB0c2lja2xlXG4gKiBAc3VwcHJlc3Mge2NoZWNrVHlwZXN9IGNoZWNrZWQgYnkgdHNjXG4gKi9cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBTRUxGX1RPS0VOID0gJzpzZWxmJztcbnZhciBTRUxGX1RPS0VOX1JFR0VYID0gbmV3IFJlZ0V4cChcInMqXCIgKyBTRUxGX1RPS0VOICsgXCJzKiw/XCIsICdnJyk7XG4vKipcbiAqIEBwYXJhbSB7P30gZHJpdmVyXG4gKiBAcGFyYW0gez99IG1ldGFkYXRhXG4gKiBAcGFyYW0gez99IGVycm9yc1xuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gYnVpbGRBbmltYXRpb25Bc3QoZHJpdmVyLCBtZXRhZGF0YSwgZXJyb3JzKSB7XG4gICAgcmV0dXJuIG5ldyBBbmltYXRpb25Bc3RCdWlsZGVyVmlzaXRvcihkcml2ZXIpLmJ1aWxkKG1ldGFkYXRhLCBlcnJvcnMpO1xufVxudmFyIExFQVZFX1RPS0VOID0gJzpsZWF2ZSc7XG52YXIgTEVBVkVfVE9LRU5fUkVHRVggPSBuZXcgUmVnRXhwKExFQVZFX1RPS0VOLCAnZycpO1xudmFyIEVOVEVSX1RPS0VOID0gJzplbnRlcic7XG52YXIgRU5URVJfVE9LRU5fUkVHRVggPSBuZXcgUmVnRXhwKEVOVEVSX1RPS0VOLCAnZycpO1xudmFyIFJPT1RfU0VMRUNUT1IgPSAnJztcbnZhciBBbmltYXRpb25Bc3RCdWlsZGVyVmlzaXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQW5pbWF0aW9uQXN0QnVpbGRlclZpc2l0b3IoX2RyaXZlcikge1xuICAgICAgICB0aGlzLl9kcml2ZXIgPSBfZHJpdmVyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG1ldGFkYXRhXG4gICAgICogQHBhcmFtIHs/fSBlcnJvcnNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFuaW1hdGlvbkFzdEJ1aWxkZXJWaXNpdG9yLnByb3RvdHlwZS5idWlsZCA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gbWV0YWRhdGFcbiAgICAgKiBAcGFyYW0gez99IGVycm9yc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKG1ldGFkYXRhLCBlcnJvcnMpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY29udGV4dCA9IG5ldyBBbmltYXRpb25Bc3RCdWlsZGVyQ29udGV4dChlcnJvcnMpO1xuICAgICAgICB0aGlzLl9yZXNldENvbnRleHRTdHlsZVRpbWluZ1N0YXRlKGNvbnRleHQpO1xuICAgICAgICByZXR1cm4gLyoqIEB0eXBlIHs/fSAqLyAodmlzaXRBbmltYXRpb25Ob2RlKHRoaXMsIG5vcm1hbGl6ZUFuaW1hdGlvbkVudHJ5KG1ldGFkYXRhKSwgY29udGV4dCkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBbmltYXRpb25Bc3RCdWlsZGVyVmlzaXRvci5wcm90b3R5cGUuX3Jlc2V0Q29udGV4dFN0eWxlVGltaW5nU3RhdGUgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICAgIGNvbnRleHQuY3VycmVudFF1ZXJ5U2VsZWN0b3IgPSBST09UX1NFTEVDVE9SO1xuICAgICAgICBjb250ZXh0LmNvbGxlY3RlZFN0eWxlcyA9IHt9O1xuICAgICAgICBjb250ZXh0LmNvbGxlY3RlZFN0eWxlc1tST09UX1NFTEVDVE9SXSA9IHt9O1xuICAgICAgICBjb250ZXh0LmN1cnJlbnRUaW1lID0gMDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbWV0YWRhdGFcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFuaW1hdGlvbkFzdEJ1aWxkZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdFRyaWdnZXIgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IG1ldGFkYXRhXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAobWV0YWRhdGEsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcXVlcnlDb3VudCA9IGNvbnRleHQucXVlcnlDb3VudCA9IDA7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGRlcENvdW50ID0gY29udGV4dC5kZXBDb3VudCA9IDA7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0YXRlcyA9IFtdO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0cmFuc2l0aW9ucyA9IFtdO1xuICAgICAgICBtZXRhZGF0YS5kZWZpbml0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChkZWYpIHtcbiAgICAgICAgICAgIF90aGlzLl9yZXNldENvbnRleHRTdHlsZVRpbWluZ1N0YXRlKGNvbnRleHQpO1xuICAgICAgICAgICAgaWYgKGRlZi50eXBlID09IDAgLyogU3RhdGUgKi8pIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdGF0ZURlZl8xID0gLyoqIEB0eXBlIHs/fSAqLyAoZGVmKTtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBuYW1lXzEgPSBzdGF0ZURlZl8xLm5hbWU7XG4gICAgICAgICAgICAgICAgbmFtZV8xLnNwbGl0KC9cXHMqLFxccyovKS5mb3JFYWNoKGZ1bmN0aW9uIChuKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlRGVmXzEubmFtZSA9IG47XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlcy5wdXNoKF90aGlzLnZpc2l0U3RhdGUoc3RhdGVEZWZfMSwgY29udGV4dCkpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHN0YXRlRGVmXzEubmFtZSA9IG5hbWVfMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGRlZi50eXBlID09IDEgLyogVHJhbnNpdGlvbiAqLykge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRyYW5zaXRpb24gPSBfdGhpcy52aXNpdFRyYW5zaXRpb24oLyoqIEB0eXBlIHs/fSAqLyAoZGVmKSwgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgcXVlcnlDb3VudCArPSB0cmFuc2l0aW9uLnF1ZXJ5Q291bnQ7XG4gICAgICAgICAgICAgICAgZGVwQ291bnQgKz0gdHJhbnNpdGlvbi5kZXBDb3VudDtcbiAgICAgICAgICAgICAgICB0cmFuc2l0aW9ucy5wdXNoKHRyYW5zaXRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29udGV4dC5lcnJvcnMucHVzaCgnb25seSBzdGF0ZSgpIGFuZCB0cmFuc2l0aW9uKCkgZGVmaW5pdGlvbnMgY2FuIHNpdCBpbnNpZGUgb2YgYSB0cmlnZ2VyKCknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGFzdCA9IG5ldyBUcmlnZ2VyQXN0KG1ldGFkYXRhLm5hbWUsIHN0YXRlcywgdHJhbnNpdGlvbnMpO1xuICAgICAgICBhc3Qub3B0aW9ucyA9IG5vcm1hbGl6ZUFuaW1hdGlvbk9wdGlvbnMobWV0YWRhdGEub3B0aW9ucyk7XG4gICAgICAgIGFzdC5xdWVyeUNvdW50ID0gcXVlcnlDb3VudDtcbiAgICAgICAgYXN0LmRlcENvdW50ID0gZGVwQ291bnQ7XG4gICAgICAgIHJldHVybiBhc3Q7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG1ldGFkYXRhXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBbmltYXRpb25Bc3RCdWlsZGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRTdGF0ZSA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gbWV0YWRhdGFcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChtZXRhZGF0YSwgY29udGV4dCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdHlsZUFzdCA9IHRoaXMudmlzaXRTdHlsZShtZXRhZGF0YS5zdHlsZXMsIGNvbnRleHQpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBhc3RQYXJhbXMgPSAobWV0YWRhdGEub3B0aW9ucyAmJiBtZXRhZGF0YS5vcHRpb25zLnBhcmFtcykgfHwgbnVsbDtcbiAgICAgICAgaWYgKHN0eWxlQXN0LmNvbnRhaW5zRHluYW1pY1N0eWxlcykge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbWlzc2luZ1N1YnNfMSA9IG5ldyBTZXQoKTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBhcmFtc18xID0gYXN0UGFyYW1zIHx8IHt9O1xuICAgICAgICAgICAgc3R5bGVBc3Quc3R5bGVzLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdHlsZXNPYmpfMSA9IC8qKiBAdHlwZSB7P30gKi8gKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmtleXMoc3R5bGVzT2JqXzEpLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4dHJhY3RTdHlsZVBhcmFtcyhzdHlsZXNPYmpfMVtwcm9wXSkuZm9yRWFjaChmdW5jdGlvbiAoc3ViKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFwYXJhbXNfMS5oYXNPd25Qcm9wZXJ0eShzdWIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pc3NpbmdTdWJzXzEuYWRkKHN1Yik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKG1pc3NpbmdTdWJzXzEuc2l6ZSkge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG1pc3NpbmdTdWJzQXJyID0gaXRlcmF0b3JUb0FycmF5KG1pc3NpbmdTdWJzXzEudmFsdWVzKCkpO1xuICAgICAgICAgICAgICAgIGNvbnRleHQuZXJyb3JzLnB1c2goXCJzdGF0ZShcXFwiXCIgKyBtZXRhZGF0YS5uYW1lICsgXCJcXFwiLCAuLi4pIG11c3QgZGVmaW5lIGRlZmF1bHQgdmFsdWVzIGZvciBhbGwgdGhlIGZvbGxvd2luZyBzdHlsZSBzdWJzdGl0dXRpb25zOiBcIiArIG1pc3NpbmdTdWJzQXJyLmpvaW4oJywgJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0YXRlQXN0ID0gbmV3IFN0YXRlQXN0KG1ldGFkYXRhLm5hbWUsIHN0eWxlQXN0KTtcbiAgICAgICAgaWYgKGFzdFBhcmFtcykge1xuICAgICAgICAgICAgc3RhdGVBc3Qub3B0aW9ucyA9IHsgcGFyYW1zOiBhc3RQYXJhbXMgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RhdGVBc3Q7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG1ldGFkYXRhXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBbmltYXRpb25Bc3RCdWlsZGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRUcmFuc2l0aW9uID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBtZXRhZGF0YVxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKG1ldGFkYXRhLCBjb250ZXh0KSB7XG4gICAgICAgIGNvbnRleHQucXVlcnlDb3VudCA9IDA7XG4gICAgICAgIGNvbnRleHQuZGVwQ291bnQgPSAwO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlbnRyeSA9IHZpc2l0QW5pbWF0aW9uTm9kZSh0aGlzLCBub3JtYWxpemVBbmltYXRpb25FbnRyeShtZXRhZGF0YS5hbmltYXRpb24pLCBjb250ZXh0KTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbWF0Y2hlcnMgPSBwYXJzZVRyYW5zaXRpb25FeHByKG1ldGFkYXRhLmV4cHIsIGNvbnRleHQuZXJyb3JzKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYXN0ID0gbmV3IFRyYW5zaXRpb25Bc3QobWF0Y2hlcnMsIGVudHJ5KTtcbiAgICAgICAgYXN0Lm9wdGlvbnMgPSBub3JtYWxpemVBbmltYXRpb25PcHRpb25zKG1ldGFkYXRhLm9wdGlvbnMpO1xuICAgICAgICBhc3QucXVlcnlDb3VudCA9IGNvbnRleHQucXVlcnlDb3VudDtcbiAgICAgICAgYXN0LmRlcENvdW50ID0gY29udGV4dC5kZXBDb3VudDtcbiAgICAgICAgcmV0dXJuIGFzdDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbWV0YWRhdGFcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFuaW1hdGlvbkFzdEJ1aWxkZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdFNlcXVlbmNlID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBtZXRhZGF0YVxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKG1ldGFkYXRhLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGFzdCA9IG5ldyBTZXF1ZW5jZUFzdChtZXRhZGF0YS5zdGVwcy5tYXAoZnVuY3Rpb24gKHMpIHsgcmV0dXJuIHZpc2l0QW5pbWF0aW9uTm9kZShfdGhpcywgcywgY29udGV4dCk7IH0pKTtcbiAgICAgICAgYXN0Lm9wdGlvbnMgPSBub3JtYWxpemVBbmltYXRpb25PcHRpb25zKG1ldGFkYXRhLm9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gYXN0O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBtZXRhZGF0YVxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQW5pbWF0aW9uQXN0QnVpbGRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0R3JvdXAgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IG1ldGFkYXRhXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAobWV0YWRhdGEsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY3VycmVudFRpbWUgPSBjb250ZXh0LmN1cnJlbnRUaW1lO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBmdXJ0aGVzdFRpbWUgPSAwO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdGVwcyA9IG1ldGFkYXRhLnN0ZXBzLm1hcChmdW5jdGlvbiAoc3RlcCkge1xuICAgICAgICAgICAgY29udGV4dC5jdXJyZW50VGltZSA9IGN1cnJlbnRUaW1lO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaW5uZXJBc3QgPSB2aXNpdEFuaW1hdGlvbk5vZGUoX3RoaXMsIHN0ZXAsIGNvbnRleHQpO1xuICAgICAgICAgICAgZnVydGhlc3RUaW1lID0gTWF0aC5tYXgoZnVydGhlc3RUaW1lLCBjb250ZXh0LmN1cnJlbnRUaW1lKTtcbiAgICAgICAgICAgIHJldHVybiBpbm5lckFzdDtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnRleHQuY3VycmVudFRpbWUgPSBmdXJ0aGVzdFRpbWU7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGFzdCA9IG5ldyBHcm91cEFzdChzdGVwcyk7XG4gICAgICAgIGFzdC5vcHRpb25zID0gbm9ybWFsaXplQW5pbWF0aW9uT3B0aW9ucyhtZXRhZGF0YS5vcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIGFzdDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbWV0YWRhdGFcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFuaW1hdGlvbkFzdEJ1aWxkZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdEFuaW1hdGUgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IG1ldGFkYXRhXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAobWV0YWRhdGEsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdGltaW5nQXN0ID0gY29uc3RydWN0VGltaW5nQXN0KG1ldGFkYXRhLnRpbWluZ3MsIGNvbnRleHQuZXJyb3JzKTtcbiAgICAgICAgY29udGV4dC5jdXJyZW50QW5pbWF0ZVRpbWluZ3MgPSB0aW1pbmdBc3Q7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0eWxlcztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3R5bGVNZXRhZGF0YSA9IG1ldGFkYXRhLnN0eWxlcyA/IG1ldGFkYXRhLnN0eWxlcyA6IF9hbmd1bGFyX2FuaW1hdGlvbnMuc3R5bGUoe30pO1xuICAgICAgICBpZiAoc3R5bGVNZXRhZGF0YS50eXBlID09IDUgLyogS2V5ZnJhbWVzICovKSB7XG4gICAgICAgICAgICBzdHlsZXMgPSB0aGlzLnZpc2l0S2V5ZnJhbWVzKC8qKiBAdHlwZSB7P30gKi8gKHN0eWxlTWV0YWRhdGEpLCBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0eWxlTWV0YWRhdGFfMSA9IC8qKiBAdHlwZSB7P30gKi8gKG1ldGFkYXRhLnN0eWxlcyk7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpc0VtcHR5ID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoIXN0eWxlTWV0YWRhdGFfMSkge1xuICAgICAgICAgICAgICAgIGlzRW1wdHkgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5ld1N0eWxlRGF0YSA9IHt9O1xuICAgICAgICAgICAgICAgIGlmICh0aW1pbmdBc3QuZWFzaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld1N0eWxlRGF0YVsnZWFzaW5nJ10gPSB0aW1pbmdBc3QuZWFzaW5nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdHlsZU1ldGFkYXRhXzEgPSBfYW5ndWxhcl9hbmltYXRpb25zLnN0eWxlKG5ld1N0eWxlRGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250ZXh0LmN1cnJlbnRUaW1lICs9IHRpbWluZ0FzdC5kdXJhdGlvbiArIHRpbWluZ0FzdC5kZWxheTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0eWxlQXN0ID0gdGhpcy52aXNpdFN0eWxlKHN0eWxlTWV0YWRhdGFfMSwgY29udGV4dCk7XG4gICAgICAgICAgICBzdHlsZUFzdC5pc0VtcHR5U3RlcCA9IGlzRW1wdHk7XG4gICAgICAgICAgICBzdHlsZXMgPSBzdHlsZUFzdDtcbiAgICAgICAgfVxuICAgICAgICBjb250ZXh0LmN1cnJlbnRBbmltYXRlVGltaW5ncyA9IG51bGw7XG4gICAgICAgIHJldHVybiBuZXcgQW5pbWF0ZUFzdCh0aW1pbmdBc3QsIHN0eWxlcyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG1ldGFkYXRhXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBbmltYXRpb25Bc3RCdWlsZGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRTdHlsZSA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gbWV0YWRhdGFcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChtZXRhZGF0YSwgY29udGV4dCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBhc3QgPSB0aGlzLl9tYWtlU3R5bGVBc3QobWV0YWRhdGEsIGNvbnRleHQpO1xuICAgICAgICB0aGlzLl92YWxpZGF0ZVN0eWxlQXN0KGFzdCwgY29udGV4dCk7XG4gICAgICAgIHJldHVybiBhc3Q7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG1ldGFkYXRhXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBbmltYXRpb25Bc3RCdWlsZGVyVmlzaXRvci5wcm90b3R5cGUuX21ha2VTdHlsZUFzdCA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gbWV0YWRhdGFcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChtZXRhZGF0YSwgY29udGV4dCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdHlsZXMgPSBbXTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkobWV0YWRhdGEuc3R5bGVzKSkge1xuICAgICAgICAgICAgKC8qKiBAdHlwZSB7P30gKi8gKG1ldGFkYXRhLnN0eWxlcykpLmZvckVhY2goZnVuY3Rpb24gKHN0eWxlVHVwbGUpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHN0eWxlVHVwbGUgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0eWxlVHVwbGUgPT0gX2FuZ3VsYXJfYW5pbWF0aW9ucy5BVVRPX1NUWUxFKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZXMucHVzaCgvKiogQHR5cGUgez99ICovIChzdHlsZVR1cGxlKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmVycm9ycy5wdXNoKFwiVGhlIHByb3ZpZGVkIHN0eWxlIHN0cmluZyB2YWx1ZSBcIiArIHN0eWxlVHVwbGUgKyBcIiBpcyBub3QgYWxsb3dlZC5cIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlcy5wdXNoKC8qKiBAdHlwZSB7P30gKi8gKHN0eWxlVHVwbGUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0eWxlcy5wdXNoKG1ldGFkYXRhLnN0eWxlcyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY29udGFpbnNEeW5hbWljU3R5bGVzID0gZmFsc2U7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNvbGxlY3RlZEVhc2luZyA9IG51bGw7XG4gICAgICAgIHN0eWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChzdHlsZURhdGEpIHtcbiAgICAgICAgICAgIGlmIChpc09iamVjdChzdHlsZURhdGEpKSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3R5bGVNYXAgPSAvKiogQHR5cGUgez99ICovIChzdHlsZURhdGEpO1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVhc2luZyA9IHN0eWxlTWFwWydlYXNpbmcnXTtcbiAgICAgICAgICAgICAgICBpZiAoZWFzaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbGxlY3RlZEVhc2luZyA9IC8qKiBAdHlwZSB7P30gKi8gKGVhc2luZyk7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBzdHlsZU1hcFsnZWFzaW5nJ107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghY29udGFpbnNEeW5hbWljU3R5bGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gcHJvcCBpbiBzdHlsZU1hcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmFsdWUgPSBzdHlsZU1hcFtwcm9wXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZS50b1N0cmluZygpLmluZGV4T2YoU1VCU1RJVFVUSU9OX0VYUFJfU1RBUlQpID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250YWluc0R5bmFtaWNTdHlsZXMgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYXN0ID0gbmV3IFN0eWxlQXN0KHN0eWxlcywgY29sbGVjdGVkRWFzaW5nLCBtZXRhZGF0YS5vZmZzZXQpO1xuICAgICAgICBhc3QuY29udGFpbnNEeW5hbWljU3R5bGVzID0gY29udGFpbnNEeW5hbWljU3R5bGVzO1xuICAgICAgICByZXR1cm4gYXN0O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFuaW1hdGlvbkFzdEJ1aWxkZXJWaXNpdG9yLnByb3RvdHlwZS5fdmFsaWRhdGVTdHlsZUFzdCA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRpbWluZ3MgPSBjb250ZXh0LmN1cnJlbnRBbmltYXRlVGltaW5ncztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZW5kVGltZSA9IGNvbnRleHQuY3VycmVudFRpbWU7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0YXJ0VGltZSA9IGNvbnRleHQuY3VycmVudFRpbWU7XG4gICAgICAgIGlmICh0aW1pbmdzICYmIHN0YXJ0VGltZSA+IDApIHtcbiAgICAgICAgICAgIHN0YXJ0VGltZSAtPSB0aW1pbmdzLmR1cmF0aW9uICsgdGltaW5ncy5kZWxheTtcbiAgICAgICAgfVxuICAgICAgICBhc3Quc3R5bGVzLmZvckVhY2goZnVuY3Rpb24gKHR1cGxlKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHR1cGxlID09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHR1cGxlKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFfdGhpcy5fZHJpdmVyLnZhbGlkYXRlU3R5bGVQcm9wZXJ0eShwcm9wKSkge1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmVycm9ycy5wdXNoKFwiVGhlIHByb3ZpZGVkIGFuaW1hdGlvbiBwcm9wZXJ0eSBcXFwiXCIgKyBwcm9wICsgXCJcXFwiIGlzIG5vdCBhIHN1cHBvcnRlZCBDU1MgcHJvcGVydHkgZm9yIGFuaW1hdGlvbnNcIik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY29sbGVjdGVkU3R5bGVzID0gY29udGV4dC5jb2xsZWN0ZWRTdHlsZXNbLyoqIEB0eXBlIHs/fSAqLyAoKGNvbnRleHQuY3VycmVudFF1ZXJ5U2VsZWN0b3IpKV07XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY29sbGVjdGVkRW50cnkgPSBjb2xsZWN0ZWRTdHlsZXNbcHJvcF07XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdXBkYXRlQ29sbGVjdGVkU3R5bGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmIChjb2xsZWN0ZWRFbnRyeSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhcnRUaW1lICE9IGVuZFRpbWUgJiYgc3RhcnRUaW1lID49IGNvbGxlY3RlZEVudHJ5LnN0YXJ0VGltZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kVGltZSA8PSBjb2xsZWN0ZWRFbnRyeS5lbmRUaW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmVycm9ycy5wdXNoKFwiVGhlIENTUyBwcm9wZXJ0eSBcXFwiXCIgKyBwcm9wICsgXCJcXFwiIHRoYXQgZXhpc3RzIGJldHdlZW4gdGhlIHRpbWVzIG9mIFxcXCJcIiArIGNvbGxlY3RlZEVudHJ5LnN0YXJ0VGltZSArIFwibXNcXFwiIGFuZCBcXFwiXCIgKyBjb2xsZWN0ZWRFbnRyeS5lbmRUaW1lICsgXCJtc1xcXCIgaXMgYWxzbyBiZWluZyBhbmltYXRlZCBpbiBhIHBhcmFsbGVsIGFuaW1hdGlvbiBiZXR3ZWVuIHRoZSB0aW1lcyBvZiBcXFwiXCIgKyBzdGFydFRpbWUgKyBcIm1zXFxcIiBhbmQgXFxcIlwiICsgZW5kVGltZSArIFwibXNcXFwiXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlQ29sbGVjdGVkU3R5bGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyB3ZSBhbHdheXMgY2hvb3NlIHRoZSBzbWFsbGVyIHN0YXJ0IHRpbWUgdmFsdWUgc2luY2Ugd2VcbiAgICAgICAgICAgICAgICAgICAgLy8gd2FudCB0byBoYXZlIGEgcmVjb3JkIG9mIHRoZSBlbnRpcmUgYW5pbWF0aW9uIHdpbmRvdyB3aGVyZVxuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgc3R5bGUgcHJvcGVydHkgaXMgYmVpbmcgYW5pbWF0ZWQgaW4gYmV0d2VlblxuICAgICAgICAgICAgICAgICAgICBzdGFydFRpbWUgPSBjb2xsZWN0ZWRFbnRyeS5zdGFydFRpbWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh1cGRhdGVDb2xsZWN0ZWRTdHlsZSkge1xuICAgICAgICAgICAgICAgICAgICBjb2xsZWN0ZWRTdHlsZXNbcHJvcF0gPSB7IHN0YXJ0VGltZTogc3RhcnRUaW1lLCBlbmRUaW1lOiBlbmRUaW1lIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjb250ZXh0Lm9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGVTdHlsZVBhcmFtcyh0dXBsZVtwcm9wXSwgY29udGV4dC5vcHRpb25zLCBjb250ZXh0LmVycm9ycyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBtZXRhZGF0YVxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQW5pbWF0aW9uQXN0QnVpbGRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0S2V5ZnJhbWVzID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBtZXRhZGF0YVxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKG1ldGFkYXRhLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICghY29udGV4dC5jdXJyZW50QW5pbWF0ZVRpbWluZ3MpIHtcbiAgICAgICAgICAgIGNvbnRleHQuZXJyb3JzLnB1c2goXCJrZXlmcmFtZXMoKSBtdXN0IGJlIHBsYWNlZCBpbnNpZGUgb2YgYSBjYWxsIHRvIGFuaW1hdGUoKVwiKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgS2V5ZnJhbWVzQXN0KFtdKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBNQVhfS0VZRlJBTUVfT0ZGU0VUID0gMTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdG90YWxLZXlmcmFtZXNXaXRoT2Zmc2V0cyA9IDA7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG9mZnNldHMgPSBbXTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gb2Zmc2V0c091dE9mT3JkZXIgPSBmYWxzZTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8ga2V5ZnJhbWVzT3V0T2ZSYW5nZSA9IGZhbHNlO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwcmV2aW91c09mZnNldCA9IDA7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGtleWZyYW1lcyA9IG1ldGFkYXRhLnN0ZXBzLm1hcChmdW5jdGlvbiAoc3R5bGVzKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdHlsZSQkMSA9IF90aGlzLl9tYWtlU3R5bGVBc3Qoc3R5bGVzLCBjb250ZXh0KTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG9mZnNldFZhbCA9IHN0eWxlJCQxLm9mZnNldCAhPSBudWxsID8gc3R5bGUkJDEub2Zmc2V0IDogY29uc3VtZU9mZnNldChzdHlsZSQkMS5zdHlsZXMpO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gb2Zmc2V0ID0gMDtcbiAgICAgICAgICAgIGlmIChvZmZzZXRWYWwgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRvdGFsS2V5ZnJhbWVzV2l0aE9mZnNldHMrKztcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSBzdHlsZSQkMS5vZmZzZXQgPSBvZmZzZXRWYWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBrZXlmcmFtZXNPdXRPZlJhbmdlID0ga2V5ZnJhbWVzT3V0T2ZSYW5nZSB8fCBvZmZzZXQgPCAwIHx8IG9mZnNldCA+IDE7XG4gICAgICAgICAgICBvZmZzZXRzT3V0T2ZPcmRlciA9IG9mZnNldHNPdXRPZk9yZGVyIHx8IG9mZnNldCA8IHByZXZpb3VzT2Zmc2V0O1xuICAgICAgICAgICAgcHJldmlvdXNPZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgICAgICBvZmZzZXRzLnB1c2gob2Zmc2V0KTtcbiAgICAgICAgICAgIHJldHVybiBzdHlsZSQkMTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChrZXlmcmFtZXNPdXRPZlJhbmdlKSB7XG4gICAgICAgICAgICBjb250ZXh0LmVycm9ycy5wdXNoKFwiUGxlYXNlIGVuc3VyZSB0aGF0IGFsbCBrZXlmcmFtZSBvZmZzZXRzIGFyZSBiZXR3ZWVuIDAgYW5kIDFcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9mZnNldHNPdXRPZk9yZGVyKSB7XG4gICAgICAgICAgICBjb250ZXh0LmVycm9ycy5wdXNoKFwiUGxlYXNlIGVuc3VyZSB0aGF0IGFsbCBrZXlmcmFtZSBvZmZzZXRzIGFyZSBpbiBvcmRlclwiKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBsZW5ndGggPSBtZXRhZGF0YS5zdGVwcy5sZW5ndGg7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGdlbmVyYXRlZE9mZnNldCA9IDA7XG4gICAgICAgIGlmICh0b3RhbEtleWZyYW1lc1dpdGhPZmZzZXRzID4gMCAmJiB0b3RhbEtleWZyYW1lc1dpdGhPZmZzZXRzIDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBjb250ZXh0LmVycm9ycy5wdXNoKFwiTm90IGFsbCBzdHlsZSgpIHN0ZXBzIHdpdGhpbiB0aGUgZGVjbGFyZWQga2V5ZnJhbWVzKCkgY29udGFpbiBvZmZzZXRzXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRvdGFsS2V5ZnJhbWVzV2l0aE9mZnNldHMgPT0gMCkge1xuICAgICAgICAgICAgZ2VuZXJhdGVkT2Zmc2V0ID0gTUFYX0tFWUZSQU1FX09GRlNFVCAvIChsZW5ndGggLSAxKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBsaW1pdCA9IGxlbmd0aCAtIDE7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGN1cnJlbnRUaW1lID0gY29udGV4dC5jdXJyZW50VGltZTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY3VycmVudEFuaW1hdGVUaW1pbmdzID0gLyoqIEB0eXBlIHs/fSAqLyAoKGNvbnRleHQuY3VycmVudEFuaW1hdGVUaW1pbmdzKSk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGFuaW1hdGVEdXJhdGlvbiA9IGN1cnJlbnRBbmltYXRlVGltaW5ncy5kdXJhdGlvbjtcbiAgICAgICAga2V5ZnJhbWVzLmZvckVhY2goZnVuY3Rpb24gKGtmLCBpKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBvZmZzZXQgPSBnZW5lcmF0ZWRPZmZzZXQgPiAwID8gKGkgPT0gbGltaXQgPyAxIDogKGdlbmVyYXRlZE9mZnNldCAqIGkpKSA6IG9mZnNldHNbaV07XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkdXJhdGlvblVwVG9UaGlzRnJhbWUgPSBvZmZzZXQgKiBhbmltYXRlRHVyYXRpb247XG4gICAgICAgICAgICBjb250ZXh0LmN1cnJlbnRUaW1lID0gY3VycmVudFRpbWUgKyBjdXJyZW50QW5pbWF0ZVRpbWluZ3MuZGVsYXkgKyBkdXJhdGlvblVwVG9UaGlzRnJhbWU7XG4gICAgICAgICAgICBjdXJyZW50QW5pbWF0ZVRpbWluZ3MuZHVyYXRpb24gPSBkdXJhdGlvblVwVG9UaGlzRnJhbWU7XG4gICAgICAgICAgICBfdGhpcy5fdmFsaWRhdGVTdHlsZUFzdChrZiwgY29udGV4dCk7XG4gICAgICAgICAgICBrZi5vZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbmV3IEtleWZyYW1lc0FzdChrZXlmcmFtZXMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBtZXRhZGF0YVxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQW5pbWF0aW9uQXN0QnVpbGRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0UmVmZXJlbmNlID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBtZXRhZGF0YVxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKG1ldGFkYXRhLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVudHJ5ID0gdmlzaXRBbmltYXRpb25Ob2RlKHRoaXMsIG5vcm1hbGl6ZUFuaW1hdGlvbkVudHJ5KG1ldGFkYXRhLmFuaW1hdGlvbiksIGNvbnRleHQpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBhc3QgPSBuZXcgUmVmZXJlbmNlQXN0KGVudHJ5KTtcbiAgICAgICAgYXN0Lm9wdGlvbnMgPSBub3JtYWxpemVBbmltYXRpb25PcHRpb25zKG1ldGFkYXRhLm9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gYXN0O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBtZXRhZGF0YVxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQW5pbWF0aW9uQXN0QnVpbGRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0QW5pbWF0ZUNoaWxkID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBtZXRhZGF0YVxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKG1ldGFkYXRhLCBjb250ZXh0KSB7XG4gICAgICAgIGNvbnRleHQuZGVwQ291bnQrKztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYXN0ID0gbmV3IEFuaW1hdGVDaGlsZEFzdCgpO1xuICAgICAgICBhc3Qub3B0aW9ucyA9IG5vcm1hbGl6ZUFuaW1hdGlvbk9wdGlvbnMobWV0YWRhdGEub3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBhc3Q7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG1ldGFkYXRhXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBbmltYXRpb25Bc3RCdWlsZGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRBbmltYXRlUmVmID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBtZXRhZGF0YVxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKG1ldGFkYXRhLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGFuaW1hdGlvbiA9IHRoaXMudmlzaXRSZWZlcmVuY2UobWV0YWRhdGEuYW5pbWF0aW9uLCBjb250ZXh0KTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYXN0ID0gbmV3IEFuaW1hdGVSZWZBc3QoYW5pbWF0aW9uKTtcbiAgICAgICAgYXN0Lm9wdGlvbnMgPSBub3JtYWxpemVBbmltYXRpb25PcHRpb25zKG1ldGFkYXRhLm9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gYXN0O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBtZXRhZGF0YVxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQW5pbWF0aW9uQXN0QnVpbGRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0UXVlcnkgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IG1ldGFkYXRhXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAobWV0YWRhdGEsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGFyZW50U2VsZWN0b3IgPSAvKiogQHR5cGUgez99ICovICgoY29udGV4dC5jdXJyZW50UXVlcnlTZWxlY3RvcikpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBvcHRpb25zID0gLyoqIEB0eXBlIHs/fSAqLyAoKG1ldGFkYXRhLm9wdGlvbnMgfHwge30pKTtcbiAgICAgICAgY29udGV4dC5xdWVyeUNvdW50Kys7XG4gICAgICAgIGNvbnRleHQuY3VycmVudFF1ZXJ5ID0gbWV0YWRhdGE7XG4gICAgICAgIHZhciBfYSA9IG5vcm1hbGl6ZVNlbGVjdG9yKG1ldGFkYXRhLnNlbGVjdG9yKSwgc2VsZWN0b3IgPSBfYVswXSwgaW5jbHVkZVNlbGYgPSBfYVsxXTtcbiAgICAgICAgY29udGV4dC5jdXJyZW50UXVlcnlTZWxlY3RvciA9XG4gICAgICAgICAgICBwYXJlbnRTZWxlY3Rvci5sZW5ndGggPyAocGFyZW50U2VsZWN0b3IgKyAnICcgKyBzZWxlY3RvcikgOiBzZWxlY3RvcjtcbiAgICAgICAgZ2V0T3JTZXRBc0luTWFwKGNvbnRleHQuY29sbGVjdGVkU3R5bGVzLCBjb250ZXh0LmN1cnJlbnRRdWVyeVNlbGVjdG9yLCB7fSk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVudHJ5ID0gdmlzaXRBbmltYXRpb25Ob2RlKHRoaXMsIG5vcm1hbGl6ZUFuaW1hdGlvbkVudHJ5KG1ldGFkYXRhLmFuaW1hdGlvbiksIGNvbnRleHQpO1xuICAgICAgICBjb250ZXh0LmN1cnJlbnRRdWVyeSA9IG51bGw7XG4gICAgICAgIGNvbnRleHQuY3VycmVudFF1ZXJ5U2VsZWN0b3IgPSBwYXJlbnRTZWxlY3RvcjtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYXN0ID0gbmV3IFF1ZXJ5QXN0KHNlbGVjdG9yLCBvcHRpb25zLmxpbWl0IHx8IDAsICEhb3B0aW9ucy5vcHRpb25hbCwgaW5jbHVkZVNlbGYsIGVudHJ5KTtcbiAgICAgICAgYXN0Lm9yaWdpbmFsU2VsZWN0b3IgPSBtZXRhZGF0YS5zZWxlY3RvcjtcbiAgICAgICAgYXN0Lm9wdGlvbnMgPSBub3JtYWxpemVBbmltYXRpb25PcHRpb25zKG1ldGFkYXRhLm9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gYXN0O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBtZXRhZGF0YVxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQW5pbWF0aW9uQXN0QnVpbGRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0U3RhZ2dlciA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gbWV0YWRhdGFcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChtZXRhZGF0YSwgY29udGV4dCkge1xuICAgICAgICBpZiAoIWNvbnRleHQuY3VycmVudFF1ZXJ5KSB7XG4gICAgICAgICAgICBjb250ZXh0LmVycm9ycy5wdXNoKFwic3RhZ2dlcigpIGNhbiBvbmx5IGJlIHVzZWQgaW5zaWRlIG9mIHF1ZXJ5KClcIik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdGltaW5ncyA9IG1ldGFkYXRhLnRpbWluZ3MgPT09ICdmdWxsJyA/XG4gICAgICAgICAgICB7IGR1cmF0aW9uOiAwLCBkZWxheTogMCwgZWFzaW5nOiAnZnVsbCcgfSA6XG4gICAgICAgICAgICByZXNvbHZlVGltaW5nKG1ldGFkYXRhLnRpbWluZ3MsIGNvbnRleHQuZXJyb3JzLCB0cnVlKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYW5pbWF0aW9uID0gdmlzaXRBbmltYXRpb25Ob2RlKHRoaXMsIG5vcm1hbGl6ZUFuaW1hdGlvbkVudHJ5KG1ldGFkYXRhLmFuaW1hdGlvbiksIGNvbnRleHQpO1xuICAgICAgICByZXR1cm4gbmV3IFN0YWdnZXJBc3QodGltaW5ncywgYW5pbWF0aW9uKTtcbiAgICB9O1xuICAgIHJldHVybiBBbmltYXRpb25Bc3RCdWlsZGVyVmlzaXRvcjtcbn0oKSk7XG4vKipcbiAqIEBwYXJhbSB7P30gc2VsZWN0b3JcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZVNlbGVjdG9yKHNlbGVjdG9yKSB7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaGFzQW1wZXJzYW5kID0gc2VsZWN0b3Iuc3BsaXQoL1xccyosXFxzKi8pLmZpbmQoZnVuY3Rpb24gKHRva2VuKSB7IHJldHVybiB0b2tlbiA9PSBTRUxGX1RPS0VOOyB9KSA/IHRydWUgOiBmYWxzZTtcbiAgICBpZiAoaGFzQW1wZXJzYW5kKSB7XG4gICAgICAgIHNlbGVjdG9yID0gc2VsZWN0b3IucmVwbGFjZShTRUxGX1RPS0VOX1JFR0VYLCAnJyk7XG4gICAgfVxuICAgIHNlbGVjdG9yID0gc2VsZWN0b3IucmVwbGFjZShFTlRFUl9UT0tFTl9SRUdFWCwgRU5URVJfU0VMRUNUT1IpXG4gICAgICAgIC5yZXBsYWNlKExFQVZFX1RPS0VOX1JFR0VYLCBMRUFWRV9TRUxFQ1RPUilcbiAgICAgICAgLnJlcGxhY2UoL0BcXCovZywgTkdfVFJJR0dFUl9TRUxFQ1RPUilcbiAgICAgICAgLnJlcGxhY2UoL0BcXHcrL2csIGZ1bmN0aW9uIChtYXRjaCkgeyByZXR1cm4gTkdfVFJJR0dFUl9TRUxFQ1RPUiArICctJyArIG1hdGNoLnN1YnN0cigxKTsgfSlcbiAgICAgICAgLnJlcGxhY2UoLzphbmltYXRpbmcvZywgTkdfQU5JTUFUSU5HX1NFTEVDVE9SKTtcbiAgICByZXR1cm4gW3NlbGVjdG9yLCBoYXNBbXBlcnNhbmRdO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IG9ialxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplUGFyYW1zKG9iaikge1xuICAgIHJldHVybiBvYmogPyBjb3B5T2JqKG9iaikgOiBudWxsO1xufVxudmFyIEFuaW1hdGlvbkFzdEJ1aWxkZXJDb250ZXh0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBbmltYXRpb25Bc3RCdWlsZGVyQ29udGV4dChlcnJvcnMpIHtcbiAgICAgICAgdGhpcy5lcnJvcnMgPSBlcnJvcnM7XG4gICAgICAgIHRoaXMucXVlcnlDb3VudCA9IDA7XG4gICAgICAgIHRoaXMuZGVwQ291bnQgPSAwO1xuICAgICAgICB0aGlzLmN1cnJlbnRUcmFuc2l0aW9uID0gbnVsbDtcbiAgICAgICAgdGhpcy5jdXJyZW50UXVlcnkgPSBudWxsO1xuICAgICAgICB0aGlzLmN1cnJlbnRRdWVyeVNlbGVjdG9yID0gbnVsbDtcbiAgICAgICAgdGhpcy5jdXJyZW50QW5pbWF0ZVRpbWluZ3MgPSBudWxsO1xuICAgICAgICB0aGlzLmN1cnJlbnRUaW1lID0gMDtcbiAgICAgICAgdGhpcy5jb2xsZWN0ZWRTdHlsZXMgPSB7fTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIEFuaW1hdGlvbkFzdEJ1aWxkZXJDb250ZXh0O1xufSgpKTtcbi8qKlxuICogQHBhcmFtIHs/fSBzdHlsZXNcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGNvbnN1bWVPZmZzZXQoc3R5bGVzKSB7XG4gICAgaWYgKHR5cGVvZiBzdHlsZXMgPT0gJ3N0cmluZycpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIG9mZnNldCA9IG51bGw7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoc3R5bGVzKSkge1xuICAgICAgICBzdHlsZXMuZm9yRWFjaChmdW5jdGlvbiAoc3R5bGVUdXBsZSkge1xuICAgICAgICAgICAgaWYgKGlzT2JqZWN0KHN0eWxlVHVwbGUpICYmIHN0eWxlVHVwbGUuaGFzT3duUHJvcGVydHkoJ29mZnNldCcpKSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gb2JqID0gLyoqIEB0eXBlIHs/fSAqLyAoc3R5bGVUdXBsZSk7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gcGFyc2VGbG9hdCgvKiogQHR5cGUgez99ICovIChvYmpbJ29mZnNldCddKSk7XG4gICAgICAgICAgICAgICAgZGVsZXRlIG9ialsnb2Zmc2V0J107XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc09iamVjdChzdHlsZXMpICYmIHN0eWxlcy5oYXNPd25Qcm9wZXJ0eSgnb2Zmc2V0JykpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gb2JqID0gLyoqIEB0eXBlIHs/fSAqLyAoc3R5bGVzKTtcbiAgICAgICAgb2Zmc2V0ID0gcGFyc2VGbG9hdCgvKiogQHR5cGUgez99ICovIChvYmpbJ29mZnNldCddKSk7XG4gICAgICAgIGRlbGV0ZSBvYmpbJ29mZnNldCddO1xuICAgIH1cbiAgICByZXR1cm4gb2Zmc2V0O1xufVxuLyoqXG4gKiBAcGFyYW0gez99IHZhbHVlXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICAgIHJldHVybiAhQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IHZhbHVlXG4gKiBAcGFyYW0gez99IGVycm9yc1xuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gY29uc3RydWN0VGltaW5nQXN0KHZhbHVlLCBlcnJvcnMpIHtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0aW1pbmdzID0gbnVsbDtcbiAgICBpZiAodmFsdWUuaGFzT3duUHJvcGVydHkoJ2R1cmF0aW9uJykpIHtcbiAgICAgICAgdGltaW5ncyA9IC8qKiBAdHlwZSB7P30gKi8gKHZhbHVlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09ICdudW1iZXInKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGR1cmF0aW9uID0gcmVzb2x2ZVRpbWluZygvKiogQHR5cGUgez99ICovICh2YWx1ZSksIGVycm9ycykuZHVyYXRpb247XG4gICAgICAgIHJldHVybiBuZXcgVGltaW5nQXN0KC8qKiBAdHlwZSB7P30gKi8gKHZhbHVlKSwgMCwgJycpO1xuICAgIH1cbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdHJWYWx1ZSA9IC8qKiBAdHlwZSB7P30gKi8gKHZhbHVlKTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpc0R5bmFtaWMgPSBzdHJWYWx1ZS5zcGxpdCgvXFxzKy8pLnNvbWUoZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHYuY2hhckF0KDApID09ICd7JyAmJiB2LmNoYXJBdCgxKSA9PSAneyc7IH0pO1xuICAgIGlmIChpc0R5bmFtaWMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEeW5hbWljVGltaW5nQXN0KHN0clZhbHVlKTtcbiAgICB9XG4gICAgdGltaW5ncyA9IHRpbWluZ3MgfHwgcmVzb2x2ZVRpbWluZyhzdHJWYWx1ZSwgZXJyb3JzKTtcbiAgICByZXR1cm4gbmV3IFRpbWluZ0FzdCh0aW1pbmdzLmR1cmF0aW9uLCB0aW1pbmdzLmRlbGF5LCB0aW1pbmdzLmVhc2luZyk7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gb3B0aW9uc1xuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplQW5pbWF0aW9uT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucyA9IGNvcHlPYmoob3B0aW9ucyk7XG4gICAgICAgIGlmIChvcHRpb25zWydwYXJhbXMnXSkge1xuICAgICAgICAgICAgb3B0aW9uc1sncGFyYW1zJ10gPSAvKiogQHR5cGUgez99ICovICgobm9ybWFsaXplUGFyYW1zKG9wdGlvbnNbJ3BhcmFtcyddKSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBvcHRpb25zID0ge307XG4gICAgfVxuICAgIHJldHVybiBvcHRpb25zO1xufVxuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgYWRkZWQgYnkgdHNpY2tsZVxuICogQHN1cHByZXNzIHtjaGVja1R5cGVzfSBjaGVja2VkIGJ5IHRzY1xuICovXG4vKipcbiAqIEByZWNvcmRcbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7P30gZWxlbWVudFxuICogQHBhcmFtIHs/fSBrZXlmcmFtZXNcbiAqIEBwYXJhbSB7P30gcHJlU3R5bGVQcm9wc1xuICogQHBhcmFtIHs/fSBwb3N0U3R5bGVQcm9wc1xuICogQHBhcmFtIHs/fSBkdXJhdGlvblxuICogQHBhcmFtIHs/fSBkZWxheVxuICogQHBhcmFtIHs/PX0gZWFzaW5nXG4gKiBAcGFyYW0gez89fSBzdWJUaW1lbGluZVxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gY3JlYXRlVGltZWxpbmVJbnN0cnVjdGlvbihlbGVtZW50LCBrZXlmcmFtZXMsIHByZVN0eWxlUHJvcHMsIHBvc3RTdHlsZVByb3BzLCBkdXJhdGlvbiwgZGVsYXksIGVhc2luZywgc3ViVGltZWxpbmUpIHtcbiAgICBpZiAoZWFzaW5nID09PSB2b2lkIDApIHsgZWFzaW5nID0gbnVsbDsgfVxuICAgIGlmIChzdWJUaW1lbGluZSA9PT0gdm9pZCAwKSB7IHN1YlRpbWVsaW5lID0gZmFsc2U7IH1cbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAxIC8qIFRpbWVsaW5lQW5pbWF0aW9uICovLFxuICAgICAgICBlbGVtZW50OiBlbGVtZW50LFxuICAgICAgICBrZXlmcmFtZXM6IGtleWZyYW1lcyxcbiAgICAgICAgcHJlU3R5bGVQcm9wczogcHJlU3R5bGVQcm9wcyxcbiAgICAgICAgcG9zdFN0eWxlUHJvcHM6IHBvc3RTdHlsZVByb3BzLFxuICAgICAgICBkdXJhdGlvbjogZHVyYXRpb24sXG4gICAgICAgIGRlbGF5OiBkZWxheSxcbiAgICAgICAgdG90YWxUaW1lOiBkdXJhdGlvbiArIGRlbGF5LCBlYXNpbmc6IGVhc2luZywgc3ViVGltZWxpbmU6IHN1YlRpbWVsaW5lXG4gICAgfTtcbn1cblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IGFkZGVkIGJ5IHRzaWNrbGVcbiAqIEBzdXBwcmVzcyB7Y2hlY2tUeXBlc30gY2hlY2tlZCBieSB0c2NcbiAqL1xudmFyIEVsZW1lbnRJbnN0cnVjdGlvbk1hcCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRWxlbWVudEluc3RydWN0aW9uTWFwKCkge1xuICAgICAgICB0aGlzLl9tYXAgPSBuZXcgTWFwKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRWxlbWVudEluc3RydWN0aW9uTWFwLnByb3RvdHlwZS5jb25zdW1lID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpbnN0cnVjdGlvbnMgPSB0aGlzLl9tYXAuZ2V0KGVsZW1lbnQpO1xuICAgICAgICBpZiAoaW5zdHJ1Y3Rpb25zKSB7XG4gICAgICAgICAgICB0aGlzLl9tYXAuZGVsZXRlKGVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaW5zdHJ1Y3Rpb25zID0gW107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGluc3RydWN0aW9ucztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFxuICAgICAqIEBwYXJhbSB7P30gaW5zdHJ1Y3Rpb25zXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBFbGVtZW50SW5zdHJ1Y3Rpb25NYXAucHJvdG90eXBlLmFwcGVuZCA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFxuICAgICAqIEBwYXJhbSB7P30gaW5zdHJ1Y3Rpb25zXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoZWxlbWVudCwgaW5zdHJ1Y3Rpb25zKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGV4aXN0aW5nSW5zdHJ1Y3Rpb25zID0gdGhpcy5fbWFwLmdldChlbGVtZW50KTtcbiAgICAgICAgaWYgKCFleGlzdGluZ0luc3RydWN0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5fbWFwLnNldChlbGVtZW50LCBleGlzdGluZ0luc3RydWN0aW9ucyA9IFtdKTtcbiAgICAgICAgfVxuICAgICAgICBleGlzdGluZ0luc3RydWN0aW9ucy5wdXNoLmFwcGx5KGV4aXN0aW5nSW5zdHJ1Y3Rpb25zLCBpbnN0cnVjdGlvbnMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBFbGVtZW50SW5zdHJ1Y3Rpb25NYXAucHJvdG90eXBlLmhhcyA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKGVsZW1lbnQpIHsgcmV0dXJuIHRoaXMuX21hcC5oYXMoZWxlbWVudCk7IH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBFbGVtZW50SW5zdHJ1Y3Rpb25NYXAucHJvdG90eXBlLmNsZWFyID0gLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoKSB7IHRoaXMuX21hcC5jbGVhcigpOyB9O1xuICAgIHJldHVybiBFbGVtZW50SW5zdHJ1Y3Rpb25NYXA7XG59KCkpO1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgYWRkZWQgYnkgdHNpY2tsZVxuICogQHN1cHByZXNzIHtjaGVja1R5cGVzfSBjaGVja2VkIGJ5IHRzY1xuICovXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgT05FX0ZSQU1FX0lOX01JTExJU0VDT05EUyA9IDE7XG4vKipcbiAqIEBwYXJhbSB7P30gZHJpdmVyXG4gKiBAcGFyYW0gez99IHJvb3RFbGVtZW50XG4gKiBAcGFyYW0gez99IGFzdFxuICogQHBhcmFtIHs/PX0gc3RhcnRpbmdTdHlsZXNcbiAqIEBwYXJhbSB7Pz19IGZpbmFsU3R5bGVzXG4gKiBAcGFyYW0gez89fSBvcHRpb25zXG4gKiBAcGFyYW0gez89fSBzdWJJbnN0cnVjdGlvbnNcbiAqIEBwYXJhbSB7Pz19IGVycm9yc1xuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gYnVpbGRBbmltYXRpb25UaW1lbGluZXMoZHJpdmVyLCByb290RWxlbWVudCwgYXN0LCBzdGFydGluZ1N0eWxlcywgZmluYWxTdHlsZXMsIG9wdGlvbnMsIHN1Ykluc3RydWN0aW9ucywgZXJyb3JzKSB7XG4gICAgaWYgKHN0YXJ0aW5nU3R5bGVzID09PSB2b2lkIDApIHsgc3RhcnRpbmdTdHlsZXMgPSB7fTsgfVxuICAgIGlmIChmaW5hbFN0eWxlcyA9PT0gdm9pZCAwKSB7IGZpbmFsU3R5bGVzID0ge307IH1cbiAgICBpZiAoZXJyb3JzID09PSB2b2lkIDApIHsgZXJyb3JzID0gW107IH1cbiAgICByZXR1cm4gbmV3IEFuaW1hdGlvblRpbWVsaW5lQnVpbGRlclZpc2l0b3IoKS5idWlsZEtleWZyYW1lcyhkcml2ZXIsIHJvb3RFbGVtZW50LCBhc3QsIHN0YXJ0aW5nU3R5bGVzLCBmaW5hbFN0eWxlcywgb3B0aW9ucywgc3ViSW5zdHJ1Y3Rpb25zLCBlcnJvcnMpO1xufVxudmFyIEFuaW1hdGlvblRpbWVsaW5lQnVpbGRlclZpc2l0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEFuaW1hdGlvblRpbWVsaW5lQnVpbGRlclZpc2l0b3IoKSB7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZHJpdmVyXG4gICAgICogQHBhcmFtIHs/fSByb290RWxlbWVudFxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBzdGFydGluZ1N0eWxlc1xuICAgICAqIEBwYXJhbSB7P30gZmluYWxTdHlsZXNcbiAgICAgKiBAcGFyYW0gez99IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0gez89fSBzdWJJbnN0cnVjdGlvbnNcbiAgICAgKiBAcGFyYW0gez89fSBlcnJvcnNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFuaW1hdGlvblRpbWVsaW5lQnVpbGRlclZpc2l0b3IucHJvdG90eXBlLmJ1aWxkS2V5ZnJhbWVzID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBkcml2ZXJcbiAgICAgKiBAcGFyYW0gez99IHJvb3RFbGVtZW50XG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IHN0YXJ0aW5nU3R5bGVzXG4gICAgICogQHBhcmFtIHs/fSBmaW5hbFN0eWxlc1xuICAgICAqIEBwYXJhbSB7P30gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7Pz19IHN1Ykluc3RydWN0aW9uc1xuICAgICAqIEBwYXJhbSB7Pz19IGVycm9yc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKGRyaXZlciwgcm9vdEVsZW1lbnQsIGFzdCwgc3RhcnRpbmdTdHlsZXMsIGZpbmFsU3R5bGVzLCBvcHRpb25zLCBzdWJJbnN0cnVjdGlvbnMsIGVycm9ycykge1xuICAgICAgICBpZiAoZXJyb3JzID09PSB2b2lkIDApIHsgZXJyb3JzID0gW107IH1cbiAgICAgICAgc3ViSW5zdHJ1Y3Rpb25zID0gc3ViSW5zdHJ1Y3Rpb25zIHx8IG5ldyBFbGVtZW50SW5zdHJ1Y3Rpb25NYXAoKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY29udGV4dCA9IG5ldyBBbmltYXRpb25UaW1lbGluZUNvbnRleHQoZHJpdmVyLCByb290RWxlbWVudCwgc3ViSW5zdHJ1Y3Rpb25zLCBlcnJvcnMsIFtdKTtcbiAgICAgICAgY29udGV4dC5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgY29udGV4dC5jdXJyZW50VGltZWxpbmUuc2V0U3R5bGVzKFtzdGFydGluZ1N0eWxlc10sIG51bGwsIGNvbnRleHQuZXJyb3JzLCBvcHRpb25zKTtcbiAgICAgICAgYXN0LnZpc2l0KHRoaXMsIGNvbnRleHQpO1xuICAgICAgICAvLyB0aGlzIGNoZWNrcyB0byBzZWUgaWYgYW4gYWN0dWFsIGFuaW1hdGlvbiBoYXBwZW5lZFxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0aW1lbGluZXMgPSBjb250ZXh0LnRpbWVsaW5lcy5maWx0ZXIoZnVuY3Rpb24gKHRpbWVsaW5lKSB7IHJldHVybiB0aW1lbGluZS5jb250YWluc0FuaW1hdGlvbigpOyB9KTtcbiAgICAgICAgaWYgKHRpbWVsaW5lcy5sZW5ndGggJiYgT2JqZWN0LmtleXMoZmluYWxTdHlsZXMpLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdGwgPSB0aW1lbGluZXNbdGltZWxpbmVzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgaWYgKCF0bC5hbGxvd09ubHlUaW1lbGluZVN0eWxlcygpKSB7XG4gICAgICAgICAgICAgICAgdGwuc2V0U3R5bGVzKFtmaW5hbFN0eWxlc10sIG51bGwsIGNvbnRleHQuZXJyb3JzLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGltZWxpbmVzLmxlbmd0aCA/IHRpbWVsaW5lcy5tYXAoZnVuY3Rpb24gKHRpbWVsaW5lKSB7IHJldHVybiB0aW1lbGluZS5idWlsZEtleWZyYW1lcygpOyB9KSA6XG4gICAgICAgICAgICBbY3JlYXRlVGltZWxpbmVJbnN0cnVjdGlvbihyb290RWxlbWVudCwgW10sIFtdLCBbXSwgMCwgMCwgJycsIGZhbHNlKV07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQW5pbWF0aW9uVGltZWxpbmVCdWlsZGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRUcmlnZ2VyID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgLy8gdGhlc2UgdmFsdWVzIGFyZSBub3QgdmlzaXRlZCBpbiB0aGlzIEFTVFxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFuaW1hdGlvblRpbWVsaW5lQnVpbGRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0U3RhdGUgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICAvLyB0aGVzZSB2YWx1ZXMgYXJlIG5vdCB2aXNpdGVkIGluIHRoaXMgQVNUXG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQW5pbWF0aW9uVGltZWxpbmVCdWlsZGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRUcmFuc2l0aW9uID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgLy8gdGhlc2UgdmFsdWVzIGFyZSBub3QgdmlzaXRlZCBpbiB0aGlzIEFTVFxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFuaW1hdGlvblRpbWVsaW5lQnVpbGRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0QW5pbWF0ZUNoaWxkID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZWxlbWVudEluc3RydWN0aW9ucyA9IGNvbnRleHQuc3ViSW5zdHJ1Y3Rpb25zLmNvbnN1bWUoY29udGV4dC5lbGVtZW50KTtcbiAgICAgICAgaWYgKGVsZW1lbnRJbnN0cnVjdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGlubmVyQ29udGV4dCA9IGNvbnRleHQuY3JlYXRlU3ViQ29udGV4dChhc3Qub3B0aW9ucyk7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdGFydFRpbWUgPSBjb250ZXh0LmN1cnJlbnRUaW1lbGluZS5jdXJyZW50VGltZTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVuZFRpbWUgPSB0aGlzLl92aXNpdFN1Ykluc3RydWN0aW9ucyhlbGVtZW50SW5zdHJ1Y3Rpb25zLCBpbm5lckNvbnRleHQsIC8qKiBAdHlwZSB7P30gKi8gKGlubmVyQ29udGV4dC5vcHRpb25zKSk7XG4gICAgICAgICAgICBpZiAoc3RhcnRUaW1lICE9IGVuZFRpbWUpIHtcbiAgICAgICAgICAgICAgICAvLyB3ZSBkbyB0aGlzIG9uIHRoZSB1cHBlciBjb250ZXh0IGJlY2F1c2Ugd2UgY3JlYXRlZCBhIHN1YiBjb250ZXh0IGZvclxuICAgICAgICAgICAgICAgIC8vIHRoZSBzdWIgY2hpbGQgYW5pbWF0aW9uc1xuICAgICAgICAgICAgICAgIGNvbnRleHQudHJhbnNmb3JtSW50b05ld1RpbWVsaW5lKGVuZFRpbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnRleHQucHJldmlvdXNOb2RlID0gYXN0O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFuaW1hdGlvblRpbWVsaW5lQnVpbGRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0QW5pbWF0ZVJlZiA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGlubmVyQ29udGV4dCA9IGNvbnRleHQuY3JlYXRlU3ViQ29udGV4dChhc3Qub3B0aW9ucyk7XG4gICAgICAgIGlubmVyQ29udGV4dC50cmFuc2Zvcm1JbnRvTmV3VGltZWxpbmUoKTtcbiAgICAgICAgdGhpcy52aXNpdFJlZmVyZW5jZShhc3QuYW5pbWF0aW9uLCBpbm5lckNvbnRleHQpO1xuICAgICAgICBjb250ZXh0LnRyYW5zZm9ybUludG9OZXdUaW1lbGluZShpbm5lckNvbnRleHQuY3VycmVudFRpbWVsaW5lLmN1cnJlbnRUaW1lKTtcbiAgICAgICAgY29udGV4dC5wcmV2aW91c05vZGUgPSBhc3Q7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGluc3RydWN0aW9uc1xuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEBwYXJhbSB7P30gb3B0aW9uc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQW5pbWF0aW9uVGltZWxpbmVCdWlsZGVyVmlzaXRvci5wcm90b3R5cGUuX3Zpc2l0U3ViSW5zdHJ1Y3Rpb25zID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBpbnN0cnVjdGlvbnNcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcGFyYW0gez99IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChpbnN0cnVjdGlvbnMsIGNvbnRleHQsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3RhcnRUaW1lID0gY29udGV4dC5jdXJyZW50VGltZWxpbmUuY3VycmVudFRpbWU7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGZ1cnRoZXN0VGltZSA9IHN0YXJ0VGltZTtcbiAgICAgICAgLy8gdGhpcyBpcyBhIHNwZWNpYWwtY2FzZSBmb3Igd2hlbiBhIHVzZXIgd2FudHMgdG8gc2tpcCBhIHN1YlxuICAgICAgICAvLyBhbmltYXRpb24gZnJvbSBiZWluZyBmaXJlZCBlbnRpcmVseS5cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZHVyYXRpb24gPSBvcHRpb25zLmR1cmF0aW9uICE9IG51bGwgPyByZXNvbHZlVGltaW5nVmFsdWUob3B0aW9ucy5kdXJhdGlvbikgOiBudWxsO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkZWxheSA9IG9wdGlvbnMuZGVsYXkgIT0gbnVsbCA/IHJlc29sdmVUaW1pbmdWYWx1ZShvcHRpb25zLmRlbGF5KSA6IG51bGw7XG4gICAgICAgIGlmIChkdXJhdGlvbiAhPT0gMCkge1xuICAgICAgICAgICAgaW5zdHJ1Y3Rpb25zLmZvckVhY2goZnVuY3Rpb24gKGluc3RydWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaW5zdHJ1Y3Rpb25UaW1pbmdzID0gY29udGV4dC5hcHBlbmRJbnN0cnVjdGlvblRvVGltZWxpbmUoaW5zdHJ1Y3Rpb24sIGR1cmF0aW9uLCBkZWxheSk7XG4gICAgICAgICAgICAgICAgZnVydGhlc3RUaW1lID1cbiAgICAgICAgICAgICAgICAgICAgTWF0aC5tYXgoZnVydGhlc3RUaW1lLCBpbnN0cnVjdGlvblRpbWluZ3MuZHVyYXRpb24gKyBpbnN0cnVjdGlvblRpbWluZ3MuZGVsYXkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZ1cnRoZXN0VGltZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBbmltYXRpb25UaW1lbGluZUJ1aWxkZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdFJlZmVyZW5jZSA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIGNvbnRleHQudXBkYXRlT3B0aW9ucyhhc3Qub3B0aW9ucywgdHJ1ZSk7XG4gICAgICAgIGFzdC5hbmltYXRpb24udmlzaXQodGhpcywgY29udGV4dCk7XG4gICAgICAgIGNvbnRleHQucHJldmlvdXNOb2RlID0gYXN0O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFuaW1hdGlvblRpbWVsaW5lQnVpbGRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0U2VxdWVuY2UgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdWJDb250ZXh0Q291bnQgPSBjb250ZXh0LnN1YkNvbnRleHRDb3VudDtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY3R4ID0gY29udGV4dDtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gb3B0aW9ucyA9IGFzdC5vcHRpb25zO1xuICAgICAgICBpZiAob3B0aW9ucyAmJiAob3B0aW9ucy5wYXJhbXMgfHwgb3B0aW9ucy5kZWxheSkpIHtcbiAgICAgICAgICAgIGN0eCA9IGNvbnRleHQuY3JlYXRlU3ViQ29udGV4dChvcHRpb25zKTtcbiAgICAgICAgICAgIGN0eC50cmFuc2Zvcm1JbnRvTmV3VGltZWxpbmUoKTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmRlbGF5ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAoY3R4LnByZXZpb3VzTm9kZSBpbnN0YW5jZW9mIFN0eWxlQXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5jdXJyZW50VGltZWxpbmUuc25hcHNob3RDdXJyZW50U3R5bGVzKCk7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5wcmV2aW91c05vZGUgPSBERUZBVUxUX05PT1BfUFJFVklPVVNfTk9ERTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZGVsYXkgPSByZXNvbHZlVGltaW5nVmFsdWUob3B0aW9ucy5kZWxheSk7XG4gICAgICAgICAgICAgICAgY3R4LmRlbGF5TmV4dFN0ZXAoZGVsYXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChhc3Quc3RlcHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBhc3Quc3RlcHMuZm9yRWFjaChmdW5jdGlvbiAocykgeyByZXR1cm4gcy52aXNpdChfdGhpcywgY3R4KTsgfSk7XG4gICAgICAgICAgICAvLyB0aGlzIGlzIGhlcmUganVzdCBpbmNhc2UgdGhlIGlubmVyIHN0ZXBzIG9ubHkgY29udGFpbiBvciBlbmQgd2l0aCBhIHN0eWxlKCkgY2FsbFxuICAgICAgICAgICAgY3R4LmN1cnJlbnRUaW1lbGluZS5hcHBseVN0eWxlc1RvS2V5ZnJhbWUoKTtcbiAgICAgICAgICAgIC8vIHRoaXMgbWVhbnMgdGhhdCBzb21lIGFuaW1hdGlvbiBmdW5jdGlvbiB3aXRoaW4gdGhlIHNlcXVlbmNlXG4gICAgICAgICAgICAvLyBlbmRlZCB1cCBjcmVhdGluZyBhIHN1YiB0aW1lbGluZSAod2hpY2ggbWVhbnMgdGhlIGN1cnJlbnRcbiAgICAgICAgICAgIC8vIHRpbWVsaW5lIGNhbm5vdCBvdmVybGFwIHdpdGggdGhlIGNvbnRlbnRzIG9mIHRoZSBzZXF1ZW5jZSlcbiAgICAgICAgICAgIGlmIChjdHguc3ViQ29udGV4dENvdW50ID4gc3ViQ29udGV4dENvdW50KSB7XG4gICAgICAgICAgICAgICAgY3R4LnRyYW5zZm9ybUludG9OZXdUaW1lbGluZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnRleHQucHJldmlvdXNOb2RlID0gYXN0O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFuaW1hdGlvblRpbWVsaW5lQnVpbGRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0R3JvdXAgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpbm5lclRpbWVsaW5lcyA9IFtdO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBmdXJ0aGVzdFRpbWUgPSBjb250ZXh0LmN1cnJlbnRUaW1lbGluZS5jdXJyZW50VGltZTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZGVsYXkgPSBhc3Qub3B0aW9ucyAmJiBhc3Qub3B0aW9ucy5kZWxheSA/IHJlc29sdmVUaW1pbmdWYWx1ZShhc3Qub3B0aW9ucy5kZWxheSkgOiAwO1xuICAgICAgICBhc3Quc3RlcHMuZm9yRWFjaChmdW5jdGlvbiAocykge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaW5uZXJDb250ZXh0ID0gY29udGV4dC5jcmVhdGVTdWJDb250ZXh0KGFzdC5vcHRpb25zKTtcbiAgICAgICAgICAgIGlmIChkZWxheSkge1xuICAgICAgICAgICAgICAgIGlubmVyQ29udGV4dC5kZWxheU5leHRTdGVwKGRlbGF5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHMudmlzaXQoX3RoaXMsIGlubmVyQ29udGV4dCk7XG4gICAgICAgICAgICBmdXJ0aGVzdFRpbWUgPSBNYXRoLm1heChmdXJ0aGVzdFRpbWUsIGlubmVyQ29udGV4dC5jdXJyZW50VGltZWxpbmUuY3VycmVudFRpbWUpO1xuICAgICAgICAgICAgaW5uZXJUaW1lbGluZXMucHVzaChpbm5lckNvbnRleHQuY3VycmVudFRpbWVsaW5lKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIHRoaXMgb3BlcmF0aW9uIGlzIHJ1biBhZnRlciB0aGUgQVNUIGxvb3AgYmVjYXVzZSBvdGhlcndpc2VcbiAgICAgICAgLy8gaWYgdGhlIHBhcmVudCB0aW1lbGluZSdzIGNvbGxlY3RlZCBzdHlsZXMgd2VyZSB1cGRhdGVkIHRoZW5cbiAgICAgICAgLy8gaXQgd291bGQgcGFzcyBpbiBpbnZhbGlkIGRhdGEgaW50byB0aGUgbmV3LXRvLWJlIGZvcmtlZCBpdGVtc1xuICAgICAgICBpbm5lclRpbWVsaW5lcy5mb3JFYWNoKGZ1bmN0aW9uICh0aW1lbGluZSkgeyByZXR1cm4gY29udGV4dC5jdXJyZW50VGltZWxpbmUubWVyZ2VUaW1lbGluZUNvbGxlY3RlZFN0eWxlcyh0aW1lbGluZSk7IH0pO1xuICAgICAgICBjb250ZXh0LnRyYW5zZm9ybUludG9OZXdUaW1lbGluZShmdXJ0aGVzdFRpbWUpO1xuICAgICAgICBjb250ZXh0LnByZXZpb3VzTm9kZSA9IGFzdDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBbmltYXRpb25UaW1lbGluZUJ1aWxkZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdFRpbWluZyA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIGlmIChhc3QgaW5zdGFuY2VvZiBEeW5hbWljVGltaW5nQXN0KSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdHJWYWx1ZSA9IGNvbnRleHQucGFyYW1zID9cbiAgICAgICAgICAgICAgICBpbnRlcnBvbGF0ZVBhcmFtcyhhc3QudmFsdWUsIGNvbnRleHQucGFyYW1zLCBjb250ZXh0LmVycm9ycykgOlxuICAgICAgICAgICAgICAgIGFzdC52YWx1ZS50b1N0cmluZygpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc29sdmVUaW1pbmcoc3RyVmFsdWUsIGNvbnRleHQuZXJyb3JzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB7IGR1cmF0aW9uOiBhc3QuZHVyYXRpb24sIGRlbGF5OiBhc3QuZGVsYXksIGVhc2luZzogYXN0LmVhc2luZyB9O1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQW5pbWF0aW9uVGltZWxpbmVCdWlsZGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRBbmltYXRlID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdGltaW5ncyA9IGNvbnRleHQuY3VycmVudEFuaW1hdGVUaW1pbmdzID0gdGhpcy52aXNpdFRpbWluZyhhc3QudGltaW5ncywgY29udGV4dCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRpbWVsaW5lID0gY29udGV4dC5jdXJyZW50VGltZWxpbmU7XG4gICAgICAgIGlmICh0aW1pbmdzLmRlbGF5KSB7XG4gICAgICAgICAgICBjb250ZXh0LmluY3JlbWVudFRpbWUodGltaW5ncy5kZWxheSk7XG4gICAgICAgICAgICB0aW1lbGluZS5zbmFwc2hvdEN1cnJlbnRTdHlsZXMoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdHlsZSQkMSA9IGFzdC5zdHlsZTtcbiAgICAgICAgaWYgKHN0eWxlJCQxIGluc3RhbmNlb2YgS2V5ZnJhbWVzQXN0KSB7XG4gICAgICAgICAgICB0aGlzLnZpc2l0S2V5ZnJhbWVzKHN0eWxlJCQxLCBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnRleHQuaW5jcmVtZW50VGltZSh0aW1pbmdzLmR1cmF0aW9uKTtcbiAgICAgICAgICAgIHRoaXMudmlzaXRTdHlsZSgvKiogQHR5cGUgez99ICovIChzdHlsZSQkMSksIGNvbnRleHQpO1xuICAgICAgICAgICAgdGltZWxpbmUuYXBwbHlTdHlsZXNUb0tleWZyYW1lKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29udGV4dC5jdXJyZW50QW5pbWF0ZVRpbWluZ3MgPSBudWxsO1xuICAgICAgICBjb250ZXh0LnByZXZpb3VzTm9kZSA9IGFzdDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBbmltYXRpb25UaW1lbGluZUJ1aWxkZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdFN0eWxlID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdGltZWxpbmUgPSBjb250ZXh0LmN1cnJlbnRUaW1lbGluZTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdGltaW5ncyA9IC8qKiBAdHlwZSB7P30gKi8gKChjb250ZXh0LmN1cnJlbnRBbmltYXRlVGltaW5ncykpO1xuICAgICAgICAvLyB0aGlzIGlzIGEgc3BlY2lhbCBjYXNlIGZvciB3aGVuIGEgc3R5bGUoKSBjYWxsXG4gICAgICAgIC8vIGRpcmVjdGx5IGZvbGxvd3MgIGFuIGFuaW1hdGUoKSBjYWxsIChidXQgbm90IGluc2lkZSBvZiBhbiBhbmltYXRlKCkgY2FsbClcbiAgICAgICAgaWYgKCF0aW1pbmdzICYmIHRpbWVsaW5lLmdldEN1cnJlbnRTdHlsZVByb3BlcnRpZXMoKS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRpbWVsaW5lLmZvcndhcmRGcmFtZSgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVhc2luZyA9ICh0aW1pbmdzICYmIHRpbWluZ3MuZWFzaW5nKSB8fCBhc3QuZWFzaW5nO1xuICAgICAgICBpZiAoYXN0LmlzRW1wdHlTdGVwKSB7XG4gICAgICAgICAgICB0aW1lbGluZS5hcHBseUVtcHR5U3RlcChlYXNpbmcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGltZWxpbmUuc2V0U3R5bGVzKGFzdC5zdHlsZXMsIGVhc2luZywgY29udGV4dC5lcnJvcnMsIGNvbnRleHQub3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgY29udGV4dC5wcmV2aW91c05vZGUgPSBhc3Q7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQW5pbWF0aW9uVGltZWxpbmVCdWlsZGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRLZXlmcmFtZXMgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjdXJyZW50QW5pbWF0ZVRpbWluZ3MgPSAvKiogQHR5cGUgez99ICovICgoY29udGV4dC5jdXJyZW50QW5pbWF0ZVRpbWluZ3MpKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3RhcnRUaW1lID0gKC8qKiBAdHlwZSB7P30gKi8gKChjb250ZXh0LmN1cnJlbnRUaW1lbGluZSkpKS5kdXJhdGlvbjtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZHVyYXRpb24gPSBjdXJyZW50QW5pbWF0ZVRpbWluZ3MuZHVyYXRpb247XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGlubmVyQ29udGV4dCA9IGNvbnRleHQuY3JlYXRlU3ViQ29udGV4dCgpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpbm5lclRpbWVsaW5lID0gaW5uZXJDb250ZXh0LmN1cnJlbnRUaW1lbGluZTtcbiAgICAgICAgaW5uZXJUaW1lbGluZS5lYXNpbmcgPSBjdXJyZW50QW5pbWF0ZVRpbWluZ3MuZWFzaW5nO1xuICAgICAgICBhc3Quc3R5bGVzLmZvckVhY2goZnVuY3Rpb24gKHN0ZXApIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG9mZnNldCA9IHN0ZXAub2Zmc2V0IHx8IDA7XG4gICAgICAgICAgICBpbm5lclRpbWVsaW5lLmZvcndhcmRUaW1lKG9mZnNldCAqIGR1cmF0aW9uKTtcbiAgICAgICAgICAgIGlubmVyVGltZWxpbmUuc2V0U3R5bGVzKHN0ZXAuc3R5bGVzLCBzdGVwLmVhc2luZywgY29udGV4dC5lcnJvcnMsIGNvbnRleHQub3B0aW9ucyk7XG4gICAgICAgICAgICBpbm5lclRpbWVsaW5lLmFwcGx5U3R5bGVzVG9LZXlmcmFtZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gdGhpcyB3aWxsIGVuc3VyZSB0aGF0IHRoZSBwYXJlbnQgdGltZWxpbmUgZ2V0cyBhbGwgdGhlIHN0eWxlcyBmcm9tXG4gICAgICAgIC8vIHRoZSBjaGlsZCBldmVuIGlmIHRoZSBuZXcgdGltZWxpbmUgYmVsb3cgaXMgbm90IHVzZWRcbiAgICAgICAgY29udGV4dC5jdXJyZW50VGltZWxpbmUubWVyZ2VUaW1lbGluZUNvbGxlY3RlZFN0eWxlcyhpbm5lclRpbWVsaW5lKTtcbiAgICAgICAgLy8gd2UgZG8gdGhpcyBiZWNhdXNlIHRoZSB3aW5kb3cgYmV0d2VlbiB0aGlzIHRpbWVsaW5lIGFuZCB0aGUgc3ViIHRpbWVsaW5lXG4gICAgICAgIC8vIHNob3VsZCBlbnN1cmUgdGhhdCB0aGUgc3R5bGVzIHdpdGhpbiBhcmUgZXhhY3RseSB0aGUgc2FtZSBhcyB0aGV5IHdlcmUgYmVmb3JlXG4gICAgICAgIGNvbnRleHQudHJhbnNmb3JtSW50b05ld1RpbWVsaW5lKHN0YXJ0VGltZSArIGR1cmF0aW9uKTtcbiAgICAgICAgY29udGV4dC5wcmV2aW91c05vZGUgPSBhc3Q7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQW5pbWF0aW9uVGltZWxpbmVCdWlsZGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRRdWVyeSA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIC8vIGluIHRoZSBldmVudCB0aGF0IHRoZSBmaXJzdCBzdGVwIGJlZm9yZSB0aGlzIGlzIGEgc3R5bGUgc3RlcCB3ZSBuZWVkXG4gICAgICAgIC8vIHRvIGVuc3VyZSB0aGUgc3R5bGVzIGFyZSBhcHBsaWVkIGJlZm9yZSB0aGUgY2hpbGRyZW4gYXJlIGFuaW1hdGVkXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0YXJ0VGltZSA9IGNvbnRleHQuY3VycmVudFRpbWVsaW5lLmN1cnJlbnRUaW1lO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBvcHRpb25zID0gLyoqIEB0eXBlIHs/fSAqLyAoKGFzdC5vcHRpb25zIHx8IHt9KSk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGRlbGF5ID0gb3B0aW9ucy5kZWxheSA/IHJlc29sdmVUaW1pbmdWYWx1ZShvcHRpb25zLmRlbGF5KSA6IDA7XG4gICAgICAgIGlmIChkZWxheSAmJiAoY29udGV4dC5wcmV2aW91c05vZGUgaW5zdGFuY2VvZiBTdHlsZUFzdCB8fFxuICAgICAgICAgICAgKHN0YXJ0VGltZSA9PSAwICYmIGNvbnRleHQuY3VycmVudFRpbWVsaW5lLmdldEN1cnJlbnRTdHlsZVByb3BlcnRpZXMoKS5sZW5ndGgpKSkge1xuICAgICAgICAgICAgY29udGV4dC5jdXJyZW50VGltZWxpbmUuc25hcHNob3RDdXJyZW50U3R5bGVzKCk7XG4gICAgICAgICAgICBjb250ZXh0LnByZXZpb3VzTm9kZSA9IERFRkFVTFRfTk9PUF9QUkVWSU9VU19OT0RFO1xuICAgICAgICB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGZ1cnRoZXN0VGltZSA9IHN0YXJ0VGltZTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZWxtcyA9IGNvbnRleHQuaW52b2tlUXVlcnkoYXN0LnNlbGVjdG9yLCBhc3Qub3JpZ2luYWxTZWxlY3RvciwgYXN0LmxpbWl0LCBhc3QuaW5jbHVkZVNlbGYsIG9wdGlvbnMub3B0aW9uYWwgPyB0cnVlIDogZmFsc2UsIGNvbnRleHQuZXJyb3JzKTtcbiAgICAgICAgY29udGV4dC5jdXJyZW50UXVlcnlUb3RhbCA9IGVsbXMubGVuZ3RoO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzYW1lRWxlbWVudFRpbWVsaW5lID0gbnVsbDtcbiAgICAgICAgZWxtcy5mb3JFYWNoKGZ1bmN0aW9uIChlbGVtZW50LCBpKSB7XG4gICAgICAgICAgICBjb250ZXh0LmN1cnJlbnRRdWVyeUluZGV4ID0gaTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGlubmVyQ29udGV4dCA9IGNvbnRleHQuY3JlYXRlU3ViQ29udGV4dChhc3Qub3B0aW9ucywgZWxlbWVudCk7XG4gICAgICAgICAgICBpZiAoZGVsYXkpIHtcbiAgICAgICAgICAgICAgICBpbm5lckNvbnRleHQuZGVsYXlOZXh0U3RlcChkZWxheSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZWxlbWVudCA9PT0gY29udGV4dC5lbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgc2FtZUVsZW1lbnRUaW1lbGluZSA9IGlubmVyQ29udGV4dC5jdXJyZW50VGltZWxpbmU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhc3QuYW5pbWF0aW9uLnZpc2l0KF90aGlzLCBpbm5lckNvbnRleHQpO1xuICAgICAgICAgICAgLy8gdGhpcyBpcyBoZXJlIGp1c3QgaW5jYXNlIHRoZSBpbm5lciBzdGVwcyBvbmx5IGNvbnRhaW4gb3IgZW5kXG4gICAgICAgICAgICAvLyB3aXRoIGEgc3R5bGUoKSBjYWxsICh3aGljaCBpcyBoZXJlIHRvIHNpZ25hbCB0aGF0IHRoaXMgaXMgYSBwcmVwYXJhdG9yeVxuICAgICAgICAgICAgLy8gY2FsbCB0byBzdHlsZSBhbiBlbGVtZW50IGJlZm9yZSBpdCBpcyBhbmltYXRlZCBhZ2FpbilcbiAgICAgICAgICAgIGlubmVyQ29udGV4dC5jdXJyZW50VGltZWxpbmUuYXBwbHlTdHlsZXNUb0tleWZyYW1lKCk7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlbmRUaW1lID0gaW5uZXJDb250ZXh0LmN1cnJlbnRUaW1lbGluZS5jdXJyZW50VGltZTtcbiAgICAgICAgICAgIGZ1cnRoZXN0VGltZSA9IE1hdGgubWF4KGZ1cnRoZXN0VGltZSwgZW5kVGltZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBjb250ZXh0LmN1cnJlbnRRdWVyeUluZGV4ID0gMDtcbiAgICAgICAgY29udGV4dC5jdXJyZW50UXVlcnlUb3RhbCA9IDA7XG4gICAgICAgIGNvbnRleHQudHJhbnNmb3JtSW50b05ld1RpbWVsaW5lKGZ1cnRoZXN0VGltZSk7XG4gICAgICAgIGlmIChzYW1lRWxlbWVudFRpbWVsaW5lKSB7XG4gICAgICAgICAgICBjb250ZXh0LmN1cnJlbnRUaW1lbGluZS5tZXJnZVRpbWVsaW5lQ29sbGVjdGVkU3R5bGVzKHNhbWVFbGVtZW50VGltZWxpbmUpO1xuICAgICAgICAgICAgY29udGV4dC5jdXJyZW50VGltZWxpbmUuc25hcHNob3RDdXJyZW50U3R5bGVzKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29udGV4dC5wcmV2aW91c05vZGUgPSBhc3Q7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQW5pbWF0aW9uVGltZWxpbmVCdWlsZGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRTdGFnZ2VyID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGFyZW50Q29udGV4dCA9IC8qKiBAdHlwZSB7P30gKi8gKChjb250ZXh0LnBhcmVudENvbnRleHQpKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdGwgPSBjb250ZXh0LmN1cnJlbnRUaW1lbGluZTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdGltaW5ncyA9IGFzdC50aW1pbmdzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkdXJhdGlvbiA9IE1hdGguYWJzKHRpbWluZ3MuZHVyYXRpb24pO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBtYXhUaW1lID0gZHVyYXRpb24gKiAoY29udGV4dC5jdXJyZW50UXVlcnlUb3RhbCAtIDEpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkZWxheSA9IGR1cmF0aW9uICogY29udGV4dC5jdXJyZW50UXVlcnlJbmRleDtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3RhZ2dlclRyYW5zZm9ybWVyID0gdGltaW5ncy5kdXJhdGlvbiA8IDAgPyAncmV2ZXJzZScgOiB0aW1pbmdzLmVhc2luZztcbiAgICAgICAgc3dpdGNoIChzdGFnZ2VyVHJhbnNmb3JtZXIpIHtcbiAgICAgICAgICAgIGNhc2UgJ3JldmVyc2UnOlxuICAgICAgICAgICAgICAgIGRlbGF5ID0gbWF4VGltZSAtIGRlbGF5O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnZnVsbCc6XG4gICAgICAgICAgICAgICAgZGVsYXkgPSBwYXJlbnRDb250ZXh0LmN1cnJlbnRTdGFnZ2VyVGltZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0aW1lbGluZSA9IGNvbnRleHQuY3VycmVudFRpbWVsaW5lO1xuICAgICAgICBpZiAoZGVsYXkpIHtcbiAgICAgICAgICAgIHRpbWVsaW5lLmRlbGF5TmV4dFN0ZXAoZGVsYXkpO1xuICAgICAgICB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0YXJ0aW5nVGltZSA9IHRpbWVsaW5lLmN1cnJlbnRUaW1lO1xuICAgICAgICBhc3QuYW5pbWF0aW9uLnZpc2l0KHRoaXMsIGNvbnRleHQpO1xuICAgICAgICBjb250ZXh0LnByZXZpb3VzTm9kZSA9IGFzdDtcbiAgICAgICAgLy8gdGltZSA9IGR1cmF0aW9uICsgZGVsYXlcbiAgICAgICAgLy8gdGhlIHJlYXNvbiB3aHkgdGhpcyBjb21wdXRhdGlvbiBpcyBzbyBjb21wbGV4IGlzIGJlY2F1c2VcbiAgICAgICAgLy8gdGhlIGlubmVyIHRpbWVsaW5lIG1heSBlaXRoZXIgaGF2ZSBhIGRlbGF5IHZhbHVlIG9yIGEgc3RyZXRjaGVkXG4gICAgICAgIC8vIGtleWZyYW1lIGRlcGVuZGluZyBvbiBpZiBhIHN1YnRpbWVsaW5lIGlzIG5vdCB1c2VkIG9yIGlzIHVzZWQuXG4gICAgICAgIHBhcmVudENvbnRleHQuY3VycmVudFN0YWdnZXJUaW1lID1cbiAgICAgICAgICAgICh0bC5jdXJyZW50VGltZSAtIHN0YXJ0aW5nVGltZSkgKyAodGwuc3RhcnRUaW1lIC0gcGFyZW50Q29udGV4dC5jdXJyZW50VGltZWxpbmUuc3RhcnRUaW1lKTtcbiAgICB9O1xuICAgIHJldHVybiBBbmltYXRpb25UaW1lbGluZUJ1aWxkZXJWaXNpdG9yO1xufSgpKTtcbnZhciBERUZBVUxUX05PT1BfUFJFVklPVVNfTk9ERSA9IC8qKiBAdHlwZSB7P30gKi8gKHt9KTtcbnZhciBBbmltYXRpb25UaW1lbGluZUNvbnRleHQgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEFuaW1hdGlvblRpbWVsaW5lQ29udGV4dChfZHJpdmVyLCBlbGVtZW50LCBzdWJJbnN0cnVjdGlvbnMsIGVycm9ycywgdGltZWxpbmVzLCBpbml0aWFsVGltZWxpbmUpIHtcbiAgICAgICAgdGhpcy5fZHJpdmVyID0gX2RyaXZlcjtcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgICAgICAgdGhpcy5zdWJJbnN0cnVjdGlvbnMgPSBzdWJJbnN0cnVjdGlvbnM7XG4gICAgICAgIHRoaXMuZXJyb3JzID0gZXJyb3JzO1xuICAgICAgICB0aGlzLnRpbWVsaW5lcyA9IHRpbWVsaW5lcztcbiAgICAgICAgdGhpcy5wYXJlbnRDb250ZXh0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5jdXJyZW50QW5pbWF0ZVRpbWluZ3MgPSBudWxsO1xuICAgICAgICB0aGlzLnByZXZpb3VzTm9kZSA9IERFRkFVTFRfTk9PUF9QUkVWSU9VU19OT0RFO1xuICAgICAgICB0aGlzLnN1YkNvbnRleHRDb3VudCA9IDA7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IHt9O1xuICAgICAgICB0aGlzLmN1cnJlbnRRdWVyeUluZGV4ID0gMDtcbiAgICAgICAgdGhpcy5jdXJyZW50UXVlcnlUb3RhbCA9IDA7XG4gICAgICAgIHRoaXMuY3VycmVudFN0YWdnZXJUaW1lID0gMDtcbiAgICAgICAgdGhpcy5jdXJyZW50VGltZWxpbmUgPSBpbml0aWFsVGltZWxpbmUgfHwgbmV3IFRpbWVsaW5lQnVpbGRlcih0aGlzLl9kcml2ZXIsIGVsZW1lbnQsIDApO1xuICAgICAgICB0aW1lbGluZXMucHVzaCh0aGlzLmN1cnJlbnRUaW1lbGluZSk7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBbmltYXRpb25UaW1lbGluZUNvbnRleHQucHJvdG90eXBlLCBcInBhcmFtc1wiLCB7XG4gICAgICAgIGdldDogLyoqXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLm9wdGlvbnMucGFyYW1zOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0gez89fSBza2lwSWZFeGlzdHNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFuaW1hdGlvblRpbWVsaW5lQ29udGV4dC5wcm90b3R5cGUudXBkYXRlT3B0aW9ucyA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7Pz19IHNraXBJZkV4aXN0c1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKG9wdGlvbnMsIHNraXBJZkV4aXN0cykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoIW9wdGlvbnMpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5ld09wdGlvbnMgPSAvKiogQHR5cGUgez99ICovIChvcHRpb25zKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gb3B0aW9uc1RvVXBkYXRlID0gdGhpcy5vcHRpb25zO1xuICAgICAgICAvLyBOT1RFOiB0aGlzIHdpbGwgZ2V0IHBhdGNoZWQgdXAgd2hlbiBvdGhlciBhbmltYXRpb24gbWV0aG9kcyBzdXBwb3J0IGR1cmF0aW9uIG92ZXJyaWRlc1xuICAgICAgICBpZiAobmV3T3B0aW9ucy5kdXJhdGlvbiAhPSBudWxsKSB7XG4gICAgICAgICAgICAoLyoqIEB0eXBlIHs/fSAqLyAob3B0aW9uc1RvVXBkYXRlKSkuZHVyYXRpb24gPSByZXNvbHZlVGltaW5nVmFsdWUobmV3T3B0aW9ucy5kdXJhdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5ld09wdGlvbnMuZGVsYXkgIT0gbnVsbCkge1xuICAgICAgICAgICAgb3B0aW9uc1RvVXBkYXRlLmRlbGF5ID0gcmVzb2x2ZVRpbWluZ1ZhbHVlKG5ld09wdGlvbnMuZGVsYXkpO1xuICAgICAgICB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5ld1BhcmFtcyA9IG5ld09wdGlvbnMucGFyYW1zO1xuICAgICAgICBpZiAobmV3UGFyYW1zKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwYXJhbXNUb1VwZGF0ZV8xID0gLyoqIEB0eXBlIHs/fSAqLyAoKG9wdGlvbnNUb1VwZGF0ZS5wYXJhbXMpKTtcbiAgICAgICAgICAgIGlmICghcGFyYW1zVG9VcGRhdGVfMSkge1xuICAgICAgICAgICAgICAgIHBhcmFtc1RvVXBkYXRlXzEgPSB0aGlzLm9wdGlvbnMucGFyYW1zID0ge307XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhuZXdQYXJhbXMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXNraXBJZkV4aXN0cyB8fCAhcGFyYW1zVG9VcGRhdGVfMS5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICBwYXJhbXNUb1VwZGF0ZV8xW25hbWVdID0gaW50ZXJwb2xhdGVQYXJhbXMobmV3UGFyYW1zW25hbWVdLCBwYXJhbXNUb1VwZGF0ZV8xLCBfdGhpcy5lcnJvcnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFuaW1hdGlvblRpbWVsaW5lQ29udGV4dC5wcm90b3R5cGUuX2NvcHlPcHRpb25zID0gLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucykge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gb2xkUGFyYW1zXzEgPSB0aGlzLm9wdGlvbnMucGFyYW1zO1xuICAgICAgICAgICAgaWYgKG9sZFBhcmFtc18xKSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGFyYW1zXzEgPSBvcHRpb25zWydwYXJhbXMnXSA9IHt9O1xuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKHRoaXMub3B0aW9ucy5wYXJhbXMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHsgcGFyYW1zXzFbbmFtZV0gPSBvbGRQYXJhbXNfMVtuYW1lXTsgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez89fSBvcHRpb25zXG4gICAgICogQHBhcmFtIHs/PX0gZWxlbWVudFxuICAgICAqIEBwYXJhbSB7Pz19IG5ld1RpbWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFuaW1hdGlvblRpbWVsaW5lQ29udGV4dC5wcm90b3R5cGUuY3JlYXRlU3ViQ29udGV4dCA9IC8qKlxuICAgICAqIEBwYXJhbSB7Pz19IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0gez89fSBlbGVtZW50XG4gICAgICogQHBhcmFtIHs/PX0gbmV3VGltZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKG9wdGlvbnMsIGVsZW1lbnQsIG5ld1RpbWUpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0gbnVsbDsgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0YXJnZXQgPSBlbGVtZW50IHx8IHRoaXMuZWxlbWVudDtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY29udGV4dCA9IG5ldyBBbmltYXRpb25UaW1lbGluZUNvbnRleHQodGhpcy5fZHJpdmVyLCB0YXJnZXQsIHRoaXMuc3ViSW5zdHJ1Y3Rpb25zLCB0aGlzLmVycm9ycywgdGhpcy50aW1lbGluZXMsIHRoaXMuY3VycmVudFRpbWVsaW5lLmZvcmsodGFyZ2V0LCBuZXdUaW1lIHx8IDApKTtcbiAgICAgICAgY29udGV4dC5wcmV2aW91c05vZGUgPSB0aGlzLnByZXZpb3VzTm9kZTtcbiAgICAgICAgY29udGV4dC5jdXJyZW50QW5pbWF0ZVRpbWluZ3MgPSB0aGlzLmN1cnJlbnRBbmltYXRlVGltaW5ncztcbiAgICAgICAgY29udGV4dC5vcHRpb25zID0gdGhpcy5fY29weU9wdGlvbnMoKTtcbiAgICAgICAgY29udGV4dC51cGRhdGVPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgICBjb250ZXh0LmN1cnJlbnRRdWVyeUluZGV4ID0gdGhpcy5jdXJyZW50UXVlcnlJbmRleDtcbiAgICAgICAgY29udGV4dC5jdXJyZW50UXVlcnlUb3RhbCA9IHRoaXMuY3VycmVudFF1ZXJ5VG90YWw7XG4gICAgICAgIGNvbnRleHQucGFyZW50Q29udGV4dCA9IHRoaXM7XG4gICAgICAgIHRoaXMuc3ViQ29udGV4dENvdW50Kys7XG4gICAgICAgIHJldHVybiBjb250ZXh0O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/PX0gbmV3VGltZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQW5pbWF0aW9uVGltZWxpbmVDb250ZXh0LnByb3RvdHlwZS50cmFuc2Zvcm1JbnRvTmV3VGltZWxpbmUgPSAvKipcbiAgICAgKiBAcGFyYW0gez89fSBuZXdUaW1lXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAobmV3VGltZSkge1xuICAgICAgICB0aGlzLnByZXZpb3VzTm9kZSA9IERFRkFVTFRfTk9PUF9QUkVWSU9VU19OT0RFO1xuICAgICAgICB0aGlzLmN1cnJlbnRUaW1lbGluZSA9IHRoaXMuY3VycmVudFRpbWVsaW5lLmZvcmsodGhpcy5lbGVtZW50LCBuZXdUaW1lKTtcbiAgICAgICAgdGhpcy50aW1lbGluZXMucHVzaCh0aGlzLmN1cnJlbnRUaW1lbGluZSk7XG4gICAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRUaW1lbGluZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gaW5zdHJ1Y3Rpb25cbiAgICAgKiBAcGFyYW0gez99IGR1cmF0aW9uXG4gICAgICogQHBhcmFtIHs/fSBkZWxheVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQW5pbWF0aW9uVGltZWxpbmVDb250ZXh0LnByb3RvdHlwZS5hcHBlbmRJbnN0cnVjdGlvblRvVGltZWxpbmUgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IGluc3RydWN0aW9uXG4gICAgICogQHBhcmFtIHs/fSBkdXJhdGlvblxuICAgICAqIEBwYXJhbSB7P30gZGVsYXlcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChpbnN0cnVjdGlvbiwgZHVyYXRpb24sIGRlbGF5KSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHVwZGF0ZWRUaW1pbmdzID0ge1xuICAgICAgICAgICAgZHVyYXRpb246IGR1cmF0aW9uICE9IG51bGwgPyBkdXJhdGlvbiA6IGluc3RydWN0aW9uLmR1cmF0aW9uLFxuICAgICAgICAgICAgZGVsYXk6IHRoaXMuY3VycmVudFRpbWVsaW5lLmN1cnJlbnRUaW1lICsgKGRlbGF5ICE9IG51bGwgPyBkZWxheSA6IDApICsgaW5zdHJ1Y3Rpb24uZGVsYXksXG4gICAgICAgICAgICBlYXNpbmc6ICcnXG4gICAgICAgIH07XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGJ1aWxkZXIgPSBuZXcgU3ViVGltZWxpbmVCdWlsZGVyKHRoaXMuX2RyaXZlciwgaW5zdHJ1Y3Rpb24uZWxlbWVudCwgaW5zdHJ1Y3Rpb24ua2V5ZnJhbWVzLCBpbnN0cnVjdGlvbi5wcmVTdHlsZVByb3BzLCBpbnN0cnVjdGlvbi5wb3N0U3R5bGVQcm9wcywgdXBkYXRlZFRpbWluZ3MsIGluc3RydWN0aW9uLnN0cmV0Y2hTdGFydGluZ0tleWZyYW1lKTtcbiAgICAgICAgdGhpcy50aW1lbGluZXMucHVzaChidWlsZGVyKTtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZWRUaW1pbmdzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB0aW1lXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBbmltYXRpb25UaW1lbGluZUNvbnRleHQucHJvdG90eXBlLmluY3JlbWVudFRpbWUgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IHRpbWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uICh0aW1lKSB7XG4gICAgICAgIHRoaXMuY3VycmVudFRpbWVsaW5lLmZvcndhcmRUaW1lKHRoaXMuY3VycmVudFRpbWVsaW5lLmR1cmF0aW9uICsgdGltZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGRlbGF5XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBbmltYXRpb25UaW1lbGluZUNvbnRleHQucHJvdG90eXBlLmRlbGF5TmV4dFN0ZXAgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IGRlbGF5XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoZGVsYXkpIHtcbiAgICAgICAgLy8gbmVnYXRpdmUgZGVsYXlzIGFyZSBub3QgeWV0IHN1cHBvcnRlZFxuICAgICAgICBpZiAoZGVsYXkgPiAwKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRUaW1lbGluZS5kZWxheU5leHRTdGVwKGRlbGF5KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzZWxlY3RvclxuICAgICAqIEBwYXJhbSB7P30gb3JpZ2luYWxTZWxlY3RvclxuICAgICAqIEBwYXJhbSB7P30gbGltaXRcbiAgICAgKiBAcGFyYW0gez99IGluY2x1ZGVTZWxmXG4gICAgICogQHBhcmFtIHs/fSBvcHRpb25hbFxuICAgICAqIEBwYXJhbSB7P30gZXJyb3JzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBbmltYXRpb25UaW1lbGluZUNvbnRleHQucHJvdG90eXBlLmludm9rZVF1ZXJ5ID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBzZWxlY3RvclxuICAgICAqIEBwYXJhbSB7P30gb3JpZ2luYWxTZWxlY3RvclxuICAgICAqIEBwYXJhbSB7P30gbGltaXRcbiAgICAgKiBAcGFyYW0gez99IGluY2x1ZGVTZWxmXG4gICAgICogQHBhcmFtIHs/fSBvcHRpb25hbFxuICAgICAqIEBwYXJhbSB7P30gZXJyb3JzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoc2VsZWN0b3IsIG9yaWdpbmFsU2VsZWN0b3IsIGxpbWl0LCBpbmNsdWRlU2VsZiwgb3B0aW9uYWwsIGVycm9ycykge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZXN1bHRzID0gW107XG4gICAgICAgIGlmIChpbmNsdWRlU2VsZikge1xuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHRoaXMuZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlbGVjdG9yLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIC8vIGlmIDpzZWxmIGlzIG9ubHkgdXNlZCB0aGVuIHRoZSBzZWxlY3RvciBpcyBlbXB0eVxuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbXVsdGkgPSBsaW1pdCAhPSAxO1xuICAgICAgICAgICAgcmVzdWx0cy5wdXNoLmFwcGx5KHJlc3VsdHMsIHRoaXMuX2RyaXZlci5xdWVyeSh0aGlzLmVsZW1lbnQsIHNlbGVjdG9yLCBtdWx0aSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghb3B0aW9uYWwgJiYgcmVzdWx0cy5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgZXJyb3JzLnB1c2goXCJgcXVlcnkoXFxcIlwiICsgb3JpZ2luYWxTZWxlY3RvciArIFwiXFxcIilgIHJldHVybmVkIHplcm8gZWxlbWVudHMuIChVc2UgYHF1ZXJ5KFxcXCJcIiArIG9yaWdpbmFsU2VsZWN0b3IgKyBcIlxcXCIsIHsgb3B0aW9uYWw6IHRydWUgfSlgIGlmIHlvdSB3aXNoIHRvIGFsbG93IHRoaXMuKVwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9O1xuICAgIHJldHVybiBBbmltYXRpb25UaW1lbGluZUNvbnRleHQ7XG59KCkpO1xudmFyIFRpbWVsaW5lQnVpbGRlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVGltZWxpbmVCdWlsZGVyKF9kcml2ZXIsIGVsZW1lbnQsIHN0YXJ0VGltZSwgX2VsZW1lbnRUaW1lbGluZVN0eWxlc0xvb2t1cCkge1xuICAgICAgICB0aGlzLl9kcml2ZXIgPSBfZHJpdmVyO1xuICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgICB0aGlzLnN0YXJ0VGltZSA9IHN0YXJ0VGltZTtcbiAgICAgICAgdGhpcy5fZWxlbWVudFRpbWVsaW5lU3R5bGVzTG9va3VwID0gX2VsZW1lbnRUaW1lbGluZVN0eWxlc0xvb2t1cDtcbiAgICAgICAgdGhpcy5kdXJhdGlvbiA9IDA7XG4gICAgICAgIHRoaXMuX3ByZXZpb3VzS2V5ZnJhbWUgPSB7fTtcbiAgICAgICAgdGhpcy5fY3VycmVudEtleWZyYW1lID0ge307XG4gICAgICAgIHRoaXMuX2tleWZyYW1lcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fc3R5bGVTdW1tYXJ5ID0ge307XG4gICAgICAgIHRoaXMuX3BlbmRpbmdTdHlsZXMgPSB7fTtcbiAgICAgICAgdGhpcy5fYmFja0ZpbGwgPSB7fTtcbiAgICAgICAgdGhpcy5fY3VycmVudEVtcHR5U3RlcEtleWZyYW1lID0gbnVsbDtcbiAgICAgICAgaWYgKCF0aGlzLl9lbGVtZW50VGltZWxpbmVTdHlsZXNMb29rdXApIHtcbiAgICAgICAgICAgIHRoaXMuX2VsZW1lbnRUaW1lbGluZVN0eWxlc0xvb2t1cCA9IG5ldyBNYXAoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9sb2NhbFRpbWVsaW5lU3R5bGVzID0gT2JqZWN0LmNyZWF0ZSh0aGlzLl9iYWNrRmlsbCwge30pO1xuICAgICAgICB0aGlzLl9nbG9iYWxUaW1lbGluZVN0eWxlcyA9IC8qKiBAdHlwZSB7P30gKi8gKCh0aGlzLl9lbGVtZW50VGltZWxpbmVTdHlsZXNMb29rdXAuZ2V0KGVsZW1lbnQpKSk7XG4gICAgICAgIGlmICghdGhpcy5fZ2xvYmFsVGltZWxpbmVTdHlsZXMpIHtcbiAgICAgICAgICAgIHRoaXMuX2dsb2JhbFRpbWVsaW5lU3R5bGVzID0gdGhpcy5fbG9jYWxUaW1lbGluZVN0eWxlcztcbiAgICAgICAgICAgIHRoaXMuX2VsZW1lbnRUaW1lbGluZVN0eWxlc0xvb2t1cC5zZXQoZWxlbWVudCwgdGhpcy5fbG9jYWxUaW1lbGluZVN0eWxlcyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbG9hZEtleWZyYW1lKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVGltZWxpbmVCdWlsZGVyLnByb3RvdHlwZS5jb250YWluc0FuaW1hdGlvbiA9IC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKCkge1xuICAgICAgICBzd2l0Y2ggKHRoaXMuX2tleWZyYW1lcy5zaXplKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEN1cnJlbnRTdHlsZVByb3BlcnRpZXMoKS5sZW5ndGggPiAwO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUaW1lbGluZUJ1aWxkZXIucHJvdG90eXBlLmdldEN1cnJlbnRTdHlsZVByb3BlcnRpZXMgPSAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uICgpIHsgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuX2N1cnJlbnRLZXlmcmFtZSk7IH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRpbWVsaW5lQnVpbGRlci5wcm90b3R5cGUsIFwiY3VycmVudFRpbWVcIiwge1xuICAgICAgICBnZXQ6IC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5zdGFydFRpbWUgKyB0aGlzLmR1cmF0aW9uOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGRlbGF5XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUaW1lbGluZUJ1aWxkZXIucHJvdG90eXBlLmRlbGF5TmV4dFN0ZXAgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IGRlbGF5XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoZGVsYXkpIHtcbiAgICAgICAgLy8gaW4gdGhlIGV2ZW50IHRoYXQgYSBzdHlsZSgpIHN0ZXAgaXMgcGxhY2VkIHJpZ2h0IGJlZm9yZSBhIHN0YWdnZXIoKVxuICAgICAgICAvLyBhbmQgdGhhdCBzdHlsZSgpIHN0ZXAgaXMgdGhlIHZlcnkgZmlyc3Qgc3R5bGUoKSB2YWx1ZSBpbiB0aGUgYW5pbWF0aW9uXG4gICAgICAgIC8vIHRoZW4gd2UgbmVlZCB0byBtYWtlIGEgY29weSBvZiB0aGUga2V5ZnJhbWUgWzAsIGNvcHksIDFdIHNvIHRoYXQgdGhlIGRlbGF5XG4gICAgICAgIC8vIHByb3Blcmx5IGFwcGxpZXMgdGhlIHN0eWxlKCkgdmFsdWVzIHRvIHdvcmsgd2l0aCB0aGUgc3RhZ2dlci4uLlxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBoYXNQcmVTdHlsZVN0ZXAgPSB0aGlzLl9rZXlmcmFtZXMuc2l6ZSA9PSAxICYmIE9iamVjdC5rZXlzKHRoaXMuX3BlbmRpbmdTdHlsZXMpLmxlbmd0aDtcbiAgICAgICAgaWYgKHRoaXMuZHVyYXRpb24gfHwgaGFzUHJlU3R5bGVTdGVwKSB7XG4gICAgICAgICAgICB0aGlzLmZvcndhcmRUaW1lKHRoaXMuY3VycmVudFRpbWUgKyBkZWxheSk7XG4gICAgICAgICAgICBpZiAoaGFzUHJlU3R5bGVTdGVwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zbmFwc2hvdEN1cnJlbnRTdHlsZXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc3RhcnRUaW1lICs9IGRlbGF5O1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0gez89fSBjdXJyZW50VGltZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVGltZWxpbmVCdWlsZGVyLnByb3RvdHlwZS5mb3JrID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XG4gICAgICogQHBhcmFtIHs/PX0gY3VycmVudFRpbWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChlbGVtZW50LCBjdXJyZW50VGltZSkge1xuICAgICAgICB0aGlzLmFwcGx5U3R5bGVzVG9LZXlmcmFtZSgpO1xuICAgICAgICByZXR1cm4gbmV3IFRpbWVsaW5lQnVpbGRlcih0aGlzLl9kcml2ZXIsIGVsZW1lbnQsIGN1cnJlbnRUaW1lIHx8IHRoaXMuY3VycmVudFRpbWUsIHRoaXMuX2VsZW1lbnRUaW1lbGluZVN0eWxlc0xvb2t1cCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRpbWVsaW5lQnVpbGRlci5wcm90b3R5cGUuX2xvYWRLZXlmcmFtZSA9IC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fY3VycmVudEtleWZyYW1lKSB7XG4gICAgICAgICAgICB0aGlzLl9wcmV2aW91c0tleWZyYW1lID0gdGhpcy5fY3VycmVudEtleWZyYW1lO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2N1cnJlbnRLZXlmcmFtZSA9IC8qKiBAdHlwZSB7P30gKi8gKCh0aGlzLl9rZXlmcmFtZXMuZ2V0KHRoaXMuZHVyYXRpb24pKSk7XG4gICAgICAgIGlmICghdGhpcy5fY3VycmVudEtleWZyYW1lKSB7XG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50S2V5ZnJhbWUgPSBPYmplY3QuY3JlYXRlKHRoaXMuX2JhY2tGaWxsLCB7fSk7XG4gICAgICAgICAgICB0aGlzLl9rZXlmcmFtZXMuc2V0KHRoaXMuZHVyYXRpb24sIHRoaXMuX2N1cnJlbnRLZXlmcmFtZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVGltZWxpbmVCdWlsZGVyLnByb3RvdHlwZS5mb3J3YXJkRnJhbWUgPSAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5kdXJhdGlvbiArPSBPTkVfRlJBTUVfSU5fTUlMTElTRUNPTkRTO1xuICAgICAgICB0aGlzLl9sb2FkS2V5ZnJhbWUoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdGltZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVGltZWxpbmVCdWlsZGVyLnByb3RvdHlwZS5mb3J3YXJkVGltZSA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gdGltZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKHRpbWUpIHtcbiAgICAgICAgdGhpcy5hcHBseVN0eWxlc1RvS2V5ZnJhbWUoKTtcbiAgICAgICAgdGhpcy5kdXJhdGlvbiA9IHRpbWU7XG4gICAgICAgIHRoaXMuX2xvYWRLZXlmcmFtZSgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBwcm9wXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVGltZWxpbmVCdWlsZGVyLnByb3RvdHlwZS5fdXBkYXRlU3R5bGUgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IHByb3BcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAocHJvcCwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5fbG9jYWxUaW1lbGluZVN0eWxlc1twcm9wXSA9IHZhbHVlO1xuICAgICAgICB0aGlzLl9nbG9iYWxUaW1lbGluZVN0eWxlc1twcm9wXSA9IHZhbHVlO1xuICAgICAgICB0aGlzLl9zdHlsZVN1bW1hcnlbcHJvcF0gPSB7IHRpbWU6IHRoaXMuY3VycmVudFRpbWUsIHZhbHVlOiB2YWx1ZSB9O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUaW1lbGluZUJ1aWxkZXIucHJvdG90eXBlLmFsbG93T25seVRpbWVsaW5lU3R5bGVzID0gLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9jdXJyZW50RW1wdHlTdGVwS2V5ZnJhbWUgIT09IHRoaXMuX2N1cnJlbnRLZXlmcmFtZTsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVhc2luZ1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVGltZWxpbmVCdWlsZGVyLnByb3RvdHlwZS5hcHBseUVtcHR5U3RlcCA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gZWFzaW5nXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoZWFzaW5nKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChlYXNpbmcpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByZXZpb3VzS2V5ZnJhbWVbJ2Vhc2luZyddID0gZWFzaW5nO1xuICAgICAgICB9XG4gICAgICAgIC8vIHNwZWNpYWwgY2FzZSBmb3IgYW5pbWF0ZShkdXJhdGlvbik6XG4gICAgICAgIC8vIGFsbCBtaXNzaW5nIHN0eWxlcyBhcmUgZmlsbGVkIHdpdGggYSBgKmAgdmFsdWUgdGhlblxuICAgICAgICAvLyBpZiBhbnkgZGVzdGluYXRpb24gc3R5bGVzIGFyZSBmaWxsZWQgaW4gbGF0ZXIgb24gdGhlIHNhbWVcbiAgICAgICAgLy8ga2V5ZnJhbWUgdGhlbiB0aGV5IHdpbGwgb3ZlcnJpZGUgdGhlIG92ZXJyaWRkZW4gc3R5bGVzXG4gICAgICAgIC8vIFdlIHVzZSBgX2dsb2JhbFRpbWVsaW5lU3R5bGVzYCBoZXJlIGJlY2F1c2UgdGhlcmUgbWF5IGJlXG4gICAgICAgIC8vIHN0eWxlcyBpbiBwcmV2aW91cyBrZXlmcmFtZXMgdGhhdCBhcmUgbm90IHByZXNlbnQgaW4gdGhpcyB0aW1lbGluZVxuICAgICAgICBPYmplY3Qua2V5cyh0aGlzLl9nbG9iYWxUaW1lbGluZVN0eWxlcykuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgICAgICAgICAgX3RoaXMuX2JhY2tGaWxsW3Byb3BdID0gX3RoaXMuX2dsb2JhbFRpbWVsaW5lU3R5bGVzW3Byb3BdIHx8IF9hbmd1bGFyX2FuaW1hdGlvbnMuQVVUT19TVFlMRTtcbiAgICAgICAgICAgIF90aGlzLl9jdXJyZW50S2V5ZnJhbWVbcHJvcF0gPSBfYW5ndWxhcl9hbmltYXRpb25zLkFVVE9fU1RZTEU7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9jdXJyZW50RW1wdHlTdGVwS2V5ZnJhbWUgPSB0aGlzLl9jdXJyZW50S2V5ZnJhbWU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGlucHV0XG4gICAgICogQHBhcmFtIHs/fSBlYXNpbmdcbiAgICAgKiBAcGFyYW0gez99IGVycm9yc1xuICAgICAqIEBwYXJhbSB7Pz19IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRpbWVsaW5lQnVpbGRlci5wcm90b3R5cGUuc2V0U3R5bGVzID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBpbnB1dFxuICAgICAqIEBwYXJhbSB7P30gZWFzaW5nXG4gICAgICogQHBhcmFtIHs/fSBlcnJvcnNcbiAgICAgKiBAcGFyYW0gez89fSBvcHRpb25zXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoaW5wdXQsIGVhc2luZywgZXJyb3JzLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChlYXNpbmcpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByZXZpb3VzS2V5ZnJhbWVbJ2Vhc2luZyddID0gZWFzaW5nO1xuICAgICAgICB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBhcmFtcyA9IChvcHRpb25zICYmIG9wdGlvbnMucGFyYW1zKSB8fCB7fTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3R5bGVzID0gZmxhdHRlblN0eWxlcyhpbnB1dCwgdGhpcy5fZ2xvYmFsVGltZWxpbmVTdHlsZXMpO1xuICAgICAgICBPYmplY3Qua2V5cyhzdHlsZXMpLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHZhbCA9IGludGVycG9sYXRlUGFyYW1zKHN0eWxlc1twcm9wXSwgcGFyYW1zLCBlcnJvcnMpO1xuICAgICAgICAgICAgX3RoaXMuX3BlbmRpbmdTdHlsZXNbcHJvcF0gPSB2YWw7XG4gICAgICAgICAgICBpZiAoIV90aGlzLl9sb2NhbFRpbWVsaW5lU3R5bGVzLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX2JhY2tGaWxsW3Byb3BdID0gX3RoaXMuX2dsb2JhbFRpbWVsaW5lU3R5bGVzLmhhc093blByb3BlcnR5KHByb3ApID9cbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2dsb2JhbFRpbWVsaW5lU3R5bGVzW3Byb3BdIDpcbiAgICAgICAgICAgICAgICAgICAgX2FuZ3VsYXJfYW5pbWF0aW9ucy5BVVRPX1NUWUxFO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXMuX3VwZGF0ZVN0eWxlKHByb3AsIHZhbCk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUaW1lbGluZUJ1aWxkZXIucHJvdG90eXBlLmFwcGx5U3R5bGVzVG9LZXlmcmFtZSA9IC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdHlsZXMgPSB0aGlzLl9wZW5kaW5nU3R5bGVzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwcm9wcyA9IE9iamVjdC5rZXlzKHN0eWxlcyk7XG4gICAgICAgIGlmIChwcm9wcy5sZW5ndGggPT0gMClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5fcGVuZGluZ1N0eWxlcyA9IHt9O1xuICAgICAgICBwcm9wcy5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2YWwgPSBzdHlsZXNbcHJvcF07XG4gICAgICAgICAgICBfdGhpcy5fY3VycmVudEtleWZyYW1lW3Byb3BdID0gdmFsO1xuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmtleXModGhpcy5fbG9jYWxUaW1lbGluZVN0eWxlcykuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgICAgICAgICAgaWYgKCFfdGhpcy5fY3VycmVudEtleWZyYW1lLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX2N1cnJlbnRLZXlmcmFtZVtwcm9wXSA9IF90aGlzLl9sb2NhbFRpbWVsaW5lU3R5bGVzW3Byb3BdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVGltZWxpbmVCdWlsZGVyLnByb3RvdHlwZS5zbmFwc2hvdEN1cnJlbnRTdHlsZXMgPSAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgT2JqZWN0LmtleXModGhpcy5fbG9jYWxUaW1lbGluZVN0eWxlcykuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmFsID0gX3RoaXMuX2xvY2FsVGltZWxpbmVTdHlsZXNbcHJvcF07XG4gICAgICAgICAgICBfdGhpcy5fcGVuZGluZ1N0eWxlc1twcm9wXSA9IHZhbDtcbiAgICAgICAgICAgIF90aGlzLl91cGRhdGVTdHlsZShwcm9wLCB2YWwpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVGltZWxpbmVCdWlsZGVyLnByb3RvdHlwZS5nZXRGaW5hbEtleWZyYW1lID0gLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9rZXlmcmFtZXMuZ2V0KHRoaXMuZHVyYXRpb24pOyB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUaW1lbGluZUJ1aWxkZXIucHJvdG90eXBlLCBcInByb3BlcnRpZXNcIiwge1xuICAgICAgICBnZXQ6IC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcHJvcGVydGllcyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBwcm9wIGluIHRoaXMuX2N1cnJlbnRLZXlmcmFtZSkge1xuICAgICAgICAgICAgICAgIHByb3BlcnRpZXMucHVzaChwcm9wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwcm9wZXJ0aWVzO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHRpbWVsaW5lXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUaW1lbGluZUJ1aWxkZXIucHJvdG90eXBlLm1lcmdlVGltZWxpbmVDb2xsZWN0ZWRTdHlsZXMgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IHRpbWVsaW5lXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAodGltZWxpbmUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgT2JqZWN0LmtleXModGltZWxpbmUuX3N0eWxlU3VtbWFyeSkuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZGV0YWlsczAgPSBfdGhpcy5fc3R5bGVTdW1tYXJ5W3Byb3BdO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZGV0YWlsczEgPSB0aW1lbGluZS5fc3R5bGVTdW1tYXJ5W3Byb3BdO1xuICAgICAgICAgICAgaWYgKCFkZXRhaWxzMCB8fCBkZXRhaWxzMS50aW1lID4gZGV0YWlsczAudGltZSkge1xuICAgICAgICAgICAgICAgIF90aGlzLl91cGRhdGVTdHlsZShwcm9wLCBkZXRhaWxzMS52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUaW1lbGluZUJ1aWxkZXIucHJvdG90eXBlLmJ1aWxkS2V5ZnJhbWVzID0gLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuYXBwbHlTdHlsZXNUb0tleWZyYW1lKCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHByZVN0eWxlUHJvcHMgPSBuZXcgU2V0KCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBvc3RTdHlsZVByb3BzID0gbmV3IFNldCgpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpc0VtcHR5ID0gdGhpcy5fa2V5ZnJhbWVzLnNpemUgPT09IDEgJiYgdGhpcy5kdXJhdGlvbiA9PT0gMDtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZmluYWxLZXlmcmFtZXMgPSBbXTtcbiAgICAgICAgdGhpcy5fa2V5ZnJhbWVzLmZvckVhY2goZnVuY3Rpb24gKGtleWZyYW1lLCB0aW1lKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBmaW5hbEtleWZyYW1lID0gY29weVN0eWxlcyhrZXlmcmFtZSwgdHJ1ZSk7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhmaW5hbEtleWZyYW1lKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmFsdWUgPSBmaW5hbEtleWZyYW1lW3Byb3BdO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBfYW5ndWxhcl9hbmltYXRpb25zLsm1UFJFX1NUWUxFKSB7XG4gICAgICAgICAgICAgICAgICAgIHByZVN0eWxlUHJvcHMuYWRkKHByb3ApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh2YWx1ZSA9PSBfYW5ndWxhcl9hbmltYXRpb25zLkFVVE9fU1RZTEUpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zdFN0eWxlUHJvcHMuYWRkKHByb3ApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKCFpc0VtcHR5KSB7XG4gICAgICAgICAgICAgICAgZmluYWxLZXlmcmFtZVsnb2Zmc2V0J10gPSB0aW1lIC8gX3RoaXMuZHVyYXRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbEtleWZyYW1lcy5wdXNoKGZpbmFsS2V5ZnJhbWUpO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcHJlUHJvcHMgPSBwcmVTdHlsZVByb3BzLnNpemUgPyBpdGVyYXRvclRvQXJyYXkocHJlU3R5bGVQcm9wcy52YWx1ZXMoKSkgOiBbXTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcG9zdFByb3BzID0gcG9zdFN0eWxlUHJvcHMuc2l6ZSA/IGl0ZXJhdG9yVG9BcnJheShwb3N0U3R5bGVQcm9wcy52YWx1ZXMoKSkgOiBbXTtcbiAgICAgICAgLy8gc3BlY2lhbCBjYXNlIGZvciBhIDAtc2Vjb25kIGFuaW1hdGlvbiAod2hpY2ggaXMgZGVzaWduZWQganVzdCB0byBwbGFjZSBzdHlsZXMgb25zY3JlZW4pXG4gICAgICAgIGlmIChpc0VtcHR5KSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBrZjAgPSBmaW5hbEtleWZyYW1lc1swXTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGtmMSA9IGNvcHlPYmooa2YwKTtcbiAgICAgICAgICAgIGtmMFsnb2Zmc2V0J10gPSAwO1xuICAgICAgICAgICAga2YxWydvZmZzZXQnXSA9IDE7XG4gICAgICAgICAgICBmaW5hbEtleWZyYW1lcyA9IFtrZjAsIGtmMV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNyZWF0ZVRpbWVsaW5lSW5zdHJ1Y3Rpb24odGhpcy5lbGVtZW50LCBmaW5hbEtleWZyYW1lcywgcHJlUHJvcHMsIHBvc3RQcm9wcywgdGhpcy5kdXJhdGlvbiwgdGhpcy5zdGFydFRpbWUsIHRoaXMuZWFzaW5nLCBmYWxzZSk7XG4gICAgfTtcbiAgICByZXR1cm4gVGltZWxpbmVCdWlsZGVyO1xufSgpKTtcbnZhciBTdWJUaW1lbGluZUJ1aWxkZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTdWJUaW1lbGluZUJ1aWxkZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU3ViVGltZWxpbmVCdWlsZGVyKGRyaXZlciwgZWxlbWVudCwga2V5ZnJhbWVzLCBwcmVTdHlsZVByb3BzLCBwb3N0U3R5bGVQcm9wcywgdGltaW5ncywgX3N0cmV0Y2hTdGFydGluZ0tleWZyYW1lKSB7XG4gICAgICAgIGlmIChfc3RyZXRjaFN0YXJ0aW5nS2V5ZnJhbWUgPT09IHZvaWQgMCkgeyBfc3RyZXRjaFN0YXJ0aW5nS2V5ZnJhbWUgPSBmYWxzZTsgfVxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBkcml2ZXIsIGVsZW1lbnQsIHRpbWluZ3MuZGVsYXkpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgICBfdGhpcy5rZXlmcmFtZXMgPSBrZXlmcmFtZXM7XG4gICAgICAgIF90aGlzLnByZVN0eWxlUHJvcHMgPSBwcmVTdHlsZVByb3BzO1xuICAgICAgICBfdGhpcy5wb3N0U3R5bGVQcm9wcyA9IHBvc3RTdHlsZVByb3BzO1xuICAgICAgICBfdGhpcy5fc3RyZXRjaFN0YXJ0aW5nS2V5ZnJhbWUgPSBfc3RyZXRjaFN0YXJ0aW5nS2V5ZnJhbWU7XG4gICAgICAgIF90aGlzLnRpbWluZ3MgPSB7IGR1cmF0aW9uOiB0aW1pbmdzLmR1cmF0aW9uLCBkZWxheTogdGltaW5ncy5kZWxheSwgZWFzaW5nOiB0aW1pbmdzLmVhc2luZyB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU3ViVGltZWxpbmVCdWlsZGVyLnByb3RvdHlwZS5jb250YWluc0FuaW1hdGlvbiA9IC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5rZXlmcmFtZXMubGVuZ3RoID4gMTsgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFN1YlRpbWVsaW5lQnVpbGRlci5wcm90b3R5cGUuYnVpbGRLZXlmcmFtZXMgPSAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8ga2V5ZnJhbWVzID0gdGhpcy5rZXlmcmFtZXM7XG4gICAgICAgIHZhciBfYSA9IHRoaXMudGltaW5ncywgZGVsYXkgPSBfYS5kZWxheSwgZHVyYXRpb24gPSBfYS5kdXJhdGlvbiwgZWFzaW5nID0gX2EuZWFzaW5nO1xuICAgICAgICBpZiAodGhpcy5fc3RyZXRjaFN0YXJ0aW5nS2V5ZnJhbWUgJiYgZGVsYXkpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5ld0tleWZyYW1lcyA9IFtdO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdG90YWxUaW1lID0gZHVyYXRpb24gKyBkZWxheTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0YXJ0aW5nR2FwID0gZGVsYXkgLyB0b3RhbFRpbWU7XG4gICAgICAgICAgICAvLyB0aGUgb3JpZ2luYWwgc3RhcnRpbmcga2V5ZnJhbWUgbm93IHN0YXJ0cyBvbmNlIHRoZSBkZWxheSBpcyBkb25lXG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBuZXdGaXJzdEtleWZyYW1lID0gY29weVN0eWxlcyhrZXlmcmFtZXNbMF0sIGZhbHNlKTtcbiAgICAgICAgICAgIG5ld0ZpcnN0S2V5ZnJhbWVbJ29mZnNldCddID0gMDtcbiAgICAgICAgICAgIG5ld0tleWZyYW1lcy5wdXNoKG5ld0ZpcnN0S2V5ZnJhbWUpO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gb2xkRmlyc3RLZXlmcmFtZSA9IGNvcHlTdHlsZXMoa2V5ZnJhbWVzWzBdLCBmYWxzZSk7XG4gICAgICAgICAgICBvbGRGaXJzdEtleWZyYW1lWydvZmZzZXQnXSA9IHJvdW5kT2Zmc2V0KHN0YXJ0aW5nR2FwKTtcbiAgICAgICAgICAgIG5ld0tleWZyYW1lcy5wdXNoKG9sZEZpcnN0S2V5ZnJhbWUpO1xuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgICAgV2hlbiB0aGUga2V5ZnJhbWUgaXMgc3RyZXRjaGVkIHRoZW4gaXQgbWVhbnMgdGhhdCB0aGUgZGVsYXkgYmVmb3JlIHRoZSBhbmltYXRpb25cbiAgICAgICAgICAgICAgICAgICAgc3RhcnRzIGlzIGdvbmUuIEluc3RlYWQgdGhlIGZpcnN0IGtleWZyYW1lIGlzIHBsYWNlZCBhdCB0aGUgc3RhcnQgb2YgdGhlIGFuaW1hdGlvblxuICAgICAgICAgICAgICAgICAgICBhbmQgaXQgaXMgdGhlbiBjb3BpZWQgdG8gd2hlcmUgaXQgc3RhcnRzIHdoZW4gdGhlIG9yaWdpbmFsIGRlbGF5IGlzIG92ZXIuIFRoaXMgYmFzaWNhbGx5XG4gICAgICAgICAgICAgICAgICAgIG1lYW5zIG5vdGhpbmcgYW5pbWF0ZXMgZHVyaW5nIHRoYXQgZGVsYXksIGJ1dCB0aGUgc3R5bGVzIGFyZSBzdGlsbCByZW5kZXJlcmVkLiBGb3IgdGhpc1xuICAgICAgICAgICAgICAgICAgICB0byB3b3JrIHRoZSBvcmlnaW5hbCBvZmZzZXQgdmFsdWVzIHRoYXQgZXhpc3QgaW4gdGhlIG9yaWdpbmFsIGtleWZyYW1lcyBtdXN0IGJlIFwid2FycGVkXCJcbiAgICAgICAgICAgICAgICAgICAgc28gdGhhdCB0aGV5IGNhbiB0YWtlIHRoZSBuZXcga2V5ZnJhbWUgKyBkZWxheSBpbnRvIGFjY291bnQuXG4gICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgZGVsYXk9MTAwMCwgZHVyYXRpb249MTAwMCwga2V5ZnJhbWVzID0gMCAuNSAxXG4gICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgdHVybnMgaW50b1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGRlbGF5PTAsIGR1cmF0aW9uPTIwMDAsIGtleWZyYW1lcyA9IDAgLjMzIC42NiAxXG4gICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIC8vIG9mZnNldHMgYmV0d2VlbiAxIC4uLiBuIC0xIGFyZSBhbGwgd2FycGVkIGJ5IHRoZSBrZXlmcmFtZSBzdHJldGNoXG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBsaW1pdCA9IGtleWZyYW1lcy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBpID0gMTsgaSA8PSBsaW1pdDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8ga2YgPSBjb3B5U3R5bGVzKGtleWZyYW1lc1tpXSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG9sZE9mZnNldCA9IC8qKiBAdHlwZSB7P30gKi8gKGtmWydvZmZzZXQnXSk7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdGltZUF0S2V5ZnJhbWUgPSBkZWxheSArIG9sZE9mZnNldCAqIGR1cmF0aW9uO1xuICAgICAgICAgICAgICAgIGtmWydvZmZzZXQnXSA9IHJvdW5kT2Zmc2V0KHRpbWVBdEtleWZyYW1lIC8gdG90YWxUaW1lKTtcbiAgICAgICAgICAgICAgICBuZXdLZXlmcmFtZXMucHVzaChrZik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB0aGUgbmV3IHN0YXJ0aW5nIGtleWZyYW1lIHNob3VsZCBiZSBhZGRlZCBhdCB0aGUgc3RhcnRcbiAgICAgICAgICAgIGR1cmF0aW9uID0gdG90YWxUaW1lO1xuICAgICAgICAgICAgZGVsYXkgPSAwO1xuICAgICAgICAgICAgZWFzaW5nID0gJyc7XG4gICAgICAgICAgICBrZXlmcmFtZXMgPSBuZXdLZXlmcmFtZXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNyZWF0ZVRpbWVsaW5lSW5zdHJ1Y3Rpb24odGhpcy5lbGVtZW50LCBrZXlmcmFtZXMsIHRoaXMucHJlU3R5bGVQcm9wcywgdGhpcy5wb3N0U3R5bGVQcm9wcywgZHVyYXRpb24sIGRlbGF5LCBlYXNpbmcsIHRydWUpO1xuICAgIH07XG4gICAgcmV0dXJuIFN1YlRpbWVsaW5lQnVpbGRlcjtcbn0oVGltZWxpbmVCdWlsZGVyKSk7XG4vKipcbiAqIEBwYXJhbSB7P30gb2Zmc2V0XG4gKiBAcGFyYW0gez89fSBkZWNpbWFsUG9pbnRzXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiByb3VuZE9mZnNldChvZmZzZXQsIGRlY2ltYWxQb2ludHMpIHtcbiAgICBpZiAoZGVjaW1hbFBvaW50cyA9PT0gdm9pZCAwKSB7IGRlY2ltYWxQb2ludHMgPSAzOyB9XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbXVsdCA9IE1hdGgucG93KDEwLCBkZWNpbWFsUG9pbnRzIC0gMSk7XG4gICAgcmV0dXJuIE1hdGgucm91bmQob2Zmc2V0ICogbXVsdCkgLyBtdWx0O1xufVxuLyoqXG4gKiBAcGFyYW0gez99IGlucHV0XG4gKiBAcGFyYW0gez99IGFsbFN0eWxlc1xuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gZmxhdHRlblN0eWxlcyhpbnB1dCwgYWxsU3R5bGVzKSB7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3R5bGVzID0ge307XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYWxsUHJvcGVydGllcztcbiAgICBpbnB1dC5mb3JFYWNoKGZ1bmN0aW9uICh0b2tlbikge1xuICAgICAgICBpZiAodG9rZW4gPT09ICcqJykge1xuICAgICAgICAgICAgYWxsUHJvcGVydGllcyA9IGFsbFByb3BlcnRpZXMgfHwgT2JqZWN0LmtleXMoYWxsU3R5bGVzKTtcbiAgICAgICAgICAgIGFsbFByb3BlcnRpZXMuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkgeyBzdHlsZXNbcHJvcF0gPSBfYW5ndWxhcl9hbmltYXRpb25zLkFVVE9fU1RZTEU7IH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29weVN0eWxlcygvKiogQHR5cGUgez99ICovICh0b2tlbiksIGZhbHNlLCBzdHlsZXMpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHN0eWxlcztcbn1cblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IGFkZGVkIGJ5IHRzaWNrbGVcbiAqIEBzdXBwcmVzcyB7Y2hlY2tUeXBlc30gY2hlY2tlZCBieSB0c2NcbiAqL1xudmFyIEFuaW1hdGlvbiA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQW5pbWF0aW9uKF9kcml2ZXIsIGlucHV0KSB7XG4gICAgICAgIHRoaXMuX2RyaXZlciA9IF9kcml2ZXI7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVycm9ycyA9IFtdO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBhc3QgPSBidWlsZEFuaW1hdGlvbkFzdChfZHJpdmVyLCBpbnB1dCwgZXJyb3JzKTtcbiAgICAgICAgaWYgKGVycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVycm9yTWVzc2FnZSA9IFwiYW5pbWF0aW9uIHZhbGlkYXRpb24gZmFpbGVkOlxcblwiICsgZXJyb3JzLmpvaW4oXCJcXG5cIik7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JNZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9hbmltYXRpb25Bc3QgPSBhc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFxuICAgICAqIEBwYXJhbSB7P30gc3RhcnRpbmdTdHlsZXNcbiAgICAgKiBAcGFyYW0gez99IGRlc3RpbmF0aW9uU3R5bGVzXG4gICAgICogQHBhcmFtIHs/fSBvcHRpb25zXG4gICAgICogQHBhcmFtIHs/PX0gc3ViSW5zdHJ1Y3Rpb25zXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBbmltYXRpb24ucHJvdG90eXBlLmJ1aWxkVGltZWxpbmVzID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XG4gICAgICogQHBhcmFtIHs/fSBzdGFydGluZ1N0eWxlc1xuICAgICAqIEBwYXJhbSB7P30gZGVzdGluYXRpb25TdHlsZXNcbiAgICAgKiBAcGFyYW0gez99IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0gez89fSBzdWJJbnN0cnVjdGlvbnNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChlbGVtZW50LCBzdGFydGluZ1N0eWxlcywgZGVzdGluYXRpb25TdHlsZXMsIG9wdGlvbnMsIHN1Ykluc3RydWN0aW9ucykge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdGFydCA9IEFycmF5LmlzQXJyYXkoc3RhcnRpbmdTdHlsZXMpID8gbm9ybWFsaXplU3R5bGVzKHN0YXJ0aW5nU3R5bGVzKSA6IC8qKiBAdHlwZSB7P30gKi8gKHN0YXJ0aW5nU3R5bGVzKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZGVzdCA9IEFycmF5LmlzQXJyYXkoZGVzdGluYXRpb25TdHlsZXMpID8gbm9ybWFsaXplU3R5bGVzKGRlc3RpbmF0aW9uU3R5bGVzKSA6IC8qKiBAdHlwZSB7P30gKi8gKGRlc3RpbmF0aW9uU3R5bGVzKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZXJyb3JzID0gW107XG4gICAgICAgIHN1Ykluc3RydWN0aW9ucyA9IHN1Ykluc3RydWN0aW9ucyB8fCBuZXcgRWxlbWVudEluc3RydWN0aW9uTWFwKCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlc3VsdCA9IGJ1aWxkQW5pbWF0aW9uVGltZWxpbmVzKHRoaXMuX2RyaXZlciwgZWxlbWVudCwgdGhpcy5fYW5pbWF0aW9uQXN0LCBzdGFydCwgZGVzdCwgb3B0aW9ucywgc3ViSW5zdHJ1Y3Rpb25zLCBlcnJvcnMpO1xuICAgICAgICBpZiAoZXJyb3JzLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZXJyb3JNZXNzYWdlID0gXCJhbmltYXRpb24gYnVpbGRpbmcgZmFpbGVkOlxcblwiICsgZXJyb3JzLmpvaW4oXCJcXG5cIik7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JNZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgcmV0dXJuIEFuaW1hdGlvbjtcbn0oKSk7XG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBhZGRlZCBieSB0c2lja2xlXG4gKiBAc3VwcHJlc3Mge2NoZWNrVHlwZXN9IGNoZWNrZWQgYnkgdHNjXG4gKi9cbi8qKlxuICogXFxAZXhwZXJpbWVudGFsIEFuaW1hdGlvbiBzdXBwb3J0IGlzIGV4cGVyaW1lbnRhbC5cbiAqIEBhYnN0cmFjdFxuICovXG52YXIgQW5pbWF0aW9uU3R5bGVOb3JtYWxpemVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBbmltYXRpb25TdHlsZU5vcm1hbGl6ZXIoKSB7XG4gICAgfVxuICAgIHJldHVybiBBbmltYXRpb25TdHlsZU5vcm1hbGl6ZXI7XG59KCkpO1xuLyoqXG4gKiBcXEBleHBlcmltZW50YWwgQW5pbWF0aW9uIHN1cHBvcnQgaXMgZXhwZXJpbWVudGFsLlxuICovXG52YXIgTm9vcEFuaW1hdGlvblN0eWxlTm9ybWFsaXplciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTm9vcEFuaW1hdGlvblN0eWxlTm9ybWFsaXplcigpIHtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBwcm9wZXJ0eU5hbWVcbiAgICAgKiBAcGFyYW0gez99IGVycm9yc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTm9vcEFuaW1hdGlvblN0eWxlTm9ybWFsaXplci5wcm90b3R5cGUubm9ybWFsaXplUHJvcGVydHlOYW1lID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBwcm9wZXJ0eU5hbWVcbiAgICAgKiBAcGFyYW0gez99IGVycm9yc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKHByb3BlcnR5TmFtZSwgZXJyb3JzKSB7IHJldHVybiBwcm9wZXJ0eU5hbWU7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB1c2VyUHJvdmlkZWRQcm9wZXJ0eVxuICAgICAqIEBwYXJhbSB7P30gbm9ybWFsaXplZFByb3BlcnR5XG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7P30gZXJyb3JzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBOb29wQW5pbWF0aW9uU3R5bGVOb3JtYWxpemVyLnByb3RvdHlwZS5ub3JtYWxpemVTdHlsZVZhbHVlID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSB1c2VyUHJvdmlkZWRQcm9wZXJ0eVxuICAgICAqIEBwYXJhbSB7P30gbm9ybWFsaXplZFByb3BlcnR5XG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7P30gZXJyb3JzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAodXNlclByb3ZpZGVkUHJvcGVydHksIG5vcm1hbGl6ZWRQcm9wZXJ0eSwgdmFsdWUsIGVycm9ycykge1xuICAgICAgICByZXR1cm4gLyoqIEB0eXBlIHs/fSAqLyAodmFsdWUpO1xuICAgIH07XG4gICAgcmV0dXJuIE5vb3BBbmltYXRpb25TdHlsZU5vcm1hbGl6ZXI7XG59KCkpO1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgYWRkZWQgYnkgdHNpY2tsZVxuICogQHN1cHByZXNzIHtjaGVja1R5cGVzfSBjaGVja2VkIGJ5IHRzY1xuICovXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgV2ViQW5pbWF0aW9uc1N0eWxlTm9ybWFsaXplciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFdlYkFuaW1hdGlvbnNTdHlsZU5vcm1hbGl6ZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gV2ViQW5pbWF0aW9uc1N0eWxlTm9ybWFsaXplcigpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHByb3BlcnR5TmFtZVxuICAgICAqIEBwYXJhbSB7P30gZXJyb3JzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBXZWJBbmltYXRpb25zU3R5bGVOb3JtYWxpemVyLnByb3RvdHlwZS5ub3JtYWxpemVQcm9wZXJ0eU5hbWUgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IHByb3BlcnR5TmFtZVxuICAgICAqIEBwYXJhbSB7P30gZXJyb3JzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAocHJvcGVydHlOYW1lLCBlcnJvcnMpIHtcbiAgICAgICAgcmV0dXJuIGRhc2hDYXNlVG9DYW1lbENhc2UocHJvcGVydHlOYW1lKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdXNlclByb3ZpZGVkUHJvcGVydHlcbiAgICAgKiBAcGFyYW0gez99IG5vcm1hbGl6ZWRQcm9wZXJ0eVxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgKiBAcGFyYW0gez99IGVycm9yc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgV2ViQW5pbWF0aW9uc1N0eWxlTm9ybWFsaXplci5wcm90b3R5cGUubm9ybWFsaXplU3R5bGVWYWx1ZSA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gdXNlclByb3ZpZGVkUHJvcGVydHlcbiAgICAgKiBAcGFyYW0gez99IG5vcm1hbGl6ZWRQcm9wZXJ0eVxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgKiBAcGFyYW0gez99IGVycm9yc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKHVzZXJQcm92aWRlZFByb3BlcnR5LCBub3JtYWxpemVkUHJvcGVydHksIHZhbHVlLCBlcnJvcnMpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdW5pdCA9ICcnO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdHJWYWwgPSB2YWx1ZS50b1N0cmluZygpLnRyaW0oKTtcbiAgICAgICAgaWYgKERJTUVOU0lPTkFMX1BST1BfTUFQW25vcm1hbGl6ZWRQcm9wZXJ0eV0gJiYgdmFsdWUgIT09IDAgJiYgdmFsdWUgIT09ICcwJykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICB1bml0ID0gJ3B4JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHZhbEFuZFN1ZmZpeE1hdGNoID0gdmFsdWUubWF0Y2goL15bKy1dP1tcXGRcXC5dKyhbYS16XSopJC8pO1xuICAgICAgICAgICAgICAgIGlmICh2YWxBbmRTdWZmaXhNYXRjaCAmJiB2YWxBbmRTdWZmaXhNYXRjaFsxXS5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBlcnJvcnMucHVzaChcIlBsZWFzZSBwcm92aWRlIGEgQ1NTIHVuaXQgdmFsdWUgZm9yIFwiICsgdXNlclByb3ZpZGVkUHJvcGVydHkgKyBcIjpcIiArIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0clZhbCArIHVuaXQ7XG4gICAgfTtcbiAgICByZXR1cm4gV2ViQW5pbWF0aW9uc1N0eWxlTm9ybWFsaXplcjtcbn0oQW5pbWF0aW9uU3R5bGVOb3JtYWxpemVyKSk7XG52YXIgRElNRU5TSU9OQUxfUFJPUF9NQVAgPSBtYWtlQm9vbGVhbk1hcCgnd2lkdGgsaGVpZ2h0LG1pbldpZHRoLG1pbkhlaWdodCxtYXhXaWR0aCxtYXhIZWlnaHQsbGVmdCx0b3AsYm90dG9tLHJpZ2h0LGZvbnRTaXplLG91dGxpbmVXaWR0aCxvdXRsaW5lT2Zmc2V0LHBhZGRpbmdUb3AscGFkZGluZ0xlZnQscGFkZGluZ0JvdHRvbSxwYWRkaW5nUmlnaHQsbWFyZ2luVG9wLG1hcmdpbkxlZnQsbWFyZ2luQm90dG9tLG1hcmdpblJpZ2h0LGJvcmRlclJhZGl1cyxib3JkZXJXaWR0aCxib3JkZXJUb3BXaWR0aCxib3JkZXJMZWZ0V2lkdGgsYm9yZGVyUmlnaHRXaWR0aCxib3JkZXJCb3R0b21XaWR0aCx0ZXh0SW5kZW50LHBlcnNwZWN0aXZlJ1xuICAgIC5zcGxpdCgnLCcpKTtcbi8qKlxuICogQHBhcmFtIHs/fSBrZXlzXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBtYWtlQm9vbGVhbk1hcChrZXlzKSB7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbWFwID0ge307XG4gICAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIG1hcFtrZXldID0gdHJ1ZTsgfSk7XG4gICAgcmV0dXJuIG1hcDtcbn1cblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IGFkZGVkIGJ5IHRzaWNrbGVcbiAqIEBzdXBwcmVzcyB7Y2hlY2tUeXBlc30gY2hlY2tlZCBieSB0c2NcbiAqL1xuLyoqXG4gKiBAcmVjb3JkXG4gKi9cblxuLyoqXG4gKiBAcGFyYW0gez99IGVsZW1lbnRcbiAqIEBwYXJhbSB7P30gdHJpZ2dlck5hbWVcbiAqIEBwYXJhbSB7P30gZnJvbVN0YXRlXG4gKiBAcGFyYW0gez99IHRvU3RhdGVcbiAqIEBwYXJhbSB7P30gaXNSZW1vdmFsVHJhbnNpdGlvblxuICogQHBhcmFtIHs/fSBmcm9tU3R5bGVzXG4gKiBAcGFyYW0gez99IHRvU3R5bGVzXG4gKiBAcGFyYW0gez99IHRpbWVsaW5lc1xuICogQHBhcmFtIHs/fSBxdWVyaWVkRWxlbWVudHNcbiAqIEBwYXJhbSB7P30gcHJlU3R5bGVQcm9wc1xuICogQHBhcmFtIHs/fSBwb3N0U3R5bGVQcm9wc1xuICogQHBhcmFtIHs/PX0gZXJyb3JzXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBjcmVhdGVUcmFuc2l0aW9uSW5zdHJ1Y3Rpb24oZWxlbWVudCwgdHJpZ2dlck5hbWUsIGZyb21TdGF0ZSwgdG9TdGF0ZSwgaXNSZW1vdmFsVHJhbnNpdGlvbiwgZnJvbVN0eWxlcywgdG9TdHlsZXMsIHRpbWVsaW5lcywgcXVlcmllZEVsZW1lbnRzLCBwcmVTdHlsZVByb3BzLCBwb3N0U3R5bGVQcm9wcywgZXJyb3JzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogMCAvKiBUcmFuc2l0aW9uQW5pbWF0aW9uICovLFxuICAgICAgICBlbGVtZW50OiBlbGVtZW50LFxuICAgICAgICB0cmlnZ2VyTmFtZTogdHJpZ2dlck5hbWUsXG4gICAgICAgIGlzUmVtb3ZhbFRyYW5zaXRpb246IGlzUmVtb3ZhbFRyYW5zaXRpb24sXG4gICAgICAgIGZyb21TdGF0ZTogZnJvbVN0YXRlLFxuICAgICAgICBmcm9tU3R5bGVzOiBmcm9tU3R5bGVzLFxuICAgICAgICB0b1N0YXRlOiB0b1N0YXRlLFxuICAgICAgICB0b1N0eWxlczogdG9TdHlsZXMsXG4gICAgICAgIHRpbWVsaW5lczogdGltZWxpbmVzLFxuICAgICAgICBxdWVyaWVkRWxlbWVudHM6IHF1ZXJpZWRFbGVtZW50cyxcbiAgICAgICAgcHJlU3R5bGVQcm9wczogcHJlU3R5bGVQcm9wcyxcbiAgICAgICAgcG9zdFN0eWxlUHJvcHM6IHBvc3RTdHlsZVByb3BzLFxuICAgICAgICBlcnJvcnM6IGVycm9yc1xuICAgIH07XG59XG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBhZGRlZCBieSB0c2lja2xlXG4gKiBAc3VwcHJlc3Mge2NoZWNrVHlwZXN9IGNoZWNrZWQgYnkgdHNjXG4gKi9cbnZhciBFTVBUWV9PQkpFQ1QgPSB7fTtcbnZhciBBbmltYXRpb25UcmFuc2l0aW9uRmFjdG9yeSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQW5pbWF0aW9uVHJhbnNpdGlvbkZhY3RvcnkoX3RyaWdnZXJOYW1lLCBhc3QsIF9zdGF0ZVN0eWxlcykge1xuICAgICAgICB0aGlzLl90cmlnZ2VyTmFtZSA9IF90cmlnZ2VyTmFtZTtcbiAgICAgICAgdGhpcy5hc3QgPSBhc3Q7XG4gICAgICAgIHRoaXMuX3N0YXRlU3R5bGVzID0gX3N0YXRlU3R5bGVzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGN1cnJlbnRTdGF0ZVxuICAgICAqIEBwYXJhbSB7P30gbmV4dFN0YXRlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBbmltYXRpb25UcmFuc2l0aW9uRmFjdG9yeS5wcm90b3R5cGUubWF0Y2ggPSAvKipcbiAgICAgKiBAcGFyYW0gez99IGN1cnJlbnRTdGF0ZVxuICAgICAqIEBwYXJhbSB7P30gbmV4dFN0YXRlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoY3VycmVudFN0YXRlLCBuZXh0U3RhdGUpIHtcbiAgICAgICAgcmV0dXJuIG9uZU9yTW9yZVRyYW5zaXRpb25zTWF0Y2godGhpcy5hc3QubWF0Y2hlcnMsIGN1cnJlbnRTdGF0ZSwgbmV4dFN0YXRlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3RhdGVOYW1lXG4gICAgICogQHBhcmFtIHs/fSBwYXJhbXNcbiAgICAgKiBAcGFyYW0gez99IGVycm9yc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQW5pbWF0aW9uVHJhbnNpdGlvbkZhY3RvcnkucHJvdG90eXBlLmJ1aWxkU3R5bGVzID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBzdGF0ZU5hbWVcbiAgICAgKiBAcGFyYW0gez99IHBhcmFtc1xuICAgICAqIEBwYXJhbSB7P30gZXJyb3JzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoc3RhdGVOYW1lLCBwYXJhbXMsIGVycm9ycykge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBiYWNrdXBTdGF0ZVN0eWxlciA9IHRoaXMuX3N0YXRlU3R5bGVzWycqJ107XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0YXRlU3R5bGVyID0gdGhpcy5fc3RhdGVTdHlsZXNbc3RhdGVOYW1lXTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYmFja3VwU3R5bGVzID0gYmFja3VwU3RhdGVTdHlsZXIgPyBiYWNrdXBTdGF0ZVN0eWxlci5idWlsZFN0eWxlcyhwYXJhbXMsIGVycm9ycykgOiB7fTtcbiAgICAgICAgcmV0dXJuIHN0YXRlU3R5bGVyID8gc3RhdGVTdHlsZXIuYnVpbGRTdHlsZXMocGFyYW1zLCBlcnJvcnMpIDogYmFja3VwU3R5bGVzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBkcml2ZXJcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0gez99IGN1cnJlbnRTdGF0ZVxuICAgICAqIEBwYXJhbSB7P30gbmV4dFN0YXRlXG4gICAgICogQHBhcmFtIHs/PX0gY3VycmVudE9wdGlvbnNcbiAgICAgKiBAcGFyYW0gez89fSBuZXh0T3B0aW9uc1xuICAgICAqIEBwYXJhbSB7Pz19IHN1Ykluc3RydWN0aW9uc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQW5pbWF0aW9uVHJhbnNpdGlvbkZhY3RvcnkucHJvdG90eXBlLmJ1aWxkID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBkcml2ZXJcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0gez99IGN1cnJlbnRTdGF0ZVxuICAgICAqIEBwYXJhbSB7P30gbmV4dFN0YXRlXG4gICAgICogQHBhcmFtIHs/PX0gY3VycmVudE9wdGlvbnNcbiAgICAgKiBAcGFyYW0gez89fSBuZXh0T3B0aW9uc1xuICAgICAqIEBwYXJhbSB7Pz19IHN1Ykluc3RydWN0aW9uc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKGRyaXZlciwgZWxlbWVudCwgY3VycmVudFN0YXRlLCBuZXh0U3RhdGUsIGN1cnJlbnRPcHRpb25zLCBuZXh0T3B0aW9ucywgc3ViSW5zdHJ1Y3Rpb25zKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVycm9ycyA9IFtdO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0cmFuc2l0aW9uQW5pbWF0aW9uUGFyYW1zID0gdGhpcy5hc3Qub3B0aW9ucyAmJiB0aGlzLmFzdC5vcHRpb25zLnBhcmFtcyB8fCBFTVBUWV9PQkpFQ1Q7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGN1cnJlbnRBbmltYXRpb25QYXJhbXMgPSBjdXJyZW50T3B0aW9ucyAmJiBjdXJyZW50T3B0aW9ucy5wYXJhbXMgfHwgRU1QVFlfT0JKRUNUO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjdXJyZW50U3RhdGVTdHlsZXMgPSB0aGlzLmJ1aWxkU3R5bGVzKGN1cnJlbnRTdGF0ZSwgY3VycmVudEFuaW1hdGlvblBhcmFtcywgZXJyb3JzKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbmV4dEFuaW1hdGlvblBhcmFtcyA9IG5leHRPcHRpb25zICYmIG5leHRPcHRpb25zLnBhcmFtcyB8fCBFTVBUWV9PQkpFQ1Q7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5leHRTdGF0ZVN0eWxlcyA9IHRoaXMuYnVpbGRTdHlsZXMobmV4dFN0YXRlLCBuZXh0QW5pbWF0aW9uUGFyYW1zLCBlcnJvcnMpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBxdWVyaWVkRWxlbWVudHMgPSBuZXcgU2V0KCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHByZVN0eWxlTWFwID0gbmV3IE1hcCgpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwb3N0U3R5bGVNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGlzUmVtb3ZhbCA9IG5leHRTdGF0ZSA9PT0gJ3ZvaWQnO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBhbmltYXRpb25PcHRpb25zID0geyBwYXJhbXM6IF9fYXNzaWduKHt9LCB0cmFuc2l0aW9uQW5pbWF0aW9uUGFyYW1zLCBuZXh0QW5pbWF0aW9uUGFyYW1zKSB9O1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0aW1lbGluZXMgPSBidWlsZEFuaW1hdGlvblRpbWVsaW5lcyhkcml2ZXIsIGVsZW1lbnQsIHRoaXMuYXN0LmFuaW1hdGlvbiwgY3VycmVudFN0YXRlU3R5bGVzLCBuZXh0U3RhdGVTdHlsZXMsIGFuaW1hdGlvbk9wdGlvbnMsIHN1Ykluc3RydWN0aW9ucywgZXJyb3JzKTtcbiAgICAgICAgaWYgKGVycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVUcmFuc2l0aW9uSW5zdHJ1Y3Rpb24oZWxlbWVudCwgdGhpcy5fdHJpZ2dlck5hbWUsIGN1cnJlbnRTdGF0ZSwgbmV4dFN0YXRlLCBpc1JlbW92YWwsIGN1cnJlbnRTdGF0ZVN0eWxlcywgbmV4dFN0YXRlU3R5bGVzLCBbXSwgW10sIHByZVN0eWxlTWFwLCBwb3N0U3R5bGVNYXAsIGVycm9ycyk7XG4gICAgICAgIH1cbiAgICAgICAgdGltZWxpbmVzLmZvckVhY2goZnVuY3Rpb24gKHRsKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlbG0gPSB0bC5lbGVtZW50O1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcHJlUHJvcHMgPSBnZXRPclNldEFzSW5NYXAocHJlU3R5bGVNYXAsIGVsbSwge30pO1xuICAgICAgICAgICAgdGwucHJlU3R5bGVQcm9wcy5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7IHJldHVybiBwcmVQcm9wc1twcm9wXSA9IHRydWU7IH0pO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcG9zdFByb3BzID0gZ2V0T3JTZXRBc0luTWFwKHBvc3RTdHlsZU1hcCwgZWxtLCB7fSk7XG4gICAgICAgICAgICB0bC5wb3N0U3R5bGVQcm9wcy5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7IHJldHVybiBwb3N0UHJvcHNbcHJvcF0gPSB0cnVlOyB9KTtcbiAgICAgICAgICAgIGlmIChlbG0gIT09IGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBxdWVyaWVkRWxlbWVudHMuYWRkKGVsbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBxdWVyaWVkRWxlbWVudHNMaXN0ID0gaXRlcmF0b3JUb0FycmF5KHF1ZXJpZWRFbGVtZW50cy52YWx1ZXMoKSk7XG4gICAgICAgIHJldHVybiBjcmVhdGVUcmFuc2l0aW9uSW5zdHJ1Y3Rpb24oZWxlbWVudCwgdGhpcy5fdHJpZ2dlck5hbWUsIGN1cnJlbnRTdGF0ZSwgbmV4dFN0YXRlLCBpc1JlbW92YWwsIGN1cnJlbnRTdGF0ZVN0eWxlcywgbmV4dFN0YXRlU3R5bGVzLCB0aW1lbGluZXMsIHF1ZXJpZWRFbGVtZW50c0xpc3QsIHByZVN0eWxlTWFwLCBwb3N0U3R5bGVNYXApO1xuICAgIH07XG4gICAgcmV0dXJuIEFuaW1hdGlvblRyYW5zaXRpb25GYWN0b3J5O1xufSgpKTtcbi8qKlxuICogQHBhcmFtIHs/fSBtYXRjaEZuc1xuICogQHBhcmFtIHs/fSBjdXJyZW50U3RhdGVcbiAqIEBwYXJhbSB7P30gbmV4dFN0YXRlXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBvbmVPck1vcmVUcmFuc2l0aW9uc01hdGNoKG1hdGNoRm5zLCBjdXJyZW50U3RhdGUsIG5leHRTdGF0ZSkge1xuICAgIHJldHVybiBtYXRjaEZucy5zb21lKGZ1bmN0aW9uIChmbikgeyByZXR1cm4gZm4oY3VycmVudFN0YXRlLCBuZXh0U3RhdGUpOyB9KTtcbn1cbnZhciBBbmltYXRpb25TdGF0ZVN0eWxlcyA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQW5pbWF0aW9uU3RhdGVTdHlsZXMoc3R5bGVzLCBkZWZhdWx0UGFyYW1zKSB7XG4gICAgICAgIHRoaXMuc3R5bGVzID0gc3R5bGVzO1xuICAgICAgICB0aGlzLmRlZmF1bHRQYXJhbXMgPSBkZWZhdWx0UGFyYW1zO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHBhcmFtc1xuICAgICAqIEBwYXJhbSB7P30gZXJyb3JzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBbmltYXRpb25TdGF0ZVN0eWxlcy5wcm90b3R5cGUuYnVpbGRTdHlsZXMgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IHBhcmFtc1xuICAgICAqIEBwYXJhbSB7P30gZXJyb3JzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAocGFyYW1zLCBlcnJvcnMpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZmluYWxTdHlsZXMgPSB7fTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY29tYmluZWRQYXJhbXMgPSBjb3B5T2JqKHRoaXMuZGVmYXVsdFBhcmFtcyk7XG4gICAgICAgIE9iamVjdC5rZXlzKHBhcmFtcykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2YWx1ZSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb21iaW5lZFBhcmFtc1trZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnN0eWxlcy5zdHlsZXMuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3R5bGVPYmpfMSA9IC8qKiBAdHlwZSB7P30gKi8gKHZhbHVlKTtcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhzdHlsZU9ial8xKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHZhbCA9IHN0eWxlT2JqXzFbcHJvcF07XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWwubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsID0gaW50ZXJwb2xhdGVQYXJhbXModmFsLCBjb21iaW5lZFBhcmFtcywgZXJyb3JzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmaW5hbFN0eWxlc1twcm9wXSA9IHZhbDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBmaW5hbFN0eWxlcztcbiAgICB9O1xuICAgIHJldHVybiBBbmltYXRpb25TdGF0ZVN0eWxlcztcbn0oKSk7XG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBhZGRlZCBieSB0c2lja2xlXG4gKiBAc3VwcHJlc3Mge2NoZWNrVHlwZXN9IGNoZWNrZWQgYnkgdHNjXG4gKi9cbi8qKlxuICogXFxAZXhwZXJpbWVudGFsIEFuaW1hdGlvbiBzdXBwb3J0IGlzIGV4cGVyaW1lbnRhbC5cbiAqIEBwYXJhbSB7P30gbmFtZVxuICogQHBhcmFtIHs/fSBhc3RcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGJ1aWxkVHJpZ2dlcihuYW1lLCBhc3QpIHtcbiAgICByZXR1cm4gbmV3IEFuaW1hdGlvblRyaWdnZXIobmFtZSwgYXN0KTtcbn1cbi8qKlxuICogXFxAZXhwZXJpbWVudGFsIEFuaW1hdGlvbiBzdXBwb3J0IGlzIGV4cGVyaW1lbnRhbC5cbiAqL1xudmFyIEFuaW1hdGlvblRyaWdnZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEFuaW1hdGlvblRyaWdnZXIobmFtZSwgYXN0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuYXN0ID0gYXN0O1xuICAgICAgICB0aGlzLnRyYW5zaXRpb25GYWN0b3JpZXMgPSBbXTtcbiAgICAgICAgdGhpcy5zdGF0ZXMgPSB7fTtcbiAgICAgICAgYXN0LnN0YXRlcy5mb3JFYWNoKGZ1bmN0aW9uIChhc3QpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGRlZmF1bHRQYXJhbXMgPSAoYXN0Lm9wdGlvbnMgJiYgYXN0Lm9wdGlvbnMucGFyYW1zKSB8fCB7fTtcbiAgICAgICAgICAgIF90aGlzLnN0YXRlc1thc3QubmFtZV0gPSBuZXcgQW5pbWF0aW9uU3RhdGVTdHlsZXMoYXN0LnN0eWxlLCBkZWZhdWx0UGFyYW1zKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGJhbGFuY2VQcm9wZXJ0aWVzKHRoaXMuc3RhdGVzLCAndHJ1ZScsICcxJyk7XG4gICAgICAgIGJhbGFuY2VQcm9wZXJ0aWVzKHRoaXMuc3RhdGVzLCAnZmFsc2UnLCAnMCcpO1xuICAgICAgICBhc3QudHJhbnNpdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAoYXN0KSB7XG4gICAgICAgICAgICBfdGhpcy50cmFuc2l0aW9uRmFjdG9yaWVzLnB1c2gobmV3IEFuaW1hdGlvblRyYW5zaXRpb25GYWN0b3J5KG5hbWUsIGFzdCwgX3RoaXMuc3RhdGVzKSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmZhbGxiYWNrVHJhbnNpdGlvbiA9IGNyZWF0ZUZhbGxiYWNrVHJhbnNpdGlvbihuYW1lLCB0aGlzLnN0YXRlcyk7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBbmltYXRpb25UcmlnZ2VyLnByb3RvdHlwZSwgXCJjb250YWluc1F1ZXJpZXNcIiwge1xuICAgICAgICBnZXQ6IC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5hc3QucXVlcnlDb3VudCA+IDA7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gY3VycmVudFN0YXRlXG4gICAgICogQHBhcmFtIHs/fSBuZXh0U3RhdGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFuaW1hdGlvblRyaWdnZXIucHJvdG90eXBlLm1hdGNoVHJhbnNpdGlvbiA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gY3VycmVudFN0YXRlXG4gICAgICogQHBhcmFtIHs/fSBuZXh0U3RhdGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChjdXJyZW50U3RhdGUsIG5leHRTdGF0ZSkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlbnRyeSA9IHRoaXMudHJhbnNpdGlvbkZhY3Rvcmllcy5maW5kKGZ1bmN0aW9uIChmKSB7IHJldHVybiBmLm1hdGNoKGN1cnJlbnRTdGF0ZSwgbmV4dFN0YXRlKTsgfSk7XG4gICAgICAgIHJldHVybiBlbnRyeSB8fCBudWxsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBjdXJyZW50U3RhdGVcbiAgICAgKiBAcGFyYW0gez99IHBhcmFtc1xuICAgICAqIEBwYXJhbSB7P30gZXJyb3JzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBbmltYXRpb25UcmlnZ2VyLnByb3RvdHlwZS5tYXRjaFN0eWxlcyA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gY3VycmVudFN0YXRlXG4gICAgICogQHBhcmFtIHs/fSBwYXJhbXNcbiAgICAgKiBAcGFyYW0gez99IGVycm9yc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKGN1cnJlbnRTdGF0ZSwgcGFyYW1zLCBlcnJvcnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmFsbGJhY2tUcmFuc2l0aW9uLmJ1aWxkU3R5bGVzKGN1cnJlbnRTdGF0ZSwgcGFyYW1zLCBlcnJvcnMpO1xuICAgIH07XG4gICAgcmV0dXJuIEFuaW1hdGlvblRyaWdnZXI7XG59KCkpO1xuLyoqXG4gKiBAcGFyYW0gez99IHRyaWdnZXJOYW1lXG4gKiBAcGFyYW0gez99IHN0YXRlc1xuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gY3JlYXRlRmFsbGJhY2tUcmFuc2l0aW9uKHRyaWdnZXJOYW1lLCBzdGF0ZXMpIHtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBtYXRjaGVycyA9IFtmdW5jdGlvbiAoZnJvbVN0YXRlLCB0b1N0YXRlKSB7IHJldHVybiB0cnVlOyB9XTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBhbmltYXRpb24gPSBuZXcgU2VxdWVuY2VBc3QoW10pO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIHRyYW5zaXRpb24gPSBuZXcgVHJhbnNpdGlvbkFzdChtYXRjaGVycywgYW5pbWF0aW9uKTtcbiAgICByZXR1cm4gbmV3IEFuaW1hdGlvblRyYW5zaXRpb25GYWN0b3J5KHRyaWdnZXJOYW1lLCB0cmFuc2l0aW9uLCBzdGF0ZXMpO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IG9ialxuICogQHBhcmFtIHs/fSBrZXkxXG4gKiBAcGFyYW0gez99IGtleTJcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGJhbGFuY2VQcm9wZXJ0aWVzKG9iaiwga2V5MSwga2V5Mikge1xuICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoa2V5MSkpIHtcbiAgICAgICAgaWYgKCFvYmouaGFzT3duUHJvcGVydHkoa2V5MikpIHtcbiAgICAgICAgICAgIG9ialtrZXkyXSA9IG9ialtrZXkxXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChvYmouaGFzT3duUHJvcGVydHkoa2V5MikpIHtcbiAgICAgICAgb2JqW2tleTFdID0gb2JqW2tleTJdO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IGFkZGVkIGJ5IHRzaWNrbGVcbiAqIEBzdXBwcmVzcyB7Y2hlY2tUeXBlc30gY2hlY2tlZCBieSB0c2NcbiAqL1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xudmFyIEVNUFRZX0lOU1RSVUNUSU9OX01BUCA9IG5ldyBFbGVtZW50SW5zdHJ1Y3Rpb25NYXAoKTtcbnZhciBUaW1lbGluZUFuaW1hdGlvbkVuZ2luZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVGltZWxpbmVBbmltYXRpb25FbmdpbmUoX2RyaXZlciwgX25vcm1hbGl6ZXIpIHtcbiAgICAgICAgdGhpcy5fZHJpdmVyID0gX2RyaXZlcjtcbiAgICAgICAgdGhpcy5fbm9ybWFsaXplciA9IF9ub3JtYWxpemVyO1xuICAgICAgICB0aGlzLl9hbmltYXRpb25zID0ge307XG4gICAgICAgIHRoaXMuX3BsYXllcnNCeUlkID0ge307XG4gICAgICAgIHRoaXMucGxheWVycyA9IFtdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGlkXG4gICAgICogQHBhcmFtIHs/fSBtZXRhZGF0YVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVGltZWxpbmVBbmltYXRpb25FbmdpbmUucHJvdG90eXBlLnJlZ2lzdGVyID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBpZFxuICAgICAqIEBwYXJhbSB7P30gbWV0YWRhdGFcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChpZCwgbWV0YWRhdGEpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZXJyb3JzID0gW107XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGFzdCA9IGJ1aWxkQW5pbWF0aW9uQXN0KHRoaXMuX2RyaXZlciwgbWV0YWRhdGEsIGVycm9ycyk7XG4gICAgICAgIGlmIChlcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gYnVpbGQgdGhlIGFuaW1hdGlvbiBkdWUgdG8gdGhlIGZvbGxvd2luZyBlcnJvcnM6IFwiICsgZXJyb3JzLmpvaW4oXCJcXG5cIikpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fYW5pbWF0aW9uc1tpZF0gPSBhc3Q7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gaVxuICAgICAqIEBwYXJhbSB7P30gcHJlU3R5bGVzXG4gICAgICogQHBhcmFtIHs/PX0gcG9zdFN0eWxlc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVGltZWxpbmVBbmltYXRpb25FbmdpbmUucHJvdG90eXBlLl9idWlsZFBsYXllciA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gaVxuICAgICAqIEBwYXJhbSB7P30gcHJlU3R5bGVzXG4gICAgICogQHBhcmFtIHs/PX0gcG9zdFN0eWxlc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKGksIHByZVN0eWxlcywgcG9zdFN0eWxlcykge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlbGVtZW50ID0gaS5lbGVtZW50O1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBrZXlmcmFtZXMgPSBub3JtYWxpemVLZXlmcmFtZXModGhpcy5fZHJpdmVyLCB0aGlzLl9ub3JtYWxpemVyLCBlbGVtZW50LCBpLmtleWZyYW1lcywgcHJlU3R5bGVzLCBwb3N0U3R5bGVzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RyaXZlci5hbmltYXRlKGVsZW1lbnQsIGtleWZyYW1lcywgaS5kdXJhdGlvbiwgaS5kZWxheSwgaS5lYXNpbmcsIFtdKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gaWRcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0gez89fSBvcHRpb25zXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUaW1lbGluZUFuaW1hdGlvbkVuZ2luZS5wcm90b3R5cGUuY3JlYXRlID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBpZFxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFxuICAgICAqIEBwYXJhbSB7Pz19IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChpZCwgZWxlbWVudCwgb3B0aW9ucykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlcnJvcnMgPSBbXTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYXN0ID0gdGhpcy5fYW5pbWF0aW9uc1tpZF07XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGluc3RydWN0aW9ucztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYXV0b1N0eWxlc01hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgaWYgKGFzdCkge1xuICAgICAgICAgICAgaW5zdHJ1Y3Rpb25zID0gYnVpbGRBbmltYXRpb25UaW1lbGluZXModGhpcy5fZHJpdmVyLCBlbGVtZW50LCBhc3QsIHt9LCB7fSwgb3B0aW9ucywgRU1QVFlfSU5TVFJVQ1RJT05fTUFQLCBlcnJvcnMpO1xuICAgICAgICAgICAgaW5zdHJ1Y3Rpb25zLmZvckVhY2goZnVuY3Rpb24gKGluc3QpIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdHlsZXMgPSBnZXRPclNldEFzSW5NYXAoYXV0b1N0eWxlc01hcCwgaW5zdC5lbGVtZW50LCB7fSk7XG4gICAgICAgICAgICAgICAgaW5zdC5wb3N0U3R5bGVQcm9wcy5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7IHJldHVybiBzdHlsZXNbcHJvcF0gPSBudWxsOyB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZXJyb3JzLnB1c2goJ1RoZSByZXF1ZXN0ZWQgYW5pbWF0aW9uIGRvZXNuXFwndCBleGlzdCBvciBoYXMgYWxyZWFkeSBiZWVuIGRlc3Ryb3llZCcpO1xuICAgICAgICAgICAgaW5zdHJ1Y3Rpb25zID0gW107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byBjcmVhdGUgdGhlIGFuaW1hdGlvbiBkdWUgdG8gdGhlIGZvbGxvd2luZyBlcnJvcnM6IFwiICsgZXJyb3JzLmpvaW4oXCJcXG5cIikpO1xuICAgICAgICB9XG4gICAgICAgIGF1dG9TdHlsZXNNYXAuZm9yRWFjaChmdW5jdGlvbiAoc3R5bGVzLCBlbGVtZW50KSB7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhzdHlsZXMpLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHsgc3R5bGVzW3Byb3BdID0gX3RoaXMuX2RyaXZlci5jb21wdXRlU3R5bGUoZWxlbWVudCwgcHJvcCwgX2FuZ3VsYXJfYW5pbWF0aW9ucy5BVVRPX1NUWUxFKTsgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwbGF5ZXJzID0gaW5zdHJ1Y3Rpb25zLm1hcChmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3R5bGVzID0gYXV0b1N0eWxlc01hcC5nZXQoaS5lbGVtZW50KTtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5fYnVpbGRQbGF5ZXIoaSwge30sIHN0eWxlcyk7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwbGF5ZXIgPSBvcHRpbWl6ZUdyb3VwUGxheWVyKHBsYXllcnMpO1xuICAgICAgICB0aGlzLl9wbGF5ZXJzQnlJZFtpZF0gPSBwbGF5ZXI7XG4gICAgICAgIHBsYXllci5vbkRlc3Ryb3koZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuZGVzdHJveShpZCk7IH0pO1xuICAgICAgICB0aGlzLnBsYXllcnMucHVzaChwbGF5ZXIpO1xuICAgICAgICByZXR1cm4gcGxheWVyO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBpZFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVGltZWxpbmVBbmltYXRpb25FbmdpbmUucHJvdG90eXBlLmRlc3Ryb3kgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IGlkXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGxheWVyID0gdGhpcy5fZ2V0UGxheWVyKGlkKTtcbiAgICAgICAgcGxheWVyLmRlc3Ryb3koKTtcbiAgICAgICAgZGVsZXRlIHRoaXMuX3BsYXllcnNCeUlkW2lkXTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaW5kZXggPSB0aGlzLnBsYXllcnMuaW5kZXhPZihwbGF5ZXIpO1xuICAgICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICAgICAgdGhpcy5wbGF5ZXJzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gaWRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRpbWVsaW5lQW5pbWF0aW9uRW5naW5lLnByb3RvdHlwZS5fZ2V0UGxheWVyID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBpZFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBsYXllciA9IHRoaXMuX3BsYXllcnNCeUlkW2lkXTtcbiAgICAgICAgaWYgKCFwbGF5ZXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byBmaW5kIHRoZSB0aW1lbGluZSBwbGF5ZXIgcmVmZXJlbmNlZCBieSBcIiArIGlkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGxheWVyO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBpZFxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFxuICAgICAqIEBwYXJhbSB7P30gZXZlbnROYW1lXG4gICAgICogQHBhcmFtIHs/fSBjYWxsYmFja1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVGltZWxpbmVBbmltYXRpb25FbmdpbmUucHJvdG90eXBlLmxpc3RlbiA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gaWRcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0gez99IGV2ZW50TmFtZVxuICAgICAqIEBwYXJhbSB7P30gY2FsbGJhY2tcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChpZCwgZWxlbWVudCwgZXZlbnROYW1lLCBjYWxsYmFjaykge1xuICAgICAgICAvLyB0cmlnZ2VyTmFtZSwgZnJvbVN0YXRlLCB0b1N0YXRlIGFyZSBhbGwgaWdub3JlZCBmb3IgdGltZWxpbmUgYW5pbWF0aW9uc1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBiYXNlRXZlbnQgPSBtYWtlQW5pbWF0aW9uRXZlbnQoZWxlbWVudCwgJycsICcnLCAnJyk7XG4gICAgICAgIGxpc3Rlbk9uUGxheWVyKHRoaXMuX2dldFBsYXllcihpZCksIGV2ZW50TmFtZSwgYmFzZUV2ZW50LCBjYWxsYmFjayk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IH07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGlkXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XG4gICAgICogQHBhcmFtIHs/fSBjb21tYW5kXG4gICAgICogQHBhcmFtIHs/fSBhcmdzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUaW1lbGluZUFuaW1hdGlvbkVuZ2luZS5wcm90b3R5cGUuY29tbWFuZCA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gaWRcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0gez99IGNvbW1hbmRcbiAgICAgKiBAcGFyYW0gez99IGFyZ3NcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChpZCwgZWxlbWVudCwgY29tbWFuZCwgYXJncykge1xuICAgICAgICBpZiAoY29tbWFuZCA9PSAncmVnaXN0ZXInKSB7XG4gICAgICAgICAgICB0aGlzLnJlZ2lzdGVyKGlkLCAvKiogQHR5cGUgez99ICovIChhcmdzWzBdKSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbW1hbmQgPT0gJ2NyZWF0ZScpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG9wdGlvbnMgPSAvKiogQHR5cGUgez99ICovICgoYXJnc1swXSB8fCB7fSkpO1xuICAgICAgICAgICAgdGhpcy5jcmVhdGUoaWQsIGVsZW1lbnQsIG9wdGlvbnMpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBsYXllciA9IHRoaXMuX2dldFBsYXllcihpZCk7XG4gICAgICAgIHN3aXRjaCAoY29tbWFuZCkge1xuICAgICAgICAgICAgY2FzZSAncGxheSc6XG4gICAgICAgICAgICAgICAgcGxheWVyLnBsYXkoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3BhdXNlJzpcbiAgICAgICAgICAgICAgICBwbGF5ZXIucGF1c2UoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3Jlc2V0JzpcbiAgICAgICAgICAgICAgICBwbGF5ZXIucmVzZXQoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3Jlc3RhcnQnOlxuICAgICAgICAgICAgICAgIHBsYXllci5yZXN0YXJ0KCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdmaW5pc2gnOlxuICAgICAgICAgICAgICAgIHBsYXllci5maW5pc2goKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2luaXQnOlxuICAgICAgICAgICAgICAgIHBsYXllci5pbml0KCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdzZXRQb3NpdGlvbic6XG4gICAgICAgICAgICAgICAgcGxheWVyLnNldFBvc2l0aW9uKHBhcnNlRmxvYXQoLyoqIEB0eXBlIHs/fSAqLyAoYXJnc1swXSkpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2Rlc3Ryb3knOlxuICAgICAgICAgICAgICAgIHRoaXMuZGVzdHJveShpZCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBUaW1lbGluZUFuaW1hdGlvbkVuZ2luZTtcbn0oKSk7XG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBhZGRlZCBieSB0c2lja2xlXG4gKiBAc3VwcHJlc3Mge2NoZWNrVHlwZXN9IGNoZWNrZWQgYnkgdHNjXG4gKi9cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBRVUVVRURfQ0xBU1NOQU1FID0gJ25nLWFuaW1hdGUtcXVldWVkJztcbnZhciBRVUVVRURfU0VMRUNUT1IgPSAnLm5nLWFuaW1hdGUtcXVldWVkJztcbnZhciBESVNBQkxFRF9DTEFTU05BTUUgPSAnbmctYW5pbWF0ZS1kaXNhYmxlZCc7XG52YXIgRElTQUJMRURfU0VMRUNUT1IgPSAnLm5nLWFuaW1hdGUtZGlzYWJsZWQnO1xudmFyIEVNUFRZX1BMQVlFUl9BUlJBWSA9IFtdO1xudmFyIE5VTExfUkVNT1ZBTF9TVEFURSA9IHtcbiAgICBuYW1lc3BhY2VJZDogJycsXG4gICAgc2V0Rm9yUmVtb3ZhbDogbnVsbCxcbiAgICBoYXNBbmltYXRpb246IGZhbHNlLFxuICAgIHJlbW92ZWRCZWZvcmVRdWVyaWVkOiBmYWxzZVxufTtcbnZhciBOVUxMX1JFTU9WRURfUVVFUklFRF9TVEFURSA9IHtcbiAgICBuYW1lc3BhY2VJZDogJycsXG4gICAgc2V0Rm9yUmVtb3ZhbDogbnVsbCxcbiAgICBoYXNBbmltYXRpb246IGZhbHNlLFxuICAgIHJlbW92ZWRCZWZvcmVRdWVyaWVkOiB0cnVlXG59O1xuLyoqXG4gKiBAcmVjb3JkXG4gKi9cblxudmFyIFJFTU9WQUxfRkxBRyA9ICdfX25nX3JlbW92ZWQnO1xuLyoqXG4gKiBAcmVjb3JkXG4gKi9cblxudmFyIFN0YXRlVmFsdWUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFN0YXRlVmFsdWUoaW5wdXQpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaXNPYmogPSBpbnB1dCAmJiBpbnB1dC5oYXNPd25Qcm9wZXJ0eSgndmFsdWUnKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmFsdWUgPSBpc09iaiA/IGlucHV0Wyd2YWx1ZSddIDogaW5wdXQ7XG4gICAgICAgIHRoaXMudmFsdWUgPSBub3JtYWxpemVUcmlnZ2VyVmFsdWUodmFsdWUpO1xuICAgICAgICBpZiAoaXNPYmopIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG9wdGlvbnMgPSBjb3B5T2JqKC8qKiBAdHlwZSB7P30gKi8gKGlucHV0KSk7XG4gICAgICAgICAgICBkZWxldGUgb3B0aW9uc1sndmFsdWUnXTtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucyA9IC8qKiBAdHlwZSB7P30gKi8gKG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zID0ge307XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMucGFyYW1zKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMucGFyYW1zID0ge307XG4gICAgICAgIH1cbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFN0YXRlVmFsdWUucHJvdG90eXBlLCBcInBhcmFtc1wiLCB7XG4gICAgICAgIGdldDogLyoqXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiAoKSB7IHJldHVybiAvKiogQHR5cGUgez99ICovICh0aGlzLm9wdGlvbnMucGFyYW1zKTsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBvcHRpb25zXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTdGF0ZVZhbHVlLnByb3RvdHlwZS5hYnNvcmJPcHRpb25zID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBvcHRpb25zXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBuZXdQYXJhbXMgPSBvcHRpb25zLnBhcmFtcztcbiAgICAgICAgaWYgKG5ld1BhcmFtcykge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gb2xkUGFyYW1zXzEgPSAvKiogQHR5cGUgez99ICovICgodGhpcy5vcHRpb25zLnBhcmFtcykpO1xuICAgICAgICAgICAgT2JqZWN0LmtleXMobmV3UGFyYW1zKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9sZFBhcmFtc18xW3Byb3BdID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgb2xkUGFyYW1zXzFbcHJvcF0gPSBuZXdQYXJhbXNbcHJvcF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBTdGF0ZVZhbHVlO1xufSgpKTtcbnZhciBWT0lEX1ZBTFVFID0gJ3ZvaWQnO1xudmFyIERFRkFVTFRfU1RBVEVfVkFMVUUgPSBuZXcgU3RhdGVWYWx1ZShWT0lEX1ZBTFVFKTtcbnZhciBERUxFVEVEX1NUQVRFX1ZBTFVFID0gbmV3IFN0YXRlVmFsdWUoJ0RFTEVURUQnKTtcbnZhciBBbmltYXRpb25UcmFuc2l0aW9uTmFtZXNwYWNlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBbmltYXRpb25UcmFuc2l0aW9uTmFtZXNwYWNlKGlkLCBob3N0RWxlbWVudCwgX2VuZ2luZSkge1xuICAgICAgICB0aGlzLmlkID0gaWQ7XG4gICAgICAgIHRoaXMuaG9zdEVsZW1lbnQgPSBob3N0RWxlbWVudDtcbiAgICAgICAgdGhpcy5fZW5naW5lID0gX2VuZ2luZTtcbiAgICAgICAgdGhpcy5wbGF5ZXJzID0gW107XG4gICAgICAgIHRoaXMuX3RyaWdnZXJzID0ge307XG4gICAgICAgIHRoaXMuX3F1ZXVlID0gW107XG4gICAgICAgIHRoaXMuX2VsZW1lbnRMaXN0ZW5lcnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX2hvc3RDbGFzc05hbWUgPSAnbmctdG5zLScgKyBpZDtcbiAgICAgICAgYWRkQ2xhc3MoaG9zdEVsZW1lbnQsIHRoaXMuX2hvc3RDbGFzc05hbWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKiBAcGFyYW0gez99IHBoYXNlXG4gICAgICogQHBhcmFtIHs/fSBjYWxsYmFja1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQW5pbWF0aW9uVHJhbnNpdGlvbk5hbWVzcGFjZS5wcm90b3R5cGUubGlzdGVuID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHBhcmFtIHs/fSBwaGFzZVxuICAgICAqIEBwYXJhbSB7P30gY2FsbGJhY2tcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChlbGVtZW50LCBuYW1lLCBwaGFzZSwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKCF0aGlzLl90cmlnZ2Vycy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIGxpc3RlbiBvbiB0aGUgYW5pbWF0aW9uIHRyaWdnZXIgZXZlbnQgXFxcIlwiICsgcGhhc2UgKyBcIlxcXCIgYmVjYXVzZSB0aGUgYW5pbWF0aW9uIHRyaWdnZXIgXFxcIlwiICsgbmFtZSArIFwiXFxcIiBkb2Vzbid0IGV4aXN0IVwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGhhc2UgPT0gbnVsbCB8fCBwaGFzZS5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIGxpc3RlbiBvbiB0aGUgYW5pbWF0aW9uIHRyaWdnZXIgXFxcIlwiICsgbmFtZSArIFwiXFxcIiBiZWNhdXNlIHRoZSBwcm92aWRlZCBldmVudCBpcyB1bmRlZmluZWQhXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNUcmlnZ2VyRXZlbnRWYWxpZChwaGFzZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBwcm92aWRlZCBhbmltYXRpb24gdHJpZ2dlciBldmVudCBcXFwiXCIgKyBwaGFzZSArIFwiXFxcIiBmb3IgdGhlIGFuaW1hdGlvbiB0cmlnZ2VyIFxcXCJcIiArIG5hbWUgKyBcIlxcXCIgaXMgbm90IHN1cHBvcnRlZCFcIik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbGlzdGVuZXJzID0gZ2V0T3JTZXRBc0luTWFwKHRoaXMuX2VsZW1lbnRMaXN0ZW5lcnMsIGVsZW1lbnQsIFtdKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZGF0YSA9IHsgbmFtZTogbmFtZSwgcGhhc2U6IHBoYXNlLCBjYWxsYmFjazogY2FsbGJhY2sgfTtcbiAgICAgICAgbGlzdGVuZXJzLnB1c2goZGF0YSk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRyaWdnZXJzV2l0aFN0YXRlcyA9IGdldE9yU2V0QXNJbk1hcCh0aGlzLl9lbmdpbmUuc3RhdGVzQnlFbGVtZW50LCBlbGVtZW50LCB7fSk7XG4gICAgICAgIGlmICghdHJpZ2dlcnNXaXRoU3RhdGVzLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgICBhZGRDbGFzcyhlbGVtZW50LCBOR19UUklHR0VSX0NMQVNTTkFNRSk7XG4gICAgICAgICAgICBhZGRDbGFzcyhlbGVtZW50LCBOR19UUklHR0VSX0NMQVNTTkFNRSArICctJyArIG5hbWUpO1xuICAgICAgICAgICAgdHJpZ2dlcnNXaXRoU3RhdGVzW25hbWVdID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gdGhlIGV2ZW50IGxpc3RlbmVyIGlzIHJlbW92ZWQgQUZURVIgdGhlIGZsdXNoIGhhcyBvY2N1cnJlZCBzdWNoXG4gICAgICAgICAgICAvLyB0aGF0IGxlYXZlIGFuaW1hdGlvbnMgY2FsbGJhY2tzIGNhbiBmaXJlIChvdGhlcndpc2UgaWYgdGhlIG5vZGVcbiAgICAgICAgICAgIC8vIGlzIHJlbW92ZWQgaW4gYmV0d2VlbiB0aGVuIHRoZSBsaXN0ZW5lcnMgd291bGQgYmUgZGVyZWdpc3RlcmVkKVxuICAgICAgICAgICAgLy8gdGhlIGV2ZW50IGxpc3RlbmVyIGlzIHJlbW92ZWQgQUZURVIgdGhlIGZsdXNoIGhhcyBvY2N1cnJlZCBzdWNoXG4gICAgICAgICAgICAvLyB0aGF0IGxlYXZlIGFuaW1hdGlvbnMgY2FsbGJhY2tzIGNhbiBmaXJlIChvdGhlcndpc2UgaWYgdGhlIG5vZGVcbiAgICAgICAgICAgIC8vIGlzIHJlbW92ZWQgaW4gYmV0d2VlbiB0aGVuIHRoZSBsaXN0ZW5lcnMgd291bGQgYmUgZGVyZWdpc3RlcmVkKVxuICAgICAgICAgICAgX3RoaXMuX2VuZ2luZS5hZnRlckZsdXNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpbmRleCA9IGxpc3RlbmVycy5pbmRleE9mKGRhdGEpO1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIV90aGlzLl90cmlnZ2Vyc1tuYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdHJpZ2dlcnNXaXRoU3RhdGVzW25hbWVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFuaW1hdGlvblRyYW5zaXRpb25OYW1lc3BhY2UucHJvdG90eXBlLnJlZ2lzdGVyID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChuYW1lLCBhc3QpIHtcbiAgICAgICAgaWYgKHRoaXMuX3RyaWdnZXJzW25hbWVdKSB7XG4gICAgICAgICAgICAvLyB0aHJvd1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fdHJpZ2dlcnNbbmFtZV0gPSBhc3Q7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBbmltYXRpb25UcmFuc2l0aW9uTmFtZXNwYWNlLnByb3RvdHlwZS5fZ2V0VHJpZ2dlciA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdHJpZ2dlciA9IHRoaXMuX3RyaWdnZXJzW25hbWVdO1xuICAgICAgICBpZiAoIXRyaWdnZXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBwcm92aWRlZCBhbmltYXRpb24gdHJpZ2dlciBcXFwiXCIgKyBuYW1lICsgXCJcXFwiIGhhcyBub3QgYmVlbiByZWdpc3RlcmVkIVwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJpZ2dlcjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFxuICAgICAqIEBwYXJhbSB7P30gdHJpZ2dlck5hbWVcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICogQHBhcmFtIHs/PX0gZGVmYXVsdFRvRmFsbGJhY2tcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFuaW1hdGlvblRyYW5zaXRpb25OYW1lc3BhY2UucHJvdG90eXBlLnRyaWdnZXIgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0gez99IHRyaWdnZXJOYW1lXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Pz19IGRlZmF1bHRUb0ZhbGxiYWNrXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoZWxlbWVudCwgdHJpZ2dlck5hbWUsIHZhbHVlLCBkZWZhdWx0VG9GYWxsYmFjaykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoZGVmYXVsdFRvRmFsbGJhY2sgPT09IHZvaWQgMCkgeyBkZWZhdWx0VG9GYWxsYmFjayA9IHRydWU7IH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdHJpZ2dlciA9IHRoaXMuX2dldFRyaWdnZXIodHJpZ2dlck5hbWUpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwbGF5ZXIgPSBuZXcgVHJhbnNpdGlvbkFuaW1hdGlvblBsYXllcih0aGlzLmlkLCB0cmlnZ2VyTmFtZSwgZWxlbWVudCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRyaWdnZXJzV2l0aFN0YXRlcyA9IHRoaXMuX2VuZ2luZS5zdGF0ZXNCeUVsZW1lbnQuZ2V0KGVsZW1lbnQpO1xuICAgICAgICBpZiAoIXRyaWdnZXJzV2l0aFN0YXRlcykge1xuICAgICAgICAgICAgYWRkQ2xhc3MoZWxlbWVudCwgTkdfVFJJR0dFUl9DTEFTU05BTUUpO1xuICAgICAgICAgICAgYWRkQ2xhc3MoZWxlbWVudCwgTkdfVFJJR0dFUl9DTEFTU05BTUUgKyAnLScgKyB0cmlnZ2VyTmFtZSk7XG4gICAgICAgICAgICB0aGlzLl9lbmdpbmUuc3RhdGVzQnlFbGVtZW50LnNldChlbGVtZW50LCB0cmlnZ2Vyc1dpdGhTdGF0ZXMgPSB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZnJvbVN0YXRlID0gdHJpZ2dlcnNXaXRoU3RhdGVzW3RyaWdnZXJOYW1lXTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdG9TdGF0ZSA9IG5ldyBTdGF0ZVZhbHVlKHZhbHVlKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaXNPYmogPSB2YWx1ZSAmJiB2YWx1ZS5oYXNPd25Qcm9wZXJ0eSgndmFsdWUnKTtcbiAgICAgICAgaWYgKCFpc09iaiAmJiBmcm9tU3RhdGUpIHtcbiAgICAgICAgICAgIHRvU3RhdGUuYWJzb3JiT3B0aW9ucyhmcm9tU3RhdGUub3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgdHJpZ2dlcnNXaXRoU3RhdGVzW3RyaWdnZXJOYW1lXSA9IHRvU3RhdGU7XG4gICAgICAgIGlmICghZnJvbVN0YXRlKSB7XG4gICAgICAgICAgICBmcm9tU3RhdGUgPSBERUZBVUxUX1NUQVRFX1ZBTFVFO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGZyb21TdGF0ZSA9PT0gREVMRVRFRF9TVEFURV9WQUxVRSkge1xuICAgICAgICAgICAgcmV0dXJuIHBsYXllcjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpc1JlbW92YWwgPSB0b1N0YXRlLnZhbHVlID09PSBWT0lEX1ZBTFVFO1xuICAgICAgICAvLyBub3JtYWxseSB0aGlzIGlzbid0IHJlYWNoZWQgYnkgaGVyZSwgaG93ZXZlciwgaWYgYW4gb2JqZWN0IGV4cHJlc3Npb25cbiAgICAgICAgLy8gaXMgcGFzc2VkIGluIHRoZW4gaXQgbWF5IGJlIGEgbmV3IG9iamVjdCBlYWNoIHRpbWUuIENvbXBhcmluZyB0aGUgdmFsdWVcbiAgICAgICAgLy8gaXMgaW1wb3J0YW50IHNpbmNlIHRoYXQgd2lsbCBzdGF5IHRoZSBzYW1lIGRlc3BpdGUgdGhlcmUgYmVpbmcgYSBuZXcgb2JqZWN0LlxuICAgICAgICAvLyBUaGUgcmVtb3ZhbCBhcmMgaGVyZSBpcyBzcGVjaWFsIGNhc2VkIGJlY2F1c2UgdGhlIHNhbWUgZWxlbWVudCBpcyB0cmlnZ2VyZWRcbiAgICAgICAgLy8gdHdpY2UgaW4gdGhlIGV2ZW50IHRoYXQgaXQgY29udGFpbnMgYW5pbWF0aW9ucyBvbiB0aGUgb3V0ZXIvaW5uZXIgcG9ydGlvbnNcbiAgICAgICAgLy8gb2YgdGhlIGhvc3QgY29udGFpbmVyXG4gICAgICAgIGlmICghaXNSZW1vdmFsICYmIGZyb21TdGF0ZS52YWx1ZSA9PT0gdG9TdGF0ZS52YWx1ZSkge1xuICAgICAgICAgICAgLy8gdGhpcyBtZWFucyB0aGF0IGRlc3BpdGUgdGhlIHZhbHVlIG5vdCBjaGFuZ2luZywgc29tZSBpbm5lciBwYXJhbXNcbiAgICAgICAgICAgIC8vIGhhdmUgY2hhbmdlZCB3aGljaCBtZWFucyB0aGF0IHRoZSBhbmltYXRpb24gZmluYWwgc3R5bGVzIG5lZWQgdG8gYmUgYXBwbGllZFxuICAgICAgICAgICAgaWYgKCFvYmpFcXVhbHMoZnJvbVN0YXRlLnBhcmFtcywgdG9TdGF0ZS5wYXJhbXMpKSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZXJyb3JzID0gW107XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZnJvbVN0eWxlc18xID0gdHJpZ2dlci5tYXRjaFN0eWxlcyhmcm9tU3RhdGUudmFsdWUsIGZyb21TdGF0ZS5wYXJhbXMsIGVycm9ycyk7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdG9TdHlsZXNfMSA9IHRyaWdnZXIubWF0Y2hTdHlsZXModG9TdGF0ZS52YWx1ZSwgdG9TdGF0ZS5wYXJhbXMsIGVycm9ycyk7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZW5naW5lLnJlcG9ydEVycm9yKGVycm9ycyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9lbmdpbmUuYWZ0ZXJGbHVzaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcmFzZVN0eWxlcyhlbGVtZW50LCBmcm9tU3R5bGVzXzEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0U3R5bGVzKGVsZW1lbnQsIHRvU3R5bGVzXzEpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGxheWVyc09uRWxlbWVudCA9IGdldE9yU2V0QXNJbk1hcCh0aGlzLl9lbmdpbmUucGxheWVyc0J5RWxlbWVudCwgZWxlbWVudCwgW10pO1xuICAgICAgICBwbGF5ZXJzT25FbGVtZW50LmZvckVhY2goZnVuY3Rpb24gKHBsYXllcikge1xuICAgICAgICAgICAgLy8gb25seSByZW1vdmUgdGhlIHBsYXllciBpZiBpdCBpcyBxdWV1ZWQgb24gdGhlIEVYQUNUIHNhbWUgdHJpZ2dlci9uYW1lc3BhY2VcbiAgICAgICAgICAgIC8vIHdlIG9ubHkgYWxzbyBkZWFsIHdpdGggcXVldWVkIHBsYXllcnMgaGVyZSBiZWNhdXNlIGlmIHRoZSBhbmltYXRpb24gaGFzXG4gICAgICAgICAgICAvLyBzdGFydGVkIHRoZW4gd2Ugd2FudCB0byBrZWVwIHRoZSBwbGF5ZXIgYWxpdmUgdW50aWwgdGhlIGZsdXNoIGhhcHBlbnNcbiAgICAgICAgICAgIC8vICh3aGljaCBpcyB3aGVyZSB0aGUgcHJldmlvdXNQbGF5ZXJzIGFyZSBwYXNzZWQgaW50byB0aGUgbmV3IHBhbHllcilcbiAgICAgICAgICAgIGlmIChwbGF5ZXIubmFtZXNwYWNlSWQgPT0gX3RoaXMuaWQgJiYgcGxheWVyLnRyaWdnZXJOYW1lID09IHRyaWdnZXJOYW1lICYmIHBsYXllci5xdWV1ZWQpIHtcbiAgICAgICAgICAgICAgICBwbGF5ZXIuZGVzdHJveSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdHJhbnNpdGlvbiA9IHRyaWdnZXIubWF0Y2hUcmFuc2l0aW9uKGZyb21TdGF0ZS52YWx1ZSwgdG9TdGF0ZS52YWx1ZSk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGlzRmFsbGJhY2tUcmFuc2l0aW9uID0gZmFsc2U7XG4gICAgICAgIGlmICghdHJhbnNpdGlvbikge1xuICAgICAgICAgICAgaWYgKCFkZWZhdWx0VG9GYWxsYmFjaylcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB0cmFuc2l0aW9uID0gdHJpZ2dlci5mYWxsYmFja1RyYW5zaXRpb247XG4gICAgICAgICAgICBpc0ZhbGxiYWNrVHJhbnNpdGlvbiA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZW5naW5lLnRvdGFsUXVldWVkUGxheWVycysrO1xuICAgICAgICB0aGlzLl9xdWV1ZS5wdXNoKHsgZWxlbWVudDogZWxlbWVudCwgdHJpZ2dlck5hbWU6IHRyaWdnZXJOYW1lLCB0cmFuc2l0aW9uOiB0cmFuc2l0aW9uLCBmcm9tU3RhdGU6IGZyb21TdGF0ZSwgdG9TdGF0ZTogdG9TdGF0ZSwgcGxheWVyOiBwbGF5ZXIsIGlzRmFsbGJhY2tUcmFuc2l0aW9uOiBpc0ZhbGxiYWNrVHJhbnNpdGlvbiB9KTtcbiAgICAgICAgaWYgKCFpc0ZhbGxiYWNrVHJhbnNpdGlvbikge1xuICAgICAgICAgICAgYWRkQ2xhc3MoZWxlbWVudCwgUVVFVUVEX0NMQVNTTkFNRSk7XG4gICAgICAgICAgICBwbGF5ZXIub25TdGFydChmdW5jdGlvbiAoKSB7IHJlbW92ZUNsYXNzKGVsZW1lbnQsIFFVRVVFRF9DTEFTU05BTUUpOyB9KTtcbiAgICAgICAgfVxuICAgICAgICBwbGF5ZXIub25Eb25lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGluZGV4ID0gX3RoaXMucGxheWVycy5pbmRleE9mKHBsYXllcik7XG4gICAgICAgICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICAgICAgICAgIF90aGlzLnBsYXllcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBsYXllcnMgPSBfdGhpcy5fZW5naW5lLnBsYXllcnNCeUVsZW1lbnQuZ2V0KGVsZW1lbnQpO1xuICAgICAgICAgICAgaWYgKHBsYXllcnMpIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpbmRleF8xID0gcGxheWVycy5pbmRleE9mKHBsYXllcik7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4XzEgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICBwbGF5ZXJzLnNwbGljZShpbmRleF8xLCAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnBsYXllcnMucHVzaChwbGF5ZXIpO1xuICAgICAgICBwbGF5ZXJzT25FbGVtZW50LnB1c2gocGxheWVyKTtcbiAgICAgICAgcmV0dXJuIHBsYXllcjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQW5pbWF0aW9uVHJhbnNpdGlvbk5hbWVzcGFjZS5wcm90b3R5cGUuZGVyZWdpc3RlciA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgZGVsZXRlIHRoaXMuX3RyaWdnZXJzW25hbWVdO1xuICAgICAgICB0aGlzLl9lbmdpbmUuc3RhdGVzQnlFbGVtZW50LmZvckVhY2goZnVuY3Rpb24gKHN0YXRlTWFwLCBlbGVtZW50KSB7IGRlbGV0ZSBzdGF0ZU1hcFtuYW1lXTsgfSk7XG4gICAgICAgIHRoaXMuX2VsZW1lbnRMaXN0ZW5lcnMuZm9yRWFjaChmdW5jdGlvbiAobGlzdGVuZXJzLCBlbGVtZW50KSB7XG4gICAgICAgICAgICBfdGhpcy5fZWxlbWVudExpc3RlbmVycy5zZXQoZWxlbWVudCwgbGlzdGVuZXJzLmZpbHRlcihmdW5jdGlvbiAoZW50cnkpIHsgcmV0dXJuIGVudHJ5Lm5hbWUgIT0gbmFtZTsgfSkpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQW5pbWF0aW9uVHJhbnNpdGlvbk5hbWVzcGFjZS5wcm90b3R5cGUuY2xlYXJFbGVtZW50Q2FjaGUgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgIHRoaXMuX2VuZ2luZS5zdGF0ZXNCeUVsZW1lbnQuZGVsZXRlKGVsZW1lbnQpO1xuICAgICAgICB0aGlzLl9lbGVtZW50TGlzdGVuZXJzLmRlbGV0ZShlbGVtZW50KTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZWxlbWVudFBsYXllcnMgPSB0aGlzLl9lbmdpbmUucGxheWVyc0J5RWxlbWVudC5nZXQoZWxlbWVudCk7XG4gICAgICAgIGlmIChlbGVtZW50UGxheWVycykge1xuICAgICAgICAgICAgZWxlbWVudFBsYXllcnMuZm9yRWFjaChmdW5jdGlvbiAocGxheWVyKSB7IHJldHVybiBwbGF5ZXIuZGVzdHJveSgpOyB9KTtcbiAgICAgICAgICAgIHRoaXMuX2VuZ2luZS5wbGF5ZXJzQnlFbGVtZW50LmRlbGV0ZShlbGVtZW50KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSByb290RWxlbWVudFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEBwYXJhbSB7Pz19IGFuaW1hdGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFuaW1hdGlvblRyYW5zaXRpb25OYW1lc3BhY2UucHJvdG90eXBlLl9kZXN0cm95SW5uZXJOb2RlcyA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gcm9vdEVsZW1lbnRcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcGFyYW0gez89fSBhbmltYXRlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAocm9vdEVsZW1lbnQsIGNvbnRleHQsIGFuaW1hdGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKGFuaW1hdGUgPT09IHZvaWQgMCkgeyBhbmltYXRlID0gZmFsc2U7IH1cbiAgICAgICAgdGhpcy5fZW5naW5lLmRyaXZlci5xdWVyeShyb290RWxlbWVudCwgTkdfVFJJR0dFUl9TRUxFQ1RPUiwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoZWxtKSB7XG4gICAgICAgICAgICBpZiAoYW5pbWF0ZSAmJiBjb250YWluc0NsYXNzKGVsbSwgX3RoaXMuX2hvc3RDbGFzc05hbWUpKSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaW5uZXJOcyA9IF90aGlzLl9lbmdpbmUubmFtZXNwYWNlc0J5SG9zdEVsZW1lbnQuZ2V0KGVsbSk7XG4gICAgICAgICAgICAgICAgLy8gc3BlY2lhbCBjYXNlIGZvciBhIGhvc3QgZWxlbWVudCB3aXRoIGFuaW1hdGlvbnMgb24gdGhlIHNhbWUgZWxlbWVudFxuICAgICAgICAgICAgICAgIGlmIChpbm5lck5zKSB7XG4gICAgICAgICAgICAgICAgICAgIGlubmVyTnMucmVtb3ZlTm9kZShlbG0sIGNvbnRleHQsIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfdGhpcy5yZW1vdmVOb2RlKGVsbSwgY29udGV4dCwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5jbGVhckVsZW1lbnRDYWNoZShlbG0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEBwYXJhbSB7Pz19IGRvTm90UmVjdXJzZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQW5pbWF0aW9uVHJhbnNpdGlvbk5hbWVzcGFjZS5wcm90b3R5cGUucmVtb3ZlTm9kZSA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEBwYXJhbSB7Pz19IGRvTm90UmVjdXJzZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKGVsZW1lbnQsIGNvbnRleHQsIGRvTm90UmVjdXJzZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlbmdpbmUgPSB0aGlzLl9lbmdpbmU7XG4gICAgICAgIGlmICghZG9Ob3RSZWN1cnNlICYmIGVsZW1lbnQuY2hpbGRFbGVtZW50Q291bnQpIHtcbiAgICAgICAgICAgIHRoaXMuX2Rlc3Ryb3lJbm5lck5vZGVzKGVsZW1lbnQsIGNvbnRleHQsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRyaWdnZXJTdGF0ZXMgPSBlbmdpbmUuc3RhdGVzQnlFbGVtZW50LmdldChlbGVtZW50KTtcbiAgICAgICAgaWYgKHRyaWdnZXJTdGF0ZXMpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBsYXllcnNfMSA9IFtdO1xuICAgICAgICAgICAgT2JqZWN0LmtleXModHJpZ2dlclN0YXRlcykuZm9yRWFjaChmdW5jdGlvbiAodHJpZ2dlck5hbWUpIHtcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGNoZWNrIGlzIGhlcmUgaW4gdGhlIGV2ZW50IHRoYXQgYW4gZWxlbWVudCBpcyByZW1vdmVkXG4gICAgICAgICAgICAgICAgLy8gdHdpY2UgKGJvdGggb24gdGhlIGhvc3QgbGV2ZWwgYW5kIHRoZSBjb21wb25lbnQgbGV2ZWwpXG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLl90cmlnZ2Vyc1t0cmlnZ2VyTmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGxheWVyID0gX3RoaXMudHJpZ2dlcihlbGVtZW50LCB0cmlnZ2VyTmFtZSwgVk9JRF9WQUxVRSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocGxheWVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwbGF5ZXJzXzEucHVzaChwbGF5ZXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAocGxheWVyc18xLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGVuZ2luZS5tYXJrRWxlbWVudEFzUmVtb3ZlZCh0aGlzLmlkLCBlbGVtZW50LCB0cnVlLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICBvcHRpbWl6ZUdyb3VwUGxheWVyKHBsYXllcnNfMSkub25Eb25lKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVuZ2luZS5wcm9jZXNzTGVhdmVOb2RlKGVsZW1lbnQpOyB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gZmluZCB0aGUgcGxheWVyIHRoYXQgaXMgYW5pbWF0aW5nIGFuZCBtYWtlIHN1cmUgdGhhdCB0aGVcbiAgICAgICAgLy8gcmVtb3ZhbCBpcyBkZWxheWVkIHVudGlsIHRoYXQgcGxheWVyIGhhcyBjb21wbGV0ZWRcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY29udGFpbnNQb3RlbnRpYWxQYXJlbnRUcmFuc2l0aW9uID0gZmFsc2U7XG4gICAgICAgIGlmIChlbmdpbmUudG90YWxBbmltYXRpb25zKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjdXJyZW50UGxheWVycyA9IGVuZ2luZS5wbGF5ZXJzLmxlbmd0aCA/IGVuZ2luZS5wbGF5ZXJzQnlRdWVyaWVkRWxlbWVudC5nZXQoZWxlbWVudCkgOiBbXTtcbiAgICAgICAgICAgIC8vIHdoZW4gdGhpcyBgaWYgc3RhdGVtZW50YCBkb2VzIG5vdCBjb250aW51ZSBmb3J3YXJkIGl0IG1lYW5zIHRoYXRcbiAgICAgICAgICAgIC8vIGEgcHJldmlvdXMgYW5pbWF0aW9uIHF1ZXJ5IGhhcyBzZWxlY3RlZCB0aGUgY3VycmVudCBlbGVtZW50IGFuZFxuICAgICAgICAgICAgLy8gaXMgYW5pbWF0aW5nIGl0LiBJbiB0aGlzIHNpdHVhdGlvbiB3YW50IHRvIGNvbnRpbnVlIGZvd2FyZHMgYW5kXG4gICAgICAgICAgICAvLyBhbGxvdyB0aGUgZWxlbWVudCB0byBiZSBxdWV1ZWQgdXAgZm9yIGFuaW1hdGlvbiBsYXRlci5cbiAgICAgICAgICAgIGlmIChjdXJyZW50UGxheWVycyAmJiBjdXJyZW50UGxheWVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjb250YWluc1BvdGVudGlhbFBhcmVudFRyYW5zaXRpb24gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGFyZW50XzEgPSBlbGVtZW50O1xuICAgICAgICAgICAgICAgIHdoaWxlIChwYXJlbnRfMSA9IHBhcmVudF8xLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdHJpZ2dlcnMgPSBlbmdpbmUuc3RhdGVzQnlFbGVtZW50LmdldChwYXJlbnRfMSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0cmlnZ2Vycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGFpbnNQb3RlbnRpYWxQYXJlbnRUcmFuc2l0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGF0IHRoaXMgc3RhZ2Ugd2Uga25vdyB0aGF0IHRoZSBlbGVtZW50IHdpbGwgZWl0aGVyIGdldCByZW1vdmVkXG4gICAgICAgIC8vIGR1cmluZyBmbHVzaCBvciB3aWxsIGJlIHBpY2tlZCB1cCBieSBhIHBhcmVudCBxdWVyeS4gRWl0aGVyIHdheVxuICAgICAgICAvLyB3ZSBuZWVkIHRvIGZpcmUgdGhlIGxpc3RlbmVycyBmb3IgdGhpcyBlbGVtZW50IHdoZW4gaXQgRE9FUyBnZXRcbiAgICAgICAgLy8gcmVtb3ZlZCAob25jZSB0aGUgcXVlcnkgcGFyZW50IGFuaW1hdGlvbiBpcyBkb25lIG9yIGFmdGVyIGZsdXNoKVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBsaXN0ZW5lcnMgPSB0aGlzLl9lbGVtZW50TGlzdGVuZXJzLmdldChlbGVtZW50KTtcbiAgICAgICAgaWYgKGxpc3RlbmVycykge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmlzaXRlZFRyaWdnZXJzXzEgPSBuZXcgU2V0KCk7XG4gICAgICAgICAgICBsaXN0ZW5lcnMuZm9yRWFjaChmdW5jdGlvbiAobGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0cmlnZ2VyTmFtZSA9IGxpc3RlbmVyLm5hbWU7XG4gICAgICAgICAgICAgICAgaWYgKHZpc2l0ZWRUcmlnZ2Vyc18xLmhhcyh0cmlnZ2VyTmFtZSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB2aXNpdGVkVHJpZ2dlcnNfMS5hZGQodHJpZ2dlck5hbWUpO1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRyaWdnZXIgPSBfdGhpcy5fdHJpZ2dlcnNbdHJpZ2dlck5hbWVdO1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRyYW5zaXRpb24gPSB0cmlnZ2VyLmZhbGxiYWNrVHJhbnNpdGlvbjtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlbGVtZW50U3RhdGVzID0gLyoqIEB0eXBlIHs/fSAqLyAoKGVuZ2luZS5zdGF0ZXNCeUVsZW1lbnQuZ2V0KGVsZW1lbnQpKSk7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZnJvbVN0YXRlID0gZWxlbWVudFN0YXRlc1t0cmlnZ2VyTmFtZV0gfHwgREVGQVVMVF9TVEFURV9WQUxVRTtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0b1N0YXRlID0gbmV3IFN0YXRlVmFsdWUoVk9JRF9WQUxVRSk7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGxheWVyID0gbmV3IFRyYW5zaXRpb25BbmltYXRpb25QbGF5ZXIoX3RoaXMuaWQsIHRyaWdnZXJOYW1lLCBlbGVtZW50KTtcbiAgICAgICAgICAgICAgICBfdGhpcy5fZW5naW5lLnRvdGFsUXVldWVkUGxheWVycysrO1xuICAgICAgICAgICAgICAgIF90aGlzLl9xdWV1ZS5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudDogZWxlbWVudCxcbiAgICAgICAgICAgICAgICAgICAgdHJpZ2dlck5hbWU6IHRyaWdnZXJOYW1lLFxuICAgICAgICAgICAgICAgICAgICB0cmFuc2l0aW9uOiB0cmFuc2l0aW9uLFxuICAgICAgICAgICAgICAgICAgICBmcm9tU3RhdGU6IGZyb21TdGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgdG9TdGF0ZTogdG9TdGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgcGxheWVyOiBwbGF5ZXIsXG4gICAgICAgICAgICAgICAgICAgIGlzRmFsbGJhY2tUcmFuc2l0aW9uOiB0cnVlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyB3aGV0aGVyIG9yIG5vdCBhIHBhcmVudCBoYXMgYW4gYW5pbWF0aW9uIHdlIG5lZWQgdG8gZGVsYXkgdGhlIGRlZmVycmFsIG9mIHRoZSBsZWF2ZVxuICAgICAgICAvLyBvcGVyYXRpb24gdW50aWwgd2UgaGF2ZSBtb3JlIGluZm9ybWF0aW9uICh3aGljaCB3ZSBkbyBhZnRlciBmbHVzaCgpIGhhcyBiZWVuIGNhbGxlZClcbiAgICAgICAgaWYgKGNvbnRhaW5zUG90ZW50aWFsUGFyZW50VHJhbnNpdGlvbikge1xuICAgICAgICAgICAgZW5naW5lLm1hcmtFbGVtZW50QXNSZW1vdmVkKHRoaXMuaWQsIGVsZW1lbnQsIGZhbHNlLCBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIHdlIGRvIHRoaXMgYWZ0ZXIgdGhlIGZsdXNoIGhhcyBvY2N1cnJlZCBzdWNoXG4gICAgICAgICAgICAvLyB0aGF0IHRoZSBjYWxsYmFja3MgY2FuIGJlIGZpcmVkXG4gICAgICAgICAgICBlbmdpbmUuYWZ0ZXJGbHVzaChmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5jbGVhckVsZW1lbnRDYWNoZShlbGVtZW50KTsgfSk7XG4gICAgICAgICAgICBlbmdpbmUuZGVzdHJveUlubmVyQW5pbWF0aW9ucyhlbGVtZW50KTtcbiAgICAgICAgICAgIGVuZ2luZS5fb25SZW1vdmFsQ29tcGxldGUoZWxlbWVudCwgY29udGV4dCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFxuICAgICAqIEBwYXJhbSB7P30gcGFyZW50XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBbmltYXRpb25UcmFuc2l0aW9uTmFtZXNwYWNlLnByb3RvdHlwZS5pbnNlcnROb2RlID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XG4gICAgICogQHBhcmFtIHs/fSBwYXJlbnRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChlbGVtZW50LCBwYXJlbnQpIHsgYWRkQ2xhc3MoZWxlbWVudCwgdGhpcy5faG9zdENsYXNzTmFtZSk7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBtaWNyb3Rhc2tJZFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQW5pbWF0aW9uVHJhbnNpdGlvbk5hbWVzcGFjZS5wcm90b3R5cGUuZHJhaW5RdWV1ZWRUcmFuc2l0aW9ucyA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gbWljcm90YXNrSWRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChtaWNyb3Rhc2tJZCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpbnN0cnVjdGlvbnMgPSBbXTtcbiAgICAgICAgdGhpcy5fcXVldWUuZm9yRWFjaChmdW5jdGlvbiAoZW50cnkpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBsYXllciA9IGVudHJ5LnBsYXllcjtcbiAgICAgICAgICAgIGlmIChwbGF5ZXIuZGVzdHJveWVkKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVsZW1lbnQgPSBlbnRyeS5lbGVtZW50O1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbGlzdGVuZXJzID0gX3RoaXMuX2VsZW1lbnRMaXN0ZW5lcnMuZ2V0KGVsZW1lbnQpO1xuICAgICAgICAgICAgaWYgKGxpc3RlbmVycykge1xuICAgICAgICAgICAgICAgIGxpc3RlbmVycy5mb3JFYWNoKGZ1bmN0aW9uIChsaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAobGlzdGVuZXIubmFtZSA9PSBlbnRyeS50cmlnZ2VyTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYmFzZUV2ZW50ID0gbWFrZUFuaW1hdGlvbkV2ZW50KGVsZW1lbnQsIGVudHJ5LnRyaWdnZXJOYW1lLCBlbnRyeS5mcm9tU3RhdGUudmFsdWUsIGVudHJ5LnRvU3RhdGUudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgKC8qKiBAdHlwZSB7P30gKi8gKGJhc2VFdmVudCkpWydfZGF0YSddID0gbWljcm90YXNrSWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaXN0ZW5PblBsYXllcihlbnRyeS5wbGF5ZXIsIGxpc3RlbmVyLnBoYXNlLCBiYXNlRXZlbnQsIGxpc3RlbmVyLmNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBsYXllci5tYXJrZWRGb3JEZXN0cm95KSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX2VuZ2luZS5hZnRlckZsdXNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbm93IHdlIGNhbiBkZXN0cm95IHRoZSBlbGVtZW50IHByb3Blcmx5IHNpbmNlIHRoZSBldmVudCBsaXN0ZW5lcnMgaGF2ZVxuICAgICAgICAgICAgICAgICAgICAvLyBiZWVuIGJvdW5kIHRvIHRoZSBwbGF5ZXJcbiAgICAgICAgICAgICAgICAgICAgcGxheWVyLmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGluc3RydWN0aW9ucy5wdXNoKGVudHJ5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX3F1ZXVlID0gW107XG4gICAgICAgIHJldHVybiBpbnN0cnVjdGlvbnMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgLy8gaWYgZGVwQ291bnQgPT0gMCB0aGVtIG1vdmUgdG8gZnJvbnRcbiAgICAgICAgICAgIC8vIG90aGVyd2lzZSBpZiBhIGNvbnRhaW5zIGIgdGhlbiBtb3ZlIGJhY2tcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGQwID0gYS50cmFuc2l0aW9uLmFzdC5kZXBDb3VudDtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGQxID0gYi50cmFuc2l0aW9uLmFzdC5kZXBDb3VudDtcbiAgICAgICAgICAgIGlmIChkMCA9PSAwIHx8IGQxID09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZDAgLSBkMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5fZW5naW5lLmRyaXZlci5jb250YWluc0VsZW1lbnQoYS5lbGVtZW50LCBiLmVsZW1lbnQpID8gMSA6IC0xO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQW5pbWF0aW9uVHJhbnNpdGlvbk5hbWVzcGFjZS5wcm90b3R5cGUuZGVzdHJveSA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy5wbGF5ZXJzLmZvckVhY2goZnVuY3Rpb24gKHApIHsgcmV0dXJuIHAuZGVzdHJveSgpOyB9KTtcbiAgICAgICAgdGhpcy5fZGVzdHJveUlubmVyTm9kZXModGhpcy5ob3N0RWxlbWVudCwgY29udGV4dCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFuaW1hdGlvblRyYW5zaXRpb25OYW1lc3BhY2UucHJvdG90eXBlLmVsZW1lbnRDb250YWluc0RhdGEgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNvbnRhaW5zRGF0YSA9IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5fZWxlbWVudExpc3RlbmVycy5oYXMoZWxlbWVudCkpXG4gICAgICAgICAgICBjb250YWluc0RhdGEgPSB0cnVlO1xuICAgICAgICBjb250YWluc0RhdGEgPVxuICAgICAgICAgICAgKHRoaXMuX3F1ZXVlLmZpbmQoZnVuY3Rpb24gKGVudHJ5KSB7IHJldHVybiBlbnRyeS5lbGVtZW50ID09PSBlbGVtZW50OyB9KSA/IHRydWUgOiBmYWxzZSkgfHwgY29udGFpbnNEYXRhO1xuICAgICAgICByZXR1cm4gY29udGFpbnNEYXRhO1xuICAgIH07XG4gICAgcmV0dXJuIEFuaW1hdGlvblRyYW5zaXRpb25OYW1lc3BhY2U7XG59KCkpO1xuLyoqXG4gKiBAcmVjb3JkXG4gKi9cblxudmFyIFRyYW5zaXRpb25BbmltYXRpb25FbmdpbmUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRyYW5zaXRpb25BbmltYXRpb25FbmdpbmUoZHJpdmVyLCBfbm9ybWFsaXplcikge1xuICAgICAgICB0aGlzLmRyaXZlciA9IGRyaXZlcjtcbiAgICAgICAgdGhpcy5fbm9ybWFsaXplciA9IF9ub3JtYWxpemVyO1xuICAgICAgICB0aGlzLnBsYXllcnMgPSBbXTtcbiAgICAgICAgdGhpcy5uZXdIb3N0RWxlbWVudHMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMucGxheWVyc0J5RWxlbWVudCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5wbGF5ZXJzQnlRdWVyaWVkRWxlbWVudCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5zdGF0ZXNCeUVsZW1lbnQgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuZGlzYWJsZWROb2RlcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgdGhpcy50b3RhbEFuaW1hdGlvbnMgPSAwO1xuICAgICAgICB0aGlzLnRvdGFsUXVldWVkUGxheWVycyA9IDA7XG4gICAgICAgIHRoaXMuX25hbWVzcGFjZUxvb2t1cCA9IHt9O1xuICAgICAgICB0aGlzLl9uYW1lc3BhY2VMaXN0ID0gW107XG4gICAgICAgIHRoaXMuX2ZsdXNoRm5zID0gW107XG4gICAgICAgIHRoaXMuX3doZW5RdWlldEZucyA9IFtdO1xuICAgICAgICB0aGlzLm5hbWVzcGFjZXNCeUhvc3RFbGVtZW50ID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLmNvbGxlY3RlZEVudGVyRWxlbWVudHMgPSBbXTtcbiAgICAgICAgdGhpcy5jb2xsZWN0ZWRMZWF2ZUVsZW1lbnRzID0gW107XG4gICAgICAgIHRoaXMub25SZW1vdmFsQ29tcGxldGUgPSBmdW5jdGlvbiAoZWxlbWVudCwgY29udGV4dCkgeyB9O1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgLyoqXG4gICAgICogXFxAaW50ZXJuYWxcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRyYW5zaXRpb25BbmltYXRpb25FbmdpbmUucHJvdG90eXBlLl9vblJlbW92YWxDb21wbGV0ZSA9IC8qKlxuICAgICAqIFxcQGludGVybmFsXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoZWxlbWVudCwgY29udGV4dCkgeyB0aGlzLm9uUmVtb3ZhbENvbXBsZXRlKGVsZW1lbnQsIGNvbnRleHQpOyB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUcmFuc2l0aW9uQW5pbWF0aW9uRW5naW5lLnByb3RvdHlwZSwgXCJxdWV1ZWRQbGF5ZXJzXCIsIHtcbiAgICAgICAgZ2V0OiAvKipcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBsYXllcnMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX25hbWVzcGFjZUxpc3QuZm9yRWFjaChmdW5jdGlvbiAobnMpIHtcbiAgICAgICAgICAgICAgICBucy5wbGF5ZXJzLmZvckVhY2goZnVuY3Rpb24gKHBsYXllcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAocGxheWVyLnF1ZXVlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGxheWVycy5wdXNoKHBsYXllcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHBsYXllcnM7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbmFtZXNwYWNlSWRcbiAgICAgKiBAcGFyYW0gez99IGhvc3RFbGVtZW50XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUcmFuc2l0aW9uQW5pbWF0aW9uRW5naW5lLnByb3RvdHlwZS5jcmVhdGVOYW1lc3BhY2UgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IG5hbWVzcGFjZUlkXG4gICAgICogQHBhcmFtIHs/fSBob3N0RWxlbWVudFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKG5hbWVzcGFjZUlkLCBob3N0RWxlbWVudCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBucyA9IG5ldyBBbmltYXRpb25UcmFuc2l0aW9uTmFtZXNwYWNlKG5hbWVzcGFjZUlkLCBob3N0RWxlbWVudCwgdGhpcyk7XG4gICAgICAgIGlmIChob3N0RWxlbWVudC5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICB0aGlzLl9iYWxhbmNlTmFtZXNwYWNlTGlzdChucywgaG9zdEVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gZGVmZXIgdGhpcyBsYXRlciB1bnRpbCBmbHVzaCBkdXJpbmcgd2hlbiB0aGUgaG9zdCBlbGVtZW50IGhhc1xuICAgICAgICAgICAgLy8gYmVlbiBpbnNlcnRlZCBzbyB0aGF0IHdlIGtub3cgZXhhY3RseSB3aGVyZSB0byBwbGFjZSBpdCBpblxuICAgICAgICAgICAgLy8gdGhlIG5hbWVzcGFjZSBsaXN0XG4gICAgICAgICAgICB0aGlzLm5ld0hvc3RFbGVtZW50cy5zZXQoaG9zdEVsZW1lbnQsIG5zKTtcbiAgICAgICAgICAgIC8vIGdpdmVuIHRoYXQgdGhpcyBob3N0IGVsZW1lbnQgaXMgYXBhcnQgb2YgdGhlIGFuaW1hdGlvbiBjb2RlLCBpdFxuICAgICAgICAgICAgLy8gbWF5IG9yIG1heSBub3QgYmUgaW5zZXJ0ZWQgYnkgYSBwYXJlbnQgbm9kZSB0aGF0IGlzIGFuIG9mIGFuXG4gICAgICAgICAgICAvLyBhbmltYXRpb24gcmVuZGVyZXIgdHlwZS4gSWYgdGhpcyBoYXBwZW5zIHRoZW4gd2UgY2FuIHN0aWxsIGhhdmVcbiAgICAgICAgICAgIC8vIGFjY2VzcyB0byB0aGlzIGl0ZW0gd2hlbiB3ZSBxdWVyeSBmb3IgOmVudGVyIG5vZGVzLiBJZiB0aGUgcGFyZW50XG4gICAgICAgICAgICAvLyBpcyBhIHJlbmRlcmVyIHRoZW4gdGhlIHNldCBkYXRhLXN0cnVjdHVyZSB3aWxsIG5vcm1hbGl6ZSB0aGUgZW50cnlcbiAgICAgICAgICAgIHRoaXMuY29sbGVjdEVudGVyRWxlbWVudChob3N0RWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX25hbWVzcGFjZUxvb2t1cFtuYW1lc3BhY2VJZF0gPSBucztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbnNcbiAgICAgKiBAcGFyYW0gez99IGhvc3RFbGVtZW50XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUcmFuc2l0aW9uQW5pbWF0aW9uRW5naW5lLnByb3RvdHlwZS5fYmFsYW5jZU5hbWVzcGFjZUxpc3QgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IG5zXG4gICAgICogQHBhcmFtIHs/fSBob3N0RWxlbWVudFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKG5zLCBob3N0RWxlbWVudCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBsaW1pdCA9IHRoaXMuX25hbWVzcGFjZUxpc3QubGVuZ3RoIC0gMTtcbiAgICAgICAgaWYgKGxpbWl0ID49IDApIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGZvdW5kID0gZmFsc2U7XG4gICAgICAgICAgICBmb3IgKHZhciAvKiogQHR5cGUgez99ICovIGkgPSBsaW1pdDsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBuZXh0TmFtZXNwYWNlID0gdGhpcy5fbmFtZXNwYWNlTGlzdFtpXTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5kcml2ZXIuY29udGFpbnNFbGVtZW50KG5leHROYW1lc3BhY2UuaG9zdEVsZW1lbnQsIGhvc3RFbGVtZW50KSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9uYW1lc3BhY2VMaXN0LnNwbGljZShpICsgMSwgMCwgbnMpO1xuICAgICAgICAgICAgICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZm91bmQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9uYW1lc3BhY2VMaXN0LnNwbGljZSgwLCAwLCBucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9uYW1lc3BhY2VMaXN0LnB1c2gobnMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubmFtZXNwYWNlc0J5SG9zdEVsZW1lbnQuc2V0KGhvc3RFbGVtZW50LCBucyk7XG4gICAgICAgIHJldHVybiBucztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbmFtZXNwYWNlSWRcbiAgICAgKiBAcGFyYW0gez99IGhvc3RFbGVtZW50XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUcmFuc2l0aW9uQW5pbWF0aW9uRW5naW5lLnByb3RvdHlwZS5yZWdpc3RlciA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gbmFtZXNwYWNlSWRcbiAgICAgKiBAcGFyYW0gez99IGhvc3RFbGVtZW50XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAobmFtZXNwYWNlSWQsIGhvc3RFbGVtZW50KSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5zID0gdGhpcy5fbmFtZXNwYWNlTG9va3VwW25hbWVzcGFjZUlkXTtcbiAgICAgICAgaWYgKCFucykge1xuICAgICAgICAgICAgbnMgPSB0aGlzLmNyZWF0ZU5hbWVzcGFjZShuYW1lc3BhY2VJZCwgaG9zdEVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBucztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbmFtZXNwYWNlSWRcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKiBAcGFyYW0gez99IHRyaWdnZXJcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRyYW5zaXRpb25BbmltYXRpb25FbmdpbmUucHJvdG90eXBlLnJlZ2lzdGVyVHJpZ2dlciA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gbmFtZXNwYWNlSWRcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKiBAcGFyYW0gez99IHRyaWdnZXJcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChuYW1lc3BhY2VJZCwgbmFtZSwgdHJpZ2dlcikge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBucyA9IHRoaXMuX25hbWVzcGFjZUxvb2t1cFtuYW1lc3BhY2VJZF07XG4gICAgICAgIGlmIChucyAmJiBucy5yZWdpc3RlcihuYW1lLCB0cmlnZ2VyKSkge1xuICAgICAgICAgICAgdGhpcy50b3RhbEFuaW1hdGlvbnMrKztcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBuYW1lc3BhY2VJZFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVHJhbnNpdGlvbkFuaW1hdGlvbkVuZ2luZS5wcm90b3R5cGUuZGVzdHJveSA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gbmFtZXNwYWNlSWRcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChuYW1lc3BhY2VJZCwgY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoIW5hbWVzcGFjZUlkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBucyA9IHRoaXMuX2ZldGNoTmFtZXNwYWNlKG5hbWVzcGFjZUlkKTtcbiAgICAgICAgdGhpcy5hZnRlckZsdXNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLm5hbWVzcGFjZXNCeUhvc3RFbGVtZW50LmRlbGV0ZShucy5ob3N0RWxlbWVudCk7XG4gICAgICAgICAgICBkZWxldGUgX3RoaXMuX25hbWVzcGFjZUxvb2t1cFtuYW1lc3BhY2VJZF07XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpbmRleCA9IF90aGlzLl9uYW1lc3BhY2VMaXN0LmluZGV4T2YobnMpO1xuICAgICAgICAgICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fbmFtZXNwYWNlTGlzdC5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5hZnRlckZsdXNoQW5pbWF0aW9uc0RvbmUoZnVuY3Rpb24gKCkgeyByZXR1cm4gbnMuZGVzdHJveShjb250ZXh0KTsgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGlkXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUcmFuc2l0aW9uQW5pbWF0aW9uRW5naW5lLnByb3RvdHlwZS5fZmV0Y2hOYW1lc3BhY2UgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IGlkXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoaWQpIHsgcmV0dXJuIHRoaXMuX25hbWVzcGFjZUxvb2t1cFtpZF07IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBuYW1lc3BhY2VJZFxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRyYW5zaXRpb25BbmltYXRpb25FbmdpbmUucHJvdG90eXBlLnRyaWdnZXIgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IG5hbWVzcGFjZUlkXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKG5hbWVzcGFjZUlkLCBlbGVtZW50LCBuYW1lLCB2YWx1ZSkge1xuICAgICAgICBpZiAoaXNFbGVtZW50Tm9kZShlbGVtZW50KSkge1xuICAgICAgICAgICAgdGhpcy5fZmV0Y2hOYW1lc3BhY2UobmFtZXNwYWNlSWQpLnRyaWdnZXIoZWxlbWVudCwgbmFtZSwgdmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBuYW1lc3BhY2VJZFxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFxuICAgICAqIEBwYXJhbSB7P30gcGFyZW50XG4gICAgICogQHBhcmFtIHs/fSBpbnNlcnRCZWZvcmVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRyYW5zaXRpb25BbmltYXRpb25FbmdpbmUucHJvdG90eXBlLmluc2VydE5vZGUgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IG5hbWVzcGFjZUlkXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XG4gICAgICogQHBhcmFtIHs/fSBwYXJlbnRcbiAgICAgKiBAcGFyYW0gez99IGluc2VydEJlZm9yZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKG5hbWVzcGFjZUlkLCBlbGVtZW50LCBwYXJlbnQsIGluc2VydEJlZm9yZSkge1xuICAgICAgICBpZiAoIWlzRWxlbWVudE5vZGUoZWxlbWVudCkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIC8vIHNwZWNpYWwgY2FzZSBmb3Igd2hlbiBhbiBlbGVtZW50IGlzIHJlbW92ZWQgYW5kIHJlaW5zZXJ0ZWQgKG1vdmUgb3BlcmF0aW9uKVxuICAgICAgICAvLyB3aGVuIHRoaXMgb2NjdXJzIHdlIGRvIG5vdCB3YW50IHRvIHVzZSB0aGUgZWxlbWVudCBmb3IgZGVsZXRpb24gbGF0ZXJcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZGV0YWlscyA9IC8qKiBAdHlwZSB7P30gKi8gKGVsZW1lbnRbUkVNT1ZBTF9GTEFHXSk7XG4gICAgICAgIGlmIChkZXRhaWxzICYmIGRldGFpbHMuc2V0Rm9yUmVtb3ZhbCkge1xuICAgICAgICAgICAgZGV0YWlscy5zZXRGb3JSZW1vdmFsID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaW4gdGhlIGV2ZW50IHRoYXQgdGhlIG5hbWVzcGFjZUlkIGlzIGJsYW5rIHRoZW4gdGhlIGNhbGxlclxuICAgICAgICAvLyBjb2RlIGRvZXMgbm90IGNvbnRhaW4gYW55IGFuaW1hdGlvbiBjb2RlIGluIGl0LCBidXQgaXQgaXNcbiAgICAgICAgLy8ganVzdCBiZWluZyBjYWxsZWQgc28gdGhhdCB0aGUgbm9kZSBpcyBtYXJrZWQgYXMgYmVpbmcgaW5zZXJ0ZWRcbiAgICAgICAgaWYgKG5hbWVzcGFjZUlkKSB7XG4gICAgICAgICAgICB0aGlzLl9mZXRjaE5hbWVzcGFjZShuYW1lc3BhY2VJZCkuaW5zZXJ0Tm9kZShlbGVtZW50LCBwYXJlbnQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIG9ubHkgKmRpcmVjdGl2ZXMgYW5kIGhvc3QgZWxlbWVudHMgYXJlIGluc2VydGVkIGJlZm9yZVxuICAgICAgICBpZiAoaW5zZXJ0QmVmb3JlKSB7XG4gICAgICAgICAgICB0aGlzLmNvbGxlY3RFbnRlckVsZW1lbnQoZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVHJhbnNpdGlvbkFuaW1hdGlvbkVuZ2luZS5wcm90b3R5cGUuY29sbGVjdEVudGVyRWxlbWVudCA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKGVsZW1lbnQpIHsgdGhpcy5jb2xsZWN0ZWRFbnRlckVsZW1lbnRzLnB1c2goZWxlbWVudCk7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVHJhbnNpdGlvbkFuaW1hdGlvbkVuZ2luZS5wcm90b3R5cGUubWFya0VsZW1lbnRBc0Rpc2FibGVkID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKGVsZW1lbnQsIHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmRpc2FibGVkTm9kZXMuaGFzKGVsZW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNhYmxlZE5vZGVzLmFkZChlbGVtZW50KTtcbiAgICAgICAgICAgICAgICBhZGRDbGFzcyhlbGVtZW50LCBESVNBQkxFRF9DTEFTU05BTUUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuZGlzYWJsZWROb2Rlcy5oYXMoZWxlbWVudCkpIHtcbiAgICAgICAgICAgIHRoaXMuZGlzYWJsZWROb2Rlcy5kZWxldGUoZWxlbWVudCk7XG4gICAgICAgICAgICByZW1vdmVDbGFzcyhlbGVtZW50LCBESVNBQkxFRF9DTEFTU05BTUUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5hbWVzcGFjZUlkXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHBhcmFtIHs/PX0gZG9Ob3RSZWN1cnNlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUcmFuc2l0aW9uQW5pbWF0aW9uRW5naW5lLnByb3RvdHlwZS5yZW1vdmVOb2RlID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBuYW1lc3BhY2VJZFxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEBwYXJhbSB7Pz19IGRvTm90UmVjdXJzZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKG5hbWVzcGFjZUlkLCBlbGVtZW50LCBjb250ZXh0LCBkb05vdFJlY3Vyc2UpIHtcbiAgICAgICAgaWYgKCFpc0VsZW1lbnROb2RlKGVsZW1lbnQpKSB7XG4gICAgICAgICAgICB0aGlzLl9vblJlbW92YWxDb21wbGV0ZShlbGVtZW50LCBjb250ZXh0KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBucyA9IG5hbWVzcGFjZUlkID8gdGhpcy5fZmV0Y2hOYW1lc3BhY2UobmFtZXNwYWNlSWQpIDogbnVsbDtcbiAgICAgICAgaWYgKG5zKSB7XG4gICAgICAgICAgICBucy5yZW1vdmVOb2RlKGVsZW1lbnQsIGNvbnRleHQsIGRvTm90UmVjdXJzZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm1hcmtFbGVtZW50QXNSZW1vdmVkKG5hbWVzcGFjZUlkLCBlbGVtZW50LCBmYWxzZSwgY29udGV4dCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbmFtZXNwYWNlSWRcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0gez89fSBoYXNBbmltYXRpb25cbiAgICAgKiBAcGFyYW0gez89fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUcmFuc2l0aW9uQW5pbWF0aW9uRW5naW5lLnByb3RvdHlwZS5tYXJrRWxlbWVudEFzUmVtb3ZlZCA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gbmFtZXNwYWNlSWRcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0gez89fSBoYXNBbmltYXRpb25cbiAgICAgKiBAcGFyYW0gez89fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAobmFtZXNwYWNlSWQsIGVsZW1lbnQsIGhhc0FuaW1hdGlvbiwgY29udGV4dCkge1xuICAgICAgICB0aGlzLmNvbGxlY3RlZExlYXZlRWxlbWVudHMucHVzaChlbGVtZW50KTtcbiAgICAgICAgZWxlbWVudFtSRU1PVkFMX0ZMQUddID0ge1xuICAgICAgICAgICAgbmFtZXNwYWNlSWQ6IG5hbWVzcGFjZUlkLFxuICAgICAgICAgICAgc2V0Rm9yUmVtb3ZhbDogY29udGV4dCwgaGFzQW5pbWF0aW9uOiBoYXNBbmltYXRpb24sXG4gICAgICAgICAgICByZW1vdmVkQmVmb3JlUXVlcmllZDogZmFsc2VcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbmFtZXNwYWNlSWRcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKiBAcGFyYW0gez99IHBoYXNlXG4gICAgICogQHBhcmFtIHs/fSBjYWxsYmFja1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVHJhbnNpdGlvbkFuaW1hdGlvbkVuZ2luZS5wcm90b3R5cGUubGlzdGVuID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBuYW1lc3BhY2VJZFxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEBwYXJhbSB7P30gcGhhc2VcbiAgICAgKiBAcGFyYW0gez99IGNhbGxiYWNrXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAobmFtZXNwYWNlSWQsIGVsZW1lbnQsIG5hbWUsIHBoYXNlLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAoaXNFbGVtZW50Tm9kZShlbGVtZW50KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ZldGNoTmFtZXNwYWNlKG5hbWVzcGFjZUlkKS5saXN0ZW4oZWxlbWVudCwgbmFtZSwgcGhhc2UsIGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkgeyB9O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbnRyeVxuICAgICAqIEBwYXJhbSB7P30gc3ViVGltZWxpbmVzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUcmFuc2l0aW9uQW5pbWF0aW9uRW5naW5lLnByb3RvdHlwZS5fYnVpbGRJbnN0cnVjdGlvbiA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gZW50cnlcbiAgICAgKiBAcGFyYW0gez99IHN1YlRpbWVsaW5lc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKGVudHJ5LCBzdWJUaW1lbGluZXMpIHtcbiAgICAgICAgcmV0dXJuIGVudHJ5LnRyYW5zaXRpb24uYnVpbGQodGhpcy5kcml2ZXIsIGVudHJ5LmVsZW1lbnQsIGVudHJ5LmZyb21TdGF0ZS52YWx1ZSwgZW50cnkudG9TdGF0ZS52YWx1ZSwgZW50cnkuZnJvbVN0YXRlLm9wdGlvbnMsIGVudHJ5LnRvU3RhdGUub3B0aW9ucywgc3ViVGltZWxpbmVzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gY29udGFpbmVyRWxlbWVudFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVHJhbnNpdGlvbkFuaW1hdGlvbkVuZ2luZS5wcm90b3R5cGUuZGVzdHJveUlubmVyQW5pbWF0aW9ucyA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gY29udGFpbmVyRWxlbWVudFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKGNvbnRhaW5lckVsZW1lbnQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZWxlbWVudHMgPSB0aGlzLmRyaXZlci5xdWVyeShjb250YWluZXJFbGVtZW50LCBOR19UUklHR0VSX1NFTEVDVE9SLCB0cnVlKTtcbiAgICAgICAgZWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGxheWVycyA9IF90aGlzLnBsYXllcnNCeUVsZW1lbnQuZ2V0KGVsZW1lbnQpO1xuICAgICAgICAgICAgaWYgKHBsYXllcnMpIHtcbiAgICAgICAgICAgICAgICBwbGF5ZXJzLmZvckVhY2goZnVuY3Rpb24gKHBsYXllcikge1xuICAgICAgICAgICAgICAgICAgICAvLyBzcGVjaWFsIGNhc2UgZm9yIHdoZW4gYW4gZWxlbWVudCBpcyBzZXQgZm9yIGRlc3RydWN0aW9uLCBidXQgaGFzbid0IHN0YXJ0ZWQuXG4gICAgICAgICAgICAgICAgICAgIC8vIGluIHRoaXMgc2l0dWF0aW9uIHdlIHdhbnQgdG8gZGVsYXkgdGhlIGRlc3RydWN0aW9uIHVudGlsIHRoZSBmbHVzaCBvY2N1cnNcbiAgICAgICAgICAgICAgICAgICAgLy8gc28gdGhhdCBhbnkgZXZlbnQgbGlzdGVuZXJzIGF0dGFjaGVkIHRvIHRoZSBwbGF5ZXIgYXJlIHRyaWdnZXJlZC5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHBsYXllci5xdWV1ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBsYXllci5tYXJrZWRGb3JEZXN0cm95ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBsYXllci5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0YXRlTWFwID0gX3RoaXMuc3RhdGVzQnlFbGVtZW50LmdldChlbGVtZW50KTtcbiAgICAgICAgICAgIGlmIChzdGF0ZU1hcCkge1xuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKHN0YXRlTWFwKS5mb3JFYWNoKGZ1bmN0aW9uICh0cmlnZ2VyTmFtZSkgeyByZXR1cm4gc3RhdGVNYXBbdHJpZ2dlck5hbWVdID0gREVMRVRFRF9TVEFURV9WQUxVRTsgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodGhpcy5wbGF5ZXJzQnlRdWVyaWVkRWxlbWVudC5zaXplID09IDApXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGVsZW1lbnRzID0gdGhpcy5kcml2ZXIucXVlcnkoY29udGFpbmVyRWxlbWVudCwgTkdfQU5JTUFUSU5HX1NFTEVDVE9SLCB0cnVlKTtcbiAgICAgICAgaWYgKGVsZW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgZWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBsYXllcnMgPSBfdGhpcy5wbGF5ZXJzQnlRdWVyaWVkRWxlbWVudC5nZXQoZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgaWYgKHBsYXllcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgcGxheWVycy5mb3JFYWNoKGZ1bmN0aW9uIChwbGF5ZXIpIHsgcmV0dXJuIHBsYXllci5maW5pc2goKTsgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVHJhbnNpdGlvbkFuaW1hdGlvbkVuZ2luZS5wcm90b3R5cGUud2hlblJlbmRlcmluZ0RvbmUgPSAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMucGxheWVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3B0aW1pemVHcm91cFBsYXllcihfdGhpcy5wbGF5ZXJzKS5vbkRvbmUoZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVzb2x2ZSgpOyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRyYW5zaXRpb25BbmltYXRpb25FbmdpbmUucHJvdG90eXBlLnByb2Nlc3NMZWF2ZU5vZGUgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGRldGFpbHMgPSAvKiogQHR5cGUgez99ICovIChlbGVtZW50W1JFTU9WQUxfRkxBR10pO1xuICAgICAgICBpZiAoZGV0YWlscyAmJiBkZXRhaWxzLnNldEZvclJlbW92YWwpIHtcbiAgICAgICAgICAgIC8vIHRoaXMgd2lsbCBwcmV2ZW50IGl0IGZyb20gcmVtb3ZpbmcgaXQgdHdpY2VcbiAgICAgICAgICAgIGVsZW1lbnRbUkVNT1ZBTF9GTEFHXSA9IE5VTExfUkVNT1ZBTF9TVEFURTtcbiAgICAgICAgICAgIGlmIChkZXRhaWxzLm5hbWVzcGFjZUlkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kZXN0cm95SW5uZXJBbmltYXRpb25zKGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5zID0gdGhpcy5fZmV0Y2hOYW1lc3BhY2UoZGV0YWlscy5uYW1lc3BhY2VJZCk7XG4gICAgICAgICAgICAgICAgaWYgKG5zKSB7XG4gICAgICAgICAgICAgICAgICAgIG5zLmNsZWFyRWxlbWVudENhY2hlKGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX29uUmVtb3ZhbENvbXBsZXRlKGVsZW1lbnQsIGRldGFpbHMuc2V0Rm9yUmVtb3ZhbCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZHJpdmVyLm1hdGNoZXNFbGVtZW50KGVsZW1lbnQsIERJU0FCTEVEX1NFTEVDVE9SKSkge1xuICAgICAgICAgICAgdGhpcy5tYXJrRWxlbWVudEFzRGlzYWJsZWQoZWxlbWVudCwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZHJpdmVyLnF1ZXJ5KGVsZW1lbnQsIERJU0FCTEVEX1NFTEVDVE9SLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICBfdGhpcy5tYXJrRWxlbWVudEFzRGlzYWJsZWQoZWxlbWVudCwgZmFsc2UpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Pz19IG1pY3JvdGFza0lkXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUcmFuc2l0aW9uQW5pbWF0aW9uRW5naW5lLnByb3RvdHlwZS5mbHVzaCA9IC8qKlxuICAgICAqIEBwYXJhbSB7Pz19IG1pY3JvdGFza0lkXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAobWljcm90YXNrSWQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKG1pY3JvdGFza0lkID09PSB2b2lkIDApIHsgbWljcm90YXNrSWQgPSAtMTsgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwbGF5ZXJzID0gW107XG4gICAgICAgIGlmICh0aGlzLm5ld0hvc3RFbGVtZW50cy5zaXplKSB7XG4gICAgICAgICAgICB0aGlzLm5ld0hvc3RFbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChucywgZWxlbWVudCkgeyByZXR1cm4gX3RoaXMuX2JhbGFuY2VOYW1lc3BhY2VMaXN0KG5zLCBlbGVtZW50KTsgfSk7XG4gICAgICAgICAgICB0aGlzLm5ld0hvc3RFbGVtZW50cy5jbGVhcigpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9uYW1lc3BhY2VMaXN0Lmxlbmd0aCAmJlxuICAgICAgICAgICAgKHRoaXMudG90YWxRdWV1ZWRQbGF5ZXJzIHx8IHRoaXMuY29sbGVjdGVkTGVhdmVFbGVtZW50cy5sZW5ndGgpKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjbGVhbnVwRm5zID0gW107XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHBsYXllcnMgPSB0aGlzLl9mbHVzaEFuaW1hdGlvbnMoY2xlYW51cEZucywgbWljcm90YXNrSWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBpID0gMDsgaSA8IGNsZWFudXBGbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYW51cEZuc1tpXSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gaSA9IDA7IGkgPCB0aGlzLmNvbGxlY3RlZExlYXZlRWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlbGVtZW50ID0gdGhpcy5jb2xsZWN0ZWRMZWF2ZUVsZW1lbnRzW2ldO1xuICAgICAgICAgICAgICAgIHRoaXMucHJvY2Vzc0xlYXZlTm9kZShlbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRvdGFsUXVldWVkUGxheWVycyA9IDA7XG4gICAgICAgIHRoaXMuY29sbGVjdGVkRW50ZXJFbGVtZW50cy5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLmNvbGxlY3RlZExlYXZlRWxlbWVudHMubGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5fZmx1c2hGbnMuZm9yRWFjaChmdW5jdGlvbiAoZm4pIHsgcmV0dXJuIGZuKCk7IH0pO1xuICAgICAgICB0aGlzLl9mbHVzaEZucyA9IFtdO1xuICAgICAgICBpZiAodGhpcy5fd2hlblF1aWV0Rm5zLmxlbmd0aCkge1xuICAgICAgICAgICAgLy8gd2UgbW92ZSB0aGVzZSBvdmVyIHRvIGEgdmFyaWFibGUgc28gdGhhdFxuICAgICAgICAgICAgLy8gaWYgYW55IG5ldyBjYWxsYmFja3MgYXJlIHJlZ2lzdGVyZWQgaW4gYW5vdGhlclxuICAgICAgICAgICAgLy8gZmx1c2ggdGhleSBkbyBub3QgcG9wdWxhdGUgdGhlIGV4aXN0aW5nIHNldFxuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcXVpZXRGbnNfMSA9IHRoaXMuX3doZW5RdWlldEZucztcbiAgICAgICAgICAgIHRoaXMuX3doZW5RdWlldEZucyA9IFtdO1xuICAgICAgICAgICAgaWYgKHBsYXllcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgb3B0aW1pemVHcm91cFBsYXllcihwbGF5ZXJzKS5vbkRvbmUoZnVuY3Rpb24gKCkgeyBxdWlldEZuc18xLmZvckVhY2goZnVuY3Rpb24gKGZuKSB7IHJldHVybiBmbigpOyB9KTsgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBxdWlldEZuc18xLmZvckVhY2goZnVuY3Rpb24gKGZuKSB7IHJldHVybiBmbigpOyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBlcnJvcnNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRyYW5zaXRpb25BbmltYXRpb25FbmdpbmUucHJvdG90eXBlLnJlcG9ydEVycm9yID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBlcnJvcnNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChlcnJvcnMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIHByb2Nlc3MgYW5pbWF0aW9ucyBkdWUgdG8gdGhlIGZvbGxvd2luZyBmYWlsZWQgdHJpZ2dlciB0cmFuc2l0aW9uc1xcbiBcIiArIGVycm9ycy5qb2luKFwiXFxuXCIpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gY2xlYW51cEZuc1xuICAgICAqIEBwYXJhbSB7P30gbWljcm90YXNrSWRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRyYW5zaXRpb25BbmltYXRpb25FbmdpbmUucHJvdG90eXBlLl9mbHVzaEFuaW1hdGlvbnMgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IGNsZWFudXBGbnNcbiAgICAgKiBAcGFyYW0gez99IG1pY3JvdGFza0lkXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoY2xlYW51cEZucywgbWljcm90YXNrSWQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3ViVGltZWxpbmVzID0gbmV3IEVsZW1lbnRJbnN0cnVjdGlvbk1hcCgpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBza2lwcGVkUGxheWVycyA9IFtdO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBza2lwcGVkUGxheWVyc01hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcXVldWVkSW5zdHJ1Y3Rpb25zID0gW107XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHF1ZXJpZWRFbGVtZW50cyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYWxsUHJlU3R5bGVFbGVtZW50cyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYWxsUG9zdFN0eWxlRWxlbWVudHMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGRpc2FibGVkRWxlbWVudHNTZXQgPSBuZXcgU2V0KCk7XG4gICAgICAgIHRoaXMuZGlzYWJsZWROb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICBkaXNhYmxlZEVsZW1lbnRzU2V0LmFkZChub2RlKTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5vZGVzVGhhdEFyZURpc2FibGVkID0gX3RoaXMuZHJpdmVyLnF1ZXJ5KG5vZGUsIFFVRVVFRF9TRUxFQ1RPUiwgdHJ1ZSk7XG4gICAgICAgICAgICBmb3IgKHZhciAvKiogQHR5cGUgez99ICovIGkgPSAwOyBpIDwgbm9kZXNUaGF0QXJlRGlzYWJsZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBkaXNhYmxlZEVsZW1lbnRzU2V0LmFkZChub2Rlc1RoYXRBcmVEaXNhYmxlZFtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBib2R5Tm9kZSA9IGdldEJvZHlOb2RlKCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGFsbEVudGVyTm9kZXMgPSB0aGlzLmNvbGxlY3RlZEVudGVyRWxlbWVudHMubGVuZ3RoID9cbiAgICAgICAgICAgIHRoaXMuY29sbGVjdGVkRW50ZXJFbGVtZW50cy5maWx0ZXIoY3JlYXRlSXNSb290RmlsdGVyRm4odGhpcy5jb2xsZWN0ZWRFbnRlckVsZW1lbnRzKSkgOlxuICAgICAgICAgICAgW107XG4gICAgICAgIC8vIHRoaXMgbXVzdCBvY2N1ciBiZWZvcmUgdGhlIGluc3RydWN0aW9ucyBhcmUgYnVpbHQgYmVsb3cgc3VjaCB0aGF0XG4gICAgICAgIC8vIHRoZSA6ZW50ZXIgcXVlcmllcyBtYXRjaCB0aGUgZWxlbWVudHMgKHNpbmNlIHRoZSB0aW1lbGluZSBxdWVyaWVzXG4gICAgICAgIC8vIGFyZSBmaXJlZCBkdXJpbmcgaW5zdHJ1Y3Rpb24gYnVpbGRpbmcpLlxuICAgICAgICBmb3IgKHZhciAvKiogQHR5cGUgez99ICovIGkgPSAwOyBpIDwgYWxsRW50ZXJOb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYWRkQ2xhc3MoYWxsRW50ZXJOb2Rlc1tpXSwgRU5URVJfQ0xBU1NOQU1FKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBhbGxMZWF2ZU5vZGVzID0gW107XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGxlYXZlTm9kZXNXaXRob3V0QW5pbWF0aW9ucyA9IG5ldyBTZXQoKTtcbiAgICAgICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBpID0gMDsgaSA8IHRoaXMuY29sbGVjdGVkTGVhdmVFbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZWxlbWVudCA9IHRoaXMuY29sbGVjdGVkTGVhdmVFbGVtZW50c1tpXTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGRldGFpbHMgPSAvKiogQHR5cGUgez99ICovIChlbGVtZW50W1JFTU9WQUxfRkxBR10pO1xuICAgICAgICAgICAgaWYgKGRldGFpbHMgJiYgZGV0YWlscy5zZXRGb3JSZW1vdmFsKSB7XG4gICAgICAgICAgICAgICAgYWRkQ2xhc3MoZWxlbWVudCwgTEVBVkVfQ0xBU1NOQU1FKTtcbiAgICAgICAgICAgICAgICBhbGxMZWF2ZU5vZGVzLnB1c2goZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgaWYgKCFkZXRhaWxzLmhhc0FuaW1hdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBsZWF2ZU5vZGVzV2l0aG91dEFuaW1hdGlvbnMuYWRkKGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjbGVhbnVwRm5zLnB1c2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgYWxsRW50ZXJOb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChlbGVtZW50KSB7IHJldHVybiByZW1vdmVDbGFzcyhlbGVtZW50LCBFTlRFUl9DTEFTU05BTUUpOyB9KTtcbiAgICAgICAgICAgIGFsbExlYXZlTm9kZXMuZm9yRWFjaChmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHJlbW92ZUNsYXNzKGVsZW1lbnQsIExFQVZFX0NMQVNTTkFNRSk7XG4gICAgICAgICAgICAgICAgX3RoaXMucHJvY2Vzc0xlYXZlTm9kZShlbGVtZW50KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYWxsUGxheWVycyA9IFtdO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlcnJvbmVvdXNUcmFuc2l0aW9ucyA9IFtdO1xuICAgICAgICBmb3IgKHZhciAvKiogQHR5cGUgez99ICovIGkgPSB0aGlzLl9uYW1lc3BhY2VMaXN0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBucyA9IHRoaXMuX25hbWVzcGFjZUxpc3RbaV07XG4gICAgICAgICAgICBucy5kcmFpblF1ZXVlZFRyYW5zaXRpb25zKG1pY3JvdGFza0lkKS5mb3JFYWNoKGZ1bmN0aW9uIChlbnRyeSkge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBsYXllciA9IGVudHJ5LnBsYXllcjtcbiAgICAgICAgICAgICAgICBhbGxQbGF5ZXJzLnB1c2gocGxheWVyKTtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlbGVtZW50ID0gZW50cnkuZWxlbWVudDtcbiAgICAgICAgICAgICAgICBpZiAoIWJvZHlOb2RlIHx8ICFfdGhpcy5kcml2ZXIuY29udGFpbnNFbGVtZW50KGJvZHlOb2RlLCBlbGVtZW50KSkge1xuICAgICAgICAgICAgICAgICAgICBwbGF5ZXIuZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGluc3RydWN0aW9uID0gLyoqIEB0eXBlIHs/fSAqLyAoKF90aGlzLl9idWlsZEluc3RydWN0aW9uKGVudHJ5LCBzdWJUaW1lbGluZXMpKSk7XG4gICAgICAgICAgICAgICAgaWYgKGluc3RydWN0aW9uLmVycm9ycyAmJiBpbnN0cnVjdGlvbi5lcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9uZW91c1RyYW5zaXRpb25zLnB1c2goaW5zdHJ1Y3Rpb24pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGlmIGEgdW5tYXRjaGVkIHRyYW5zaXRpb24gaXMgcXVldWVkIHRvIGdvIHRoZW4gaXQgU0hPVUxEIE5PVCByZW5kZXJcbiAgICAgICAgICAgICAgICAvLyBhbiBhbmltYXRpb24gYW5kIGNhbmNlbCB0aGUgcHJldmlvdXNseSBydW5uaW5nIGFuaW1hdGlvbnMuXG4gICAgICAgICAgICAgICAgaWYgKGVudHJ5LmlzRmFsbGJhY2tUcmFuc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHBsYXllci5vblN0YXJ0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVyYXNlU3R5bGVzKGVsZW1lbnQsIGluc3RydWN0aW9uLmZyb21TdHlsZXMpOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgcGxheWVyLm9uRGVzdHJveShmdW5jdGlvbiAoKSB7IHJldHVybiBzZXRTdHlsZXMoZWxlbWVudCwgaW5zdHJ1Y3Rpb24udG9TdHlsZXMpOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgc2tpcHBlZFBsYXllcnMucHVzaChwbGF5ZXIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHRoaXMgbWVhbnMgdGhhdCBpZiBhIHBhcmVudCBhbmltYXRpb24gdXNlcyB0aGlzIGFuaW1hdGlvbiBhcyBhIHN1YiB0cmlnZ2VyXG4gICAgICAgICAgICAgICAgLy8gdGhlbiBpdCB3aWxsIGluc3RydWN0IHRoZSB0aW1lbGluZSBidWlsZGVyIHRvIG5vdCBhZGQgYSBwbGF5ZXIgZGVsYXksIGJ1dFxuICAgICAgICAgICAgICAgIC8vIGluc3RlYWQgc3RyZXRjaCB0aGUgZmlyc3Qga2V5ZnJhbWUgZ2FwIHVwIHVudGlsIHRoZSBhbmltYXRpb24gc3RhcnRzLiBUaGVcbiAgICAgICAgICAgICAgICAvLyByZWFzb24gdGhpcyBpcyBpbXBvcnRhbnQgaXMgdG8gcHJldmVudCBleHRyYSBpbml0aWFsaXphdGlvbiBzdHlsZXMgZnJvbSBiZWluZ1xuICAgICAgICAgICAgICAgIC8vIHJlcXVpcmVkIGJ5IHRoZSB1c2VyIGluIHRoZSBhbmltYXRpb24uXG4gICAgICAgICAgICAgICAgaW5zdHJ1Y3Rpb24udGltZWxpbmVzLmZvckVhY2goZnVuY3Rpb24gKHRsKSB7IHJldHVybiB0bC5zdHJldGNoU3RhcnRpbmdLZXlmcmFtZSA9IHRydWU7IH0pO1xuICAgICAgICAgICAgICAgIHN1YlRpbWVsaW5lcy5hcHBlbmQoZWxlbWVudCwgaW5zdHJ1Y3Rpb24udGltZWxpbmVzKTtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0dXBsZSA9IHsgaW5zdHJ1Y3Rpb246IGluc3RydWN0aW9uLCBwbGF5ZXI6IHBsYXllciwgZWxlbWVudDogZWxlbWVudCB9O1xuICAgICAgICAgICAgICAgIHF1ZXVlZEluc3RydWN0aW9ucy5wdXNoKHR1cGxlKTtcbiAgICAgICAgICAgICAgICBpbnN0cnVjdGlvbi5xdWVyaWVkRWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAoZWxlbWVudCkgeyByZXR1cm4gZ2V0T3JTZXRBc0luTWFwKHF1ZXJpZWRFbGVtZW50cywgZWxlbWVudCwgW10pLnB1c2gocGxheWVyKTsgfSk7XG4gICAgICAgICAgICAgICAgaW5zdHJ1Y3Rpb24ucHJlU3R5bGVQcm9wcy5mb3JFYWNoKGZ1bmN0aW9uIChzdHJpbmdNYXAsIGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcHJvcHMgPSBPYmplY3Qua2V5cyhzdHJpbmdNYXApO1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJvcHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzZXRWYWxfMSA9IC8qKiBAdHlwZSB7P30gKi8gKChhbGxQcmVTdHlsZUVsZW1lbnRzLmdldChlbGVtZW50KSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzZXRWYWxfMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsbFByZVN0eWxlRWxlbWVudHMuc2V0KGVsZW1lbnQsIHNldFZhbF8xID0gbmV3IFNldCgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BzLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHsgcmV0dXJuIHNldFZhbF8xLmFkZChwcm9wKTsgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpbnN0cnVjdGlvbi5wb3N0U3R5bGVQcm9wcy5mb3JFYWNoKGZ1bmN0aW9uIChzdHJpbmdNYXAsIGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcHJvcHMgPSBPYmplY3Qua2V5cyhzdHJpbmdNYXApO1xuICAgICAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzZXRWYWwgPSAvKiogQHR5cGUgez99ICovICgoYWxsUG9zdFN0eWxlRWxlbWVudHMuZ2V0KGVsZW1lbnQpKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghc2V0VmFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbGxQb3N0U3R5bGVFbGVtZW50cy5zZXQoZWxlbWVudCwgc2V0VmFsID0gbmV3IFNldCgpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwcm9wcy5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7IHJldHVybiBzZXRWYWwuYWRkKHByb3ApOyB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlcnJvbmVvdXNUcmFuc2l0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVycm9yc18xID0gW107XG4gICAgICAgICAgICBlcnJvbmVvdXNUcmFuc2l0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChpbnN0cnVjdGlvbikge1xuICAgICAgICAgICAgICAgIGVycm9yc18xLnB1c2goXCJAXCIgKyBpbnN0cnVjdGlvbi50cmlnZ2VyTmFtZSArIFwiIGhhcyBmYWlsZWQgZHVlIHRvOlxcblwiKTsgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICAgICAgICAgICgoaW5zdHJ1Y3Rpb24uZXJyb3JzKSkuZm9yRWFjaChmdW5jdGlvbiAoZXJyb3IpIHsgcmV0dXJuIGVycm9yc18xLnB1c2goXCItIFwiICsgZXJyb3IgKyBcIlxcblwiKTsgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGFsbFBsYXllcnMuZm9yRWFjaChmdW5jdGlvbiAocGxheWVyKSB7IHJldHVybiBwbGF5ZXIuZGVzdHJveSgpOyB9KTtcbiAgICAgICAgICAgIHRoaXMucmVwb3J0RXJyb3IoZXJyb3JzXzEpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHRoZXNlIGNhbiBvbmx5IGJlIGRldGVjdGVkIGhlcmUgc2luY2Ugd2UgaGF2ZSBhIG1hcCBvZiBhbGwgdGhlIGVsZW1lbnRzXG4gICAgICAgIC8vIHRoYXQgaGF2ZSBhbmltYXRpb25zIGF0dGFjaGVkIHRvIHRoZW0uLi4gV2UgdXNlIGEgc2V0IGhlcmUgaW4gdGhlIGV2ZW50XG4gICAgICAgIC8vIG11bHRpcGxlIGVudGVyIGNhcHR1cmVzIG9uIHRoZSBzYW1lIGVsZW1lbnQgd2VyZSBjYXVnaHQgaW4gZGlmZmVyZW50XG4gICAgICAgIC8vIHJlbmRlcmVyIG5hbWVzcGFjZXMgKGUuZy4gd2hlbiBhIEB0cmlnZ2VyIHdhcyBvbiBhIGhvc3QgYmluZGluZyB0aGF0IGhhZCAqbmdJZilcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZW50ZXJOb2Rlc1dpdGhvdXRBbmltYXRpb25zID0gbmV3IFNldCgpO1xuICAgICAgICBmb3IgKHZhciAvKiogQHR5cGUgez99ICovIGkgPSAwOyBpIDwgYWxsRW50ZXJOb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZWxlbWVudCA9IGFsbEVudGVyTm9kZXNbaV07XG4gICAgICAgICAgICBpZiAoIXN1YlRpbWVsaW5lcy5oYXMoZWxlbWVudCkpIHtcbiAgICAgICAgICAgICAgICBlbnRlck5vZGVzV2l0aG91dEFuaW1hdGlvbnMuYWRkKGVsZW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGFsbFByZXZpb3VzUGxheWVyc01hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc29ydGVkUGFyZW50RWxlbWVudHMgPSBbXTtcbiAgICAgICAgcXVldWVkSW5zdHJ1Y3Rpb25zLmZvckVhY2goZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlbGVtZW50ID0gZW50cnkuZWxlbWVudDtcbiAgICAgICAgICAgIGlmIChzdWJUaW1lbGluZXMuaGFzKGVsZW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgc29ydGVkUGFyZW50RWxlbWVudHMudW5zaGlmdChlbGVtZW50KTtcbiAgICAgICAgICAgICAgICBfdGhpcy5fYmVmb3JlQW5pbWF0aW9uQnVpbGQoZW50cnkucGxheWVyLm5hbWVzcGFjZUlkLCBlbnRyeS5pbnN0cnVjdGlvbiwgYWxsUHJldmlvdXNQbGF5ZXJzTWFwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHNraXBwZWRQbGF5ZXJzLmZvckVhY2goZnVuY3Rpb24gKHBsYXllcikge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZWxlbWVudCA9IHBsYXllci5lbGVtZW50O1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcHJldmlvdXNQbGF5ZXJzID0gX3RoaXMuX2dldFByZXZpb3VzUGxheWVycyhlbGVtZW50LCBmYWxzZSwgcGxheWVyLm5hbWVzcGFjZUlkLCBwbGF5ZXIudHJpZ2dlck5hbWUsIG51bGwpO1xuICAgICAgICAgICAgcHJldmlvdXNQbGF5ZXJzLmZvckVhY2goZnVuY3Rpb24gKHByZXZQbGF5ZXIpIHtcbiAgICAgICAgICAgICAgICBnZXRPclNldEFzSW5NYXAoYWxsUHJldmlvdXNQbGF5ZXJzTWFwLCBlbGVtZW50LCBbXSkucHVzaChwcmV2UGxheWVyKTtcbiAgICAgICAgICAgICAgICBwcmV2UGxheWVyLmRlc3Ryb3koKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gdGhpcyBpcyBhIHNwZWNpYWwgY2FzZSBmb3Igbm9kZXMgdGhhdCB3aWxsIGJlIHJlbW92ZWQgKGVpdGhlciBieSlcbiAgICAgICAgLy8gaGF2aW5nIHRoZWlyIG93biBsZWF2ZSBhbmltYXRpb25zIG9yIGJ5IGJlaW5nIHF1ZXJpZWQgaW4gYSBjb250YWluZXJcbiAgICAgICAgLy8gdGhhdCB3aWxsIGJlIHJlbW92ZWQgb25jZSBhIHBhcmVudCBhbmltYXRpb24gaXMgY29tcGxldGUuIFRoZSBpZGVhXG4gICAgICAgIC8vIGhlcmUgaXMgdGhhdCAqIHN0eWxlcyBtdXN0IGJlIGlkZW50aWNhbCB0byAhIHN0eWxlcyBiZWNhdXNlIG9mXG4gICAgICAgIC8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5ICgqIGlzIGFsc28gZmlsbGVkIGluIGJ5IGRlZmF1bHQgaW4gbWFueSBwbGFjZXMpLlxuICAgICAgICAvLyBPdGhlcndpc2UgKiBzdHlsZXMgd2lsbCByZXR1cm4gYW4gZW1wdHkgdmFsdWUgb3IgYXV0byBzaW5jZSB0aGUgZWxlbWVudFxuICAgICAgICAvLyB0aGF0IGlzIGJlaW5nIGdldENvbXB1dGVkU3R5bGUnZCB3aWxsIG5vdCBiZSB2aXNpYmxlIChzaW5jZSAqID0gZGVzdGluYXRpb24pXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlcGxhY2VOb2RlcyA9IGFsbExlYXZlTm9kZXMuZmlsdGVyKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVwbGFjZVBvc3RTdHlsZXNBc1ByZShub2RlLCBhbGxQcmVTdHlsZUVsZW1lbnRzLCBhbGxQb3N0U3R5bGVFbGVtZW50cyk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBQT1NUIFNUQUdFOiBmaWxsIHRoZSAqIHN0eWxlc1xuICAgICAgICB2YXIgX2EgPSBjbG9ha0FuZENvbXB1dGVTdHlsZXModGhpcy5kcml2ZXIsIGxlYXZlTm9kZXNXaXRob3V0QW5pbWF0aW9ucywgYWxsUG9zdFN0eWxlRWxlbWVudHMsIF9hbmd1bGFyX2FuaW1hdGlvbnMuQVVUT19TVFlMRSksIHBvc3RTdHlsZXNNYXAgPSBfYVswXSwgYWxsTGVhdmVRdWVyaWVkTm9kZXMgPSBfYVsxXTtcbiAgICAgICAgYWxsTGVhdmVRdWVyaWVkTm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgaWYgKHJlcGxhY2VQb3N0U3R5bGVzQXNQcmUobm9kZSwgYWxsUHJlU3R5bGVFbGVtZW50cywgYWxsUG9zdFN0eWxlRWxlbWVudHMpKSB7XG4gICAgICAgICAgICAgICAgcmVwbGFjZU5vZGVzLnB1c2gobm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBQUkUgU1RBR0U6IGZpbGwgdGhlICEgc3R5bGVzXG4gICAgICAgIHZhciBwcmVTdHlsZXNNYXAgPSAoYWxsUHJlU3R5bGVFbGVtZW50cy5zaXplID9cbiAgICAgICAgICAgIGNsb2FrQW5kQ29tcHV0ZVN0eWxlcyh0aGlzLmRyaXZlciwgZW50ZXJOb2Rlc1dpdGhvdXRBbmltYXRpb25zLCBhbGxQcmVTdHlsZUVsZW1lbnRzLCBfYW5ndWxhcl9hbmltYXRpb25zLsm1UFJFX1NUWUxFKSA6XG4gICAgICAgICAgICBbbmV3IE1hcCgpXSlbMF07XG4gICAgICAgIHJlcGxhY2VOb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwb3N0ID0gcG9zdFN0eWxlc01hcC5nZXQobm9kZSk7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwcmUgPSBwcmVTdHlsZXNNYXAuZ2V0KG5vZGUpO1xuICAgICAgICAgICAgcG9zdFN0eWxlc01hcC5zZXQobm9kZSwgLyoqIEB0eXBlIHs/fSAqLyAoX19hc3NpZ24oe30sIHBvc3QsIHByZSkpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJvb3RQbGF5ZXJzID0gW107XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN1YlBsYXllcnMgPSBbXTtcbiAgICAgICAgcXVldWVkSW5zdHJ1Y3Rpb25zLmZvckVhY2goZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgICAgICAgICB2YXIgZWxlbWVudCA9IGVudHJ5LmVsZW1lbnQsIHBsYXllciA9IGVudHJ5LnBsYXllciwgaW5zdHJ1Y3Rpb24gPSBlbnRyeS5pbnN0cnVjdGlvbjtcbiAgICAgICAgICAgIC8vIHRoaXMgbWVhbnMgdGhhdCBpdCB3YXMgbmV2ZXIgY29uc3VtZWQgYnkgYSBwYXJlbnQgYW5pbWF0aW9uIHdoaWNoXG4gICAgICAgICAgICAvLyBtZWFucyB0aGF0IGl0IGlzIGluZGVwZW5kZW50IGFuZCB0aGVyZWZvcmUgc2hvdWxkIGJlIHNldCBmb3IgYW5pbWF0aW9uXG4gICAgICAgICAgICBpZiAoc3ViVGltZWxpbmVzLmhhcyhlbGVtZW50KSkge1xuICAgICAgICAgICAgICAgIGlmIChkaXNhYmxlZEVsZW1lbnRzU2V0LmhhcyhlbGVtZW50KSkge1xuICAgICAgICAgICAgICAgICAgICBza2lwcGVkUGxheWVycy5wdXNoKHBsYXllcik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaW5uZXJQbGF5ZXIgPSBfdGhpcy5fYnVpbGRBbmltYXRpb24ocGxheWVyLm5hbWVzcGFjZUlkLCBpbnN0cnVjdGlvbiwgYWxsUHJldmlvdXNQbGF5ZXJzTWFwLCBza2lwcGVkUGxheWVyc01hcCwgcHJlU3R5bGVzTWFwLCBwb3N0U3R5bGVzTWFwKTtcbiAgICAgICAgICAgICAgICBwbGF5ZXIuc2V0UmVhbFBsYXllcihpbm5lclBsYXllcik7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGFyZW50SGFzUHJpb3JpdHkgPSBudWxsO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gaSA9IDA7IGkgPCBzb3J0ZWRQYXJlbnRFbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwYXJlbnRfMiA9IHNvcnRlZFBhcmVudEVsZW1lbnRzW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAocGFyZW50XzIgPT09IGVsZW1lbnQpXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLmRyaXZlci5jb250YWluc0VsZW1lbnQocGFyZW50XzIsIGVsZW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRIYXNQcmlvcml0eSA9IHBhcmVudF8yO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHBhcmVudEhhc1ByaW9yaXR5KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBhcmVudFBsYXllcnMgPSBfdGhpcy5wbGF5ZXJzQnlFbGVtZW50LmdldChwYXJlbnRIYXNQcmlvcml0eSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJlbnRQbGF5ZXJzICYmIHBhcmVudFBsYXllcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwbGF5ZXIucGFyZW50UGxheWVyID0gb3B0aW1pemVHcm91cFBsYXllcihwYXJlbnRQbGF5ZXJzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBza2lwcGVkUGxheWVycy5wdXNoKHBsYXllcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByb290UGxheWVycy5wdXNoKHBsYXllcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZXJhc2VTdHlsZXMoZWxlbWVudCwgaW5zdHJ1Y3Rpb24uZnJvbVN0eWxlcyk7XG4gICAgICAgICAgICAgICAgcGxheWVyLm9uRGVzdHJveShmdW5jdGlvbiAoKSB7IHJldHVybiBzZXRTdHlsZXMoZWxlbWVudCwgaW5zdHJ1Y3Rpb24udG9TdHlsZXMpOyB9KTtcbiAgICAgICAgICAgICAgICAvLyB0aGVyZSBzdGlsbCBtaWdodCBiZSBhIGFuY2VzdG9yIHBsYXllciBhbmltYXRpbmcgdGhpc1xuICAgICAgICAgICAgICAgIC8vIGVsZW1lbnQgdGhlcmVmb3JlIHdlIHdpbGwgc3RpbGwgYWRkIGl0IGFzIGEgc3ViIHBsYXllclxuICAgICAgICAgICAgICAgIC8vIGV2ZW4gaWYgaXRzIGFuaW1hdGlvbiBtYXkgYmUgZGlzYWJsZWRcbiAgICAgICAgICAgICAgICBzdWJQbGF5ZXJzLnB1c2gocGxheWVyKTtcbiAgICAgICAgICAgICAgICBpZiAoZGlzYWJsZWRFbGVtZW50c1NldC5oYXMoZWxlbWVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgc2tpcHBlZFBsYXllcnMucHVzaChwbGF5ZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIGZpbmQgYWxsIG9mIHRoZSBzdWIgcGxheWVycycgY29ycmVzcG9uZGluZyBpbm5lciBhbmltYXRpb24gcGxheWVyXG4gICAgICAgIHN1YlBsYXllcnMuZm9yRWFjaChmdW5jdGlvbiAocGxheWVyKSB7XG4gICAgICAgICAgICAvLyBldmVuIGlmIGFueSBwbGF5ZXJzIGFyZSBub3QgZm91bmQgZm9yIGEgc3ViIGFuaW1hdGlvbiB0aGVuIGl0XG4gICAgICAgICAgICAvLyB3aWxsIHN0aWxsIGNvbXBsZXRlIGl0c2VsZiBhZnRlciB0aGUgbmV4dCB0aWNrIHNpbmNlIGl0J3MgTm9vcFxuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGxheWVyc0ZvckVsZW1lbnQgPSBza2lwcGVkUGxheWVyc01hcC5nZXQocGxheWVyLmVsZW1lbnQpO1xuICAgICAgICAgICAgaWYgKHBsYXllcnNGb3JFbGVtZW50ICYmIHBsYXllcnNGb3JFbGVtZW50Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGlubmVyUGxheWVyID0gb3B0aW1pemVHcm91cFBsYXllcihwbGF5ZXJzRm9yRWxlbWVudCk7XG4gICAgICAgICAgICAgICAgcGxheWVyLnNldFJlYWxQbGF5ZXIoaW5uZXJQbGF5ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gdGhlIHJlYXNvbiB3aHkgd2UgZG9uJ3QgYWN0dWFsbHkgcGxheSB0aGUgYW5pbWF0aW9uIGlzXG4gICAgICAgIC8vIGJlY2F1c2UgYWxsIHRoYXQgYSBza2lwcGVkIHBsYXllciBpcyBkZXNpZ25lZCB0byBkbyBpcyB0b1xuICAgICAgICAvLyBmaXJlIHRoZSBzdGFydC9kb25lIHRyYW5zaXRpb24gY2FsbGJhY2sgZXZlbnRzXG4gICAgICAgIHNraXBwZWRQbGF5ZXJzLmZvckVhY2goZnVuY3Rpb24gKHBsYXllcikge1xuICAgICAgICAgICAgaWYgKHBsYXllci5wYXJlbnRQbGF5ZXIpIHtcbiAgICAgICAgICAgICAgICBwbGF5ZXIucGFyZW50UGxheWVyLm9uRGVzdHJveShmdW5jdGlvbiAoKSB7IHJldHVybiBwbGF5ZXIuZGVzdHJveSgpOyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHBsYXllci5kZXN0cm95KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBydW4gdGhyb3VnaCBhbGwgb2YgdGhlIHF1ZXVlZCByZW1vdmFscyBhbmQgc2VlIGlmIHRoZXlcbiAgICAgICAgLy8gd2VyZSBwaWNrZWQgdXAgYnkgYSBxdWVyeS4gSWYgbm90IHRoZW4gcGVyZm9ybSB0aGUgcmVtb3ZhbFxuICAgICAgICAvLyBvcGVyYXRpb24gcmlnaHQgYXdheSB1bmxlc3MgYSBwYXJlbnQgYW5pbWF0aW9uIGlzIG9uZ29pbmcuXG4gICAgICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gaSA9IDA7IGkgPCBhbGxMZWF2ZU5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlbGVtZW50ID0gYWxsTGVhdmVOb2Rlc1tpXTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGRldGFpbHMgPSAvKiogQHR5cGUgez99ICovIChlbGVtZW50W1JFTU9WQUxfRkxBR10pO1xuICAgICAgICAgICAgcmVtb3ZlQ2xhc3MoZWxlbWVudCwgTEVBVkVfQ0xBU1NOQU1FKTtcbiAgICAgICAgICAgIC8vIHRoaXMgbWVhbnMgdGhlIGVsZW1lbnQgaGFzIGEgcmVtb3ZhbCBhbmltYXRpb24gdGhhdCBpcyBiZWluZ1xuICAgICAgICAgICAgLy8gdGFrZW4gY2FyZSBvZiBhbmQgdGhlcmVmb3JlIHRoZSBpbm5lciBlbGVtZW50cyB3aWxsIGhhbmcgYXJvdW5kXG4gICAgICAgICAgICAvLyB1bnRpbCB0aGF0IGFuaW1hdGlvbiBpcyBvdmVyIChvciB0aGUgcGFyZW50IHF1ZXJpZWQgYW5pbWF0aW9uKVxuICAgICAgICAgICAgaWYgKGRldGFpbHMgJiYgZGV0YWlscy5oYXNBbmltYXRpb24pXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwbGF5ZXJzID0gW107XG4gICAgICAgICAgICAvLyBpZiB0aGlzIGVsZW1lbnQgaXMgcXVlcmllZCBvciBpZiBpdCBjb250YWlucyBxdWVyaWVkIGNoaWxkcmVuXG4gICAgICAgICAgICAvLyB0aGVuIHdlIHdhbnQgZm9yIHRoZSBlbGVtZW50IG5vdCB0byBiZSByZW1vdmVkIGZyb20gdGhlIHBhZ2VcbiAgICAgICAgICAgIC8vIHVudGlsIHRoZSBxdWVyaWVkIGFuaW1hdGlvbnMgaGF2ZSBmaW5pc2hlZFxuICAgICAgICAgICAgaWYgKHF1ZXJpZWRFbGVtZW50cy5zaXplKSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcXVlcmllZFBsYXllclJlc3VsdHMgPSBxdWVyaWVkRWxlbWVudHMuZ2V0KGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIGlmIChxdWVyaWVkUGxheWVyUmVzdWx0cyAmJiBxdWVyaWVkUGxheWVyUmVzdWx0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcGxheWVycy5wdXNoLmFwcGx5KHBsYXllcnMsIHF1ZXJpZWRQbGF5ZXJSZXN1bHRzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcXVlcmllZElubmVyRWxlbWVudHMgPSB0aGlzLmRyaXZlci5xdWVyeShlbGVtZW50LCBOR19BTklNQVRJTkdfU0VMRUNUT1IsIHRydWUpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gaiA9IDA7IGogPCBxdWVyaWVkSW5uZXJFbGVtZW50cy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBxdWVyaWVkUGxheWVycyA9IHF1ZXJpZWRFbGVtZW50cy5nZXQocXVlcmllZElubmVyRWxlbWVudHNbal0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAocXVlcmllZFBsYXllcnMgJiYgcXVlcmllZFBsYXllcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwbGF5ZXJzLnB1c2guYXBwbHkocGxheWVycywgcXVlcmllZFBsYXllcnMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYWN0aXZlUGxheWVycyA9IHBsYXllcnMuZmlsdGVyKGZ1bmN0aW9uIChwKSB7IHJldHVybiAhcC5kZXN0cm95ZWQ7IH0pO1xuICAgICAgICAgICAgaWYgKGFjdGl2ZVBsYXllcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmVtb3ZlTm9kZXNBZnRlckFuaW1hdGlvbkRvbmUodGhpcywgZWxlbWVudCwgYWN0aXZlUGxheWVycyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3NMZWF2ZU5vZGUoZWxlbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gdGhpcyBpcyByZXF1aXJlZCBzbyB0aGUgY2xlYW51cCBtZXRob2QgZG9lc24ndCByZW1vdmUgdGhlbVxuICAgICAgICBhbGxMZWF2ZU5vZGVzLmxlbmd0aCA9IDA7XG4gICAgICAgIHJvb3RQbGF5ZXJzLmZvckVhY2goZnVuY3Rpb24gKHBsYXllcikge1xuICAgICAgICAgICAgX3RoaXMucGxheWVycy5wdXNoKHBsYXllcik7XG4gICAgICAgICAgICBwbGF5ZXIub25Eb25lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBwbGF5ZXIuZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGluZGV4ID0gX3RoaXMucGxheWVycy5pbmRleE9mKHBsYXllcik7XG4gICAgICAgICAgICAgICAgX3RoaXMucGxheWVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBwbGF5ZXIucGxheSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJvb3RQbGF5ZXJzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBuYW1lc3BhY2VJZFxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVHJhbnNpdGlvbkFuaW1hdGlvbkVuZ2luZS5wcm90b3R5cGUuZWxlbWVudENvbnRhaW5zRGF0YSA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gbmFtZXNwYWNlSWRcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChuYW1lc3BhY2VJZCwgZWxlbWVudCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb250YWluc0RhdGEgPSBmYWxzZTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZGV0YWlscyA9IC8qKiBAdHlwZSB7P30gKi8gKGVsZW1lbnRbUkVNT1ZBTF9GTEFHXSk7XG4gICAgICAgIGlmIChkZXRhaWxzICYmIGRldGFpbHMuc2V0Rm9yUmVtb3ZhbClcbiAgICAgICAgICAgIGNvbnRhaW5zRGF0YSA9IHRydWU7XG4gICAgICAgIGlmICh0aGlzLnBsYXllcnNCeUVsZW1lbnQuaGFzKGVsZW1lbnQpKVxuICAgICAgICAgICAgY29udGFpbnNEYXRhID0gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMucGxheWVyc0J5UXVlcmllZEVsZW1lbnQuaGFzKGVsZW1lbnQpKVxuICAgICAgICAgICAgY29udGFpbnNEYXRhID0gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGVzQnlFbGVtZW50LmhhcyhlbGVtZW50KSlcbiAgICAgICAgICAgIGNvbnRhaW5zRGF0YSA9IHRydWU7XG4gICAgICAgIHJldHVybiB0aGlzLl9mZXRjaE5hbWVzcGFjZShuYW1lc3BhY2VJZCkuZWxlbWVudENvbnRhaW5zRGF0YShlbGVtZW50KSB8fCBjb250YWluc0RhdGE7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGNhbGxiYWNrXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUcmFuc2l0aW9uQW5pbWF0aW9uRW5naW5lLnByb3RvdHlwZS5hZnRlckZsdXNoID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBjYWxsYmFja1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKGNhbGxiYWNrKSB7IHRoaXMuX2ZsdXNoRm5zLnB1c2goY2FsbGJhY2spOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gY2FsbGJhY2tcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRyYW5zaXRpb25BbmltYXRpb25FbmdpbmUucHJvdG90eXBlLmFmdGVyRmx1c2hBbmltYXRpb25zRG9uZSA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gY2FsbGJhY2tcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChjYWxsYmFjaykgeyB0aGlzLl93aGVuUXVpZXRGbnMucHVzaChjYWxsYmFjayk7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XG4gICAgICogQHBhcmFtIHs/fSBpc1F1ZXJpZWRFbGVtZW50XG4gICAgICogQHBhcmFtIHs/PX0gbmFtZXNwYWNlSWRcbiAgICAgKiBAcGFyYW0gez89fSB0cmlnZ2VyTmFtZVxuICAgICAqIEBwYXJhbSB7Pz19IHRvU3RhdGVWYWx1ZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVHJhbnNpdGlvbkFuaW1hdGlvbkVuZ2luZS5wcm90b3R5cGUuX2dldFByZXZpb3VzUGxheWVycyA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFxuICAgICAqIEBwYXJhbSB7P30gaXNRdWVyaWVkRWxlbWVudFxuICAgICAqIEBwYXJhbSB7Pz19IG5hbWVzcGFjZUlkXG4gICAgICogQHBhcmFtIHs/PX0gdHJpZ2dlck5hbWVcbiAgICAgKiBAcGFyYW0gez89fSB0b1N0YXRlVmFsdWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChlbGVtZW50LCBpc1F1ZXJpZWRFbGVtZW50LCBuYW1lc3BhY2VJZCwgdHJpZ2dlck5hbWUsIHRvU3RhdGVWYWx1ZSkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwbGF5ZXJzID0gW107XG4gICAgICAgIGlmIChpc1F1ZXJpZWRFbGVtZW50KSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBxdWVyaWVkRWxlbWVudFBsYXllcnMgPSB0aGlzLnBsYXllcnNCeVF1ZXJpZWRFbGVtZW50LmdldChlbGVtZW50KTtcbiAgICAgICAgICAgIGlmIChxdWVyaWVkRWxlbWVudFBsYXllcnMpIHtcbiAgICAgICAgICAgICAgICBwbGF5ZXJzID0gcXVlcmllZEVsZW1lbnRQbGF5ZXJzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZWxlbWVudFBsYXllcnMgPSB0aGlzLnBsYXllcnNCeUVsZW1lbnQuZ2V0KGVsZW1lbnQpO1xuICAgICAgICAgICAgaWYgKGVsZW1lbnRQbGF5ZXJzKSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaXNSZW1vdmFsQW5pbWF0aW9uXzEgPSAhdG9TdGF0ZVZhbHVlIHx8IHRvU3RhdGVWYWx1ZSA9PSBWT0lEX1ZBTFVFO1xuICAgICAgICAgICAgICAgIGVsZW1lbnRQbGF5ZXJzLmZvckVhY2goZnVuY3Rpb24gKHBsYXllcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAocGxheWVyLnF1ZXVlZClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1JlbW92YWxBbmltYXRpb25fMSAmJiBwbGF5ZXIudHJpZ2dlck5hbWUgIT0gdHJpZ2dlck5hbWUpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIHBsYXllcnMucHVzaChwbGF5ZXIpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChuYW1lc3BhY2VJZCB8fCB0cmlnZ2VyTmFtZSkge1xuICAgICAgICAgICAgcGxheWVycyA9IHBsYXllcnMuZmlsdGVyKGZ1bmN0aW9uIChwbGF5ZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAobmFtZXNwYWNlSWQgJiYgbmFtZXNwYWNlSWQgIT0gcGxheWVyLm5hbWVzcGFjZUlkKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgaWYgKHRyaWdnZXJOYW1lICYmIHRyaWdnZXJOYW1lICE9IHBsYXllci50cmlnZ2VyTmFtZSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBsYXllcnM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5hbWVzcGFjZUlkXG4gICAgICogQHBhcmFtIHs/fSBpbnN0cnVjdGlvblxuICAgICAqIEBwYXJhbSB7P30gYWxsUHJldmlvdXNQbGF5ZXJzTWFwXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUcmFuc2l0aW9uQW5pbWF0aW9uRW5naW5lLnByb3RvdHlwZS5fYmVmb3JlQW5pbWF0aW9uQnVpbGQgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IG5hbWVzcGFjZUlkXG4gICAgICogQHBhcmFtIHs/fSBpbnN0cnVjdGlvblxuICAgICAqIEBwYXJhbSB7P30gYWxsUHJldmlvdXNQbGF5ZXJzTWFwXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAobmFtZXNwYWNlSWQsIGluc3RydWN0aW9uLCBhbGxQcmV2aW91c1BsYXllcnNNYXApIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdHJpZ2dlck5hbWUgPSBpbnN0cnVjdGlvbi50cmlnZ2VyTmFtZTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcm9vdEVsZW1lbnQgPSBpbnN0cnVjdGlvbi5lbGVtZW50O1xuICAgICAgICAvLyB3aGVuIGEgcmVtb3ZhbCBhbmltYXRpb24gb2NjdXJzLCBBTEwgcHJldmlvdXMgcGxheWVycyBhcmUgY29sbGVjdGVkXG4gICAgICAgIC8vIGFuZCBkZXN0cm95ZWQgKGV2ZW4gaWYgdGhleSBhcmUgb3V0c2lkZSBvZiB0aGUgY3VycmVudCBuYW1lc3BhY2UpXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRhcmdldE5hbWVTcGFjZUlkID0gaW5zdHJ1Y3Rpb24uaXNSZW1vdmFsVHJhbnNpdGlvbiA/IHVuZGVmaW5lZCA6IG5hbWVzcGFjZUlkO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0YXJnZXRUcmlnZ2VyTmFtZSA9IGluc3RydWN0aW9uLmlzUmVtb3ZhbFRyYW5zaXRpb24gPyB1bmRlZmluZWQgOiB0cmlnZ2VyTmFtZTtcbiAgICAgICAgaW5zdHJ1Y3Rpb24udGltZWxpbmVzLm1hcChmdW5jdGlvbiAodGltZWxpbmVJbnN0cnVjdGlvbikge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZWxlbWVudCA9IHRpbWVsaW5lSW5zdHJ1Y3Rpb24uZWxlbWVudDtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGlzUXVlcmllZEVsZW1lbnQgPSBlbGVtZW50ICE9PSByb290RWxlbWVudDtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBsYXllcnMgPSBnZXRPclNldEFzSW5NYXAoYWxsUHJldmlvdXNQbGF5ZXJzTWFwLCBlbGVtZW50LCBbXSk7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwcmV2aW91c1BsYXllcnMgPSBfdGhpcy5fZ2V0UHJldmlvdXNQbGF5ZXJzKGVsZW1lbnQsIGlzUXVlcmllZEVsZW1lbnQsIHRhcmdldE5hbWVTcGFjZUlkLCB0YXJnZXRUcmlnZ2VyTmFtZSwgaW5zdHJ1Y3Rpb24udG9TdGF0ZSk7XG4gICAgICAgICAgICBwcmV2aW91c1BsYXllcnMuZm9yRWFjaChmdW5jdGlvbiAocGxheWVyKSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVhbFBsYXllciA9IC8qKiBAdHlwZSB7P30gKi8gKHBsYXllci5nZXRSZWFsUGxheWVyKCkpO1xuICAgICAgICAgICAgICAgIGlmIChyZWFsUGxheWVyLmJlZm9yZURlc3Ryb3kpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVhbFBsYXllci5iZWZvcmVEZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBsYXllci5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgcGxheWVycy5wdXNoKHBsYXllcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIHRoaXMgbmVlZHMgdG8gYmUgZG9uZSBzbyB0aGF0IHRoZSBQUkUvUE9TVCBzdHlsZXMgY2FuIGJlXG4gICAgICAgIC8vIGNvbXB1dGVkIHByb3Blcmx5IHdpdGhvdXQgaW50ZXJmZXJpbmcgd2l0aCB0aGUgcHJldmlvdXMgYW5pbWF0aW9uXG4gICAgICAgIGVyYXNlU3R5bGVzKHJvb3RFbGVtZW50LCBpbnN0cnVjdGlvbi5mcm9tU3R5bGVzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbmFtZXNwYWNlSWRcbiAgICAgKiBAcGFyYW0gez99IGluc3RydWN0aW9uXG4gICAgICogQHBhcmFtIHs/fSBhbGxQcmV2aW91c1BsYXllcnNNYXBcbiAgICAgKiBAcGFyYW0gez99IHNraXBwZWRQbGF5ZXJzTWFwXG4gICAgICogQHBhcmFtIHs/fSBwcmVTdHlsZXNNYXBcbiAgICAgKiBAcGFyYW0gez99IHBvc3RTdHlsZXNNYXBcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRyYW5zaXRpb25BbmltYXRpb25FbmdpbmUucHJvdG90eXBlLl9idWlsZEFuaW1hdGlvbiA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gbmFtZXNwYWNlSWRcbiAgICAgKiBAcGFyYW0gez99IGluc3RydWN0aW9uXG4gICAgICogQHBhcmFtIHs/fSBhbGxQcmV2aW91c1BsYXllcnNNYXBcbiAgICAgKiBAcGFyYW0gez99IHNraXBwZWRQbGF5ZXJzTWFwXG4gICAgICogQHBhcmFtIHs/fSBwcmVTdHlsZXNNYXBcbiAgICAgKiBAcGFyYW0gez99IHBvc3RTdHlsZXNNYXBcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChuYW1lc3BhY2VJZCwgaW5zdHJ1Y3Rpb24sIGFsbFByZXZpb3VzUGxheWVyc01hcCwgc2tpcHBlZFBsYXllcnNNYXAsIHByZVN0eWxlc01hcCwgcG9zdFN0eWxlc01hcCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0cmlnZ2VyTmFtZSA9IGluc3RydWN0aW9uLnRyaWdnZXJOYW1lO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByb290RWxlbWVudCA9IGluc3RydWN0aW9uLmVsZW1lbnQ7XG4gICAgICAgIC8vIHdlIGZpcnN0IHJ1biB0aGlzIHNvIHRoYXQgdGhlIHByZXZpb3VzIGFuaW1hdGlvbiBwbGF5ZXJcbiAgICAgICAgLy8gZGF0YSBjYW4gYmUgcGFzc2VkIGludG8gdGhlIHN1Y2Nlc3NpdmUgYW5pbWF0aW9uIHBsYXllcnNcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYWxsUXVlcmllZFBsYXllcnMgPSBbXTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYWxsQ29uc3VtZWRFbGVtZW50cyA9IG5ldyBTZXQoKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYWxsU3ViRWxlbWVudHMgPSBuZXcgU2V0KCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGFsbE5ld1BsYXllcnMgPSBpbnN0cnVjdGlvbi50aW1lbGluZXMubWFwKGZ1bmN0aW9uICh0aW1lbGluZUluc3RydWN0aW9uKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlbGVtZW50ID0gdGltZWxpbmVJbnN0cnVjdGlvbi5lbGVtZW50O1xuICAgICAgICAgICAgYWxsQ29uc3VtZWRFbGVtZW50cy5hZGQoZWxlbWVudCk7XG4gICAgICAgICAgICAvLyBGSVhNRSAobWF0c2tvKTogbWFrZSBzdXJlIHRvLWJlLXJlbW92ZWQgYW5pbWF0aW9ucyBhcmUgcmVtb3ZlZCBwcm9wZXJseVxuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZGV0YWlscyA9IGVsZW1lbnRbUkVNT1ZBTF9GTEFHXTtcbiAgICAgICAgICAgIGlmIChkZXRhaWxzICYmIGRldGFpbHMucmVtb3ZlZEJlZm9yZVF1ZXJpZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBfYW5ndWxhcl9hbmltYXRpb25zLk5vb3BBbmltYXRpb25QbGF5ZXIoKTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGlzUXVlcmllZEVsZW1lbnQgPSBlbGVtZW50ICE9PSByb290RWxlbWVudDtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHByZXZpb3VzUGxheWVycyA9IGZsYXR0ZW5Hcm91cFBsYXllcnMoKGFsbFByZXZpb3VzUGxheWVyc01hcC5nZXQoZWxlbWVudCkgfHwgRU1QVFlfUExBWUVSX0FSUkFZKVxuICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKHApIHsgcmV0dXJuIHAuZ2V0UmVhbFBsYXllcigpOyB9KSlcbiAgICAgICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChwKSB7XG4gICAgICAgICAgICAgICAgLy8gdGhlIGBlbGVtZW50YCBpcyBub3QgYXBhcnQgb2YgdGhlIEFuaW1hdGlvblBsYXllciBkZWZpbml0aW9uLCBidXRcbiAgICAgICAgICAgICAgICAvLyBNb2NrL1dlYkFuaW1hdGlvbnNcbiAgICAgICAgICAgICAgICAvLyB1c2UgdGhlIGVsZW1lbnQgd2l0aGluIHRoZWlyIGltcGxlbWVudGF0aW9uLiBUaGlzIHdpbGwgYmUgYWRkZWQgaW4gQW5ndWxhcjUgdG9cbiAgICAgICAgICAgICAgICAvLyBBbmltYXRpb25QbGF5ZXJcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwcCA9IC8qKiBAdHlwZSB7P30gKi8gKHApO1xuICAgICAgICAgICAgICAgIHJldHVybiBwcC5lbGVtZW50ID8gcHAuZWxlbWVudCA9PT0gZWxlbWVudCA6IGZhbHNlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwcmVTdHlsZXMgPSBwcmVTdHlsZXNNYXAuZ2V0KGVsZW1lbnQpO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcG9zdFN0eWxlcyA9IHBvc3RTdHlsZXNNYXAuZ2V0KGVsZW1lbnQpO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8ga2V5ZnJhbWVzID0gbm9ybWFsaXplS2V5ZnJhbWVzKF90aGlzLmRyaXZlciwgX3RoaXMuX25vcm1hbGl6ZXIsIGVsZW1lbnQsIHRpbWVsaW5lSW5zdHJ1Y3Rpb24ua2V5ZnJhbWVzLCBwcmVTdHlsZXMsIHBvc3RTdHlsZXMpO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGxheWVyID0gX3RoaXMuX2J1aWxkUGxheWVyKHRpbWVsaW5lSW5zdHJ1Y3Rpb24sIGtleWZyYW1lcywgcHJldmlvdXNQbGF5ZXJzKTtcbiAgICAgICAgICAgIC8vIHRoaXMgbWVhbnMgdGhhdCB0aGlzIHBhcnRpY3VsYXIgcGxheWVyIGJlbG9uZ3MgdG8gYSBzdWIgdHJpZ2dlci4gSXQgaXNcbiAgICAgICAgICAgIC8vIGltcG9ydGFudCB0aGF0IHdlIG1hdGNoIHRoaXMgcGxheWVyIHVwIHdpdGggdGhlIGNvcnJlc3BvbmRpbmcgKEB0cmlnZ2VyLmxpc3RlbmVyKVxuICAgICAgICAgICAgaWYgKHRpbWVsaW5lSW5zdHJ1Y3Rpb24uc3ViVGltZWxpbmUgJiYgc2tpcHBlZFBsYXllcnNNYXApIHtcbiAgICAgICAgICAgICAgICBhbGxTdWJFbGVtZW50cy5hZGQoZWxlbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNRdWVyaWVkRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHdyYXBwZWRQbGF5ZXIgPSBuZXcgVHJhbnNpdGlvbkFuaW1hdGlvblBsYXllcihuYW1lc3BhY2VJZCwgdHJpZ2dlck5hbWUsIGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIHdyYXBwZWRQbGF5ZXIuc2V0UmVhbFBsYXllcihwbGF5ZXIpO1xuICAgICAgICAgICAgICAgIGFsbFF1ZXJpZWRQbGF5ZXJzLnB1c2god3JhcHBlZFBsYXllcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcGxheWVyO1xuICAgICAgICB9KTtcbiAgICAgICAgYWxsUXVlcmllZFBsYXllcnMuZm9yRWFjaChmdW5jdGlvbiAocGxheWVyKSB7XG4gICAgICAgICAgICBnZXRPclNldEFzSW5NYXAoX3RoaXMucGxheWVyc0J5UXVlcmllZEVsZW1lbnQsIHBsYXllci5lbGVtZW50LCBbXSkucHVzaChwbGF5ZXIpO1xuICAgICAgICAgICAgcGxheWVyLm9uRG9uZShmdW5jdGlvbiAoKSB7IHJldHVybiBkZWxldGVPclVuc2V0SW5NYXAoX3RoaXMucGxheWVyc0J5UXVlcmllZEVsZW1lbnQsIHBsYXllci5lbGVtZW50LCBwbGF5ZXIpOyB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGFsbENvbnN1bWVkRWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAoZWxlbWVudCkgeyByZXR1cm4gYWRkQ2xhc3MoZWxlbWVudCwgTkdfQU5JTUFUSU5HX0NMQVNTTkFNRSk7IH0pO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwbGF5ZXIgPSBvcHRpbWl6ZUdyb3VwUGxheWVyKGFsbE5ld1BsYXllcnMpO1xuICAgICAgICBwbGF5ZXIub25EZXN0cm95KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGFsbENvbnN1bWVkRWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAoZWxlbWVudCkgeyByZXR1cm4gcmVtb3ZlQ2xhc3MoZWxlbWVudCwgTkdfQU5JTUFUSU5HX0NMQVNTTkFNRSk7IH0pO1xuICAgICAgICAgICAgc2V0U3R5bGVzKHJvb3RFbGVtZW50LCBpbnN0cnVjdGlvbi50b1N0eWxlcyk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyB0aGlzIGJhc2ljYWxseSBtYWtlcyBhbGwgb2YgdGhlIGNhbGxiYWNrcyBmb3Igc3ViIGVsZW1lbnQgYW5pbWF0aW9uc1xuICAgICAgICAvLyBiZSBkZXBlbmRlbnQgb24gdGhlIHVwcGVyIHBsYXllcnMgZm9yIHdoZW4gdGhleSBmaW5pc2hcbiAgICAgICAgYWxsU3ViRWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAoZWxlbWVudCkgeyBnZXRPclNldEFzSW5NYXAoc2tpcHBlZFBsYXllcnNNYXAsIGVsZW1lbnQsIFtdKS5wdXNoKHBsYXllcik7IH0pO1xuICAgICAgICByZXR1cm4gcGxheWVyO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBpbnN0cnVjdGlvblxuICAgICAqIEBwYXJhbSB7P30ga2V5ZnJhbWVzXG4gICAgICogQHBhcmFtIHs/fSBwcmV2aW91c1BsYXllcnNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRyYW5zaXRpb25BbmltYXRpb25FbmdpbmUucHJvdG90eXBlLl9idWlsZFBsYXllciA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gaW5zdHJ1Y3Rpb25cbiAgICAgKiBAcGFyYW0gez99IGtleWZyYW1lc1xuICAgICAqIEBwYXJhbSB7P30gcHJldmlvdXNQbGF5ZXJzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoaW5zdHJ1Y3Rpb24sIGtleWZyYW1lcywgcHJldmlvdXNQbGF5ZXJzKSB7XG4gICAgICAgIGlmIChrZXlmcmFtZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZHJpdmVyLmFuaW1hdGUoaW5zdHJ1Y3Rpb24uZWxlbWVudCwga2V5ZnJhbWVzLCBpbnN0cnVjdGlvbi5kdXJhdGlvbiwgaW5zdHJ1Y3Rpb24uZGVsYXksIGluc3RydWN0aW9uLmVhc2luZywgcHJldmlvdXNQbGF5ZXJzKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBzcGVjaWFsIGNhc2UgZm9yIHdoZW4gYW4gZW1wdHkgdHJhbnNpdGlvbnxkZWZpbml0aW9uIGlzIHByb3ZpZGVkXG4gICAgICAgIC8vIC4uLiB0aGVyZSBpcyBubyBwb2ludCBpbiByZW5kZXJpbmcgYW4gZW1wdHkgYW5pbWF0aW9uXG4gICAgICAgIHJldHVybiBuZXcgX2FuZ3VsYXJfYW5pbWF0aW9ucy5Ob29wQW5pbWF0aW9uUGxheWVyKCk7XG4gICAgfTtcbiAgICByZXR1cm4gVHJhbnNpdGlvbkFuaW1hdGlvbkVuZ2luZTtcbn0oKSk7XG52YXIgVHJhbnNpdGlvbkFuaW1hdGlvblBsYXllciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVHJhbnNpdGlvbkFuaW1hdGlvblBsYXllcihuYW1lc3BhY2VJZCwgdHJpZ2dlck5hbWUsIGVsZW1lbnQpIHtcbiAgICAgICAgdGhpcy5uYW1lc3BhY2VJZCA9IG5hbWVzcGFjZUlkO1xuICAgICAgICB0aGlzLnRyaWdnZXJOYW1lID0gdHJpZ2dlck5hbWU7XG4gICAgICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICAgIHRoaXMuX3BsYXllciA9IG5ldyBfYW5ndWxhcl9hbmltYXRpb25zLk5vb3BBbmltYXRpb25QbGF5ZXIoKTtcbiAgICAgICAgdGhpcy5fY29udGFpbnNSZWFsUGxheWVyID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3F1ZXVlZENhbGxiYWNrcyA9IHt9O1xuICAgICAgICB0aGlzLl9kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5tYXJrZWRGb3JEZXN0cm95ID0gZmFsc2U7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUcmFuc2l0aW9uQW5pbWF0aW9uUGxheWVyLnByb3RvdHlwZSwgXCJxdWV1ZWRcIiwge1xuICAgICAgICBnZXQ6IC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fY29udGFpbnNSZWFsUGxheWVyID09IGZhbHNlOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVHJhbnNpdGlvbkFuaW1hdGlvblBsYXllci5wcm90b3R5cGUsIFwiZGVzdHJveWVkXCIsIHtcbiAgICAgICAgZ2V0OiAvKipcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2Rlc3Ryb3llZDsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBwbGF5ZXJcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRyYW5zaXRpb25BbmltYXRpb25QbGF5ZXIucHJvdG90eXBlLnNldFJlYWxQbGF5ZXIgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IHBsYXllclxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKHBsYXllcikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5fY29udGFpbnNSZWFsUGxheWVyKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLl9wbGF5ZXIgPSBwbGF5ZXI7XG4gICAgICAgIE9iamVjdC5rZXlzKHRoaXMuX3F1ZXVlZENhbGxiYWNrcykuZm9yRWFjaChmdW5jdGlvbiAocGhhc2UpIHtcbiAgICAgICAgICAgIF90aGlzLl9xdWV1ZWRDYWxsYmFja3NbcGhhc2VdLmZvckVhY2goZnVuY3Rpb24gKGNhbGxiYWNrKSB7IHJldHVybiBsaXN0ZW5PblBsYXllcihwbGF5ZXIsIHBoYXNlLCB1bmRlZmluZWQsIGNhbGxiYWNrKTsgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9xdWV1ZWRDYWxsYmFja3MgPSB7fTtcbiAgICAgICAgdGhpcy5fY29udGFpbnNSZWFsUGxheWVyID0gdHJ1ZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVHJhbnNpdGlvbkFuaW1hdGlvblBsYXllci5wcm90b3R5cGUuZ2V0UmVhbFBsYXllciA9IC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fcGxheWVyOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEBwYXJhbSB7P30gY2FsbGJhY2tcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRyYW5zaXRpb25BbmltYXRpb25QbGF5ZXIucHJvdG90eXBlLl9xdWV1ZUV2ZW50ID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHBhcmFtIHs/fSBjYWxsYmFja1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKG5hbWUsIGNhbGxiYWNrKSB7XG4gICAgICAgIGdldE9yU2V0QXNJbk1hcCh0aGlzLl9xdWV1ZWRDYWxsYmFja3MsIG5hbWUsIFtdKS5wdXNoKGNhbGxiYWNrKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZm5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRyYW5zaXRpb25BbmltYXRpb25QbGF5ZXIucHJvdG90eXBlLm9uRG9uZSA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gZm5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChmbikge1xuICAgICAgICBpZiAodGhpcy5xdWV1ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3F1ZXVlRXZlbnQoJ2RvbmUnLCBmbik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcGxheWVyLm9uRG9uZShmbik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGZuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUcmFuc2l0aW9uQW5pbWF0aW9uUGxheWVyLnByb3RvdHlwZS5vblN0YXJ0ID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBmblxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIGlmICh0aGlzLnF1ZXVlZCkge1xuICAgICAgICAgICAgdGhpcy5fcXVldWVFdmVudCgnc3RhcnQnLCBmbik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcGxheWVyLm9uU3RhcnQoZm4pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBmblxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVHJhbnNpdGlvbkFuaW1hdGlvblBsYXllci5wcm90b3R5cGUub25EZXN0cm95ID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBmblxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIGlmICh0aGlzLnF1ZXVlZCkge1xuICAgICAgICAgICAgdGhpcy5fcXVldWVFdmVudCgnZGVzdHJveScsIGZuKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wbGF5ZXIub25EZXN0cm95KGZuKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVHJhbnNpdGlvbkFuaW1hdGlvblBsYXllci5wcm90b3R5cGUuaW5pdCA9IC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKCkgeyB0aGlzLl9wbGF5ZXIuaW5pdCgpOyB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVHJhbnNpdGlvbkFuaW1hdGlvblBsYXllci5wcm90b3R5cGUuaGFzU3RhcnRlZCA9IC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5xdWV1ZWQgPyBmYWxzZSA6IHRoaXMuX3BsYXllci5oYXNTdGFydGVkKCk7IH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUcmFuc2l0aW9uQW5pbWF0aW9uUGxheWVyLnByb3RvdHlwZS5wbGF5ID0gLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoKSB7ICF0aGlzLnF1ZXVlZCAmJiB0aGlzLl9wbGF5ZXIucGxheSgpOyB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVHJhbnNpdGlvbkFuaW1hdGlvblBsYXllci5wcm90b3R5cGUucGF1c2UgPSAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uICgpIHsgIXRoaXMucXVldWVkICYmIHRoaXMuX3BsYXllci5wYXVzZSgpOyB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVHJhbnNpdGlvbkFuaW1hdGlvblBsYXllci5wcm90b3R5cGUucmVzdGFydCA9IC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKCkgeyAhdGhpcy5xdWV1ZWQgJiYgdGhpcy5fcGxheWVyLnJlc3RhcnQoKTsgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRyYW5zaXRpb25BbmltYXRpb25QbGF5ZXIucHJvdG90eXBlLmZpbmlzaCA9IC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKCkgeyB0aGlzLl9wbGF5ZXIuZmluaXNoKCk7IH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUcmFuc2l0aW9uQW5pbWF0aW9uUGxheWVyLnByb3RvdHlwZS5kZXN0cm95ID0gLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2Rlc3Ryb3llZCA9IHRydWU7XG4gICAgICAgIHRoaXMuX3BsYXllci5kZXN0cm95KCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRyYW5zaXRpb25BbmltYXRpb25QbGF5ZXIucHJvdG90eXBlLnJlc2V0ID0gLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoKSB7ICF0aGlzLnF1ZXVlZCAmJiB0aGlzLl9wbGF5ZXIucmVzZXQoKTsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHBcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRyYW5zaXRpb25BbmltYXRpb25QbGF5ZXIucHJvdG90eXBlLnNldFBvc2l0aW9uID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBwXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAocCkge1xuICAgICAgICBpZiAoIXRoaXMucXVldWVkKSB7XG4gICAgICAgICAgICB0aGlzLl9wbGF5ZXIuc2V0UG9zaXRpb24ocCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVHJhbnNpdGlvbkFuaW1hdGlvblBsYXllci5wcm90b3R5cGUuZ2V0UG9zaXRpb24gPSAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMucXVldWVkID8gMCA6IHRoaXMuX3BsYXllci5nZXRQb3NpdGlvbigpOyB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUcmFuc2l0aW9uQW5pbWF0aW9uUGxheWVyLnByb3RvdHlwZSwgXCJ0b3RhbFRpbWVcIiwge1xuICAgICAgICBnZXQ6IC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fcGxheWVyLnRvdGFsVGltZTsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIFRyYW5zaXRpb25BbmltYXRpb25QbGF5ZXI7XG59KCkpO1xuLyoqXG4gKiBAcGFyYW0gez99IG1hcFxuICogQHBhcmFtIHs/fSBrZXlcbiAqIEBwYXJhbSB7P30gdmFsdWVcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGRlbGV0ZU9yVW5zZXRJbk1hcChtYXAsIGtleSwgdmFsdWUpIHtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjdXJyZW50VmFsdWVzO1xuICAgIGlmIChtYXAgaW5zdGFuY2VvZiBNYXApIHtcbiAgICAgICAgY3VycmVudFZhbHVlcyA9IG1hcC5nZXQoa2V5KTtcbiAgICAgICAgaWYgKGN1cnJlbnRWYWx1ZXMpIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50VmFsdWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGluZGV4ID0gY3VycmVudFZhbHVlcy5pbmRleE9mKHZhbHVlKTtcbiAgICAgICAgICAgICAgICBjdXJyZW50VmFsdWVzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY3VycmVudFZhbHVlcy5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgICAgIG1hcC5kZWxldGUoa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY3VycmVudFZhbHVlcyA9IG1hcFtrZXldO1xuICAgICAgICBpZiAoY3VycmVudFZhbHVlcykge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRWYWx1ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaW5kZXggPSBjdXJyZW50VmFsdWVzLmluZGV4T2YodmFsdWUpO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRWYWx1ZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjdXJyZW50VmFsdWVzLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIG1hcFtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjdXJyZW50VmFsdWVzO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IHZhbHVlXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBub3JtYWxpemVUcmlnZ2VyVmFsdWUodmFsdWUpIHtcbiAgICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZSA/ICcxJyA6ICcwJztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZSAhPSBudWxsID8gdmFsdWUudG9TdHJpbmcoKSA6IG51bGw7XG4gICAgfVxufVxuLyoqXG4gKiBAcGFyYW0gez99IG5vZGVcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGlzRWxlbWVudE5vZGUobm9kZSkge1xuICAgIHJldHVybiBub2RlICYmIG5vZGVbJ25vZGVUeXBlJ10gPT09IDE7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gZXZlbnROYW1lXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBpc1RyaWdnZXJFdmVudFZhbGlkKGV2ZW50TmFtZSkge1xuICAgIHJldHVybiBldmVudE5hbWUgPT0gJ3N0YXJ0JyB8fCBldmVudE5hbWUgPT0gJ2RvbmUnO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IGVsZW1lbnRcbiAqIEBwYXJhbSB7Pz19IHZhbHVlXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBjbG9ha0VsZW1lbnQoZWxlbWVudCwgdmFsdWUpIHtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBvbGRWYWx1ZSA9IGVsZW1lbnQuc3R5bGUuZGlzcGxheTtcbiAgICBlbGVtZW50LnN0eWxlLmRpc3BsYXkgPSB2YWx1ZSAhPSBudWxsID8gdmFsdWUgOiAnbm9uZSc7XG4gICAgcmV0dXJuIG9sZFZhbHVlO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IGRyaXZlclxuICogQHBhcmFtIHs/fSBlbGVtZW50c1xuICogQHBhcmFtIHs/fSBlbGVtZW50UHJvcHNNYXBcbiAqIEBwYXJhbSB7P30gZGVmYXVsdFN0eWxlXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBjbG9ha0FuZENvbXB1dGVTdHlsZXMoZHJpdmVyLCBlbGVtZW50cywgZWxlbWVudFByb3BzTWFwLCBkZWZhdWx0U3R5bGUpIHtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjbG9ha1ZhbHMgPSBbXTtcbiAgICBlbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChlbGVtZW50KSB7IHJldHVybiBjbG9ha1ZhbHMucHVzaChjbG9ha0VsZW1lbnQoZWxlbWVudCkpOyB9KTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2YWx1ZXNNYXAgPSBuZXcgTWFwKCk7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZmFpbGVkRWxlbWVudHMgPSBbXTtcbiAgICBlbGVtZW50UHJvcHNNYXAuZm9yRWFjaChmdW5jdGlvbiAocHJvcHMsIGVsZW1lbnQpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3R5bGVzID0ge307XG4gICAgICAgIHByb3BzLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHZhbHVlID0gc3R5bGVzW3Byb3BdID0gZHJpdmVyLmNvbXB1dGVTdHlsZShlbGVtZW50LCBwcm9wLCBkZWZhdWx0U3R5bGUpO1xuICAgICAgICAgICAgLy8gdGhlcmUgaXMgbm8gZWFzeSB3YXkgdG8gZGV0ZWN0IHRoaXMgYmVjYXVzZSBhIHN1YiBlbGVtZW50IGNvdWxkIGJlIHJlbW92ZWRcbiAgICAgICAgICAgIC8vIGJ5IGEgcGFyZW50IGFuaW1hdGlvbiBlbGVtZW50IGJlaW5nIGRldGFjaGVkLlxuICAgICAgICAgICAgaWYgKCF2YWx1ZSB8fCB2YWx1ZS5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgICAgIGVsZW1lbnRbUkVNT1ZBTF9GTEFHXSA9IE5VTExfUkVNT1ZFRF9RVUVSSUVEX1NUQVRFO1xuICAgICAgICAgICAgICAgIGZhaWxlZEVsZW1lbnRzLnB1c2goZWxlbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB2YWx1ZXNNYXAuc2V0KGVsZW1lbnQsIHN0eWxlcyk7XG4gICAgfSk7XG4gICAgLy8gd2UgdXNlIGEgaW5kZXggdmFyaWFibGUgaGVyZSBzaW5jZSBTZXQuZm9yRWFjaChhLCBpKSBkb2VzIG5vdCByZXR1cm5cbiAgICAvLyBhbiBpbmRleCB2YWx1ZSBmb3IgdGhlIGNsb3N1cmUgKGJ1dCBpbnN0ZWFkIGp1c3QgdGhlIHZhbHVlKVxuICAgIHZhciAvKiogQHR5cGUgez99ICovIGkgPSAwO1xuICAgIGVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKGVsZW1lbnQpIHsgcmV0dXJuIGNsb2FrRWxlbWVudChlbGVtZW50LCBjbG9ha1ZhbHNbaSsrXSk7IH0pO1xuICAgIHJldHVybiBbdmFsdWVzTWFwLCBmYWlsZWRFbGVtZW50c107XG59XG4vKipcbiAqIEBwYXJhbSB7P30gbm9kZXNcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUlzUm9vdEZpbHRlckZuKG5vZGVzKSB7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbm9kZVNldCA9IG5ldyBTZXQobm9kZXMpO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIGtub3duUm9vdENvbnRhaW5lciA9IG5ldyBTZXQoKTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpc1Jvb3Q7XG4gICAgaXNSb290ID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgaWYgKCFub2RlKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmIChub2RlU2V0Lmhhcyhub2RlLnBhcmVudE5vZGUpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoa25vd25Sb290Q29udGFpbmVyLmhhcyhub2RlLnBhcmVudE5vZGUpKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmIChpc1Jvb3Qobm9kZS5wYXJlbnROb2RlKSkge1xuICAgICAgICAgICAga25vd25Sb290Q29udGFpbmVyLmFkZChub2RlKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIHJldHVybiBpc1Jvb3Q7XG59XG52YXIgQ0xBU1NFU19DQUNIRV9LRVkgPSAnJCRjbGFzc2VzJztcbi8qKlxuICogQHBhcmFtIHs/fSBlbGVtZW50XG4gKiBAcGFyYW0gez99IGNsYXNzTmFtZVxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gY29udGFpbnNDbGFzcyhlbGVtZW50LCBjbGFzc05hbWUpIHtcbiAgICBpZiAoZWxlbWVudC5jbGFzc0xpc3QpIHtcbiAgICAgICAgcmV0dXJuIGVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKGNsYXNzTmFtZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjbGFzc2VzID0gZWxlbWVudFtDTEFTU0VTX0NBQ0hFX0tFWV07XG4gICAgICAgIHJldHVybiBjbGFzc2VzICYmIGNsYXNzZXNbY2xhc3NOYW1lXTtcbiAgICB9XG59XG4vKipcbiAqIEBwYXJhbSB7P30gZWxlbWVudFxuICogQHBhcmFtIHs/fSBjbGFzc05hbWVcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGFkZENsYXNzKGVsZW1lbnQsIGNsYXNzTmFtZSkge1xuICAgIGlmIChlbGVtZW50LmNsYXNzTGlzdCkge1xuICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoY2xhc3NOYW1lKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNsYXNzZXMgPSBlbGVtZW50W0NMQVNTRVNfQ0FDSEVfS0VZXTtcbiAgICAgICAgaWYgKCFjbGFzc2VzKSB7XG4gICAgICAgICAgICBjbGFzc2VzID0gZWxlbWVudFtDTEFTU0VTX0NBQ0hFX0tFWV0gPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBjbGFzc2VzW2NsYXNzTmFtZV0gPSB0cnVlO1xuICAgIH1cbn1cbi8qKlxuICogQHBhcmFtIHs/fSBlbGVtZW50XG4gKiBAcGFyYW0gez99IGNsYXNzTmFtZVxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gcmVtb3ZlQ2xhc3MoZWxlbWVudCwgY2xhc3NOYW1lKSB7XG4gICAgaWYgKGVsZW1lbnQuY2xhc3NMaXN0KSB7XG4gICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShjbGFzc05hbWUpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY2xhc3NlcyA9IGVsZW1lbnRbQ0xBU1NFU19DQUNIRV9LRVldO1xuICAgICAgICBpZiAoY2xhc3Nlcykge1xuICAgICAgICAgICAgZGVsZXRlIGNsYXNzZXNbY2xhc3NOYW1lXTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogQHBhcmFtIHs/fSBlbmdpbmVcbiAqIEBwYXJhbSB7P30gZWxlbWVudFxuICogQHBhcmFtIHs/fSBwbGF5ZXJzXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiByZW1vdmVOb2Rlc0FmdGVyQW5pbWF0aW9uRG9uZShlbmdpbmUsIGVsZW1lbnQsIHBsYXllcnMpIHtcbiAgICBvcHRpbWl6ZUdyb3VwUGxheWVyKHBsYXllcnMpLm9uRG9uZShmdW5jdGlvbiAoKSB7IHJldHVybiBlbmdpbmUucHJvY2Vzc0xlYXZlTm9kZShlbGVtZW50KTsgfSk7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gcGxheWVyc1xuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gZmxhdHRlbkdyb3VwUGxheWVycyhwbGF5ZXJzKSB7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZmluYWxQbGF5ZXJzID0gW107XG4gICAgX2ZsYXR0ZW5Hcm91cFBsYXllcnNSZWN1cihwbGF5ZXJzLCBmaW5hbFBsYXllcnMpO1xuICAgIHJldHVybiBmaW5hbFBsYXllcnM7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gcGxheWVyc1xuICogQHBhcmFtIHs/fSBmaW5hbFBsYXllcnNcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIF9mbGF0dGVuR3JvdXBQbGF5ZXJzUmVjdXIocGxheWVycywgZmluYWxQbGF5ZXJzKSB7XG4gICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBpID0gMDsgaSA8IHBsYXllcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGxheWVyID0gcGxheWVyc1tpXTtcbiAgICAgICAgaWYgKHBsYXllciBpbnN0YW5jZW9mIF9hbmd1bGFyX2FuaW1hdGlvbnMuybVBbmltYXRpb25Hcm91cFBsYXllcikge1xuICAgICAgICAgICAgX2ZsYXR0ZW5Hcm91cFBsYXllcnNSZWN1cihwbGF5ZXIucGxheWVycywgZmluYWxQbGF5ZXJzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZpbmFsUGxheWVycy5wdXNoKC8qKiBAdHlwZSB7P30gKi8gKHBsYXllcikpO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBAcGFyYW0gez99IGFcbiAqIEBwYXJhbSB7P30gYlxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gb2JqRXF1YWxzKGEsIGIpIHtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBrMSA9IE9iamVjdC5rZXlzKGEpO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIGsyID0gT2JqZWN0LmtleXMoYik7XG4gICAgaWYgKGsxLmxlbmd0aCAhPSBrMi5sZW5ndGgpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBmb3IgKHZhciAvKiogQHR5cGUgez99ICovIGkgPSAwOyBpIDwgazEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcHJvcCA9IGsxW2ldO1xuICAgICAgICBpZiAoIWIuaGFzT3duUHJvcGVydHkocHJvcCkgfHwgYVtwcm9wXSAhPT0gYltwcm9wXSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gZWxlbWVudFxuICogQHBhcmFtIHs/fSBhbGxQcmVTdHlsZUVsZW1lbnRzXG4gKiBAcGFyYW0gez99IGFsbFBvc3RTdHlsZUVsZW1lbnRzXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiByZXBsYWNlUG9zdFN0eWxlc0FzUHJlKGVsZW1lbnQsIGFsbFByZVN0eWxlRWxlbWVudHMsIGFsbFBvc3RTdHlsZUVsZW1lbnRzKSB7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcG9zdEVudHJ5ID0gYWxsUG9zdFN0eWxlRWxlbWVudHMuZ2V0KGVsZW1lbnQpO1xuICAgIGlmICghcG9zdEVudHJ5KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcHJlRW50cnkgPSBhbGxQcmVTdHlsZUVsZW1lbnRzLmdldChlbGVtZW50KTtcbiAgICBpZiAocHJlRW50cnkpIHtcbiAgICAgICAgcG9zdEVudHJ5LmZvckVhY2goZnVuY3Rpb24gKGRhdGEpIHsgcmV0dXJuIC8qKiBAdHlwZSB7P30gKi8gKChwcmVFbnRyeSkpLmFkZChkYXRhKTsgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBhbGxQcmVTdHlsZUVsZW1lbnRzLnNldChlbGVtZW50LCBwb3N0RW50cnkpO1xuICAgIH1cbiAgICBhbGxQb3N0U3R5bGVFbGVtZW50cy5kZWxldGUoZWxlbWVudCk7XG4gICAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBhZGRlZCBieSB0c2lja2xlXG4gKiBAc3VwcHJlc3Mge2NoZWNrVHlwZXN9IGNoZWNrZWQgYnkgdHNjXG4gKi9cbnZhciBBbmltYXRpb25FbmdpbmUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEFuaW1hdGlvbkVuZ2luZShfZHJpdmVyLCBub3JtYWxpemVyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX2RyaXZlciA9IF9kcml2ZXI7XG4gICAgICAgIHRoaXMuX3RyaWdnZXJDYWNoZSA9IHt9O1xuICAgICAgICB0aGlzLm9uUmVtb3ZhbENvbXBsZXRlID0gZnVuY3Rpb24gKGVsZW1lbnQsIGNvbnRleHQpIHsgfTtcbiAgICAgICAgdGhpcy5fdHJhbnNpdGlvbkVuZ2luZSA9IG5ldyBUcmFuc2l0aW9uQW5pbWF0aW9uRW5naW5lKF9kcml2ZXIsIG5vcm1hbGl6ZXIpO1xuICAgICAgICB0aGlzLl90aW1lbGluZUVuZ2luZSA9IG5ldyBUaW1lbGluZUFuaW1hdGlvbkVuZ2luZShfZHJpdmVyLCBub3JtYWxpemVyKTtcbiAgICAgICAgdGhpcy5fdHJhbnNpdGlvbkVuZ2luZS5vblJlbW92YWxDb21wbGV0ZSA9IGZ1bmN0aW9uIChlbGVtZW50LCBjb250ZXh0KSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMub25SZW1vdmFsQ29tcGxldGUoZWxlbWVudCwgY29udGV4dCk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gY29tcG9uZW50SWRcbiAgICAgKiBAcGFyYW0gez99IG5hbWVzcGFjZUlkXG4gICAgICogQHBhcmFtIHs/fSBob3N0RWxlbWVudFxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEBwYXJhbSB7P30gbWV0YWRhdGFcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFuaW1hdGlvbkVuZ2luZS5wcm90b3R5cGUucmVnaXN0ZXJUcmlnZ2VyID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBjb21wb25lbnRJZFxuICAgICAqIEBwYXJhbSB7P30gbmFtZXNwYWNlSWRcbiAgICAgKiBAcGFyYW0gez99IGhvc3RFbGVtZW50XG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHBhcmFtIHs/fSBtZXRhZGF0YVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKGNvbXBvbmVudElkLCBuYW1lc3BhY2VJZCwgaG9zdEVsZW1lbnQsIG5hbWUsIG1ldGFkYXRhKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNhY2hlS2V5ID0gY29tcG9uZW50SWQgKyAnLScgKyBuYW1lO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0cmlnZ2VyID0gdGhpcy5fdHJpZ2dlckNhY2hlW2NhY2hlS2V5XTtcbiAgICAgICAgaWYgKCF0cmlnZ2VyKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlcnJvcnMgPSBbXTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGFzdCA9IC8qKiBAdHlwZSB7P30gKi8gKGJ1aWxkQW5pbWF0aW9uQXN0KHRoaXMuX2RyaXZlciwgLyoqIEB0eXBlIHs/fSAqLyAobWV0YWRhdGEpLCBlcnJvcnMpKTtcbiAgICAgICAgICAgIGlmIChlcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGFuaW1hdGlvbiB0cmlnZ2VyIFxcXCJcIiArIG5hbWUgKyBcIlxcXCIgaGFzIGZhaWxlZCB0byBidWlsZCBkdWUgdG8gdGhlIGZvbGxvd2luZyBlcnJvcnM6XFxuIC0gXCIgKyBlcnJvcnMuam9pbihcIlxcbiAtIFwiKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cmlnZ2VyID0gYnVpbGRUcmlnZ2VyKG5hbWUsIGFzdCk7XG4gICAgICAgICAgICB0aGlzLl90cmlnZ2VyQ2FjaGVbY2FjaGVLZXldID0gdHJpZ2dlcjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl90cmFuc2l0aW9uRW5naW5lLnJlZ2lzdGVyVHJpZ2dlcihuYW1lc3BhY2VJZCwgbmFtZSwgdHJpZ2dlcik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5hbWVzcGFjZUlkXG4gICAgICogQHBhcmFtIHs/fSBob3N0RWxlbWVudFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQW5pbWF0aW9uRW5naW5lLnByb3RvdHlwZS5yZWdpc3RlciA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gbmFtZXNwYWNlSWRcbiAgICAgKiBAcGFyYW0gez99IGhvc3RFbGVtZW50XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAobmFtZXNwYWNlSWQsIGhvc3RFbGVtZW50KSB7XG4gICAgICAgIHRoaXMuX3RyYW5zaXRpb25FbmdpbmUucmVnaXN0ZXIobmFtZXNwYWNlSWQsIGhvc3RFbGVtZW50KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbmFtZXNwYWNlSWRcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFuaW1hdGlvbkVuZ2luZS5wcm90b3R5cGUuZGVzdHJveSA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gbmFtZXNwYWNlSWRcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChuYW1lc3BhY2VJZCwgY29udGV4dCkge1xuICAgICAgICB0aGlzLl90cmFuc2l0aW9uRW5naW5lLmRlc3Ryb3kobmFtZXNwYWNlSWQsIGNvbnRleHQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBuYW1lc3BhY2VJZFxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFxuICAgICAqIEBwYXJhbSB7P30gcGFyZW50XG4gICAgICogQHBhcmFtIHs/fSBpbnNlcnRCZWZvcmVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFuaW1hdGlvbkVuZ2luZS5wcm90b3R5cGUub25JbnNlcnQgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IG5hbWVzcGFjZUlkXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XG4gICAgICogQHBhcmFtIHs/fSBwYXJlbnRcbiAgICAgKiBAcGFyYW0gez99IGluc2VydEJlZm9yZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKG5hbWVzcGFjZUlkLCBlbGVtZW50LCBwYXJlbnQsIGluc2VydEJlZm9yZSkge1xuICAgICAgICB0aGlzLl90cmFuc2l0aW9uRW5naW5lLmluc2VydE5vZGUobmFtZXNwYWNlSWQsIGVsZW1lbnQsIHBhcmVudCwgaW5zZXJ0QmVmb3JlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbmFtZXNwYWNlSWRcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFuaW1hdGlvbkVuZ2luZS5wcm90b3R5cGUub25SZW1vdmUgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IG5hbWVzcGFjZUlkXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAobmFtZXNwYWNlSWQsIGVsZW1lbnQsIGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy5fdHJhbnNpdGlvbkVuZ2luZS5yZW1vdmVOb2RlKG5hbWVzcGFjZUlkLCBlbGVtZW50LCBjb250ZXh0KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFxuICAgICAqIEBwYXJhbSB7P30gZGlzYWJsZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQW5pbWF0aW9uRW5naW5lLnByb3RvdHlwZS5kaXNhYmxlQW5pbWF0aW9ucyA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFxuICAgICAqIEBwYXJhbSB7P30gZGlzYWJsZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKGVsZW1lbnQsIGRpc2FibGUpIHtcbiAgICAgICAgdGhpcy5fdHJhbnNpdGlvbkVuZ2luZS5tYXJrRWxlbWVudEFzRGlzYWJsZWQoZWxlbWVudCwgZGlzYWJsZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5hbWVzcGFjZUlkXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XG4gICAgICogQHBhcmFtIHs/fSBwcm9wZXJ0eVxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFuaW1hdGlvbkVuZ2luZS5wcm90b3R5cGUucHJvY2VzcyA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gbmFtZXNwYWNlSWRcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0gez99IHByb3BlcnR5XG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKG5hbWVzcGFjZUlkLCBlbGVtZW50LCBwcm9wZXJ0eSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKHByb3BlcnR5LmNoYXJBdCgwKSA9PSAnQCcpIHtcbiAgICAgICAgICAgIHZhciBfYSA9IHBhcnNlVGltZWxpbmVDb21tYW5kKHByb3BlcnR5KSwgaWQgPSBfYVswXSwgYWN0aW9uID0gX2FbMV07XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBhcmdzID0gLyoqIEB0eXBlIHs/fSAqLyAodmFsdWUpO1xuICAgICAgICAgICAgdGhpcy5fdGltZWxpbmVFbmdpbmUuY29tbWFuZChpZCwgZWxlbWVudCwgYWN0aW9uLCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3RyYW5zaXRpb25FbmdpbmUudHJpZ2dlcihuYW1lc3BhY2VJZCwgZWxlbWVudCwgcHJvcGVydHksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBuYW1lc3BhY2VJZFxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFxuICAgICAqIEBwYXJhbSB7P30gZXZlbnROYW1lXG4gICAgICogQHBhcmFtIHs/fSBldmVudFBoYXNlXG4gICAgICogQHBhcmFtIHs/fSBjYWxsYmFja1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQW5pbWF0aW9uRW5naW5lLnByb3RvdHlwZS5saXN0ZW4gPSAvKipcbiAgICAgKiBAcGFyYW0gez99IG5hbWVzcGFjZUlkXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XG4gICAgICogQHBhcmFtIHs/fSBldmVudE5hbWVcbiAgICAgKiBAcGFyYW0gez99IGV2ZW50UGhhc2VcbiAgICAgKiBAcGFyYW0gez99IGNhbGxiYWNrXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAobmFtZXNwYWNlSWQsIGVsZW1lbnQsIGV2ZW50TmFtZSwgZXZlbnRQaGFzZSwgY2FsbGJhY2spIHtcbiAgICAgICAgLy8gQEBsaXN0ZW5cbiAgICAgICAgaWYgKGV2ZW50TmFtZS5jaGFyQXQoMCkgPT0gJ0AnKSB7XG4gICAgICAgICAgICB2YXIgX2EgPSBwYXJzZVRpbWVsaW5lQ29tbWFuZChldmVudE5hbWUpLCBpZCA9IF9hWzBdLCBhY3Rpb24gPSBfYVsxXTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl90aW1lbGluZUVuZ2luZS5saXN0ZW4oaWQsIGVsZW1lbnQsIGFjdGlvbiwgY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl90cmFuc2l0aW9uRW5naW5lLmxpc3RlbihuYW1lc3BhY2VJZCwgZWxlbWVudCwgZXZlbnROYW1lLCBldmVudFBoYXNlLCBjYWxsYmFjayk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez89fSBtaWNyb3Rhc2tJZFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQW5pbWF0aW9uRW5naW5lLnByb3RvdHlwZS5mbHVzaCA9IC8qKlxuICAgICAqIEBwYXJhbSB7Pz19IG1pY3JvdGFza0lkXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAobWljcm90YXNrSWQpIHtcbiAgICAgICAgaWYgKG1pY3JvdGFza0lkID09PSB2b2lkIDApIHsgbWljcm90YXNrSWQgPSAtMTsgfVxuICAgICAgICB0aGlzLl90cmFuc2l0aW9uRW5naW5lLmZsdXNoKG1pY3JvdGFza0lkKTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBbmltYXRpb25FbmdpbmUucHJvdG90eXBlLCBcInBsYXllcnNcIiwge1xuICAgICAgICBnZXQ6IC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICgvKiogQHR5cGUgez99ICovICh0aGlzLl90cmFuc2l0aW9uRW5naW5lLnBsYXllcnMpKVxuICAgICAgICAgICAgICAgIC5jb25jYXQoLyoqIEB0eXBlIHs/fSAqLyAodGhpcy5fdGltZWxpbmVFbmdpbmUucGxheWVycykpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFuaW1hdGlvbkVuZ2luZS5wcm90b3R5cGUud2hlblJlbmRlcmluZ0RvbmUgPSAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3RyYW5zaXRpb25FbmdpbmUud2hlblJlbmRlcmluZ0RvbmUoKTsgfTtcbiAgICByZXR1cm4gQW5pbWF0aW9uRW5naW5lO1xufSgpKTtcblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IGFkZGVkIGJ5IHRzaWNrbGVcbiAqIEBzdXBwcmVzcyB7Y2hlY2tUeXBlc30gY2hlY2tlZCBieSB0c2NcbiAqL1xudmFyIFdlYkFuaW1hdGlvbnNQbGF5ZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFdlYkFuaW1hdGlvbnNQbGF5ZXIoZWxlbWVudCwga2V5ZnJhbWVzLCBvcHRpb25zLCBwcmV2aW91c1BsYXllcnMpIHtcbiAgICAgICAgaWYgKHByZXZpb3VzUGxheWVycyA9PT0gdm9pZCAwKSB7IHByZXZpb3VzUGxheWVycyA9IFtdOyB9XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICAgIHRoaXMua2V5ZnJhbWVzID0ga2V5ZnJhbWVzO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLnByZXZpb3VzUGxheWVycyA9IHByZXZpb3VzUGxheWVycztcbiAgICAgICAgdGhpcy5fb25Eb25lRm5zID0gW107XG4gICAgICAgIHRoaXMuX29uU3RhcnRGbnMgPSBbXTtcbiAgICAgICAgdGhpcy5fb25EZXN0cm95Rm5zID0gW107XG4gICAgICAgIHRoaXMuX2luaXRpYWxpemVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2ZpbmlzaGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fZGVzdHJveWVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMudGltZSA9IDA7XG4gICAgICAgIHRoaXMucGFyZW50UGxheWVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5wcmV2aW91c1N0eWxlcyA9IHt9O1xuICAgICAgICB0aGlzLmN1cnJlbnRTbmFwc2hvdCA9IHt9O1xuICAgICAgICB0aGlzLl9kdXJhdGlvbiA9IC8qKiBAdHlwZSB7P30gKi8gKG9wdGlvbnNbJ2R1cmF0aW9uJ10pO1xuICAgICAgICB0aGlzLl9kZWxheSA9IC8qKiBAdHlwZSB7P30gKi8gKG9wdGlvbnNbJ2RlbGF5J10pIHx8IDA7XG4gICAgICAgIHRoaXMudGltZSA9IHRoaXMuX2R1cmF0aW9uICsgdGhpcy5fZGVsYXk7XG4gICAgICAgIGlmIChhbGxvd1ByZXZpb3VzUGxheWVyU3R5bGVzTWVyZ2UodGhpcy5fZHVyYXRpb24sIHRoaXMuX2RlbGF5KSkge1xuICAgICAgICAgICAgcHJldmlvdXNQbGF5ZXJzLmZvckVhY2goZnVuY3Rpb24gKHBsYXllcikge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0eWxlcyA9IHBsYXllci5jdXJyZW50U25hcHNob3Q7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmtleXMoc3R5bGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7IHJldHVybiBfdGhpcy5wcmV2aW91c1N0eWxlc1twcm9wXSA9IHN0eWxlc1twcm9wXTsgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFdlYkFuaW1hdGlvbnNQbGF5ZXIucHJvdG90eXBlLl9vbkZpbmlzaCA9IC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuX2ZpbmlzaGVkKSB7XG4gICAgICAgICAgICB0aGlzLl9maW5pc2hlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9vbkRvbmVGbnMuZm9yRWFjaChmdW5jdGlvbiAoZm4pIHsgcmV0dXJuIGZuKCk7IH0pO1xuICAgICAgICAgICAgdGhpcy5fb25Eb25lRm5zID0gW107XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgV2ViQW5pbWF0aW9uc1BsYXllci5wcm90b3R5cGUuaW5pdCA9IC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9idWlsZFBsYXllcigpO1xuICAgICAgICB0aGlzLl9wcmVwYXJlUGxheWVyQmVmb3JlU3RhcnQoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgV2ViQW5pbWF0aW9uc1BsYXllci5wcm90b3R5cGUuX2J1aWxkUGxheWVyID0gLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLl9pbml0aWFsaXplZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5faW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBrZXlmcmFtZXMgPSB0aGlzLmtleWZyYW1lcy5tYXAoZnVuY3Rpb24gKHN0eWxlcykgeyByZXR1cm4gY29weVN0eWxlcyhzdHlsZXMsIGZhbHNlKTsgfSk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHByZXZpb3VzU3R5bGVQcm9wcyA9IE9iamVjdC5rZXlzKHRoaXMucHJldmlvdXNTdHlsZXMpO1xuICAgICAgICBpZiAocHJldmlvdXNTdHlsZVByb3BzLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3RhcnRpbmdLZXlmcmFtZV8xID0ga2V5ZnJhbWVzWzBdO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbWlzc2luZ1N0eWxlUHJvcHNfMSA9IFtdO1xuICAgICAgICAgICAgcHJldmlvdXNTdHlsZVByb3BzLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgICAgICAgICBpZiAoIXN0YXJ0aW5nS2V5ZnJhbWVfMS5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICAgICAgICAgICAgICAgICAgICBtaXNzaW5nU3R5bGVQcm9wc18xLnB1c2gocHJvcCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN0YXJ0aW5nS2V5ZnJhbWVfMVtwcm9wXSA9IF90aGlzLnByZXZpb3VzU3R5bGVzW3Byb3BdO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAobWlzc2luZ1N0eWxlUHJvcHNfMS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzZWxmXzEgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHZhciBfbG9vcF8xID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBrZiA9IGtleWZyYW1lc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgbWlzc2luZ1N0eWxlUHJvcHNfMS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZltwcm9wXSA9IF9jb21wdXRlU3R5bGUoc2VsZl8xLmVsZW1lbnQsIHByb3ApO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZVxuICAgICAgICAgICAgICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gaSA9IDE7IGkgPCBrZXlmcmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgX2xvb3BfMSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wbGF5ZXIgPSB0aGlzLl90cmlnZ2VyV2ViQW5pbWF0aW9uKHRoaXMuZWxlbWVudCwga2V5ZnJhbWVzLCB0aGlzLm9wdGlvbnMpO1xuICAgICAgICB0aGlzLl9maW5hbEtleWZyYW1lID0ga2V5ZnJhbWVzLmxlbmd0aCA/IGtleWZyYW1lc1trZXlmcmFtZXMubGVuZ3RoIC0gMV0gOiB7fTtcbiAgICAgICAgdGhpcy5fcGxheWVyLmFkZEV2ZW50TGlzdGVuZXIoJ2ZpbmlzaCcsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLl9vbkZpbmlzaCgpOyB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgV2ViQW5pbWF0aW9uc1BsYXllci5wcm90b3R5cGUuX3ByZXBhcmVQbGF5ZXJCZWZvcmVTdGFydCA9IC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyB0aGlzIGlzIHJlcXVpcmVkIHNvIHRoYXQgdGhlIHBsYXllciBkb2Vzbid0IHN0YXJ0IHRvIGFuaW1hdGUgcmlnaHQgYXdheVxuICAgICAgICBpZiAodGhpcy5fZGVsYXkpIHtcbiAgICAgICAgICAgIHRoaXMuX3Jlc2V0RG9tUGxheWVyU3RhdGUoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3BsYXllci5wYXVzZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgLyoqXG4gICAgICogXFxAaW50ZXJuYWxcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0gez99IGtleWZyYW1lc1xuICAgICAqIEBwYXJhbSB7P30gb3B0aW9uc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgV2ViQW5pbWF0aW9uc1BsYXllci5wcm90b3R5cGUuX3RyaWdnZXJXZWJBbmltYXRpb24gPSAvKipcbiAgICAgKiBcXEBpbnRlcm5hbFxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFxuICAgICAqIEBwYXJhbSB7P30ga2V5ZnJhbWVzXG4gICAgICogQHBhcmFtIHs/fSBvcHRpb25zXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoZWxlbWVudCwga2V5ZnJhbWVzLCBvcHRpb25zKSB7XG4gICAgICAgIC8vIGpzY29tcGlsZXIgZG9lc24ndCBzZWVtIHRvIGtub3cgYW5pbWF0ZSBpcyBhIG5hdGl2ZSBwcm9wZXJ0eSBiZWNhdXNlIGl0J3Mgbm90IGZ1bGx5XG4gICAgICAgIC8vIHN1cHBvcnRlZCB5ZXQgYWNyb3NzIGNvbW1vbiBicm93c2VycyAod2UgcG9seWZpbGwgaXQgZm9yIEVkZ2UvU2FmYXJpKSBbQ0wgIzE0MzYzMDkyOV1cbiAgICAgICAgcmV0dXJuIC8qKiBAdHlwZSB7P30gKi8gKGVsZW1lbnRbJ2FuaW1hdGUnXShrZXlmcmFtZXMsIG9wdGlvbnMpKTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXZWJBbmltYXRpb25zUGxheWVyLnByb3RvdHlwZSwgXCJkb21QbGF5ZXJcIiwge1xuICAgICAgICBnZXQ6IC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fcGxheWVyOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGZuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBXZWJBbmltYXRpb25zUGxheWVyLnByb3RvdHlwZS5vblN0YXJ0ID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBmblxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKGZuKSB7IHRoaXMuX29uU3RhcnRGbnMucHVzaChmbik7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBmblxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgV2ViQW5pbWF0aW9uc1BsYXllci5wcm90b3R5cGUub25Eb25lID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBmblxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKGZuKSB7IHRoaXMuX29uRG9uZUZucy5wdXNoKGZuKTsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGZuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBXZWJBbmltYXRpb25zUGxheWVyLnByb3RvdHlwZS5vbkRlc3Ryb3kgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IGZuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoZm4pIHsgdGhpcy5fb25EZXN0cm95Rm5zLnB1c2goZm4pOyB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgV2ViQW5pbWF0aW9uc1BsYXllci5wcm90b3R5cGUucGxheSA9IC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9idWlsZFBsYXllcigpO1xuICAgICAgICBpZiAoIXRoaXMuaGFzU3RhcnRlZCgpKSB7XG4gICAgICAgICAgICB0aGlzLl9vblN0YXJ0Rm5zLmZvckVhY2goZnVuY3Rpb24gKGZuKSB7IHJldHVybiBmbigpOyB9KTtcbiAgICAgICAgICAgIHRoaXMuX29uU3RhcnRGbnMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3BsYXllci5wbGF5KCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFdlYkFuaW1hdGlvbnNQbGF5ZXIucHJvdG90eXBlLnBhdXNlID0gLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaW5pdCgpO1xuICAgICAgICB0aGlzLl9wbGF5ZXIucGF1c2UoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgV2ViQW5pbWF0aW9uc1BsYXllci5wcm90b3R5cGUuZmluaXNoID0gLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaW5pdCgpO1xuICAgICAgICB0aGlzLl9vbkZpbmlzaCgpO1xuICAgICAgICB0aGlzLl9wbGF5ZXIuZmluaXNoKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFdlYkFuaW1hdGlvbnNQbGF5ZXIucHJvdG90eXBlLnJlc2V0ID0gLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3Jlc2V0RG9tUGxheWVyU3RhdGUoKTtcbiAgICAgICAgdGhpcy5fZGVzdHJveWVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2ZpbmlzaGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSBmYWxzZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgV2ViQW5pbWF0aW9uc1BsYXllci5wcm90b3R5cGUuX3Jlc2V0RG9tUGxheWVyU3RhdGUgPSAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3BsYXllcikge1xuICAgICAgICAgICAgdGhpcy5fcGxheWVyLmNhbmNlbCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFdlYkFuaW1hdGlvbnNQbGF5ZXIucHJvdG90eXBlLnJlc3RhcnQgPSAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgICB0aGlzLnBsYXkoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgV2ViQW5pbWF0aW9uc1BsYXllci5wcm90b3R5cGUuaGFzU3RhcnRlZCA9IC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fc3RhcnRlZDsgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFdlYkFuaW1hdGlvbnNQbGF5ZXIucHJvdG90eXBlLmRlc3Ryb3kgPSAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9kZXN0cm95ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2Rlc3Ryb3llZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9yZXNldERvbVBsYXllclN0YXRlKCk7XG4gICAgICAgICAgICB0aGlzLl9vbkZpbmlzaCgpO1xuICAgICAgICAgICAgdGhpcy5fb25EZXN0cm95Rm5zLmZvckVhY2goZnVuY3Rpb24gKGZuKSB7IHJldHVybiBmbigpOyB9KTtcbiAgICAgICAgICAgIHRoaXMuX29uRGVzdHJveUZucyA9IFtdO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHBcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFdlYkFuaW1hdGlvbnNQbGF5ZXIucHJvdG90eXBlLnNldFBvc2l0aW9uID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBwXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAocCkgeyB0aGlzLl9wbGF5ZXIuY3VycmVudFRpbWUgPSBwICogdGhpcy50aW1lOyB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgV2ViQW5pbWF0aW9uc1BsYXllci5wcm90b3R5cGUuZ2V0UG9zaXRpb24gPSAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3BsYXllci5jdXJyZW50VGltZSAvIHRoaXMudGltZTsgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV2ViQW5pbWF0aW9uc1BsYXllci5wcm90b3R5cGUsIFwidG90YWxUaW1lXCIsIHtcbiAgICAgICAgZ2V0OiAvKipcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2RlbGF5ICsgdGhpcy5fZHVyYXRpb247IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgV2ViQW5pbWF0aW9uc1BsYXllci5wcm90b3R5cGUuYmVmb3JlRGVzdHJveSA9IC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdHlsZXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuaGFzU3RhcnRlZCgpKSB7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyh0aGlzLl9maW5hbEtleWZyYW1lKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByb3AgIT0gJ29mZnNldCcpIHtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVzW3Byb3BdID1cbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9maW5pc2hlZCA/IF90aGlzLl9maW5hbEtleWZyYW1lW3Byb3BdIDogX2NvbXB1dGVTdHlsZShfdGhpcy5lbGVtZW50LCBwcm9wKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmN1cnJlbnRTbmFwc2hvdCA9IHN0eWxlcztcbiAgICB9O1xuICAgIHJldHVybiBXZWJBbmltYXRpb25zUGxheWVyO1xufSgpKTtcbi8qKlxuICogQHBhcmFtIHs/fSBlbGVtZW50XG4gKiBAcGFyYW0gez99IHByb3BcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIF9jb21wdXRlU3R5bGUoZWxlbWVudCwgcHJvcCkge1xuICAgIHJldHVybiAoLyoqIEB0eXBlIHs/fSAqLyAod2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkpKVtwcm9wXTtcbn1cblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IGFkZGVkIGJ5IHRzaWNrbGVcbiAqIEBzdXBwcmVzcyB7Y2hlY2tUeXBlc30gY2hlY2tlZCBieSB0c2NcbiAqL1xudmFyIFdlYkFuaW1hdGlvbnNEcml2ZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFdlYkFuaW1hdGlvbnNEcml2ZXIoKSB7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcHJvcFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgV2ViQW5pbWF0aW9uc0RyaXZlci5wcm90b3R5cGUudmFsaWRhdGVTdHlsZVByb3BlcnR5ID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBwcm9wXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAocHJvcCkgeyByZXR1cm4gdmFsaWRhdGVTdHlsZVByb3BlcnR5KHByb3ApOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFxuICAgICAqIEBwYXJhbSB7P30gc2VsZWN0b3JcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFdlYkFuaW1hdGlvbnNEcml2ZXIucHJvdG90eXBlLm1hdGNoZXNFbGVtZW50ID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XG4gICAgICogQHBhcmFtIHs/fSBzZWxlY3RvclxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKGVsZW1lbnQsIHNlbGVjdG9yKSB7XG4gICAgICAgIHJldHVybiBtYXRjaGVzRWxlbWVudChlbGVtZW50LCBzZWxlY3Rvcik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsbTFcbiAgICAgKiBAcGFyYW0gez99IGVsbTJcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFdlYkFuaW1hdGlvbnNEcml2ZXIucHJvdG90eXBlLmNvbnRhaW5zRWxlbWVudCA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gZWxtMVxuICAgICAqIEBwYXJhbSB7P30gZWxtMlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKGVsbTEsIGVsbTIpIHsgcmV0dXJuIGNvbnRhaW5zRWxlbWVudChlbG0xLCBlbG0yKTsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0gez99IHNlbGVjdG9yXG4gICAgICogQHBhcmFtIHs/fSBtdWx0aVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgV2ViQW5pbWF0aW9uc0RyaXZlci5wcm90b3R5cGUucXVlcnkgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0gez99IHNlbGVjdG9yXG4gICAgICogQHBhcmFtIHs/fSBtdWx0aVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKGVsZW1lbnQsIHNlbGVjdG9yLCBtdWx0aSkge1xuICAgICAgICByZXR1cm4gaW52b2tlUXVlcnkoZWxlbWVudCwgc2VsZWN0b3IsIG11bHRpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFxuICAgICAqIEBwYXJhbSB7P30gcHJvcFxuICAgICAqIEBwYXJhbSB7Pz19IGRlZmF1bHRWYWx1ZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgV2ViQW5pbWF0aW9uc0RyaXZlci5wcm90b3R5cGUuY29tcHV0ZVN0eWxlID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XG4gICAgICogQHBhcmFtIHs/fSBwcm9wXG4gICAgICogQHBhcmFtIHs/PX0gZGVmYXVsdFZhbHVlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoZWxlbWVudCwgcHJvcCwgZGVmYXVsdFZhbHVlKSB7XG4gICAgICAgIHJldHVybiAvKiogQHR5cGUgez99ICovICgoLyoqIEB0eXBlIHs/fSAqLyAod2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkpKVtwcm9wXSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0gez99IGtleWZyYW1lc1xuICAgICAqIEBwYXJhbSB7P30gZHVyYXRpb25cbiAgICAgKiBAcGFyYW0gez99IGRlbGF5XG4gICAgICogQHBhcmFtIHs/fSBlYXNpbmdcbiAgICAgKiBAcGFyYW0gez89fSBwcmV2aW91c1BsYXllcnNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFdlYkFuaW1hdGlvbnNEcml2ZXIucHJvdG90eXBlLmFuaW1hdGUgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0gez99IGtleWZyYW1lc1xuICAgICAqIEBwYXJhbSB7P30gZHVyYXRpb25cbiAgICAgKiBAcGFyYW0gez99IGRlbGF5XG4gICAgICogQHBhcmFtIHs/fSBlYXNpbmdcbiAgICAgKiBAcGFyYW0gez89fSBwcmV2aW91c1BsYXllcnNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChlbGVtZW50LCBrZXlmcmFtZXMsIGR1cmF0aW9uLCBkZWxheSwgZWFzaW5nLCBwcmV2aW91c1BsYXllcnMpIHtcbiAgICAgICAgaWYgKHByZXZpb3VzUGxheWVycyA9PT0gdm9pZCAwKSB7IHByZXZpb3VzUGxheWVycyA9IFtdOyB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGZpbGwgPSBkZWxheSA9PSAwID8gJ2JvdGgnIDogJ2ZvcndhcmRzJztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGxheWVyT3B0aW9ucyA9IHsgZHVyYXRpb246IGR1cmF0aW9uLCBkZWxheTogZGVsYXksIGZpbGw6IGZpbGwgfTtcbiAgICAgICAgLy8gd2UgY2hlY2sgZm9yIHRoaXMgdG8gYXZvaWQgaGF2aW5nIGEgbnVsbHx1bmRlZmluZWQgdmFsdWUgYmUgcHJlc2VudFxuICAgICAgICAvLyBmb3IgdGhlIGVhc2luZyAod2hpY2ggcmVzdWx0cyBpbiBhbiBlcnJvciBmb3IgY2VydGFpbiBicm93c2VycyAjOTc1MilcbiAgICAgICAgaWYgKGVhc2luZykge1xuICAgICAgICAgICAgcGxheWVyT3B0aW9uc1snZWFzaW5nJ10gPSBlYXNpbmc7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcHJldmlvdXNXZWJBbmltYXRpb25QbGF5ZXJzID0gLyoqIEB0eXBlIHs/fSAqLyAocHJldmlvdXNQbGF5ZXJzLmZpbHRlcihmdW5jdGlvbiAocGxheWVyKSB7IHJldHVybiBwbGF5ZXIgaW5zdGFuY2VvZiBXZWJBbmltYXRpb25zUGxheWVyOyB9KSk7XG4gICAgICAgIHJldHVybiBuZXcgV2ViQW5pbWF0aW9uc1BsYXllcihlbGVtZW50LCBrZXlmcmFtZXMsIHBsYXllck9wdGlvbnMsIHByZXZpb3VzV2ViQW5pbWF0aW9uUGxheWVycyk7XG4gICAgfTtcbiAgICByZXR1cm4gV2ViQW5pbWF0aW9uc0RyaXZlcjtcbn0oKSk7XG4vKipcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIHN1cHBvcnRzV2ViQW5pbWF0aW9ucygpIHtcbiAgICByZXR1cm4gdHlwZW9mIEVsZW1lbnQgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiAoLyoqIEB0eXBlIHs/fSAqLyAoRWxlbWVudCkpLnByb3RvdHlwZVsnYW5pbWF0ZSddID09PSAnZnVuY3Rpb24nO1xufVxuXG5leHBvcnRzLkFuaW1hdGlvbkRyaXZlciA9IEFuaW1hdGlvbkRyaXZlcjtcbmV4cG9ydHMuybVBbmltYXRpb24gPSBBbmltYXRpb247XG5leHBvcnRzLsm1QW5pbWF0aW9uU3R5bGVOb3JtYWxpemVyID0gQW5pbWF0aW9uU3R5bGVOb3JtYWxpemVyO1xuZXhwb3J0cy7JtU5vb3BBbmltYXRpb25TdHlsZU5vcm1hbGl6ZXIgPSBOb29wQW5pbWF0aW9uU3R5bGVOb3JtYWxpemVyO1xuZXhwb3J0cy7JtVdlYkFuaW1hdGlvbnNTdHlsZU5vcm1hbGl6ZXIgPSBXZWJBbmltYXRpb25zU3R5bGVOb3JtYWxpemVyO1xuZXhwb3J0cy7JtU5vb3BBbmltYXRpb25Ecml2ZXIgPSBOb29wQW5pbWF0aW9uRHJpdmVyO1xuZXhwb3J0cy7JtUFuaW1hdGlvbkVuZ2luZSA9IEFuaW1hdGlvbkVuZ2luZTtcbmV4cG9ydHMuybVXZWJBbmltYXRpb25zRHJpdmVyID0gV2ViQW5pbWF0aW9uc0RyaXZlcjtcbmV4cG9ydHMuybVzdXBwb3J0c1dlYkFuaW1hdGlvbnMgPSBzdXBwb3J0c1dlYkFuaW1hdGlvbnM7XG5leHBvcnRzLsm1V2ViQW5pbWF0aW9uc1BsYXllciA9IFdlYkFuaW1hdGlvbnNQbGF5ZXI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbn0pKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hbmltYXRpb25zLWJyb3dzZXIudW1kLmpzLm1hcFxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvYW5pbWF0aW9ucy9idW5kbGVzL2FuaW1hdGlvbnMtYnJvd3Nlci51bWQuanNcbi8vIG1vZHVsZSBpZCA9IDM1XG4vLyBtb2R1bGUgY2h1bmtzID0gNCIsIm1vZHVsZS5leHBvcnRzID0gKF9fd2VicGFja19yZXF1aXJlX18oMikpKDQyKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBkZWxlZ2F0ZWQgLi9ub2RlX21vZHVsZXMvcnhqcy9vcGVyYXRvci9maWx0ZXIuanMgZnJvbSBkbGwtcmVmZXJlbmNlIC4vdmVuZG9yXG4vLyBtb2R1bGUgaWQgPSAzNlxuLy8gbW9kdWxlIGNodW5rcyA9IDQiLCJtb2R1bGUuZXhwb3J0cyA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKDIpKSg5Nyk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZGVsZWdhdGVkIC4vbm9kZV9tb2R1bGVzL0Bhbmd1bGFyL2h0dHAvYnVuZGxlcy9odHRwLnVtZC5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgLi92ZW5kb3Jcbi8vIG1vZHVsZSBpZCA9IDM3XG4vLyBtb2R1bGUgY2h1bmtzID0gNCIsIi8qKlxuICogQGxpY2Vuc2UgQW5ndWxhciB2NS4wLjAtYmV0YS43XG4gKiAoYykgMjAxMC0yMDE3IEdvb2dsZSwgSW5jLiBodHRwczovL2FuZ3VsYXIuaW8vXG4gKiBMaWNlbnNlOiBNSVRcbiAqL1xuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcblx0dHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzLCByZXF1aXJlKCdAYW5ndWxhci9jb3JlJyksIHJlcXVpcmUoJ0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXInKSwgcmVxdWlyZSgnQGFuZ3VsYXIvYW5pbWF0aW9ucycpLCByZXF1aXJlKCdAYW5ndWxhci9hbmltYXRpb25zL2Jyb3dzZXInKSkgOlxuXHR0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJywgJ0Bhbmd1bGFyL2NvcmUnLCAnQGFuZ3VsYXIvcGxhdGZvcm0tYnJvd3NlcicsICdAYW5ndWxhci9hbmltYXRpb25zJywgJ0Bhbmd1bGFyL2FuaW1hdGlvbnMvYnJvd3NlciddLCBmYWN0b3J5KSA6XG5cdChmYWN0b3J5KChnbG9iYWwubmcgPSBnbG9iYWwubmcgfHwge30sIGdsb2JhbC5uZy5wbGF0Zm9ybUJyb3dzZXIgPSBnbG9iYWwubmcucGxhdGZvcm1Ccm93c2VyIHx8IHt9LCBnbG9iYWwubmcucGxhdGZvcm1Ccm93c2VyLmFuaW1hdGlvbnMgPSB7fSksZ2xvYmFsLm5nLmNvcmUsZ2xvYmFsLm5nLnBsYXRmb3JtQnJvd3NlcixnbG9iYWwubmcuYW5pbWF0aW9ucyxnbG9iYWwubmcuYW5pbWF0aW9ucy5icm93c2VyKSk7XG59KHRoaXMsIChmdW5jdGlvbiAoZXhwb3J0cyxfYW5ndWxhcl9jb3JlLF9hbmd1bGFyX3BsYXRmb3JtQnJvd3NlcixfYW5ndWxhcl9hbmltYXRpb25zLF9hbmd1bGFyX2FuaW1hdGlvbnNfYnJvd3NlcikgeyAndXNlIHN0cmljdCc7XG5cbi8qISAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlXHJcbnRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlXHJcbkxpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcblxyXG5USElTIENPREUgSVMgUFJPVklERUQgT04gQU4gKkFTIElTKiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbktJTkQsIEVJVEhFUiBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBXSVRIT1VUIExJTUlUQVRJT04gQU5ZIElNUExJRURcclxuV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIFRJVExFLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSxcclxuTUVSQ0hBTlRBQkxJVFkgT1IgTk9OLUlORlJJTkdFTUVOVC5cclxuXHJcblNlZSB0aGUgQXBhY2hlIFZlcnNpb24gMi4wIExpY2Vuc2UgZm9yIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9uc1xyXG5hbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcbi8qIGdsb2JhbCBSZWZsZWN0LCBQcm9taXNlICovXHJcblxyXG52YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XHJcblxyXG5mdW5jdGlvbiBfX2V4dGVuZHMoZCwgYikge1xyXG4gICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG59XG5cbi8qKlxuICogQGxpY2Vuc2UgQW5ndWxhciB2NS4wLjAtYmV0YS43XG4gKiAoYykgMjAxMC0yMDE3IEdvb2dsZSwgSW5jLiBodHRwczovL2FuZ3VsYXIuaW8vXG4gKiBMaWNlbnNlOiBNSVRcbiAqL1xuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IGFkZGVkIGJ5IHRzaWNrbGVcbiAqIEBzdXBwcmVzcyB7Y2hlY2tUeXBlc30gY2hlY2tlZCBieSB0c2NcbiAqL1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xudmFyIEJyb3dzZXJBbmltYXRpb25CdWlsZGVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQnJvd3NlckFuaW1hdGlvbkJ1aWxkZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQnJvd3NlckFuaW1hdGlvbkJ1aWxkZXIocm9vdFJlbmRlcmVyLCBkb2MpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuX25leHRBbmltYXRpb25JZCA9IDA7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHR5cGVEYXRhID0gLyoqIEB0eXBlIHs/fSAqLyAoe1xuICAgICAgICAgICAgaWQ6ICcwJyxcbiAgICAgICAgICAgIGVuY2Fwc3VsYXRpb246IF9hbmd1bGFyX2NvcmUuVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcbiAgICAgICAgICAgIHN0eWxlczogW10sXG4gICAgICAgICAgICBkYXRhOiB7IGFuaW1hdGlvbjogW10gfVxuICAgICAgICB9KTtcbiAgICAgICAgX3RoaXMuX3JlbmRlcmVyID0gLyoqIEB0eXBlIHs/fSAqLyAocm9vdFJlbmRlcmVyLmNyZWF0ZVJlbmRlcmVyKGRvYy5ib2R5LCB0eXBlRGF0YSkpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYW5pbWF0aW9uXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBCcm93c2VyQW5pbWF0aW9uQnVpbGRlci5wcm90b3R5cGUuYnVpbGQgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IGFuaW1hdGlvblxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKGFuaW1hdGlvbikge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpZCA9IHRoaXMuX25leHRBbmltYXRpb25JZC50b1N0cmluZygpO1xuICAgICAgICB0aGlzLl9uZXh0QW5pbWF0aW9uSWQrKztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZW50cnkgPSBBcnJheS5pc0FycmF5KGFuaW1hdGlvbikgPyBfYW5ndWxhcl9hbmltYXRpb25zLnNlcXVlbmNlKGFuaW1hdGlvbikgOiBhbmltYXRpb247XG4gICAgICAgIGlzc3VlQW5pbWF0aW9uQ29tbWFuZCh0aGlzLl9yZW5kZXJlciwgbnVsbCwgaWQsICdyZWdpc3RlcicsIFtlbnRyeV0pO1xuICAgICAgICByZXR1cm4gbmV3IEJyb3dzZXJBbmltYXRpb25GYWN0b3J5KGlkLCB0aGlzLl9yZW5kZXJlcik7XG4gICAgfTtcbiAgICBCcm93c2VyQW5pbWF0aW9uQnVpbGRlci5kZWNvcmF0b3JzID0gW1xuICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5qZWN0YWJsZSB9LFxuICAgIF07XG4gICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgQnJvd3NlckFuaW1hdGlvbkJ1aWxkZXIuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5SZW5kZXJlckZhY3RvcnkyLCB9LFxuICAgICAgICB7IHR5cGU6IHVuZGVmaW5lZCwgZGVjb3JhdG9yczogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3QsIGFyZ3M6IFtfYW5ndWxhcl9wbGF0Zm9ybUJyb3dzZXIuRE9DVU1FTlQsXSB9LF0gfSxcbiAgICBdOyB9O1xuICAgIHJldHVybiBCcm93c2VyQW5pbWF0aW9uQnVpbGRlcjtcbn0oX2FuZ3VsYXJfYW5pbWF0aW9ucy5BbmltYXRpb25CdWlsZGVyKSk7XG52YXIgQnJvd3NlckFuaW1hdGlvbkZhY3RvcnkgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhCcm93c2VyQW5pbWF0aW9uRmFjdG9yeSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBCcm93c2VyQW5pbWF0aW9uRmFjdG9yeShfaWQsIF9yZW5kZXJlcikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5faWQgPSBfaWQ7XG4gICAgICAgIF90aGlzLl9yZW5kZXJlciA9IF9yZW5kZXJlcjtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0gez89fSBvcHRpb25zXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBCcm93c2VyQW5pbWF0aW9uRmFjdG9yeS5wcm90b3R5cGUuY3JlYXRlID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XG4gICAgICogQHBhcmFtIHs/PX0gb3B0aW9uc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSZW5kZXJlckFuaW1hdGlvblBsYXllcih0aGlzLl9pZCwgZWxlbWVudCwgb3B0aW9ucyB8fCB7fSwgdGhpcy5fcmVuZGVyZXIpO1xuICAgIH07XG4gICAgcmV0dXJuIEJyb3dzZXJBbmltYXRpb25GYWN0b3J5O1xufShfYW5ndWxhcl9hbmltYXRpb25zLkFuaW1hdGlvbkZhY3RvcnkpKTtcbnZhciBSZW5kZXJlckFuaW1hdGlvblBsYXllciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUmVuZGVyZXJBbmltYXRpb25QbGF5ZXIoaWQsIGVsZW1lbnQsIG9wdGlvbnMsIF9yZW5kZXJlcikge1xuICAgICAgICB0aGlzLmlkID0gaWQ7XG4gICAgICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICAgIHRoaXMuX3JlbmRlcmVyID0gX3JlbmRlcmVyO1xuICAgICAgICB0aGlzLnBhcmVudFBsYXllciA9IG51bGw7XG4gICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy50b3RhbFRpbWUgPSAwO1xuICAgICAgICB0aGlzLl9jb21tYW5kKCdjcmVhdGUnLCBvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBldmVudE5hbWVcbiAgICAgKiBAcGFyYW0gez99IGNhbGxiYWNrXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBSZW5kZXJlckFuaW1hdGlvblBsYXllci5wcm90b3R5cGUuX2xpc3RlbiA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gZXZlbnROYW1lXG4gICAgICogQHBhcmFtIHs/fSBjYWxsYmFja1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKGV2ZW50TmFtZSwgY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlbmRlcmVyLmxpc3Rlbih0aGlzLmVsZW1lbnQsIFwiQEBcIiArIHRoaXMuaWQgKyBcIjpcIiArIGV2ZW50TmFtZSwgY2FsbGJhY2spO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBjb21tYW5kXG4gICAgICogQHBhcmFtIHsuLi4/fSBhcmdzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBSZW5kZXJlckFuaW1hdGlvblBsYXllci5wcm90b3R5cGUuX2NvbW1hbmQgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IGNvbW1hbmRcbiAgICAgKiBAcGFyYW0gey4uLj99IGFyZ3NcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChjb21tYW5kKSB7XG4gICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBhcmdzW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpc3N1ZUFuaW1hdGlvbkNvbW1hbmQodGhpcy5fcmVuZGVyZXIsIHRoaXMuZWxlbWVudCwgdGhpcy5pZCwgY29tbWFuZCwgYXJncyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGZuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBSZW5kZXJlckFuaW1hdGlvblBsYXllci5wcm90b3R5cGUub25Eb25lID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBmblxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKGZuKSB7IHRoaXMuX2xpc3RlbignZG9uZScsIGZuKTsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGZuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBSZW5kZXJlckFuaW1hdGlvblBsYXllci5wcm90b3R5cGUub25TdGFydCA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gZm5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChmbikgeyB0aGlzLl9saXN0ZW4oJ3N0YXJ0JywgZm4pOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZm5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFJlbmRlcmVyQW5pbWF0aW9uUGxheWVyLnByb3RvdHlwZS5vbkRlc3Ryb3kgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IGZuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoZm4pIHsgdGhpcy5fbGlzdGVuKCdkZXN0cm95JywgZm4pOyB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUmVuZGVyZXJBbmltYXRpb25QbGF5ZXIucHJvdG90eXBlLmluaXQgPSAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uICgpIHsgdGhpcy5fY29tbWFuZCgnaW5pdCcpOyB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUmVuZGVyZXJBbmltYXRpb25QbGF5ZXIucHJvdG90eXBlLmhhc1N0YXJ0ZWQgPSAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3N0YXJ0ZWQ7IH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBSZW5kZXJlckFuaW1hdGlvblBsYXllci5wcm90b3R5cGUucGxheSA9IC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9jb21tYW5kKCdwbGF5Jyk7XG4gICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSB0cnVlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBSZW5kZXJlckFuaW1hdGlvblBsYXllci5wcm90b3R5cGUucGF1c2UgPSAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uICgpIHsgdGhpcy5fY29tbWFuZCgncGF1c2UnKTsgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFJlbmRlcmVyQW5pbWF0aW9uUGxheWVyLnByb3RvdHlwZS5yZXN0YXJ0ID0gLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoKSB7IHRoaXMuX2NvbW1hbmQoJ3Jlc3RhcnQnKTsgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFJlbmRlcmVyQW5pbWF0aW9uUGxheWVyLnByb3RvdHlwZS5maW5pc2ggPSAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uICgpIHsgdGhpcy5fY29tbWFuZCgnZmluaXNoJyk7IH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBSZW5kZXJlckFuaW1hdGlvblBsYXllci5wcm90b3R5cGUuZGVzdHJveSA9IC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKCkgeyB0aGlzLl9jb21tYW5kKCdkZXN0cm95Jyk7IH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBSZW5kZXJlckFuaW1hdGlvblBsYXllci5wcm90b3R5cGUucmVzZXQgPSAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uICgpIHsgdGhpcy5fY29tbWFuZCgncmVzZXQnKTsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHBcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFJlbmRlcmVyQW5pbWF0aW9uUGxheWVyLnByb3RvdHlwZS5zZXRQb3NpdGlvbiA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gcFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKHApIHsgdGhpcy5fY29tbWFuZCgnc2V0UG9zaXRpb24nLCBwKTsgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFJlbmRlcmVyQW5pbWF0aW9uUGxheWVyLnByb3RvdHlwZS5nZXRQb3NpdGlvbiA9IC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKCkgeyByZXR1cm4gMDsgfTtcbiAgICByZXR1cm4gUmVuZGVyZXJBbmltYXRpb25QbGF5ZXI7XG59KCkpO1xuLyoqXG4gKiBAcGFyYW0gez99IHJlbmRlcmVyXG4gKiBAcGFyYW0gez99IGVsZW1lbnRcbiAqIEBwYXJhbSB7P30gaWRcbiAqIEBwYXJhbSB7P30gY29tbWFuZFxuICogQHBhcmFtIHs/fSBhcmdzXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBpc3N1ZUFuaW1hdGlvbkNvbW1hbmQocmVuZGVyZXIsIGVsZW1lbnQsIGlkLCBjb21tYW5kLCBhcmdzKSB7XG4gICAgcmV0dXJuIHJlbmRlcmVyLnNldFByb3BlcnR5KGVsZW1lbnQsIFwiQEBcIiArIGlkICsgXCI6XCIgKyBjb21tYW5kLCBhcmdzKTtcbn1cblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IGFkZGVkIGJ5IHRzaWNrbGVcbiAqIEBzdXBwcmVzcyB7Y2hlY2tUeXBlc30gY2hlY2tlZCBieSB0c2NcbiAqL1xudmFyIEFOSU1BVElPTl9QUkVGSVggPSAnQCc7XG52YXIgRElTQUJMRV9BTklNQVRJT05TX0ZMQUcgPSAnQC5kaXNhYmxlZCc7XG52YXIgQW5pbWF0aW9uUmVuZGVyZXJGYWN0b3J5ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBbmltYXRpb25SZW5kZXJlckZhY3RvcnkoZGVsZWdhdGUsIGVuZ2luZSwgX3pvbmUpIHtcbiAgICAgICAgdGhpcy5kZWxlZ2F0ZSA9IGRlbGVnYXRlO1xuICAgICAgICB0aGlzLmVuZ2luZSA9IGVuZ2luZTtcbiAgICAgICAgdGhpcy5fem9uZSA9IF96b25lO1xuICAgICAgICB0aGlzLl9jdXJyZW50SWQgPSAwO1xuICAgICAgICB0aGlzLl9taWNyb3Rhc2tJZCA9IDE7XG4gICAgICAgIHRoaXMuX2FuaW1hdGlvbkNhbGxiYWNrc0J1ZmZlciA9IFtdO1xuICAgICAgICB0aGlzLl9yZW5kZXJlckNhY2hlID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9jZFJlY3VyRGVwdGggPSAwO1xuICAgICAgICBlbmdpbmUub25SZW1vdmFsQ29tcGxldGUgPSBmdW5jdGlvbiAoZWxlbWVudCwgZGVsZWdhdGUpIHtcbiAgICAgICAgICAgIC8vIE5vdGU6IGlmIGFuIGNvbXBvbmVudCBlbGVtZW50IGhhcyBhIGxlYXZlIGFuaW1hdGlvbiwgYW5kIHRoZSBjb21wb25lbnRcbiAgICAgICAgICAgIC8vIGEgaG9zdCBsZWF2ZSBhbmltYXRpb24sIHRoZSB2aWV3IGVuZ2luZSB3aWxsIGNhbGwgYHJlbW92ZUNoaWxkYCBmb3IgdGhlIHBhcmVudFxuICAgICAgICAgICAgLy8gY29tcG9uZW50IHJlbmRlcmVyIGFzIHdlbGwgYXMgZm9yIHRoZSBjaGlsZCBjb21wb25lbnQgcmVuZGVyZXIuXG4gICAgICAgICAgICAvLyBUaGVyZWZvcmUsIHdlIG5lZWQgdG8gY2hlY2sgaWYgd2UgYWxyZWFkeSByZW1vdmVkIHRoZSBlbGVtZW50LlxuICAgICAgICAgICAgaWYgKGRlbGVnYXRlICYmIGRlbGVnYXRlLnBhcmVudE5vZGUoZWxlbWVudCkpIHtcbiAgICAgICAgICAgICAgICBkZWxlZ2F0ZS5yZW1vdmVDaGlsZChlbGVtZW50LnBhcmVudE5vZGUsIGVsZW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGhvc3RFbGVtZW50XG4gICAgICogQHBhcmFtIHs/fSB0eXBlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBbmltYXRpb25SZW5kZXJlckZhY3RvcnkucHJvdG90eXBlLmNyZWF0ZVJlbmRlcmVyID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBob3N0RWxlbWVudFxuICAgICAqIEBwYXJhbSB7P30gdHlwZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKGhvc3RFbGVtZW50LCB0eXBlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIEVNUFRZX05BTUVTUEFDRV9JRCA9ICcnO1xuICAgICAgICAvLyBjYWNoZSB0aGUgZGVsZWdhdGVzIHRvIGZpbmQgb3V0IHdoaWNoIGNhY2hlZCBkZWxlZ2F0ZSBjYW5cbiAgICAgICAgLy8gYmUgdXNlZCBieSB3aGljaCBjYWNoZWQgcmVuZGVyZXJcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZGVsZWdhdGUgPSB0aGlzLmRlbGVnYXRlLmNyZWF0ZVJlbmRlcmVyKGhvc3RFbGVtZW50LCB0eXBlKTtcbiAgICAgICAgaWYgKCFob3N0RWxlbWVudCB8fCAhdHlwZSB8fCAhdHlwZS5kYXRhIHx8ICF0eXBlLmRhdGFbJ2FuaW1hdGlvbiddKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZW5kZXJlciA9IHRoaXMuX3JlbmRlcmVyQ2FjaGUuZ2V0KGRlbGVnYXRlKTtcbiAgICAgICAgICAgIGlmICghcmVuZGVyZXIpIHtcbiAgICAgICAgICAgICAgICByZW5kZXJlciA9IG5ldyBCYXNlQW5pbWF0aW9uUmVuZGVyZXIoRU1QVFlfTkFNRVNQQUNFX0lELCBkZWxlZ2F0ZSwgdGhpcy5lbmdpbmUpO1xuICAgICAgICAgICAgICAgIC8vIG9ubHkgY2FjaGUgdGhpcyByZXN1bHQgd2hlbiB0aGUgYmFzZSByZW5kZXJlciBpcyB1c2VkXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXJDYWNoZS5zZXQoZGVsZWdhdGUsIHJlbmRlcmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZW5kZXJlcjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb21wb25lbnRJZCA9IHR5cGUuaWQ7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5hbWVzcGFjZUlkID0gdHlwZS5pZCArICctJyArIHRoaXMuX2N1cnJlbnRJZDtcbiAgICAgICAgdGhpcy5fY3VycmVudElkKys7XG4gICAgICAgIHRoaXMuZW5naW5lLnJlZ2lzdGVyKG5hbWVzcGFjZUlkLCBob3N0RWxlbWVudCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGFuaW1hdGlvblRyaWdnZXJzID0gLyoqIEB0eXBlIHs/fSAqLyAodHlwZS5kYXRhWydhbmltYXRpb24nXSk7XG4gICAgICAgIGFuaW1hdGlvblRyaWdnZXJzLmZvckVhY2goZnVuY3Rpb24gKHRyaWdnZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5lbmdpbmUucmVnaXN0ZXJUcmlnZ2VyKGNvbXBvbmVudElkLCBuYW1lc3BhY2VJZCwgaG9zdEVsZW1lbnQsIHRyaWdnZXIubmFtZSwgdHJpZ2dlcik7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbmV3IEFuaW1hdGlvblJlbmRlcmVyKHRoaXMsIG5hbWVzcGFjZUlkLCBkZWxlZ2F0ZSwgdGhpcy5lbmdpbmUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBbmltYXRpb25SZW5kZXJlckZhY3RvcnkucHJvdG90eXBlLmJlZ2luID0gLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2NkUmVjdXJEZXB0aCsrO1xuICAgICAgICBpZiAodGhpcy5kZWxlZ2F0ZS5iZWdpbikge1xuICAgICAgICAgICAgdGhpcy5kZWxlZ2F0ZS5iZWdpbigpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFuaW1hdGlvblJlbmRlcmVyRmFjdG9yeS5wcm90b3R5cGUuX3NjaGVkdWxlQ291bnRUYXNrID0gLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIFpvbmUuY3VycmVudC5zY2hlZHVsZU1pY3JvVGFzaygnaW5jcmVtZW5ldCB0aGUgYW5pbWF0aW9uIG1pY3JvdGFzaycsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLl9taWNyb3Rhc2tJZCsrOyB9KTtcbiAgICB9O1xuICAgIC8qIEBpbnRlcm5hbCAqL1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gY291bnRcbiAgICAgKiBAcGFyYW0gez99IGZuXG4gICAgICogQHBhcmFtIHs/fSBkYXRhXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBbmltYXRpb25SZW5kZXJlckZhY3RvcnkucHJvdG90eXBlLnNjaGVkdWxlTGlzdGVuZXJDYWxsYmFjayA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gY291bnRcbiAgICAgKiBAcGFyYW0gez99IGZuXG4gICAgICogQHBhcmFtIHs/fSBkYXRhXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoY291bnQsIGZuLCBkYXRhKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChjb3VudCA+PSAwICYmIGNvdW50IDwgdGhpcy5fbWljcm90YXNrSWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3pvbmUucnVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZuKGRhdGEpOyB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fYW5pbWF0aW9uQ2FsbGJhY2tzQnVmZmVyLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICBQcm9taXNlLnJlc29sdmUobnVsbCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX3pvbmUucnVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2FuaW1hdGlvbkNhbGxiYWNrc0J1ZmZlci5mb3JFYWNoKGZ1bmN0aW9uICh0dXBsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZuID0gdHVwbGVbMF0sIGRhdGEgPSB0dXBsZVsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZuKGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2FuaW1hdGlvbkNhbGxiYWNrc0J1ZmZlciA9IFtdO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fYW5pbWF0aW9uQ2FsbGJhY2tzQnVmZmVyLnB1c2goW2ZuLCBkYXRhXSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFuaW1hdGlvblJlbmRlcmVyRmFjdG9yeS5wcm90b3R5cGUuZW5kID0gLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX2NkUmVjdXJEZXB0aC0tO1xuICAgICAgICAvLyB0aGlzIGlzIHRvIHByZXZlbnQgYW5pbWF0aW9ucyBmcm9tIHJ1bm5pbmcgdHdpY2Ugd2hlbiBhbiBpbm5lclxuICAgICAgICAvLyBjb21wb25lbnQgZG9lcyBDRCB3aGVuIGEgcGFyZW50IGNvbXBvbmVudCBpbnN0ZWQgaGFzIGluc2VydGVkIGl0XG4gICAgICAgIGlmICh0aGlzLl9jZFJlY3VyRGVwdGggPT0gMCkge1xuICAgICAgICAgICAgdGhpcy5fem9uZS5ydW5PdXRzaWRlQW5ndWxhcihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX3NjaGVkdWxlQ291bnRUYXNrKCk7XG4gICAgICAgICAgICAgICAgX3RoaXMuZW5naW5lLmZsdXNoKF90aGlzLl9taWNyb3Rhc2tJZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5kZWxlZ2F0ZS5lbmQpIHtcbiAgICAgICAgICAgIHRoaXMuZGVsZWdhdGUuZW5kKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQW5pbWF0aW9uUmVuZGVyZXJGYWN0b3J5LnByb3RvdHlwZS53aGVuUmVuZGVyaW5nRG9uZSA9IC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5lbmdpbmUud2hlblJlbmRlcmluZ0RvbmUoKTsgfTtcbiAgICBBbmltYXRpb25SZW5kZXJlckZhY3RvcnkuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdGFibGUgfSxcbiAgICBdO1xuICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgIEFuaW1hdGlvblJlbmRlcmVyRmFjdG9yeS5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLlJlbmRlcmVyRmFjdG9yeTIsIH0sXG4gICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfYW5pbWF0aW9uc19icm93c2VyLsm1QW5pbWF0aW9uRW5naW5lLCB9LFxuICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuTmdab25lLCB9LFxuICAgIF07IH07XG4gICAgcmV0dXJuIEFuaW1hdGlvblJlbmRlcmVyRmFjdG9yeTtcbn0oKSk7XG52YXIgQmFzZUFuaW1hdGlvblJlbmRlcmVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBCYXNlQW5pbWF0aW9uUmVuZGVyZXIobmFtZXNwYWNlSWQsIGRlbGVnYXRlLCBlbmdpbmUpIHtcbiAgICAgICAgdGhpcy5uYW1lc3BhY2VJZCA9IG5hbWVzcGFjZUlkO1xuICAgICAgICB0aGlzLmRlbGVnYXRlID0gZGVsZWdhdGU7XG4gICAgICAgIHRoaXMuZW5naW5lID0gZW5naW5lO1xuICAgICAgICB0aGlzLmRlc3Ryb3lOb2RlID0gdGhpcy5kZWxlZ2F0ZS5kZXN0cm95Tm9kZSA/IGZ1bmN0aW9uIChuKSB7IHJldHVybiAvKiogQHR5cGUgez99ICovICgoZGVsZWdhdGUuZGVzdHJveU5vZGUpKShuKTsgfSA6IG51bGw7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCYXNlQW5pbWF0aW9uUmVuZGVyZXIucHJvdG90eXBlLCBcImRhdGFcIiwge1xuICAgICAgICBnZXQ6IC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5kZWxlZ2F0ZS5kYXRhOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEJhc2VBbmltYXRpb25SZW5kZXJlci5wcm90b3R5cGUuZGVzdHJveSA9IC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmVuZ2luZS5kZXN0cm95KHRoaXMubmFtZXNwYWNlSWQsIHRoaXMuZGVsZWdhdGUpO1xuICAgICAgICB0aGlzLmRlbGVnYXRlLmRlc3Ryb3koKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEBwYXJhbSB7Pz19IG5hbWVzcGFjZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQmFzZUFuaW1hdGlvblJlbmRlcmVyLnByb3RvdHlwZS5jcmVhdGVFbGVtZW50ID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHBhcmFtIHs/PX0gbmFtZXNwYWNlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAobmFtZSwgbmFtZXNwYWNlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlbGVnYXRlLmNyZWF0ZUVsZW1lbnQobmFtZSwgbmFtZXNwYWNlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEJhc2VBbmltYXRpb25SZW5kZXJlci5wcm90b3R5cGUuY3JlYXRlQ29tbWVudCA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gdGhpcy5kZWxlZ2F0ZS5jcmVhdGVDb21tZW50KHZhbHVlKTsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBCYXNlQW5pbWF0aW9uUmVuZGVyZXIucHJvdG90eXBlLmNyZWF0ZVRleHQgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIHRoaXMuZGVsZWdhdGUuY3JlYXRlVGV4dCh2YWx1ZSk7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBwYXJlbnRcbiAgICAgKiBAcGFyYW0gez99IG5ld0NoaWxkXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBCYXNlQW5pbWF0aW9uUmVuZGVyZXIucHJvdG90eXBlLmFwcGVuZENoaWxkID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBwYXJlbnRcbiAgICAgKiBAcGFyYW0gez99IG5ld0NoaWxkXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAocGFyZW50LCBuZXdDaGlsZCkge1xuICAgICAgICB0aGlzLmRlbGVnYXRlLmFwcGVuZENoaWxkKHBhcmVudCwgbmV3Q2hpbGQpO1xuICAgICAgICB0aGlzLmVuZ2luZS5vbkluc2VydCh0aGlzLm5hbWVzcGFjZUlkLCBuZXdDaGlsZCwgcGFyZW50LCBmYWxzZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHBhcmVudFxuICAgICAqIEBwYXJhbSB7P30gbmV3Q2hpbGRcbiAgICAgKiBAcGFyYW0gez99IHJlZkNoaWxkXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBCYXNlQW5pbWF0aW9uUmVuZGVyZXIucHJvdG90eXBlLmluc2VydEJlZm9yZSA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gcGFyZW50XG4gICAgICogQHBhcmFtIHs/fSBuZXdDaGlsZFxuICAgICAqIEBwYXJhbSB7P30gcmVmQ2hpbGRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChwYXJlbnQsIG5ld0NoaWxkLCByZWZDaGlsZCkge1xuICAgICAgICB0aGlzLmRlbGVnYXRlLmluc2VydEJlZm9yZShwYXJlbnQsIG5ld0NoaWxkLCByZWZDaGlsZCk7XG4gICAgICAgIHRoaXMuZW5naW5lLm9uSW5zZXJ0KHRoaXMubmFtZXNwYWNlSWQsIG5ld0NoaWxkLCBwYXJlbnQsIHRydWUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBwYXJlbnRcbiAgICAgKiBAcGFyYW0gez99IG9sZENoaWxkXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBCYXNlQW5pbWF0aW9uUmVuZGVyZXIucHJvdG90eXBlLnJlbW92ZUNoaWxkID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBwYXJlbnRcbiAgICAgKiBAcGFyYW0gez99IG9sZENoaWxkXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAocGFyZW50LCBvbGRDaGlsZCkge1xuICAgICAgICB0aGlzLmVuZ2luZS5vblJlbW92ZSh0aGlzLm5hbWVzcGFjZUlkLCBvbGRDaGlsZCwgdGhpcy5kZWxlZ2F0ZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHNlbGVjdG9yT3JOb2RlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBCYXNlQW5pbWF0aW9uUmVuZGVyZXIucHJvdG90eXBlLnNlbGVjdFJvb3RFbGVtZW50ID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBzZWxlY3Rvck9yTm9kZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKHNlbGVjdG9yT3JOb2RlKSB7IHJldHVybiB0aGlzLmRlbGVnYXRlLnNlbGVjdFJvb3RFbGVtZW50KHNlbGVjdG9yT3JOb2RlKTsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5vZGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEJhc2VBbmltYXRpb25SZW5kZXJlci5wcm90b3R5cGUucGFyZW50Tm9kZSA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gbm9kZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIHRoaXMuZGVsZWdhdGUucGFyZW50Tm9kZShub2RlKTsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5vZGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEJhc2VBbmltYXRpb25SZW5kZXJlci5wcm90b3R5cGUubmV4dFNpYmxpbmcgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IG5vZGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiB0aGlzLmRlbGVnYXRlLm5leHRTaWJsaW5nKG5vZGUpOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZWxcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICogQHBhcmFtIHs/PX0gbmFtZXNwYWNlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBCYXNlQW5pbWF0aW9uUmVuZGVyZXIucHJvdG90eXBlLnNldEF0dHJpYnV0ZSA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gZWxcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICogQHBhcmFtIHs/PX0gbmFtZXNwYWNlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoZWwsIG5hbWUsIHZhbHVlLCBuYW1lc3BhY2UpIHtcbiAgICAgICAgdGhpcy5kZWxlZ2F0ZS5zZXRBdHRyaWJ1dGUoZWwsIG5hbWUsIHZhbHVlLCBuYW1lc3BhY2UpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbFxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEBwYXJhbSB7Pz19IG5hbWVzcGFjZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQmFzZUFuaW1hdGlvblJlbmRlcmVyLnByb3RvdHlwZS5yZW1vdmVBdHRyaWJ1dGUgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHBhcmFtIHs/PX0gbmFtZXNwYWNlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoZWwsIG5hbWUsIG5hbWVzcGFjZSkge1xuICAgICAgICB0aGlzLmRlbGVnYXRlLnJlbW92ZUF0dHJpYnV0ZShlbCwgbmFtZSwgbmFtZXNwYWNlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZWxcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEJhc2VBbmltYXRpb25SZW5kZXJlci5wcm90b3R5cGUuYWRkQ2xhc3MgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoZWwsIG5hbWUpIHsgdGhpcy5kZWxlZ2F0ZS5hZGRDbGFzcyhlbCwgbmFtZSk7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbFxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQmFzZUFuaW1hdGlvblJlbmRlcmVyLnByb3RvdHlwZS5yZW1vdmVDbGFzcyA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gZWxcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChlbCwgbmFtZSkgeyB0aGlzLmRlbGVnYXRlLnJlbW92ZUNsYXNzKGVsLCBuYW1lKTsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsXG4gICAgICogQHBhcmFtIHs/fSBzdHlsZVxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgKiBAcGFyYW0gez89fSBmbGFnc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQmFzZUFuaW1hdGlvblJlbmRlcmVyLnByb3RvdHlwZS5zZXRTdHlsZSA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gZWxcbiAgICAgKiBAcGFyYW0gez99IHN0eWxlXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Pz19IGZsYWdzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoZWwsIHN0eWxlLCB2YWx1ZSwgZmxhZ3MpIHtcbiAgICAgICAgdGhpcy5kZWxlZ2F0ZS5zZXRTdHlsZShlbCwgc3R5bGUsIHZhbHVlLCBmbGFncyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsXG4gICAgICogQHBhcmFtIHs/fSBzdHlsZVxuICAgICAqIEBwYXJhbSB7Pz19IGZsYWdzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBCYXNlQW5pbWF0aW9uUmVuZGVyZXIucHJvdG90eXBlLnJlbW92ZVN0eWxlID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbFxuICAgICAqIEBwYXJhbSB7P30gc3R5bGVcbiAgICAgKiBAcGFyYW0gez89fSBmbGFnc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKGVsLCBzdHlsZSwgZmxhZ3MpIHtcbiAgICAgICAgdGhpcy5kZWxlZ2F0ZS5yZW1vdmVTdHlsZShlbCwgc3R5bGUsIGZsYWdzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZWxcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBCYXNlQW5pbWF0aW9uUmVuZGVyZXIucHJvdG90eXBlLnNldFByb3BlcnR5ID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbFxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChlbCwgbmFtZSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKG5hbWUuY2hhckF0KDApID09IEFOSU1BVElPTl9QUkVGSVggJiYgbmFtZSA9PSBESVNBQkxFX0FOSU1BVElPTlNfRkxBRykge1xuICAgICAgICAgICAgdGhpcy5kaXNhYmxlQW5pbWF0aW9ucyhlbCwgISF2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRlbGVnYXRlLnNldFByb3BlcnR5KGVsLCBuYW1lLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbm9kZVxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEJhc2VBbmltYXRpb25SZW5kZXJlci5wcm90b3R5cGUuc2V0VmFsdWUgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IG5vZGVcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAobm9kZSwgdmFsdWUpIHsgdGhpcy5kZWxlZ2F0ZS5zZXRWYWx1ZShub2RlLCB2YWx1ZSk7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB0YXJnZXRcbiAgICAgKiBAcGFyYW0gez99IGV2ZW50TmFtZVxuICAgICAqIEBwYXJhbSB7P30gY2FsbGJhY2tcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEJhc2VBbmltYXRpb25SZW5kZXJlci5wcm90b3R5cGUubGlzdGVuID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSB0YXJnZXRcbiAgICAgKiBAcGFyYW0gez99IGV2ZW50TmFtZVxuICAgICAqIEBwYXJhbSB7P30gY2FsbGJhY2tcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uICh0YXJnZXQsIGV2ZW50TmFtZSwgY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVsZWdhdGUubGlzdGVuKHRhcmdldCwgZXZlbnROYW1lLCBjYWxsYmFjayk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBCYXNlQW5pbWF0aW9uUmVuZGVyZXIucHJvdG90eXBlLmRpc2FibGVBbmltYXRpb25zID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKGVsZW1lbnQsIHZhbHVlKSB7XG4gICAgICAgIHRoaXMuZW5naW5lLmRpc2FibGVBbmltYXRpb25zKGVsZW1lbnQsIHZhbHVlKTtcbiAgICB9O1xuICAgIHJldHVybiBCYXNlQW5pbWF0aW9uUmVuZGVyZXI7XG59KCkpO1xudmFyIEFuaW1hdGlvblJlbmRlcmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQW5pbWF0aW9uUmVuZGVyZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQW5pbWF0aW9uUmVuZGVyZXIoZmFjdG9yeSwgbmFtZXNwYWNlSWQsIGRlbGVnYXRlLCBlbmdpbmUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbmFtZXNwYWNlSWQsIGRlbGVnYXRlLCBlbmdpbmUpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmZhY3RvcnkgPSBmYWN0b3J5O1xuICAgICAgICBfdGhpcy5uYW1lc3BhY2VJZCA9IG5hbWVzcGFjZUlkO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZWxcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBbmltYXRpb25SZW5kZXJlci5wcm90b3R5cGUuc2V0UHJvcGVydHkgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKGVsLCBuYW1lLCB2YWx1ZSkge1xuICAgICAgICBpZiAobmFtZS5jaGFyQXQoMCkgPT0gQU5JTUFUSU9OX1BSRUZJWCkge1xuICAgICAgICAgICAgaWYgKG5hbWUuY2hhckF0KDEpID09ICcuJyAmJiBuYW1lID09IERJU0FCTEVfQU5JTUFUSU9OU19GTEFHKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6ICEhdmFsdWU7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNhYmxlQW5pbWF0aW9ucyhlbCwgLyoqIEB0eXBlIHs/fSAqLyAodmFsdWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZW5naW5lLnByb2Nlc3ModGhpcy5uYW1lc3BhY2VJZCwgZWwsIG5hbWUuc3Vic3RyKDEpLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRlbGVnYXRlLnNldFByb3BlcnR5KGVsLCBuYW1lLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdGFyZ2V0XG4gICAgICogQHBhcmFtIHs/fSBldmVudE5hbWVcbiAgICAgKiBAcGFyYW0gez99IGNhbGxiYWNrXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBbmltYXRpb25SZW5kZXJlci5wcm90b3R5cGUubGlzdGVuID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSB0YXJnZXRcbiAgICAgKiBAcGFyYW0gez99IGV2ZW50TmFtZVxuICAgICAqIEBwYXJhbSB7P30gY2FsbGJhY2tcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uICh0YXJnZXQsIGV2ZW50TmFtZSwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKGV2ZW50TmFtZS5jaGFyQXQoMCkgPT0gQU5JTUFUSU9OX1BSRUZJWCkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZWxlbWVudCA9IHJlc29sdmVFbGVtZW50RnJvbVRhcmdldCh0YXJnZXQpO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbmFtZV8xID0gZXZlbnROYW1lLnN1YnN0cigxKTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBoYXNlID0gJyc7XG4gICAgICAgICAgICAvLyBAbGlzdGVuZXIucGhhc2UgaXMgZm9yIHRyaWdnZXIgYW5pbWF0aW9uIGNhbGxiYWNrc1xuICAgICAgICAgICAgLy8gQEBsaXN0ZW5lciBpcyBmb3IgYW5pbWF0aW9uIGJ1aWxkZXIgY2FsbGJhY2tzXG4gICAgICAgICAgICBpZiAobmFtZV8xLmNoYXJBdCgwKSAhPSBBTklNQVRJT05fUFJFRklYKSB7XG4gICAgICAgICAgICAgICAgX2EgPSBwYXJzZVRyaWdnZXJDYWxsYmFja05hbWUobmFtZV8xKSwgbmFtZV8xID0gX2FbMF0sIHBoYXNlID0gX2FbMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbmdpbmUubGlzdGVuKHRoaXMubmFtZXNwYWNlSWQsIGVsZW1lbnQsIG5hbWVfMSwgcGhhc2UsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNvdW50SWQgPSAoLyoqIEB0eXBlIHs/fSAqLyAoZXZlbnQpKVsnX2RhdGEnXSB8fCAtMTtcbiAgICAgICAgICAgICAgICBfdGhpcy5mYWN0b3J5LnNjaGVkdWxlTGlzdGVuZXJDYWxsYmFjayhjb3VudElkLCBjYWxsYmFjaywgZXZlbnQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZGVsZWdhdGUubGlzdGVuKHRhcmdldCwgZXZlbnROYW1lLCBjYWxsYmFjayk7XG4gICAgICAgIHZhciBfYTtcbiAgICB9O1xuICAgIHJldHVybiBBbmltYXRpb25SZW5kZXJlcjtcbn0oQmFzZUFuaW1hdGlvblJlbmRlcmVyKSk7XG4vKipcbiAqIEBwYXJhbSB7P30gdGFyZ2V0XG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiByZXNvbHZlRWxlbWVudEZyb21UYXJnZXQodGFyZ2V0KSB7XG4gICAgc3dpdGNoICh0YXJnZXQpIHtcbiAgICAgICAgY2FzZSAnYm9keSc6XG4gICAgICAgICAgICByZXR1cm4gZG9jdW1lbnQuYm9keTtcbiAgICAgICAgY2FzZSAnZG9jdW1lbnQnOlxuICAgICAgICAgICAgcmV0dXJuIGRvY3VtZW50O1xuICAgICAgICBjYXNlICd3aW5kb3cnOlxuICAgICAgICAgICAgcmV0dXJuIHdpbmRvdztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxufVxuLyoqXG4gKiBAcGFyYW0gez99IHRyaWdnZXJOYW1lXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBwYXJzZVRyaWdnZXJDYWxsYmFja05hbWUodHJpZ2dlck5hbWUpIHtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkb3RJbmRleCA9IHRyaWdnZXJOYW1lLmluZGV4T2YoJy4nKTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0cmlnZ2VyID0gdHJpZ2dlck5hbWUuc3Vic3RyaW5nKDAsIGRvdEluZGV4KTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwaGFzZSA9IHRyaWdnZXJOYW1lLnN1YnN0cihkb3RJbmRleCArIDEpO1xuICAgIHJldHVybiBbdHJpZ2dlciwgcGhhc2VdO1xufVxuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgYWRkZWQgYnkgdHNpY2tsZVxuICogQHN1cHByZXNzIHtjaGVja1R5cGVzfSBjaGVja2VkIGJ5IHRzY1xuICovXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgSW5qZWN0YWJsZUFuaW1hdGlvbkVuZ2luZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEluamVjdGFibGVBbmltYXRpb25FbmdpbmUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSW5qZWN0YWJsZUFuaW1hdGlvbkVuZ2luZShkcml2ZXIsIG5vcm1hbGl6ZXIpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIGRyaXZlciwgbm9ybWFsaXplcikgfHwgdGhpcztcbiAgICB9XG4gICAgSW5qZWN0YWJsZUFuaW1hdGlvbkVuZ2luZS5kZWNvcmF0b3JzID0gW1xuICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5qZWN0YWJsZSB9LFxuICAgIF07XG4gICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgSW5qZWN0YWJsZUFuaW1hdGlvbkVuZ2luZS5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9hbmltYXRpb25zX2Jyb3dzZXIuQW5pbWF0aW9uRHJpdmVyLCB9LFxuICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2FuaW1hdGlvbnNfYnJvd3Nlci7JtUFuaW1hdGlvblN0eWxlTm9ybWFsaXplciwgfSxcbiAgICBdOyB9O1xuICAgIHJldHVybiBJbmplY3RhYmxlQW5pbWF0aW9uRW5naW5lO1xufShfYW5ndWxhcl9hbmltYXRpb25zX2Jyb3dzZXIuybVBbmltYXRpb25FbmdpbmUpKTtcbi8qKlxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gaW5zdGFudGlhdGVTdXBwb3J0ZWRBbmltYXRpb25Ecml2ZXIoKSB7XG4gICAgaWYgKF9hbmd1bGFyX2FuaW1hdGlvbnNfYnJvd3Nlci7JtXN1cHBvcnRzV2ViQW5pbWF0aW9ucygpKSB7XG4gICAgICAgIHJldHVybiBuZXcgX2FuZ3VsYXJfYW5pbWF0aW9uc19icm93c2VyLsm1V2ViQW5pbWF0aW9uc0RyaXZlcigpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IF9hbmd1bGFyX2FuaW1hdGlvbnNfYnJvd3Nlci7JtU5vb3BBbmltYXRpb25Ecml2ZXIoKTtcbn1cbi8qKlxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gaW5zdGFudGlhdGVEZWZhdWx0U3R5bGVOb3JtYWxpemVyKCkge1xuICAgIHJldHVybiBuZXcgX2FuZ3VsYXJfYW5pbWF0aW9uc19icm93c2VyLsm1V2ViQW5pbWF0aW9uc1N0eWxlTm9ybWFsaXplcigpO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IHJlbmRlcmVyXG4gKiBAcGFyYW0gez99IGVuZ2luZVxuICogQHBhcmFtIHs/fSB6b25lXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBpbnN0YW50aWF0ZVJlbmRlcmVyRmFjdG9yeShyZW5kZXJlciwgZW5naW5lLCB6b25lKSB7XG4gICAgcmV0dXJuIG5ldyBBbmltYXRpb25SZW5kZXJlckZhY3RvcnkocmVuZGVyZXIsIGVuZ2luZSwgem9uZSk7XG59XG52YXIgU0hBUkVEX0FOSU1BVElPTl9QUk9WSURFUlMgPSBbXG4gICAgeyBwcm92aWRlOiBfYW5ndWxhcl9hbmltYXRpb25zLkFuaW1hdGlvbkJ1aWxkZXIsIHVzZUNsYXNzOiBCcm93c2VyQW5pbWF0aW9uQnVpbGRlciB9LFxuICAgIHsgcHJvdmlkZTogX2FuZ3VsYXJfYW5pbWF0aW9uc19icm93c2VyLsm1QW5pbWF0aW9uU3R5bGVOb3JtYWxpemVyLCB1c2VGYWN0b3J5OiBpbnN0YW50aWF0ZURlZmF1bHRTdHlsZU5vcm1hbGl6ZXIgfSxcbiAgICB7IHByb3ZpZGU6IF9hbmd1bGFyX2FuaW1hdGlvbnNfYnJvd3Nlci7JtUFuaW1hdGlvbkVuZ2luZSwgdXNlQ2xhc3M6IEluamVjdGFibGVBbmltYXRpb25FbmdpbmUgfSwge1xuICAgICAgICBwcm92aWRlOiBfYW5ndWxhcl9jb3JlLlJlbmRlcmVyRmFjdG9yeTIsXG4gICAgICAgIHVzZUZhY3Rvcnk6IGluc3RhbnRpYXRlUmVuZGVyZXJGYWN0b3J5LFxuICAgICAgICBkZXBzOiBbX2FuZ3VsYXJfcGxhdGZvcm1Ccm93c2VyLsm1RG9tUmVuZGVyZXJGYWN0b3J5MiwgX2FuZ3VsYXJfYW5pbWF0aW9uc19icm93c2VyLsm1QW5pbWF0aW9uRW5naW5lLCBfYW5ndWxhcl9jb3JlLk5nWm9uZV1cbiAgICB9XG5dO1xuLyoqXG4gKiBTZXBhcmF0ZSBwcm92aWRlcnMgZnJvbSB0aGUgYWN0dWFsIG1vZHVsZSBzbyB0aGF0IHdlIGNhbiBkbyBhIGxvY2FsIG1vZGlmaWNhdGlvbiBpbiBHb29nbGUzIHRvXG4gKiBpbmNsdWRlIHRoZW0gaW4gdGhlIEJyb3dzZXJNb2R1bGUuXG4gKi9cbnZhciBCUk9XU0VSX0FOSU1BVElPTlNfUFJPVklERVJTID0gW1xuICAgIHsgcHJvdmlkZTogX2FuZ3VsYXJfYW5pbWF0aW9uc19icm93c2VyLkFuaW1hdGlvbkRyaXZlciwgdXNlRmFjdG9yeTogaW5zdGFudGlhdGVTdXBwb3J0ZWRBbmltYXRpb25Ecml2ZXIgfVxuXS5jb25jYXQoU0hBUkVEX0FOSU1BVElPTl9QUk9WSURFUlMpO1xuLyoqXG4gKiBTZXBhcmF0ZSBwcm92aWRlcnMgZnJvbSB0aGUgYWN0dWFsIG1vZHVsZSBzbyB0aGF0IHdlIGNhbiBkbyBhIGxvY2FsIG1vZGlmaWNhdGlvbiBpbiBHb29nbGUzIHRvXG4gKiBpbmNsdWRlIHRoZW0gaW4gdGhlIEJyb3dzZXJUZXN0aW5nTW9kdWxlLlxuICovXG52YXIgQlJPV1NFUl9OT09QX0FOSU1BVElPTlNfUFJPVklERVJTID0gW3sgcHJvdmlkZTogX2FuZ3VsYXJfYW5pbWF0aW9uc19icm93c2VyLkFuaW1hdGlvbkRyaXZlciwgdXNlQ2xhc3M6IF9hbmd1bGFyX2FuaW1hdGlvbnNfYnJvd3Nlci7JtU5vb3BBbmltYXRpb25Ecml2ZXIgfV0uY29uY2F0KFNIQVJFRF9BTklNQVRJT05fUFJPVklERVJTKTtcblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IGFkZGVkIGJ5IHRzaWNrbGVcbiAqIEBzdXBwcmVzcyB7Y2hlY2tUeXBlc30gY2hlY2tlZCBieSB0c2NcbiAqL1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLyoqXG4gKiBcXEBleHBlcmltZW50YWwgQW5pbWF0aW9uIHN1cHBvcnQgaXMgZXhwZXJpbWVudGFsLlxuICovXG52YXIgQnJvd3NlckFuaW1hdGlvbnNNb2R1bGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEJyb3dzZXJBbmltYXRpb25zTW9kdWxlKCkge1xuICAgIH1cbiAgICBCcm93c2VyQW5pbWF0aW9uc01vZHVsZS5kZWNvcmF0b3JzID0gW1xuICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuTmdNb2R1bGUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgICAgIGV4cG9ydHM6IFtfYW5ndWxhcl9wbGF0Zm9ybUJyb3dzZXIuQnJvd3Nlck1vZHVsZV0sXG4gICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyczogQlJPV1NFUl9BTklNQVRJT05TX1BST1ZJREVSUyxcbiAgICAgICAgICAgICAgICB9LF0gfSxcbiAgICBdO1xuICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgIEJyb3dzZXJBbmltYXRpb25zTW9kdWxlLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH07XG4gICAgcmV0dXJuIEJyb3dzZXJBbmltYXRpb25zTW9kdWxlO1xufSgpKTtcbi8qKlxuICogXFxAZXhwZXJpbWVudGFsIEFuaW1hdGlvbiBzdXBwb3J0IGlzIGV4cGVyaW1lbnRhbC5cbiAqL1xudmFyIE5vb3BBbmltYXRpb25zTW9kdWxlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBOb29wQW5pbWF0aW9uc01vZHVsZSgpIHtcbiAgICB9XG4gICAgTm9vcEFuaW1hdGlvbnNNb2R1bGUuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLk5nTW9kdWxlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICBleHBvcnRzOiBbX2FuZ3VsYXJfcGxhdGZvcm1Ccm93c2VyLkJyb3dzZXJNb2R1bGVdLFxuICAgICAgICAgICAgICAgICAgICBwcm92aWRlcnM6IEJST1dTRVJfTk9PUF9BTklNQVRJT05TX1BST1ZJREVSUyxcbiAgICAgICAgICAgICAgICB9LF0gfSxcbiAgICBdO1xuICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgIE5vb3BBbmltYXRpb25zTW9kdWxlLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH07XG4gICAgcmV0dXJuIE5vb3BBbmltYXRpb25zTW9kdWxlO1xufSgpKTtcblxuZXhwb3J0cy5Ccm93c2VyQW5pbWF0aW9uc01vZHVsZSA9IEJyb3dzZXJBbmltYXRpb25zTW9kdWxlO1xuZXhwb3J0cy5Ob29wQW5pbWF0aW9uc01vZHVsZSA9IE5vb3BBbmltYXRpb25zTW9kdWxlO1xuZXhwb3J0cy7JtUJyb3dzZXJBbmltYXRpb25CdWlsZGVyID0gQnJvd3NlckFuaW1hdGlvbkJ1aWxkZXI7XG5leHBvcnRzLsm1QnJvd3NlckFuaW1hdGlvbkZhY3RvcnkgPSBCcm93c2VyQW5pbWF0aW9uRmFjdG9yeTtcbmV4cG9ydHMuybVBbmltYXRpb25SZW5kZXJlciA9IEFuaW1hdGlvblJlbmRlcmVyO1xuZXhwb3J0cy7JtUFuaW1hdGlvblJlbmRlcmVyRmFjdG9yeSA9IEFuaW1hdGlvblJlbmRlcmVyRmFjdG9yeTtcbmV4cG9ydHMuybVhID0gQmFzZUFuaW1hdGlvblJlbmRlcmVyO1xuZXhwb3J0cy7JtWYgPSBCUk9XU0VSX0FOSU1BVElPTlNfUFJPVklERVJTO1xuZXhwb3J0cy7JtWcgPSBCUk9XU0VSX05PT1BfQU5JTUFUSU9OU19QUk9WSURFUlM7XG5leHBvcnRzLsm1YiA9IEluamVjdGFibGVBbmltYXRpb25FbmdpbmU7XG5leHBvcnRzLsm1ZCA9IGluc3RhbnRpYXRlRGVmYXVsdFN0eWxlTm9ybWFsaXplcjtcbmV4cG9ydHMuybVlID0gaW5zdGFudGlhdGVSZW5kZXJlckZhY3Rvcnk7XG5leHBvcnRzLsm1YyA9IGluc3RhbnRpYXRlU3VwcG9ydGVkQW5pbWF0aW9uRHJpdmVyO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG59KSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGxhdGZvcm0tYnJvd3Nlci1hbmltYXRpb25zLnVtZC5qcy5tYXBcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXIvYnVuZGxlcy9wbGF0Zm9ybS1icm93c2VyLWFuaW1hdGlvbnMudW1kLmpzXG4vLyBtb2R1bGUgaWQgPSAzOFxuLy8gbW9kdWxlIGNodW5rcyA9IDQiLCJtb2R1bGUuZXhwb3J0cyA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKDIpKSg0KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBkZWxlZ2F0ZWQgLi9ub2RlX21vZHVsZXMvcnhqcy9TdWJqZWN0LmpzIGZyb20gZGxsLXJlZmVyZW5jZSAuL3ZlbmRvclxuLy8gbW9kdWxlIGlkID0gMzlcbi8vIG1vZHVsZSBjaHVua3MgPSA0IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwidXJsXCIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwidXJsXCJcbi8vIG1vZHVsZSBpZCA9IDQwXG4vLyBtb2R1bGUgY2h1bmtzID0gNCIsIlwidXNlIHN0cmljdFwiO1xudmFyIEV2ZW50ID0gcmVxdWlyZSgnLi9FdmVudCcpO1xudmFyIE1vdXNlRXZlbnQgPSByZXF1aXJlKCcuL01vdXNlRXZlbnQnKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBFdmVudFRhcmdldDtcblxuZnVuY3Rpb24gRXZlbnRUYXJnZXQoKSB7fVxuXG5FdmVudFRhcmdldC5wcm90b3R5cGUgPSB7XG4gIC8vIFhYWFxuICAvLyBTZWUgV2ViSURMIMKnNC44IGZvciBkZXRhaWxzIG9uIG9iamVjdCBldmVudCBoYW5kbGVyc1xuICAvLyBhbmQgaG93IHRoZXkgc2hvdWxkIGJlaGF2ZS4gIFdlIGFjdHVhbGx5IGhhdmUgdG8gYWNjZXB0XG4gIC8vIGFueSBvYmplY3QgdG8gYWRkRXZlbnRMaXN0ZW5lci4uLiBDYW4ndCB0eXBlIGNoZWNrIGl0LlxuICAvLyBvbiByZWdpc3RyYXRpb24uXG5cbiAgLy8gWFhYOlxuICAvLyBDYXB0dXJpbmcgZXZlbnQgbGlzdGVuZXJzIGFyZSBzb3J0IG9mIHJhcmUuICBJIHRoaW5rIEkgY2FuIG9wdGltaXplXG4gIC8vIHRoZW0gc28gdGhhdCBkaXNwYXRjaEV2ZW50IGNhbiBza2lwIHRoZSBjYXB0dXJpbmcgcGhhc2UgKG9yIG11Y2ggb2ZcbiAgLy8gaXQpLiAgRWFjaCB0aW1lIGEgY2FwdHVyaW5nIGxpc3RlbmVyIGlzIGFkZGVkLCBpbmNyZW1lbnQgYSBmbGFnIG9uXG4gIC8vIHRoZSB0YXJnZXQgbm9kZSBhbmQgZWFjaCBvZiBpdHMgYW5jZXN0b3JzLiAgRGVjcmVtZW50IHdoZW4gcmVtb3ZlZC5cbiAgLy8gQW5kIHVwZGF0ZSB0aGUgY291bnRlciB3aGVuIG5vZGVzIGFyZSBhZGRlZCBhbmQgcmVtb3ZlZCBmcm9tIHRoZVxuICAvLyB0cmVlIGFzIHdlbGwuICBUaGVuLCBpbiBkaXNwYXRjaCBldmVudCwgdGhlIGNhcHR1cmluZyBwaGFzZSBjYW5cbiAgLy8gYWJvcnQgaWYgaXQgc2VlcyBhbnkgbm9kZSB3aXRoIGEgemVybyBjb3VudC5cbiAgYWRkRXZlbnRMaXN0ZW5lcjogZnVuY3Rpb24gYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lciwgY2FwdHVyZSkge1xuICAgIGlmICghbGlzdGVuZXIpIHJldHVybjtcbiAgICBpZiAoY2FwdHVyZSA9PT0gdW5kZWZpbmVkKSBjYXB0dXJlID0gZmFsc2U7XG4gICAgaWYgKCF0aGlzLl9saXN0ZW5lcnMpIHRoaXMuX2xpc3RlbmVycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgaWYgKCF0aGlzLl9saXN0ZW5lcnNbdHlwZV0pIHRoaXMuX2xpc3RlbmVyc1t0eXBlXSA9IFtdO1xuICAgIHZhciBsaXN0ID0gdGhpcy5fbGlzdGVuZXJzW3R5cGVdO1xuXG4gICAgLy8gSWYgdGhpcyBsaXN0ZW5lciBoYXMgYWxyZWFkeSBiZWVuIHJlZ2lzdGVyZWQsIGp1c3QgcmV0dXJuXG4gICAgZm9yKHZhciBpID0gMCwgbiA9IGxpc3QubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICB2YXIgbCA9IGxpc3RbaV07XG4gICAgICBpZiAobC5saXN0ZW5lciA9PT0gbGlzdGVuZXIgJiYgbC5jYXB0dXJlID09PSBjYXB0dXJlKVxuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gQWRkIGFuIG9iamVjdCB0byB0aGUgbGlzdCBvZiBsaXN0ZW5lcnNcbiAgICB2YXIgb2JqID0geyBsaXN0ZW5lcjogbGlzdGVuZXIsIGNhcHR1cmU6IGNhcHR1cmUgfTtcbiAgICBpZiAodHlwZW9mIGxpc3RlbmVyID09PSAnZnVuY3Rpb24nKSBvYmouZiA9IGxpc3RlbmVyO1xuICAgIGxpc3QucHVzaChvYmopO1xuICB9LFxuXG4gIHJlbW92ZUV2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uIHJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXB0dXJlKSB7XG4gICAgaWYgKGNhcHR1cmUgPT09IHVuZGVmaW5lZCkgY2FwdHVyZSA9IGZhbHNlO1xuICAgIGlmICh0aGlzLl9saXN0ZW5lcnMpIHtcbiAgICAgIHZhciBsaXN0ID0gdGhpcy5fbGlzdGVuZXJzW3R5cGVdO1xuICAgICAgaWYgKGxpc3QpIHtcbiAgICAgICAgLy8gRmluZCB0aGUgbGlzdGVuZXIgaW4gdGhlIGxpc3QgYW5kIHJlbW92ZSBpdFxuICAgICAgICBmb3IodmFyIGkgPSAwLCBuID0gbGlzdC5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICB2YXIgbCA9IGxpc3RbaV07XG4gICAgICAgICAgaWYgKGwubGlzdGVuZXIgPT09IGxpc3RlbmVyICYmIGwuY2FwdHVyZSA9PT0gY2FwdHVyZSkge1xuICAgICAgICAgICAgaWYgKGxpc3QubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2xpc3RlbmVyc1t0eXBlXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBsaXN0LnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLy8gVGhpcyBpcyB0aGUgcHVibGljIEFQSSBmb3IgZGlzcGF0Y2hpbmcgdW50cnVzdGVkIHB1YmxpYyBldmVudHMuXG4gIC8vIFNlZSBfZGlzcGF0Y2hFdmVudCBmb3IgdGhlIGltcGxlbWVudGF0aW9uXG4gIGRpc3BhdGNoRXZlbnQ6IGZ1bmN0aW9uIGRpc3BhdGNoRXZlbnQoZXZlbnQpIHtcbiAgICAvLyBEaXNwYXRjaCBhbiB1bnRydXN0ZWQgZXZlbnRcbiAgICByZXR1cm4gdGhpcy5fZGlzcGF0Y2hFdmVudChldmVudCwgZmFsc2UpO1xuICB9LFxuXG4gIC8vXG4gIC8vIFNlZSBET01Db3JlIMKnNC40XG4gIC8vIFhYWDogSSdsbCBwcm9iYWJseSBuZWVkIGFub3RoZXIgdmVyc2lvbiBvZiB0aGlzIG1ldGhvZCBmb3JcbiAgLy8gaW50ZXJuYWwgdXNlLCBvbmUgdGhhdCBkb2VzIG5vdCBzZXQgaXNUcnVzdGVkIHRvIGZhbHNlLlxuICAvLyBYWFg6IHNlZSBEb2N1bWVudC5fZGlzcGF0Y2hFdmVudDogcGVyaGFwcyB0aGF0IGFuZCB0aGlzIGNvdWxkXG4gIC8vIGNhbGwgYSBjb21tb24gaW50ZXJuYWwgZnVuY3Rpb24gd2l0aCBkaWZmZXJlbnQgc2V0dGluZ3Mgb2ZcbiAgLy8gYSB0cnVzdGVkIGJvb2xlYW4gYXJndW1lbnRcbiAgLy9cbiAgLy8gWFhYOlxuICAvLyBUaGUgc3BlYyBoYXMgY2hhbmdlZCBpbiBob3cgdG8gZGVhbCB3aXRoIGhhbmRsZXJzIHJlZ2lzdGVyZWRcbiAgLy8gb24gaWRsIG9yIGNvbnRlbnQgYXR0cmlidXRlcyByYXRoZXIgdGhhbiB3aXRoIGFkZEV2ZW50TGlzdGVuZXIuXG4gIC8vIFVzZWQgdG8gc2F5IHRoYXQgdGhleSBhbHdheXMgcmFuIGZpcnN0LiAgVGhhdCdzIGhvdyB3ZWJraXQgZG9lcyBpdFxuICAvLyBTcGVjIG5vdyBzYXlzIHRoYXQgdGhleSBydW4gaW4gYSBwb3NpdGlvbiBkZXRlcm1pbmVkIGJ5XG4gIC8vIHdoZW4gdGhleSB3ZXJlIGZpcnN0IHNldC4gIEZGIGRvZXMgaXQgdGhhdCB3YXkuICBTZWU6XG4gIC8vIGh0dHA6Ly93d3cud2hhdHdnLm9yZy9zcGVjcy93ZWItYXBwcy9jdXJyZW50LXdvcmsvbXVsdGlwYWdlL3dlYmFwcGFwaXMuaHRtbCNldmVudC1oYW5kbGVyc1xuICAvL1xuICBfZGlzcGF0Y2hFdmVudDogZnVuY3Rpb24gX2Rpc3BhdGNoRXZlbnQoZXZlbnQsIHRydXN0ZWQpIHtcbiAgICBpZiAodHlwZW9mIHRydXN0ZWQgIT09ICdib29sZWFuJykgdHJ1c3RlZCA9IGZhbHNlO1xuICAgIGZ1bmN0aW9uIGludm9rZSh0YXJnZXQsIGV2ZW50KSB7XG4gICAgICB2YXIgdHlwZSA9IGV2ZW50LnR5cGUsIHBoYXNlID0gZXZlbnQuZXZlbnRQaGFzZTtcbiAgICAgIGV2ZW50LmN1cnJlbnRUYXJnZXQgPSB0YXJnZXQ7XG5cbiAgICAgIC8vIElmIHRoZXJlIHdhcyBhbiBpbmRpdmlkdWFsIGhhbmRsZXIgZGVmaW5lZCwgaW52b2tlIGl0IGZpcnN0XG4gICAgICAvLyBYWFg6IHNlZSBjb21tZW50IGFib3ZlOiB0aGlzIHNob3VsZG4ndCBhbHdheXMgYmUgZmlyc3QuXG4gICAgICBpZiAocGhhc2UgIT09IEV2ZW50LkNBUFRVUklOR19QSEFTRSAmJlxuICAgICAgICB0YXJnZXQuX2hhbmRsZXJzICYmIHRhcmdldC5faGFuZGxlcnNbdHlwZV0pXG4gICAgICB7XG4gICAgICAgIHZhciBoYW5kbGVyID0gdGFyZ2V0Ll9oYW5kbGVyc1t0eXBlXTtcbiAgICAgICAgdmFyIHJ2O1xuICAgICAgICBpZiAodHlwZW9mIGhhbmRsZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBydj1oYW5kbGVyLmNhbGwoZXZlbnQuY3VycmVudFRhcmdldCwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHZhciBmID0gaGFuZGxlci5oYW5kbGVFdmVudDtcbiAgICAgICAgICBpZiAodHlwZW9mIGYgIT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdoYW5kbGVFdmVudCBwcm9wZXJ0eSBvZiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2V2ZW50IGhhbmRsZXIgb2JqZWN0IGlzJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdub3QgYSBmdW5jdGlvbi4nKTtcbiAgICAgICAgICBydj1mLmNhbGwoaGFuZGxlciwgZXZlbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3dpdGNoKGV2ZW50LnR5cGUpIHtcbiAgICAgICAgY2FzZSAnbW91c2VvdmVyJzpcbiAgICAgICAgICBpZiAocnYgPT09IHRydWUpICAvLyBIaXN0b3JpY2FsIGJhZ2dhZ2VcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2JlZm9yZXVubG9hZCc6XG4gICAgICAgICAgLy8gWFhYOiBldmVudHVhbGx5IHdlIG5lZWQgYSBzcGVjaWFsIGNhc2UgaGVyZVxuICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBpZiAocnYgPT09IGZhbHNlKVxuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBOb3cgaW52b2tlIGxpc3QgbGlzdCBvZiBsaXN0ZW5lcnMgZm9yIHRoaXMgdGFyZ2V0IGFuZCB0eXBlXG4gICAgICB2YXIgbGlzdCA9IHRhcmdldC5fbGlzdGVuZXJzICYmIHRhcmdldC5fbGlzdGVuZXJzW3R5cGVdO1xuICAgICAgaWYgKCFsaXN0KSByZXR1cm47XG4gICAgICBsaXN0ID0gbGlzdC5zbGljZSgpO1xuICAgICAgZm9yKHZhciBpID0gMCwgbiA9IGxpc3QubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgIGlmIChldmVudC5faW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkKSByZXR1cm47XG4gICAgICAgIHZhciBsID0gbGlzdFtpXTtcbiAgICAgICAgaWYgKChwaGFzZSA9PT0gRXZlbnQuQ0FQVFVSSU5HX1BIQVNFICYmICFsLmNhcHR1cmUpIHx8XG4gICAgICAgICAgKHBoYXNlID09PSBFdmVudC5CVUJCTElOR19QSEFTRSAmJiBsLmNhcHR1cmUpKVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBpZiAobC5mKSB7XG4gICAgICAgICAgbC5mLmNhbGwoZXZlbnQuY3VycmVudFRhcmdldCwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHZhciBmbiA9IGwubGlzdGVuZXIuaGFuZGxlRXZlbnQ7XG4gICAgICAgICAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2hhbmRsZUV2ZW50IHByb3BlcnR5IG9mIGV2ZW50IGxpc3RlbmVyIG9iamVjdCBpcyBub3QgYSBmdW5jdGlvbi4nKTtcbiAgICAgICAgICBmbi5jYWxsKGwubGlzdGVuZXIsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghZXZlbnQuX2luaXRpYWxpemVkIHx8IGV2ZW50Ll9kaXNwYXRjaGluZykgdXRpbHMuSW52YWxpZFN0YXRlRXJyb3IoKTtcbiAgICBldmVudC5pc1RydXN0ZWQgPSB0cnVzdGVkO1xuXG4gICAgLy8gQmVnaW4gZGlzcGF0Y2hpbmcgdGhlIGV2ZW50IG5vd1xuICAgIGV2ZW50Ll9kaXNwYXRjaGluZyA9IHRydWU7XG4gICAgZXZlbnQudGFyZ2V0ID0gdGhpcztcblxuICAgIC8vIEJ1aWxkIHRoZSBsaXN0IG9mIHRhcmdldHMgZm9yIHRoZSBjYXB0dXJpbmcgYW5kIGJ1YmJsaW5nIHBoYXNlc1xuICAgIC8vIFhYWDogd2UnbGwgZXZlbnR1YWxseSBoYXZlIHRvIGFkZCBXaW5kb3cgdG8gdGhpcyBsaXN0LlxuICAgIHZhciBhbmNlc3RvcnMgPSBbXTtcbiAgICBmb3IodmFyIG4gPSB0aGlzLnBhcmVudE5vZGU7IG47IG4gPSBuLnBhcmVudE5vZGUpXG4gICAgICBhbmNlc3RvcnMucHVzaChuKTtcblxuICAgIC8vIENhcHR1cmluZyBwaGFzZVxuICAgIGV2ZW50LmV2ZW50UGhhc2UgPSBFdmVudC5DQVBUVVJJTkdfUEhBU0U7XG4gICAgZm9yKHZhciBpID0gYW5jZXN0b3JzLmxlbmd0aC0xOyBpID49IDA7IGktLSkge1xuICAgICAgaW52b2tlKGFuY2VzdG9yc1tpXSwgZXZlbnQpO1xuICAgICAgaWYgKGV2ZW50Ll9wcm9wYWdhdGlvblN0b3BwZWQpIGJyZWFrO1xuICAgIH1cblxuICAgIC8vIEF0IHRhcmdldCBwaGFzZVxuICAgIGlmICghZXZlbnQuX3Byb3BhZ2F0aW9uU3RvcHBlZCkge1xuICAgICAgZXZlbnQuZXZlbnRQaGFzZSA9IEV2ZW50LkFUX1RBUkdFVDtcbiAgICAgIGludm9rZSh0aGlzLCBldmVudCk7XG4gICAgfVxuXG4gICAgLy8gQnViYmxpbmcgcGhhc2VcbiAgICBpZiAoZXZlbnQuYnViYmxlcyAmJiAhZXZlbnQuX3Byb3BhZ2F0aW9uU3RvcHBlZCkge1xuICAgICAgZXZlbnQuZXZlbnRQaGFzZSA9IEV2ZW50LkJVQkJMSU5HX1BIQVNFO1xuICAgICAgZm9yKHZhciBpaSA9IDAsIG5uID0gYW5jZXN0b3JzLmxlbmd0aDsgaWkgPCBubjsgaWkrKykge1xuICAgICAgICBpbnZva2UoYW5jZXN0b3JzW2lpXSwgZXZlbnQpO1xuICAgICAgICBpZiAoZXZlbnQuX3Byb3BhZ2F0aW9uU3RvcHBlZCkgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZXZlbnQuX2Rpc3BhdGNoaW5nID0gZmFsc2U7XG4gICAgZXZlbnQuZXZlbnRQaGFzZSA9IEV2ZW50LkFUX1RBUkdFVDtcbiAgICBldmVudC5jdXJyZW50VGFyZ2V0ID0gbnVsbDtcblxuICAgIC8vIERlYWwgd2l0aCBtb3VzZSBldmVudHMgYW5kIGZpZ3VyZSBvdXQgd2hlblxuICAgIC8vIGEgY2xpY2sgaGFzIGhhcHBlbmVkXG4gICAgaWYgKHRydXN0ZWQgJiYgIWV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQgJiYgZXZlbnQgaW5zdGFuY2VvZiBNb3VzZUV2ZW50KSB7XG4gICAgICBzd2l0Y2goZXZlbnQudHlwZSkge1xuICAgICAgY2FzZSAnbW91c2Vkb3duJzpcbiAgICAgICAgdGhpcy5fYXJtZWQgPSB7XG4gICAgICAgICAgeDogZXZlbnQuY2xpZW50WCxcbiAgICAgICAgICB5OiBldmVudC5jbGllbnRZLFxuICAgICAgICAgIHQ6IGV2ZW50LnRpbWVTdGFtcFxuICAgICAgICB9O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ21vdXNlb3V0JzpcbiAgICAgIGNhc2UgJ21vdXNlb3Zlcic6XG4gICAgICAgIHRoaXMuX2FybWVkID0gbnVsbDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdtb3VzZXVwJzpcbiAgICAgICAgaWYgKHRoaXMuX2lzQ2xpY2soZXZlbnQpKSB0aGlzLl9kb0NsaWNrKGV2ZW50KTtcbiAgICAgICAgdGhpcy5fYXJtZWQgPSBudWxsO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cblxuXG4gICAgcmV0dXJuICFldmVudC5kZWZhdWx0UHJldmVudGVkO1xuICB9LFxuXG4gIC8vIERldGVybWluZSB3aGV0aGVyIGEgY2xpY2sgb2NjdXJyZWRcbiAgLy8gWFhYIFdlIGRvbid0IHN1cHBvcnQgZG91YmxlIGNsaWNrcyBmb3Igbm93XG4gIF9pc0NsaWNrOiBmdW5jdGlvbihldmVudCkge1xuICAgIHJldHVybiAodGhpcy5fYXJtZWQgIT09IG51bGwgJiZcbiAgICAgICAgZXZlbnQudHlwZSA9PT0gJ21vdXNldXAnICYmXG4gICAgICAgIGV2ZW50LmlzVHJ1c3RlZCAmJlxuICAgICAgICBldmVudC5idXR0b24gPT09IDAgJiZcbiAgICAgICAgZXZlbnQudGltZVN0YW1wIC0gdGhpcy5fYXJtZWQudCA8IDEwMDAgJiZcbiAgICAgICAgTWF0aC5hYnMoZXZlbnQuY2xpZW50WCAtIHRoaXMuX2FybWVkLngpIDwgMTAgJiZcbiAgICAgICAgTWF0aC5hYnMoZXZlbnQuY2xpZW50WSAtIHRoaXMuX2FybWVkLlkpIDwgMTApO1xuICB9LFxuXG4gIC8vIENsaWNrcyBhcmUgaGFuZGxlZCBsaWtlIHRoaXM6XG4gIC8vIGh0dHA6Ly93d3cud2hhdHdnLm9yZy9zcGVjcy93ZWItYXBwcy9jdXJyZW50LXdvcmsvbXVsdGlwYWdlL2VsZW1lbnRzLmh0bWwjaW50ZXJhY3RpdmUtY29udGVudC0wXG4gIC8vXG4gIC8vIE5vdGUgdGhhdCB0aGlzIG1ldGhvZCBpcyBzaW1pbGFyIHRvIHRoZSBIVE1MRWxlbWVudC5jbGljaygpIG1ldGhvZFxuICAvLyBUaGUgZXZlbnQgYXJndW1lbnQgbXVzdCBiZSB0aGUgdHJ1c3RlZCBtb3VzZXVwIGV2ZW50XG4gIF9kb0NsaWNrOiBmdW5jdGlvbihldmVudCkge1xuICAgIGlmICh0aGlzLl9jbGlja19pbl9wcm9ncmVzcykgcmV0dXJuO1xuICAgIHRoaXMuX2NsaWNrX2luX3Byb2dyZXNzID0gdHJ1ZTtcblxuICAgIC8vIEZpbmQgdGhlIG5lYXJlc3QgZW5jbG9zaW5nIGVsZW1lbnQgdGhhdCBpcyBhY3RpdmF0YWJsZVxuICAgIC8vIEFuIGVsZW1lbnQgaXMgYWN0aXZhdGFibGUgaWYgaXQgaGFzIGFcbiAgICAvLyBfcG9zdF9jbGlja19hY3RpdmF0aW9uX3N0ZXBzIGhvb2tcbiAgICB2YXIgYWN0aXZhdGVkID0gdGhpcztcbiAgICB3aGlsZShhY3RpdmF0ZWQgJiYgIWFjdGl2YXRlZC5fcG9zdF9jbGlja19hY3RpdmF0aW9uX3N0ZXBzKVxuICAgICAgYWN0aXZhdGVkID0gYWN0aXZhdGVkLnBhcmVudE5vZGU7XG5cbiAgICBpZiAoYWN0aXZhdGVkICYmIGFjdGl2YXRlZC5fcHJlX2NsaWNrX2FjdGl2YXRpb25fc3RlcHMpIHtcbiAgICAgIGFjdGl2YXRlZC5fcHJlX2NsaWNrX2FjdGl2YXRpb25fc3RlcHMoKTtcbiAgICB9XG5cbiAgICB2YXIgY2xpY2sgPSB0aGlzLm93bmVyRG9jdW1lbnQuY3JlYXRlRXZlbnQoJ01vdXNlRXZlbnQnKTtcbiAgICBjbGljay5pbml0TW91c2VFdmVudCgnY2xpY2snLCB0cnVlLCB0cnVlLFxuICAgICAgdGhpcy5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3LCAxLFxuICAgICAgZXZlbnQuc2NyZWVuWCwgZXZlbnQuc2NyZWVuWSxcbiAgICAgIGV2ZW50LmNsaWVudFgsIGV2ZW50LmNsaWVudFksXG4gICAgICBldmVudC5jdHJsS2V5LCBldmVudC5hbHRLZXksXG4gICAgICBldmVudC5zaGlmdEtleSwgZXZlbnQubWV0YUtleSxcbiAgICAgIGV2ZW50LmJ1dHRvbiwgbnVsbCk7XG5cbiAgICB2YXIgcmVzdWx0ID0gdGhpcy5fZGlzcGF0Y2hFdmVudChjbGljaywgdHJ1ZSk7XG5cbiAgICBpZiAoYWN0aXZhdGVkKSB7XG4gICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgIC8vIFRoaXMgaXMgd2hlcmUgaHlwZXJsaW5rcyBnZXQgZm9sbG93ZWQsIGZvciBleGFtcGxlLlxuICAgICAgICBpZiAoYWN0aXZhdGVkLl9wb3N0X2NsaWNrX2FjdGl2YXRpb25fc3RlcHMpXG4gICAgICAgICAgYWN0aXZhdGVkLl9wb3N0X2NsaWNrX2FjdGl2YXRpb25fc3RlcHMoY2xpY2spO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGlmIChhY3RpdmF0ZWQuX2NhbmNlbGxlZF9hY3RpdmF0aW9uX3N0ZXBzKVxuICAgICAgICAgIGFjdGl2YXRlZC5fY2FuY2VsbGVkX2FjdGl2YXRpb25fc3RlcHMoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLy9cbiAgLy8gQW4gZXZlbnQgaGFuZGxlciBpcyBsaWtlIGFuIGV2ZW50IGxpc3RlbmVyLCBidXQgaXQgcmVnaXN0ZXJlZFxuICAvLyBieSBzZXR0aW5nIGFuIElETCBvciBjb250ZW50IGF0dHJpYnV0ZSBsaWtlIG9ubG9hZCBvciBvbmNsaWNrLlxuICAvLyBUaGVyZSBjYW4gb25seSBiZSBvbmUgb2YgdGhlc2UgYXQgYSB0aW1lIGZvciBhbnkgZXZlbnQgdHlwZS5cbiAgLy8gVGhpcyBpcyBhbiBpbnRlcm5hbCBtZXRob2QgZm9yIHRoZSBhdHRyaWJ1dGUgYWNjZXNzb3JzIGFuZFxuICAvLyBjb250ZW50IGF0dHJpYnV0ZSBoYW5kbGVycyB0aGF0IG5lZWQgdG8gcmVnaXN0ZXIgZXZlbnRzIGhhbmRsZXJzLlxuICAvLyBUaGUgdHlwZSBhcmd1bWVudCBpcyB0aGUgc2FtZSBhcyBpbiBhZGRFdmVudExpc3RlbmVyKCkuXG4gIC8vIFRoZSBoYW5kbGVyIGFyZ3VtZW50IGlzIHRoZSBzYW1lIGFzIGxpc3RlbmVycyBpbiBhZGRFdmVudExpc3RlbmVyOlxuICAvLyBpdCBjYW4gYmUgYSBmdW5jdGlvbiBvciBhbiBvYmplY3QuIFBhc3MgbnVsbCB0byByZW1vdmUgYW55IGV4aXN0aW5nXG4gIC8vIGhhbmRsZXIuICBIYW5kbGVycyBhcmUgYWx3YXlzIGludm9rZWQgYmVmb3JlIGFueSBsaXN0ZW5lcnMgb2ZcbiAgLy8gdGhlIHNhbWUgdHlwZS4gIFRoZXkgYXJlIG5vdCBpbnZva2VkIGR1cmluZyB0aGUgY2FwdHVyaW5nIHBoYXNlXG4gIC8vIG9mIGV2ZW50IGRpc3BhdGNoLlxuICAvL1xuICBfc2V0RXZlbnRIYW5kbGVyOiBmdW5jdGlvbiBfc2V0RXZlbnRIYW5kbGVyKHR5cGUsIGhhbmRsZXIpIHtcbiAgICBpZiAoIXRoaXMuX2hhbmRsZXJzKSB0aGlzLl9oYW5kbGVycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5faGFuZGxlcnNbdHlwZV0gPSBoYW5kbGVyO1xuICB9LFxuXG4gIF9nZXRFdmVudEhhbmRsZXI6IGZ1bmN0aW9uIF9nZXRFdmVudEhhbmRsZXIodHlwZSkge1xuICAgIHJldHVybiAodGhpcy5faGFuZGxlcnMgJiYgdGhpcy5faGFuZGxlcnNbdHlwZV0pIHx8IG51bGw7XG4gIH1cblxufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2RvbWluby9saWIvRXZlbnRUYXJnZXQuanNcbi8vIG1vZHVsZSBpZCA9IDQxXG4vLyBtb2R1bGUgY2h1bmtzID0gNCIsIlwidXNlIHN0cmljdFwiO1xudmFyIFVJRXZlbnQgPSByZXF1aXJlKCcuL1VJRXZlbnQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBNb3VzZUV2ZW50O1xuXG5mdW5jdGlvbiBNb3VzZUV2ZW50KCkge1xuICAvLyBKdXN0IHVzZSB0aGUgc3VwZXJjbGFzcyBjb25zdHJ1Y3RvciB0byBpbml0aWFsaXplXG4gIFVJRXZlbnQuY2FsbCh0aGlzKTtcblxuICB0aGlzLnNjcmVlblggPSB0aGlzLnNjcmVlblkgPSB0aGlzLmNsaWVudFggPSB0aGlzLmNsaWVudFkgPSAwO1xuICB0aGlzLmN0cmxLZXkgPSB0aGlzLmFsdEtleSA9IHRoaXMuc2hpZnRLZXkgPSB0aGlzLm1ldGFLZXkgPSBmYWxzZTtcbiAgdGhpcy5idXR0b24gPSAwO1xuICB0aGlzLmJ1dHRvbnMgPSAxO1xuICB0aGlzLnJlbGF0ZWRUYXJnZXQgPSBudWxsO1xufVxuTW91c2VFdmVudC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFVJRXZlbnQucHJvdG90eXBlLCB7XG4gIGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBNb3VzZUV2ZW50IH0sXG4gIGluaXRNb3VzZUV2ZW50OiB7IHZhbHVlOiBmdW5jdGlvbih0eXBlLCBidWJibGVzLCBjYW5jZWxhYmxlLFxuICAgIHZpZXcsIGRldGFpbCxcbiAgICBzY3JlZW5YLCBzY3JlZW5ZLCBjbGllbnRYLCBjbGllbnRZLFxuICAgIGN0cmxLZXksIGFsdEtleSwgc2hpZnRLZXksIG1ldGFLZXksXG4gICAgYnV0dG9uLCByZWxhdGVkVGFyZ2V0KSB7XG5cbiAgICB0aGlzLmluaXRFdmVudCh0eXBlLCBidWJibGVzLCBjYW5jZWxhYmxlLCB2aWV3LCBkZXRhaWwpO1xuICAgIHRoaXMuc2NyZWVuWCA9IHNjcmVlblg7XG4gICAgdGhpcy5zY3JlZW5ZID0gc2NyZWVuWTtcbiAgICB0aGlzLmNsaWVudFggPSBjbGllbnRYO1xuICAgIHRoaXMuY2xpZW50WSA9IGNsaWVudFk7XG4gICAgdGhpcy5jdHJsS2V5ID0gY3RybEtleTtcbiAgICB0aGlzLmFsdEtleSA9IGFsdEtleTtcbiAgICB0aGlzLnNoaWZ0S2V5ID0gc2hpZnRLZXk7XG4gICAgdGhpcy5tZXRhS2V5ID0gbWV0YUtleTtcbiAgICB0aGlzLmJ1dHRvbiA9IGJ1dHRvbjtcbiAgICBzd2l0Y2goYnV0dG9uKSB7XG4gICAgY2FzZSAwOiB0aGlzLmJ1dHRvbnMgPSAxOyBicmVhaztcbiAgICBjYXNlIDE6IHRoaXMuYnV0dG9ucyA9IDQ7IGJyZWFrO1xuICAgIGNhc2UgMjogdGhpcy5idXR0b25zID0gMjsgYnJlYWs7XG4gICAgZGVmYXVsdDogdGhpcy5idXR0b25zID0gMDsgYnJlYWs7XG4gICAgfVxuICAgIHRoaXMucmVsYXRlZFRhcmdldCA9IHJlbGF0ZWRUYXJnZXQ7XG4gIH19LFxuXG4gIGdldE1vZGlmaWVyU3RhdGU6IHsgdmFsdWU6IGZ1bmN0aW9uKGtleSkge1xuICAgIHN3aXRjaChrZXkpIHtcbiAgICBjYXNlIFwiQWx0XCI6IHJldHVybiB0aGlzLmFsdEtleTtcbiAgICBjYXNlIFwiQ29udHJvbFwiOiByZXR1cm4gdGhpcy5jdHJsS2V5O1xuICAgIGNhc2UgXCJTaGlmdFwiOiByZXR1cm4gdGhpcy5zaGlmdEtleTtcbiAgICBjYXNlIFwiTWV0YVwiOiByZXR1cm4gdGhpcy5tZXRhS2V5O1xuICAgIGRlZmF1bHQ6IHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH19XG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2RvbWluby9saWIvTW91c2VFdmVudC5qc1xuLy8gbW9kdWxlIGlkID0gNDJcbi8vIG1vZHVsZSBjaHVua3MgPSA0IiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgRXZlbnQgPSByZXF1aXJlKCcuL0V2ZW50Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gVUlFdmVudDtcblxuZnVuY3Rpb24gVUlFdmVudCgpIHtcbiAgLy8gSnVzdCB1c2UgdGhlIHN1cGVyY2xhc3MgY29uc3RydWN0b3IgdG8gaW5pdGlhbGl6ZVxuICBFdmVudC5jYWxsKHRoaXMpO1xuICB0aGlzLnZpZXcgPSBudWxsOyAvLyBGRiB1c2VzIHRoZSBjdXJyZW50IHdpbmRvd1xuICB0aGlzLmRldGFpbCA9IDA7XG59XG5VSUV2ZW50LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXZlbnQucHJvdG90eXBlLCB7XG4gIGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBVSUV2ZW50IH0sXG4gIGluaXRVSUV2ZW50OiB7IHZhbHVlOiBmdW5jdGlvbih0eXBlLCBidWJibGVzLCBjYW5jZWxhYmxlLCB2aWV3LCBkZXRhaWwpIHtcbiAgICB0aGlzLmluaXRFdmVudCh0eXBlLCBidWJibGVzLCBjYW5jZWxhYmxlKTtcbiAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgIHRoaXMuZGV0YWlsID0gZGV0YWlsO1xuICB9fVxufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9kb21pbm8vbGliL1VJRXZlbnQuanNcbi8vIG1vZHVsZSBpZCA9IDQzXG4vLyBtb2R1bGUgY2h1bmtzID0gNCIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBET01FeGNlcHRpb247XG5cbnZhciBJTkRFWF9TSVpFX0VSUiA9IDE7XG52YXIgSElFUkFSQ0hZX1JFUVVFU1RfRVJSID0gMztcbnZhciBXUk9OR19ET0NVTUVOVF9FUlIgPSA0O1xudmFyIElOVkFMSURfQ0hBUkFDVEVSX0VSUiA9IDU7XG52YXIgTk9fTU9ESUZJQ0FUSU9OX0FMTE9XRURfRVJSID0gNztcbnZhciBOT1RfRk9VTkRfRVJSID0gODtcbnZhciBOT1RfU1VQUE9SVEVEX0VSUiA9IDk7XG52YXIgSU5WQUxJRF9TVEFURV9FUlIgPSAxMTtcbnZhciBTWU5UQVhfRVJSID0gMTI7XG52YXIgSU5WQUxJRF9NT0RJRklDQVRJT05fRVJSID0gMTM7XG52YXIgTkFNRVNQQUNFX0VSUiA9IDE0O1xudmFyIElOVkFMSURfQUNDRVNTX0VSUiA9IDE1O1xudmFyIFRZUEVfTUlTTUFUQ0hfRVJSID0gMTc7XG52YXIgU0VDVVJJVFlfRVJSID0gMTg7XG52YXIgTkVUV09SS19FUlIgPSAxOTtcbnZhciBBQk9SVF9FUlIgPSAyMDtcbnZhciBVUkxfTUlTTUFUQ0hfRVJSID0gMjE7XG52YXIgUVVPVEFfRVhDRUVERURfRVJSID0gMjI7XG52YXIgVElNRU9VVF9FUlIgPSAyMztcbnZhciBJTlZBTElEX05PREVfVFlQRV9FUlIgPSAyNDtcbnZhciBEQVRBX0NMT05FX0VSUiA9IDI1O1xuXG4vLyBDb2RlIHRvIG5hbWVcbnZhciBuYW1lcyA9IFtcbiAgbnVsbCwgIC8vIE5vIGVycm9yIHdpdGggY29kZSAwXG4gICdJTkRFWF9TSVpFX0VSUicsXG4gIG51bGwsIC8vIGhpc3RvcmljYWxcbiAgJ0hJRVJBUkNIWV9SRVFVRVNUX0VSUicsXG4gICdXUk9OR19ET0NVTUVOVF9FUlInLFxuICAnSU5WQUxJRF9DSEFSQUNURVJfRVJSJyxcbiAgbnVsbCwgLy8gaGlzdG9yaWNhbFxuICAnTk9fTU9ESUZJQ0FUSU9OX0FMTE9XRURfRVJSJyxcbiAgJ05PVF9GT1VORF9FUlInLFxuICAnTk9UX1NVUFBPUlRFRF9FUlInLFxuICBudWxsLCAvLyBoaXN0b3JpY2FsXG4gICdJTlZBTElEX1NUQVRFX0VSUicsXG4gICdTWU5UQVhfRVJSJyxcbiAgJ0lOVkFMSURfTU9ESUZJQ0FUSU9OX0VSUicsXG4gICdOQU1FU1BBQ0VfRVJSJyxcbiAgJ0lOVkFMSURfQUNDRVNTX0VSUicsXG4gIG51bGwsIC8vIGhpc3RvcmljYWxcbiAgJ1RZUEVfTUlTTUFUQ0hfRVJSJyxcbiAgJ1NFQ1VSSVRZX0VSUicsXG4gICdORVRXT1JLX0VSUicsXG4gICdBQk9SVF9FUlInLFxuICAnVVJMX01JU01BVENIX0VSUicsXG4gICdRVU9UQV9FWENFRURFRF9FUlInLFxuICAnVElNRU9VVF9FUlInLFxuICAnSU5WQUxJRF9OT0RFX1RZUEVfRVJSJyxcbiAgJ0RBVEFfQ0xPTkVfRVJSJyxcbl07XG5cbi8vIENvZGUgdG8gbWVzc2FnZVxuLy8gVGhlc2Ugc3RyaW5ncyBhcmUgZnJvbSB0aGUgMTMgTWF5IDIwMTEgRWRpdG9yJ3MgRHJhZnQgb2YgRE9NIENvcmUuXG4vLyBodHRwOi8vZHZjcy53My5vcmcvaGcvZG9tY29yZS9yYXctZmlsZS90aXAvT3ZlcnZpZXcuaHRtbFxuLy8gQ29weXJpZ2h0IMKpIDIwMTEgVzNDwq4gKE1JVCwgRVJDSU0sIEtlaW8pLCBBbGwgUmlnaHRzIFJlc2VydmVkLlxuLy8gVXNlZCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIFczQyBEb2N1bWVudCBMaWNlbnNlOlxuLy8gaHR0cDovL3d3dy53My5vcmcvQ29uc29ydGl1bS9MZWdhbC8yMDAyL2NvcHlyaWdodC1kb2N1bWVudHMtMjAwMjEyMzFcbnZhciBtZXNzYWdlcyA9IFtcbiAgbnVsbCwgIC8vIE5vIGVycm9yIHdpdGggY29kZSAwXG4gICdJTkRFWF9TSVpFX0VSUiAoMSk6IHRoZSBpbmRleCBpcyBub3QgaW4gdGhlIGFsbG93ZWQgcmFuZ2UnLFxuICBudWxsLFxuICAnSElFUkFSQ0hZX1JFUVVFU1RfRVJSICgzKTogdGhlIG9wZXJhdGlvbiB3b3VsZCB5aWVsZCBhbiBpbmNvcnJlY3Qgbm9kZXMgbW9kZWwnLFxuICAnV1JPTkdfRE9DVU1FTlRfRVJSICg0KTogdGhlIG9iamVjdCBpcyBpbiB0aGUgd3JvbmcgRG9jdW1lbnQsIGEgY2FsbCB0byBpbXBvcnROb2RlIGlzIHJlcXVpcmVkJyxcbiAgJ0lOVkFMSURfQ0hBUkFDVEVSX0VSUiAoNSk6IHRoZSBzdHJpbmcgY29udGFpbnMgaW52YWxpZCBjaGFyYWN0ZXJzJyxcbiAgbnVsbCxcbiAgJ05PX01PRElGSUNBVElPTl9BTExPV0VEX0VSUiAoNyk6IHRoZSBvYmplY3QgY2FuIG5vdCBiZSBtb2RpZmllZCcsXG4gICdOT1RfRk9VTkRfRVJSICg4KTogdGhlIG9iamVjdCBjYW4gbm90IGJlIGZvdW5kIGhlcmUnLFxuICAnTk9UX1NVUFBPUlRFRF9FUlIgKDkpOiB0aGlzIG9wZXJhdGlvbiBpcyBub3Qgc3VwcG9ydGVkJyxcbiAgbnVsbCxcbiAgJ0lOVkFMSURfU1RBVEVfRVJSICgxMSk6IHRoZSBvYmplY3QgaXMgaW4gYW4gaW52YWxpZCBzdGF0ZScsXG4gICdTWU5UQVhfRVJSICgxMik6IHRoZSBzdHJpbmcgZGlkIG5vdCBtYXRjaCB0aGUgZXhwZWN0ZWQgcGF0dGVybicsXG4gICdJTlZBTElEX01PRElGSUNBVElPTl9FUlIgKDEzKTogdGhlIG9iamVjdCBjYW4gbm90IGJlIG1vZGlmaWVkIGluIHRoaXMgd2F5JyxcbiAgJ05BTUVTUEFDRV9FUlIgKDE0KTogdGhlIG9wZXJhdGlvbiBpcyBub3QgYWxsb3dlZCBieSBOYW1lc3BhY2VzIGluIFhNTCcsXG4gICdJTlZBTElEX0FDQ0VTU19FUlIgKDE1KTogdGhlIG9iamVjdCBkb2VzIG5vdCBzdXBwb3J0IHRoZSBvcGVyYXRpb24gb3IgYXJndW1lbnQnLFxuICBudWxsLFxuICAnVFlQRV9NSVNNQVRDSF9FUlIgKDE3KTogdGhlIHR5cGUgb2YgdGhlIG9iamVjdCBkb2VzIG5vdCBtYXRjaCB0aGUgZXhwZWN0ZWQgdHlwZScsXG4gICdTRUNVUklUWV9FUlIgKDE4KTogdGhlIG9wZXJhdGlvbiBpcyBpbnNlY3VyZScsXG4gICdORVRXT1JLX0VSUiAoMTkpOiBhIG5ldHdvcmsgZXJyb3Igb2NjdXJyZWQnLFxuICAnQUJPUlRfRVJSICgyMCk6IHRoZSB1c2VyIGFib3J0ZWQgYW4gb3BlcmF0aW9uJyxcbiAgJ1VSTF9NSVNNQVRDSF9FUlIgKDIxKTogdGhlIGdpdmVuIFVSTCBkb2VzIG5vdCBtYXRjaCBhbm90aGVyIFVSTCcsXG4gICdRVU9UQV9FWENFRURFRF9FUlIgKDIyKTogdGhlIHF1b3RhIGhhcyBiZWVuIGV4Y2VlZGVkJyxcbiAgJ1RJTUVPVVRfRVJSICgyMyk6IGEgdGltZW91dCBvY2N1cnJlZCcsXG4gICdJTlZBTElEX05PREVfVFlQRV9FUlIgKDI0KTogdGhlIHN1cHBsaWVkIG5vZGUgaXMgaW52YWxpZCBvciBoYXMgYW4gaW52YWxpZCBhbmNlc3RvciBmb3IgdGhpcyBvcGVyYXRpb24nLFxuICAnREFUQV9DTE9ORV9FUlIgKDI1KTogdGhlIG9iamVjdCBjYW4gbm90IGJlIGNsb25lZC4nXG5dO1xuXG4vLyBOYW1lIHRvIGNvZGVcbnZhciBjb25zdGFudHMgPSB7XG4gIElOREVYX1NJWkVfRVJSOiBJTkRFWF9TSVpFX0VSUixcbiAgRE9NU1RSSU5HX1NJWkVfRVJSOiAyLCAvLyBoaXN0b3JpY2FsXG4gIEhJRVJBUkNIWV9SRVFVRVNUX0VSUjogSElFUkFSQ0hZX1JFUVVFU1RfRVJSLFxuICBXUk9OR19ET0NVTUVOVF9FUlI6IFdST05HX0RPQ1VNRU5UX0VSUixcbiAgSU5WQUxJRF9DSEFSQUNURVJfRVJSOiBJTlZBTElEX0NIQVJBQ1RFUl9FUlIsXG4gIE5PX0RBVEFfQUxMT1dFRF9FUlI6IDYsIC8vIGhpc3RvcmljYWxcbiAgTk9fTU9ESUZJQ0FUSU9OX0FMTE9XRURfRVJSOiBOT19NT0RJRklDQVRJT05fQUxMT1dFRF9FUlIsXG4gIE5PVF9GT1VORF9FUlI6IE5PVF9GT1VORF9FUlIsXG4gIE5PVF9TVVBQT1JURURfRVJSOiBOT1RfU1VQUE9SVEVEX0VSUixcbiAgSU5VU0VfQVRUUklCVVRFX0VSUjogMTAsIC8vIGhpc3RvcmljYWxcbiAgSU5WQUxJRF9TVEFURV9FUlI6IElOVkFMSURfU1RBVEVfRVJSLFxuICBTWU5UQVhfRVJSOiBTWU5UQVhfRVJSLFxuICBJTlZBTElEX01PRElGSUNBVElPTl9FUlI6IElOVkFMSURfTU9ESUZJQ0FUSU9OX0VSUixcbiAgTkFNRVNQQUNFX0VSUjogTkFNRVNQQUNFX0VSUixcbiAgSU5WQUxJRF9BQ0NFU1NfRVJSOiBJTlZBTElEX0FDQ0VTU19FUlIsXG4gIFZBTElEQVRJT05fRVJSOiAxNiwgLy8gaGlzdG9yaWNhbFxuICBUWVBFX01JU01BVENIX0VSUjogVFlQRV9NSVNNQVRDSF9FUlIsXG4gIFNFQ1VSSVRZX0VSUjogU0VDVVJJVFlfRVJSLFxuICBORVRXT1JLX0VSUjogTkVUV09SS19FUlIsXG4gIEFCT1JUX0VSUjogQUJPUlRfRVJSLFxuICBVUkxfTUlTTUFUQ0hfRVJSOiBVUkxfTUlTTUFUQ0hfRVJSLFxuICBRVU9UQV9FWENFRURFRF9FUlI6IFFVT1RBX0VYQ0VFREVEX0VSUixcbiAgVElNRU9VVF9FUlI6IFRJTUVPVVRfRVJSLFxuICBJTlZBTElEX05PREVfVFlQRV9FUlI6IElOVkFMSURfTk9ERV9UWVBFX0VSUixcbiAgREFUQV9DTE9ORV9FUlI6IERBVEFfQ0xPTkVfRVJSXG59O1xuXG5mdW5jdGlvbiBET01FeGNlcHRpb24oY29kZSkge1xuICBFcnJvci5jYWxsKHRoaXMpO1xuICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCB0aGlzLmNvbnN0cnVjdG9yKTtcbiAgdGhpcy5jb2RlID0gY29kZTtcbiAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZXNbY29kZV07XG4gIHRoaXMubmFtZSA9IG5hbWVzW2NvZGVdO1xufVxuRE9NRXhjZXB0aW9uLnByb3RvdHlwZS5fX3Byb3RvX18gPSBFcnJvci5wcm90b3R5cGU7XG5cbi8vIEluaXRpYWxpemUgdGhlIGNvbnN0YW50cyBvbiBET01FeGNlcHRpb24gYW5kIERPTUV4Y2VwdGlvbi5wcm90b3R5cGVcbmZvcih2YXIgYyBpbiBjb25zdGFudHMpIHtcbiAgdmFyIHYgPSB7IHZhbHVlOiBjb25zdGFudHNbY10gfTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERPTUV4Y2VwdGlvbiwgYywgdik7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShET01FeGNlcHRpb24ucHJvdG90eXBlLCBjLCB2KTtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2RvbWluby9saWIvRE9NRXhjZXB0aW9uLmpzXG4vLyBtb2R1bGUgaWQgPSA0NFxuLy8gbW9kdWxlIGNodW5rcyA9IDQiLCIvKlxuICogVGhpcyBmaWxlIGRlZmluZXMgRG9taW5vIGJlaGF2aW91ciB0aGF0IGNhbiBiZSBleHRlcm5hbGx5IGNvbmZpZ3VyZWQuXG4gKiBUbyBjaGFuZ2UgdGhlc2Ugc2V0dGluZ3MsIHNldCB0aGUgcmVsZXZhbnQgZ2xvYmFsIHByb3BlcnR5ICpiZWZvcmUqXG4gKiB5b3UgY2FsbCBgcmVxdWlyZShcImRvbWlub1wiKWAuXG4gKi9cblxuZXhwb3J0cy5pc0FwaVdyaXRhYmxlID0gIWdsb2JhbC5fX2RvbWlub19mcm96ZW5fXztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2RvbWluby9saWIvY29uZmlnLmpzXG4vLyBtb2R1bGUgaWQgPSA0NVxuLy8gbW9kdWxlIGNodW5rcyA9IDQiLCJcInVzZSBzdHJpY3RcIjtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcblxuZXhwb3J0cy5wcm9wZXJ0eSA9IGZ1bmN0aW9uKGF0dHIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXR0ci50eXBlKSkge1xuICAgIHZhciB2YWxpZCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgYXR0ci50eXBlLmZvckVhY2goZnVuY3Rpb24odmFsKSB7XG4gICAgICB2YWxpZFt2YWwudmFsdWUgfHwgdmFsXSA9IHZhbC5hbGlhcyB8fCB2YWw7XG4gICAgfSk7XG4gICAgdmFyIG1pc3NpbmdWYWx1ZURlZmF1bHQgPSBhdHRyLm1pc3Npbmc7XG4gICAgaWYgKG1pc3NpbmdWYWx1ZURlZmF1bHQ9PT11bmRlZmluZWQpIHsgbWlzc2luZ1ZhbHVlRGVmYXVsdCA9IG51bGw7IH1cbiAgICB2YXIgaW52YWxpZFZhbHVlRGVmYXVsdCA9IGF0dHIuaW52YWxpZDtcbiAgICBpZiAoaW52YWxpZFZhbHVlRGVmYXVsdD09PXVuZGVmaW5lZCkgeyBpbnZhbGlkVmFsdWVEZWZhdWx0ID0gbWlzc2luZ1ZhbHVlRGVmYXVsdDsgfVxuICAgIHJldHVybiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdiA9IHRoaXMuX2dldGF0dHIoYXR0ci5uYW1lKTtcbiAgICAgICAgaWYgKHYgPT09IG51bGwpIHJldHVybiBtaXNzaW5nVmFsdWVEZWZhdWx0O1xuXG4gICAgICAgIHYgPSB2YWxpZFt2LnRvTG93ZXJDYXNlKCldO1xuICAgICAgICBpZiAodiAhPT0gdW5kZWZpbmVkKSByZXR1cm4gdjtcbiAgICAgICAgaWYgKGludmFsaWRWYWx1ZURlZmF1bHQgIT09IG51bGwpIHJldHVybiBpbnZhbGlkVmFsdWVEZWZhdWx0O1xuICAgICAgICByZXR1cm4gdjtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgdGhpcy5fc2V0YXR0cihhdHRyLm5hbWUsIHYpO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgZWxzZSBpZiAoYXR0ci50eXBlID09PSBCb29sZWFuKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhhc0F0dHJpYnV0ZShhdHRyLm5hbWUpO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24odikge1xuICAgICAgICBpZiAodikge1xuICAgICAgICAgIHRoaXMuX3NldGF0dHIoYXR0ci5uYW1lLCAnJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgdGhpcy5yZW1vdmVBdHRyaWJ1dGUoYXR0ci5uYW1lKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cbiAgZWxzZSBpZiAoYXR0ci50eXBlID09PSBOdW1iZXIgfHxcbiAgICAgICAgICAgYXR0ci50eXBlID09PSBcImxvbmdcIiB8fFxuICAgICAgICAgICBhdHRyLnR5cGUgPT09IFwidW5zaWduZWQgbG9uZ1wiIHx8XG4gICAgICAgICAgIGF0dHIudHlwZSA9PT0gXCJsaW1pdGVkIHVuc2lnbmVkIGxvbmcgd2l0aCBmYWxsYmFja1wiKSB7XG4gICAgcmV0dXJuIG51bWJlclByb3BEZXNjKGF0dHIpO1xuICB9XG4gIGVsc2UgaWYgKCFhdHRyLnR5cGUgfHwgYXR0ci50eXBlID09PSBTdHJpbmcpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuX2dldGF0dHIoYXR0ci5uYW1lKSB8fCAnJzsgfSxcbiAgICAgIHNldDogZnVuY3Rpb24odikge1xuICAgICAgICBpZiAoYXR0ci50cmVhdE51bGxBc0VtcHR5U3RyaW5nICYmIHYgPT09IG51bGwpIHsgdiA9ICcnOyB9XG4gICAgICAgIHRoaXMuX3NldGF0dHIoYXR0ci5uYW1lLCB2KTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIGVsc2UgaWYgKHR5cGVvZiBhdHRyLnR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gYXR0ci50eXBlKGF0dHIubmFtZSwgYXR0cik7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGF0dHJpYnV0ZSBkZWZpbml0aW9uJyk7XG59O1xuXG4vLyBTZWUgaHR0cDovL3d3dy53aGF0d2cub3JnL3NwZWNzL3dlYi1hcHBzL2N1cnJlbnQtd29yay8jcmVmbGVjdFxuLy9cbi8vIGRlZnZhbCBpcyB0aGUgZGVmYXVsdCB2YWx1ZS4gSWYgaXQgaXMgYSBmdW5jdGlvbiwgdGhlbiB0aGF0IGZ1bmN0aW9uXG4vLyB3aWxsIGJlIGludm9rZWQgYXMgYSBtZXRob2Qgb2YgdGhlIGVsZW1lbnQgdG8gb2J0YWluIHRoZSBkZWZhdWx0LlxuLy8gSWYgbm8gZGVmYXVsdCBpcyBzcGVjaWZpZWQgZm9yIGEgZ2l2ZW4gYXR0cmlidXRlLCB0aGVuIHRoZSBkZWZhdWx0XG4vLyBkZXBlbmRzIG9uIHRoZSB0eXBlIG9mIHRoZSBhdHRyaWJ1dGUsIGJ1dCBzaW5jZSB0aGlzIGZ1bmN0aW9uIGhhbmRsZXNcbi8vIDQgaW50ZWdlciBjYXNlcywgeW91IG11c3Qgc3BlY2lmeSB0aGUgZGVmYXVsdCB2YWx1ZSBpbiBlYWNoIGNhbGxcbi8vXG4vLyBtaW4gYW5kIG1heCBkZWZpbmUgYSB2YWxpZCByYW5nZSBmb3IgZ2V0dGluZyB0aGUgYXR0cmlidXRlLlxuLy9cbi8vIHNldG1pbiBkZWZpbmVzIGEgbWluaW11bSB2YWx1ZSB3aGVuIHNldHRpbmcuICBJZiB0aGUgdmFsdWUgaXMgbGVzc1xuLy8gdGhhbiB0aGF0LCB0aGVuIHRocm93IElOREVYX1NJWkVfRVJSLlxuLy9cbi8vIENvbnZlbmllbnRseSwgSmF2YVNjcmlwdCdzIHBhcnNlSW50IGZ1bmN0aW9uIGFwcGVhcnMgdG8gYmVcbi8vIGNvbXBhdGlibGUgd2l0aCBIVE1MJ3MgJ3J1bGVzIGZvciBwYXJzaW5nIGludGVnZXJzJ1xuZnVuY3Rpb24gbnVtYmVyUHJvcERlc2MoYSkge1xuICB2YXIgZGVmO1xuICBpZih0eXBlb2YgYS5kZWZhdWx0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgZGVmID0gYS5kZWZhdWx0O1xuICB9XG4gIGVsc2UgaWYodHlwZW9mIGEuZGVmYXVsdCA9PT0gJ251bWJlcicpIHtcbiAgICBkZWYgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGEuZGVmYXVsdDsgfTtcbiAgfVxuICBlbHNlIHtcbiAgICBkZWYgPSBmdW5jdGlvbigpIHsgdXRpbHMuYXNzZXJ0KGZhbHNlLCB0eXBlb2YgYS5kZWZhdWx0KTsgfTtcbiAgfVxuICB2YXIgdW5zaWduZWRfbG9uZyA9IChhLnR5cGUgPT09ICd1bnNpZ25lZCBsb25nJyk7XG4gIHZhciBzaWduZWRfbG9uZyA9IChhLnR5cGUgPT09ICdsb25nJyk7XG4gIHZhciB1bnNpZ25lZF9mYWxsYmFjayA9IChhLnR5cGUgPT09ICdsaW1pdGVkIHVuc2lnbmVkIGxvbmcgd2l0aCBmYWxsYmFjaycpO1xuICB2YXIgbWluID0gYS5taW4sIG1heCA9IGEubWF4LCBzZXRtaW4gPSBhLnNldG1pbjtcbiAgaWYgKG1pbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKHVuc2lnbmVkX2xvbmcpIG1pbiA9IDA7XG4gICAgaWYgKHNpZ25lZF9sb25nKSBtaW4gPSAtMHg4MDAwMDAwMDtcbiAgICBpZiAodW5zaWduZWRfZmFsbGJhY2spIG1pbiA9IDE7XG4gIH1cbiAgaWYgKG1heCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKHVuc2lnbmVkX2xvbmcgfHwgc2lnbmVkX2xvbmcgfHwgdW5zaWduZWRfZmFsbGJhY2spIG1heCA9IDB4N0ZGRkZGRkY7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgdiA9IHRoaXMuX2dldGF0dHIoYS5uYW1lKTtcbiAgICAgIHZhciBuID0gYS5mbG9hdCA/IHBhcnNlRmxvYXQodikgOiBwYXJzZUludCh2LCAxMCk7XG4gICAgICBpZiAodiA9PT0gbnVsbCB8fCAhaXNGaW5pdGUobikgfHwgKG1pbiAhPT0gdW5kZWZpbmVkICYmIG4gPCBtaW4pIHx8IChtYXggIT09IHVuZGVmaW5lZCAmJiBuID4gbWF4KSkge1xuICAgICAgICByZXR1cm4gZGVmLmNhbGwodGhpcyk7XG4gICAgICB9XG4gICAgICBpZiAodW5zaWduZWRfbG9uZyB8fCBzaWduZWRfbG9uZyB8fCB1bnNpZ25lZF9mYWxsYmFjaykge1xuICAgICAgICBpZiAoIS9eWyBcXHRcXG5cXGZcXHJdKlstK10/WzAtOV0vLnRlc3QodikpIHsgcmV0dXJuIGRlZi5jYWxsKHRoaXMpOyB9XG4gICAgICAgIG4gPSBufDA7IC8vIGpzaGludCBpZ25vcmU6bGluZVxuICAgICAgfVxuICAgICAgcmV0dXJuIG47XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uKHYpIHtcbiAgICAgIGlmICghYS5mbG9hdCkgeyB2ID0gTWF0aC5mbG9vcih2KTsgfVxuICAgICAgaWYgKHNldG1pbiAhPT0gdW5kZWZpbmVkICYmIHYgPCBzZXRtaW4pIHtcbiAgICAgICAgdXRpbHMuSW5kZXhTaXplRXJyb3IoYS5uYW1lICsgJyBzZXQgdG8gJyArIHYpO1xuICAgICAgfVxuICAgICAgaWYgKHVuc2lnbmVkX2xvbmcpIHtcbiAgICAgICAgdiA9ICh2IDwgMCB8fCB2ID4gMHg3RkZGRkZGRikgPyBkZWYuY2FsbCh0aGlzKSA6XG4gICAgICAgICAgKHZ8MCk7ICAvLyBqc2hpbnQgaWdub3JlOmxpbmVcbiAgICAgIH0gZWxzZSBpZiAodW5zaWduZWRfZmFsbGJhY2spIHtcbiAgICAgICAgdiA9ICh2IDwgMSB8fCB2ID4gMHg3RkZGRkZGRikgPyBkZWYuY2FsbCh0aGlzKSA6XG4gICAgICAgICAgKHZ8MCk7IC8vIGpzaGludCBpZ25vcmU6bGluZVxuICAgICAgfSBlbHNlIGlmIChzaWduZWRfbG9uZykge1xuICAgICAgICB2ID0gKHYgPCAtMHg4MDAwMDAwMCB8fCB2ID4gMHg3RkZGRkZGRikgPyBkZWYuY2FsbCh0aGlzKSA6XG4gICAgICAgICAgKHZ8MCk7IC8vIGpzaGludCBpZ25vcmU6bGluZVxuICAgICAgfVxuICAgICAgdGhpcy5fc2V0YXR0cihhLm5hbWUsIFN0cmluZyh2KSk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBUaGlzIGlzIGEgdXRpbGl0eSBmdW5jdGlvbiBmb3Igc2V0dGluZyB1cCBjaGFuZ2UgaGFuZGxlciBmdW5jdGlvbnNcbi8vIGZvciBhdHRyaWJ1dGVzIGxpa2UgJ2lkJyB0aGF0IHJlcXVpcmUgc3BlY2lhbCBoYW5kbGluZyB3aGVuIHRoZXkgY2hhbmdlLlxuZXhwb3J0cy5yZWdpc3RlckNoYW5nZUhhbmRsZXIgPSBmdW5jdGlvbihjLCBuYW1lLCBoYW5kbGVyKSB7XG4gIHZhciBwID0gYy5wcm90b3R5cGU7XG5cbiAgLy8gSWYgcCBkb2VzIG5vdCBhbHJlYWR5IGhhdmUgaXRzIG93biBfYXR0cmlidXRlQ2hhbmdlSGFuZGxlcnNcbiAgLy8gdGhlbiBjcmVhdGUgb25lIGZvciBpdCwgaW5oZXJpdGluZyBmcm9tIHRoZSBpbmhlcml0ZWRcbiAgLy8gX2F0dHJpYnV0ZUNoYW5nZUhhbmRsZXJzLiBBdCB0aGUgdG9wIChmb3IgdGhlIEVsZW1lbnQgY2xhc3MpIHRoZVxuICAvLyBfYXR0cmlidXRlQ2hhbmdlSGFuZGxlcnMgb2JqZWN0IHdpbGwgYmUgY3JlYXRlZCB3aXRoIGEgbnVsbCBwcm90b3R5cGUuXG4gIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHAsICdfYXR0cmlidXRlQ2hhbmdlSGFuZGxlcnMnKSkge1xuICAgIHAuX2F0dHJpYnV0ZUNoYW5nZUhhbmRsZXJzID1cbiAgICAgIE9iamVjdC5jcmVhdGUocC5fYXR0cmlidXRlQ2hhbmdlSGFuZGxlcnMgfHwgbnVsbCk7XG4gIH1cblxuICBwLl9hdHRyaWJ1dGVDaGFuZ2VIYW5kbGVyc1tuYW1lXSA9IGhhbmRsZXI7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZG9taW5vL2xpYi9hdHRyaWJ1dGVzLmpzXG4vLyBtb2R1bGUgaWQgPSA0NlxuLy8gbW9kdWxlIGNodW5rcyA9IDQiLCJcInVzZSBzdHJpY3RcIjtcbi8vIERPTVRva2VuTGlzdCBpbXBsZW1lbnRhdGlvbiBiYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vUmF5bm9zL0RPTS1zaGltXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gRE9NVG9rZW5MaXN0O1xuXG5mdW5jdGlvbiBET01Ub2tlbkxpc3QoZ2V0dGVyLCBzZXR0ZXIpIHtcbiAgdGhpcy5fZ2V0U3RyaW5nID0gZ2V0dGVyO1xuICB0aGlzLl9zZXRTdHJpbmcgPSBzZXR0ZXI7XG4gIGZpeEluZGV4KHRoaXMsIGdldExpc3QodGhpcykpO1xufVxuXG5ET01Ub2tlbkxpc3QucHJvdG90eXBlID0ge1xuICBpdGVtOiBmdW5jdGlvbihpbmRleCkge1xuICAgIGlmIChpbmRleCA+PSB0aGlzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9nZXRTdHJpbmcoKS5zcGxpdChcIiBcIilbaW5kZXhdO1xuICB9LFxuXG4gIGNvbnRhaW5zOiBmdW5jdGlvbih0b2tlbikge1xuICAgIHRva2VuID0gU3RyaW5nKHRva2VuKTtcbiAgICBoYW5kbGVFcnJvcnModG9rZW4pO1xuICAgIHZhciBsaXN0ID0gZ2V0TGlzdCh0aGlzKTtcbiAgICByZXR1cm4gbGlzdC5pbmRleE9mKHRva2VuKSA+IC0xO1xuICB9LFxuXG4gIGFkZDogZnVuY3Rpb24odG9rZW4pIHtcbiAgICBoYW5kbGVFcnJvcnModG9rZW4pO1xuICAgIHZhciBsaXN0ID0gZ2V0TGlzdCh0aGlzKTtcbiAgICBpZiAobGlzdC5pbmRleE9mKHRva2VuKSA+IC0xKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxpc3QucHVzaCh0b2tlbik7XG4gICAgdGhpcy5fc2V0U3RyaW5nKGxpc3Quam9pbihcIiBcIikudHJpbSgpKTtcbiAgICBmaXhJbmRleCh0aGlzLCBsaXN0KTtcbiAgfSxcblxuICByZW1vdmU6IGZ1bmN0aW9uKHRva2VuKSB7XG4gICAgaGFuZGxlRXJyb3JzKHRva2VuKTtcbiAgICB2YXIgbGlzdCA9IGdldExpc3QodGhpcyk7XG4gICAgdmFyIGluZGV4ID0gbGlzdC5pbmRleE9mKHRva2VuKTtcbiAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgbGlzdC5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgdGhpcy5fc2V0U3RyaW5nKGxpc3Quam9pbihcIiBcIikudHJpbSgpKTtcbiAgICB9XG4gICAgZml4SW5kZXgodGhpcywgbGlzdCk7XG4gIH0sXG5cbiAgdG9nZ2xlOiBmdW5jdGlvbiB0b2dnbGUodG9rZW4pIHtcbiAgICBpZiAodGhpcy5jb250YWlucyh0b2tlbikpIHtcbiAgICAgIHRoaXMucmVtb3ZlKHRva2VuKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aGlzLmFkZCh0b2tlbik7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0sXG5cbiAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9nZXRTdHJpbmcoKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gZml4SW5kZXgoY2xpc3QsIGxpc3QpIHtcbiAgY2xpc3QubGVuZ3RoID0gbGlzdC5sZW5ndGg7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIGNsaXN0W2ldID0gbGlzdFtpXTtcbiAgfVxufVxuXG5mdW5jdGlvbiBoYW5kbGVFcnJvcnModG9rZW4pIHtcbiAgaWYgKHRva2VuID09PSBcIlwiIHx8IHRva2VuID09PSB1bmRlZmluZWQpIHtcbiAgICB1dGlscy5TeW50YXhFcnJvcigpO1xuICB9XG4gIGlmICh0b2tlbi5pbmRleE9mKFwiIFwiKSA+IC0xKSB7XG4gICAgdXRpbHMuSW52YWxpZENoYXJhY3RlckVycm9yKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0TGlzdChjbGlzdCkge1xuICB2YXIgc3RyID0gY2xpc3QuX2dldFN0cmluZygpO1xuICBpZiAoc3RyID09PSBcIlwiKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIGVsc2Uge1xuICAgIHJldHVybiBzdHIuc3BsaXQoXCIgXCIpO1xuICB9XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9kb21pbm8vbGliL0RPTVRva2VuTGlzdC5qc1xuLy8gbW9kdWxlIGlkID0gNDdcbi8vIG1vZHVsZSBjaHVua3MgPSA0IiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgTm9kZSA9IHJlcXVpcmUoJy4vTm9kZScpO1xuXG52YXIgTm9uRG9jdW1lbnRUeXBlQ2hpbGROb2RlID0ge1xuXG4gIG5leHRFbGVtZW50U2libGluZzogeyBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLnBhcmVudE5vZGUpIHtcbiAgICAgIHZhciBzaWJzID0gdGhpcy5wYXJlbnROb2RlLmNoaWxkTm9kZXM7XG4gICAgICBmb3IodmFyIGkgPSB0aGlzLmluZGV4KzEsIG4gPSBzaWJzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICBpZiAoc2lic1tpXS5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUpIHJldHVybiBzaWJzW2ldO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfX0sXG5cbiAgcHJldmlvdXNFbGVtZW50U2libGluZzogeyBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLnBhcmVudE5vZGUpIHtcbiAgICAgIHZhciBzaWJzID0gdGhpcy5wYXJlbnROb2RlLmNoaWxkTm9kZXM7XG4gICAgICBmb3IodmFyIGkgPSB0aGlzLmluZGV4LTE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGlmIChzaWJzW2ldLm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSkgcmV0dXJuIHNpYnNbaV07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9fVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE5vbkRvY3VtZW50VHlwZUNoaWxkTm9kZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2RvbWluby9saWIvTm9uRG9jdW1lbnRUeXBlQ2hpbGROb2RlLmpzXG4vLyBtb2R1bGUgaWQgPSA0OFxuLy8gbW9kdWxlIGNodW5rcyA9IDQiLCJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gVGV4dDtcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xudmFyIE5vZGUgPSByZXF1aXJlKCcuL05vZGUnKTtcbnZhciBDaGFyYWN0ZXJEYXRhID0gcmVxdWlyZSgnLi9DaGFyYWN0ZXJEYXRhJyk7XG5cbmZ1bmN0aW9uIFRleHQoZG9jLCBkYXRhKSB7XG4gIHRoaXMubm9kZVR5cGUgPSBOb2RlLlRFWFRfTk9ERTtcbiAgdGhpcy5vd25lckRvY3VtZW50ID0gZG9jO1xuICB0aGlzLl9kYXRhID0gZGF0YTtcbiAgdGhpcy5faW5kZXggPSB1bmRlZmluZWQ7XG59XG5cbnZhciBub2RlVmFsdWUgPSB7XG4gIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLl9kYXRhOyB9LFxuICBzZXQ6IGZ1bmN0aW9uKHYpIHtcbiAgICBpZiAodiA9PT0gdGhpcy5fZGF0YSkgcmV0dXJuO1xuICAgIHRoaXMuX2RhdGEgPSB2O1xuICAgIGlmICh0aGlzLnJvb3RlZClcbiAgICAgIHRoaXMub3duZXJEb2N1bWVudC5tdXRhdGVWYWx1ZSh0aGlzKTtcbiAgICBpZiAodGhpcy5wYXJlbnROb2RlICYmXG4gICAgICB0aGlzLnBhcmVudE5vZGUuX3RleHRjaGFuZ2Vob29rKVxuICAgICAgdGhpcy5wYXJlbnROb2RlLl90ZXh0Y2hhbmdlaG9vayh0aGlzKTtcbiAgfVxufTtcblxuVGV4dC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKENoYXJhY3RlckRhdGEucHJvdG90eXBlLCB7XG4gIG5vZGVOYW1lOiB7IHZhbHVlOiBcIiN0ZXh0XCIgfSxcbiAgLy8gVGhlc2UgdGhyZWUgYXR0cmlidXRlcyBhcmUgYWxsIHRoZSBzYW1lLlxuICAvLyBUaGUgZGF0YSBhdHRyaWJ1dGUgaGFzIGEgW1RyZWF0TnVsbEFzPUVtcHR5U3RyaW5nXSBidXQgd2UnbGxcbiAgLy8gaW1wbGVtZW50IHRoYXQgYXQgdGhlIGludGVyZmFjZSBsZXZlbFxuICBub2RlVmFsdWU6IG5vZGVWYWx1ZSxcbiAgdGV4dENvbnRlbnQ6IG5vZGVWYWx1ZSxcbiAgZGF0YTogbm9kZVZhbHVlLFxuXG4gIHNwbGl0VGV4dDogeyB2YWx1ZTogZnVuY3Rpb24gc3BsaXRUZXh0KG9mZnNldCkge1xuICAgIGlmIChvZmZzZXQgPiB0aGlzLl9kYXRhLmxlbmd0aCB8fCBvZmZzZXQgPCAwKSB1dGlscy5JbmRleFNpemVFcnJvcigpO1xuXG4gICAgdmFyIG5ld2RhdGEgPSB0aGlzLl9kYXRhLnN1YnN0cmluZyhvZmZzZXQpLFxuICAgICAgbmV3bm9kZSA9IHRoaXMub3duZXJEb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShuZXdkYXRhKTtcbiAgICB0aGlzLmRhdGEgPSB0aGlzLmRhdGEuc3Vic3RyaW5nKDAsIG9mZnNldCk7XG5cbiAgICB2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnROb2RlO1xuICAgIGlmIChwYXJlbnQgIT09IG51bGwpXG4gICAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKG5ld25vZGUsIHRoaXMubmV4dFNpYmxpbmcpO1xuXG4gICAgcmV0dXJuIG5ld25vZGU7XG4gIH19LFxuXG4gIC8vIFhYWFxuICAvLyB3aG9sZVRleHQgYW5kIHJlcGxhY2VXaG9sZVRleHQoKSBhcmUgbm90IGltcGxlbWVudGVkIHlldCBiZWNhdXNlXG4gIC8vIHRoZSBET01Db3JlIHNwZWNpZmljYXRpb24gaXMgY29uc2lkZXJpbmcgcmVtb3Zpbmcgb3IgYWx0ZXJpbmcgdGhlbS5cbiAgd2hvbGVUZXh0OiB7Z2V0OiB1dGlscy5ueWkgfSxcbiAgcmVwbGFjZVdob2xlVGV4dDogeyB2YWx1ZTogdXRpbHMubnlpIH0sXG5cbiAgLy8gVXRpbGl0eSBtZXRob2RzXG4gIGNsb25lOiB7IHZhbHVlOiBmdW5jdGlvbiBjbG9uZSgpIHtcbiAgICByZXR1cm4gbmV3IFRleHQodGhpcy5vd25lckRvY3VtZW50LCB0aGlzLl9kYXRhKTtcbiAgfX0sXG5cbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZG9taW5vL2xpYi9UZXh0LmpzXG4vLyBtb2R1bGUgaWQgPSA0OVxuLy8gbW9kdWxlIGNodW5rcyA9IDQiLCJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gTGVhZjtcblxudmFyIE5vZGUgPSByZXF1aXJlKCcuL05vZGUnKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbnZhciBIaWVyYXJjaHlSZXF1ZXN0RXJyb3IgPSB1dGlscy5IaWVyYXJjaHlSZXF1ZXN0RXJyb3I7XG52YXIgTm90Rm91bmRFcnJvciA9IHV0aWxzLk5vdEZvdW5kRXJyb3I7XG5cbi8vIFRoaXMgY2xhc3MgZGVmaW5lcyBjb21tb24gZnVuY3Rpb25hbGl0eSBmb3Igbm9kZSBzdWJ0eXBlcyB0aGF0XG4vLyBjYW4gbmV2ZXIgaGF2ZSBjaGlsZHJlblxuZnVuY3Rpb24gTGVhZigpIHtcbn1cblxuTGVhZi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKE5vZGUucHJvdG90eXBlLCB7XG4gIGhhc0NoaWxkTm9kZXM6IHsgdmFsdWU6IGZ1bmN0aW9uKCkgeyByZXR1cm4gZmFsc2U7IH19LFxuICBmaXJzdENoaWxkOiB7IHZhbHVlOiBudWxsIH0sXG4gIGxhc3RDaGlsZDogeyB2YWx1ZTogbnVsbCB9LFxuICBpbnNlcnRCZWZvcmU6IHsgdmFsdWU6IGZ1bmN0aW9uKG5vZGUsIGNoaWxkKSB7XG4gICAgaWYgKCFub2RlLm5vZGVUeXBlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdub3QgYSBub2RlJyk7XG4gICAgSGllcmFyY2h5UmVxdWVzdEVycm9yKCk7XG4gIH19LFxuICByZXBsYWNlQ2hpbGQ6IHsgdmFsdWU6IGZ1bmN0aW9uKG5vZGUsIGNoaWxkKSB7XG4gICAgaWYgKCFub2RlLm5vZGVUeXBlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdub3QgYSBub2RlJyk7XG4gICAgSGllcmFyY2h5UmVxdWVzdEVycm9yKCk7XG4gIH19LFxuICByZW1vdmVDaGlsZDogeyB2YWx1ZTogZnVuY3Rpb24obm9kZSkge1xuICAgIGlmICghbm9kZS5ub2RlVHlwZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignbm90IGEgbm9kZScpO1xuICAgIE5vdEZvdW5kRXJyb3IoKTtcbiAgfX0sXG4gIGNoaWxkTm9kZXM6IHsgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICBpZiAoIXRoaXMuX2NoaWxkTm9kZXMpIHRoaXMuX2NoaWxkTm9kZXMgPSBbXTtcbiAgICByZXR1cm4gdGhpcy5fY2hpbGROb2RlcztcbiAgfX1cbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZG9taW5vL2xpYi9MZWFmLmpzXG4vLyBtb2R1bGUgaWQgPSA1MFxuLy8gbW9kdWxlIGNodW5rcyA9IDQiLCJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gQ29tbWVudDtcblxudmFyIE5vZGUgPSByZXF1aXJlKCcuL05vZGUnKTtcbnZhciBDaGFyYWN0ZXJEYXRhID0gcmVxdWlyZSgnLi9DaGFyYWN0ZXJEYXRhJyk7XG5cbmZ1bmN0aW9uIENvbW1lbnQoZG9jLCBkYXRhKSB7XG4gIHRoaXMubm9kZVR5cGUgPSBOb2RlLkNPTU1FTlRfTk9ERTtcbiAgdGhpcy5vd25lckRvY3VtZW50ID0gZG9jO1xuICB0aGlzLl9kYXRhID0gZGF0YTtcbiAgdGhpcy5faW5kZXggPSB1bmRlZmluZWQ7XG59XG5cbnZhciBub2RlVmFsdWUgPSB7XG4gIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLl9kYXRhOyB9LFxuICBzZXQ6IGZ1bmN0aW9uKHYpIHtcbiAgICB0aGlzLl9kYXRhID0gdjtcbiAgICBpZiAodGhpcy5yb290ZWQpXG4gICAgICB0aGlzLm93bmVyRG9jdW1lbnQubXV0YXRlVmFsdWUodGhpcyk7XG4gIH1cbn07XG5cbkNvbW1lbnQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShDaGFyYWN0ZXJEYXRhLnByb3RvdHlwZSwge1xuICBub2RlTmFtZTogeyB2YWx1ZTogJyNjb21tZW50JyB9LFxuICBub2RlVmFsdWU6IG5vZGVWYWx1ZSxcbiAgdGV4dENvbnRlbnQ6IG5vZGVWYWx1ZSxcbiAgZGF0YTogbm9kZVZhbHVlLFxuXG4gIC8vIFV0aWxpdHkgbWV0aG9kc1xuICBjbG9uZTogeyB2YWx1ZTogZnVuY3Rpb24gY2xvbmUoKSB7XG4gICAgcmV0dXJuIG5ldyBDb21tZW50KHRoaXMub3duZXJEb2N1bWVudCwgdGhpcy5fZGF0YSk7XG4gIH19LFxufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9kb21pbm8vbGliL0NvbW1lbnQuanNcbi8vIG1vZHVsZSBpZCA9IDUxXG4vLyBtb2R1bGUgY2h1bmtzID0gNCIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSAgRG9jdW1lbnRGcmFnbWVudDtcblxudmFyIE5vZGUgPSByZXF1aXJlKCcuL05vZGUnKTtcbnZhciBOb2RlTGlzdCA9IHJlcXVpcmUoJy4vTm9kZUxpc3QnKTtcbnZhciBFbGVtZW50ID0gcmVxdWlyZSgnLi9FbGVtZW50Jyk7XG52YXIgc2VsZWN0ID0gcmVxdWlyZSgnLi9zZWxlY3QnKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcblxuZnVuY3Rpb24gRG9jdW1lbnRGcmFnbWVudChkb2MpIHtcbiAgdGhpcy5ub2RlVHlwZSA9IE5vZGUuRE9DVU1FTlRfRlJBR01FTlRfTk9ERTtcbiAgdGhpcy5vd25lckRvY3VtZW50ID0gZG9jO1xuICB0aGlzLmNoaWxkTm9kZXMgPSBbXTtcbn1cblxuRG9jdW1lbnRGcmFnbWVudC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKE5vZGUucHJvdG90eXBlLCB7XG4gIG5vZGVOYW1lOiB7IHZhbHVlOiAnI2RvY3VtZW50LWZyYWdtZW50JyB9LFxuICBub2RlVmFsdWU6IHsgXG4gICAgZ2V0OiBmdW5jdGlvbigpIHsgXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24oKSB7fVxuICB9LFxuICAvLyBDb3B5IHRoZSB0ZXh0IGNvbnRlbnQgZ2V0dGVyL3NldHRlciBmcm9tIEVsZW1lbnRcbiAgdGV4dENvbnRlbnQ6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoRWxlbWVudC5wcm90b3R5cGUsICd0ZXh0Q29udGVudCcpLFxuXG4gIHF1ZXJ5U2VsZWN0b3I6IHsgdmFsdWU6IGZ1bmN0aW9uKHNlbGVjdG9yKSB7XG4gICAgLy8gaW1wbGVtZW50IGluIHRlcm1zIG9mIHF1ZXJ5U2VsZWN0b3JBbGxcbiAgICB2YXIgbm9kZXMgPSB0aGlzLnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpO1xuICAgIHJldHVybiBub2Rlcy5sZW5ndGggPyBub2Rlc1swXSA6IG51bGw7XG4gIH19LFxuICBxdWVyeVNlbGVjdG9yQWxsOiB7IHZhbHVlOiBmdW5jdGlvbihzZWxlY3Rvcikge1xuICAgIC8vIGNyZWF0ZSBhIGNvbnRleHRcbiAgICB2YXIgY29udGV4dCA9IE9iamVjdC5jcmVhdGUodGhpcyk7XG4gICAgLy8gYWRkIHNvbWUgbWV0aG9kcyB0byB0aGUgY29udGV4dCBmb3IgemVzdCBpbXBsZW1lbnRhdGlvbiwgd2l0aG91dFxuICAgIC8vIGFkZGluZyB0aGVtIHRvIHRoZSBwdWJsaWMgRG9jdW1lbnRGcmFnbWVudCBBUElcbiAgICBjb250ZXh0LmlzSFRNTCA9IHRydWU7IC8vIGluIEhUTUwgbmFtZXNwYWNlIChjYXNlLWluc2Vuc2l0aXZlIG1hdGNoKVxuICAgIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgPSBFbGVtZW50LnByb3RvdHlwZS5nZXRFbGVtZW50c0J5VGFnTmFtZTtcbiAgICBjb250ZXh0Lm5leHRFbGVtZW50ID1cbiAgICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoRWxlbWVudC5wcm90b3R5cGUsICdmaXJzdEVsZW1lbnRDaGlsZCcpLlxuICAgICAgZ2V0O1xuICAgIC8vIGludm9rZSB6ZXN0XG4gICAgdmFyIG5vZGVzID0gc2VsZWN0KHNlbGVjdG9yLCBjb250ZXh0KTtcbiAgICByZXR1cm4gbm9kZXMuaXRlbSA/IG5vZGVzIDogbmV3IE5vZGVMaXN0KG5vZGVzKTtcbiAgfX0sXG5cbiAgLy8gVXRpbGl0eSBtZXRob2RzXG4gIGNsb25lOiB7IHZhbHVlOiBmdW5jdGlvbiBjbG9uZSgpIHtcbiAgICAgIHJldHVybiBuZXcgRG9jdW1lbnRGcmFnbWVudCh0aGlzLm93bmVyRG9jdW1lbnQpO1xuICB9fSxcbiAgaXNFcXVhbDogeyB2YWx1ZTogZnVuY3Rpb24gaXNFcXVhbChuKSB7XG4gICAgICAvLyBBbnkgdHdvIGRvY3VtZW50IGZyYWdtZW50cyBhcmUgc2hhbGxvd2x5IGVxdWFsLlxuICAgICAgLy8gTm9kZS5pc0VxdWFsTm9kZSgpIHdpbGwgdGVzdCB0aGVpciBjaGlsZHJlbiBmb3IgZXF1YWxpdHlcbiAgICAgIHJldHVybiB0cnVlO1xuICB9fSxcblxuICAvLyBOb24tc3RhbmRhcmQsIGJ1dCB1c2VmdWwgKGdpdGh1YiBpc3N1ZSAjNzMpXG4gIGlubmVySFRNTDoge1xuICAgIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLnNlcmlhbGl6ZSgpOyB9LFxuICAgIHNldDogdXRpbHMubnlpXG4gIH0sXG4gIG91dGVySFRNTDoge1xuICAgIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLnNlcmlhbGl6ZSgpOyB9LFxuICAgIHNldDogdXRpbHMubnlpXG4gIH0sXG5cbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZG9taW5vL2xpYi9Eb2N1bWVudEZyYWdtZW50LmpzXG4vLyBtb2R1bGUgaWQgPSA1MlxuLy8gbW9kdWxlIGNodW5rcyA9IDQiLCJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gUHJvY2Vzc2luZ0luc3RydWN0aW9uO1xuXG52YXIgTm9kZSA9IHJlcXVpcmUoJy4vTm9kZScpO1xudmFyIENoYXJhY3RlckRhdGEgPSByZXF1aXJlKCcuL0NoYXJhY3RlckRhdGEnKTtcblxuZnVuY3Rpb24gUHJvY2Vzc2luZ0luc3RydWN0aW9uKGRvYywgdGFyZ2V0LCBkYXRhKSB7XG4gIHRoaXMubm9kZVR5cGUgPSBOb2RlLlBST0NFU1NJTkdfSU5TVFJVQ1RJT05fTk9ERTtcbiAgdGhpcy5vd25lckRvY3VtZW50ID0gZG9jO1xuICB0aGlzLnRhcmdldCA9IHRhcmdldDtcbiAgdGhpcy5fZGF0YSA9IGRhdGE7XG59XG5cbnZhciBub2RlVmFsdWUgPSB7XG4gIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLl9kYXRhOyB9LFxuICBzZXQ6IGZ1bmN0aW9uKHYpIHtcbiAgICB0aGlzLl9kYXRhID0gdjtcbiAgICBpZiAodGhpcy5yb290ZWQpIHRoaXMub3duZXJEb2N1bWVudC5tdXRhdGVWYWx1ZSh0aGlzKTtcbiAgfVxufTtcblxuUHJvY2Vzc2luZ0luc3RydWN0aW9uLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQ2hhcmFjdGVyRGF0YS5wcm90b3R5cGUsIHtcbiAgbm9kZU5hbWU6IHsgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMudGFyZ2V0OyB9fSxcbiAgbm9kZVZhbHVlOiBub2RlVmFsdWUsXG4gIHRleHRDb250ZW50OiBub2RlVmFsdWUsXG4gIGRhdGE6IG5vZGVWYWx1ZSxcblxuICAvLyBVdGlsaXR5IG1ldGhvZHNcbiAgY2xvbmU6IHsgdmFsdWU6IGZ1bmN0aW9uIGNsb25lKCkge1xuICAgICAgcmV0dXJuIG5ldyBQcm9jZXNzaW5nSW5zdHJ1Y3Rpb24odGhpcy5vd25lckRvY3VtZW50LCB0aGlzLnRhcmdldCwgdGhpcy5fZGF0YSk7XG4gIH19LFxuICBpc0VxdWFsOiB7IHZhbHVlOiBmdW5jdGlvbiBpc0VxdWFsKG4pIHtcbiAgICAgIHJldHVybiB0aGlzLnRhcmdldCA9PT0gbi50YXJnZXQgJiYgdGhpcy5fZGF0YSA9PT0gbi5fZGF0YTtcbiAgfX1cblxufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9kb21pbm8vbGliL1Byb2Nlc3NpbmdJbnN0cnVjdGlvbi5qc1xuLy8gbW9kdWxlIGlkID0gNTNcbi8vIG1vZHVsZSBjaHVua3MgPSA0IiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKiBleHBvcnRlZCBOb2RlVHJhdmVyc2FsICovXG52YXIgTm9kZVRyYXZlcnNhbCA9IG1vZHVsZS5leHBvcnRzID0ge1xuICBuZXh0U2tpcHBpbmdDaGlsZHJlbjogbmV4dFNraXBwaW5nQ2hpbGRyZW4sXG4gIG5leHRBbmNlc3RvclNpYmxpbmc6IG5leHRBbmNlc3RvclNpYmxpbmcsXG4gIG5leHQ6IG5leHQsXG4gIHByZXZpb3VzOiBwcmV2aW91cyxcbiAgZGVlcExhc3RDaGlsZDogZGVlcExhc3RDaGlsZFxufTtcblxuLyoqXG4gKiBAYmFzZWQgb24gV2ViS2l0J3MgTm9kZVRyYXZlcnNhbDo6bmV4dFNraXBwaW5nQ2hpbGRyZW5cbiAqIGh0dHBzOi8vdHJhYy53ZWJraXQub3JnL2Jyb3dzZXIvdHJ1bmsvU291cmNlL1dlYkNvcmUvZG9tL05vZGVUcmF2ZXJzYWwuaD9yZXY9MTc5MTQzI0wxMDlcbiAqL1xuZnVuY3Rpb24gbmV4dFNraXBwaW5nQ2hpbGRyZW4obm9kZSwgc3RheVdpdGhpbikge1xuICBpZiAobm9kZSA9PT0gc3RheVdpdGhpbikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmIChub2RlLm5leHRTaWJsaW5nICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIG5vZGUubmV4dFNpYmxpbmc7XG4gIH1cbiAgcmV0dXJuIG5leHRBbmNlc3RvclNpYmxpbmcobm9kZSwgc3RheVdpdGhpbik7XG59XG5cbi8qKlxuICogQGJhc2VkIG9uIFdlYktpdCdzIE5vZGVUcmF2ZXJzYWw6Om5leHRBbmNlc3RvclNpYmxpbmdcbiAqIGh0dHBzOi8vdHJhYy53ZWJraXQub3JnL2Jyb3dzZXIvdHJ1bmsvU291cmNlL1dlYkNvcmUvZG9tL05vZGVUcmF2ZXJzYWwuY3BwP3Jldj0xNzkxNDMjTDkzXG4gKi9cbmZ1bmN0aW9uIG5leHRBbmNlc3RvclNpYmxpbmcobm9kZSwgc3RheVdpdGhpbikge1xuICBmb3IgKG5vZGUgPSBub2RlLnBhcmVudE5vZGU7IG5vZGUgIT09IG51bGw7IG5vZGUgPSBub2RlLnBhcmVudE5vZGUpIHtcbiAgICBpZiAobm9kZSA9PT0gc3RheVdpdGhpbikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmIChub2RlLm5leHRTaWJsaW5nICE9PSBudWxsKSB7XG4gICAgICByZXR1cm4gbm9kZS5uZXh0U2libGluZztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogQGJhc2VkIG9uIFdlYktpdCdzIE5vZGVUcmF2ZXJzYWw6Om5leHRcbiAqIGh0dHBzOi8vdHJhYy53ZWJraXQub3JnL2Jyb3dzZXIvdHJ1bmsvU291cmNlL1dlYkNvcmUvZG9tL05vZGVUcmF2ZXJzYWwuaD9yZXY9MTc5MTQzI0w5OVxuICovXG5mdW5jdGlvbiBuZXh0KG5vZGUsIHN0YXlXaXRoaW4pIHtcbiAgdmFyIG47XG4gIG4gPSBub2RlLmZpcnN0Q2hpbGQ7XG4gIGlmIChuICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIG47XG4gIH1cbiAgaWYgKG5vZGUgPT09IHN0YXlXaXRoaW4pIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBuID0gbm9kZS5uZXh0U2libGluZztcbiAgaWYgKG4gIT09IG51bGwpIHtcbiAgICByZXR1cm4gbjtcbiAgfVxuICByZXR1cm4gbmV4dEFuY2VzdG9yU2libGluZyhub2RlLCBzdGF5V2l0aGluKTtcbn1cblxuLyoqXG4gKiBAYmFzZWQgb24gV2ViS2l0J3MgTm9kZVRyYXZlcnNhbDo6ZGVlcExhc3RDaGlsZFxuICogaHR0cHM6Ly90cmFjLndlYmtpdC5vcmcvYnJvd3Nlci90cnVuay9Tb3VyY2UvV2ViQ29yZS9kb20vTm9kZVRyYXZlcnNhbC5jcHA/cmV2PTE3OTE0MyNMMTE2XG4gKi9cbmZ1bmN0aW9uIGRlZXBMYXN0Q2hpbGQobm9kZSkge1xuICB3aGlsZSAobm9kZS5sYXN0Q2hpbGQpIHtcbiAgICBub2RlID0gbm9kZS5sYXN0Q2hpbGQ7XG4gIH1cbiAgcmV0dXJuIG5vZGU7XG59XG5cbi8qKlxuICogQGJhc2VkIG9uIFdlYktpdCdzIE5vZGVUcmF2ZXJzYWw6OnByZXZpb3VzXG4gKiBodHRwczovL3RyYWMud2Via2l0Lm9yZy9icm93c2VyL3RydW5rL1NvdXJjZS9XZWJDb3JlL2RvbS9Ob2RlVHJhdmVyc2FsLmg/cmV2PTE3OTE0MyNMMTIxXG4gKi9cbmZ1bmN0aW9uIHByZXZpb3VzKG5vZGUsIHN0YXlXaXRoaW4pIHtcbiAgdmFyIHA7XG4gIHAgPSBub2RlLnByZXZpb3VzU2libGluZztcbiAgaWYgKHAgIT09IG51bGwpIHtcbiAgICByZXR1cm4gZGVlcExhc3RDaGlsZChwKTtcbiAgfVxuICBwID0gbm9kZS5wYXJlbnROb2RlO1xuICBpZiAocCA9PT0gc3RheVdpdGhpbikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBwO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZG9taW5vL2xpYi9Ob2RlVHJhdmVyc2FsLmpzXG4vLyBtb2R1bGUgaWQgPSA1NFxuLy8gbW9kdWxlIGNodW5rcyA9IDQiLCJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0ge1xuICBFdmVudDogcmVxdWlyZSgnLi9FdmVudCcpLFxuICBVSUV2ZW50OiByZXF1aXJlKCcuL1VJRXZlbnQnKSxcbiAgTW91c2VFdmVudDogcmVxdWlyZSgnLi9Nb3VzZUV2ZW50JyksXG4gIEN1c3RvbUV2ZW50OiByZXF1aXJlKCcuL0N1c3RvbUV2ZW50Jylcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9kb21pbm8vbGliL2V2ZW50cy5qc1xuLy8gbW9kdWxlIGlkID0gNTVcbi8vIG1vZHVsZSBjaHVua3MgPSA0IiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgVVJMID0gcmVxdWlyZSgnLi9VUkwnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBVUkxVdGlscztcblxuLy8gVGhpcyBpcyBhbiBhYnN0cmFjdCBzdXBlcmNsYXNzIGZvciBMb2NhdGlvbiwgSFRNTEFuY2hvckVsZW1lbnQgYW5kXG4vLyBvdGhlciB0eXBlcyB0aGF0IGhhdmUgdGhlIHN0YW5kYXJkIGNvbXBsZW1lbnQgb2YgXCJVUkwgZGVjb21wb3NpdGlvblxuLy8gSURMIGF0dHJpYnV0ZXNcIi4gIFRoaXMgaXMgbm93IHN0YW5kYXJkaXplZCBhcyBVUkxVdGlscywgc2VlOlxuLy8gaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyN1cmx1dGlsc1xuLy8gU3ViY2xhc3NlcyBtdXN0IGRlZmluZSBhIGdldHRlci9zZXR0ZXIgb24gaHJlZi5cbi8vIFRoZSBnZXR0ZXIgYW5kIHNldHRlciBtZXRob2RzIHBhcnNlIGFuZCByZWJ1aWxkIHRoZSBVUkwgb24gZWFjaFxuLy8gaW52b2NhdGlvbjsgdGhlcmUgaXMgbm8gYXR0ZW1wdCB0byBjYWNoZSB0aGUgdmFsdWUgYW5kIGJlIG1vcmUgZWZmaWNpZW50XG5mdW5jdGlvbiBVUkxVdGlscygpIHt9XG5VUkxVdGlscy5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBVUkxVdGlscyxcblxuICBnZXQgcHJvdG9jb2woKSB7XG4gICAgdmFyIHVybCA9IG5ldyBVUkwodGhpcy5ocmVmKTtcbiAgICBpZiAodXJsLmlzQWJzb2x1dGUoKSkgcmV0dXJuIHVybC5zY2hlbWUgKyBcIjpcIjtcbiAgICBlbHNlIHJldHVybiBcIlwiO1xuICB9LFxuXG4gIGdldCBob3N0KCkge1xuICAgIHZhciB1cmwgPSBuZXcgVVJMKHRoaXMuaHJlZik7XG4gICAgaWYgKHVybC5pc0Fic29sdXRlKCkgJiYgdXJsLmlzQXV0aG9yaXR5QmFzZWQoKSlcbiAgICAgIHJldHVybiB1cmwuaG9zdCArICh1cmwucG9ydCA/IChcIjpcIiArIHVybC5wb3J0KSA6IFwiXCIpO1xuICAgIGVsc2VcbiAgICAgIHJldHVybiBcIlwiO1xuICB9LFxuXG4gIGdldCBob3N0bmFtZSgpIHtcbiAgICB2YXIgdXJsID0gbmV3IFVSTCh0aGlzLmhyZWYpO1xuICAgIGlmICh1cmwuaXNBYnNvbHV0ZSgpICYmIHVybC5pc0F1dGhvcml0eUJhc2VkKCkpXG4gICAgICByZXR1cm4gdXJsLmhvc3Q7XG4gICAgZWxzZVxuICAgICAgcmV0dXJuIFwiXCI7XG4gIH0sXG5cbiAgZ2V0IHBvcnQoKSB7XG4gICAgdmFyIHVybCA9IG5ldyBVUkwodGhpcy5ocmVmKTtcbiAgICBpZiAodXJsLmlzQWJzb2x1dGUoKSAmJiB1cmwuaXNBdXRob3JpdHlCYXNlZCgpICYmIHVybC5wb3J0IT09dW5kZWZpbmVkKVxuICAgICAgcmV0dXJuIHVybC5wb3J0O1xuICAgIGVsc2VcbiAgICAgIHJldHVybiBcIlwiO1xuICB9LFxuXG4gIGdldCBwYXRobmFtZSgpIHtcbiAgICB2YXIgdXJsID0gbmV3IFVSTCh0aGlzLmhyZWYpO1xuICAgIGlmICh1cmwuaXNBYnNvbHV0ZSgpICYmIHVybC5pc0hpZXJhcmNoaWNhbCgpKVxuICAgICAgcmV0dXJuIHVybC5wYXRoO1xuICAgIGVsc2VcbiAgICAgIHJldHVybiBcIlwiO1xuICB9LFxuXG4gIGdldCBzZWFyY2goKSB7XG4gICAgdmFyIHVybCA9IG5ldyBVUkwodGhpcy5ocmVmKTtcbiAgICBpZiAodXJsLmlzQWJzb2x1dGUoKSAmJiB1cmwuaXNIaWVyYXJjaGljYWwoKSAmJiB1cmwucXVlcnkhPT11bmRlZmluZWQpXG4gICAgICByZXR1cm4gXCI/XCIgKyB1cmwucXVlcnk7XG4gICAgZWxzZVxuICAgICAgcmV0dXJuIFwiXCI7XG4gIH0sXG5cbiAgZ2V0IGhhc2goKSB7XG4gICAgdmFyIHVybCA9IG5ldyBVUkwodGhpcy5ocmVmKTtcbiAgICBpZiAodXJsLmlzQWJzb2x1dGUoKSAmJiB1cmwuZnJhZ21lbnQgIT09IHVuZGVmaW5lZClcbiAgICAgIHJldHVybiBcIiNcIiArIHVybC5mcmFnbWVudDtcbiAgICBlbHNlXG4gICAgICByZXR1cm4gXCJcIjtcbiAgfSxcblxuICBnZXQgdXNlcm5hbWUoKSB7XG4gICAgdmFyIHVybCA9IG5ldyBVUkwodGhpcy5ocmVmKTtcbiAgICByZXR1cm4gdXJsLnVzZXJuYW1lIHx8ICcnO1xuICB9LFxuXG4gIGdldCBwYXNzd29yZCgpIHtcbiAgICB2YXIgdXJsID0gbmV3IFVSTCh0aGlzLmhyZWYpO1xuICAgIHJldHVybiB1cmwucGFzc3dvcmQgfHwgJyc7XG4gIH0sXG5cbiAgZ2V0IG9yaWdpbigpIHtcbiAgICB2YXIgdXJsID0gbmV3IFVSTCh0aGlzLmhyZWYpO1xuICAgIHZhciBvcmlnaW5Gb3JQb3J0ID0gZnVuY3Rpb24oZGVmYXVsdFBvcnQpIHtcbiAgICAgIHZhciBvcmlnaW4gPSBbdXJsLnNjaGVtZSwgdXJsLmhvc3QsICt1cmwucG9ydCB8fCBkZWZhdWx0UG9ydF07XG4gICAgICAvLyBYWFggc2hvdWxkIGJlIFwidW5pY29kZSBzZXJpYWxpemF0aW9uXCJcbiAgICAgIHJldHVybiBvcmlnaW5bMF0gKyAnOi8vJyArIG9yaWdpblsxXSArXG4gICAgICAgIChvcmlnaW5bMl0gPT09IGRlZmF1bHRQb3J0ID8gJycgOiAoJzonICsgb3JpZ2luWzJdKSk7XG4gICAgfTtcbiAgICBzd2l0Y2ggKHVybC5zY2hlbWUpIHtcbiAgICBjYXNlICdmdHAnOlxuICAgICAgcmV0dXJuIG9yaWdpbkZvclBvcnQoMjEpO1xuICAgIGNhc2UgJ2dvcGhlcic6XG4gICAgICByZXR1cm4gb3JpZ2luRm9yUG9ydCg3MCk7XG4gICAgY2FzZSAnaHR0cCc6XG4gICAgY2FzZSAnd3MnOlxuICAgICAgcmV0dXJuIG9yaWdpbkZvclBvcnQoODApO1xuICAgIGNhc2UgJ2h0dHBzJzpcbiAgICBjYXNlICd3c3MnOlxuICAgICAgcmV0dXJuIG9yaWdpbkZvclBvcnQoNDQzKTtcbiAgICBkZWZhdWx0OlxuICAgICAgLy8gdGhpcyBpcyB3aGF0IGNocm9tZSBkb2VzXG4gICAgICByZXR1cm4gdXJsLnNjaGVtZSArICc6Ly8nO1xuICAgIH1cbiAgfSxcblxuICAvKlxuICBnZXQgc2VhcmNoUGFyYW1zKCkge1xuICAgIHZhciB1cmwgPSBuZXcgVVJMKHRoaXMuaHJlZik7XG4gICAgLy8gWFhYXG4gIH0sXG4gICovXG5cbiAgc2V0IHByb3RvY29sKHYpIHtcbiAgICB2YXIgb3V0cHV0ID0gdGhpcy5ocmVmO1xuICAgIHZhciB1cmwgPSBuZXcgVVJMKG91dHB1dCk7XG4gICAgaWYgKHVybC5pc0Fic29sdXRlKCkpIHtcbiAgICAgIHYgPSB2LnJlcGxhY2UoLzorJC8sIFwiXCIpO1xuICAgICAgdiA9IHYucmVwbGFjZSgvW14tK1xcLmEtekEtejAtOV0vZywgVVJMLnBlcmNlbnRFbmNvZGUpO1xuICAgICAgaWYgKHYubGVuZ3RoID4gMCkge1xuICAgICAgICB1cmwuc2NoZW1lID0gdjtcbiAgICAgICAgb3V0cHV0ID0gdXJsLnRvU3RyaW5nKCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuaHJlZiA9IG91dHB1dDtcbiAgfSxcblxuICBzZXQgaG9zdCh2KSB7XG4gICAgdmFyIG91dHB1dCA9IHRoaXMuaHJlZjtcbiAgICB2YXIgdXJsID0gbmV3IFVSTChvdXRwdXQpO1xuICAgIGlmICh1cmwuaXNBYnNvbHV0ZSgpICYmIHVybC5pc0F1dGhvcml0eUJhc2VkKCkpIHtcbiAgICAgIHYgPSB2LnJlcGxhY2UoL1teLStcXC5ffiEkJicoKSosOzo9YS16QS16MC05XS9nLCBVUkwucGVyY2VudEVuY29kZSk7XG4gICAgICBpZiAodi5sZW5ndGggPiAwKSB7XG4gICAgICAgIHVybC5ob3N0ID0gdjtcbiAgICAgICAgZGVsZXRlIHVybC5wb3J0O1xuICAgICAgICBvdXRwdXQgPSB1cmwudG9TdHJpbmcoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5ocmVmID0gb3V0cHV0O1xuICB9LFxuXG4gIHNldCBob3N0bmFtZSh2KSB7XG4gICAgdmFyIG91dHB1dCA9IHRoaXMuaHJlZjtcbiAgICB2YXIgdXJsID0gbmV3IFVSTChvdXRwdXQpO1xuICAgIGlmICh1cmwuaXNBYnNvbHV0ZSgpICYmIHVybC5pc0F1dGhvcml0eUJhc2VkKCkpIHtcbiAgICAgIHYgPSB2LnJlcGxhY2UoL15cXC8rLywgXCJcIik7XG4gICAgICB2ID0gdi5yZXBsYWNlKC9bXi0rXFwuX34hJCYnKCkqLDs6PWEtekEtejAtOV0vZywgVVJMLnBlcmNlbnRFbmNvZGUpO1xuICAgICAgaWYgKHYubGVuZ3RoID4gMCkge1xuICAgICAgICB1cmwuaG9zdCA9IHY7XG4gICAgICAgIG91dHB1dCA9IHVybC50b1N0cmluZygpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmhyZWYgPSBvdXRwdXQ7XG4gIH0sXG5cbiAgc2V0IHBvcnQodikge1xuICAgIHZhciBvdXRwdXQgPSB0aGlzLmhyZWY7XG4gICAgdmFyIHVybCA9IG5ldyBVUkwob3V0cHV0KTtcbiAgICBpZiAodXJsLmlzQWJzb2x1dGUoKSAmJiB1cmwuaXNBdXRob3JpdHlCYXNlZCgpKSB7XG4gICAgICB2ID0gJycgKyB2O1xuICAgICAgdiA9IHYucmVwbGFjZSgvW14wLTldLiokLywgXCJcIik7XG4gICAgICB2ID0gdi5yZXBsYWNlKC9eMCsvLCBcIlwiKTtcbiAgICAgIGlmICh2Lmxlbmd0aCA9PT0gMCkgdiA9IFwiMFwiO1xuICAgICAgaWYgKHBhcnNlSW50KHYsIDEwKSA8PSA2NTUzNSkge1xuICAgICAgICB1cmwucG9ydCA9IHY7XG4gICAgICAgIG91dHB1dCA9IHVybC50b1N0cmluZygpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmhyZWYgPSBvdXRwdXQ7XG4gIH0sXG5cbiAgc2V0IHBhdGhuYW1lKHYpIHtcbiAgICB2YXIgb3V0cHV0ID0gdGhpcy5ocmVmO1xuICAgIHZhciB1cmwgPSBuZXcgVVJMKG91dHB1dCk7XG4gICAgaWYgKHVybC5pc0Fic29sdXRlKCkgJiYgdXJsLmlzSGllcmFyY2hpY2FsKCkpIHtcbiAgICAgIGlmICh2LmNoYXJBdCgwKSAhPT0gXCIvXCIpXG4gICAgICAgIHYgPSBcIi9cIiArIHY7XG4gICAgICB2ID0gdi5yZXBsYWNlKC9bXi0rXFwuX34hJCYnKCkqLDs6PUBcXC9hLXpBLXowLTldL2csIFVSTC5wZXJjZW50RW5jb2RlKTtcbiAgICAgIHVybC5wYXRoID0gdjtcbiAgICAgIG91dHB1dCA9IHVybC50b1N0cmluZygpO1xuICAgIH1cbiAgICB0aGlzLmhyZWYgPSBvdXRwdXQ7XG4gIH0sXG5cbiAgc2V0IHNlYXJjaCh2KSB7XG4gICAgdmFyIG91dHB1dCA9IHRoaXMuaHJlZjtcbiAgICB2YXIgdXJsID0gbmV3IFVSTChvdXRwdXQpO1xuICAgIGlmICh1cmwuaXNBYnNvbHV0ZSgpICYmIHVybC5pc0hpZXJhcmNoaWNhbCgpKSB7XG4gICAgICBpZiAodi5jaGFyQXQoMCkgPT09IFwiP1wiKSB2ID0gdi5zdWJzdHJpbmcoMSk7XG4gICAgICB2ID0gdi5yZXBsYWNlKC9bXi0rXFwuX34hJCYnKCkqLDs6PUBcXC8/YS16QS16MC05XS9nLCBVUkwucGVyY2VudEVuY29kZSk7XG4gICAgICB1cmwucXVlcnkgPSB2O1xuICAgICAgb3V0cHV0ID0gdXJsLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIHRoaXMuaHJlZiA9IG91dHB1dDtcbiAgfSxcblxuICBzZXQgaGFzaCh2KSB7XG4gICAgdmFyIG91dHB1dCA9IHRoaXMuaHJlZjtcbiAgICB2YXIgdXJsID0gbmV3IFVSTChvdXRwdXQpO1xuICAgIGlmICh1cmwuaXNBYnNvbHV0ZSgpKSB7XG4gICAgICBpZiAodi5jaGFyQXQoMCkgPT09IFwiI1wiKSB2ID0gdi5zdWJzdHJpbmcoMSk7XG4gICAgICB2ID0gdi5yZXBsYWNlKC9bXi0rXFwuX34hJCYnKCkqLDs6PUBcXC8/YS16QS16MC05XS9nLCBVUkwucGVyY2VudEVuY29kZSk7XG4gICAgICB1cmwuZnJhZ21lbnQgPSB2O1xuICAgICAgb3V0cHV0ID0gdXJsLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIHRoaXMuaHJlZiA9IG91dHB1dDtcbiAgfSxcblxuICBzZXQgdXNlcm5hbWUodikge1xuICAgIHZhciBvdXRwdXQgPSB0aGlzLmhyZWY7XG4gICAgdmFyIHVybCA9IG5ldyBVUkwob3V0cHV0KTtcbiAgICBpZiAodXJsLmlzQWJzb2x1dGUoKSkge1xuICAgICAgdiA9IHYucmVwbGFjZSgvW1xceDAwLVxceDFGXFx4N0YtXFx1RkZGRiBcIiM8Pj9gXFwvQFxcXFw6XS9nLCBVUkwucGVyY2VudEVuY29kZSk7XG4gICAgICB1cmwudXNlcm5hbWUgPSB2O1xuICAgICAgb3V0cHV0ID0gdXJsLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIHRoaXMuaHJlZiA9IG91dHB1dDtcbiAgfSxcblxuICBzZXQgcGFzc3dvcmQodikge1xuICAgIHZhciBvdXRwdXQgPSB0aGlzLmhyZWY7XG4gICAgdmFyIHVybCA9IG5ldyBVUkwob3V0cHV0KTtcbiAgICBpZiAodXJsLmlzQWJzb2x1dGUoKSkge1xuICAgICAgaWYgKHY9PT0nJykge1xuICAgICAgICB1cmwucGFzc3dvcmQgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdiA9IHYucmVwbGFjZSgvW1xceDAwLVxceDFGXFx4N0YtXFx1RkZGRiBcIiM8Pj9gXFwvQFxcXFxdL2csIFVSTC5wZXJjZW50RW5jb2RlKTtcbiAgICAgICAgdXJsLnBhc3N3b3JkID0gdjtcbiAgICAgIH1cbiAgICAgIG91dHB1dCA9IHVybC50b1N0cmluZygpO1xuICAgIH1cbiAgICB0aGlzLmhyZWYgPSBvdXRwdXQ7XG4gIH0vKixcblxuICBzZXQgc2VhcmNoUGFyYW1zKHYpIHtcbiAgICB2YXIgb3V0cHV0ID0gdGhpcy5ocmVmO1xuICAgIHZhciB1cmwgPSBuZXcgVVJMKG91dHB1dCk7XG4gICAgLy8gWFhYXG4gICAgdGhpcy5ocmVmID0gb3V0cHV0O1xuICB9XG4gICovXG59O1xuXG5VUkxVdGlscy5faW5oZXJpdCA9IGZ1bmN0aW9uKHByb3RvKSB7XG4gIC8vIGNvcHkgZ2V0dGVycy9zZXR0ZXJzIGZyb20gVVJMVXRpbHMgdG8gby5cbiAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoVVJMVXRpbHMucHJvdG90eXBlKS5mb3JFYWNoKGZ1bmN0aW9uKHApIHtcbiAgICBpZiAocD09PSdjb25zdHJ1Y3RvcicgfHwgcD09PSdocmVmJykgeyByZXR1cm47IH1cbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoVVJMVXRpbHMucHJvdG90eXBlLCBwKTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvdG8sIHAsIGRlc2MpO1xuICB9KTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9kb21pbm8vbGliL1VSTFV0aWxzLmpzXG4vLyBtb2R1bGUgaWQgPSA1NlxuLy8gbW9kdWxlIGNodW5rcyA9IDQiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIGF0dHJpYnV0ZXMgPSByZXF1aXJlKCcuL2F0dHJpYnV0ZXMnKTtcbnZhciBzbG9wcHkgPSByZXF1aXJlKCcuL3Nsb3BweScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHNwZWMsIGRlZmF1bHRDb25zdHJ1Y3RvciwgdGFnTGlzdCwgdGFnTmFtZVRvSW1wbCkge1xuICB2YXIgYyA9IHNwZWMuY3RvcjtcbiAgaWYgKGMpIHtcbiAgICB2YXIgcHJvcHMgPSBzcGVjLnByb3BzIHx8IHt9O1xuXG4gICAgaWYgKHNwZWMuYXR0cmlidXRlcykge1xuICAgICAgZm9yICh2YXIgbiBpbiBzcGVjLmF0dHJpYnV0ZXMpIHtcbiAgICAgICAgdmFyIGF0dHIgPSBzcGVjLmF0dHJpYnV0ZXNbbl07XG4gICAgICAgIGlmICh0eXBlb2YgYXR0ciAhPT0gJ29iamVjdCcgfHwgQXJyYXkuaXNBcnJheShhdHRyKSkgYXR0ciA9IHt0eXBlOiBhdHRyfTtcbiAgICAgICAgaWYgKCFhdHRyLm5hbWUpIGF0dHIubmFtZSA9IG4udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgcHJvcHNbbl0gPSBhdHRyaWJ1dGVzLnByb3BlcnR5KGF0dHIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHByb3BzLmNvbnN0cnVjdG9yID0geyB2YWx1ZSA6IGMgfTtcbiAgICBjLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoKHNwZWMuc3VwZXJjbGFzcyB8fCBkZWZhdWx0Q29uc3RydWN0b3IpLnByb3RvdHlwZSwgcHJvcHMpO1xuICAgIGlmIChzcGVjLmV2ZW50cykge1xuICAgICAgYWRkRXZlbnRIYW5kbGVycyhjLCBzcGVjLmV2ZW50cyk7XG4gICAgfVxuICAgIHRhZ0xpc3RbYy5uYW1lXSA9IGM7XG4gIH1cbiAgZWxzZSB7XG4gICAgYyA9IGRlZmF1bHRDb25zdHJ1Y3RvcjtcbiAgfVxuXG4gIChzcGVjLnRhZ3MgfHwgc3BlYy50YWcgJiYgW3NwZWMudGFnXSB8fCBbXSkuZm9yRWFjaChmdW5jdGlvbih0YWcpIHtcbiAgICB0YWdOYW1lVG9JbXBsW3RhZ10gPSBjO1xuICB9KTtcblxuICByZXR1cm4gYztcbn07XG5cbmZ1bmN0aW9uIEV2ZW50SGFuZGxlckJ1aWxkZXIoYm9keSwgZG9jdW1lbnQsIGZvcm0sIGVsZW1lbnQpIHtcbiAgdGhpcy5ib2R5ID0gYm9keTtcbiAgdGhpcy5kb2N1bWVudCA9IGRvY3VtZW50O1xuICB0aGlzLmZvcm0gPSBmb3JtO1xuICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xufVxuXG5FdmVudEhhbmRsZXJCdWlsZGVyLnByb3RvdHlwZS5idWlsZCA9IHNsb3BweS5FdmVudEhhbmRsZXJCdWlsZGVyX2J1aWxkO1xuXG5mdW5jdGlvbiBFdmVudEhhbmRsZXJDaGFuZ2VIYW5kbGVyKGVsdCwgbmFtZSwgb2xkdmFsLCBuZXd2YWwpIHtcbiAgdmFyIGRvYyA9IGVsdC5vd25lckRvY3VtZW50IHx8IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHZhciBmb3JtID0gZWx0LmZvcm0gfHwgT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgZWx0W25hbWVdID0gbmV3IEV2ZW50SGFuZGxlckJ1aWxkZXIobmV3dmFsLCBkb2MsIGZvcm0sIGVsdCkuYnVpbGQoKTtcbn1cblxuZnVuY3Rpb24gYWRkRXZlbnRIYW5kbGVycyhjLCBldmVudEhhbmRsZXJUeXBlcykge1xuICB2YXIgcCA9IGMucHJvdG90eXBlO1xuICBldmVudEhhbmRsZXJUeXBlcy5mb3JFYWNoKGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAvLyBEZWZpbmUgdGhlIGV2ZW50IGhhbmRsZXIgcmVnaXN0cmF0aW9uIElETCBhdHRyaWJ1dGUgZm9yIHRoaXMgdHlwZVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwLCBcIm9uXCIgKyB0eXBlLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0RXZlbnRIYW5kbGVyKHR5cGUpO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24odikge1xuICAgICAgICB0aGlzLl9zZXRFdmVudEhhbmRsZXIodHlwZSwgdik7XG4gICAgICB9LFxuICAgIH0pO1xuXG4gICAgLy8gRGVmaW5lIHNwZWNpYWwgYmVoYXZpb3IgZm9yIHRoZSBjb250ZW50IGF0dHJpYnV0ZSBhcyB3ZWxsXG4gICAgYXR0cmlidXRlcy5yZWdpc3RlckNoYW5nZUhhbmRsZXIoYywgXCJvblwiICsgdHlwZSwgRXZlbnRIYW5kbGVyQ2hhbmdlSGFuZGxlcik7XG4gIH0pO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZG9taW5vL2xpYi9kZWZpbmVFbGVtZW50LmpzXG4vLyBtb2R1bGUgaWQgPSA1N1xuLy8gbW9kdWxlIGNodW5rcyA9IDQiLCIvKiBEb21pbm8gdXNlcyBzbG9wcHktbW9kZSBmZWF0dXJlcyAoaW4gcGFydGljdWxhciwgYHdpdGhgKSBmb3IgYSBmZXdcbiAqIG1pbm9yIHRoaW5ncy4gIFRoaXMgZmlsZSBlbmNhcHN1bGF0ZXMgYWxsIHRoZSBzbG9wcGluZXNzOyBldmVyeVxuICogb3RoZXIgbW9kdWxlIHNob3VsZCBiZSBzdHJpY3QuICovXG4vKiBqc2hpbnQgc3RyaWN0OiBmYWxzZSAqL1xuLyoganNoaW50IGV2aWw6IHRydWUgKi9cbi8qIGpzaGludCAtVzA4NSAqL1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFdpbmRvd19ydW46IGZ1bmN0aW9uIF9ydW4oY29kZSwgZmlsZSkge1xuICAgIGlmIChmaWxlKSBjb2RlICs9ICdcXG4vL0Agc291cmNlVVJMPScgKyBmaWxlO1xuICAgIHdpdGgodGhpcykgZXZhbChjb2RlKTtcbiAgfSxcbiAgRXZlbnRIYW5kbGVyQnVpbGRlcl9idWlsZDogZnVuY3Rpb24gYnVpbGQoKSB7XG4gICAgdHJ5IHtcbiAgICAgIHdpdGgodGhpcy5kb2N1bWVudC5kZWZhdWx0VmlldyB8fCBPYmplY3QuY3JlYXRlKG51bGwpKVxuICAgICAgICB3aXRoKHRoaXMuZG9jdW1lbnQpXG4gICAgICAgICAgd2l0aCh0aGlzLmZvcm0pXG4gICAgICAgICAgICB3aXRoKHRoaXMuZWxlbWVudClcbiAgICAgICAgICAgICAgcmV0dXJuIGV2YWwoXCIoZnVuY3Rpb24oZXZlbnQpe1wiICsgdGhpcy5ib2R5ICsgXCJ9KVwiKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkgeyB0aHJvdyBlcnI7IH07XG4gICAgfVxuICB9XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZG9taW5vL2xpYi9zbG9wcHkuanNcbi8vIG1vZHVsZSBpZCA9IDU4XG4vLyBtb2R1bGUgY2h1bmtzID0gNCIsIlwidXNlIHN0cmljdFwiO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSB7XG4gIENTU1N0eWxlRGVjbGFyYXRpb246IHJlcXVpcmUoJy4vQ1NTU3R5bGVEZWNsYXJhdGlvbicpLFxuICBDaGFyYWN0ZXJEYXRhOiByZXF1aXJlKCcuL0NoYXJhY3RlckRhdGEnKSxcbiAgQ29tbWVudDogcmVxdWlyZSgnLi9Db21tZW50JyksXG4gIERPTUV4Y2VwdGlvbjogcmVxdWlyZSgnLi9ET01FeGNlcHRpb24nKSxcbiAgRE9NSW1wbGVtZW50YXRpb246IHJlcXVpcmUoJy4vRE9NSW1wbGVtZW50YXRpb24nKSxcbiAgRE9NVG9rZW5MaXN0OiByZXF1aXJlKCcuL0RPTVRva2VuTGlzdCcpLFxuICBEb2N1bWVudDogcmVxdWlyZSgnLi9Eb2N1bWVudCcpLFxuICBEb2N1bWVudEZyYWdtZW50OiByZXF1aXJlKCcuL0RvY3VtZW50RnJhZ21lbnQnKSxcbiAgRG9jdW1lbnRUeXBlOiByZXF1aXJlKCcuL0RvY3VtZW50VHlwZScpLFxuICBFbGVtZW50OiByZXF1aXJlKCcuL0VsZW1lbnQnKSxcbiAgSFRNTFBhcnNlcjogcmVxdWlyZSgnLi9IVE1MUGFyc2VyJyksXG4gIE5vZGU6IHJlcXVpcmUoJy4vTm9kZScpLFxuICBOb2RlTGlzdDogcmVxdWlyZSgnLi9Ob2RlTGlzdCcpLFxuICBOb2RlRmlsdGVyOiByZXF1aXJlKCcuL05vZGVGaWx0ZXInKSxcbiAgUHJvY2Vzc2luZ0luc3RydWN0aW9uOiByZXF1aXJlKCcuL1Byb2Nlc3NpbmdJbnN0cnVjdGlvbicpLFxuICBUZXh0OiByZXF1aXJlKCcuL1RleHQnKSxcbiAgV2luZG93OiByZXF1aXJlKCcuL1dpbmRvdycpXG59O1xuXG51dGlscy5tZXJnZShleHBvcnRzLCByZXF1aXJlKCcuL2V2ZW50cycpKTtcbnV0aWxzLm1lcmdlKGV4cG9ydHMsIHJlcXVpcmUoJy4vaHRtbGVsdHMnKS5lbGVtZW50cyk7XG51dGlscy5tZXJnZShleHBvcnRzLCByZXF1aXJlKCcuL3N2ZycpLmVsZW1lbnRzKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2RvbWluby9saWIvaW1wbC5qc1xuLy8gbW9kdWxlIGlkID0gNTlcbi8vIG1vZHVsZSBjaHVua3MgPSA0IiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgRWxlbWVudCA9IHJlcXVpcmUoJy4vRWxlbWVudCcpO1xudmFyIGRlZmluZUVsZW1lbnQgPSByZXF1aXJlKCcuL2RlZmluZUVsZW1lbnQnKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbnZhciBDU1NTdHlsZURlY2xhcmF0aW9uID0gcmVxdWlyZSgnLi9DU1NTdHlsZURlY2xhcmF0aW9uJyk7XG5cbnZhciBzdmdFbGVtZW50cyA9IGV4cG9ydHMuZWxlbWVudHMgPSB7fTtcbnZhciBzdmdOYW1lVG9JbXBsID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuZXhwb3J0cy5jcmVhdGVFbGVtZW50ID0gZnVuY3Rpb24oZG9jLCBsb2NhbE5hbWUsIHByZWZpeCkge1xuICB2YXIgaW1wbCA9IHN2Z05hbWVUb0ltcGxbbG9jYWxOYW1lXSB8fCBTVkdFbGVtZW50O1xuICByZXR1cm4gbmV3IGltcGwoZG9jLCBsb2NhbE5hbWUsIHByZWZpeCk7XG59O1xuXG5mdW5jdGlvbiBkZWZpbmUoc3BlYykge1xuICByZXR1cm4gZGVmaW5lRWxlbWVudChzcGVjLCBTVkdFbGVtZW50LCBzdmdFbGVtZW50cywgc3ZnTmFtZVRvSW1wbCk7XG59XG5cbnZhciBTVkdFbGVtZW50ID0gZGVmaW5lKHtcbiAgc3VwZXJjbGFzczogRWxlbWVudCxcbiAgY3RvcjogZnVuY3Rpb24gU1ZHRWxlbWVudChkb2MsIGxvY2FsTmFtZSwgcHJlZml4KSB7XG4gICAgRWxlbWVudC5jYWxsKHRoaXMsIGRvYywgbG9jYWxOYW1lLCB1dGlscy5OQU1FU1BBQ0UuU1ZHLCBwcmVmaXgpO1xuICB9LFxuICBwcm9wczoge1xuICAgIHN0eWxlOiB7IGdldDogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIXRoaXMuX3N0eWxlKVxuICAgICAgICB0aGlzLl9zdHlsZSA9IG5ldyBDU1NTdHlsZURlY2xhcmF0aW9uKHRoaXMpO1xuICAgICAgcmV0dXJuIHRoaXMuX3N0eWxlO1xuICAgIH19XG4gIH1cbn0pO1xuXG5kZWZpbmUoe1xuICBjdG9yOiBmdW5jdGlvbiBTVkdTVkdFbGVtZW50KGRvYywgbG9jYWxOYW1lLCBwcmVmaXgpIHtcbiAgICBTVkdFbGVtZW50LmNhbGwodGhpcywgZG9jLCBsb2NhbE5hbWUsIHByZWZpeCk7XG4gIH0sXG4gIHRhZzogJ3N2ZycsXG4gIHByb3BzOiB7XG4gICAgY3JlYXRlU1ZHUmVjdDogeyB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGV4cG9ydHMuY3JlYXRlRWxlbWVudCh0aGlzLm93bmVyRG9jdW1lbnQsICdyZWN0JywgbnVsbCk7XG4gICAgfSB9XG4gIH1cbn0pO1xuXG5kZWZpbmUoe1xuICB0YWdzOiBbXG4gICAgJ2EnLCAnYWx0R2x5cGgnLCAnYWx0R2x5cGhEZWYnLCAnYWx0R2x5cGhJdGVtJywgJ2FuaW1hdGUnLCAnYW5pbWF0ZUNvbG9yJywgJ2FuaW1hdGVNb3Rpb24nLCAnYW5pbWF0ZVRyYW5zZm9ybScsXG4gICAgJ2NpcmNsZScsICdjbGlwUGF0aCcsICdjb2xvci1wcm9maWxlJywgJ2N1cnNvcicsICdkZWZzJywgJ2Rlc2MnLCAnZWxsaXBzZScsICdmZUJsZW5kJywgJ2ZlQ29sb3JNYXRyaXgnLFxuICAgICdmZUNvbXBvbmVudFRyYW5zZmVyJywgJ2ZlQ29tcG9zaXRlJywgJ2ZlQ29udm9sdmVNYXRyaXgnLCAnZmVEaWZmdXNlTGlnaHRpbmcnLCAnZmVEaXNwbGFjZW1lbnRNYXAnLCAnZmVEaXN0YW50TGlnaHQnLFxuICAgICdmZUZsb29kJywgJ2ZlRnVuY0EnLCAnZmVGdW5jQicsICdmZUZ1bmNHJywgJ2ZlRnVuY1InLCAnZmVHYXVzc2lhbkJsdXInLCAnZmVJbWFnZScsICdmZU1lcmdlJywgJ2ZlTWVyZ2VOb2RlJyxcbiAgICAnZmVNb3JwaG9sb2d5JywgJ2ZlT2Zmc2V0JywgJ2ZlUG9pbnRMaWdodCcsICdmZVNwZWN1bGFyTGlnaHRpbmcnLCAnZmVTcG90TGlnaHQnLCAnZmVUaWxlJywgJ2ZlVHVyYnVsZW5jZScsICdmaWx0ZXInLFxuICAgICdmb250JywgJ2ZvbnQtZmFjZScsICdmb250LWZhY2UtZm9ybWF0JywgJ2ZvbnQtZmFjZS1uYW1lJywgJ2ZvbnQtZmFjZS1zcmMnLCAnZm9udC1mYWNlLXVyaScsICdmb3JlaWduT2JqZWN0JywgJ2cnLFxuICAgICdnbHlwaCcsICdnbHlwaFJlZicsICdoa2VybicsICdpbWFnZScsICdsaW5lJywgJ2xpbmVhckdyYWRpZW50JywgJ21hcmtlcicsICdtYXNrJywgJ21ldGFkYXRhJywgJ21pc3NpbmctZ2x5cGgnLFxuICAgICdtcGF0aCcsICdwYXRoJywgJ3BhdHRlcm4nLCAncG9seWdvbicsICdwb2x5bGluZScsICdyYWRpYWxHcmFkaWVudCcsICdyZWN0JywgJ3NjcmlwdCcsICdzZXQnLCAnc3RvcCcsICAnc3R5bGUnLFxuICAgICdzd2l0Y2gnLCAnc3ltYm9sJywgJ3RleHQnLCAndGV4dFBhdGgnLCAndGl0bGUnLCAndHJlZicsICd0c3BhbicsICd1c2UnLCAndmlldycsICd2a2VybidcbiAgXVxufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9kb21pbm8vbGliL3N2Zy5qc1xuLy8gbW9kdWxlIGlkID0gNjBcbi8vIG1vZHVsZSBjaHVua3MgPSA0IiwiaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBGb3JtQ29udHJvbCwgRm9ybUdyb3VwLCBWYWxpZGF0b3JzIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xyXG5cclxuaW1wb3J0IHsgQ29udHJvbEJhc2UgfSBmcm9tICcuL2NvbnRyb2wtYmFzZSc7XHJcbmltcG9ydCB7IFZhbGlkYXRpb25TZXJ2aWNlIH0gZnJvbSAnLi92YWxpZGF0aW9uLnNlcnZpY2UnO1xyXG5cclxuQEluamVjdGFibGUoKVxyXG5leHBvcnQgY2xhc3MgRm9ybUNvbnRyb2xTZXJ2aWNlIHtcclxuXHJcbiAgICBwdWJsaWMgdG9Db250cm9sR3JvdXAoY29udHJvbHM6IEFycmF5PENvbnRyb2xCYXNlPGFueT4+KSB7XHJcbiAgICAgICAgY29uc3QgZ3JvdXA6IGFueSA9IHt9O1xyXG5cclxuICAgICAgICBjb250cm9scy5mb3JFYWNoKGNvbnRyb2wgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCB2YWxpZGF0b3JzOiBhbnkgPSBbXTtcclxuICAgICAgICAgICAgLy8gUmVxdWlyZWRcclxuICAgICAgICAgICAgaWYgKGNvbnRyb2wucmVxdWlyZWQpIHtcclxuICAgICAgICAgICAgICAgIHZhbGlkYXRvcnMucHVzaChWYWxpZGF0b3JzLnJlcXVpcmVkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBNaW5sZW5ndGhcclxuICAgICAgICAgICAgaWYgKGNvbnRyb2wubWlubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICB2YWxpZGF0b3JzLnB1c2goVmFsaWRhdG9ycy5taW5MZW5ndGgoY29udHJvbC5taW5sZW5ndGgpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBNYXhsZW5ndGhcclxuICAgICAgICAgICAgaWYgKGNvbnRyb2wubWF4bGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICB2YWxpZGF0b3JzLnB1c2goVmFsaWRhdG9ycy5tYXhMZW5ndGgoY29udHJvbC5tYXhsZW5ndGgpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBFbWFpbFxyXG4gICAgICAgICAgICBpZiAoY29udHJvbC50eXBlID09PSAnZW1haWwnKSB7XHJcbiAgICAgICAgICAgICAgICB2YWxpZGF0b3JzLnB1c2goVmFsaWRhdGlvblNlcnZpY2UuZW1haWxWYWxpZGF0b3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIFBhc3N3b3JkXHJcbiAgICAgICAgICAgIGlmIChjb250cm9sLnR5cGUgPT09ICdwYXNzd29yZCcpIHtcclxuICAgICAgICAgICAgICAgIHZhbGlkYXRvcnMucHVzaChWYWxpZGF0aW9uU2VydmljZS5wYXNzd29yZFZhbGlkYXRvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZ3JvdXBbY29udHJvbC5rZXldID0gbmV3IEZvcm1Db250cm9sKGNvbnRyb2wudmFsdWUgfHwgJycsIHZhbGlkYXRvcnMpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICByZXR1cm4gbmV3IEZvcm1Hcm91cChncm91cCk7XHJcbiAgICB9XHJcbn1cclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2FuZ3VsYXIyLXRlbXBsYXRlLWxvYWRlciEuL0NsaWVudEFwcC9hcHAvc2hhcmVkL2Zvcm1zL2Zvcm0tY29udHJvbC5zZXJ2aWNlLnRzIiwiZXhwb3J0IGNsYXNzIFZhbGlkYXRpb25TZXJ2aWNlIHtcclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIGdldFZhbGlkYXRvckVycm9yTWVzc2FnZShjb2RlOiBzdHJpbmcsIGZpZWxkTGVuZ3RoOiBudW1iZXIgfCB1bmRlZmluZWQpIHtcclxuICAgICAgICBjb25zdCBjb25maWc6IGFueSA9IHtcclxuICAgICAgICAgICAgcmVxdWlyZWQ6ICdUaGlzIGlzIGEgcmVxdWlyZWQgZmllbGQnLFxyXG4gICAgICAgICAgICBtaW5sZW5ndGg6ICdNaW5pbXVtIGxlbmd0aCBpcyAnICsgZmllbGRMZW5ndGgsXHJcbiAgICAgICAgICAgIG1heGxlbmd0aDogJ01heGltdW0gbGVuZ3RoIGlzICcgKyBmaWVsZExlbmd0aCxcclxuICAgICAgICAgICAgaW52YWxpZENyZWRpdENhcmQ6ICdJbnZhbGlkIGNyZWRpdCBjYXJkIG51bWJlcicsXHJcbiAgICAgICAgICAgIGludmFsaWRFbWFpbEFkZHJlc3M6ICdJbnZhbGlkIGVtYWlsIGFkZHJlc3MnLFxyXG4gICAgICAgICAgICBpbnZhbGlkUGFzc3dvcmQ6ICdQYXNzd29yZCBtdXN0IGJlIGF0IGxlYXN0IDYgY2hhcmFjdGVycyBsb25nLCBhbmQgY29udGFpbiBhIG51bWJlciBhbmQgc3BlY2lhbCBjaGFyYWN0ZXIuJ1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIGNvbmZpZ1tjb2RlXTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIGNyZWRpdENhcmRWYWxpZGF0b3IoY29udHJvbDogYW55KSB7XHJcbiAgICAgICAgLy8gVmlzYSwgTWFzdGVyQ2FyZCwgQW1lcmljYW4gRXhwcmVzcywgRGluZXJzIENsdWIsIERpc2NvdmVyLCBKQ0JcclxuICAgICAgICBpZiAoY29udHJvbC52YWx1ZS5tYXRjaCgvXig/OjRbMC05XXsxMn0oPzpbMC05XXszfSk/fDVbMS01XVswLTldezE0fXw2KD86MDExfDVbMC05XVswLTldKVswLTldezEyfXwzWzQ3XVswLTldezEzfXwzKD86MFswLTVdfFs2OF1bMC05XSlbMC05XXsxMX18KD86MjEzMXwxODAwfDM1XFxkezN9KVxcZHsxMX0pJC8pKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHsgaW52YWxpZENyZWRpdENhcmQ6IHRydWUgfTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBlbWFpbFZhbGlkYXRvcihjb250cm9sOiBhbnkpIHtcclxuICAgICAgICAvLyBSRkMgMjgyMiBjb21wbGlhbnQgcmVnZXhcclxuICAgICAgICBpZiAoY29udHJvbC52YWx1ZS5tYXRjaCgvW2EtejAtOSEjJCUmJyorLz0/Xl9ge3x9fi1dKyg/OlxcLlthLXowLTkhIyQlJicqKy89P15fYHt8fX4tXSspKkAoPzpbYS16MC05XSg/OlthLXowLTktXSpbYS16MC05XSk/XFwuKStbYS16MC05XSg/OlthLXowLTktXSpbYS16MC05XSk/LykpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4geyBpbnZhbGlkRW1haWxBZGRyZXNzOiB0cnVlIH07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgcGFzc3dvcmRWYWxpZGF0b3IoY29udHJvbDogYW55KTogYW55IHtcclxuICAgICAgICAvLyB7NiwxMDB9ICAgICAgICAgICAtIEFzc2VydCBwYXNzd29yZCBpcyBiZXR3ZWVuIDYgYW5kIDEwMCBjaGFyYWN0ZXJzXHJcbiAgICAgICAgLy8gKD89LipbMC05XSkgICAgICAgLSBBc3NlcnQgYSBzdHJpbmcgaGFzIGF0IGxlYXN0IG9uZSBudW1iZXJcclxuICAgICAgICBpZiAoY29udHJvbC52YWx1ZS5tYXRjaCgvXig/PS4qWzAtOV0pW2EtekEtWjAtOSFcIkAjJCVeJipdezYsMTAwfSQvKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7IGludmFsaWRQYXNzd29yZDogdHJ1ZSB9O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvYW5ndWxhcjItdGVtcGxhdGUtbG9hZGVyIS4vQ2xpZW50QXBwL2FwcC9zaGFyZWQvZm9ybXMvdmFsaWRhdGlvbi5zZXJ2aWNlLnRzIiwiaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5cclxuaW1wb3J0IHsgRGF0YVNlcnZpY2UgfSBmcm9tICcuLi8uLi9jb3JlL3NlcnZpY2VzL2RhdGEuc2VydmljZSc7XHJcblxyXG5ASW5qZWN0YWJsZSgpXHJcbmV4cG9ydCBjbGFzcyBDb250ZW50U2VydmljZSB7XHJcblxyXG4gICAgY29uc3RydWN0b3IocHVibGljIGRhdGFTZXJ2aWNlOiBEYXRhU2VydmljZSkgeyB9XHJcblxyXG4gICAgcHVibGljIGdldChsYW5nPzogc3RyaW5nKTogYW55IHtcclxuICAgICAgICByZXR1cm4gdGhpcy5kYXRhU2VydmljZS5nZXQ8e30+KCdhcGkvY29udGVudD9sYW5nPScgKyAobGFuZyB8fCAnZW4nKSk7XHJcbiAgICB9XHJcbn1cclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2FuZ3VsYXIyLXRlbXBsYXRlLWxvYWRlciEuL0NsaWVudEFwcC9hcHAvc2hhcmVkL3NlcnZpY2VzL2NvbnRlbnQuc2VydmljZS50cyIsImltcG9ydCB7IENvbXBvbmVudCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5cclxuQENvbXBvbmVudCh7XHJcbiAgc2VsZWN0b3I6ICdhcHBjLWhvbWUnLFxyXG4gIHN0eWxlczogW3JlcXVpcmUoJy4vaG9tZS5jb21wb25lbnQuc2NzcycpXSxcclxuICB0ZW1wbGF0ZTogcmVxdWlyZSgnLi9ob21lLmNvbXBvbmVudC5odG1sJylcclxufSlcclxuZXhwb3J0IGNsYXNzIEhvbWVDb21wb25lbnQgeyB9XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9hbmd1bGFyMi10ZW1wbGF0ZS1sb2FkZXIhLi9DbGllbnRBcHAvYXBwL2hvbWUvaG9tZS5jb21wb25lbnQudHMiLCJpbXBvcnQgeyBOZ01vZHVsZSwgTW9kdWxlV2l0aFByb3ZpZGVycyB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xyXG5pbXBvcnQgeyBGb3Jtc01vZHVsZSwgUmVhY3RpdmVGb3Jtc01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcclxuaW1wb3J0IHsgUm91dGVyTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvcm91dGVyJztcclxuaW1wb3J0IHsgSHR0cENsaWVudE1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbi9odHRwJztcclxuaW1wb3J0IHsgVHJhbnNsYXRlTW9kdWxlLCBUcmFuc2xhdGVMb2FkZXIgfSBmcm9tICdAbmd4LXRyYW5zbGF0ZS9jb3JlJztcclxuXHJcbmltcG9ydCB7IFBhZ2VIZWFkaW5nQ29tcG9uZW50IH0gZnJvbSAnLi9kaXJlY3RpdmVzL3BhZ2UtaGVhZGluZy5kaXJlY3RpdmUnO1xyXG5pbXBvcnQgeyBEeW5hbWljRm9ybUNvbXBvbmVudCB9IGZyb20gJy4vZm9ybXMvZHluYW1pYy1mb3JtLmNvbXBvbmVudCc7XHJcbmltcG9ydCB7IER5bmFtaWNGb3JtQ29udHJvbENvbXBvbmVudCB9IGZyb20gJy4vZm9ybXMvZHluYW1pYy1mb3JtLWNvbnRyb2wuY29tcG9uZW50JztcclxuaW1wb3J0IHsgRXJyb3JNZXNzYWdlQ29tcG9uZW50IH0gZnJvbSAnLi9mb3Jtcy9lcnJvci1tZXNzYWdlLmNvbXBvbmVudCc7XHJcbmltcG9ydCB7IEVycm9yU3VtbWFyeUNvbXBvbmVudCB9IGZyb20gJy4vZm9ybXMvZXJyb3Itc3VtbWFyeS5jb21wb25lbnQnO1xyXG5pbXBvcnQgeyBGb3JtQ29udHJvbFNlcnZpY2UgfSBmcm9tICcuL2Zvcm1zL2Zvcm0tY29udHJvbC5zZXJ2aWNlJztcclxuXHJcblxyXG5pbXBvcnQgeyBIZWFkZXJDb21wb25lbnQgfSBmcm9tICcuL2xheW91dC9oZWFkZXIuY29tcG9uZW50JztcclxuaW1wb3J0IHsgRm9vdGVyQ29tcG9uZW50IH0gZnJvbSAnLi9sYXlvdXQvZm9vdGVyLmNvbXBvbmVudCc7XHJcblxyXG5pbXBvcnQgeyBVcHBlcmNhc2VQaXBlIH0gZnJvbSAnLi9waXBlcy91cHBlcmNhc2UucGlwZSc7XHJcblxyXG4vLyBTZXJ2aWNlc1xyXG5pbXBvcnQgeyBDb250ZW50U2VydmljZSB9IGZyb20gJy4vc2VydmljZXMvY29udGVudC5zZXJ2aWNlJztcclxuaW1wb3J0IHsgQXBpVHJhbnNsYXRpb25Mb2FkZXIgfSBmcm9tICcuL3NlcnZpY2VzL2FwaS10cmFuc2xhdGlvbi1sb2FkZXIuc2VydmljZSc7XHJcblxyXG5ATmdNb2R1bGUoe1xyXG4gIGltcG9ydHM6IFtcclxuICAgIENvbW1vbk1vZHVsZSxcclxuICAgIEZvcm1zTW9kdWxlLFxyXG4gICAgUmVhY3RpdmVGb3Jtc01vZHVsZSxcclxuICAgIFJvdXRlck1vZHVsZSxcclxuICAgIFRyYW5zbGF0ZU1vZHVsZSxcclxuICAgIC8vIE5nYk1vZHVsZS5mb3JSb290KCksXHJcbiAgICAvLyBObyBuZWVkIHRvIGV4cG9ydCBhcyB0aGVzZSBtb2R1bGVzIGRvbid0IGV4cG9zZSBhbnkgY29tcG9uZW50cy9kaXJlY3RpdmUgZXRjJ1xyXG4gICAgSHR0cENsaWVudE1vZHVsZSxcclxuICAgIFRyYW5zbGF0ZU1vZHVsZS5mb3JSb290KHtcclxuICAgICAgbG9hZGVyOiB7XHJcbiAgICAgICAgcHJvdmlkZTogVHJhbnNsYXRlTG9hZGVyLFxyXG4gICAgICAgIHVzZUNsYXNzOiBBcGlUcmFuc2xhdGlvbkxvYWRlclxyXG4gICAgICB9XHJcbiAgICB9KVxyXG4gIF0sXHJcbiAgZGVjbGFyYXRpb25zOiBbXHJcbiAgICBEeW5hbWljRm9ybUNvbXBvbmVudCxcclxuICAgIER5bmFtaWNGb3JtQ29udHJvbENvbXBvbmVudCxcclxuICAgIEVycm9yTWVzc2FnZUNvbXBvbmVudCxcclxuICAgIEVycm9yU3VtbWFyeUNvbXBvbmVudCxcclxuICAgIEZvb3RlckNvbXBvbmVudCxcclxuICAgIEhlYWRlckNvbXBvbmVudCxcclxuICAgIFBhZ2VIZWFkaW5nQ29tcG9uZW50LFxyXG4gICAgVXBwZXJjYXNlUGlwZVxyXG4gIF0sXHJcbiAgZXhwb3J0czogW1xyXG4gICAgLy8gTW9kdWxlc1xyXG4gICAgQ29tbW9uTW9kdWxlLFxyXG4gICAgRm9ybXNNb2R1bGUsXHJcbiAgICBSZWFjdGl2ZUZvcm1zTW9kdWxlLFxyXG4gICAgUm91dGVyTW9kdWxlLFxyXG4gICAgLy8gTmdiTW9kdWxlLFxyXG4gICAgVHJhbnNsYXRlTW9kdWxlLFxyXG4gICAgLy8gUHJvdmlkZXJzLCBDb21wb25lbnRzLCBkaXJlY3RpdmUsIHBpcGVzXHJcbiAgICBEeW5hbWljRm9ybUNvbXBvbmVudCxcclxuICAgIER5bmFtaWNGb3JtQ29udHJvbENvbXBvbmVudCxcclxuICAgIEVycm9yU3VtbWFyeUNvbXBvbmVudCxcclxuICAgIEVycm9yTWVzc2FnZUNvbXBvbmVudCxcclxuICAgIEZvb3RlckNvbXBvbmVudCxcclxuICAgIEhlYWRlckNvbXBvbmVudCxcclxuICAgIFBhZ2VIZWFkaW5nQ29tcG9uZW50LFxyXG4gICAgVXBwZXJjYXNlUGlwZVxyXG4gIF1cclxuXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBTaGFyZWRNb2R1bGUge1xyXG4gIHB1YmxpYyBzdGF0aWMgZm9yUm9vdCgpOiBNb2R1bGVXaXRoUHJvdmlkZXJzIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIG5nTW9kdWxlOiBTaGFyZWRNb2R1bGUsXHJcbiAgICAgIHByb3ZpZGVyczogW1xyXG4gICAgICAgIEZvcm1Db250cm9sU2VydmljZSxcclxuICAgICAgICBDb250ZW50U2VydmljZVxyXG4gICAgICBdXHJcbiAgICB9O1xyXG4gIH1cclxufVxyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvYW5ndWxhcjItdGVtcGxhdGUtbG9hZGVyIS4vQ2xpZW50QXBwL2FwcC9zaGFyZWQvc2hhcmVkLm1vZHVsZS50cyIsImltcG9ydCAncmVmbGVjdC1tZXRhZGF0YSc7XHJcbmltcG9ydCAnem9uZS5qcyc7XHJcbmltcG9ydCAncnhqcy9hZGQvb3BlcmF0b3IvZmlyc3QnO1xyXG5pbXBvcnQgeyBBUFBfQkFTRV9IUkVGIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcclxuaW1wb3J0IHsgZW5hYmxlUHJvZE1vZGUsIEFwcGxpY2F0aW9uUmVmLCBOZ1pvbmUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgcGxhdGZvcm1EeW5hbWljU2VydmVyLCBQbGF0Zm9ybVN0YXRlLCBJTklUSUFMX0NPTkZJRyB9IGZyb20gJ0Bhbmd1bGFyL3BsYXRmb3JtLXNlcnZlcic7XHJcbmltcG9ydCB7IGNyZWF0ZVNlcnZlclJlbmRlcmVyLCBSZW5kZXJSZXN1bHQgfSBmcm9tICdhc3BuZXQtcHJlcmVuZGVyaW5nJztcclxuaW1wb3J0IHsgQXBwTW9kdWxlIH0gZnJvbSAnLi9hcHAvYXBwLm1vZHVsZS5zZXJ2ZXInO1xyXG5cclxuZW5hYmxlUHJvZE1vZGUoKTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNyZWF0ZVNlcnZlclJlbmRlcmVyKHBhcmFtcyA9PiB7XHJcbiAgICBjb25zdCBwcm92aWRlcnMgPSBbXHJcbiAgICAgICAgeyBwcm92aWRlOiBJTklUSUFMX0NPTkZJRywgdXNlVmFsdWU6IHsgZG9jdW1lbnQ6ICc8YXBwYy1yb290PjwvYXBwYy1yb290PicsIHVybDogcGFyYW1zLnVybCB9IH0sXHJcbiAgICAgICAgeyBwcm92aWRlOiBBUFBfQkFTRV9IUkVGLCB1c2VWYWx1ZTogcGFyYW1zLmJhc2VVcmwgfSxcclxuICAgICAgICB7IHByb3ZpZGU6ICdCQVNFX1VSTCcsIHVzZVZhbHVlOiBwYXJhbXMub3JpZ2luICsgcGFyYW1zLmJhc2VVcmwgfSxcclxuICAgIF07XHJcblxyXG4gICAgcmV0dXJuIHBsYXRmb3JtRHluYW1pY1NlcnZlcihwcm92aWRlcnMpLmJvb3RzdHJhcE1vZHVsZShBcHBNb2R1bGUpLnRoZW4obW9kdWxlUmVmID0+IHtcclxuICAgICAgICBjb25zdCBhcHBSZWY6IEFwcGxpY2F0aW9uUmVmID0gbW9kdWxlUmVmLmluamVjdG9yLmdldChBcHBsaWNhdGlvblJlZik7XHJcbiAgICAgICAgY29uc3Qgc3RhdGUgPSBtb2R1bGVSZWYuaW5qZWN0b3IuZ2V0KFBsYXRmb3JtU3RhdGUpO1xyXG4gICAgICAgIGNvbnN0IHpvbmU6IE5nWm9uZSA9IG1vZHVsZVJlZi5pbmplY3Rvci5nZXQoTmdab25lKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlPFJlbmRlclJlc3VsdD4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgICAgICB6b25lLm9uRXJyb3Iuc3Vic2NyaWJlKChlcnJvckluZm86IGFueSkgPT4gcmVqZWN0KGVycm9ySW5mbykpO1xyXG4gICAgICAgICAgICBhcHBSZWYuaXNTdGFibGUuZmlyc3QoaXNTdGFibGUgPT4gaXNTdGFibGUpLnN1YnNjcmliZSgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAvLyBCZWNhdXNlICdvblN0YWJsZScgZmlyZXMgYmVmb3JlICdvbkVycm9yJywgd2UgaGF2ZSB0byBkZWxheSBzbGlnaHRseSBiZWZvcmVcclxuICAgICAgICAgICAgICAgIC8vIGNvbXBsZXRpbmcgdGhlIHJlcXVlc3QgaW4gY2FzZSB0aGVyZSdzIGFuIGVycm9yIHRvIHJlcG9ydFxyXG4gICAgICAgICAgICAgICAgc2V0SW1tZWRpYXRlKCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDogc3RhdGUucmVuZGVyVG9TdHJpbmcoKVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIG1vZHVsZVJlZi5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxufSk7XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9hbmd1bGFyMi10ZW1wbGF0ZS1sb2FkZXIhLi9DbGllbnRBcHAvYm9vdC5zZXJ2ZXIudHMiLCIvKiEgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChDKSBNaWNyb3NvZnQuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZVxyXG50aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZVxyXG5MaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG5cclxuVEhJUyBDT0RFIElTIFBST1ZJREVEIE9OIEFOICpBUyBJUyogQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG5LSU5ELCBFSVRIRVIgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgV0lUSE9VVCBMSU1JVEFUSU9OIEFOWSBJTVBMSUVEXHJcbldBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBUSVRMRSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UsXHJcbk1FUkNIQU5UQUJMSVRZIE9SIE5PTi1JTkZSSU5HRU1FTlQuXHJcblxyXG5TZWUgdGhlIEFwYWNoZSBWZXJzaW9uIDIuMCBMaWNlbnNlIGZvciBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnNcclxuYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG52YXIgUmVmbGVjdDtcclxuKGZ1bmN0aW9uIChSZWZsZWN0KSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuICAgIHZhciBoYXNPd24gPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xyXG4gICAgLy8gZmVhdHVyZSB0ZXN0IGZvciBTeW1ib2wgc3VwcG9ydFxyXG4gICAgdmFyIHN1cHBvcnRzU3ltYm9sID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiO1xyXG4gICAgdmFyIHRvUHJpbWl0aXZlU3ltYm9sID0gc3VwcG9ydHNTeW1ib2wgJiYgdHlwZW9mIFN5bWJvbC50b1ByaW1pdGl2ZSAhPT0gXCJ1bmRlZmluZWRcIiA/IFN5bWJvbC50b1ByaW1pdGl2ZSA6IFwiQEB0b1ByaW1pdGl2ZVwiO1xyXG4gICAgdmFyIGl0ZXJhdG9yU3ltYm9sID0gc3VwcG9ydHNTeW1ib2wgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciAhPT0gXCJ1bmRlZmluZWRcIiA/IFN5bWJvbC5pdGVyYXRvciA6IFwiQEBpdGVyYXRvclwiO1xyXG4gICAgdmFyIEhhc2hNYXA7XHJcbiAgICAoZnVuY3Rpb24gKEhhc2hNYXApIHtcclxuICAgICAgICB2YXIgc3VwcG9ydHNDcmVhdGUgPSB0eXBlb2YgT2JqZWN0LmNyZWF0ZSA9PT0gXCJmdW5jdGlvblwiOyAvLyBmZWF0dXJlIHRlc3QgZm9yIE9iamVjdC5jcmVhdGUgc3VwcG9ydFxyXG4gICAgICAgIHZhciBzdXBwb3J0c1Byb3RvID0geyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheTsgLy8gZmVhdHVyZSB0ZXN0IGZvciBfX3Byb3RvX18gc3VwcG9ydFxyXG4gICAgICAgIHZhciBkb3duTGV2ZWwgPSAhc3VwcG9ydHNDcmVhdGUgJiYgIXN1cHBvcnRzUHJvdG87XHJcbiAgICAgICAgLy8gY3JlYXRlIGFuIG9iamVjdCBpbiBkaWN0aW9uYXJ5IG1vZGUgKGEuay5hLiBcInNsb3dcIiBtb2RlIGluIHY4KVxyXG4gICAgICAgIEhhc2hNYXAuY3JlYXRlID0gc3VwcG9ydHNDcmVhdGVcclxuICAgICAgICAgICAgPyBmdW5jdGlvbiAoKSB7IHJldHVybiBNYWtlRGljdGlvbmFyeShPYmplY3QuY3JlYXRlKG51bGwpKTsgfVxyXG4gICAgICAgICAgICA6IHN1cHBvcnRzUHJvdG9cclxuICAgICAgICAgICAgICAgID8gZnVuY3Rpb24gKCkgeyByZXR1cm4gTWFrZURpY3Rpb25hcnkoeyBfX3Byb3RvX186IG51bGwgfSk7IH1cclxuICAgICAgICAgICAgICAgIDogZnVuY3Rpb24gKCkgeyByZXR1cm4gTWFrZURpY3Rpb25hcnkoe30pOyB9O1xyXG4gICAgICAgIEhhc2hNYXAuaGFzID0gZG93bkxldmVsXHJcbiAgICAgICAgICAgID8gZnVuY3Rpb24gKG1hcCwga2V5KSB7IHJldHVybiBoYXNPd24uY2FsbChtYXAsIGtleSk7IH1cclxuICAgICAgICAgICAgOiBmdW5jdGlvbiAobWFwLCBrZXkpIHsgcmV0dXJuIGtleSBpbiBtYXA7IH07XHJcbiAgICAgICAgSGFzaE1hcC5nZXQgPSBkb3duTGV2ZWxcclxuICAgICAgICAgICAgPyBmdW5jdGlvbiAobWFwLCBrZXkpIHsgcmV0dXJuIGhhc093bi5jYWxsKG1hcCwga2V5KSA/IG1hcFtrZXldIDogdW5kZWZpbmVkOyB9XHJcbiAgICAgICAgICAgIDogZnVuY3Rpb24gKG1hcCwga2V5KSB7IHJldHVybiBtYXBba2V5XTsgfTtcclxuICAgIH0pKEhhc2hNYXAgfHwgKEhhc2hNYXAgPSB7fSkpO1xyXG4gICAgLy8gTG9hZCBnbG9iYWwgb3Igc2hpbSB2ZXJzaW9ucyBvZiBNYXAsIFNldCwgYW5kIFdlYWtNYXBcclxuICAgIHZhciBmdW5jdGlvblByb3RvdHlwZSA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihGdW5jdGlvbik7XHJcbiAgICB2YXIgdXNlUG9seWZpbGwgPSB0eXBlb2YgcHJvY2VzcyA9PT0gXCJvYmplY3RcIiAmJiBwcm9jZXNzLmVudiAmJiBwcm9jZXNzLmVudltcIlJFRkxFQ1RfTUVUQURBVEFfVVNFX01BUF9QT0xZRklMTFwiXSA9PT0gXCJ0cnVlXCI7XHJcbiAgICB2YXIgX01hcCA9ICF1c2VQb2x5ZmlsbCAmJiB0eXBlb2YgTWFwID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIE1hcC5wcm90b3R5cGUuZW50cmllcyA9PT0gXCJmdW5jdGlvblwiID8gTWFwIDogQ3JlYXRlTWFwUG9seWZpbGwoKTtcclxuICAgIHZhciBfU2V0ID0gIXVzZVBvbHlmaWxsICYmIHR5cGVvZiBTZXQgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU2V0LnByb3RvdHlwZS5lbnRyaWVzID09PSBcImZ1bmN0aW9uXCIgPyBTZXQgOiBDcmVhdGVTZXRQb2x5ZmlsbCgpO1xyXG4gICAgdmFyIF9XZWFrTWFwID0gIXVzZVBvbHlmaWxsICYmIHR5cGVvZiBXZWFrTWFwID09PSBcImZ1bmN0aW9uXCIgPyBXZWFrTWFwIDogQ3JlYXRlV2Vha01hcFBvbHlmaWxsKCk7XHJcbiAgICAvLyBbW01ldGFkYXRhXV0gaW50ZXJuYWwgc2xvdFxyXG4gICAgLy8gaHR0cHM6Ly9yYnVja3Rvbi5naXRodWIuaW8vcmVmbGVjdC1tZXRhZGF0YS8jb3JkaW5hcnktb2JqZWN0LWludGVybmFsLW1ldGhvZHMtYW5kLWludGVybmFsLXNsb3RzXHJcbiAgICB2YXIgTWV0YWRhdGEgPSBuZXcgX1dlYWtNYXAoKTtcclxuICAgIC8qKlxyXG4gICAgICAqIEFwcGxpZXMgYSBzZXQgb2YgZGVjb3JhdG9ycyB0byBhIHByb3BlcnR5IG9mIGEgdGFyZ2V0IG9iamVjdC5cclxuICAgICAgKiBAcGFyYW0gZGVjb3JhdG9ycyBBbiBhcnJheSBvZiBkZWNvcmF0b3JzLlxyXG4gICAgICAqIEBwYXJhbSB0YXJnZXQgVGhlIHRhcmdldCBvYmplY3QuXHJcbiAgICAgICogQHBhcmFtIHByb3BlcnR5S2V5IChPcHRpb25hbCkgVGhlIHByb3BlcnR5IGtleSB0byBkZWNvcmF0ZS5cclxuICAgICAgKiBAcGFyYW0gYXR0cmlidXRlcyAoT3B0aW9uYWwpIFRoZSBwcm9wZXJ0eSBkZXNjcmlwdG9yIGZvciB0aGUgdGFyZ2V0IGtleS5cclxuICAgICAgKiBAcmVtYXJrcyBEZWNvcmF0b3JzIGFyZSBhcHBsaWVkIGluIHJldmVyc2Ugb3JkZXIuXHJcbiAgICAgICogQGV4YW1wbGVcclxuICAgICAgKlxyXG4gICAgICAqICAgICBjbGFzcyBFeGFtcGxlIHtcclxuICAgICAgKiAgICAgICAgIC8vIHByb3BlcnR5IGRlY2xhcmF0aW9ucyBhcmUgbm90IHBhcnQgb2YgRVM2LCB0aG91Z2ggdGhleSBhcmUgdmFsaWQgaW4gVHlwZVNjcmlwdDpcclxuICAgICAgKiAgICAgICAgIC8vIHN0YXRpYyBzdGF0aWNQcm9wZXJ0eTtcclxuICAgICAgKiAgICAgICAgIC8vIHByb3BlcnR5O1xyXG4gICAgICAqXHJcbiAgICAgICogICAgICAgICBjb25zdHJ1Y3RvcihwKSB7IH1cclxuICAgICAgKiAgICAgICAgIHN0YXRpYyBzdGF0aWNNZXRob2QocCkgeyB9XHJcbiAgICAgICogICAgICAgICBtZXRob2QocCkgeyB9XHJcbiAgICAgICogICAgIH1cclxuICAgICAgKlxyXG4gICAgICAqICAgICAvLyBjb25zdHJ1Y3RvclxyXG4gICAgICAqICAgICBFeGFtcGxlID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzQXJyYXksIEV4YW1wbGUpO1xyXG4gICAgICAqXHJcbiAgICAgICogICAgIC8vIHByb3BlcnR5IChvbiBjb25zdHJ1Y3RvcilcclxuICAgICAgKiAgICAgUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzQXJyYXksIEV4YW1wbGUsIFwic3RhdGljUHJvcGVydHlcIik7XHJcbiAgICAgICpcclxuICAgICAgKiAgICAgLy8gcHJvcGVydHkgKG9uIHByb3RvdHlwZSlcclxuICAgICAgKiAgICAgUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzQXJyYXksIEV4YW1wbGUucHJvdG90eXBlLCBcInByb3BlcnR5XCIpO1xyXG4gICAgICAqXHJcbiAgICAgICogICAgIC8vIG1ldGhvZCAob24gY29uc3RydWN0b3IpXHJcbiAgICAgICogICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFeGFtcGxlLCBcInN0YXRpY01ldGhvZFwiLFxyXG4gICAgICAqICAgICAgICAgUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzQXJyYXksIEV4YW1wbGUsIFwic3RhdGljTWV0aG9kXCIsXHJcbiAgICAgICogICAgICAgICAgICAgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihFeGFtcGxlLCBcInN0YXRpY01ldGhvZFwiKSkpO1xyXG4gICAgICAqXHJcbiAgICAgICogICAgIC8vIG1ldGhvZCAob24gcHJvdG90eXBlKVxyXG4gICAgICAqICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRXhhbXBsZS5wcm90b3R5cGUsIFwibWV0aG9kXCIsXHJcbiAgICAgICogICAgICAgICBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnNBcnJheSwgRXhhbXBsZS5wcm90b3R5cGUsIFwibWV0aG9kXCIsXHJcbiAgICAgICogICAgICAgICAgICAgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihFeGFtcGxlLnByb3RvdHlwZSwgXCJtZXRob2RcIikpKTtcclxuICAgICAgKlxyXG4gICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBwcm9wZXJ0eUtleSwgYXR0cmlidXRlcykge1xyXG4gICAgICAgIGlmICghSXNVbmRlZmluZWQocHJvcGVydHlLZXkpKSB7XHJcbiAgICAgICAgICAgIGlmICghSXNBcnJheShkZWNvcmF0b3JzKSlcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcclxuICAgICAgICAgICAgaWYgKCFJc09iamVjdCh0YXJnZXQpKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xyXG4gICAgICAgICAgICBpZiAoIUlzT2JqZWN0KGF0dHJpYnV0ZXMpICYmICFJc1VuZGVmaW5lZChhdHRyaWJ1dGVzKSAmJiAhSXNOdWxsKGF0dHJpYnV0ZXMpKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xyXG4gICAgICAgICAgICBpZiAoSXNOdWxsKGF0dHJpYnV0ZXMpKVxyXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlcyA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgcHJvcGVydHlLZXkgPSBUb1Byb3BlcnR5S2V5KHByb3BlcnR5S2V5KTtcclxuICAgICAgICAgICAgcmV0dXJuIERlY29yYXRlUHJvcGVydHkoZGVjb3JhdG9ycywgdGFyZ2V0LCBwcm9wZXJ0eUtleSwgYXR0cmlidXRlcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAoIUlzQXJyYXkoZGVjb3JhdG9ycykpXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XHJcbiAgICAgICAgICAgIGlmICghSXNDb25zdHJ1Y3Rvcih0YXJnZXQpKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xyXG4gICAgICAgICAgICByZXR1cm4gRGVjb3JhdGVDb25zdHJ1Y3RvcihkZWNvcmF0b3JzLCB0YXJnZXQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIFJlZmxlY3QuZGVjb3JhdGUgPSBkZWNvcmF0ZTtcclxuICAgIC8vIDQuMS4yIFJlZmxlY3QubWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpXHJcbiAgICAvLyBodHRwczovL3JidWNrdG9uLmdpdGh1Yi5pby9yZWZsZWN0LW1ldGFkYXRhLyNyZWZsZWN0Lm1ldGFkYXRhXHJcbiAgICAvKipcclxuICAgICAgKiBBIGRlZmF1bHQgbWV0YWRhdGEgZGVjb3JhdG9yIGZhY3RvcnkgdGhhdCBjYW4gYmUgdXNlZCBvbiBhIGNsYXNzLCBjbGFzcyBtZW1iZXIsIG9yIHBhcmFtZXRlci5cclxuICAgICAgKiBAcGFyYW0gbWV0YWRhdGFLZXkgVGhlIGtleSBmb3IgdGhlIG1ldGFkYXRhIGVudHJ5LlxyXG4gICAgICAqIEBwYXJhbSBtZXRhZGF0YVZhbHVlIFRoZSB2YWx1ZSBmb3IgdGhlIG1ldGFkYXRhIGVudHJ5LlxyXG4gICAgICAqIEByZXR1cm5zIEEgZGVjb3JhdG9yIGZ1bmN0aW9uLlxyXG4gICAgICAqIEByZW1hcmtzXHJcbiAgICAgICogSWYgYG1ldGFkYXRhS2V5YCBpcyBhbHJlYWR5IGRlZmluZWQgZm9yIHRoZSB0YXJnZXQgYW5kIHRhcmdldCBrZXksIHRoZVxyXG4gICAgICAqIG1ldGFkYXRhVmFsdWUgZm9yIHRoYXQga2V5IHdpbGwgYmUgb3ZlcndyaXR0ZW4uXHJcbiAgICAgICogQGV4YW1wbGVcclxuICAgICAgKlxyXG4gICAgICAqICAgICAvLyBjb25zdHJ1Y3RvclxyXG4gICAgICAqICAgICBAUmVmbGVjdC5tZXRhZGF0YShrZXksIHZhbHVlKVxyXG4gICAgICAqICAgICBjbGFzcyBFeGFtcGxlIHtcclxuICAgICAgKiAgICAgfVxyXG4gICAgICAqXHJcbiAgICAgICogICAgIC8vIHByb3BlcnR5IChvbiBjb25zdHJ1Y3RvciwgVHlwZVNjcmlwdCBvbmx5KVxyXG4gICAgICAqICAgICBjbGFzcyBFeGFtcGxlIHtcclxuICAgICAgKiAgICAgICAgIEBSZWZsZWN0Lm1ldGFkYXRhKGtleSwgdmFsdWUpXHJcbiAgICAgICogICAgICAgICBzdGF0aWMgc3RhdGljUHJvcGVydHk7XHJcbiAgICAgICogICAgIH1cclxuICAgICAgKlxyXG4gICAgICAqICAgICAvLyBwcm9wZXJ0eSAob24gcHJvdG90eXBlLCBUeXBlU2NyaXB0IG9ubHkpXHJcbiAgICAgICogICAgIGNsYXNzIEV4YW1wbGUge1xyXG4gICAgICAqICAgICAgICAgQFJlZmxlY3QubWV0YWRhdGEoa2V5LCB2YWx1ZSlcclxuICAgICAgKiAgICAgICAgIHByb3BlcnR5O1xyXG4gICAgICAqICAgICB9XHJcbiAgICAgICpcclxuICAgICAgKiAgICAgLy8gbWV0aG9kIChvbiBjb25zdHJ1Y3RvcilcclxuICAgICAgKiAgICAgY2xhc3MgRXhhbXBsZSB7XHJcbiAgICAgICogICAgICAgICBAUmVmbGVjdC5tZXRhZGF0YShrZXksIHZhbHVlKVxyXG4gICAgICAqICAgICAgICAgc3RhdGljIHN0YXRpY01ldGhvZCgpIHsgfVxyXG4gICAgICAqICAgICB9XHJcbiAgICAgICpcclxuICAgICAgKiAgICAgLy8gbWV0aG9kIChvbiBwcm90b3R5cGUpXHJcbiAgICAgICogICAgIGNsYXNzIEV4YW1wbGUge1xyXG4gICAgICAqICAgICAgICAgQFJlZmxlY3QubWV0YWRhdGEoa2V5LCB2YWx1ZSlcclxuICAgICAgKiAgICAgICAgIG1ldGhvZCgpIHsgfVxyXG4gICAgICAqICAgICB9XHJcbiAgICAgICpcclxuICAgICAgKi9cclxuICAgIGZ1bmN0aW9uIG1ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gZGVjb3JhdG9yKHRhcmdldCwgcHJvcGVydHlLZXkpIHtcclxuICAgICAgICAgICAgaWYgKCFJc09iamVjdCh0YXJnZXQpKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xyXG4gICAgICAgICAgICBpZiAoIUlzVW5kZWZpbmVkKHByb3BlcnR5S2V5KSAmJiAhSXNQcm9wZXJ0eUtleShwcm9wZXJ0eUtleSkpXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XHJcbiAgICAgICAgICAgIE9yZGluYXJ5RGVmaW5lT3duTWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUsIHRhcmdldCwgcHJvcGVydHlLZXkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZGVjb3JhdG9yO1xyXG4gICAgfVxyXG4gICAgUmVmbGVjdC5tZXRhZGF0YSA9IG1ldGFkYXRhO1xyXG4gICAgLyoqXHJcbiAgICAgICogRGVmaW5lIGEgdW5pcXVlIG1ldGFkYXRhIGVudHJ5IG9uIHRoZSB0YXJnZXQuXHJcbiAgICAgICogQHBhcmFtIG1ldGFkYXRhS2V5IEEga2V5IHVzZWQgdG8gc3RvcmUgYW5kIHJldHJpZXZlIG1ldGFkYXRhLlxyXG4gICAgICAqIEBwYXJhbSBtZXRhZGF0YVZhbHVlIEEgdmFsdWUgdGhhdCBjb250YWlucyBhdHRhY2hlZCBtZXRhZGF0YS5cclxuICAgICAgKiBAcGFyYW0gdGFyZ2V0IFRoZSB0YXJnZXQgb2JqZWN0IG9uIHdoaWNoIHRvIGRlZmluZSBtZXRhZGF0YS5cclxuICAgICAgKiBAcGFyYW0gcHJvcGVydHlLZXkgKE9wdGlvbmFsKSBUaGUgcHJvcGVydHkga2V5IGZvciB0aGUgdGFyZ2V0LlxyXG4gICAgICAqIEBleGFtcGxlXHJcbiAgICAgICpcclxuICAgICAgKiAgICAgY2xhc3MgRXhhbXBsZSB7XHJcbiAgICAgICogICAgICAgICAvLyBwcm9wZXJ0eSBkZWNsYXJhdGlvbnMgYXJlIG5vdCBwYXJ0IG9mIEVTNiwgdGhvdWdoIHRoZXkgYXJlIHZhbGlkIGluIFR5cGVTY3JpcHQ6XHJcbiAgICAgICogICAgICAgICAvLyBzdGF0aWMgc3RhdGljUHJvcGVydHk7XHJcbiAgICAgICogICAgICAgICAvLyBwcm9wZXJ0eTtcclxuICAgICAgKlxyXG4gICAgICAqICAgICAgICAgY29uc3RydWN0b3IocCkgeyB9XHJcbiAgICAgICogICAgICAgICBzdGF0aWMgc3RhdGljTWV0aG9kKHApIHsgfVxyXG4gICAgICAqICAgICAgICAgbWV0aG9kKHApIHsgfVxyXG4gICAgICAqICAgICB9XHJcbiAgICAgICpcclxuICAgICAgKiAgICAgLy8gY29uc3RydWN0b3JcclxuICAgICAgKiAgICAgUmVmbGVjdC5kZWZpbmVNZXRhZGF0YShcImN1c3RvbTphbm5vdGF0aW9uXCIsIG9wdGlvbnMsIEV4YW1wbGUpO1xyXG4gICAgICAqXHJcbiAgICAgICogICAgIC8vIHByb3BlcnR5IChvbiBjb25zdHJ1Y3RvcilcclxuICAgICAgKiAgICAgUmVmbGVjdC5kZWZpbmVNZXRhZGF0YShcImN1c3RvbTphbm5vdGF0aW9uXCIsIG9wdGlvbnMsIEV4YW1wbGUsIFwic3RhdGljUHJvcGVydHlcIik7XHJcbiAgICAgICpcclxuICAgICAgKiAgICAgLy8gcHJvcGVydHkgKG9uIHByb3RvdHlwZSlcclxuICAgICAgKiAgICAgUmVmbGVjdC5kZWZpbmVNZXRhZGF0YShcImN1c3RvbTphbm5vdGF0aW9uXCIsIG9wdGlvbnMsIEV4YW1wbGUucHJvdG90eXBlLCBcInByb3BlcnR5XCIpO1xyXG4gICAgICAqXHJcbiAgICAgICogICAgIC8vIG1ldGhvZCAob24gY29uc3RydWN0b3IpXHJcbiAgICAgICogICAgIFJlZmxlY3QuZGVmaW5lTWV0YWRhdGEoXCJjdXN0b206YW5ub3RhdGlvblwiLCBvcHRpb25zLCBFeGFtcGxlLCBcInN0YXRpY01ldGhvZFwiKTtcclxuICAgICAgKlxyXG4gICAgICAqICAgICAvLyBtZXRob2QgKG9uIHByb3RvdHlwZSlcclxuICAgICAgKiAgICAgUmVmbGVjdC5kZWZpbmVNZXRhZGF0YShcImN1c3RvbTphbm5vdGF0aW9uXCIsIG9wdGlvbnMsIEV4YW1wbGUucHJvdG90eXBlLCBcIm1ldGhvZFwiKTtcclxuICAgICAgKlxyXG4gICAgICAqICAgICAvLyBkZWNvcmF0b3IgZmFjdG9yeSBhcyBtZXRhZGF0YS1wcm9kdWNpbmcgYW5ub3RhdGlvbi5cclxuICAgICAgKiAgICAgZnVuY3Rpb24gTXlBbm5vdGF0aW9uKG9wdGlvbnMpOiBEZWNvcmF0b3Ige1xyXG4gICAgICAqICAgICAgICAgcmV0dXJuICh0YXJnZXQsIGtleT8pID0+IFJlZmxlY3QuZGVmaW5lTWV0YWRhdGEoXCJjdXN0b206YW5ub3RhdGlvblwiLCBvcHRpb25zLCB0YXJnZXQsIGtleSk7XHJcbiAgICAgICogICAgIH1cclxuICAgICAgKlxyXG4gICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZGVmaW5lTWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUsIHRhcmdldCwgcHJvcGVydHlLZXkpIHtcclxuICAgICAgICBpZiAoIUlzT2JqZWN0KHRhcmdldCkpXHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcclxuICAgICAgICBpZiAoIUlzVW5kZWZpbmVkKHByb3BlcnR5S2V5KSlcclxuICAgICAgICAgICAgcHJvcGVydHlLZXkgPSBUb1Byb3BlcnR5S2V5KHByb3BlcnR5S2V5KTtcclxuICAgICAgICByZXR1cm4gT3JkaW5hcnlEZWZpbmVPd25NZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSwgdGFyZ2V0LCBwcm9wZXJ0eUtleSk7XHJcbiAgICB9XHJcbiAgICBSZWZsZWN0LmRlZmluZU1ldGFkYXRhID0gZGVmaW5lTWV0YWRhdGE7XHJcbiAgICAvKipcclxuICAgICAgKiBHZXRzIGEgdmFsdWUgaW5kaWNhdGluZyB3aGV0aGVyIHRoZSB0YXJnZXQgb2JqZWN0IG9yIGl0cyBwcm90b3R5cGUgY2hhaW4gaGFzIHRoZSBwcm92aWRlZCBtZXRhZGF0YSBrZXkgZGVmaW5lZC5cclxuICAgICAgKiBAcGFyYW0gbWV0YWRhdGFLZXkgQSBrZXkgdXNlZCB0byBzdG9yZSBhbmQgcmV0cmlldmUgbWV0YWRhdGEuXHJcbiAgICAgICogQHBhcmFtIHRhcmdldCBUaGUgdGFyZ2V0IG9iamVjdCBvbiB3aGljaCB0aGUgbWV0YWRhdGEgaXMgZGVmaW5lZC5cclxuICAgICAgKiBAcGFyYW0gcHJvcGVydHlLZXkgKE9wdGlvbmFsKSBUaGUgcHJvcGVydHkga2V5IGZvciB0aGUgdGFyZ2V0LlxyXG4gICAgICAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgbWV0YWRhdGEga2V5IHdhcyBkZWZpbmVkIG9uIHRoZSB0YXJnZXQgb2JqZWN0IG9yIGl0cyBwcm90b3R5cGUgY2hhaW47IG90aGVyd2lzZSwgYGZhbHNlYC5cclxuICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAqXHJcbiAgICAgICogICAgIGNsYXNzIEV4YW1wbGUge1xyXG4gICAgICAqICAgICAgICAgLy8gcHJvcGVydHkgZGVjbGFyYXRpb25zIGFyZSBub3QgcGFydCBvZiBFUzYsIHRob3VnaCB0aGV5IGFyZSB2YWxpZCBpbiBUeXBlU2NyaXB0OlxyXG4gICAgICAqICAgICAgICAgLy8gc3RhdGljIHN0YXRpY1Byb3BlcnR5O1xyXG4gICAgICAqICAgICAgICAgLy8gcHJvcGVydHk7XHJcbiAgICAgICpcclxuICAgICAgKiAgICAgICAgIGNvbnN0cnVjdG9yKHApIHsgfVxyXG4gICAgICAqICAgICAgICAgc3RhdGljIHN0YXRpY01ldGhvZChwKSB7IH1cclxuICAgICAgKiAgICAgICAgIG1ldGhvZChwKSB7IH1cclxuICAgICAgKiAgICAgfVxyXG4gICAgICAqXHJcbiAgICAgICogICAgIC8vIGNvbnN0cnVjdG9yXHJcbiAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuaGFzTWV0YWRhdGEoXCJjdXN0b206YW5ub3RhdGlvblwiLCBFeGFtcGxlKTtcclxuICAgICAgKlxyXG4gICAgICAqICAgICAvLyBwcm9wZXJ0eSAob24gY29uc3RydWN0b3IpXHJcbiAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuaGFzTWV0YWRhdGEoXCJjdXN0b206YW5ub3RhdGlvblwiLCBFeGFtcGxlLCBcInN0YXRpY1Byb3BlcnR5XCIpO1xyXG4gICAgICAqXHJcbiAgICAgICogICAgIC8vIHByb3BlcnR5IChvbiBwcm90b3R5cGUpXHJcbiAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuaGFzTWV0YWRhdGEoXCJjdXN0b206YW5ub3RhdGlvblwiLCBFeGFtcGxlLnByb3RvdHlwZSwgXCJwcm9wZXJ0eVwiKTtcclxuICAgICAgKlxyXG4gICAgICAqICAgICAvLyBtZXRob2QgKG9uIGNvbnN0cnVjdG9yKVxyXG4gICAgICAqICAgICByZXN1bHQgPSBSZWZsZWN0Lmhhc01ldGFkYXRhKFwiY3VzdG9tOmFubm90YXRpb25cIiwgRXhhbXBsZSwgXCJzdGF0aWNNZXRob2RcIik7XHJcbiAgICAgICpcclxuICAgICAgKiAgICAgLy8gbWV0aG9kIChvbiBwcm90b3R5cGUpXHJcbiAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuaGFzTWV0YWRhdGEoXCJjdXN0b206YW5ub3RhdGlvblwiLCBFeGFtcGxlLnByb3RvdHlwZSwgXCJtZXRob2RcIik7XHJcbiAgICAgICpcclxuICAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGhhc01ldGFkYXRhKG1ldGFkYXRhS2V5LCB0YXJnZXQsIHByb3BlcnR5S2V5KSB7XHJcbiAgICAgICAgaWYgKCFJc09iamVjdCh0YXJnZXQpKVxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XHJcbiAgICAgICAgaWYgKCFJc1VuZGVmaW5lZChwcm9wZXJ0eUtleSkpXHJcbiAgICAgICAgICAgIHByb3BlcnR5S2V5ID0gVG9Qcm9wZXJ0eUtleShwcm9wZXJ0eUtleSk7XHJcbiAgICAgICAgcmV0dXJuIE9yZGluYXJ5SGFzTWV0YWRhdGEobWV0YWRhdGFLZXksIHRhcmdldCwgcHJvcGVydHlLZXkpO1xyXG4gICAgfVxyXG4gICAgUmVmbGVjdC5oYXNNZXRhZGF0YSA9IGhhc01ldGFkYXRhO1xyXG4gICAgLyoqXHJcbiAgICAgICogR2V0cyBhIHZhbHVlIGluZGljYXRpbmcgd2hldGhlciB0aGUgdGFyZ2V0IG9iamVjdCBoYXMgdGhlIHByb3ZpZGVkIG1ldGFkYXRhIGtleSBkZWZpbmVkLlxyXG4gICAgICAqIEBwYXJhbSBtZXRhZGF0YUtleSBBIGtleSB1c2VkIHRvIHN0b3JlIGFuZCByZXRyaWV2ZSBtZXRhZGF0YS5cclxuICAgICAgKiBAcGFyYW0gdGFyZ2V0IFRoZSB0YXJnZXQgb2JqZWN0IG9uIHdoaWNoIHRoZSBtZXRhZGF0YSBpcyBkZWZpbmVkLlxyXG4gICAgICAqIEBwYXJhbSBwcm9wZXJ0eUtleSAoT3B0aW9uYWwpIFRoZSBwcm9wZXJ0eSBrZXkgZm9yIHRoZSB0YXJnZXQuXHJcbiAgICAgICogQHJldHVybnMgYHRydWVgIGlmIHRoZSBtZXRhZGF0YSBrZXkgd2FzIGRlZmluZWQgb24gdGhlIHRhcmdldCBvYmplY3Q7IG90aGVyd2lzZSwgYGZhbHNlYC5cclxuICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAqXHJcbiAgICAgICogICAgIGNsYXNzIEV4YW1wbGUge1xyXG4gICAgICAqICAgICAgICAgLy8gcHJvcGVydHkgZGVjbGFyYXRpb25zIGFyZSBub3QgcGFydCBvZiBFUzYsIHRob3VnaCB0aGV5IGFyZSB2YWxpZCBpbiBUeXBlU2NyaXB0OlxyXG4gICAgICAqICAgICAgICAgLy8gc3RhdGljIHN0YXRpY1Byb3BlcnR5O1xyXG4gICAgICAqICAgICAgICAgLy8gcHJvcGVydHk7XHJcbiAgICAgICpcclxuICAgICAgKiAgICAgICAgIGNvbnN0cnVjdG9yKHApIHsgfVxyXG4gICAgICAqICAgICAgICAgc3RhdGljIHN0YXRpY01ldGhvZChwKSB7IH1cclxuICAgICAgKiAgICAgICAgIG1ldGhvZChwKSB7IH1cclxuICAgICAgKiAgICAgfVxyXG4gICAgICAqXHJcbiAgICAgICogICAgIC8vIGNvbnN0cnVjdG9yXHJcbiAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuaGFzT3duTWV0YWRhdGEoXCJjdXN0b206YW5ub3RhdGlvblwiLCBFeGFtcGxlKTtcclxuICAgICAgKlxyXG4gICAgICAqICAgICAvLyBwcm9wZXJ0eSAob24gY29uc3RydWN0b3IpXHJcbiAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuaGFzT3duTWV0YWRhdGEoXCJjdXN0b206YW5ub3RhdGlvblwiLCBFeGFtcGxlLCBcInN0YXRpY1Byb3BlcnR5XCIpO1xyXG4gICAgICAqXHJcbiAgICAgICogICAgIC8vIHByb3BlcnR5IChvbiBwcm90b3R5cGUpXHJcbiAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuaGFzT3duTWV0YWRhdGEoXCJjdXN0b206YW5ub3RhdGlvblwiLCBFeGFtcGxlLnByb3RvdHlwZSwgXCJwcm9wZXJ0eVwiKTtcclxuICAgICAgKlxyXG4gICAgICAqICAgICAvLyBtZXRob2QgKG9uIGNvbnN0cnVjdG9yKVxyXG4gICAgICAqICAgICByZXN1bHQgPSBSZWZsZWN0Lmhhc093bk1ldGFkYXRhKFwiY3VzdG9tOmFubm90YXRpb25cIiwgRXhhbXBsZSwgXCJzdGF0aWNNZXRob2RcIik7XHJcbiAgICAgICpcclxuICAgICAgKiAgICAgLy8gbWV0aG9kIChvbiBwcm90b3R5cGUpXHJcbiAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuaGFzT3duTWV0YWRhdGEoXCJjdXN0b206YW5ub3RhdGlvblwiLCBFeGFtcGxlLnByb3RvdHlwZSwgXCJtZXRob2RcIik7XHJcbiAgICAgICpcclxuICAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGhhc093bk1ldGFkYXRhKG1ldGFkYXRhS2V5LCB0YXJnZXQsIHByb3BlcnR5S2V5KSB7XHJcbiAgICAgICAgaWYgKCFJc09iamVjdCh0YXJnZXQpKVxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XHJcbiAgICAgICAgaWYgKCFJc1VuZGVmaW5lZChwcm9wZXJ0eUtleSkpXHJcbiAgICAgICAgICAgIHByb3BlcnR5S2V5ID0gVG9Qcm9wZXJ0eUtleShwcm9wZXJ0eUtleSk7XHJcbiAgICAgICAgcmV0dXJuIE9yZGluYXJ5SGFzT3duTWV0YWRhdGEobWV0YWRhdGFLZXksIHRhcmdldCwgcHJvcGVydHlLZXkpO1xyXG4gICAgfVxyXG4gICAgUmVmbGVjdC5oYXNPd25NZXRhZGF0YSA9IGhhc093bk1ldGFkYXRhO1xyXG4gICAgLyoqXHJcbiAgICAgICogR2V0cyB0aGUgbWV0YWRhdGEgdmFsdWUgZm9yIHRoZSBwcm92aWRlZCBtZXRhZGF0YSBrZXkgb24gdGhlIHRhcmdldCBvYmplY3Qgb3IgaXRzIHByb3RvdHlwZSBjaGFpbi5cclxuICAgICAgKiBAcGFyYW0gbWV0YWRhdGFLZXkgQSBrZXkgdXNlZCB0byBzdG9yZSBhbmQgcmV0cmlldmUgbWV0YWRhdGEuXHJcbiAgICAgICogQHBhcmFtIHRhcmdldCBUaGUgdGFyZ2V0IG9iamVjdCBvbiB3aGljaCB0aGUgbWV0YWRhdGEgaXMgZGVmaW5lZC5cclxuICAgICAgKiBAcGFyYW0gcHJvcGVydHlLZXkgKE9wdGlvbmFsKSBUaGUgcHJvcGVydHkga2V5IGZvciB0aGUgdGFyZ2V0LlxyXG4gICAgICAqIEByZXR1cm5zIFRoZSBtZXRhZGF0YSB2YWx1ZSBmb3IgdGhlIG1ldGFkYXRhIGtleSBpZiBmb3VuZDsgb3RoZXJ3aXNlLCBgdW5kZWZpbmVkYC5cclxuICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAqXHJcbiAgICAgICogICAgIGNsYXNzIEV4YW1wbGUge1xyXG4gICAgICAqICAgICAgICAgLy8gcHJvcGVydHkgZGVjbGFyYXRpb25zIGFyZSBub3QgcGFydCBvZiBFUzYsIHRob3VnaCB0aGV5IGFyZSB2YWxpZCBpbiBUeXBlU2NyaXB0OlxyXG4gICAgICAqICAgICAgICAgLy8gc3RhdGljIHN0YXRpY1Byb3BlcnR5O1xyXG4gICAgICAqICAgICAgICAgLy8gcHJvcGVydHk7XHJcbiAgICAgICpcclxuICAgICAgKiAgICAgICAgIGNvbnN0cnVjdG9yKHApIHsgfVxyXG4gICAgICAqICAgICAgICAgc3RhdGljIHN0YXRpY01ldGhvZChwKSB7IH1cclxuICAgICAgKiAgICAgICAgIG1ldGhvZChwKSB7IH1cclxuICAgICAgKiAgICAgfVxyXG4gICAgICAqXHJcbiAgICAgICogICAgIC8vIGNvbnN0cnVjdG9yXHJcbiAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuZ2V0TWV0YWRhdGEoXCJjdXN0b206YW5ub3RhdGlvblwiLCBFeGFtcGxlKTtcclxuICAgICAgKlxyXG4gICAgICAqICAgICAvLyBwcm9wZXJ0eSAob24gY29uc3RydWN0b3IpXHJcbiAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuZ2V0TWV0YWRhdGEoXCJjdXN0b206YW5ub3RhdGlvblwiLCBFeGFtcGxlLCBcInN0YXRpY1Byb3BlcnR5XCIpO1xyXG4gICAgICAqXHJcbiAgICAgICogICAgIC8vIHByb3BlcnR5IChvbiBwcm90b3R5cGUpXHJcbiAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuZ2V0TWV0YWRhdGEoXCJjdXN0b206YW5ub3RhdGlvblwiLCBFeGFtcGxlLnByb3RvdHlwZSwgXCJwcm9wZXJ0eVwiKTtcclxuICAgICAgKlxyXG4gICAgICAqICAgICAvLyBtZXRob2QgKG9uIGNvbnN0cnVjdG9yKVxyXG4gICAgICAqICAgICByZXN1bHQgPSBSZWZsZWN0LmdldE1ldGFkYXRhKFwiY3VzdG9tOmFubm90YXRpb25cIiwgRXhhbXBsZSwgXCJzdGF0aWNNZXRob2RcIik7XHJcbiAgICAgICpcclxuICAgICAgKiAgICAgLy8gbWV0aG9kIChvbiBwcm90b3R5cGUpXHJcbiAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuZ2V0TWV0YWRhdGEoXCJjdXN0b206YW5ub3RhdGlvblwiLCBFeGFtcGxlLnByb3RvdHlwZSwgXCJtZXRob2RcIik7XHJcbiAgICAgICpcclxuICAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGdldE1ldGFkYXRhKG1ldGFkYXRhS2V5LCB0YXJnZXQsIHByb3BlcnR5S2V5KSB7XHJcbiAgICAgICAgaWYgKCFJc09iamVjdCh0YXJnZXQpKVxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XHJcbiAgICAgICAgaWYgKCFJc1VuZGVmaW5lZChwcm9wZXJ0eUtleSkpXHJcbiAgICAgICAgICAgIHByb3BlcnR5S2V5ID0gVG9Qcm9wZXJ0eUtleShwcm9wZXJ0eUtleSk7XHJcbiAgICAgICAgcmV0dXJuIE9yZGluYXJ5R2V0TWV0YWRhdGEobWV0YWRhdGFLZXksIHRhcmdldCwgcHJvcGVydHlLZXkpO1xyXG4gICAgfVxyXG4gICAgUmVmbGVjdC5nZXRNZXRhZGF0YSA9IGdldE1ldGFkYXRhO1xyXG4gICAgLyoqXHJcbiAgICAgICogR2V0cyB0aGUgbWV0YWRhdGEgdmFsdWUgZm9yIHRoZSBwcm92aWRlZCBtZXRhZGF0YSBrZXkgb24gdGhlIHRhcmdldCBvYmplY3QuXHJcbiAgICAgICogQHBhcmFtIG1ldGFkYXRhS2V5IEEga2V5IHVzZWQgdG8gc3RvcmUgYW5kIHJldHJpZXZlIG1ldGFkYXRhLlxyXG4gICAgICAqIEBwYXJhbSB0YXJnZXQgVGhlIHRhcmdldCBvYmplY3Qgb24gd2hpY2ggdGhlIG1ldGFkYXRhIGlzIGRlZmluZWQuXHJcbiAgICAgICogQHBhcmFtIHByb3BlcnR5S2V5IChPcHRpb25hbCkgVGhlIHByb3BlcnR5IGtleSBmb3IgdGhlIHRhcmdldC5cclxuICAgICAgKiBAcmV0dXJucyBUaGUgbWV0YWRhdGEgdmFsdWUgZm9yIHRoZSBtZXRhZGF0YSBrZXkgaWYgZm91bmQ7IG90aGVyd2lzZSwgYHVuZGVmaW5lZGAuXHJcbiAgICAgICogQGV4YW1wbGVcclxuICAgICAgKlxyXG4gICAgICAqICAgICBjbGFzcyBFeGFtcGxlIHtcclxuICAgICAgKiAgICAgICAgIC8vIHByb3BlcnR5IGRlY2xhcmF0aW9ucyBhcmUgbm90IHBhcnQgb2YgRVM2LCB0aG91Z2ggdGhleSBhcmUgdmFsaWQgaW4gVHlwZVNjcmlwdDpcclxuICAgICAgKiAgICAgICAgIC8vIHN0YXRpYyBzdGF0aWNQcm9wZXJ0eTtcclxuICAgICAgKiAgICAgICAgIC8vIHByb3BlcnR5O1xyXG4gICAgICAqXHJcbiAgICAgICogICAgICAgICBjb25zdHJ1Y3RvcihwKSB7IH1cclxuICAgICAgKiAgICAgICAgIHN0YXRpYyBzdGF0aWNNZXRob2QocCkgeyB9XHJcbiAgICAgICogICAgICAgICBtZXRob2QocCkgeyB9XHJcbiAgICAgICogICAgIH1cclxuICAgICAgKlxyXG4gICAgICAqICAgICAvLyBjb25zdHJ1Y3RvclxyXG4gICAgICAqICAgICByZXN1bHQgPSBSZWZsZWN0LmdldE93bk1ldGFkYXRhKFwiY3VzdG9tOmFubm90YXRpb25cIiwgRXhhbXBsZSk7XHJcbiAgICAgICpcclxuICAgICAgKiAgICAgLy8gcHJvcGVydHkgKG9uIGNvbnN0cnVjdG9yKVxyXG4gICAgICAqICAgICByZXN1bHQgPSBSZWZsZWN0LmdldE93bk1ldGFkYXRhKFwiY3VzdG9tOmFubm90YXRpb25cIiwgRXhhbXBsZSwgXCJzdGF0aWNQcm9wZXJ0eVwiKTtcclxuICAgICAgKlxyXG4gICAgICAqICAgICAvLyBwcm9wZXJ0eSAob24gcHJvdG90eXBlKVxyXG4gICAgICAqICAgICByZXN1bHQgPSBSZWZsZWN0LmdldE93bk1ldGFkYXRhKFwiY3VzdG9tOmFubm90YXRpb25cIiwgRXhhbXBsZS5wcm90b3R5cGUsIFwicHJvcGVydHlcIik7XHJcbiAgICAgICpcclxuICAgICAgKiAgICAgLy8gbWV0aG9kIChvbiBjb25zdHJ1Y3RvcilcclxuICAgICAgKiAgICAgcmVzdWx0ID0gUmVmbGVjdC5nZXRPd25NZXRhZGF0YShcImN1c3RvbTphbm5vdGF0aW9uXCIsIEV4YW1wbGUsIFwic3RhdGljTWV0aG9kXCIpO1xyXG4gICAgICAqXHJcbiAgICAgICogICAgIC8vIG1ldGhvZCAob24gcHJvdG90eXBlKVxyXG4gICAgICAqICAgICByZXN1bHQgPSBSZWZsZWN0LmdldE93bk1ldGFkYXRhKFwiY3VzdG9tOmFubm90YXRpb25cIiwgRXhhbXBsZS5wcm90b3R5cGUsIFwibWV0aG9kXCIpO1xyXG4gICAgICAqXHJcbiAgICAgICovXHJcbiAgICBmdW5jdGlvbiBnZXRPd25NZXRhZGF0YShtZXRhZGF0YUtleSwgdGFyZ2V0LCBwcm9wZXJ0eUtleSkge1xyXG4gICAgICAgIGlmICghSXNPYmplY3QodGFyZ2V0KSlcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xyXG4gICAgICAgIGlmICghSXNVbmRlZmluZWQocHJvcGVydHlLZXkpKVxyXG4gICAgICAgICAgICBwcm9wZXJ0eUtleSA9IFRvUHJvcGVydHlLZXkocHJvcGVydHlLZXkpO1xyXG4gICAgICAgIHJldHVybiBPcmRpbmFyeUdldE93bk1ldGFkYXRhKG1ldGFkYXRhS2V5LCB0YXJnZXQsIHByb3BlcnR5S2V5KTtcclxuICAgIH1cclxuICAgIFJlZmxlY3QuZ2V0T3duTWV0YWRhdGEgPSBnZXRPd25NZXRhZGF0YTtcclxuICAgIC8qKlxyXG4gICAgICAqIEdldHMgdGhlIG1ldGFkYXRhIGtleXMgZGVmaW5lZCBvbiB0aGUgdGFyZ2V0IG9iamVjdCBvciBpdHMgcHJvdG90eXBlIGNoYWluLlxyXG4gICAgICAqIEBwYXJhbSB0YXJnZXQgVGhlIHRhcmdldCBvYmplY3Qgb24gd2hpY2ggdGhlIG1ldGFkYXRhIGlzIGRlZmluZWQuXHJcbiAgICAgICogQHBhcmFtIHByb3BlcnR5S2V5IChPcHRpb25hbCkgVGhlIHByb3BlcnR5IGtleSBmb3IgdGhlIHRhcmdldC5cclxuICAgICAgKiBAcmV0dXJucyBBbiBhcnJheSBvZiB1bmlxdWUgbWV0YWRhdGEga2V5cy5cclxuICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAqXHJcbiAgICAgICogICAgIGNsYXNzIEV4YW1wbGUge1xyXG4gICAgICAqICAgICAgICAgLy8gcHJvcGVydHkgZGVjbGFyYXRpb25zIGFyZSBub3QgcGFydCBvZiBFUzYsIHRob3VnaCB0aGV5IGFyZSB2YWxpZCBpbiBUeXBlU2NyaXB0OlxyXG4gICAgICAqICAgICAgICAgLy8gc3RhdGljIHN0YXRpY1Byb3BlcnR5O1xyXG4gICAgICAqICAgICAgICAgLy8gcHJvcGVydHk7XHJcbiAgICAgICpcclxuICAgICAgKiAgICAgICAgIGNvbnN0cnVjdG9yKHApIHsgfVxyXG4gICAgICAqICAgICAgICAgc3RhdGljIHN0YXRpY01ldGhvZChwKSB7IH1cclxuICAgICAgKiAgICAgICAgIG1ldGhvZChwKSB7IH1cclxuICAgICAgKiAgICAgfVxyXG4gICAgICAqXHJcbiAgICAgICogICAgIC8vIGNvbnN0cnVjdG9yXHJcbiAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuZ2V0TWV0YWRhdGFLZXlzKEV4YW1wbGUpO1xyXG4gICAgICAqXHJcbiAgICAgICogICAgIC8vIHByb3BlcnR5IChvbiBjb25zdHJ1Y3RvcilcclxuICAgICAgKiAgICAgcmVzdWx0ID0gUmVmbGVjdC5nZXRNZXRhZGF0YUtleXMoRXhhbXBsZSwgXCJzdGF0aWNQcm9wZXJ0eVwiKTtcclxuICAgICAgKlxyXG4gICAgICAqICAgICAvLyBwcm9wZXJ0eSAob24gcHJvdG90eXBlKVxyXG4gICAgICAqICAgICByZXN1bHQgPSBSZWZsZWN0LmdldE1ldGFkYXRhS2V5cyhFeGFtcGxlLnByb3RvdHlwZSwgXCJwcm9wZXJ0eVwiKTtcclxuICAgICAgKlxyXG4gICAgICAqICAgICAvLyBtZXRob2QgKG9uIGNvbnN0cnVjdG9yKVxyXG4gICAgICAqICAgICByZXN1bHQgPSBSZWZsZWN0LmdldE1ldGFkYXRhS2V5cyhFeGFtcGxlLCBcInN0YXRpY01ldGhvZFwiKTtcclxuICAgICAgKlxyXG4gICAgICAqICAgICAvLyBtZXRob2QgKG9uIHByb3RvdHlwZSlcclxuICAgICAgKiAgICAgcmVzdWx0ID0gUmVmbGVjdC5nZXRNZXRhZGF0YUtleXMoRXhhbXBsZS5wcm90b3R5cGUsIFwibWV0aG9kXCIpO1xyXG4gICAgICAqXHJcbiAgICAgICovXHJcbiAgICBmdW5jdGlvbiBnZXRNZXRhZGF0YUtleXModGFyZ2V0LCBwcm9wZXJ0eUtleSkge1xyXG4gICAgICAgIGlmICghSXNPYmplY3QodGFyZ2V0KSlcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xyXG4gICAgICAgIGlmICghSXNVbmRlZmluZWQocHJvcGVydHlLZXkpKVxyXG4gICAgICAgICAgICBwcm9wZXJ0eUtleSA9IFRvUHJvcGVydHlLZXkocHJvcGVydHlLZXkpO1xyXG4gICAgICAgIHJldHVybiBPcmRpbmFyeU1ldGFkYXRhS2V5cyh0YXJnZXQsIHByb3BlcnR5S2V5KTtcclxuICAgIH1cclxuICAgIFJlZmxlY3QuZ2V0TWV0YWRhdGFLZXlzID0gZ2V0TWV0YWRhdGFLZXlzO1xyXG4gICAgLyoqXHJcbiAgICAgICogR2V0cyB0aGUgdW5pcXVlIG1ldGFkYXRhIGtleXMgZGVmaW5lZCBvbiB0aGUgdGFyZ2V0IG9iamVjdC5cclxuICAgICAgKiBAcGFyYW0gdGFyZ2V0IFRoZSB0YXJnZXQgb2JqZWN0IG9uIHdoaWNoIHRoZSBtZXRhZGF0YSBpcyBkZWZpbmVkLlxyXG4gICAgICAqIEBwYXJhbSBwcm9wZXJ0eUtleSAoT3B0aW9uYWwpIFRoZSBwcm9wZXJ0eSBrZXkgZm9yIHRoZSB0YXJnZXQuXHJcbiAgICAgICogQHJldHVybnMgQW4gYXJyYXkgb2YgdW5pcXVlIG1ldGFkYXRhIGtleXMuXHJcbiAgICAgICogQGV4YW1wbGVcclxuICAgICAgKlxyXG4gICAgICAqICAgICBjbGFzcyBFeGFtcGxlIHtcclxuICAgICAgKiAgICAgICAgIC8vIHByb3BlcnR5IGRlY2xhcmF0aW9ucyBhcmUgbm90IHBhcnQgb2YgRVM2LCB0aG91Z2ggdGhleSBhcmUgdmFsaWQgaW4gVHlwZVNjcmlwdDpcclxuICAgICAgKiAgICAgICAgIC8vIHN0YXRpYyBzdGF0aWNQcm9wZXJ0eTtcclxuICAgICAgKiAgICAgICAgIC8vIHByb3BlcnR5O1xyXG4gICAgICAqXHJcbiAgICAgICogICAgICAgICBjb25zdHJ1Y3RvcihwKSB7IH1cclxuICAgICAgKiAgICAgICAgIHN0YXRpYyBzdGF0aWNNZXRob2QocCkgeyB9XHJcbiAgICAgICogICAgICAgICBtZXRob2QocCkgeyB9XHJcbiAgICAgICogICAgIH1cclxuICAgICAgKlxyXG4gICAgICAqICAgICAvLyBjb25zdHJ1Y3RvclxyXG4gICAgICAqICAgICByZXN1bHQgPSBSZWZsZWN0LmdldE93bk1ldGFkYXRhS2V5cyhFeGFtcGxlKTtcclxuICAgICAgKlxyXG4gICAgICAqICAgICAvLyBwcm9wZXJ0eSAob24gY29uc3RydWN0b3IpXHJcbiAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuZ2V0T3duTWV0YWRhdGFLZXlzKEV4YW1wbGUsIFwic3RhdGljUHJvcGVydHlcIik7XHJcbiAgICAgICpcclxuICAgICAgKiAgICAgLy8gcHJvcGVydHkgKG9uIHByb3RvdHlwZSlcclxuICAgICAgKiAgICAgcmVzdWx0ID0gUmVmbGVjdC5nZXRPd25NZXRhZGF0YUtleXMoRXhhbXBsZS5wcm90b3R5cGUsIFwicHJvcGVydHlcIik7XHJcbiAgICAgICpcclxuICAgICAgKiAgICAgLy8gbWV0aG9kIChvbiBjb25zdHJ1Y3RvcilcclxuICAgICAgKiAgICAgcmVzdWx0ID0gUmVmbGVjdC5nZXRPd25NZXRhZGF0YUtleXMoRXhhbXBsZSwgXCJzdGF0aWNNZXRob2RcIik7XHJcbiAgICAgICpcclxuICAgICAgKiAgICAgLy8gbWV0aG9kIChvbiBwcm90b3R5cGUpXHJcbiAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuZ2V0T3duTWV0YWRhdGFLZXlzKEV4YW1wbGUucHJvdG90eXBlLCBcIm1ldGhvZFwiKTtcclxuICAgICAgKlxyXG4gICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZ2V0T3duTWV0YWRhdGFLZXlzKHRhcmdldCwgcHJvcGVydHlLZXkpIHtcclxuICAgICAgICBpZiAoIUlzT2JqZWN0KHRhcmdldCkpXHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcclxuICAgICAgICBpZiAoIUlzVW5kZWZpbmVkKHByb3BlcnR5S2V5KSlcclxuICAgICAgICAgICAgcHJvcGVydHlLZXkgPSBUb1Byb3BlcnR5S2V5KHByb3BlcnR5S2V5KTtcclxuICAgICAgICByZXR1cm4gT3JkaW5hcnlPd25NZXRhZGF0YUtleXModGFyZ2V0LCBwcm9wZXJ0eUtleSk7XHJcbiAgICB9XHJcbiAgICBSZWZsZWN0LmdldE93bk1ldGFkYXRhS2V5cyA9IGdldE93bk1ldGFkYXRhS2V5cztcclxuICAgIC8qKlxyXG4gICAgICAqIERlbGV0ZXMgdGhlIG1ldGFkYXRhIGVudHJ5IGZyb20gdGhlIHRhcmdldCBvYmplY3Qgd2l0aCB0aGUgcHJvdmlkZWQga2V5LlxyXG4gICAgICAqIEBwYXJhbSBtZXRhZGF0YUtleSBBIGtleSB1c2VkIHRvIHN0b3JlIGFuZCByZXRyaWV2ZSBtZXRhZGF0YS5cclxuICAgICAgKiBAcGFyYW0gdGFyZ2V0IFRoZSB0YXJnZXQgb2JqZWN0IG9uIHdoaWNoIHRoZSBtZXRhZGF0YSBpcyBkZWZpbmVkLlxyXG4gICAgICAqIEBwYXJhbSBwcm9wZXJ0eUtleSAoT3B0aW9uYWwpIFRoZSBwcm9wZXJ0eSBrZXkgZm9yIHRoZSB0YXJnZXQuXHJcbiAgICAgICogQHJldHVybnMgYHRydWVgIGlmIHRoZSBtZXRhZGF0YSBlbnRyeSB3YXMgZm91bmQgYW5kIGRlbGV0ZWQ7IG90aGVyd2lzZSwgZmFsc2UuXHJcbiAgICAgICogQGV4YW1wbGVcclxuICAgICAgKlxyXG4gICAgICAqICAgICBjbGFzcyBFeGFtcGxlIHtcclxuICAgICAgKiAgICAgICAgIC8vIHByb3BlcnR5IGRlY2xhcmF0aW9ucyBhcmUgbm90IHBhcnQgb2YgRVM2LCB0aG91Z2ggdGhleSBhcmUgdmFsaWQgaW4gVHlwZVNjcmlwdDpcclxuICAgICAgKiAgICAgICAgIC8vIHN0YXRpYyBzdGF0aWNQcm9wZXJ0eTtcclxuICAgICAgKiAgICAgICAgIC8vIHByb3BlcnR5O1xyXG4gICAgICAqXHJcbiAgICAgICogICAgICAgICBjb25zdHJ1Y3RvcihwKSB7IH1cclxuICAgICAgKiAgICAgICAgIHN0YXRpYyBzdGF0aWNNZXRob2QocCkgeyB9XHJcbiAgICAgICogICAgICAgICBtZXRob2QocCkgeyB9XHJcbiAgICAgICogICAgIH1cclxuICAgICAgKlxyXG4gICAgICAqICAgICAvLyBjb25zdHJ1Y3RvclxyXG4gICAgICAqICAgICByZXN1bHQgPSBSZWZsZWN0LmRlbGV0ZU1ldGFkYXRhKFwiY3VzdG9tOmFubm90YXRpb25cIiwgRXhhbXBsZSk7XHJcbiAgICAgICpcclxuICAgICAgKiAgICAgLy8gcHJvcGVydHkgKG9uIGNvbnN0cnVjdG9yKVxyXG4gICAgICAqICAgICByZXN1bHQgPSBSZWZsZWN0LmRlbGV0ZU1ldGFkYXRhKFwiY3VzdG9tOmFubm90YXRpb25cIiwgRXhhbXBsZSwgXCJzdGF0aWNQcm9wZXJ0eVwiKTtcclxuICAgICAgKlxyXG4gICAgICAqICAgICAvLyBwcm9wZXJ0eSAob24gcHJvdG90eXBlKVxyXG4gICAgICAqICAgICByZXN1bHQgPSBSZWZsZWN0LmRlbGV0ZU1ldGFkYXRhKFwiY3VzdG9tOmFubm90YXRpb25cIiwgRXhhbXBsZS5wcm90b3R5cGUsIFwicHJvcGVydHlcIik7XHJcbiAgICAgICpcclxuICAgICAgKiAgICAgLy8gbWV0aG9kIChvbiBjb25zdHJ1Y3RvcilcclxuICAgICAgKiAgICAgcmVzdWx0ID0gUmVmbGVjdC5kZWxldGVNZXRhZGF0YShcImN1c3RvbTphbm5vdGF0aW9uXCIsIEV4YW1wbGUsIFwic3RhdGljTWV0aG9kXCIpO1xyXG4gICAgICAqXHJcbiAgICAgICogICAgIC8vIG1ldGhvZCAob24gcHJvdG90eXBlKVxyXG4gICAgICAqICAgICByZXN1bHQgPSBSZWZsZWN0LmRlbGV0ZU1ldGFkYXRhKFwiY3VzdG9tOmFubm90YXRpb25cIiwgRXhhbXBsZS5wcm90b3R5cGUsIFwibWV0aG9kXCIpO1xyXG4gICAgICAqXHJcbiAgICAgICovXHJcbiAgICBmdW5jdGlvbiBkZWxldGVNZXRhZGF0YShtZXRhZGF0YUtleSwgdGFyZ2V0LCBwcm9wZXJ0eUtleSkge1xyXG4gICAgICAgIGlmICghSXNPYmplY3QodGFyZ2V0KSlcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xyXG4gICAgICAgIGlmICghSXNVbmRlZmluZWQocHJvcGVydHlLZXkpKVxyXG4gICAgICAgICAgICBwcm9wZXJ0eUtleSA9IFRvUHJvcGVydHlLZXkocHJvcGVydHlLZXkpO1xyXG4gICAgICAgIHZhciBtZXRhZGF0YU1hcCA9IEdldE9yQ3JlYXRlTWV0YWRhdGFNYXAodGFyZ2V0LCBwcm9wZXJ0eUtleSwgLypDcmVhdGUqLyBmYWxzZSk7XHJcbiAgICAgICAgaWYgKElzVW5kZWZpbmVkKG1ldGFkYXRhTWFwKSlcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIGlmICghbWV0YWRhdGFNYXAuZGVsZXRlKG1ldGFkYXRhS2V5KSlcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIGlmIChtZXRhZGF0YU1hcC5zaXplID4gMClcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgdmFyIHRhcmdldE1ldGFkYXRhID0gTWV0YWRhdGEuZ2V0KHRhcmdldCk7XHJcbiAgICAgICAgdGFyZ2V0TWV0YWRhdGEuZGVsZXRlKHByb3BlcnR5S2V5KTtcclxuICAgICAgICBpZiAodGFyZ2V0TWV0YWRhdGEuc2l6ZSA+IDApXHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIE1ldGFkYXRhLmRlbGV0ZSh0YXJnZXQpO1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgUmVmbGVjdC5kZWxldGVNZXRhZGF0YSA9IGRlbGV0ZU1ldGFkYXRhO1xyXG4gICAgZnVuY3Rpb24gRGVjb3JhdGVDb25zdHJ1Y3RvcihkZWNvcmF0b3JzLCB0YXJnZXQpIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xyXG4gICAgICAgICAgICB2YXIgZGVjb3JhdG9yID0gZGVjb3JhdG9yc1tpXTtcclxuICAgICAgICAgICAgdmFyIGRlY29yYXRlZCA9IGRlY29yYXRvcih0YXJnZXQpO1xyXG4gICAgICAgICAgICBpZiAoIUlzVW5kZWZpbmVkKGRlY29yYXRlZCkgJiYgIUlzTnVsbChkZWNvcmF0ZWQpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIUlzQ29uc3RydWN0b3IoZGVjb3JhdGVkKSlcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XHJcbiAgICAgICAgICAgICAgICB0YXJnZXQgPSBkZWNvcmF0ZWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRhcmdldDtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIERlY29yYXRlUHJvcGVydHkoZGVjb3JhdG9ycywgdGFyZ2V0LCBwcm9wZXJ0eUtleSwgZGVzY3JpcHRvcikge1xyXG4gICAgICAgIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XHJcbiAgICAgICAgICAgIHZhciBkZWNvcmF0b3IgPSBkZWNvcmF0b3JzW2ldO1xyXG4gICAgICAgICAgICB2YXIgZGVjb3JhdGVkID0gZGVjb3JhdG9yKHRhcmdldCwgcHJvcGVydHlLZXksIGRlc2NyaXB0b3IpO1xyXG4gICAgICAgICAgICBpZiAoIUlzVW5kZWZpbmVkKGRlY29yYXRlZCkgJiYgIUlzTnVsbChkZWNvcmF0ZWQpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIUlzT2JqZWN0KGRlY29yYXRlZCkpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xyXG4gICAgICAgICAgICAgICAgZGVzY3JpcHRvciA9IGRlY29yYXRlZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZGVzY3JpcHRvcjtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIEdldE9yQ3JlYXRlTWV0YWRhdGFNYXAoTywgUCwgQ3JlYXRlKSB7XHJcbiAgICAgICAgdmFyIHRhcmdldE1ldGFkYXRhID0gTWV0YWRhdGEuZ2V0KE8pO1xyXG4gICAgICAgIGlmIChJc1VuZGVmaW5lZCh0YXJnZXRNZXRhZGF0YSkpIHtcclxuICAgICAgICAgICAgaWYgKCFDcmVhdGUpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICB0YXJnZXRNZXRhZGF0YSA9IG5ldyBfTWFwKCk7XHJcbiAgICAgICAgICAgIE1ldGFkYXRhLnNldChPLCB0YXJnZXRNZXRhZGF0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBtZXRhZGF0YU1hcCA9IHRhcmdldE1ldGFkYXRhLmdldChQKTtcclxuICAgICAgICBpZiAoSXNVbmRlZmluZWQobWV0YWRhdGFNYXApKSB7XHJcbiAgICAgICAgICAgIGlmICghQ3JlYXRlKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgbWV0YWRhdGFNYXAgPSBuZXcgX01hcCgpO1xyXG4gICAgICAgICAgICB0YXJnZXRNZXRhZGF0YS5zZXQoUCwgbWV0YWRhdGFNYXApO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbWV0YWRhdGFNYXA7XHJcbiAgICB9XHJcbiAgICAvLyAzLjEuMS4xIE9yZGluYXJ5SGFzTWV0YWRhdGEoTWV0YWRhdGFLZXksIE8sIFApXHJcbiAgICAvLyBodHRwczovL3JidWNrdG9uLmdpdGh1Yi5pby9yZWZsZWN0LW1ldGFkYXRhLyNvcmRpbmFyeWhhc21ldGFkYXRhXHJcbiAgICBmdW5jdGlvbiBPcmRpbmFyeUhhc01ldGFkYXRhKE1ldGFkYXRhS2V5LCBPLCBQKSB7XHJcbiAgICAgICAgdmFyIGhhc093biA9IE9yZGluYXJ5SGFzT3duTWV0YWRhdGEoTWV0YWRhdGFLZXksIE8sIFApO1xyXG4gICAgICAgIGlmIChoYXNPd24pXHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIHZhciBwYXJlbnQgPSBPcmRpbmFyeUdldFByb3RvdHlwZU9mKE8pO1xyXG4gICAgICAgIGlmICghSXNOdWxsKHBhcmVudCkpXHJcbiAgICAgICAgICAgIHJldHVybiBPcmRpbmFyeUhhc01ldGFkYXRhKE1ldGFkYXRhS2V5LCBwYXJlbnQsIFApO1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIC8vIDMuMS4yLjEgT3JkaW5hcnlIYXNPd25NZXRhZGF0YShNZXRhZGF0YUtleSwgTywgUClcclxuICAgIC8vIGh0dHBzOi8vcmJ1Y2t0b24uZ2l0aHViLmlvL3JlZmxlY3QtbWV0YWRhdGEvI29yZGluYXJ5aGFzb3dubWV0YWRhdGFcclxuICAgIGZ1bmN0aW9uIE9yZGluYXJ5SGFzT3duTWV0YWRhdGEoTWV0YWRhdGFLZXksIE8sIFApIHtcclxuICAgICAgICB2YXIgbWV0YWRhdGFNYXAgPSBHZXRPckNyZWF0ZU1ldGFkYXRhTWFwKE8sIFAsIC8qQ3JlYXRlKi8gZmFsc2UpO1xyXG4gICAgICAgIGlmIChJc1VuZGVmaW5lZChtZXRhZGF0YU1hcCkpXHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICByZXR1cm4gVG9Cb29sZWFuKG1ldGFkYXRhTWFwLmhhcyhNZXRhZGF0YUtleSkpO1xyXG4gICAgfVxyXG4gICAgLy8gMy4xLjMuMSBPcmRpbmFyeUdldE1ldGFkYXRhKE1ldGFkYXRhS2V5LCBPLCBQKVxyXG4gICAgLy8gaHR0cHM6Ly9yYnVja3Rvbi5naXRodWIuaW8vcmVmbGVjdC1tZXRhZGF0YS8jb3JkaW5hcnlnZXRtZXRhZGF0YVxyXG4gICAgZnVuY3Rpb24gT3JkaW5hcnlHZXRNZXRhZGF0YShNZXRhZGF0YUtleSwgTywgUCkge1xyXG4gICAgICAgIHZhciBoYXNPd24gPSBPcmRpbmFyeUhhc093bk1ldGFkYXRhKE1ldGFkYXRhS2V5LCBPLCBQKTtcclxuICAgICAgICBpZiAoaGFzT3duKVxyXG4gICAgICAgICAgICByZXR1cm4gT3JkaW5hcnlHZXRPd25NZXRhZGF0YShNZXRhZGF0YUtleSwgTywgUCk7XHJcbiAgICAgICAgdmFyIHBhcmVudCA9IE9yZGluYXJ5R2V0UHJvdG90eXBlT2YoTyk7XHJcbiAgICAgICAgaWYgKCFJc051bGwocGFyZW50KSlcclxuICAgICAgICAgICAgcmV0dXJuIE9yZGluYXJ5R2V0TWV0YWRhdGEoTWV0YWRhdGFLZXksIHBhcmVudCwgUCk7XHJcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgIH1cclxuICAgIC8vIDMuMS40LjEgT3JkaW5hcnlHZXRPd25NZXRhZGF0YShNZXRhZGF0YUtleSwgTywgUClcclxuICAgIC8vIGh0dHBzOi8vcmJ1Y2t0b24uZ2l0aHViLmlvL3JlZmxlY3QtbWV0YWRhdGEvI29yZGluYXJ5Z2V0b3dubWV0YWRhdGFcclxuICAgIGZ1bmN0aW9uIE9yZGluYXJ5R2V0T3duTWV0YWRhdGEoTWV0YWRhdGFLZXksIE8sIFApIHtcclxuICAgICAgICB2YXIgbWV0YWRhdGFNYXAgPSBHZXRPckNyZWF0ZU1ldGFkYXRhTWFwKE8sIFAsIC8qQ3JlYXRlKi8gZmFsc2UpO1xyXG4gICAgICAgIGlmIChJc1VuZGVmaW5lZChtZXRhZGF0YU1hcCkpXHJcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgcmV0dXJuIG1ldGFkYXRhTWFwLmdldChNZXRhZGF0YUtleSk7XHJcbiAgICB9XHJcbiAgICAvLyAzLjEuNS4xIE9yZGluYXJ5RGVmaW5lT3duTWV0YWRhdGEoTWV0YWRhdGFLZXksIE1ldGFkYXRhVmFsdWUsIE8sIFApXHJcbiAgICAvLyBodHRwczovL3JidWNrdG9uLmdpdGh1Yi5pby9yZWZsZWN0LW1ldGFkYXRhLyNvcmRpbmFyeWRlZmluZW93bm1ldGFkYXRhXHJcbiAgICBmdW5jdGlvbiBPcmRpbmFyeURlZmluZU93bk1ldGFkYXRhKE1ldGFkYXRhS2V5LCBNZXRhZGF0YVZhbHVlLCBPLCBQKSB7XHJcbiAgICAgICAgdmFyIG1ldGFkYXRhTWFwID0gR2V0T3JDcmVhdGVNZXRhZGF0YU1hcChPLCBQLCAvKkNyZWF0ZSovIHRydWUpO1xyXG4gICAgICAgIG1ldGFkYXRhTWFwLnNldChNZXRhZGF0YUtleSwgTWV0YWRhdGFWYWx1ZSk7XHJcbiAgICB9XHJcbiAgICAvLyAzLjEuNi4xIE9yZGluYXJ5TWV0YWRhdGFLZXlzKE8sIFApXHJcbiAgICAvLyBodHRwczovL3JidWNrdG9uLmdpdGh1Yi5pby9yZWZsZWN0LW1ldGFkYXRhLyNvcmRpbmFyeW1ldGFkYXRha2V5c1xyXG4gICAgZnVuY3Rpb24gT3JkaW5hcnlNZXRhZGF0YUtleXMoTywgUCkge1xyXG4gICAgICAgIHZhciBvd25LZXlzID0gT3JkaW5hcnlPd25NZXRhZGF0YUtleXMoTywgUCk7XHJcbiAgICAgICAgdmFyIHBhcmVudCA9IE9yZGluYXJ5R2V0UHJvdG90eXBlT2YoTyk7XHJcbiAgICAgICAgaWYgKHBhcmVudCA9PT0gbnVsbClcclxuICAgICAgICAgICAgcmV0dXJuIG93bktleXM7XHJcbiAgICAgICAgdmFyIHBhcmVudEtleXMgPSBPcmRpbmFyeU1ldGFkYXRhS2V5cyhwYXJlbnQsIFApO1xyXG4gICAgICAgIGlmIChwYXJlbnRLZXlzLmxlbmd0aCA8PSAwKVxyXG4gICAgICAgICAgICByZXR1cm4gb3duS2V5cztcclxuICAgICAgICBpZiAob3duS2V5cy5sZW5ndGggPD0gMClcclxuICAgICAgICAgICAgcmV0dXJuIHBhcmVudEtleXM7XHJcbiAgICAgICAgdmFyIHNldCA9IG5ldyBfU2V0KCk7XHJcbiAgICAgICAgdmFyIGtleXMgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIG93bktleXNfMSA9IG93bktleXM7IF9pIDwgb3duS2V5c18xLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICB2YXIga2V5ID0gb3duS2V5c18xW19pXTtcclxuICAgICAgICAgICAgdmFyIGhhc0tleSA9IHNldC5oYXMoa2V5KTtcclxuICAgICAgICAgICAgaWYgKCFoYXNLZXkpIHtcclxuICAgICAgICAgICAgICAgIHNldC5hZGQoa2V5KTtcclxuICAgICAgICAgICAgICAgIGtleXMucHVzaChrZXkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAodmFyIF9hID0gMCwgcGFyZW50S2V5c18xID0gcGFyZW50S2V5czsgX2EgPCBwYXJlbnRLZXlzXzEubGVuZ3RoOyBfYSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBrZXkgPSBwYXJlbnRLZXlzXzFbX2FdO1xyXG4gICAgICAgICAgICB2YXIgaGFzS2V5ID0gc2V0LmhhcyhrZXkpO1xyXG4gICAgICAgICAgICBpZiAoIWhhc0tleSkge1xyXG4gICAgICAgICAgICAgICAgc2V0LmFkZChrZXkpO1xyXG4gICAgICAgICAgICAgICAga2V5cy5wdXNoKGtleSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGtleXM7XHJcbiAgICB9XHJcbiAgICAvLyAzLjEuNy4xIE9yZGluYXJ5T3duTWV0YWRhdGFLZXlzKE8sIFApXHJcbiAgICAvLyBodHRwczovL3JidWNrdG9uLmdpdGh1Yi5pby9yZWZsZWN0LW1ldGFkYXRhLyNvcmRpbmFyeW93bm1ldGFkYXRha2V5c1xyXG4gICAgZnVuY3Rpb24gT3JkaW5hcnlPd25NZXRhZGF0YUtleXMoTywgUCkge1xyXG4gICAgICAgIHZhciBrZXlzID0gW107XHJcbiAgICAgICAgdmFyIG1ldGFkYXRhTWFwID0gR2V0T3JDcmVhdGVNZXRhZGF0YU1hcChPLCBQLCAvKkNyZWF0ZSovIGZhbHNlKTtcclxuICAgICAgICBpZiAoSXNVbmRlZmluZWQobWV0YWRhdGFNYXApKVxyXG4gICAgICAgICAgICByZXR1cm4ga2V5cztcclxuICAgICAgICB2YXIga2V5c09iaiA9IG1ldGFkYXRhTWFwLmtleXMoKTtcclxuICAgICAgICB2YXIgaXRlcmF0b3IgPSBHZXRJdGVyYXRvcihrZXlzT2JqKTtcclxuICAgICAgICB2YXIgayA9IDA7XHJcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcclxuICAgICAgICAgICAgdmFyIG5leHQgPSBJdGVyYXRvclN0ZXAoaXRlcmF0b3IpO1xyXG4gICAgICAgICAgICBpZiAoIW5leHQpIHtcclxuICAgICAgICAgICAgICAgIGtleXMubGVuZ3RoID0gaztcclxuICAgICAgICAgICAgICAgIHJldHVybiBrZXlzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBuZXh0VmFsdWUgPSBJdGVyYXRvclZhbHVlKG5leHQpO1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAga2V5c1trXSA9IG5leHRWYWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICBJdGVyYXRvckNsb3NlKGl0ZXJhdG9yKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGZpbmFsbHkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IGU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaysrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIDYgRUNNQVNjcmlwdCBEYXRhIFR5cDBlcyBhbmQgVmFsdWVzXHJcbiAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1lY21hc2NyaXB0LWRhdGEtdHlwZXMtYW5kLXZhbHVlc1xyXG4gICAgZnVuY3Rpb24gVHlwZSh4KSB7XHJcbiAgICAgICAgaWYgKHggPT09IG51bGwpXHJcbiAgICAgICAgICAgIHJldHVybiAxIC8qIE51bGwgKi87XHJcbiAgICAgICAgc3dpdGNoICh0eXBlb2YgeCkge1xyXG4gICAgICAgICAgICBjYXNlIFwidW5kZWZpbmVkXCI6IHJldHVybiAwIC8qIFVuZGVmaW5lZCAqLztcclxuICAgICAgICAgICAgY2FzZSBcImJvb2xlYW5cIjogcmV0dXJuIDIgLyogQm9vbGVhbiAqLztcclxuICAgICAgICAgICAgY2FzZSBcInN0cmluZ1wiOiByZXR1cm4gMyAvKiBTdHJpbmcgKi87XHJcbiAgICAgICAgICAgIGNhc2UgXCJzeW1ib2xcIjogcmV0dXJuIDQgLyogU3ltYm9sICovO1xyXG4gICAgICAgICAgICBjYXNlIFwibnVtYmVyXCI6IHJldHVybiA1IC8qIE51bWJlciAqLztcclxuICAgICAgICAgICAgY2FzZSBcIm9iamVjdFwiOiByZXR1cm4geCA9PT0gbnVsbCA/IDEgLyogTnVsbCAqLyA6IDYgLyogT2JqZWN0ICovO1xyXG4gICAgICAgICAgICBkZWZhdWx0OiByZXR1cm4gNiAvKiBPYmplY3QgKi87XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gNi4xLjEgVGhlIFVuZGVmaW5lZCBUeXBlXHJcbiAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1lY21hc2NyaXB0LWxhbmd1YWdlLXR5cGVzLXVuZGVmaW5lZC10eXBlXHJcbiAgICBmdW5jdGlvbiBJc1VuZGVmaW5lZCh4KSB7XHJcbiAgICAgICAgcmV0dXJuIHggPT09IHVuZGVmaW5lZDtcclxuICAgIH1cclxuICAgIC8vIDYuMS4yIFRoZSBOdWxsIFR5cGVcclxuICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWVjbWFzY3JpcHQtbGFuZ3VhZ2UtdHlwZXMtbnVsbC10eXBlXHJcbiAgICBmdW5jdGlvbiBJc051bGwoeCkge1xyXG4gICAgICAgIHJldHVybiB4ID09PSBudWxsO1xyXG4gICAgfVxyXG4gICAgLy8gNi4xLjUgVGhlIFN5bWJvbCBUeXBlXHJcbiAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1lY21hc2NyaXB0LWxhbmd1YWdlLXR5cGVzLXN5bWJvbC10eXBlXHJcbiAgICBmdW5jdGlvbiBJc1N5bWJvbCh4KSB7XHJcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB4ID09PSBcInN5bWJvbFwiO1xyXG4gICAgfVxyXG4gICAgLy8gNi4xLjcgVGhlIE9iamVjdCBUeXBlXHJcbiAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1vYmplY3QtdHlwZVxyXG4gICAgZnVuY3Rpb24gSXNPYmplY3QoeCkge1xyXG4gICAgICAgIHJldHVybiB0eXBlb2YgeCA9PT0gXCJvYmplY3RcIiA/IHggIT09IG51bGwgOiB0eXBlb2YgeCA9PT0gXCJmdW5jdGlvblwiO1xyXG4gICAgfVxyXG4gICAgLy8gNy4xIFR5cGUgQ29udmVyc2lvblxyXG4gICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtdHlwZS1jb252ZXJzaW9uXHJcbiAgICAvLyA3LjEuMSBUb1ByaW1pdGl2ZShpbnB1dCBbLCBQcmVmZXJyZWRUeXBlXSlcclxuICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXRvcHJpbWl0aXZlXHJcbiAgICBmdW5jdGlvbiBUb1ByaW1pdGl2ZShpbnB1dCwgUHJlZmVycmVkVHlwZSkge1xyXG4gICAgICAgIHN3aXRjaCAoVHlwZShpbnB1dCkpIHtcclxuICAgICAgICAgICAgY2FzZSAwIC8qIFVuZGVmaW5lZCAqLzogcmV0dXJuIGlucHV0O1xyXG4gICAgICAgICAgICBjYXNlIDEgLyogTnVsbCAqLzogcmV0dXJuIGlucHV0O1xyXG4gICAgICAgICAgICBjYXNlIDIgLyogQm9vbGVhbiAqLzogcmV0dXJuIGlucHV0O1xyXG4gICAgICAgICAgICBjYXNlIDMgLyogU3RyaW5nICovOiByZXR1cm4gaW5wdXQ7XHJcbiAgICAgICAgICAgIGNhc2UgNCAvKiBTeW1ib2wgKi86IHJldHVybiBpbnB1dDtcclxuICAgICAgICAgICAgY2FzZSA1IC8qIE51bWJlciAqLzogcmV0dXJuIGlucHV0O1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgaGludCA9IFByZWZlcnJlZFR5cGUgPT09IDMgLyogU3RyaW5nICovID8gXCJzdHJpbmdcIiA6IFByZWZlcnJlZFR5cGUgPT09IDUgLyogTnVtYmVyICovID8gXCJudW1iZXJcIiA6IFwiZGVmYXVsdFwiO1xyXG4gICAgICAgIHZhciBleG90aWNUb1ByaW0gPSBHZXRNZXRob2QoaW5wdXQsIHRvUHJpbWl0aXZlU3ltYm9sKTtcclxuICAgICAgICBpZiAoZXhvdGljVG9QcmltICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGV4b3RpY1RvUHJpbS5jYWxsKGlucHV0LCBoaW50KTtcclxuICAgICAgICAgICAgaWYgKElzT2JqZWN0KHJlc3VsdCkpXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBPcmRpbmFyeVRvUHJpbWl0aXZlKGlucHV0LCBoaW50ID09PSBcImRlZmF1bHRcIiA/IFwibnVtYmVyXCIgOiBoaW50KTtcclxuICAgIH1cclxuICAgIC8vIDcuMS4xLjEgT3JkaW5hcnlUb1ByaW1pdGl2ZShPLCBoaW50KVxyXG4gICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtb3JkaW5hcnl0b3ByaW1pdGl2ZVxyXG4gICAgZnVuY3Rpb24gT3JkaW5hcnlUb1ByaW1pdGl2ZShPLCBoaW50KSB7XHJcbiAgICAgICAgaWYgKGhpbnQgPT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICAgICAgdmFyIHRvU3RyaW5nXzEgPSBPLnRvU3RyaW5nO1xyXG4gICAgICAgICAgICBpZiAoSXNDYWxsYWJsZSh0b1N0cmluZ18xKSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRvU3RyaW5nXzEuY2FsbChPKTtcclxuICAgICAgICAgICAgICAgIGlmICghSXNPYmplY3QocmVzdWx0KSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciB2YWx1ZU9mID0gTy52YWx1ZU9mO1xyXG4gICAgICAgICAgICBpZiAoSXNDYWxsYWJsZSh2YWx1ZU9mKSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHZhbHVlT2YuY2FsbChPKTtcclxuICAgICAgICAgICAgICAgIGlmICghSXNPYmplY3QocmVzdWx0KSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB2YXIgdmFsdWVPZiA9IE8udmFsdWVPZjtcclxuICAgICAgICAgICAgaWYgKElzQ2FsbGFibGUodmFsdWVPZikpIHtcclxuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSB2YWx1ZU9mLmNhbGwoTyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIUlzT2JqZWN0KHJlc3VsdCkpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgdG9TdHJpbmdfMiA9IE8udG9TdHJpbmc7XHJcbiAgICAgICAgICAgIGlmIChJc0NhbGxhYmxlKHRvU3RyaW5nXzIpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gdG9TdHJpbmdfMi5jYWxsKE8pO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFJc09iamVjdChyZXN1bHQpKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xyXG4gICAgfVxyXG4gICAgLy8gNy4xLjIgVG9Cb29sZWFuKGFyZ3VtZW50KVxyXG4gICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLzIwMTYvI3NlYy10b2Jvb2xlYW5cclxuICAgIGZ1bmN0aW9uIFRvQm9vbGVhbihhcmd1bWVudCkge1xyXG4gICAgICAgIHJldHVybiAhIWFyZ3VtZW50O1xyXG4gICAgfVxyXG4gICAgLy8gNy4xLjEyIFRvU3RyaW5nKGFyZ3VtZW50KVxyXG4gICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtdG9zdHJpbmdcclxuICAgIGZ1bmN0aW9uIFRvU3RyaW5nKGFyZ3VtZW50KSB7XHJcbiAgICAgICAgcmV0dXJuIFwiXCIgKyBhcmd1bWVudDtcclxuICAgIH1cclxuICAgIC8vIDcuMS4xNCBUb1Byb3BlcnR5S2V5KGFyZ3VtZW50KVxyXG4gICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtdG9wcm9wZXJ0eWtleVxyXG4gICAgZnVuY3Rpb24gVG9Qcm9wZXJ0eUtleShhcmd1bWVudCkge1xyXG4gICAgICAgIHZhciBrZXkgPSBUb1ByaW1pdGl2ZShhcmd1bWVudCwgMyAvKiBTdHJpbmcgKi8pO1xyXG4gICAgICAgIGlmIChJc1N5bWJvbChrZXkpKVxyXG4gICAgICAgICAgICByZXR1cm4ga2V5O1xyXG4gICAgICAgIHJldHVybiBUb1N0cmluZyhrZXkpO1xyXG4gICAgfVxyXG4gICAgLy8gNy4yIFRlc3RpbmcgYW5kIENvbXBhcmlzb24gT3BlcmF0aW9uc1xyXG4gICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtdGVzdGluZy1hbmQtY29tcGFyaXNvbi1vcGVyYXRpb25zXHJcbiAgICAvLyA3LjIuMiBJc0FycmF5KGFyZ3VtZW50KVxyXG4gICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtaXNhcnJheVxyXG4gICAgZnVuY3Rpb24gSXNBcnJheShhcmd1bWVudCkge1xyXG4gICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5XHJcbiAgICAgICAgICAgID8gQXJyYXkuaXNBcnJheShhcmd1bWVudClcclxuICAgICAgICAgICAgOiBhcmd1bWVudCBpbnN0YW5jZW9mIE9iamVjdFxyXG4gICAgICAgICAgICAgICAgPyBhcmd1bWVudCBpbnN0YW5jZW9mIEFycmF5XHJcbiAgICAgICAgICAgICAgICA6IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhcmd1bWVudCkgPT09IFwiW29iamVjdCBBcnJheV1cIjtcclxuICAgIH1cclxuICAgIC8vIDcuMi4zIElzQ2FsbGFibGUoYXJndW1lbnQpXHJcbiAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1pc2NhbGxhYmxlXHJcbiAgICBmdW5jdGlvbiBJc0NhbGxhYmxlKGFyZ3VtZW50KSB7XHJcbiAgICAgICAgLy8gTk9URTogVGhpcyBpcyBhbiBhcHByb3hpbWF0aW9uIGFzIHdlIGNhbm5vdCBjaGVjayBmb3IgW1tDYWxsXV0gaW50ZXJuYWwgbWV0aG9kLlxyXG4gICAgICAgIHJldHVybiB0eXBlb2YgYXJndW1lbnQgPT09IFwiZnVuY3Rpb25cIjtcclxuICAgIH1cclxuICAgIC8vIDcuMi40IElzQ29uc3RydWN0b3IoYXJndW1lbnQpXHJcbiAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1pc2NvbnN0cnVjdG9yXHJcbiAgICBmdW5jdGlvbiBJc0NvbnN0cnVjdG9yKGFyZ3VtZW50KSB7XHJcbiAgICAgICAgLy8gTk9URTogVGhpcyBpcyBhbiBhcHByb3hpbWF0aW9uIGFzIHdlIGNhbm5vdCBjaGVjayBmb3IgW1tDb25zdHJ1Y3RdXSBpbnRlcm5hbCBtZXRob2QuXHJcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBhcmd1bWVudCA9PT0gXCJmdW5jdGlvblwiO1xyXG4gICAgfVxyXG4gICAgLy8gNy4yLjcgSXNQcm9wZXJ0eUtleShhcmd1bWVudClcclxuICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWlzcHJvcGVydHlrZXlcclxuICAgIGZ1bmN0aW9uIElzUHJvcGVydHlLZXkoYXJndW1lbnQpIHtcclxuICAgICAgICBzd2l0Y2ggKFR5cGUoYXJndW1lbnQpKSB7XHJcbiAgICAgICAgICAgIGNhc2UgMyAvKiBTdHJpbmcgKi86IHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICBjYXNlIDQgLyogU3ltYm9sICovOiByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgZGVmYXVsdDogcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIDcuMyBPcGVyYXRpb25zIG9uIE9iamVjdHNcclxuICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW9wZXJhdGlvbnMtb24tb2JqZWN0c1xyXG4gICAgLy8gNy4zLjkgR2V0TWV0aG9kKFYsIFApXHJcbiAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1nZXRtZXRob2RcclxuICAgIGZ1bmN0aW9uIEdldE1ldGhvZChWLCBQKSB7XHJcbiAgICAgICAgdmFyIGZ1bmMgPSBWW1BdO1xyXG4gICAgICAgIGlmIChmdW5jID09PSB1bmRlZmluZWQgfHwgZnVuYyA9PT0gbnVsbClcclxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICBpZiAoIUlzQ2FsbGFibGUoZnVuYykpXHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcclxuICAgICAgICByZXR1cm4gZnVuYztcclxuICAgIH1cclxuICAgIC8vIDcuNCBPcGVyYXRpb25zIG9uIEl0ZXJhdG9yIE9iamVjdHNcclxuICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW9wZXJhdGlvbnMtb24taXRlcmF0b3Itb2JqZWN0c1xyXG4gICAgZnVuY3Rpb24gR2V0SXRlcmF0b3Iob2JqKSB7XHJcbiAgICAgICAgdmFyIG1ldGhvZCA9IEdldE1ldGhvZChvYmosIGl0ZXJhdG9yU3ltYm9sKTtcclxuICAgICAgICBpZiAoIUlzQ2FsbGFibGUobWV0aG9kKSlcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpOyAvLyBmcm9tIENhbGxcclxuICAgICAgICB2YXIgaXRlcmF0b3IgPSBtZXRob2QuY2FsbChvYmopO1xyXG4gICAgICAgIGlmICghSXNPYmplY3QoaXRlcmF0b3IpKVxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XHJcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yO1xyXG4gICAgfVxyXG4gICAgLy8gNy40LjQgSXRlcmF0b3JWYWx1ZShpdGVyUmVzdWx0KVxyXG4gICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLzIwMTYvI3NlYy1pdGVyYXRvcnZhbHVlXHJcbiAgICBmdW5jdGlvbiBJdGVyYXRvclZhbHVlKGl0ZXJSZXN1bHQpIHtcclxuICAgICAgICByZXR1cm4gaXRlclJlc3VsdC52YWx1ZTtcclxuICAgIH1cclxuICAgIC8vIDcuNC41IEl0ZXJhdG9yU3RlcChpdGVyYXRvcilcclxuICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWl0ZXJhdG9yc3RlcFxyXG4gICAgZnVuY3Rpb24gSXRlcmF0b3JTdGVwKGl0ZXJhdG9yKSB7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IGl0ZXJhdG9yLm5leHQoKTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0LmRvbmUgPyBmYWxzZSA6IHJlc3VsdDtcclxuICAgIH1cclxuICAgIC8vIDcuNC42IEl0ZXJhdG9yQ2xvc2UoaXRlcmF0b3IsIGNvbXBsZXRpb24pXHJcbiAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1pdGVyYXRvcmNsb3NlXHJcbiAgICBmdW5jdGlvbiBJdGVyYXRvckNsb3NlKGl0ZXJhdG9yKSB7XHJcbiAgICAgICAgdmFyIGYgPSBpdGVyYXRvcltcInJldHVyblwiXTtcclxuICAgICAgICBpZiAoZilcclxuICAgICAgICAgICAgZi5jYWxsKGl0ZXJhdG9yKTtcclxuICAgIH1cclxuICAgIC8vIDkuMSBPcmRpbmFyeSBPYmplY3QgSW50ZXJuYWwgTWV0aG9kcyBhbmQgSW50ZXJuYWwgU2xvdHNcclxuICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW9yZGluYXJ5LW9iamVjdC1pbnRlcm5hbC1tZXRob2RzLWFuZC1pbnRlcm5hbC1zbG90c1xyXG4gICAgLy8gOS4xLjEuMSBPcmRpbmFyeUdldFByb3RvdHlwZU9mKE8pXHJcbiAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1vcmRpbmFyeWdldHByb3RvdHlwZW9mXHJcbiAgICBmdW5jdGlvbiBPcmRpbmFyeUdldFByb3RvdHlwZU9mKE8pIHtcclxuICAgICAgICB2YXIgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTyk7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBPICE9PSBcImZ1bmN0aW9uXCIgfHwgTyA9PT0gZnVuY3Rpb25Qcm90b3R5cGUpXHJcbiAgICAgICAgICAgIHJldHVybiBwcm90bztcclxuICAgICAgICAvLyBUeXBlU2NyaXB0IGRvZXNuJ3Qgc2V0IF9fcHJvdG9fXyBpbiBFUzUsIGFzIGl0J3Mgbm9uLXN0YW5kYXJkLlxyXG4gICAgICAgIC8vIFRyeSB0byBkZXRlcm1pbmUgdGhlIHN1cGVyY2xhc3MgY29uc3RydWN0b3IuIENvbXBhdGlibGUgaW1wbGVtZW50YXRpb25zXHJcbiAgICAgICAgLy8gbXVzdCBlaXRoZXIgc2V0IF9fcHJvdG9fXyBvbiBhIHN1YmNsYXNzIGNvbnN0cnVjdG9yIHRvIHRoZSBzdXBlcmNsYXNzIGNvbnN0cnVjdG9yLFxyXG4gICAgICAgIC8vIG9yIGVuc3VyZSBlYWNoIGNsYXNzIGhhcyBhIHZhbGlkIGBjb25zdHJ1Y3RvcmAgcHJvcGVydHkgb24gaXRzIHByb3RvdHlwZSB0aGF0XHJcbiAgICAgICAgLy8gcG9pbnRzIGJhY2sgdG8gdGhlIGNvbnN0cnVjdG9yLlxyXG4gICAgICAgIC8vIElmIHRoaXMgaXMgbm90IHRoZSBzYW1lIGFzIEZ1bmN0aW9uLltbUHJvdG90eXBlXV0sIHRoZW4gdGhpcyBpcyBkZWZpbmF0ZWx5IGluaGVyaXRlZC5cclxuICAgICAgICAvLyBUaGlzIGlzIHRoZSBjYXNlIHdoZW4gaW4gRVM2IG9yIHdoZW4gdXNpbmcgX19wcm90b19fIGluIGEgY29tcGF0aWJsZSBicm93c2VyLlxyXG4gICAgICAgIGlmIChwcm90byAhPT0gZnVuY3Rpb25Qcm90b3R5cGUpXHJcbiAgICAgICAgICAgIHJldHVybiBwcm90bztcclxuICAgICAgICAvLyBJZiB0aGUgc3VwZXIgcHJvdG90eXBlIGlzIE9iamVjdC5wcm90b3R5cGUsIG51bGwsIG9yIHVuZGVmaW5lZCwgdGhlbiB3ZSBjYW5ub3QgZGV0ZXJtaW5lIHRoZSBoZXJpdGFnZS5cclxuICAgICAgICB2YXIgcHJvdG90eXBlID0gTy5wcm90b3R5cGU7XHJcbiAgICAgICAgdmFyIHByb3RvdHlwZVByb3RvID0gcHJvdG90eXBlICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZihwcm90b3R5cGUpO1xyXG4gICAgICAgIGlmIChwcm90b3R5cGVQcm90byA9PSBudWxsIHx8IHByb3RvdHlwZVByb3RvID09PSBPYmplY3QucHJvdG90eXBlKVxyXG4gICAgICAgICAgICByZXR1cm4gcHJvdG87XHJcbiAgICAgICAgLy8gSWYgdGhlIGNvbnN0cnVjdG9yIHdhcyBub3QgYSBmdW5jdGlvbiwgdGhlbiB3ZSBjYW5ub3QgZGV0ZXJtaW5lIHRoZSBoZXJpdGFnZS5cclxuICAgICAgICB2YXIgY29uc3RydWN0b3IgPSBwcm90b3R5cGVQcm90by5jb25zdHJ1Y3RvcjtcclxuICAgICAgICBpZiAodHlwZW9mIGNvbnN0cnVjdG9yICE9PSBcImZ1bmN0aW9uXCIpXHJcbiAgICAgICAgICAgIHJldHVybiBwcm90bztcclxuICAgICAgICAvLyBJZiB3ZSBoYXZlIHNvbWUga2luZCBvZiBzZWxmLXJlZmVyZW5jZSwgdGhlbiB3ZSBjYW5ub3QgZGV0ZXJtaW5lIHRoZSBoZXJpdGFnZS5cclxuICAgICAgICBpZiAoY29uc3RydWN0b3IgPT09IE8pXHJcbiAgICAgICAgICAgIHJldHVybiBwcm90bztcclxuICAgICAgICAvLyB3ZSBoYXZlIGEgcHJldHR5IGdvb2QgZ3Vlc3MgYXQgdGhlIGhlcml0YWdlLlxyXG4gICAgICAgIHJldHVybiBjb25zdHJ1Y3RvcjtcclxuICAgIH1cclxuICAgIC8vIG5haXZlIE1hcCBzaGltXHJcbiAgICBmdW5jdGlvbiBDcmVhdGVNYXBQb2x5ZmlsbCgpIHtcclxuICAgICAgICB2YXIgY2FjaGVTZW50aW5lbCA9IHt9O1xyXG4gICAgICAgIHZhciBhcnJheVNlbnRpbmVsID0gW107XHJcbiAgICAgICAgdmFyIE1hcEl0ZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgZnVuY3Rpb24gTWFwSXRlcmF0b3Ioa2V5cywgdmFsdWVzLCBzZWxlY3Rvcikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5faW5kZXggPSAwO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fa2V5cyA9IGtleXM7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl92YWx1ZXMgPSB2YWx1ZXM7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zZWxlY3RvciA9IHNlbGVjdG9yO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIE1hcEl0ZXJhdG9yLnByb3RvdHlwZVtcIkBAaXRlcmF0b3JcIl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9O1xyXG4gICAgICAgICAgICBNYXBJdGVyYXRvci5wcm90b3R5cGVbaXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfTtcclxuICAgICAgICAgICAgTWFwSXRlcmF0b3IucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSB0aGlzLl9pbmRleDtcclxuICAgICAgICAgICAgICAgIGlmIChpbmRleCA+PSAwICYmIGluZGV4IDwgdGhpcy5fa2V5cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5fc2VsZWN0b3IodGhpcy5fa2V5c1tpbmRleF0sIHRoaXMuX3ZhbHVlc1tpbmRleF0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCArIDEgPj0gdGhpcy5fa2V5cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5kZXggPSAtMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fa2V5cyA9IGFycmF5U2VudGluZWw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3ZhbHVlcyA9IGFycmF5U2VudGluZWw7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbmRleCsrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogcmVzdWx0LCBkb25lOiBmYWxzZSB9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBNYXBJdGVyYXRvci5wcm90b3R5cGUudGhyb3cgPSBmdW5jdGlvbiAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9pbmRleCA+PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5kZXggPSAtMTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9rZXlzID0gYXJyYXlTZW50aW5lbDtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl92YWx1ZXMgPSBhcnJheVNlbnRpbmVsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIE1hcEl0ZXJhdG9yLnByb3RvdHlwZS5yZXR1cm4gPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9pbmRleCA+PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5kZXggPSAtMTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9rZXlzID0gYXJyYXlTZW50aW5lbDtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl92YWx1ZXMgPSBhcnJheVNlbnRpbmVsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHZhbHVlLCBkb25lOiB0cnVlIH07XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHJldHVybiBNYXBJdGVyYXRvcjtcclxuICAgICAgICB9KCkpO1xyXG4gICAgICAgIHJldHVybiAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBNYXAoKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9rZXlzID0gW107XHJcbiAgICAgICAgICAgICAgICB0aGlzLl92YWx1ZXMgPSBbXTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2NhY2hlS2V5ID0gY2FjaGVTZW50aW5lbDtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2NhY2hlSW5kZXggPSAtMjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWFwLnByb3RvdHlwZSwgXCJzaXplXCIsIHtcclxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fa2V5cy5sZW5ndGg7IH0sXHJcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBNYXAucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIHRoaXMuX2ZpbmQoa2V5LCAvKmluc2VydCovIGZhbHNlKSA+PSAwOyB9O1xyXG4gICAgICAgICAgICBNYXAucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IHRoaXMuX2ZpbmQoa2V5LCAvKmluc2VydCovIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpbmRleCA+PSAwID8gdGhpcy5fdmFsdWVzW2luZGV4XSA6IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgTWFwLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5fZmluZChrZXksIC8qaW5zZXJ0Ki8gdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl92YWx1ZXNbaW5kZXhdID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgTWFwLnByb3RvdHlwZS5kZWxldGUgPSBmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSB0aGlzLl9maW5kKGtleSwgLyppbnNlcnQqLyBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPj0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzaXplID0gdGhpcy5fa2V5cy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IGluZGV4ICsgMTsgaSA8IHNpemU7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9rZXlzW2kgLSAxXSA9IHRoaXMuX2tleXNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3ZhbHVlc1tpIC0gMV0gPSB0aGlzLl92YWx1ZXNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2tleXMubGVuZ3RoLS07XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdmFsdWVzLmxlbmd0aC0tO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXkgPT09IHRoaXMuX2NhY2hlS2V5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NhY2hlS2V5ID0gY2FjaGVTZW50aW5lbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2FjaGVJbmRleCA9IC0yO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgTWFwLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2tleXMubGVuZ3RoID0gMDtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3ZhbHVlcy5sZW5ndGggPSAwO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fY2FjaGVLZXkgPSBjYWNoZVNlbnRpbmVsO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fY2FjaGVJbmRleCA9IC0yO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBNYXAucHJvdG90eXBlLmtleXMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgTWFwSXRlcmF0b3IodGhpcy5fa2V5cywgdGhpcy5fdmFsdWVzLCBnZXRLZXkpOyB9O1xyXG4gICAgICAgICAgICBNYXAucHJvdG90eXBlLnZhbHVlcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBNYXBJdGVyYXRvcih0aGlzLl9rZXlzLCB0aGlzLl92YWx1ZXMsIGdldFZhbHVlKTsgfTtcclxuICAgICAgICAgICAgTWFwLnByb3RvdHlwZS5lbnRyaWVzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IE1hcEl0ZXJhdG9yKHRoaXMuX2tleXMsIHRoaXMuX3ZhbHVlcywgZ2V0RW50cnkpOyB9O1xyXG4gICAgICAgICAgICBNYXAucHJvdG90eXBlW1wiQEBpdGVyYXRvclwiXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuZW50cmllcygpOyB9O1xyXG4gICAgICAgICAgICBNYXAucHJvdG90eXBlW2l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuZW50cmllcygpOyB9O1xyXG4gICAgICAgICAgICBNYXAucHJvdG90eXBlLl9maW5kID0gZnVuY3Rpb24gKGtleSwgaW5zZXJ0KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fY2FjaGVLZXkgIT09IGtleSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NhY2hlSW5kZXggPSB0aGlzLl9rZXlzLmluZGV4T2YodGhpcy5fY2FjaGVLZXkgPSBrZXkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2NhY2hlSW5kZXggPCAwICYmIGluc2VydCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NhY2hlSW5kZXggPSB0aGlzLl9rZXlzLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9rZXlzLnB1c2goa2V5KTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl92YWx1ZXMucHVzaCh1bmRlZmluZWQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NhY2hlSW5kZXg7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHJldHVybiBNYXA7XHJcbiAgICAgICAgfSgpKTtcclxuICAgICAgICBmdW5jdGlvbiBnZXRLZXkoa2V5LCBfKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBrZXk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZ1bmN0aW9uIGdldFZhbHVlKF8sIHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZnVuY3Rpb24gZ2V0RW50cnkoa2V5LCB2YWx1ZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gW2tleSwgdmFsdWVdO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIG5haXZlIFNldCBzaGltXHJcbiAgICBmdW5jdGlvbiBDcmVhdGVTZXRQb2x5ZmlsbCgpIHtcclxuICAgICAgICByZXR1cm4gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgZnVuY3Rpb24gU2V0KCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbWFwID0gbmV3IF9NYXAoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU2V0LnByb3RvdHlwZSwgXCJzaXplXCIsIHtcclxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fbWFwLnNpemU7IH0sXHJcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBTZXQucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gdGhpcy5fbWFwLmhhcyh2YWx1ZSk7IH07XHJcbiAgICAgICAgICAgIFNldC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiB0aGlzLl9tYXAuc2V0KHZhbHVlLCB2YWx1ZSksIHRoaXM7IH07XHJcbiAgICAgICAgICAgIFNldC5wcm90b3R5cGUuZGVsZXRlID0gZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiB0aGlzLl9tYXAuZGVsZXRlKHZhbHVlKTsgfTtcclxuICAgICAgICAgICAgU2V0LnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHsgdGhpcy5fbWFwLmNsZWFyKCk7IH07XHJcbiAgICAgICAgICAgIFNldC5wcm90b3R5cGUua2V5cyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX21hcC5rZXlzKCk7IH07XHJcbiAgICAgICAgICAgIFNldC5wcm90b3R5cGUudmFsdWVzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fbWFwLnZhbHVlcygpOyB9O1xyXG4gICAgICAgICAgICBTZXQucHJvdG90eXBlLmVudHJpZXMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9tYXAuZW50cmllcygpOyB9O1xyXG4gICAgICAgICAgICBTZXQucHJvdG90eXBlW1wiQEBpdGVyYXRvclwiXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMua2V5cygpOyB9O1xyXG4gICAgICAgICAgICBTZXQucHJvdG90eXBlW2l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMua2V5cygpOyB9O1xyXG4gICAgICAgICAgICByZXR1cm4gU2V0O1xyXG4gICAgICAgIH0oKSk7XHJcbiAgICB9XHJcbiAgICAvLyBuYWl2ZSBXZWFrTWFwIHNoaW1cclxuICAgIGZ1bmN0aW9uIENyZWF0ZVdlYWtNYXBQb2x5ZmlsbCgpIHtcclxuICAgICAgICB2YXIgVVVJRF9TSVpFID0gMTY7XHJcbiAgICAgICAgdmFyIGtleXMgPSBIYXNoTWFwLmNyZWF0ZSgpO1xyXG4gICAgICAgIHZhciByb290S2V5ID0gQ3JlYXRlVW5pcXVlS2V5KCk7XHJcbiAgICAgICAgcmV0dXJuIChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIFdlYWtNYXAoKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9rZXkgPSBDcmVhdGVVbmlxdWVLZXkoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBXZWFrTWFwLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiAodGFyZ2V0KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdGFibGUgPSBHZXRPckNyZWF0ZVdlYWtNYXBUYWJsZSh0YXJnZXQsIC8qY3JlYXRlKi8gZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhYmxlICE9PSB1bmRlZmluZWQgPyBIYXNoTWFwLmhhcyh0YWJsZSwgdGhpcy5fa2V5KSA6IGZhbHNlO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBXZWFrTWFwLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAodGFyZ2V0KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdGFibGUgPSBHZXRPckNyZWF0ZVdlYWtNYXBUYWJsZSh0YXJnZXQsIC8qY3JlYXRlKi8gZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhYmxlICE9PSB1bmRlZmluZWQgPyBIYXNoTWFwLmdldCh0YWJsZSwgdGhpcy5fa2V5KSA6IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgV2Vha01hcC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKHRhcmdldCwgdmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIHZhciB0YWJsZSA9IEdldE9yQ3JlYXRlV2Vha01hcFRhYmxlKHRhcmdldCwgLypjcmVhdGUqLyB0cnVlKTtcclxuICAgICAgICAgICAgICAgIHRhYmxlW3RoaXMuX2tleV0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBXZWFrTWFwLnByb3RvdHlwZS5kZWxldGUgPSBmdW5jdGlvbiAodGFyZ2V0KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdGFibGUgPSBHZXRPckNyZWF0ZVdlYWtNYXBUYWJsZSh0YXJnZXQsIC8qY3JlYXRlKi8gZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhYmxlICE9PSB1bmRlZmluZWQgPyBkZWxldGUgdGFibGVbdGhpcy5fa2V5XSA6IGZhbHNlO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBXZWFrTWFwLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIC8vIE5PVEU6IG5vdCBhIHJlYWwgY2xlYXIsIGp1c3QgbWFrZXMgdGhlIHByZXZpb3VzIGRhdGEgdW5yZWFjaGFibGVcclxuICAgICAgICAgICAgICAgIHRoaXMuX2tleSA9IENyZWF0ZVVuaXF1ZUtleSgpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICByZXR1cm4gV2Vha01hcDtcclxuICAgICAgICB9KCkpO1xyXG4gICAgICAgIGZ1bmN0aW9uIENyZWF0ZVVuaXF1ZUtleSgpIHtcclxuICAgICAgICAgICAgdmFyIGtleTtcclxuICAgICAgICAgICAgZG9cclxuICAgICAgICAgICAgICAgIGtleSA9IFwiQEBXZWFrTWFwQEBcIiArIENyZWF0ZVVVSUQoKTtcclxuICAgICAgICAgICAgd2hpbGUgKEhhc2hNYXAuaGFzKGtleXMsIGtleSkpO1xyXG4gICAgICAgICAgICBrZXlzW2tleV0gPSB0cnVlO1xyXG4gICAgICAgICAgICByZXR1cm4ga2V5O1xyXG4gICAgICAgIH1cclxuICAgICAgICBmdW5jdGlvbiBHZXRPckNyZWF0ZVdlYWtNYXBUYWJsZSh0YXJnZXQsIGNyZWF0ZSkge1xyXG4gICAgICAgICAgICBpZiAoIWhhc093bi5jYWxsKHRhcmdldCwgcm9vdEtleSkpIHtcclxuICAgICAgICAgICAgICAgIGlmICghY3JlYXRlKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCByb290S2V5LCB7IHZhbHVlOiBIYXNoTWFwLmNyZWF0ZSgpIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0YXJnZXRbcm9vdEtleV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZ1bmN0aW9uIEZpbGxSYW5kb21CeXRlcyhidWZmZXIsIHNpemUpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaXplOyArK2kpXHJcbiAgICAgICAgICAgICAgICBidWZmZXJbaV0gPSBNYXRoLnJhbmRvbSgpICogMHhmZiB8IDA7XHJcbiAgICAgICAgICAgIHJldHVybiBidWZmZXI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZ1bmN0aW9uIEdlblJhbmRvbUJ5dGVzKHNpemUpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBVaW50OEFycmF5ID09PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY3J5cHRvICE9PSBcInVuZGVmaW5lZFwiKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50OEFycmF5KHNpemUpKTtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbXNDcnlwdG8gIT09IFwidW5kZWZpbmVkXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1zQ3J5cHRvLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDhBcnJheShzaXplKSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gRmlsbFJhbmRvbUJ5dGVzKG5ldyBVaW50OEFycmF5KHNpemUpLCBzaXplKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gRmlsbFJhbmRvbUJ5dGVzKG5ldyBBcnJheShzaXplKSwgc2l6ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZ1bmN0aW9uIENyZWF0ZVVVSUQoKSB7XHJcbiAgICAgICAgICAgIHZhciBkYXRhID0gR2VuUmFuZG9tQnl0ZXMoVVVJRF9TSVpFKTtcclxuICAgICAgICAgICAgLy8gbWFyayBhcyByYW5kb20gLSBSRkMgNDEyMiDCpyA0LjRcclxuICAgICAgICAgICAgZGF0YVs2XSA9IGRhdGFbNl0gJiAweDRmIHwgMHg0MDtcclxuICAgICAgICAgICAgZGF0YVs4XSA9IGRhdGFbOF0gJiAweGJmIHwgMHg4MDtcclxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFwiXCI7XHJcbiAgICAgICAgICAgIGZvciAodmFyIG9mZnNldCA9IDA7IG9mZnNldCA8IFVVSURfU0laRTsgKytvZmZzZXQpIHtcclxuICAgICAgICAgICAgICAgIHZhciBieXRlID0gZGF0YVtvZmZzZXRdO1xyXG4gICAgICAgICAgICAgICAgaWYgKG9mZnNldCA9PT0gNCB8fCBvZmZzZXQgPT09IDYgfHwgb2Zmc2V0ID09PSA4KVxyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBcIi1cIjtcclxuICAgICAgICAgICAgICAgIGlmIChieXRlIDwgMTYpXHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IFwiMFwiO1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IGJ5dGUudG9TdHJpbmcoMTYpLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyB1c2VzIGEgaGV1cmlzdGljIHVzZWQgYnkgdjggYW5kIGNoYWtyYSB0byBmb3JjZSBhbiBvYmplY3QgaW50byBkaWN0aW9uYXJ5IG1vZGUuXHJcbiAgICBmdW5jdGlvbiBNYWtlRGljdGlvbmFyeShvYmopIHtcclxuICAgICAgICBvYmouX18gPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgZGVsZXRlIG9iai5fXztcclxuICAgICAgICByZXR1cm4gb2JqO1xyXG4gICAgfVxyXG4gICAgLy8gcGF0Y2ggZ2xvYmFsIFJlZmxlY3RcclxuICAgIChmdW5jdGlvbiAoX19nbG9iYWwpIHtcclxuICAgICAgICBpZiAodHlwZW9mIF9fZ2xvYmFsLlJlZmxlY3QgIT09IFwidW5kZWZpbmVkXCIpIHtcclxuICAgICAgICAgICAgaWYgKF9fZ2xvYmFsLlJlZmxlY3QgIT09IFJlZmxlY3QpIHtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIHAgaW4gUmVmbGVjdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChoYXNPd24uY2FsbChSZWZsZWN0LCBwKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfX2dsb2JhbC5SZWZsZWN0W3BdID0gUmVmbGVjdFtwXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIF9fZ2xvYmFsLlJlZmxlY3QgPSBSZWZsZWN0O1xyXG4gICAgICAgIH1cclxuICAgIH0pKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOlxyXG4gICAgICAgIHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6XHJcbiAgICAgICAgICAgIEZ1bmN0aW9uKFwicmV0dXJuIHRoaXM7XCIpKCkpO1xyXG59KShSZWZsZWN0IHx8IChSZWZsZWN0ID0ge30pKTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UmVmbGVjdC5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9yZWZsZWN0LW1ldGFkYXRhL1JlZmxlY3QuanNcbi8vIG1vZHVsZSBpZCA9IDY3XG4vLyBtb2R1bGUgY2h1bmtzID0gNCIsIm1vZHVsZS5leHBvcnRzID0gKF9fd2VicGFja19yZXF1aXJlX18oMikpKDM1Nyk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZGVsZWdhdGVkIC4vbm9kZV9tb2R1bGVzL3pvbmUuanMvZGlzdC96b25lLW5vZGUuanMgZnJvbSBkbGwtcmVmZXJlbmNlIC4vdmVuZG9yXG4vLyBtb2R1bGUgaWQgPSA2OFxuLy8gbW9kdWxlIGNodW5rcyA9IDQiLCJtb2R1bGUuZXhwb3J0cyA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKDIpKSgyMjUpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGRlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9yeGpzL2FkZC9vcGVyYXRvci9maXJzdC5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgLi92ZW5kb3Jcbi8vIG1vZHVsZSBpZCA9IDY5XG4vLyBtb2R1bGUgY2h1bmtzID0gNCIsIm1vZHVsZS5leHBvcnRzID0gKF9fd2VicGFja19yZXF1aXJlX18oMikpKDY2KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBkZWxlZ2F0ZWQgLi9ub2RlX21vZHVsZXMvcnhqcy9vYnNlcnZhYmxlL29mLmpzIGZyb20gZGxsLXJlZmVyZW5jZSAuL3ZlbmRvclxuLy8gbW9kdWxlIGlkID0gNzBcbi8vIG1vZHVsZSBjaHVua3MgPSA0IiwibW9kdWxlLmV4cG9ydHMgPSAoX193ZWJwYWNrX3JlcXVpcmVfXygyKSkoNzMpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGRlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9yeGpzL29wZXJhdG9yL2NvbmNhdE1hcC5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgLi92ZW5kb3Jcbi8vIG1vZHVsZSBpZCA9IDcxXG4vLyBtb2R1bGUgY2h1bmtzID0gNCIsIm1vZHVsZS5leHBvcnRzID0gKF9fd2VicGFja19yZXF1aXJlX18oMikpKDIxKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBkZWxlZ2F0ZWQgLi9ub2RlX21vZHVsZXMvcnhqcy9vcGVyYXRvci9tYXAuanMgZnJvbSBkbGwtcmVmZXJlbmNlIC4vdmVuZG9yXG4vLyBtb2R1bGUgaWQgPSA3MlxuLy8gbW9kdWxlIGNodW5rcyA9IDQiLCJtb2R1bGUuZXhwb3J0cyA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKDIpKSgzNzgpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGRlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9AYW5ndWxhci9wbGF0Zm9ybS1icm93c2VyLWR5bmFtaWMvYnVuZGxlcy9wbGF0Zm9ybS1icm93c2VyLWR5bmFtaWMudW1kLmpzIGZyb20gZGxsLXJlZmVyZW5jZSAuL3ZlbmRvclxuLy8gbW9kdWxlIGlkID0gNzNcbi8vIG1vZHVsZSBjaHVua3MgPSA0IiwibW9kdWxlLmV4cG9ydHMgPSAoX193ZWJwYWNrX3JlcXVpcmVfXygyKSkoNTYpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGRlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9AYW5ndWxhci9jb21waWxlci9idW5kbGVzL2NvbXBpbGVyLnVtZC5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgLi92ZW5kb3Jcbi8vIG1vZHVsZSBpZCA9IDc0XG4vLyBtb2R1bGUgY2h1bmtzID0gNCIsIm1vZHVsZS5leHBvcnRzID0gKF9fd2VicGFja19yZXF1aXJlX18oMikpKDc3KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBkZWxlZ2F0ZWQgLi9ub2RlX21vZHVsZXMvcnhqcy9vcGVyYXRvci9maXJzdC5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgLi92ZW5kb3Jcbi8vIG1vZHVsZSBpZCA9IDc1XG4vLyBtb2R1bGUgY2h1bmtzID0gNCIsIm1vZHVsZS5leHBvcnRzID0gKF9fd2VicGFja19yZXF1aXJlX18oMikpKDMzNCk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZGVsZWdhdGVkIC4vbm9kZV9tb2R1bGVzL3J4anMvb3BlcmF0b3IvdG9Qcm9taXNlLmpzIGZyb20gZGxsLXJlZmVyZW5jZSAuL3ZlbmRvclxuLy8gbW9kdWxlIGlkID0gNzZcbi8vIG1vZHVsZSBjaHVua3MgPSA0IiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgRE9NSW1wbGVtZW50YXRpb24gPSByZXF1aXJlKCcuL0RPTUltcGxlbWVudGF0aW9uJyk7XG52YXIgSFRNTFBhcnNlciA9IHJlcXVpcmUoJy4vSFRNTFBhcnNlcicpO1xudmFyIFdpbmRvdyA9IHJlcXVpcmUoJy4vV2luZG93Jyk7XG5cbmV4cG9ydHMuY3JlYXRlRE9NSW1wbGVtZW50YXRpb24gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBET01JbXBsZW1lbnRhdGlvbigpO1xufTtcblxuZXhwb3J0cy5jcmVhdGVEb2N1bWVudCA9IGZ1bmN0aW9uKGh0bWwsIGZvcmNlKSB7XG4gIC8vIFByZXZpb3VzIEFQSSBjb3VsZG4ndCBsZXQgeW91IHBhc3MgJycgYXMgYSBkb2N1bWVudCwgYW5kIHRoYXRcbiAgLy8geWllbGRzIGEgc2xpZ2h0bHkgZGlmZmVyZW50IGRvY3VtZW50IHRoYW4gY3JlYXRlSFRNTERvY3VtZW50KCcnKVxuICAvLyBkb2VzLiAgVGhlIG5ldyBgZm9yY2VgIHBhcmFtZXRlciBsZXRzIHlvdSBwYXNzICcnIGlmIHlvdSB3YW50IHRvLlxuICBpZiAoaHRtbCB8fCBmb3JjZSkge1xuICAgIHZhciBwYXJzZXIgPSBuZXcgSFRNTFBhcnNlcigpO1xuICAgIHBhcnNlci5wYXJzZShodG1sIHx8ICcnLCB0cnVlKTtcbiAgICByZXR1cm4gcGFyc2VyLmRvY3VtZW50KCk7XG4gIH1cbiAgcmV0dXJuIG5ldyBET01JbXBsZW1lbnRhdGlvbigpLmNyZWF0ZUhUTUxEb2N1bWVudChcIlwiKTtcbn07XG5cbmV4cG9ydHMuY3JlYXRlV2luZG93ID0gZnVuY3Rpb24oaHRtbCwgYWRkcmVzcykge1xuICB2YXIgZG9jdW1lbnQgPSBleHBvcnRzLmNyZWF0ZURvY3VtZW50KGh0bWwpO1xuICBpZiAoYWRkcmVzcyAhPT0gdW5kZWZpbmVkKSB7IGRvY3VtZW50Ll9hZGRyZXNzID0gYWRkcmVzczsgfVxuICByZXR1cm4gbmV3IFdpbmRvdyhkb2N1bWVudCk7XG59O1xuXG5leHBvcnRzLmltcGwgPSByZXF1aXJlKCcuL2ltcGwnKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2RvbWluby9saWIvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDc3XG4vLyBtb2R1bGUgY2h1bmtzID0gNCIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBGaWx0ZXJlZEVsZW1lbnRMaXN0O1xuXG52YXIgTm9kZSA9IHJlcXVpcmUoJy4vTm9kZScpO1xuXG4vL1xuLy8gVGhpcyBmaWxlIGRlZmluZXMgbm9kZSBsaXN0IGltcGxlbWVudGF0aW9uIHRoYXQgbGF6aWx5IHRyYXZlcnNlc1xuLy8gdGhlIGRvY3VtZW50IHRyZWUgKG9yIGEgc3VidHJlZSByb290ZWQgYXQgYW55IGVsZW1lbnQpIGFuZCBpbmNsdWRlc1xuLy8gb25seSB0aG9zZSBlbGVtZW50cyBmb3Igd2hpY2ggYSBzcGVjaWZpZWQgZmlsdGVyIGZ1bmN0aW9uIHJldHVybnMgdHJ1ZS5cbi8vIEl0IGlzIHVzZWQgdG8gaW1wbGVtZW50IHRoZVxuLy8ge0RvY3VtZW50LEVsZW1lbnR9LmdldEVsZW1lbnRzQnl7VGFnTmFtZSxDbGFzc05hbWV9eyxOU30gbWV0aG9kcy5cbi8vXG5cbmZ1bmN0aW9uIEZpbHRlcmVkRWxlbWVudExpc3Qocm9vdCwgZmlsdGVyKSB7XG4gIHRoaXMucm9vdCA9IHJvb3Q7XG4gIHRoaXMuZmlsdGVyID0gZmlsdGVyO1xuICB0aGlzLmxhc3RNb2RUaW1lID0gcm9vdC5sYXN0TW9kVGltZTtcbiAgdGhpcy5kb25lID0gZmFsc2U7XG4gIHRoaXMuY2FjaGUgPSBbXTtcbiAgdGhpcy50cmF2ZXJzZSgpO1xufVxuXG5GaWx0ZXJlZEVsZW1lbnRMaXN0LnByb3RvdHlwZSA9IHtcbiAgZ2V0IGxlbmd0aCgpIHtcbiAgICB0aGlzLmNoZWNrY2FjaGUoKTtcbiAgICBpZiAoIXRoaXMuZG9uZSkgdGhpcy50cmF2ZXJzZSgpO1xuICAgIHJldHVybiB0aGlzLmNhY2hlLmxlbmd0aDtcbiAgfSxcblxuICBpdGVtOiBmdW5jdGlvbihuKSB7XG4gICAgdGhpcy5jaGVja2NhY2hlKCk7XG4gICAgaWYgKCF0aGlzLmRvbmUgJiYgbiA+PSB0aGlzLmNhY2hlLmxlbmd0aCkgdGhpcy50cmF2ZXJzZShuKTtcbiAgICByZXR1cm4gdGhpcy5jYWNoZVtuXTtcbiAgfSxcblxuICBjaGVja2NhY2hlOiBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5sYXN0TW9kVGltZSAhPT0gdGhpcy5yb290Lmxhc3RNb2RUaW1lKSB7XG4gICAgICAvLyBzdWJ0cmVlIGhhcyBjaGFuZ2VkLCBzbyBpbnZhbGlkYXRlIGNhY2hlXG4gICAgICBmb3IgKHZhciBpID0gdGhpcy5jYWNoZS5sZW5ndGgtMTsgaT49MDsgaS0tKSB7XG4gICAgICAgIHRoaXNbaV0gPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICB0aGlzLmNhY2hlLmxlbmd0aCA9IDA7XG4gICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgIHRoaXMubGFzdE1vZFRpbWUgPSB0aGlzLnJvb3QubGFzdE1vZFRpbWU7XG4gICAgfVxuICB9LFxuXG4gIC8vIElmIG4gaXMgc3BlY2lmaWVkLCB0aGVuIHRyYXZlcnNlIHRoZSB0cmVlIHVudGlsIHdlJ3ZlIGZvdW5kIHRoZSBudGhcbiAgLy8gaXRlbSAob3IgdW50aWwgd2UndmUgZm91bmQgYWxsIGl0ZW1zKS4gIElmIG4gaXMgbm90IHNwZWNpZmllZCxcbiAgLy8gdHJhdmVyc2UgdW50aWwgd2UndmUgZm91bmQgYWxsIGl0ZW1zLlxuICB0cmF2ZXJzZTogZnVuY3Rpb24obikge1xuICAgIC8vIGluY3JlbWVudCBuIHNvIHdlIGNhbiBjb21wYXJlIHRvIGxlbmd0aCwgYW5kIHNvIGl0IGlzIG5ldmVyIGZhbHN5XG4gICAgaWYgKG4gIT09IHVuZGVmaW5lZCkgbisrO1xuXG4gICAgdmFyIGVsdDtcbiAgICB3aGlsZSAoKGVsdCA9IHRoaXMubmV4dCgpKSAhPT0gbnVsbCkge1xuICAgICAgdGhpc1t0aGlzLmNhY2hlLmxlbmd0aF0gPSBlbHQ7IC8vWFhYIFVzZSBwcm94eSBpbnN0ZWFkXG4gICAgICB0aGlzLmNhY2hlLnB1c2goZWx0KTtcbiAgICAgIGlmIChuICYmIHRoaXMuY2FjaGUubGVuZ3RoID09PSBuKSByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gbm8gbmV4dCBlbGVtZW50LCBzbyB3ZSd2ZSBmb3VuZCBldmVyeXRoaW5nXG4gICAgdGhpcy5kb25lID0gdHJ1ZTtcbiAgfSxcblxuICAvLyBSZXR1cm4gdGhlIG5leHQgZWxlbWVudCB1bmRlciByb290IHRoYXQgbWF0Y2hlcyBmaWx0ZXJcbiAgbmV4dDogZnVuY3Rpb24oKSB7XG4gICAgdmFyIHN0YXJ0ID0gKHRoaXMuY2FjaGUubGVuZ3RoID09PSAwKSA/IHRoaXMucm9vdCAvLyBTdGFydCBhdCB0aGUgcm9vdCBvciBhdFxuICAgICAgOiB0aGlzLmNhY2hlW3RoaXMuY2FjaGUubGVuZ3RoLTFdOyAvLyB0aGUgbGFzdCBlbGVtZW50IHdlIGZvdW5kXG5cbiAgICB2YXIgZWx0O1xuICAgIGlmIChzdGFydC5ub2RlVHlwZSA9PT0gTm9kZS5ET0NVTUVOVF9OT0RFKVxuICAgICAgZWx0ID0gc3RhcnQuZG9jdW1lbnRFbGVtZW50O1xuICAgIGVsc2VcbiAgICAgIGVsdCA9IHN0YXJ0Lm5leHRFbGVtZW50KHRoaXMucm9vdCk7XG5cbiAgICB3aGlsZShlbHQpIHtcbiAgICAgIGlmICh0aGlzLmZpbHRlcihlbHQpKSB7XG4gICAgICAgIHJldHVybiBlbHQ7XG4gICAgICB9XG5cbiAgICAgIGVsdCA9IGVsdC5uZXh0RWxlbWVudCh0aGlzLnJvb3QpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2RvbWluby9saWIvRmlsdGVyZWRFbGVtZW50TGlzdC5qc1xuLy8gbW9kdWxlIGlkID0gNzhcbi8vIG1vZHVsZSBjaHVua3MgPSA0IiwiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IFRyZWVXYWxrZXI7XG5cbnZhciBOb2RlRmlsdGVyID0gcmVxdWlyZSgnLi9Ob2RlRmlsdGVyJyk7XG52YXIgTm9kZVRyYXZlcnNhbCA9IHJlcXVpcmUoJy4vTm9kZVRyYXZlcnNhbCcpO1xuXG52YXIgbWFwQ2hpbGQgPSB7XG4gIGZpcnN0OiAnZmlyc3RDaGlsZCcsXG4gIGxhc3Q6ICdsYXN0Q2hpbGQnLFxuICBuZXh0OiAnZmlyc3RDaGlsZCcsXG4gIHByZXZpb3VzOiAnbGFzdENoaWxkJ1xufTtcblxudmFyIG1hcFNpYmxpbmcgPSB7XG4gIGZpcnN0OiAnbmV4dFNpYmxpbmcnLFxuICBsYXN0OiAncHJldmlvdXNTaWJsaW5nJyxcbiAgbmV4dDogJ25leHRTaWJsaW5nJyxcbiAgcHJldmlvdXM6ICdwcmV2aW91c1NpYmxpbmcnXG59O1xuXG4vKiBQcml2YXRlIG1ldGhvZHMgYW5kIGhlbHBlcnMgKi9cblxuLyoqXG4gKiBAc3BlYyBodHRwOi8vd3d3LnczLm9yZy9UUi9kb20vI2NvbmNlcHQtdHJhdmVyc2UtY2hpbGRyZW5cbiAqIEBtZXRob2RcbiAqIEBhY2Nlc3MgcHJpdmF0ZVxuICogQHBhcmFtIHtUcmVlV2Fsa2VyfSB0d1xuICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgT25lIG9mICdmaXJzdCcgb3IgJ2xhc3QnLlxuICogQHJldHVybiB7Tm9kZXxudWxsfVxuICovXG5mdW5jdGlvbiB0cmF2ZXJzZUNoaWxkcmVuKHR3LCB0eXBlKSB7XG4gIHZhciBjaGlsZCwgbm9kZSwgcGFyZW50LCByZXN1bHQsIHNpYmxpbmc7XG4gIG5vZGUgPSB0dy5jdXJyZW50Tm9kZVttYXBDaGlsZFt0eXBlXV07XG4gIHdoaWxlIChub2RlICE9PSBudWxsKSB7XG4gICAgcmVzdWx0ID0gdHcuZmlsdGVyLmFjY2VwdE5vZGUobm9kZSk7XG4gICAgaWYgKHJlc3VsdCA9PT0gTm9kZUZpbHRlci5GSUxURVJfQUNDRVBUKSB7XG4gICAgICB0dy5jdXJyZW50Tm9kZSA9IG5vZGU7XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gICAgaWYgKHJlc3VsdCA9PT0gTm9kZUZpbHRlci5GSUxURVJfU0tJUCkge1xuICAgICAgY2hpbGQgPSBub2RlW21hcENoaWxkW3R5cGVdXTtcbiAgICAgIGlmIChjaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICBub2RlID0gY2hpbGQ7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgIH1cbiAgICB3aGlsZSAobm9kZSAhPT0gbnVsbCkge1xuICAgICAgc2libGluZyA9IG5vZGVbbWFwU2libGluZ1t0eXBlXV07XG4gICAgICBpZiAoc2libGluZyAhPT0gbnVsbCkge1xuICAgICAgICBub2RlID0gc2libGluZztcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBwYXJlbnQgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgICBpZiAocGFyZW50ID09PSBudWxsIHx8IHBhcmVudCA9PT0gdHcucm9vdCB8fCBwYXJlbnQgPT09IHR3LmN1cnJlbnROb2RlKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIG5vZGUgPSBwYXJlbnQ7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIEBzcGVjIGh0dHA6Ly93d3cudzMub3JnL1RSL2RvbS8jY29uY2VwdC10cmF2ZXJzZS1zaWJsaW5nc1xuICogQG1ldGhvZFxuICogQGFjY2VzcyBwcml2YXRlXG4gKiBAcGFyYW0ge1RyZWVXYWxrZXJ9IHR3XG4gKiBAcGFyYW0ge1RyZWVXYWxrZXJ9IHR5cGUgT25lIG9mICduZXh0JyBvciAncHJldmlvdXMnLlxuICogQHJldHVybiB7Tm9kZXxudWx9XG4gKi9cbmZ1bmN0aW9uIHRyYXZlcnNlU2libGluZ3ModHcsIHR5cGUpIHtcbiAgdmFyIG5vZGUsIHJlc3VsdCwgc2libGluZztcbiAgbm9kZSA9IHR3LmN1cnJlbnROb2RlO1xuICBpZiAobm9kZSA9PT0gdHcucm9vdCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgc2libGluZyA9IG5vZGVbbWFwU2libGluZ1t0eXBlXV07XG4gICAgd2hpbGUgKHNpYmxpbmcgIT09IG51bGwpIHtcbiAgICAgIG5vZGUgPSBzaWJsaW5nO1xuICAgICAgcmVzdWx0ID0gdHcuZmlsdGVyLmFjY2VwdE5vZGUobm9kZSk7XG4gICAgICBpZiAocmVzdWx0ID09PSBOb2RlRmlsdGVyLkZJTFRFUl9BQ0NFUFQpIHtcbiAgICAgICAgdHcuY3VycmVudE5vZGUgPSBub2RlO1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgIH1cbiAgICAgIHNpYmxpbmcgPSBub2RlW21hcENoaWxkW3R5cGVdXTtcbiAgICAgIGlmIChyZXN1bHQgPT09IE5vZGVGaWx0ZXIuRklMVEVSX1JFSkVDVCB8fCBzaWJsaW5nID09PSBudWxsKSB7XG4gICAgICAgIHNpYmxpbmcgPSBub2RlW21hcFNpYmxpbmdbdHlwZV1dO1xuICAgICAgfVxuICAgIH1cbiAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgIGlmIChub2RlID09PSBudWxsIHx8IG5vZGUgPT09IHR3LnJvb3QpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAodHcuZmlsdGVyLmFjY2VwdE5vZGUobm9kZSkgPT09IE5vZGVGaWx0ZXIuRklMVEVSX0FDQ0VQVCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG59XG5cblxuLyogUHVibGljIEFQSSAqL1xuXG4vKipcbiAqIEltcGxlbWVudGVkIHZlcnNpb246IGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTUvV0QtZG9tLTIwMTUwNjE4LyNpbnRlcmZhY2UtdHJlZXdhbGtlclxuICogTGF0ZXN0IHZlcnNpb246IGh0dHA6Ly93d3cudzMub3JnL1RSL2RvbS8jaW50ZXJmYWNlLXRyZWV3YWxrZXJcbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7Tm9kZX0gcm9vdFxuICogQHBhcmFtIHtudW1iZXJ9IHdoYXRUb1Nob3cgW29wdGlvbmFsXVxuICogQHBhcmFtIHtGdW5jdGlvbnxOb2RlRmlsdGVyfSBmaWx0ZXIgW29wdGlvbmFsXVxuICogQHRocm93cyBFcnJvclxuICovXG5mdW5jdGlvbiBUcmVlV2Fsa2VyKHJvb3QsIHdoYXRUb1Nob3csIGZpbHRlcikge1xuICB2YXIgdHcgPSB0aGlzLCBhY3RpdmUgPSBmYWxzZTtcblxuICBpZiAoIXJvb3QgfHwgIXJvb3Qubm9kZVR5cGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0RPTUV4Y2VwdGlvbjogTk9UX1NVUFBPUlRFRF9FUlInKTtcbiAgfVxuXG4gIHR3LnJvb3QgPSByb290O1xuICB0dy53aGF0VG9TaG93ID0gTnVtYmVyKHdoYXRUb1Nob3cpIHx8IDA7XG5cbiAgdHcuY3VycmVudE5vZGUgPSByb290O1xuXG4gIGlmICh0eXBlb2YgZmlsdGVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgZmlsdGVyID0gbnVsbDtcbiAgfVxuXG4gIHR3LmZpbHRlciA9IE9iamVjdC5jcmVhdGUoTm9kZUZpbHRlci5wcm90b3R5cGUpO1xuXG4gIC8qKlxuICAgKiBAbWV0aG9kXG4gICAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IENvbnN0YW50IE5vZGVGaWx0ZXIuRklMVEVSX0FDQ0VQVCxcbiAgICogIE5vZGVGaWx0ZXIuRklMVEVSX1JFSkVDVCBvciBOb2RlRmlsdGVyLkZJTFRFUl9TS0lQLlxuICAgKi9cbiAgdHcuZmlsdGVyLmFjY2VwdE5vZGUgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgIC8qIGpzaGludCBiaXR3aXNlOiBmYWxzZSAqL1xuICAgIHZhciByZXN1bHQ7XG4gICAgaWYgKGFjdGl2ZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdET01FeGNlcHRpb246IElOVkFMSURfU1RBVEVfRVJSJyk7XG4gICAgfVxuXG4gICAgLy8gTWFwcyBub2RlVHlwZSB0byB3aGF0VG9TaG93XG4gICAgaWYgKCEoKCgxIDw8IChub2RlLm5vZGVUeXBlIC0gMSkpICYgdHcud2hhdFRvU2hvdykpKSB7XG4gICAgICByZXR1cm4gTm9kZUZpbHRlci5GSUxURVJfU0tJUDtcbiAgICB9XG5cbiAgICBpZiAoZmlsdGVyID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gTm9kZUZpbHRlci5GSUxURVJfQUNDRVBUO1xuICAgIH1cblxuICAgIGFjdGl2ZSA9IHRydWU7XG4gICAgcmVzdWx0ID0gZmlsdGVyKG5vZGUpO1xuICAgIGFjdGl2ZSA9IGZhbHNlO1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn1cblxuVHJlZVdhbGtlci5wcm90b3R5cGUgPSB7XG5cbiAgY29uc3RydWN0b3I6IFRyZWVXYWxrZXIsXG5cbiAgLyoqXG4gICAqIEBzcGVjIGh0dHA6Ly93d3cudzMub3JnL1RSL2RvbS8jZG9tLXRyZWV3YWxrZXItcGFyZW50bm9kZVxuICAgKiBAbWV0aG9kXG4gICAqIEByZXR1cm4ge05vZGV8bnVsbH1cbiAgICovXG4gIHBhcmVudE5vZGU6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbm9kZSA9IHRoaXMuY3VycmVudE5vZGU7XG4gICAgd2hpbGUgKG5vZGUgIT09IG51bGwgJiYgbm9kZSAhPT0gdGhpcy5yb290KSB7XG4gICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgICAgaWYgKG5vZGUgIT09IG51bGwgJiYgdGhpcy5maWx0ZXIuYWNjZXB0Tm9kZShub2RlKSA9PT0gTm9kZUZpbHRlci5GSUxURVJfQUNDRVBUKSB7XG4gICAgICAgIHRoaXMuY3VycmVudE5vZGUgPSBub2RlO1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBzcGVjIGh0dHA6Ly93d3cudzMub3JnL1RSL2RvbS8jZG9tLXRyZWV3YWxrZXItZmlyc3RjaGlsZFxuICAgKiBAbWV0aG9kXG4gICAqIEByZXR1cm4ge05vZGV8bnVsbH1cbiAgICovXG4gIGZpcnN0Q2hpbGQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdHJhdmVyc2VDaGlsZHJlbih0aGlzLCAnZmlyc3QnKTtcbiAgfSxcblxuICAvKipcbiAgICogQHNwZWMgaHR0cDovL3d3dy53My5vcmcvVFIvZG9tLyNkb20tdHJlZXdhbGtlci1sYXN0Y2hpbGRcbiAgICogQG1ldGhvZFxuICAgKiBAcmV0dXJuIHtOb2RlfG51bGx9XG4gICAqL1xuICBsYXN0Q2hpbGQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdHJhdmVyc2VDaGlsZHJlbih0aGlzLCAnbGFzdCcpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAc3BlYyBodHRwOi8vd3d3LnczLm9yZy9UUi9kb20vI2RvbS10cmVld2Fsa2VyLXByZXZpb3Vzc2libGluZ1xuICAgKiBAbWV0aG9kXG4gICAqIEByZXR1cm4ge05vZGV8bnVsbH1cbiAgICovXG4gIHByZXZpb3VzU2libGluZzogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0cmF2ZXJzZVNpYmxpbmdzKHRoaXMsICdwcmV2aW91cycpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAc3BlYyBodHRwOi8vd3d3LnczLm9yZy9UUi9kb20vI2RvbS10cmVld2Fsa2VyLW5leHRzaWJsaW5nXG4gICAqIEBtZXRob2RcbiAgICogQHJldHVybiB7Tm9kZXxudWxsfVxuICAgKi9cbiAgbmV4dFNpYmxpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdHJhdmVyc2VTaWJsaW5ncyh0aGlzLCAnbmV4dCcpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAc3BlYyBodHRwOi8vd3d3LnczLm9yZy9UUi9kb20vI2RvbS10cmVld2Fsa2VyLXByZXZpb3Vzbm9kZVxuICAgKiBAbWV0aG9kXG4gICAqIEByZXR1cm4ge05vZGV8bnVsbH1cbiAgICovXG4gIHByZXZpb3VzTm9kZTogZnVuY3Rpb24gKCkge1xuICAgIHZhciBub2RlLCByZXN1bHQsIHNpYmxpbmc7XG4gICAgbm9kZSA9IHRoaXMuY3VycmVudE5vZGU7XG4gICAgd2hpbGUgKG5vZGUgIT09IHRoaXMucm9vdCkge1xuICAgICAgc2libGluZyA9IG5vZGUucHJldmlvdXNTaWJsaW5nO1xuICAgICAgd2hpbGUgKHNpYmxpbmcgIT09IG51bGwpIHtcbiAgICAgICAgbm9kZSA9IHNpYmxpbmc7XG4gICAgICAgIHJlc3VsdCA9IHRoaXMuZmlsdGVyLmFjY2VwdE5vZGUobm9kZSk7XG4gICAgICAgIHdoaWxlIChyZXN1bHQgIT09IE5vZGVGaWx0ZXIuRklMVEVSX1JFSkVDVCAmJiBub2RlLmxhc3RDaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICAgIG5vZGUgPSBub2RlLmxhc3RDaGlsZDtcbiAgICAgICAgICByZXN1bHQgPSB0aGlzLmZpbHRlci5hY2NlcHROb2RlKG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQgPT09IE5vZGVGaWx0ZXIuRklMVEVSX0FDQ0VQVCkge1xuICAgICAgICAgIHRoaXMuY3VycmVudE5vZGUgPSBub2RlO1xuICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICB9XG4gICAgICAgIHNpYmxpbmcgPSBub2RlLnByZXZpb3VzU2libGluZztcbiAgICAgIH1cbiAgICAgIGlmIChub2RlID09PSB0aGlzLnJvb3QgfHwgbm9kZS5wYXJlbnROb2RlID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgIGlmICh0aGlzLmZpbHRlci5hY2NlcHROb2RlKG5vZGUpID09PSBOb2RlRmlsdGVyLkZJTFRFUl9BQ0NFUFQpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50Tm9kZSA9IG5vZGU7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfSxcblxuICAvKipcbiAgICogQHNwZWMgaHR0cDovL3d3dy53My5vcmcvVFIvZG9tLyNkb20tdHJlZXdhbGtlci1uZXh0bm9kZVxuICAgKiBAYmFzZWQgb24gV2ViS2l0J3MgVHJlZVdhbGtlcjo6bmV4dE5vZGVcbiAgICogaHR0cHM6Ly90cmFjLndlYmtpdC5vcmcvYnJvd3Nlci90cnVuay9Tb3VyY2UvV2ViQ29yZS9kb20vVHJlZVdhbGtlci5jcHA/cmV2PTE3OTE0MyNMMjUyXG4gICAqIEBtZXRob2RcbiAgICogQHJldHVybiB7Tm9kZXxudWxsfVxuICAgKi9cbiAgbmV4dE5vZGU6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbm9kZSwgcmVzdWx0LCBmb2xsb3dpbmc7XG4gICAgbm9kZSA9IHRoaXMuY3VycmVudE5vZGU7XG4gICAgcmVzdWx0ID0gTm9kZUZpbHRlci5GSUxURVJfQUNDRVBUO1xuXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIHdoaWxlIChyZXN1bHQgIT09IE5vZGVGaWx0ZXIuRklMVEVSX1JFSkVDVCAmJiBub2RlLmZpcnN0Q2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgbm9kZSA9IG5vZGUuZmlyc3RDaGlsZDtcbiAgICAgICAgcmVzdWx0ID0gdGhpcy5maWx0ZXIuYWNjZXB0Tm9kZShub2RlKTtcbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gTm9kZUZpbHRlci5GSUxURVJfQUNDRVBUKSB7XG4gICAgICAgICAgdGhpcy5jdXJyZW50Tm9kZSA9IG5vZGU7XG4gICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZvbGxvd2luZyA9IE5vZGVUcmF2ZXJzYWwubmV4dFNraXBwaW5nQ2hpbGRyZW4obm9kZSwgdGhpcy5yb290KTtcbiAgICAgIGlmIChmb2xsb3dpbmcgIT09IG51bGwpIHtcbiAgICAgICAgbm9kZSA9IGZvbGxvd2luZztcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJlc3VsdCA9IHRoaXMuZmlsdGVyLmFjY2VwdE5vZGUobm9kZSk7XG4gICAgICBpZiAocmVzdWx0ID09PSBOb2RlRmlsdGVyLkZJTFRFUl9BQ0NFUFQpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50Tm9kZSA9IG5vZGU7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2RvbWluby9saWIvVHJlZVdhbGtlci5qc1xuLy8gbW9kdWxlIGlkID0gNzlcbi8vIG1vZHVsZSBjaHVua3MgPSA0IiwiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IE5vZGVJdGVyYXRvcjtcblxudmFyIE5vZGVGaWx0ZXIgPSByZXF1aXJlKCcuL05vZGVGaWx0ZXInKTtcbnZhciBOb2RlVHJhdmVyc2FsID0gcmVxdWlyZSgnLi9Ob2RlVHJhdmVyc2FsJyk7XG5cbi8qIFByaXZhdGUgbWV0aG9kcyBhbmQgaGVscGVycyAqL1xuXG4vKipcbiAqIEBiYXNlZCBvbiBXZWJLaXQncyBOb2RlSXRlcmF0b3I6Om1vdmVUb05leHQgYW5kIE5vZGVJdGVyYXRvcjo6bW92ZVRvUHJldmlvdXNcbiAqIGh0dHBzOi8vdHJhYy53ZWJraXQub3JnL2Jyb3dzZXIvdHJ1bmsvU291cmNlL1dlYkNvcmUvZG9tL05vZGVJdGVyYXRvci5jcHA/cmV2PTE4NjI3OSNMNTFcbiAqL1xuZnVuY3Rpb24gbW92ZShub2RlLCBzdGF5V2l0aGluLCBkaXJlY3Rpb25Jc05leHQpIHtcbiAgaWYgKGRpcmVjdGlvbklzTmV4dCkge1xuICAgIHJldHVybiBOb2RlVHJhdmVyc2FsLm5leHQobm9kZSwgc3RheVdpdGhpbik7XG4gIH0gZWxzZSB7XG4gICAgaWYgKG5vZGUgPT09IHN0YXlXaXRoaW4pIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gTm9kZVRyYXZlcnNhbC5wcmV2aW91cyhub2RlLCBudWxsKTtcbiAgfVxufVxuXG4vKipcbiAqIEBzcGVjIGh0dHA6Ly93d3cudzMub3JnL1RSL2RvbS8jY29uY2VwdC1ub2RlaXRlcmF0b3ItdHJhdmVyc2VcbiAqIEBtZXRob2RcbiAqIEBhY2Nlc3MgcHJpdmF0ZVxuICogQHBhcmFtIHtOb2RlSXRlcmF0b3J9IG5pXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlyZWN0aW9uIE9uZSBvZiAnbmV4dCcgb3IgJ3ByZXZpb3VzJy5cbiAqIEByZXR1cm4ge05vZGV8bnVsbH1cbiAqL1xuZnVuY3Rpb24gdHJhdmVyc2UobmksIGRpcmVjdGlvbklzTmV4dCkge1xuICB2YXIgbm9kZSwgYmVmb3JlTm9kZTtcbiAgbm9kZSA9IG5pLnJlZmVyZW5jZU5vZGU7XG4gIGJlZm9yZU5vZGUgPSBuaS5wb2ludGVyQmVmb3JlUmVmZXJlbmNlTm9kZTtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICBpZiAoYmVmb3JlTm9kZSA9PT0gZGlyZWN0aW9uSXNOZXh0KSB7XG4gICAgICBiZWZvcmVOb2RlID0gIWJlZm9yZU5vZGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUgPSBtb3ZlKG5vZGUsIG5pLnJvb3QsIGRpcmVjdGlvbklzTmV4dCk7XG4gICAgICBpZiAobm9kZSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIHJlc3VsdCA9IG5pLmZpbHRlci5hY2NlcHROb2RlKG5vZGUpO1xuICAgIGlmIChyZXN1bHQgPT09IE5vZGVGaWx0ZXIuRklMVEVSX0FDQ0VQVCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIG5pLnJlZmVyZW5jZU5vZGUgPSBub2RlO1xuICBuaS5wb2ludGVyQmVmb3JlUmVmZXJlbmNlTm9kZSA9IGJlZm9yZU5vZGU7XG4gIHJldHVybiBub2RlO1xufVxuXG4vKiBQdWJsaWMgQVBJICovXG5cbi8qKlxuICogSW1wbGVtZW50ZWQgdmVyc2lvbjogaHR0cDovL3d3dy53My5vcmcvVFIvMjAxNS9XRC1kb20tMjAxNTA2MTgvI25vZGVpdGVyYXRvclxuICogTGF0ZXN0IHZlcnNpb246IGh0dHA6Ly93d3cudzMub3JnL1RSL2RvbS8jbm9kZWl0ZXJhdG9yXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge05vZGV9IHJvb3RcbiAqIEBwYXJhbSB7bnVtYmVyfSB3aGF0VG9TaG93IFtvcHRpb25hbF1cbiAqIEBwYXJhbSB7RnVuY3Rpb258Tm9kZUZpbHRlcn0gZmlsdGVyIFtvcHRpb25hbF1cbiAqIEB0aHJvd3MgRXJyb3JcbiAqL1xuZnVuY3Rpb24gTm9kZUl0ZXJhdG9yKHJvb3QsIHdoYXRUb1Nob3csIGZpbHRlcikge1xuICB2YXIgbmkgPSB0aGlzLCBhY3RpdmUgPSBmYWxzZTtcblxuICBpZiAoIXJvb3QgfHwgIXJvb3Qubm9kZVR5cGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0RPTUV4Y2VwdGlvbjogTk9UX1NVUFBPUlRFRF9FUlInKTtcbiAgfVxuXG4gIG5pLnJvb3QgPSBuaS5yZWZlcmVuY2VOb2RlID0gcm9vdDtcbiAgbmkucG9pbnRlckJlZm9yZVJlZmVyZW5jZU5vZGUgPSB0cnVlO1xuICBuaS53aGF0VG9TaG93ID0gTnVtYmVyKHdoYXRUb1Nob3cpIHx8IDA7XG5cbiAgaWYgKHR5cGVvZiBmaWx0ZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICBmaWx0ZXIgPSBudWxsO1xuICB9XG5cbiAgbmkuZmlsdGVyID0gT2JqZWN0LmNyZWF0ZShOb2RlRmlsdGVyLnByb3RvdHlwZSk7XG5cbiAgLyoqXG4gICAqIEBtZXRob2RcbiAgICogQHBhcmFtIHtOb2RlfSBub2RlXG4gICAqIEByZXR1cm4ge051bWJlcn0gQ29uc3RhbnQgTm9kZUZpbHRlci5GSUxURVJfQUNDRVBULFxuICAgKiAgTm9kZUZpbHRlci5GSUxURVJfUkVKRUNUIG9yIE5vZGVGaWx0ZXIuRklMVEVSX1NLSVAuXG4gICAqL1xuICBuaS5maWx0ZXIuYWNjZXB0Tm9kZSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgLyoganNoaW50IGJpdHdpc2U6IGZhbHNlICovXG4gICAgdmFyIHJlc3VsdDtcbiAgICBpZiAoYWN0aXZlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RPTUV4Y2VwdGlvbjogSU5WQUxJRF9TVEFURV9FUlInKTtcbiAgICB9XG5cbiAgICAvLyBNYXBzIG5vZGVUeXBlIHRvIHdoYXRUb1Nob3dcbiAgICBpZiAoISgoKDEgPDwgKG5vZGUubm9kZVR5cGUgLSAxKSkgJiBuaS53aGF0VG9TaG93KSkpIHtcbiAgICAgIHJldHVybiBOb2RlRmlsdGVyLkZJTFRFUl9TS0lQO1xuICAgIH1cblxuICAgIGlmIChmaWx0ZXIgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBOb2RlRmlsdGVyLkZJTFRFUl9BQ0NFUFQ7XG4gICAgfVxuXG4gICAgYWN0aXZlID0gdHJ1ZTtcbiAgICByZXN1bHQgPSBmaWx0ZXIobm9kZSk7XG4gICAgYWN0aXZlID0gZmFsc2U7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xufVxuXG5Ob2RlSXRlcmF0b3IucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogTm9kZUl0ZXJhdG9yLFxuXG4gIC8qKlxuICAgKiBAc3BlYyBodHRwOi8vd3d3LnczLm9yZy9UUi9kb20vI2RvbS1ub2RlaXRlcmF0b3ItbmV4dG5vZGVcbiAgICogQG1ldGhvZFxuICAgKiBAcmV0dXJuIHtOb2RlfG51bGx9XG4gICAqL1xuICBuZXh0Tm9kZTogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0cmF2ZXJzZSh0aGlzLCB0cnVlKTtcbiAgfSxcblxuICAvKipcbiAgICogQHNwZWMgaHR0cDovL3d3dy53My5vcmcvVFIvZG9tLyNkb20tbm9kZWl0ZXJhdG9yLXByZXZpb3Vzbm9kZVxuICAgKiBAbWV0aG9kXG4gICAqIEByZXR1cm4ge05vZGV8bnVsbH1cbiAgICovXG4gIHByZXZpb3VzTm9kZTogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0cmF2ZXJzZSh0aGlzLCBmYWxzZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBzcGVjIGh0dHA6Ly93d3cudzMub3JnL1RSL2RvbS8jZG9tLW5vZGVpdGVyYXRvci1kZXRhY2hcbiAgICogQG1ldGhvZFxuICAgKiBAcmV0dXJuIHZvaWRcbiAgICovXG4gIGRldGFjaDogZnVuY3Rpb24oKSB7XG4gICAgLyogXCJUaGUgZGV0YWNoKCkgbWV0aG9kIG11c3QgZG8gbm90aGluZy5cbiAgICAgKiBJdHMgZnVuY3Rpb25hbGl0eSAoZGlzYWJsaW5nIGEgTm9kZUl0ZXJhdG9yIG9iamVjdCkgd2FzIHJlbW92ZWQsXG4gICAgICogYnV0IHRoZSBtZXRob2QgaXRzZWxmIGlzIHByZXNlcnZlZCBmb3IgY29tcGF0aWJpbGl0eS5cbiAgICAgKi9cbiAgfVxufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2RvbWluby9saWIvTm9kZUl0ZXJhdG9yLmpzXG4vLyBtb2R1bGUgaWQgPSA4MFxuLy8gbW9kdWxlIGNodW5rcyA9IDQiLCJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gQ3VzdG9tRXZlbnQ7XG5cbnZhciBFdmVudCA9IHJlcXVpcmUoJy4vRXZlbnQnKTtcblxuZnVuY3Rpb24gQ3VzdG9tRXZlbnQodHlwZSwgZGljdGlvbmFyeSkge1xuICAvLyBKdXN0IHVzZSB0aGUgc3VwZXJjbGFzcyBjb25zdHJ1Y3RvciB0byBpbml0aWFsaXplXG4gIEV2ZW50LmNhbGwodGhpcywgdHlwZSwgZGljdGlvbmFyeSk7XG59XG5DdXN0b21FdmVudC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEV2ZW50LnByb3RvdHlwZSwge1xuICBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogQ3VzdG9tRXZlbnQgfVxufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9kb21pbm8vbGliL0N1c3RvbUV2ZW50LmpzXG4vLyBtb2R1bGUgaWQgPSA4MVxuLy8gbW9kdWxlIGNodW5rcyA9IDQiLCIvKiBqc2hpbnQgbm9kZTp0cnVlLCBsYXRlZGVmOmZhbHNlICovXG5cInVzZSBzdHJpY3RcIjsgLy8ganNoaW50IGlnbm9yZTpsaW5lXG4vKiFcblBhcnNlci1MaWJcbkNvcHlyaWdodCAoYykgMjAwOS0yMDExIE5pY2hvbGFzIEMuIFpha2FzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuXG5QZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG5vZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG5pbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG50byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG5jb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbmZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cblRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG5hbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG5GSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbkFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbkxJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG5PVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG5USEUgU09GVFdBUkUuXG5cbiovXG4vKiBWZXJzaW9uIHYwLjIuNStkb21pbm8xLCBCdWlsZCB0aW1lOiAzMC1KYW51YXJ5LTIwMTYgMDU6MTM6MDMgKi9cbnZhciBwYXJzZXJsaWIgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuKGZ1bmN0aW9uKCl7XG5cbi8qKlxuICogQSBnZW5lcmljIGJhc2UgdG8gaW5oZXJpdCBmcm9tIGZvciBhbnkgb2JqZWN0XG4gKiB0aGF0IG5lZWRzIGV2ZW50IGhhbmRsaW5nLlxuICogQGNsYXNzIEV2ZW50VGFyZ2V0XG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gRXZlbnRUYXJnZXQoKXtcblxuICAgIC8qKlxuICAgICAqIFRoZSBhcnJheSBvZiBsaXN0ZW5lcnMgZm9yIHZhcmlvdXMgZXZlbnRzLlxuICAgICAqIEB0eXBlIE9iamVjdFxuICAgICAqIEBwcm9wZXJ0eSBfbGlzdGVuZXJzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9saXN0ZW5lcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xufVxuXG5FdmVudFRhcmdldC5wcm90b3R5cGUgPSB7XG5cbiAgICAvL3Jlc3RvcmUgY29uc3RydWN0b3JcbiAgICBjb25zdHJ1Y3RvcjogRXZlbnRUYXJnZXQsXG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgbGlzdGVuZXIgZm9yIGEgZ2l2ZW4gZXZlbnQgdHlwZS5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgdHlwZSBvZiBldmVudCB0byBhZGQgYSBsaXN0ZW5lciBmb3IuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gbGlzdGVuZXIgVGhlIGZ1bmN0aW9uIHRvIGNhbGwgd2hlbiB0aGUgZXZlbnQgb2NjdXJzLlxuICAgICAqIEByZXR1cm4ge3ZvaWR9XG4gICAgICogQG1ldGhvZCBhZGRMaXN0ZW5lclxuICAgICAqL1xuICAgIGFkZExpc3RlbmVyOiBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcil7XG4gICAgICAgIGlmICghdGhpcy5fbGlzdGVuZXJzW3R5cGVdKXtcbiAgICAgICAgICAgIHRoaXMuX2xpc3RlbmVyc1t0eXBlXSA9IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fbGlzdGVuZXJzW3R5cGVdLnB1c2gobGlzdGVuZXIpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGaXJlcyBhbiBldmVudCBiYXNlZCBvbiB0aGUgcGFzc2VkLWluIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IGV2ZW50IEFuIG9iamVjdCB3aXRoIGF0IGxlYXN0IGEgJ3R5cGUnIGF0dHJpYnV0ZVxuICAgICAqICAgICAgb3IgYSBzdHJpbmcgaW5kaWNhdGluZyB0aGUgZXZlbnQgbmFtZS5cbiAgICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgICAqIEBtZXRob2QgZmlyZVxuICAgICAqL1xuICAgIGZpcmU6IGZ1bmN0aW9uKGV2ZW50KXtcbiAgICAgICAgaWYgKHR5cGVvZiBldmVudCA9PT0gXCJzdHJpbmdcIil7XG4gICAgICAgICAgICBldmVudCA9IHsgdHlwZTogZXZlbnQgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGV2ZW50LnRhcmdldCAhPT0gXCJ1bmRlZmluZWRcIil7XG4gICAgICAgICAgICBldmVudC50YXJnZXQgPSB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBldmVudC50eXBlID09PSBcInVuZGVmaW5lZFwiKXtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkV2ZW50IG9iamVjdCBtaXNzaW5nICd0eXBlJyBwcm9wZXJ0eS5cIik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fbGlzdGVuZXJzW2V2ZW50LnR5cGVdKXtcblxuICAgICAgICAgICAgLy9jcmVhdGUgYSBjb3B5IG9mIHRoZSBhcnJheSBhbmQgdXNlIHRoYXQgc28gbGlzdGVuZXJzIGNhbid0IGNoYW5lXG4gICAgICAgICAgICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzW2V2ZW50LnR5cGVdLmNvbmNhdCgpO1xuICAgICAgICAgICAgZm9yICh2YXIgaT0wLCBsZW49bGlzdGVuZXJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKXtcbiAgICAgICAgICAgICAgICBsaXN0ZW5lcnNbaV0uY2FsbCh0aGlzLCBldmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhIGxpc3RlbmVyIGZvciBhIGdpdmVuIGV2ZW50IHR5cGUuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIHR5cGUgb2YgZXZlbnQgdG8gcmVtb3ZlIGEgbGlzdGVuZXIgZnJvbS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaXN0ZW5lciBUaGUgZnVuY3Rpb24gdG8gcmVtb3ZlIGZyb20gdGhlIGV2ZW50LlxuICAgICAqIEByZXR1cm4ge3ZvaWR9XG4gICAgICogQG1ldGhvZCByZW1vdmVMaXN0ZW5lclxuICAgICAqL1xuICAgIHJlbW92ZUxpc3RlbmVyOiBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcil7XG4gICAgICAgIGlmICh0aGlzLl9saXN0ZW5lcnNbdHlwZV0pe1xuICAgICAgICAgICAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVyc1t0eXBlXTtcbiAgICAgICAgICAgIGZvciAodmFyIGk9MCwgbGVuPWxpc3RlbmVycy5sZW5ndGg7IGkgPCBsZW47IGkrKyl7XG4gICAgICAgICAgICAgICAgaWYgKGxpc3RlbmVyc1tpXSA9PT0gbGlzdGVuZXIpe1xuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcnMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cblxuICAgICAgICB9XG4gICAgfVxufTtcbi8qKlxuICogQ29udmVuaWVudCB3YXkgdG8gcmVhZCB0aHJvdWdoIHN0cmluZ3MuXG4gKiBAbmFtZXNwYWNlIHBhcnNlcmxpYi51dGlsXG4gKiBAY2xhc3MgU3RyaW5nUmVhZGVyXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0IFRoZSB0ZXh0IHRvIHJlYWQuXG4gKi9cbmZ1bmN0aW9uIFN0cmluZ1JlYWRlcih0ZXh0KXtcblxuICAgIC8qKlxuICAgICAqIFRoZSBpbnB1dCB0ZXh0IHdpdGggbGluZSBlbmRpbmdzIG5vcm1hbGl6ZWQuXG4gICAgICogQHByb3BlcnR5IF9pbnB1dFxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5faW5wdXQgPSB0ZXh0LnJlcGxhY2UoLyhcXHJ8XFxuKXsxLDJ9L2csIFwiXFxuXCIpO1xuXG5cbiAgICAvKipcbiAgICAgKiBUaGUgcm93IGZvciB0aGUgY2hhcmFjdGVyIHRvIGJlIHJlYWQgbmV4dC5cbiAgICAgKiBAcHJvcGVydHkgX2xpbmVcbiAgICAgKiBAdHlwZSBpbnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX2xpbmUgPSAxO1xuXG5cbiAgICAvKipcbiAgICAgKiBUaGUgY29sdW1uIGZvciB0aGUgY2hhcmFjdGVyIHRvIGJlIHJlYWQgbmV4dC5cbiAgICAgKiBAcHJvcGVydHkgX2NvbFxuICAgICAqIEB0eXBlIGludFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fY29sID0gMTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBpbmRleCBvZiB0aGUgY2hhcmFjdGVyIGluIHRoZSBpbnB1dCB0byBiZSByZWFkIG5leHQuXG4gICAgICogQHByb3BlcnR5IF9jdXJzb3JcbiAgICAgKiBAdHlwZSBpbnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX2N1cnNvciA9IDA7XG59XG5cblN0cmluZ1JlYWRlci5wcm90b3R5cGUgPSB7XG5cbiAgICAvL3Jlc3RvcmUgY29uc3RydWN0b3JcbiAgICBjb25zdHJ1Y3RvcjogU3RyaW5nUmVhZGVyLFxuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gUG9zaXRpb24gaW5mb1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY29sdW1uIG9mIHRoZSBjaGFyYWN0ZXIgdG8gYmUgcmVhZCBuZXh0LlxuICAgICAqIEByZXR1cm4ge2ludH0gVGhlIGNvbHVtbiBvZiB0aGUgY2hhcmFjdGVyIHRvIGJlIHJlYWQgbmV4dC5cbiAgICAgKiBAbWV0aG9kIGdldENvbFxuICAgICAqL1xuICAgIGdldENvbDogZnVuY3Rpb24oKXtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcm93IG9mIHRoZSBjaGFyYWN0ZXIgdG8gYmUgcmVhZCBuZXh0LlxuICAgICAqIEByZXR1cm4ge2ludH0gVGhlIHJvdyBvZiB0aGUgY2hhcmFjdGVyIHRvIGJlIHJlYWQgbmV4dC5cbiAgICAgKiBAbWV0aG9kIGdldExpbmVcbiAgICAgKi9cbiAgICBnZXRMaW5lOiBmdW5jdGlvbigpe1xuICAgICAgICByZXR1cm4gdGhpcy5fbGluZSA7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgaWYgeW91J3JlIGF0IHRoZSBlbmQgb2YgdGhlIGlucHV0LlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IFRydWUgaWYgdGhlcmUncyBubyBtb3JlIGlucHV0LCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICogQG1ldGhvZCBlb2ZcbiAgICAgKi9cbiAgICBlb2Y6IGZ1bmN0aW9uKCl7XG4gICAgICAgIHJldHVybiAodGhpcy5fY3Vyc29yID09PSB0aGlzLl9pbnB1dC5sZW5ndGgpO1xuICAgIH0sXG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBCYXNpYyByZWFkaW5nXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAvKipcbiAgICAgKiBSZWFkcyB0aGUgbmV4dCBjaGFyYWN0ZXIgd2l0aG91dCBhZHZhbmNpbmcgdGhlIGN1cnNvci5cbiAgICAgKiBAcGFyYW0ge2ludH0gY291bnQgSG93IG1hbnkgY2hhcmFjdGVycyB0byBsb29rIGFoZWFkIChkZWZhdWx0IGlzIDEpLlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gVGhlIG5leHQgY2hhcmFjdGVyIG9yIG51bGwgaWYgdGhlcmUgaXMgbm8gbmV4dCBjaGFyYWN0ZXIuXG4gICAgICogQG1ldGhvZCBwZWVrXG4gICAgICovXG4gICAgcGVlazogZnVuY3Rpb24oY291bnQpe1xuICAgICAgICB2YXIgYyA9IG51bGw7XG4gICAgICAgIGNvdW50ID0gKHR5cGVvZiBjb3VudCA9PT0gXCJ1bmRlZmluZWRcIiA/IDEgOiBjb3VudCk7XG5cbiAgICAgICAgLy9pZiB3ZSdyZSBub3QgYXQgdGhlIGVuZCBvZiB0aGUgaW5wdXQuLi5cbiAgICAgICAgaWYgKHRoaXMuX2N1cnNvciA8IHRoaXMuX2lucHV0Lmxlbmd0aCl7XG5cbiAgICAgICAgICAgIC8vZ2V0IGNoYXJhY3RlciBhbmQgaW5jcmVtZW50IGN1cnNvciBhbmQgY29sdW1uXG4gICAgICAgICAgICBjID0gdGhpcy5faW5wdXQuY2hhckF0KHRoaXMuX2N1cnNvciArIGNvdW50IC0gMSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVhZHMgdGhlIG5leHQgY2hhcmFjdGVyIGZyb20gdGhlIGlucHV0IGFuZCBhZGp1c3RzIHRoZSByb3cgYW5kIGNvbHVtblxuICAgICAqIGFjY29yZGluZ2x5LlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gVGhlIG5leHQgY2hhcmFjdGVyIG9yIG51bGwgaWYgdGhlcmUgaXMgbm8gbmV4dCBjaGFyYWN0ZXIuXG4gICAgICogQG1ldGhvZCByZWFkXG4gICAgICovXG4gICAgcmVhZDogZnVuY3Rpb24oKXtcbiAgICAgICAgdmFyIGMgPSBudWxsO1xuXG4gICAgICAgIC8vaWYgd2UncmUgbm90IGF0IHRoZSBlbmQgb2YgdGhlIGlucHV0Li4uXG4gICAgICAgIGlmICh0aGlzLl9jdXJzb3IgPCB0aGlzLl9pbnB1dC5sZW5ndGgpe1xuXG4gICAgICAgICAgICAvL2lmIHRoZSBsYXN0IGNoYXJhY3RlciB3YXMgYSBuZXdsaW5lLCBpbmNyZW1lbnQgcm93IGNvdW50XG4gICAgICAgICAgICAvL2FuZCByZXNldCBjb2x1bW4gY291bnRcbiAgICAgICAgICAgIGlmICh0aGlzLl9pbnB1dC5jaGFyQXQodGhpcy5fY3Vyc29yKSA9PT0gXCJcXG5cIil7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGluZSsrO1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbD0xO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb2wrKztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy9nZXQgY2hhcmFjdGVyIGFuZCBpbmNyZW1lbnQgY3Vyc29yIGFuZCBjb2x1bW5cbiAgICAgICAgICAgIGMgPSB0aGlzLl9pbnB1dC5jaGFyQXQodGhpcy5fY3Vyc29yKyspO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGM7XG4gICAgfSxcblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIE1pc2NcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIC8qKlxuICAgICAqIFNhdmVzIHRoZSBjdXJyZW50IGxvY2F0aW9uIHNvIGl0IGNhbiBiZSByZXR1cm5lZCB0byBsYXRlci5cbiAgICAgKiBAbWV0aG9kIG1hcmtcbiAgICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgICAqL1xuICAgIG1hcms6IGZ1bmN0aW9uKCl7XG4gICAgICAgIHRoaXMuX2Jvb2ttYXJrID0ge1xuICAgICAgICAgICAgY3Vyc29yOiB0aGlzLl9jdXJzb3IsXG4gICAgICAgICAgICBsaW5lOiAgIHRoaXMuX2xpbmUsXG4gICAgICAgICAgICBjb2w6ICAgIHRoaXMuX2NvbFxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICByZXNldDogZnVuY3Rpb24oKXtcbiAgICAgICAgaWYgKHRoaXMuX2Jvb2ttYXJrKXtcbiAgICAgICAgICAgIHRoaXMuX2N1cnNvciA9IHRoaXMuX2Jvb2ttYXJrLmN1cnNvcjtcbiAgICAgICAgICAgIHRoaXMuX2xpbmUgPSB0aGlzLl9ib29rbWFyay5saW5lO1xuICAgICAgICAgICAgdGhpcy5fY29sID0gdGhpcy5fYm9va21hcmsuY29sO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2Jvb2ttYXJrO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIEFkdmFuY2VkIHJlYWRpbmdcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIC8qKlxuICAgICAqIFJlYWRzIHVwIHRvIGFuZCBpbmNsdWRpbmcgdGhlIGdpdmVuIHN0cmluZy4gVGhyb3dzIGFuIGVycm9yIGlmIHRoYXRcbiAgICAgKiBzdHJpbmcgaXMgbm90IGZvdW5kLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwYXR0ZXJuIFRoZSBzdHJpbmcgdG8gcmVhZC5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSBzdHJpbmcgd2hlbiBpdCBpcyBmb3VuZC5cbiAgICAgKiBAdGhyb3dzIEVycm9yIHdoZW4gdGhlIHN0cmluZyBwYXR0ZXJuIGlzIG5vdCBmb3VuZC5cbiAgICAgKiBAbWV0aG9kIHJlYWRUb1xuICAgICAqL1xuICAgIHJlYWRUbzogZnVuY3Rpb24ocGF0dGVybil7XG5cbiAgICAgICAgdmFyIGJ1ZmZlciA9IFwiXCIsXG4gICAgICAgICAgICBjO1xuXG4gICAgICAgIC8qXG4gICAgICAgICAqIEZpcnN0LCBidWZmZXIgbXVzdCBiZSB0aGUgc2FtZSBsZW5ndGggYXMgdGhlIHBhdHRlcm4uXG4gICAgICAgICAqIFRoZW4sIGJ1ZmZlciBtdXN0IGVuZCB3aXRoIHRoZSBwYXR0ZXJuIG9yIGVsc2UgcmVhY2ggdGhlXG4gICAgICAgICAqIGVuZCBvZiB0aGUgaW5wdXQuXG4gICAgICAgICAqL1xuICAgICAgICB3aGlsZSAoYnVmZmVyLmxlbmd0aCA8IHBhdHRlcm4ubGVuZ3RoIHx8IGJ1ZmZlci5sYXN0SW5kZXhPZihwYXR0ZXJuKSAhPT0gYnVmZmVyLmxlbmd0aCAtIHBhdHRlcm4ubGVuZ3RoKXtcbiAgICAgICAgICAgIGMgPSB0aGlzLnJlYWQoKTtcbiAgICAgICAgICAgIGlmIChjKXtcbiAgICAgICAgICAgICAgICBidWZmZXIgKz0gYztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgXFxcIlwiICsgcGF0dGVybiArIFwiXFxcIiBhdCBsaW5lIFwiICsgdGhpcy5fbGluZSAgKyBcIiwgY29sIFwiICsgdGhpcy5fY29sICsgXCIuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGJ1ZmZlcjtcblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZWFkcyBjaGFyYWN0ZXJzIHdoaWxlIGVhY2ggY2hhcmFjdGVyIGNhdXNlcyB0aGUgZ2l2ZW5cbiAgICAgKiBmaWx0ZXIgZnVuY3Rpb24gdG8gcmV0dXJuIHRydWUuIFRoZSBmdW5jdGlvbiBpcyBwYXNzZWRcbiAgICAgKiBpbiBlYWNoIGNoYXJhY3RlciBhbmQgZWl0aGVyIHJldHVybnMgdHJ1ZSB0byBjb250aW51ZVxuICAgICAqIHJlYWRpbmcgb3IgZmFsc2UgdG8gc3RvcC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmaWx0ZXIgVGhlIGZ1bmN0aW9uIHRvIHJlYWQgb24gZWFjaCBjaGFyYWN0ZXIuXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBUaGUgc3RyaW5nIG1hZGUgdXAgb2YgYWxsIGNoYXJhY3RlcnMgdGhhdCBwYXNzZWQgdGhlXG4gICAgICogICAgICBmaWx0ZXIgY2hlY2suXG4gICAgICogQG1ldGhvZCByZWFkV2hpbGVcbiAgICAgKi9cbiAgICByZWFkV2hpbGU6IGZ1bmN0aW9uKGZpbHRlcil7XG5cbiAgICAgICAgdmFyIGJ1ZmZlciA9IFwiXCIsXG4gICAgICAgICAgICBjID0gdGhpcy5yZWFkKCk7XG5cbiAgICAgICAgd2hpbGUoYyAhPT0gbnVsbCAmJiBmaWx0ZXIoYykpe1xuICAgICAgICAgICAgYnVmZmVyICs9IGM7XG4gICAgICAgICAgICBjID0gdGhpcy5yZWFkKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYnVmZmVyO1xuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlYWRzIGNoYXJhY3RlcnMgdGhhdCBtYXRjaCBlaXRoZXIgdGV4dCBvciBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBhbmRcbiAgICAgKiByZXR1cm5zIHRob3NlIGNoYXJhY3RlcnMuIElmIGEgbWF0Y2ggaXMgZm91bmQsIHRoZSByb3cgYW5kIGNvbHVtblxuICAgICAqIGFyZSBhZGp1c3RlZDsgaWYgbm8gbWF0Y2ggaXMgZm91bmQsIHRoZSByZWFkZXIncyBzdGF0ZSBpcyB1bmNoYW5nZWQuXG4gICAgICogcmVhZGluZyBvciBmYWxzZSB0byBzdG9wLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfFJlZ0V4cH0gbWF0Y2h0ZXIgSWYgYSBzdHJpbmcsIHRoZW4gdGhlIGxpdGVyYWwgc3RyaW5nXG4gICAgICogICAgICB2YWx1ZSBpcyBzZWFyY2hlZCBmb3IuIElmIGEgcmVndWxhciBleHByZXNzaW9uLCB0aGVuIGFueSBzdHJpbmdcbiAgICAgKiAgICAgIG1hdGNoaW5nIHRoZSBwYXR0ZXJuIGlzIHNlYXJjaCBmb3IuXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBUaGUgc3RyaW5nIG1hZGUgdXAgb2YgYWxsIGNoYXJhY3RlcnMgdGhhdCBtYXRjaGVkIG9yXG4gICAgICogICAgICBudWxsIGlmIHRoZXJlIHdhcyBubyBtYXRjaC5cbiAgICAgKiBAbWV0aG9kIHJlYWRNYXRjaFxuICAgICAqL1xuICAgIHJlYWRNYXRjaDogZnVuY3Rpb24obWF0Y2hlcil7XG5cbiAgICAgICAgdmFyIHNvdXJjZSA9IHRoaXMuX2lucHV0LnN1YnN0cmluZyh0aGlzLl9jdXJzb3IpLFxuICAgICAgICAgICAgdmFsdWUgPSBudWxsO1xuXG4gICAgICAgIC8vaWYgaXQncyBhIHN0cmluZywganVzdCBkbyBhIHN0cmFpZ2h0IG1hdGNoXG4gICAgICAgIGlmICh0eXBlb2YgbWF0Y2hlciA9PT0gXCJzdHJpbmdcIil7XG4gICAgICAgICAgICBpZiAoc291cmNlLmluZGV4T2YobWF0Y2hlcikgPT09IDApe1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpcy5yZWFkQ291bnQobWF0Y2hlci5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKG1hdGNoZXIgaW5zdGFuY2VvZiBSZWdFeHApe1xuICAgICAgICAgICAgaWYgKG1hdGNoZXIudGVzdChzb3VyY2UpKXtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXMucmVhZENvdW50KFJlZ0V4cC5sYXN0TWF0Y2gubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LFxuXG5cbiAgICAvKipcbiAgICAgKiBSZWFkcyBhIGdpdmVuIG51bWJlciBvZiBjaGFyYWN0ZXJzLiBJZiB0aGUgZW5kIG9mIHRoZSBpbnB1dCBpcyByZWFjaGVkLFxuICAgICAqIGl0IHJlYWRzIG9ubHkgdGhlIHJlbWFpbmluZyBjaGFyYWN0ZXJzIGFuZCBkb2VzIG5vdCB0aHJvdyBhbiBlcnJvci5cbiAgICAgKiBAcGFyYW0ge2ludH0gY291bnQgVGhlIG51bWJlciBvZiBjaGFyYWN0ZXJzIHRvIHJlYWQuXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBUaGUgc3RyaW5nIG1hZGUgdXAgdGhlIHJlYWQgY2hhcmFjdGVycy5cbiAgICAgKiBAbWV0aG9kIHJlYWRDb3VudFxuICAgICAqL1xuICAgIHJlYWRDb3VudDogZnVuY3Rpb24oY291bnQpe1xuICAgICAgICB2YXIgYnVmZmVyID0gXCJcIjtcblxuICAgICAgICB3aGlsZShjb3VudC0tKXtcbiAgICAgICAgICAgIGJ1ZmZlciArPSB0aGlzLnJlYWQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBidWZmZXI7XG4gICAgfVxuXG59O1xuLyoqXG4gKiBUeXBlIHRvIHVzZSB3aGVuIGEgc3ludGF4IGVycm9yIG9jY3Vycy5cbiAqIEBjbGFzcyBTeW50YXhFcnJvclxuICogQG5hbWVzcGFjZSBwYXJzZXJsaWIudXRpbFxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBUaGUgZXJyb3IgbWVzc2FnZS5cbiAqIEBwYXJhbSB7aW50fSBsaW5lIFRoZSBsaW5lIGF0IHdoaWNoIHRoZSBlcnJvciBvY2N1cnJlZC5cbiAqIEBwYXJhbSB7aW50fSBjb2wgVGhlIGNvbHVtbiBhdCB3aGljaCB0aGUgZXJyb3Igb2NjdXJyZWQuXG4gKi9cbmZ1bmN0aW9uIFN5bnRheEVycm9yKG1lc3NhZ2UsIGxpbmUsIGNvbCl7XG4gICAgRXJyb3IuY2FsbCh0aGlzKTtcbiAgICB0aGlzLm5hbWUgPSB0aGlzLmNvbnN0cnVjdG9yLm5hbWU7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgY29sdW1uIGF0IHdoaWNoIHRoZSBlcnJvciBvY2N1cnJlZC5cbiAgICAgKiBAdHlwZSBpbnRcbiAgICAgKiBAcHJvcGVydHkgY29sXG4gICAgICovXG4gICAgdGhpcy5jb2wgPSBjb2w7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbGluZSBhdCB3aGljaCB0aGUgZXJyb3Igb2NjdXJyZWQuXG4gICAgICogQHR5cGUgaW50XG4gICAgICogQHByb3BlcnR5IGxpbmVcbiAgICAgKi9cbiAgICB0aGlzLmxpbmUgPSBsaW5lO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHRleHQgcmVwcmVzZW50YXRpb24gb2YgdGhlIHVuaXQuXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQHByb3BlcnR5IHRleHRcbiAgICAgKi9cbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuXG59XG5cbi8vaW5oZXJpdCBmcm9tIEVycm9yXG5TeW50YXhFcnJvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEVycm9yLnByb3RvdHlwZSk7IC8vIGpzaGludCBpZ25vcmU6bGluZVxuU3ludGF4RXJyb3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU3ludGF4RXJyb3I7IC8vIGpzaGludCBpZ25vcmU6bGluZVxuLyoqXG4gKiBCYXNlIHR5cGUgdG8gcmVwcmVzZW50IGEgc2luZ2xlIHN5bnRhY3RpYyB1bml0LlxuICogQGNsYXNzIFN5bnRheFVuaXRcbiAqIEBuYW1lc3BhY2UgcGFyc2VybGliLnV0aWxcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtTdHJpbmd9IHRleHQgVGhlIHRleHQgb2YgdGhlIHVuaXQuXG4gKiBAcGFyYW0ge2ludH0gbGluZSBUaGUgbGluZSBvZiB0ZXh0IG9uIHdoaWNoIHRoZSB1bml0IHJlc2lkZXMuXG4gKiBAcGFyYW0ge2ludH0gY29sIFRoZSBjb2x1bW4gb2YgdGV4dCBvbiB3aGljaCB0aGUgdW5pdCByZXNpZGVzLlxuICovXG5mdW5jdGlvbiBTeW50YXhVbml0KHRleHQsIGxpbmUsIGNvbCwgdHlwZSl7XG5cblxuICAgIC8qKlxuICAgICAqIFRoZSBjb2x1bW4gb2YgdGV4dCBvbiB3aGljaCB0aGUgdW5pdCByZXNpZGVzLlxuICAgICAqIEB0eXBlIGludFxuICAgICAqIEBwcm9wZXJ0eSBjb2xcbiAgICAgKi9cbiAgICB0aGlzLmNvbCA9IGNvbDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBsaW5lIG9mIHRleHQgb24gd2hpY2ggdGhlIHVuaXQgcmVzaWRlcy5cbiAgICAgKiBAdHlwZSBpbnRcbiAgICAgKiBAcHJvcGVydHkgbGluZVxuICAgICAqL1xuICAgIHRoaXMubGluZSA9IGxpbmU7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdGV4dCByZXByZXNlbnRhdGlvbiBvZiB0aGUgdW5pdC5cbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAcHJvcGVydHkgdGV4dFxuICAgICAqL1xuICAgIHRoaXMudGV4dCA9IHRleHQ7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdHlwZSBvZiBzeW50YXggdW5pdC5cbiAgICAgKiBAdHlwZSBpbnRcbiAgICAgKiBAcHJvcGVydHkgdHlwZVxuICAgICAqL1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IHN5bnRheCB1bml0IGJhc2VkIHNvbGVseSBvbiB0aGUgZ2l2ZW4gdG9rZW4uXG4gKiBDb252ZW5pZW5jZSBtZXRob2QgZm9yIGNyZWF0aW5nIGEgbmV3IHN5bnRheCB1bml0IHdoZW5cbiAqIGl0IHJlcHJlc2VudHMgYSBzaW5nbGUgdG9rZW4gaW5zdGVhZCBvZiBtdWx0aXBsZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSB0b2tlbiBUaGUgdG9rZW4gb2JqZWN0IHRvIHJlcHJlc2VudC5cbiAqIEByZXR1cm4ge3BhcnNlcmxpYi51dGlsLlN5bnRheFVuaXR9IFRoZSBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSB0b2tlbi5cbiAqIEBzdGF0aWNcbiAqIEBtZXRob2QgZnJvbVRva2VuXG4gKi9cblN5bnRheFVuaXQuZnJvbVRva2VuID0gZnVuY3Rpb24odG9rZW4pe1xuICAgIHJldHVybiBuZXcgU3ludGF4VW5pdCh0b2tlbi52YWx1ZSwgdG9rZW4uc3RhcnRMaW5lLCB0b2tlbi5zdGFydENvbCk7XG59O1xuXG5TeW50YXhVbml0LnByb3RvdHlwZSA9IHtcblxuICAgIC8vcmVzdG9yZSBjb25zdHJ1Y3RvclxuICAgIGNvbnN0cnVjdG9yOiBTeW50YXhVbml0LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdGV4dCByZXByZXNlbnRhdGlvbiBvZiB0aGUgdW5pdC5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSB0ZXh0IHJlcHJlc2VudGF0aW9uIG9mIHRoZSB1bml0LlxuICAgICAqIEBtZXRob2QgdmFsdWVPZlxuICAgICAqL1xuICAgIHZhbHVlT2Y6IGZ1bmN0aW9uKCl7XG4gICAgICAgIHJldHVybiB0aGlzLnRvU3RyaW5nKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHRleHQgcmVwcmVzZW50YXRpb24gb2YgdGhlIHVuaXQuXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBUaGUgdGV4dCByZXByZXNlbnRhdGlvbiBvZiB0aGUgdW5pdC5cbiAgICAgKiBAbWV0aG9kIHRvU3RyaW5nXG4gICAgICovXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uKCl7XG4gICAgICAgIHJldHVybiB0aGlzLnRleHQ7XG4gICAgfVxuXG59O1xuXG4vKipcbiAqIEdlbmVyaWMgVG9rZW5TdHJlYW0gcHJvdmlkaW5nIGJhc2UgZnVuY3Rpb25hbGl0eS5cbiAqIEBjbGFzcyBUb2tlblN0cmVhbUJhc2VcbiAqIEBuYW1lc3BhY2UgcGFyc2VybGliLnV0aWxcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtTdHJpbmd8U3RyaW5nUmVhZGVyfSBpbnB1dCBUaGUgdGV4dCB0byB0b2tlbml6ZSBvciBhIHJlYWRlciBmcm9tXG4gKiAgICAgIHdoaWNoIHRvIHJlYWQgdGhlIGlucHV0LlxuICovXG5mdW5jdGlvbiBUb2tlblN0cmVhbUJhc2UoaW5wdXQsIHRva2VuRGF0YSl7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgc3RyaW5nIHJlYWRlciBmb3IgZWFzeSBhY2Nlc3MgdG8gdGhlIHRleHQuXG4gICAgICogQHR5cGUgU3RyaW5nUmVhZGVyXG4gICAgICogQHByb3BlcnR5IF9yZWFkZXJcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX3JlYWRlciA9IGlucHV0ID8gbmV3IFN0cmluZ1JlYWRlcihpbnB1dC50b1N0cmluZygpKSA6IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBUb2tlbiBvYmplY3QgZm9yIHRoZSBsYXN0IGNvbnN1bWVkIHRva2VuLlxuICAgICAqIEB0eXBlIFRva2VuXG4gICAgICogQHByb3BlcnR5IF90b2tlblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fdG9rZW4gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGFycmF5IG9mIHRva2VuIGluZm9ybWF0aW9uLlxuICAgICAqIEB0eXBlIEFycmF5XG4gICAgICogQHByb3BlcnR5IF90b2tlbkRhdGFcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX3Rva2VuRGF0YSA9IHRva2VuRGF0YTtcblxuICAgIC8qKlxuICAgICAqIExvb2thaGVhZCB0b2tlbiBidWZmZXIuXG4gICAgICogQHR5cGUgQXJyYXlcbiAgICAgKiBAcHJvcGVydHkgX2x0XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9sdCA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogTG9va2FoZWFkIHRva2VuIGJ1ZmZlciBpbmRleC5cbiAgICAgKiBAdHlwZSBpbnRcbiAgICAgKiBAcHJvcGVydHkgX2x0SW5kZXhcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX2x0SW5kZXggPSAwO1xuXG4gICAgdGhpcy5fbHRJbmRleENhY2hlID0gW107XG59XG5cbi8qKlxuICogQWNjZXB0cyBhbiBhcnJheSBvZiB0b2tlbiBpbmZvcm1hdGlvbiBhbmQgb3V0cHV0c1xuICogYW4gYXJyYXkgb2YgdG9rZW4gZGF0YSBjb250YWluaW5nIGtleS12YWx1ZSBtYXBwaW5nc1xuICogYW5kIG1hdGNoaW5nIGZ1bmN0aW9ucyB0aGF0IHRoZSBUb2tlblN0cmVhbSBuZWVkcy5cbiAqIEBwYXJhbSB7QXJyYXl9IHRva2VucyBBbiBhcnJheSBvZiB0b2tlbiBkZXNjcmlwdG9ycy5cbiAqIEByZXR1cm4ge0FycmF5fSBBbiBhcnJheSBvZiBwcm9jZXNzZWQgdG9rZW4gZGF0YS5cbiAqIEBtZXRob2QgY3JlYXRlVG9rZW5EYXRhXG4gKiBAc3RhdGljXG4gKi9cblRva2VuU3RyZWFtQmFzZS5jcmVhdGVUb2tlbkRhdGEgPSBmdW5jdGlvbih0b2tlbnMpe1xuXG4gICAgdmFyIG5hbWVNYXAgICAgID0gW10sXG4gICAgICAgIHR5cGVNYXAgICAgID0gT2JqZWN0LmNyZWF0ZShudWxsKSxcbiAgICAgICAgdG9rZW5EYXRhICAgICA9IHRva2Vucy5jb25jYXQoW10pLFxuICAgICAgICBpICAgICAgICAgICAgPSAwLFxuICAgICAgICBsZW4gICAgICAgICAgICA9IHRva2VuRGF0YS5sZW5ndGgrMTtcblxuICAgIHRva2VuRGF0YS5VTktOT1dOID0gLTE7XG4gICAgdG9rZW5EYXRhLnVuc2hpZnQoe25hbWU6XCJFT0ZcIn0pO1xuXG4gICAgZm9yICg7IGkgPCBsZW47IGkrKyl7XG4gICAgICAgIG5hbWVNYXAucHVzaCh0b2tlbkRhdGFbaV0ubmFtZSk7XG4gICAgICAgIHRva2VuRGF0YVt0b2tlbkRhdGFbaV0ubmFtZV0gPSBpO1xuICAgICAgICBpZiAodG9rZW5EYXRhW2ldLnRleHQpe1xuICAgICAgICAgICAgdHlwZU1hcFt0b2tlbkRhdGFbaV0udGV4dF0gPSBpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdG9rZW5EYXRhLm5hbWUgPSBmdW5jdGlvbih0dCl7XG4gICAgICAgIHJldHVybiBuYW1lTWFwW3R0XTtcbiAgICB9O1xuXG4gICAgdG9rZW5EYXRhLnR5cGUgPSBmdW5jdGlvbihjKXtcbiAgICAgICAgcmV0dXJuIHR5cGVNYXBbY107XG4gICAgfTtcblxuICAgIHJldHVybiB0b2tlbkRhdGE7XG59O1xuXG5Ub2tlblN0cmVhbUJhc2UucHJvdG90eXBlID0ge1xuXG4gICAgLy9yZXN0b3JlIGNvbnN0cnVjdG9yXG4gICAgY29uc3RydWN0b3I6IFRva2VuU3RyZWFtQmFzZSxcblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIE1hdGNoaW5nIG1ldGhvZHNcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgaWYgdGhlIG5leHQgdG9rZW4gbWF0Y2hlcyB0aGUgZ2l2ZW4gdG9rZW4gdHlwZS5cbiAgICAgKiBJZiBzbywgdGhhdCB0b2tlbiBpcyBjb25zdW1lZDsgaWYgbm90LCB0aGUgdG9rZW4gaXMgcGxhY2VkXG4gICAgICogYmFjayBvbnRvIHRoZSB0b2tlbiBzdHJlYW0uIFlvdSBjYW4gcGFzcyBpbiBhbnkgbnVtYmVyIG9mXG4gICAgICogdG9rZW4gdHlwZXMgYW5kIHRoaXMgd2lsbCByZXR1cm4gdHJ1ZSBpZiBhbnkgb2YgdGhlIHRva2VuXG4gICAgICogdHlwZXMgaXMgZm91bmQuXG4gICAgICogQHBhcmFtIHtpbnR8aW50W119IHRva2VuVHlwZXMgRWl0aGVyIGEgc2luZ2xlIHRva2VuIHR5cGUgb3IgYW4gYXJyYXkgb2ZcbiAgICAgKiAgICAgIHRva2VuIHR5cGVzIHRoYXQgdGhlIG5leHQgdG9rZW4gbWlnaHQgYmUuIElmIGFuIGFycmF5IGlzIHBhc3NlZCxcbiAgICAgKiAgICAgIGl0J3MgYXNzdW1lZCB0aGF0IHRoZSB0b2tlbiBjYW4gYmUgYW55IG9mIHRoZXNlLlxuICAgICAqIEBwYXJhbSB7dmFyaWFudH0gY2hhbm5lbCAoT3B0aW9uYWwpIFRoZSBjaGFubmVsIHRvIHJlYWQgZnJvbS4gSWYgbm90XG4gICAgICogICAgICBwcm92aWRlZCwgcmVhZHMgZnJvbSB0aGUgZGVmYXVsdCAodW5uYW1lZCkgY2hhbm5lbC5cbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBUcnVlIGlmIHRoZSB0b2tlbiB0eXBlIG1hdGNoZXMsIGZhbHNlIGlmIG5vdC5cbiAgICAgKiBAbWV0aG9kIG1hdGNoXG4gICAgICovXG4gICAgbWF0Y2g6IGZ1bmN0aW9uKHRva2VuVHlwZXMsIGNoYW5uZWwpe1xuXG4gICAgICAgIC8vYWx3YXlzIGNvbnZlcnQgdG8gYW4gYXJyYXksIG1ha2VzIHRoaW5ncyBlYXNpZXJcbiAgICAgICAgaWYgKCEodG9rZW5UeXBlcyBpbnN0YW5jZW9mIEFycmF5KSl7XG4gICAgICAgICAgICB0b2tlblR5cGVzID0gW3Rva2VuVHlwZXNdO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHR0ICA9IHRoaXMuZ2V0KGNoYW5uZWwpLFxuICAgICAgICAgICAgaSAgID0gMCxcbiAgICAgICAgICAgIGxlbiA9IHRva2VuVHlwZXMubGVuZ3RoO1xuXG4gICAgICAgIHdoaWxlKGkgPCBsZW4pe1xuICAgICAgICAgICAgaWYgKHR0ID09PSB0b2tlblR5cGVzW2krK10pe1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy9ubyBtYXRjaCBmb3VuZCwgcHV0IHRoZSB0b2tlbiBiYWNrXG4gICAgICAgIHRoaXMudW5nZXQoKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIGlmIHRoZSBuZXh0IHRva2VuIG1hdGNoZXMgdGhlIGdpdmVuIHRva2VuIHR5cGUuXG4gICAgICogSWYgc28sIHRoYXQgdG9rZW4gaXMgY29uc3VtZWQ7IGlmIG5vdCwgYW4gZXJyb3IgaXMgdGhyb3duLlxuICAgICAqIEBwYXJhbSB7aW50fGludFtdfSB0b2tlblR5cGVzIEVpdGhlciBhIHNpbmdsZSB0b2tlbiB0eXBlIG9yIGFuIGFycmF5IG9mXG4gICAgICogICAgICB0b2tlbiB0eXBlcyB0aGF0IHRoZSBuZXh0IHRva2VuIHNob3VsZCBiZS4gSWYgYW4gYXJyYXkgaXMgcGFzc2VkLFxuICAgICAqICAgICAgaXQncyBhc3N1bWVkIHRoYXQgdGhlIHRva2VuIG11c3QgYmUgb25lIG9mIHRoZXNlLlxuICAgICAqIEBwYXJhbSB7dmFyaWFudH0gY2hhbm5lbCAoT3B0aW9uYWwpIFRoZSBjaGFubmVsIHRvIHJlYWQgZnJvbS4gSWYgbm90XG4gICAgICogICAgICBwcm92aWRlZCwgcmVhZHMgZnJvbSB0aGUgZGVmYXVsdCAodW5uYW1lZCkgY2hhbm5lbC5cbiAgICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgICAqIEBtZXRob2QgbXVzdE1hdGNoXG4gICAgICovXG4gICAgbXVzdE1hdGNoOiBmdW5jdGlvbih0b2tlblR5cGVzLCBjaGFubmVsKXtcblxuICAgICAgICB2YXIgdG9rZW47XG5cbiAgICAgICAgLy9hbHdheXMgY29udmVydCB0byBhbiBhcnJheSwgbWFrZXMgdGhpbmdzIGVhc2llclxuICAgICAgICBpZiAoISh0b2tlblR5cGVzIGluc3RhbmNlb2YgQXJyYXkpKXtcbiAgICAgICAgICAgIHRva2VuVHlwZXMgPSBbdG9rZW5UeXBlc107XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMubWF0Y2guYXBwbHkodGhpcywgYXJndW1lbnRzKSl7XG4gICAgICAgICAgICB0b2tlbiA9IHRoaXMuTFQoMSk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXCJFeHBlY3RlZCBcIiArIHRoaXMuX3Rva2VuRGF0YVt0b2tlblR5cGVzWzBdXS5uYW1lICtcbiAgICAgICAgICAgICAgICBcIiBhdCBsaW5lIFwiICsgdG9rZW4uc3RhcnRMaW5lICsgXCIsIGNvbCBcIiArIHRva2VuLnN0YXJ0Q29sICsgXCIuXCIsIHRva2VuLnN0YXJ0TGluZSwgdG9rZW4uc3RhcnRDb2wpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIENvbnN1bWluZyBtZXRob2RzXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAvKipcbiAgICAgKiBLZWVwcyByZWFkaW5nIGZyb20gdGhlIHRva2VuIHN0cmVhbSB1bnRpbCBlaXRoZXIgb25lIG9mIHRoZSBzcGVjaWZpZWRcbiAgICAgKiB0b2tlbiB0eXBlcyBpcyBmb3VuZCBvciB1bnRpbCB0aGUgZW5kIG9mIHRoZSBpbnB1dCBpcyByZWFjaGVkLlxuICAgICAqIEBwYXJhbSB7aW50fGludFtdfSB0b2tlblR5cGVzIEVpdGhlciBhIHNpbmdsZSB0b2tlbiB0eXBlIG9yIGFuIGFycmF5IG9mXG4gICAgICogICAgICB0b2tlbiB0eXBlcyB0aGF0IHRoZSBuZXh0IHRva2VuIHNob3VsZCBiZS4gSWYgYW4gYXJyYXkgaXMgcGFzc2VkLFxuICAgICAqICAgICAgaXQncyBhc3N1bWVkIHRoYXQgdGhlIHRva2VuIG11c3QgYmUgb25lIG9mIHRoZXNlLlxuICAgICAqIEBwYXJhbSB7dmFyaWFudH0gY2hhbm5lbCAoT3B0aW9uYWwpIFRoZSBjaGFubmVsIHRvIHJlYWQgZnJvbS4gSWYgbm90XG4gICAgICogICAgICBwcm92aWRlZCwgcmVhZHMgZnJvbSB0aGUgZGVmYXVsdCAodW5uYW1lZCkgY2hhbm5lbC5cbiAgICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgICAqIEBtZXRob2QgYWR2YW5jZVxuICAgICAqL1xuICAgIGFkdmFuY2U6IGZ1bmN0aW9uKHRva2VuVHlwZXMsIGNoYW5uZWwpe1xuXG4gICAgICAgIHdoaWxlKHRoaXMuTEEoMCkgIT09IDAgJiYgIXRoaXMubWF0Y2godG9rZW5UeXBlcywgY2hhbm5lbCkpe1xuICAgICAgICAgICAgdGhpcy5nZXQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLkxBKDApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb25zdW1lcyB0aGUgbmV4dCB0b2tlbiBmcm9tIHRoZSB0b2tlbiBzdHJlYW0uXG4gICAgICogQHJldHVybiB7aW50fSBUaGUgdG9rZW4gdHlwZSBvZiB0aGUgdG9rZW4gdGhhdCB3YXMganVzdCBjb25zdW1lZC5cbiAgICAgKiBAbWV0aG9kIGdldFxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24oY2hhbm5lbCl7XG5cbiAgICAgICAgdmFyIHRva2VuSW5mbyAgID0gdGhpcy5fdG9rZW5EYXRhLFxuICAgICAgICAgICAgaSAgICAgICAgICAgPTAsXG4gICAgICAgICAgICB0b2tlbixcbiAgICAgICAgICAgIGluZm87XG5cbiAgICAgICAgLy9jaGVjayB0aGUgbG9va2FoZWFkIGJ1ZmZlciBmaXJzdFxuICAgICAgICBpZiAodGhpcy5fbHQubGVuZ3RoICYmIHRoaXMuX2x0SW5kZXggPj0gMCAmJiB0aGlzLl9sdEluZGV4IDwgdGhpcy5fbHQubGVuZ3RoKXtcblxuICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgdGhpcy5fdG9rZW4gPSB0aGlzLl9sdFt0aGlzLl9sdEluZGV4KytdO1xuICAgICAgICAgICAgaW5mbyA9IHRva2VuSW5mb1t0aGlzLl90b2tlbi50eXBlXTtcblxuICAgICAgICAgICAgLy9vYmV5IGNoYW5uZWxzIGxvZ2ljXG4gICAgICAgICAgICB3aGlsZSgoaW5mby5jaGFubmVsICE9PSB1bmRlZmluZWQgJiYgY2hhbm5lbCAhPT0gaW5mby5jaGFubmVsKSAmJlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9sdEluZGV4IDwgdGhpcy5fbHQubGVuZ3RoKXtcbiAgICAgICAgICAgICAgICB0aGlzLl90b2tlbiA9IHRoaXMuX2x0W3RoaXMuX2x0SW5kZXgrK107XG4gICAgICAgICAgICAgICAgaW5mbyA9IHRva2VuSW5mb1t0aGlzLl90b2tlbi50eXBlXTtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vaGVyZSBiZSBkcmFnb25zXG4gICAgICAgICAgICBpZiAoKGluZm8uY2hhbm5lbCA9PT0gdW5kZWZpbmVkIHx8IGNoYW5uZWwgPT09IGluZm8uY2hhbm5lbCkgJiZcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbHRJbmRleCA8PSB0aGlzLl9sdC5sZW5ndGgpe1xuICAgICAgICAgICAgICAgIHRoaXMuX2x0SW5kZXhDYWNoZS5wdXNoKGkpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl90b2tlbi50eXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy9jYWxsIHRva2VuIHJldHJpZXZlciBtZXRob2RcbiAgICAgICAgdG9rZW4gPSB0aGlzLl9nZXRUb2tlbigpO1xuXG4gICAgICAgIC8vaWYgaXQgc2hvdWxkIGJlIGhpZGRlbiwgZG9uJ3Qgc2F2ZSBhIHRva2VuXG4gICAgICAgIGlmICh0b2tlbi50eXBlID4gLTEgJiYgIXRva2VuSW5mb1t0b2tlbi50eXBlXS5oaWRlKXtcblxuICAgICAgICAgICAgLy9hcHBseSB0b2tlbiBjaGFubmVsXG4gICAgICAgICAgICB0b2tlbi5jaGFubmVsID0gdG9rZW5JbmZvW3Rva2VuLnR5cGVdLmNoYW5uZWw7XG5cbiAgICAgICAgICAgIC8vc2F2ZSBmb3IgbGF0ZXJcbiAgICAgICAgICAgIHRoaXMuX3Rva2VuID0gdG9rZW47XG4gICAgICAgICAgICB0aGlzLl9sdC5wdXNoKHRva2VuKTtcblxuICAgICAgICAgICAgLy9zYXZlIHNwYWNlIHRoYXQgd2lsbCBiZSBtb3ZlZCAobXVzdCBiZSBkb25lIGJlZm9yZSBhcnJheSBpcyB0cnVuY2F0ZWQpXG4gICAgICAgICAgICB0aGlzLl9sdEluZGV4Q2FjaGUucHVzaCh0aGlzLl9sdC5sZW5ndGggLSB0aGlzLl9sdEluZGV4ICsgaSk7XG5cbiAgICAgICAgICAgIC8va2VlcCB0aGUgYnVmZmVyIHVuZGVyIDUgaXRlbXNcbiAgICAgICAgICAgIGlmICh0aGlzLl9sdC5sZW5ndGggPiA1KXtcbiAgICAgICAgICAgICAgICB0aGlzLl9sdC5zaGlmdCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvL2Fsc28ga2VlcCB0aGUgc2hpZnQgYnVmZmVyIHVuZGVyIDUgaXRlbXNcbiAgICAgICAgICAgIGlmICh0aGlzLl9sdEluZGV4Q2FjaGUubGVuZ3RoID4gNSl7XG4gICAgICAgICAgICAgICAgdGhpcy5fbHRJbmRleENhY2hlLnNoaWZ0KCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vdXBkYXRlIGxvb2thaGVhZCBpbmRleFxuICAgICAgICAgICAgdGhpcy5fbHRJbmRleCA9IHRoaXMuX2x0Lmxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qXG4gICAgICAgICAqIFNraXAgdG8gdGhlIG5leHQgdG9rZW4gaWY6XG4gICAgICAgICAqIDEuIFRoZSB0b2tlbiB0eXBlIGlzIG1hcmtlZCBhcyBoaWRkZW4uXG4gICAgICAgICAqIDIuIFRoZSB0b2tlbiB0eXBlIGhhcyBhIGNoYW5uZWwgc3BlY2lmaWVkIGFuZCBpdCBpc24ndCB0aGUgY3VycmVudCBjaGFubmVsLlxuICAgICAgICAgKi9cbiAgICAgICAgaW5mbyA9IHRva2VuSW5mb1t0b2tlbi50eXBlXTtcbiAgICAgICAgaWYgKGluZm8gJiZcbiAgICAgICAgICAgICAgICAoaW5mby5oaWRlIHx8XG4gICAgICAgICAgICAgICAgKGluZm8uY2hhbm5lbCAhPT0gdW5kZWZpbmVkICYmIGNoYW5uZWwgIT09IGluZm8uY2hhbm5lbCkpKXtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldChjaGFubmVsKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vcmV0dXJuIGp1c3QgdGhlIHR5cGVcbiAgICAgICAgICAgIHJldHVybiB0b2tlbi50eXBlO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIExvb2tzIGFoZWFkIGEgY2VydGFpbiBudW1iZXIgb2YgdG9rZW5zIGFuZCByZXR1cm5zIHRoZSB0b2tlbiB0eXBlIGF0XG4gICAgICogdGhhdCBwb3NpdGlvbi4gVGhpcyB3aWxsIHRocm93IGFuIGVycm9yIGlmIHlvdSBsb29rYWhlYWQgcGFzdCB0aGVcbiAgICAgKiBlbmQgb2YgaW5wdXQsIHBhc3QgdGhlIHNpemUgb2YgdGhlIGxvb2thaGVhZCBidWZmZXIsIG9yIGJhY2sgcGFzdFxuICAgICAqIHRoZSBmaXJzdCB0b2tlbiBpbiB0aGUgbG9va2FoZWFkIGJ1ZmZlci5cbiAgICAgKiBAcGFyYW0ge2ludH0gVGhlIGluZGV4IG9mIHRoZSB0b2tlbiB0eXBlIHRvIHJldHJpZXZlLiAwIGZvciB0aGVcbiAgICAgKiAgICAgIGN1cnJlbnQgdG9rZW4sIDEgZm9yIHRoZSBuZXh0LCAtMSBmb3IgdGhlIHByZXZpb3VzLCBldGMuXG4gICAgICogQHJldHVybiB7aW50fSBUaGUgdG9rZW4gdHlwZSBvZiB0aGUgdG9rZW4gaW4gdGhlIGdpdmVuIHBvc2l0aW9uLlxuICAgICAqIEBtZXRob2QgTEFcbiAgICAgKi9cbiAgICBMQTogZnVuY3Rpb24oaW5kZXgpe1xuICAgICAgICB2YXIgdG90YWwgPSBpbmRleCxcbiAgICAgICAgICAgIHR0O1xuICAgICAgICBpZiAoaW5kZXggPiAwKXtcbiAgICAgICAgICAgIC8vVE9ETzogU3RvcmUgNSBzb21ld2hlcmVcbiAgICAgICAgICAgIGlmIChpbmRleCA+IDUpe1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRvbyBtdWNoIGxvb2thaGVhZC5cIik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vZ2V0IGFsbCB0aG9zZSB0b2tlbnNcbiAgICAgICAgICAgIHdoaWxlKHRvdGFsKXtcbiAgICAgICAgICAgICAgICB0dCA9IHRoaXMuZ2V0KCk7XG4gICAgICAgICAgICAgICAgdG90YWwtLTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy91bmdldCBhbGwgdGhvc2UgdG9rZW5zXG4gICAgICAgICAgICB3aGlsZSh0b3RhbCA8IGluZGV4KXtcbiAgICAgICAgICAgICAgICB0aGlzLnVuZ2V0KCk7XG4gICAgICAgICAgICAgICAgdG90YWwrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChpbmRleCA8IDApe1xuXG4gICAgICAgICAgICBpZih0aGlzLl9sdFt0aGlzLl9sdEluZGV4K2luZGV4XSl7XG4gICAgICAgICAgICAgICAgdHQgPSB0aGlzLl9sdFt0aGlzLl9sdEluZGV4K2luZGV4XS50eXBlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUb28gbXVjaCBsb29rYmVoaW5kLlwiKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdHQgPSB0aGlzLl90b2tlbi50eXBlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHR0O1xuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIExvb2tzIGFoZWFkIGEgY2VydGFpbiBudW1iZXIgb2YgdG9rZW5zIGFuZCByZXR1cm5zIHRoZSB0b2tlbiBhdFxuICAgICAqIHRoYXQgcG9zaXRpb24uIFRoaXMgd2lsbCB0aHJvdyBhbiBlcnJvciBpZiB5b3UgbG9va2FoZWFkIHBhc3QgdGhlXG4gICAgICogZW5kIG9mIGlucHV0LCBwYXN0IHRoZSBzaXplIG9mIHRoZSBsb29rYWhlYWQgYnVmZmVyLCBvciBiYWNrIHBhc3RcbiAgICAgKiB0aGUgZmlyc3QgdG9rZW4gaW4gdGhlIGxvb2thaGVhZCBidWZmZXIuXG4gICAgICogQHBhcmFtIHtpbnR9IFRoZSBpbmRleCBvZiB0aGUgdG9rZW4gdHlwZSB0byByZXRyaWV2ZS4gMCBmb3IgdGhlXG4gICAgICogICAgICBjdXJyZW50IHRva2VuLCAxIGZvciB0aGUgbmV4dCwgLTEgZm9yIHRoZSBwcmV2aW91cywgZXRjLlxuICAgICAqIEByZXR1cm4ge09iamVjdH0gVGhlIHRva2VuIG9mIHRoZSB0b2tlbiBpbiB0aGUgZ2l2ZW4gcG9zaXRpb24uXG4gICAgICogQG1ldGhvZCBMQVxuICAgICAqL1xuICAgIExUOiBmdW5jdGlvbihpbmRleCl7XG5cbiAgICAgICAgLy9sb29rYWhlYWQgZmlyc3QgdG8gcHJpbWUgdGhlIHRva2VuIGJ1ZmZlclxuICAgICAgICB0aGlzLkxBKGluZGV4KTtcblxuICAgICAgICAvL25vdyBmaW5kIHRoZSB0b2tlbiwgc3VidHJhY3Qgb25lIGJlY2F1c2UgX2x0SW5kZXggaXMgYWxyZWFkeSBhdCB0aGUgbmV4dCBpbmRleFxuICAgICAgICByZXR1cm4gdGhpcy5fbHRbdGhpcy5fbHRJbmRleCtpbmRleC0xXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdG9rZW4gdHlwZSBmb3IgdGhlIG5leHQgdG9rZW4gaW4gdGhlIHN0cmVhbSB3aXRob3V0XG4gICAgICogY29uc3VtaW5nIGl0LlxuICAgICAqIEByZXR1cm4ge2ludH0gVGhlIHRva2VuIHR5cGUgb2YgdGhlIG5leHQgdG9rZW4gaW4gdGhlIHN0cmVhbS5cbiAgICAgKiBAbWV0aG9kIHBlZWtcbiAgICAgKi9cbiAgICBwZWVrOiBmdW5jdGlvbigpe1xuICAgICAgICByZXR1cm4gdGhpcy5MQSgxKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgYWN0dWFsIHRva2VuIG9iamVjdCBmb3IgdGhlIGxhc3QgY29uc3VtZWQgdG9rZW4uXG4gICAgICogQHJldHVybiB7VG9rZW59IFRoZSB0b2tlbiBvYmplY3QgZm9yIHRoZSBsYXN0IGNvbnN1bWVkIHRva2VuLlxuICAgICAqIEBtZXRob2QgdG9rZW5cbiAgICAgKi9cbiAgICB0b2tlbjogZnVuY3Rpb24oKXtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Rva2VuO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBuYW1lIG9mIHRoZSB0b2tlbiBmb3IgdGhlIGdpdmVuIHRva2VuIHR5cGUuXG4gICAgICogQHBhcmFtIHtpbnR9IHRva2VuVHlwZSBUaGUgdHlwZSBvZiB0b2tlbiB0byBnZXQgdGhlIG5hbWUgb2YuXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBUaGUgbmFtZSBvZiB0aGUgdG9rZW4gb3IgXCJVTktOT1dOX1RPS0VOXCIgZm9yIGFueVxuICAgICAqICAgICAgaW52YWxpZCB0b2tlbiB0eXBlLlxuICAgICAqIEBtZXRob2QgdG9rZW5OYW1lXG4gICAgICovXG4gICAgdG9rZW5OYW1lOiBmdW5jdGlvbih0b2tlblR5cGUpe1xuICAgICAgICBpZiAodG9rZW5UeXBlIDwgMCB8fCB0b2tlblR5cGUgPiB0aGlzLl90b2tlbkRhdGEubGVuZ3RoKXtcbiAgICAgICAgICAgIHJldHVybiBcIlVOS05PV05fVE9LRU5cIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl90b2tlbkRhdGFbdG9rZW5UeXBlXS5uYW1lO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHRva2VuIHR5cGUgdmFsdWUgZm9yIHRoZSBnaXZlbiB0b2tlbiBuYW1lLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0b2tlbk5hbWUgVGhlIG5hbWUgb2YgdGhlIHRva2VuIHdob3NlIHZhbHVlIHNob3VsZCBiZSByZXR1cm5lZC5cbiAgICAgKiBAcmV0dXJuIHtpbnR9IFRoZSB0b2tlbiB0eXBlIHZhbHVlIGZvciB0aGUgZ2l2ZW4gdG9rZW4gbmFtZSBvciAtMVxuICAgICAqICAgICAgZm9yIGFuIHVua25vd24gdG9rZW4uXG4gICAgICogQG1ldGhvZCB0b2tlbk5hbWVcbiAgICAgKi9cbiAgICB0b2tlblR5cGU6IGZ1bmN0aW9uKHRva2VuTmFtZSl7XG4gICAgICAgIHJldHVybiB0aGlzLl90b2tlbkRhdGFbdG9rZW5OYW1lXSB8fCAtMTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbGFzdCBjb25zdW1lZCB0b2tlbiB0byB0aGUgdG9rZW4gc3RyZWFtLlxuICAgICAqIEBtZXRob2QgdW5nZXRcbiAgICAgKi9cbiAgICB1bmdldDogZnVuY3Rpb24oKXtcbiAgICAgICAgLy9pZiAodGhpcy5fbHRJbmRleCA+IC0xKXtcbiAgICAgICAgaWYgKHRoaXMuX2x0SW5kZXhDYWNoZS5sZW5ndGgpe1xuICAgICAgICAgICAgdGhpcy5fbHRJbmRleCAtPSB0aGlzLl9sdEluZGV4Q2FjaGUucG9wKCk7Ly8tLTtcbiAgICAgICAgICAgIHRoaXMuX3Rva2VuID0gdGhpcy5fbHRbdGhpcy5fbHRJbmRleCAtIDFdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVG9vIG11Y2ggbG9va2FoZWFkLlwiKTtcbiAgICAgICAgfVxuICAgIH1cblxufTtcblxuXG5wYXJzZXJsaWIudXRpbCA9IHtcbl9fcHJvdG9fXyAgIDogbnVsbCxcblN0cmluZ1JlYWRlcjogU3RyaW5nUmVhZGVyLFxuU3ludGF4RXJyb3IgOiBTeW50YXhFcnJvcixcblN5bnRheFVuaXQgIDogU3ludGF4VW5pdCxcbkV2ZW50VGFyZ2V0IDogRXZlbnRUYXJnZXQsXG5Ub2tlblN0cmVhbUJhc2UgOiBUb2tlblN0cmVhbUJhc2Vcbn07XG59KSgpO1xuLypcblBhcnNlci1MaWJcbkNvcHlyaWdodCAoYykgMjAwOS0yMDExIE5pY2hvbGFzIEMuIFpha2FzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuXG5QZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG5vZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG5pbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG50byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG5jb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbmZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cblRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG5hbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG5GSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbkFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbkxJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG5PVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG5USEUgU09GVFdBUkUuXG5cbiovXG4vKiBWZXJzaW9uIHYwLjIuNStkb21pbm8xLCBCdWlsZCB0aW1lOiAzMC1KYW51YXJ5LTIwMTYgMDU6MTM6MDMgKi9cbihmdW5jdGlvbigpe1xudmFyIEV2ZW50VGFyZ2V0ID0gcGFyc2VybGliLnV0aWwuRXZlbnRUYXJnZXQsXG5Ub2tlblN0cmVhbUJhc2UgPSBwYXJzZXJsaWIudXRpbC5Ub2tlblN0cmVhbUJhc2UsXG5TdHJpbmdSZWFkZXIgPSBwYXJzZXJsaWIudXRpbC5TdHJpbmdSZWFkZXIsIC8vIGpzaGludCBpZ25vcmU6bGluZVxuU3ludGF4RXJyb3IgPSBwYXJzZXJsaWIudXRpbC5TeW50YXhFcnJvcixcblN5bnRheFVuaXQgID0gcGFyc2VybGliLnV0aWwuU3ludGF4VW5pdDtcblxudmFyIENvbG9ycyA9IHtcbiAgICBfX3Byb3RvX18gICAgICAgOm51bGwsXG4gICAgYWxpY2VibHVlICAgICAgIDpcIiNmMGY4ZmZcIixcbiAgICBhbnRpcXVld2hpdGUgICAgOlwiI2ZhZWJkN1wiLFxuICAgIGFxdWEgICAgICAgICAgICA6XCIjMDBmZmZmXCIsXG4gICAgYXF1YW1hcmluZSAgICAgIDpcIiM3ZmZmZDRcIixcbiAgICBhenVyZSAgICAgICAgICAgOlwiI2YwZmZmZlwiLFxuICAgIGJlaWdlICAgICAgICAgICA6XCIjZjVmNWRjXCIsXG4gICAgYmlzcXVlICAgICAgICAgIDpcIiNmZmU0YzRcIixcbiAgICBibGFjayAgICAgICAgICAgOlwiIzAwMDAwMFwiLFxuICAgIGJsYW5jaGVkYWxtb25kICA6XCIjZmZlYmNkXCIsXG4gICAgYmx1ZSAgICAgICAgICAgIDpcIiMwMDAwZmZcIixcbiAgICBibHVldmlvbGV0ICAgICAgOlwiIzhhMmJlMlwiLFxuICAgIGJyb3duICAgICAgICAgICA6XCIjYTUyYTJhXCIsXG4gICAgYnVybHl3b29kICAgICAgIDpcIiNkZWI4ODdcIixcbiAgICBjYWRldGJsdWUgICAgICAgOlwiIzVmOWVhMFwiLFxuICAgIGNoYXJ0cmV1c2UgICAgICA6XCIjN2ZmZjAwXCIsXG4gICAgY2hvY29sYXRlICAgICAgIDpcIiNkMjY5MWVcIixcbiAgICBjb3JhbCAgICAgICAgICAgOlwiI2ZmN2Y1MFwiLFxuICAgIGNvcm5mbG93ZXJibHVlICA6XCIjNjQ5NWVkXCIsXG4gICAgY29ybnNpbGsgICAgICAgIDpcIiNmZmY4ZGNcIixcbiAgICBjcmltc29uICAgICAgICAgOlwiI2RjMTQzY1wiLFxuICAgIGN5YW4gICAgICAgICAgICA6XCIjMDBmZmZmXCIsXG4gICAgZGFya2JsdWUgICAgICAgIDpcIiMwMDAwOGJcIixcbiAgICBkYXJrY3lhbiAgICAgICAgOlwiIzAwOGI4YlwiLFxuICAgIGRhcmtnb2xkZW5yb2QgICA6XCIjYjg4NjBiXCIsXG4gICAgZGFya2dyYXkgICAgICAgIDpcIiNhOWE5YTlcIixcbiAgICBkYXJrZ3JleSAgICAgICAgOlwiI2E5YTlhOVwiLFxuICAgIGRhcmtncmVlbiAgICAgICA6XCIjMDA2NDAwXCIsXG4gICAgZGFya2toYWtpICAgICAgIDpcIiNiZGI3NmJcIixcbiAgICBkYXJrbWFnZW50YSAgICAgOlwiIzhiMDA4YlwiLFxuICAgIGRhcmtvbGl2ZWdyZWVuICA6XCIjNTU2YjJmXCIsXG4gICAgZGFya29yYW5nZSAgICAgIDpcIiNmZjhjMDBcIixcbiAgICBkYXJrb3JjaGlkICAgICAgOlwiIzk5MzJjY1wiLFxuICAgIGRhcmtyZWQgICAgICAgICA6XCIjOGIwMDAwXCIsXG4gICAgZGFya3NhbG1vbiAgICAgIDpcIiNlOTk2N2FcIixcbiAgICBkYXJrc2VhZ3JlZW4gICAgOlwiIzhmYmM4ZlwiLFxuICAgIGRhcmtzbGF0ZWJsdWUgICA6XCIjNDgzZDhiXCIsXG4gICAgZGFya3NsYXRlZ3JheSAgIDpcIiMyZjRmNGZcIixcbiAgICBkYXJrc2xhdGVncmV5ICAgOlwiIzJmNGY0ZlwiLFxuICAgIGRhcmt0dXJxdW9pc2UgICA6XCIjMDBjZWQxXCIsXG4gICAgZGFya3Zpb2xldCAgICAgIDpcIiM5NDAwZDNcIixcbiAgICBkZWVwcGluayAgICAgICAgOlwiI2ZmMTQ5M1wiLFxuICAgIGRlZXBza3libHVlICAgICA6XCIjMDBiZmZmXCIsXG4gICAgZGltZ3JheSAgICAgICAgIDpcIiM2OTY5NjlcIixcbiAgICBkaW1ncmV5ICAgICAgICAgOlwiIzY5Njk2OVwiLFxuICAgIGRvZGdlcmJsdWUgICAgICA6XCIjMWU5MGZmXCIsXG4gICAgZmlyZWJyaWNrICAgICAgIDpcIiNiMjIyMjJcIixcbiAgICBmbG9yYWx3aGl0ZSAgICAgOlwiI2ZmZmFmMFwiLFxuICAgIGZvcmVzdGdyZWVuICAgICA6XCIjMjI4YjIyXCIsXG4gICAgZnVjaHNpYSAgICAgICAgIDpcIiNmZjAwZmZcIixcbiAgICBnYWluc2Jvcm8gICAgICAgOlwiI2RjZGNkY1wiLFxuICAgIGdob3N0d2hpdGUgICAgICA6XCIjZjhmOGZmXCIsXG4gICAgZ29sZCAgICAgICAgICAgIDpcIiNmZmQ3MDBcIixcbiAgICBnb2xkZW5yb2QgICAgICAgOlwiI2RhYTUyMFwiLFxuICAgIGdyYXkgICAgICAgICAgICA6XCIjODA4MDgwXCIsXG4gICAgZ3JleSAgICAgICAgICAgIDpcIiM4MDgwODBcIixcbiAgICBncmVlbiAgICAgICAgICAgOlwiIzAwODAwMFwiLFxuICAgIGdyZWVueWVsbG93ICAgICA6XCIjYWRmZjJmXCIsXG4gICAgaG9uZXlkZXcgICAgICAgIDpcIiNmMGZmZjBcIixcbiAgICBob3RwaW5rICAgICAgICAgOlwiI2ZmNjliNFwiLFxuICAgIGluZGlhbnJlZCAgICAgICA6XCIjY2Q1YzVjXCIsXG4gICAgaW5kaWdvICAgICAgICAgIDpcIiM0YjAwODJcIixcbiAgICBpdm9yeSAgICAgICAgICAgOlwiI2ZmZmZmMFwiLFxuICAgIGtoYWtpICAgICAgICAgICA6XCIjZjBlNjhjXCIsXG4gICAgbGF2ZW5kZXIgICAgICAgIDpcIiNlNmU2ZmFcIixcbiAgICBsYXZlbmRlcmJsdXNoICAgOlwiI2ZmZjBmNVwiLFxuICAgIGxhd25ncmVlbiAgICAgICA6XCIjN2NmYzAwXCIsXG4gICAgbGVtb25jaGlmZm9uICAgIDpcIiNmZmZhY2RcIixcbiAgICBsaWdodGJsdWUgICAgICAgOlwiI2FkZDhlNlwiLFxuICAgIGxpZ2h0Y29yYWwgICAgICA6XCIjZjA4MDgwXCIsXG4gICAgbGlnaHRjeWFuICAgICAgIDpcIiNlMGZmZmZcIixcbiAgICBsaWdodGdvbGRlbnJvZHllbGxvdyAgOlwiI2ZhZmFkMlwiLFxuICAgIGxpZ2h0Z3JheSAgICAgICA6XCIjZDNkM2QzXCIsXG4gICAgbGlnaHRncmV5ICAgICAgIDpcIiNkM2QzZDNcIixcbiAgICBsaWdodGdyZWVuICAgICAgOlwiIzkwZWU5MFwiLFxuICAgIGxpZ2h0cGluayAgICAgICA6XCIjZmZiNmMxXCIsXG4gICAgbGlnaHRzYWxtb24gICAgIDpcIiNmZmEwN2FcIixcbiAgICBsaWdodHNlYWdyZWVuICAgOlwiIzIwYjJhYVwiLFxuICAgIGxpZ2h0c2t5Ymx1ZSAgICA6XCIjODdjZWZhXCIsXG4gICAgbGlnaHRzbGF0ZWdyYXkgIDpcIiM3Nzg4OTlcIixcbiAgICBsaWdodHNsYXRlZ3JleSAgOlwiIzc3ODg5OVwiLFxuICAgIGxpZ2h0c3RlZWxibHVlICA6XCIjYjBjNGRlXCIsXG4gICAgbGlnaHR5ZWxsb3cgICAgIDpcIiNmZmZmZTBcIixcbiAgICBsaW1lICAgICAgICAgICAgOlwiIzAwZmYwMFwiLFxuICAgIGxpbWVncmVlbiAgICAgICA6XCIjMzJjZDMyXCIsXG4gICAgbGluZW4gICAgICAgICAgIDpcIiNmYWYwZTZcIixcbiAgICBtYWdlbnRhICAgICAgICAgOlwiI2ZmMDBmZlwiLFxuICAgIG1hcm9vbiAgICAgICAgICA6XCIjODAwMDAwXCIsXG4gICAgbWVkaXVtYXF1YW1hcmluZTpcIiM2NmNkYWFcIixcbiAgICBtZWRpdW1ibHVlICAgICAgOlwiIzAwMDBjZFwiLFxuICAgIG1lZGl1bW9yY2hpZCAgICA6XCIjYmE1NWQzXCIsXG4gICAgbWVkaXVtcHVycGxlICAgIDpcIiM5MzcwZDhcIixcbiAgICBtZWRpdW1zZWFncmVlbiAgOlwiIzNjYjM3MVwiLFxuICAgIG1lZGl1bXNsYXRlYmx1ZSA6XCIjN2I2OGVlXCIsXG4gICAgbWVkaXVtc3ByaW5nZ3JlZW4gICA6XCIjMDBmYTlhXCIsXG4gICAgbWVkaXVtdHVycXVvaXNlIDpcIiM0OGQxY2NcIixcbiAgICBtZWRpdW12aW9sZXRyZWQgOlwiI2M3MTU4NVwiLFxuICAgIG1pZG5pZ2h0Ymx1ZSAgICA6XCIjMTkxOTcwXCIsXG4gICAgbWludGNyZWFtICAgICAgIDpcIiNmNWZmZmFcIixcbiAgICBtaXN0eXJvc2UgICAgICAgOlwiI2ZmZTRlMVwiLFxuICAgIG1vY2Nhc2luICAgICAgICA6XCIjZmZlNGI1XCIsXG4gICAgbmF2YWpvd2hpdGUgICAgIDpcIiNmZmRlYWRcIixcbiAgICBuYXZ5ICAgICAgICAgICAgOlwiIzAwMDA4MFwiLFxuICAgIG9sZGxhY2UgICAgICAgICA6XCIjZmRmNWU2XCIsXG4gICAgb2xpdmUgICAgICAgICAgIDpcIiM4MDgwMDBcIixcbiAgICBvbGl2ZWRyYWIgICAgICAgOlwiIzZiOGUyM1wiLFxuICAgIG9yYW5nZSAgICAgICAgICA6XCIjZmZhNTAwXCIsXG4gICAgb3JhbmdlcmVkICAgICAgIDpcIiNmZjQ1MDBcIixcbiAgICBvcmNoaWQgICAgICAgICAgOlwiI2RhNzBkNlwiLFxuICAgIHBhbGVnb2xkZW5yb2QgICA6XCIjZWVlOGFhXCIsXG4gICAgcGFsZWdyZWVuICAgICAgIDpcIiM5OGZiOThcIixcbiAgICBwYWxldHVycXVvaXNlICAgOlwiI2FmZWVlZVwiLFxuICAgIHBhbGV2aW9sZXRyZWQgICA6XCIjZDg3MDkzXCIsXG4gICAgcGFwYXlhd2hpcCAgICAgIDpcIiNmZmVmZDVcIixcbiAgICBwZWFjaHB1ZmYgICAgICAgOlwiI2ZmZGFiOVwiLFxuICAgIHBlcnUgICAgICAgICAgICA6XCIjY2Q4NTNmXCIsXG4gICAgcGluayAgICAgICAgICAgIDpcIiNmZmMwY2JcIixcbiAgICBwbHVtICAgICAgICAgICAgOlwiI2RkYTBkZFwiLFxuICAgIHBvd2RlcmJsdWUgICAgICA6XCIjYjBlMGU2XCIsXG4gICAgcHVycGxlICAgICAgICAgIDpcIiM4MDAwODBcIixcbiAgICByZWQgICAgICAgICAgICAgOlwiI2ZmMDAwMFwiLFxuICAgIHJvc3licm93biAgICAgICA6XCIjYmM4ZjhmXCIsXG4gICAgcm95YWxibHVlICAgICAgIDpcIiM0MTY5ZTFcIixcbiAgICBzYWRkbGVicm93biAgICAgOlwiIzhiNDUxM1wiLFxuICAgIHNhbG1vbiAgICAgICAgICA6XCIjZmE4MDcyXCIsXG4gICAgc2FuZHlicm93biAgICAgIDpcIiNmNGE0NjBcIixcbiAgICBzZWFncmVlbiAgICAgICAgOlwiIzJlOGI1N1wiLFxuICAgIHNlYXNoZWxsICAgICAgICA6XCIjZmZmNWVlXCIsXG4gICAgc2llbm5hICAgICAgICAgIDpcIiNhMDUyMmRcIixcbiAgICBzaWx2ZXIgICAgICAgICAgOlwiI2MwYzBjMFwiLFxuICAgIHNreWJsdWUgICAgICAgICA6XCIjODdjZWViXCIsXG4gICAgc2xhdGVibHVlICAgICAgIDpcIiM2YTVhY2RcIixcbiAgICBzbGF0ZWdyYXkgICAgICAgOlwiIzcwODA5MFwiLFxuICAgIHNsYXRlZ3JleSAgICAgICA6XCIjNzA4MDkwXCIsXG4gICAgc25vdyAgICAgICAgICAgIDpcIiNmZmZhZmFcIixcbiAgICBzcHJpbmdncmVlbiAgICAgOlwiIzAwZmY3ZlwiLFxuICAgIHN0ZWVsYmx1ZSAgICAgICA6XCIjNDY4MmI0XCIsXG4gICAgdGFuICAgICAgICAgICAgIDpcIiNkMmI0OGNcIixcbiAgICB0ZWFsICAgICAgICAgICAgOlwiIzAwODA4MFwiLFxuICAgIHRoaXN0bGUgICAgICAgICA6XCIjZDhiZmQ4XCIsXG4gICAgdG9tYXRvICAgICAgICAgIDpcIiNmZjYzNDdcIixcbiAgICB0dXJxdW9pc2UgICAgICAgOlwiIzQwZTBkMFwiLFxuICAgIHZpb2xldCAgICAgICAgICA6XCIjZWU4MmVlXCIsXG4gICAgd2hlYXQgICAgICAgICAgIDpcIiNmNWRlYjNcIixcbiAgICB3aGl0ZSAgICAgICAgICAgOlwiI2ZmZmZmZlwiLFxuICAgIHdoaXRlc21va2UgICAgICA6XCIjZjVmNWY1XCIsXG4gICAgeWVsbG93ICAgICAgICAgIDpcIiNmZmZmMDBcIixcbiAgICB5ZWxsb3dncmVlbiAgICAgOlwiIzlhY2QzMlwiLFxuICAgIC8vJ2N1cnJlbnRDb2xvcicgY29sb3Iga2V5d29yZCBodHRwOi8vd3d3LnczLm9yZy9UUi9jc3MzLWNvbG9yLyNjdXJyZW50Y29sb3JcbiAgICBjdXJyZW50Q29sb3IgICAgICAgIDpcIlRoZSB2YWx1ZSBvZiB0aGUgJ2NvbG9yJyBwcm9wZXJ0eS5cIixcbiAgICAvL0NTUzIgc3lzdGVtIGNvbG9ycyBodHRwOi8vd3d3LnczLm9yZy9UUi9jc3MzLWNvbG9yLyNjc3MyLXN5c3RlbVxuICAgIGFjdGl2ZUJvcmRlciAgICAgICAgOlwiQWN0aXZlIHdpbmRvdyBib3JkZXIuXCIsXG4gICAgYWN0aXZlY2FwdGlvbiAgICAgICA6XCJBY3RpdmUgd2luZG93IGNhcHRpb24uXCIsXG4gICAgYXBwd29ya3NwYWNlICAgICAgICA6XCJCYWNrZ3JvdW5kIGNvbG9yIG9mIG11bHRpcGxlIGRvY3VtZW50IGludGVyZmFjZS5cIixcbiAgICBiYWNrZ3JvdW5kICAgICAgICAgIDpcIkRlc2t0b3AgYmFja2dyb3VuZC5cIixcbiAgICBidXR0b25mYWNlICAgICAgICAgIDpcIlRoZSBmYWNlIGJhY2tncm91bmQgY29sb3IgZm9yIDMtRCBlbGVtZW50cyB0aGF0IGFwcGVhciAzLUQgZHVlIHRvIG9uZSBsYXllciBvZiBzdXJyb3VuZGluZyBib3JkZXIuXCIsXG4gICAgYnV0dG9uaGlnaGxpZ2h0ICAgICA6XCJUaGUgY29sb3Igb2YgdGhlIGJvcmRlciBmYWNpbmcgdGhlIGxpZ2h0IHNvdXJjZSBmb3IgMy1EIGVsZW1lbnRzIHRoYXQgYXBwZWFyIDMtRCBkdWUgdG8gb25lIGxheWVyIG9mIHN1cnJvdW5kaW5nIGJvcmRlci5cIixcbiAgICBidXR0b25zaGFkb3cgICAgICAgIDpcIlRoZSBjb2xvciBvZiB0aGUgYm9yZGVyIGF3YXkgZnJvbSB0aGUgbGlnaHQgc291cmNlIGZvciAzLUQgZWxlbWVudHMgdGhhdCBhcHBlYXIgMy1EIGR1ZSB0byBvbmUgbGF5ZXIgb2Ygc3Vycm91bmRpbmcgYm9yZGVyLlwiLFxuICAgIGJ1dHRvbnRleHQgICAgICAgICAgOlwiVGV4dCBvbiBwdXNoIGJ1dHRvbnMuXCIsXG4gICAgY2FwdGlvbnRleHQgICAgICAgICA6XCJUZXh0IGluIGNhcHRpb24sIHNpemUgYm94LCBhbmQgc2Nyb2xsYmFyIGFycm93IGJveC5cIixcbiAgICBncmF5dGV4dCAgICAgICAgICAgIDpcIkdyYXllZCAoZGlzYWJsZWQpIHRleHQuIFRoaXMgY29sb3IgaXMgc2V0IHRvICMwMDAgaWYgdGhlIGN1cnJlbnQgZGlzcGxheSBkcml2ZXIgZG9lcyBub3Qgc3VwcG9ydCBhIHNvbGlkIGdyYXkgY29sb3IuXCIsXG4gICAgZ3JleXRleHQgICAgICAgICAgICA6XCJHcmV5ZWQgKGRpc2FibGVkKSB0ZXh0LiBUaGlzIGNvbG9yIGlzIHNldCB0byAjMDAwIGlmIHRoZSBjdXJyZW50IGRpc3BsYXkgZHJpdmVyIGRvZXMgbm90IHN1cHBvcnQgYSBzb2xpZCBncmV5IGNvbG9yLlwiLFxuICAgIGhpZ2hsaWdodCAgICAgICAgICAgOlwiSXRlbShzKSBzZWxlY3RlZCBpbiBhIGNvbnRyb2wuXCIsXG4gICAgaGlnaGxpZ2h0dGV4dCAgICAgICA6XCJUZXh0IG9mIGl0ZW0ocykgc2VsZWN0ZWQgaW4gYSBjb250cm9sLlwiLFxuICAgIGluYWN0aXZlYm9yZGVyICAgICAgOlwiSW5hY3RpdmUgd2luZG93IGJvcmRlci5cIixcbiAgICBpbmFjdGl2ZWNhcHRpb24gICAgIDpcIkluYWN0aXZlIHdpbmRvdyBjYXB0aW9uLlwiLFxuICAgIGluYWN0aXZlY2FwdGlvbnRleHQgOlwiQ29sb3Igb2YgdGV4dCBpbiBhbiBpbmFjdGl2ZSBjYXB0aW9uLlwiLFxuICAgIGluZm9iYWNrZ3JvdW5kICAgICAgOlwiQmFja2dyb3VuZCBjb2xvciBmb3IgdG9vbHRpcCBjb250cm9scy5cIixcbiAgICBpbmZvdGV4dCAgICAgICAgICAgIDpcIlRleHQgY29sb3IgZm9yIHRvb2x0aXAgY29udHJvbHMuXCIsXG4gICAgbWVudSAgICAgICAgICAgICAgICA6XCJNZW51IGJhY2tncm91bmQuXCIsXG4gICAgbWVudXRleHQgICAgICAgICAgICA6XCJUZXh0IGluIG1lbnVzLlwiLFxuICAgIHNjcm9sbGJhciAgICAgICAgICAgOlwiU2Nyb2xsIGJhciBncmF5IGFyZWEuXCIsXG4gICAgdGhyZWVkZGFya3NoYWRvdyAgICA6XCJUaGUgY29sb3Igb2YgdGhlIGRhcmtlciAoZ2VuZXJhbGx5IG91dGVyKSBvZiB0aGUgdHdvIGJvcmRlcnMgYXdheSBmcm9tIHRoZSBsaWdodCBzb3VyY2UgZm9yIDMtRCBlbGVtZW50cyB0aGF0IGFwcGVhciAzLUQgZHVlIHRvIHR3byBjb25jZW50cmljIGxheWVycyBvZiBzdXJyb3VuZGluZyBib3JkZXIuXCIsXG4gICAgdGhyZWVkZmFjZSAgICAgICAgICA6XCJUaGUgZmFjZSBiYWNrZ3JvdW5kIGNvbG9yIGZvciAzLUQgZWxlbWVudHMgdGhhdCBhcHBlYXIgMy1EIGR1ZSB0byB0d28gY29uY2VudHJpYyBsYXllcnMgb2Ygc3Vycm91bmRpbmcgYm9yZGVyLlwiLFxuICAgIHRocmVlZGhpZ2hsaWdodCAgICAgOlwiVGhlIGNvbG9yIG9mIHRoZSBsaWdodGVyIChnZW5lcmFsbHkgb3V0ZXIpIG9mIHRoZSB0d28gYm9yZGVycyBmYWNpbmcgdGhlIGxpZ2h0IHNvdXJjZSBmb3IgMy1EIGVsZW1lbnRzIHRoYXQgYXBwZWFyIDMtRCBkdWUgdG8gdHdvIGNvbmNlbnRyaWMgbGF5ZXJzIG9mIHN1cnJvdW5kaW5nIGJvcmRlci5cIixcbiAgICB0aHJlZWRsaWdodHNoYWRvdyAgIDpcIlRoZSBjb2xvciBvZiB0aGUgZGFya2VyIChnZW5lcmFsbHkgaW5uZXIpIG9mIHRoZSB0d28gYm9yZGVycyBmYWNpbmcgdGhlIGxpZ2h0IHNvdXJjZSBmb3IgMy1EIGVsZW1lbnRzIHRoYXQgYXBwZWFyIDMtRCBkdWUgdG8gdHdvIGNvbmNlbnRyaWMgbGF5ZXJzIG9mIHN1cnJvdW5kaW5nIGJvcmRlci5cIixcbiAgICB0aHJlZWRzaGFkb3cgICAgICAgIDpcIlRoZSBjb2xvciBvZiB0aGUgbGlnaHRlciAoZ2VuZXJhbGx5IGlubmVyKSBvZiB0aGUgdHdvIGJvcmRlcnMgYXdheSBmcm9tIHRoZSBsaWdodCBzb3VyY2UgZm9yIDMtRCBlbGVtZW50cyB0aGF0IGFwcGVhciAzLUQgZHVlIHRvIHR3byBjb25jZW50cmljIGxheWVycyBvZiBzdXJyb3VuZGluZyBib3JkZXIuXCIsXG4gICAgd2luZG93ICAgICAgICAgICAgICA6XCJXaW5kb3cgYmFja2dyb3VuZC5cIixcbiAgICB3aW5kb3dmcmFtZSAgICAgICAgIDpcIldpbmRvdyBmcmFtZS5cIixcbiAgICB3aW5kb3d0ZXh0ICAgICAgICAgIDpcIlRleHQgaW4gd2luZG93cy5cIlxufTtcbi8qKlxuICogUmVwcmVzZW50cyBhIHNlbGVjdG9yIGNvbWJpbmF0b3IgKHdoaXRlc3BhY2UsICssID4pLlxuICogQG5hbWVzcGFjZSBwYXJzZXJsaWIuY3NzXG4gKiBAY2xhc3MgQ29tYmluYXRvclxuICogQGV4dGVuZHMgcGFyc2VybGliLnV0aWwuU3ludGF4VW5pdFxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge1N0cmluZ30gdGV4dCBUaGUgdGV4dCByZXByZXNlbnRhdGlvbiBvZiB0aGUgdW5pdC5cbiAqIEBwYXJhbSB7aW50fSBsaW5lIFRoZSBsaW5lIG9mIHRleHQgb24gd2hpY2ggdGhlIHVuaXQgcmVzaWRlcy5cbiAqIEBwYXJhbSB7aW50fSBjb2wgVGhlIGNvbHVtbiBvZiB0ZXh0IG9uIHdoaWNoIHRoZSB1bml0IHJlc2lkZXMuXG4gKi9cbmZ1bmN0aW9uIENvbWJpbmF0b3IodGV4dCwgbGluZSwgY29sKXtcblxuICAgIFN5bnRheFVuaXQuY2FsbCh0aGlzLCB0ZXh0LCBsaW5lLCBjb2wsIFBhcnNlci5DT01CSU5BVE9SX1RZUEUpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHR5cGUgb2YgbW9kaWZpZXIuXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQHByb3BlcnR5IHR5cGVcbiAgICAgKi9cbiAgICB0aGlzLnR5cGUgPSBcInVua25vd25cIjtcblxuICAgIC8vcHJldHR5IHNpbXBsZVxuICAgIGlmICgvXlxccyskLy50ZXN0KHRleHQpKXtcbiAgICAgICAgdGhpcy50eXBlID0gXCJkZXNjZW5kYW50XCI7XG4gICAgfSBlbHNlIGlmICh0ZXh0ID09PSBcIj5cIil7XG4gICAgICAgIHRoaXMudHlwZSA9IFwiY2hpbGRcIjtcbiAgICB9IGVsc2UgaWYgKHRleHQgPT09IFwiK1wiKXtcbiAgICAgICAgdGhpcy50eXBlID0gXCJhZGphY2VudC1zaWJsaW5nXCI7XG4gICAgfSBlbHNlIGlmICh0ZXh0ID09PSBcIn5cIil7XG4gICAgICAgIHRoaXMudHlwZSA9IFwic2libGluZ1wiO1xuICAgIH1cblxufVxuXG5Db21iaW5hdG9yLnByb3RvdHlwZSA9IG5ldyBTeW50YXhVbml0KCk7XG5Db21iaW5hdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENvbWJpbmF0b3I7XG5cbi8qKlxuICogUmVwcmVzZW50cyBhIG1lZGlhIGZlYXR1cmUsIHN1Y2ggYXMgbWF4LXdpZHRoOjUwMC5cbiAqIEBuYW1lc3BhY2UgcGFyc2VybGliLmNzc1xuICogQGNsYXNzIE1lZGlhRmVhdHVyZVxuICogQGV4dGVuZHMgcGFyc2VybGliLnV0aWwuU3ludGF4VW5pdFxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge1N5bnRheFVuaXR9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIGZlYXR1cmUuXG4gKiBAcGFyYW0ge1N5bnRheFVuaXR9IHZhbHVlIFRoZSB2YWx1ZSBvZiB0aGUgZmVhdHVyZSBvciBudWxsIGlmIG5vbmUuXG4gKi9cbmZ1bmN0aW9uIE1lZGlhRmVhdHVyZShuYW1lLCB2YWx1ZSl7XG5cbiAgICBTeW50YXhVbml0LmNhbGwodGhpcywgXCIoXCIgKyBuYW1lICsgKHZhbHVlICE9PSBudWxsID8gXCI6XCIgKyB2YWx1ZSA6IFwiXCIpICsgXCIpXCIsIG5hbWUuc3RhcnRMaW5lLCBuYW1lLnN0YXJ0Q29sLCBQYXJzZXIuTUVESUFfRkVBVFVSRV9UWVBFKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBuYW1lIG9mIHRoZSBtZWRpYSBmZWF0dXJlXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQHByb3BlcnR5IG5hbWVcbiAgICAgKi9cbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHZhbHVlIGZvciB0aGUgZmVhdHVyZSBvciBudWxsIGlmIHRoZXJlIGlzIG5vbmUuXG4gICAgICogQHR5cGUgU3ludGF4VW5pdFxuICAgICAqIEBwcm9wZXJ0eSB2YWx1ZVxuICAgICAqL1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbn1cblxuTWVkaWFGZWF0dXJlLnByb3RvdHlwZSA9IG5ldyBTeW50YXhVbml0KCk7XG5NZWRpYUZlYXR1cmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTWVkaWFGZWF0dXJlO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgYW4gaW5kaXZpZHVhbCBtZWRpYSBxdWVyeS5cbiAqIEBuYW1lc3BhY2UgcGFyc2VybGliLmNzc1xuICogQGNsYXNzIE1lZGlhUXVlcnlcbiAqIEBleHRlbmRzIHBhcnNlcmxpYi51dGlsLlN5bnRheFVuaXRcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtTdHJpbmd9IG1vZGlmaWVyIFRoZSBtb2RpZmllciBcIm5vdFwiIG9yIFwib25seVwiIChvciBudWxsKS5cbiAqIEBwYXJhbSB7U3RyaW5nfSBtZWRpYVR5cGUgVGhlIHR5cGUgb2YgbWVkaWEgKGkuZS4sIFwicHJpbnRcIikuXG4gKiBAcGFyYW0ge0FycmF5fSBwYXJ0cyBBcnJheSBvZiBzZWxlY3RvcnMgcGFydHMgbWFraW5nIHVwIHRoaXMgc2VsZWN0b3IuXG4gKiBAcGFyYW0ge2ludH0gbGluZSBUaGUgbGluZSBvZiB0ZXh0IG9uIHdoaWNoIHRoZSB1bml0IHJlc2lkZXMuXG4gKiBAcGFyYW0ge2ludH0gY29sIFRoZSBjb2x1bW4gb2YgdGV4dCBvbiB3aGljaCB0aGUgdW5pdCByZXNpZGVzLlxuICovXG5mdW5jdGlvbiBNZWRpYVF1ZXJ5KG1vZGlmaWVyLCBtZWRpYVR5cGUsIGZlYXR1cmVzLCBsaW5lLCBjb2wpe1xuXG4gICAgU3ludGF4VW5pdC5jYWxsKHRoaXMsIChtb2RpZmllciA/IG1vZGlmaWVyICsgXCIgXCI6IFwiXCIpICsgKG1lZGlhVHlwZSA/IG1lZGlhVHlwZSA6IFwiXCIpICsgKG1lZGlhVHlwZSAmJiBmZWF0dXJlcy5sZW5ndGggPiAwID8gXCIgYW5kIFwiIDogXCJcIikgKyBmZWF0dXJlcy5qb2luKFwiIGFuZCBcIiksIGxpbmUsIGNvbCwgUGFyc2VyLk1FRElBX1FVRVJZX1RZUEUpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG1lZGlhIG1vZGlmaWVyIChcIm5vdFwiIG9yIFwib25seVwiKVxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBwcm9wZXJ0eSBtb2RpZmllclxuICAgICAqL1xuICAgIHRoaXMubW9kaWZpZXIgPSBtb2RpZmllcjtcblxuICAgIC8qKlxuICAgICAqIFRoZSBtZWRpYVR5cGUgKGkuZS4sIFwicHJpbnRcIilcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAcHJvcGVydHkgbWVkaWFUeXBlXG4gICAgICovXG4gICAgdGhpcy5tZWRpYVR5cGUgPSBtZWRpYVR5cGU7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgcGFydHMgdGhhdCBtYWtlIHVwIHRoZSBzZWxlY3Rvci5cbiAgICAgKiBAdHlwZSBBcnJheVxuICAgICAqIEBwcm9wZXJ0eSBmZWF0dXJlc1xuICAgICAqL1xuICAgIHRoaXMuZmVhdHVyZXMgPSBmZWF0dXJlcztcblxufVxuXG5NZWRpYVF1ZXJ5LnByb3RvdHlwZSA9IG5ldyBTeW50YXhVbml0KCk7XG5NZWRpYVF1ZXJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE1lZGlhUXVlcnk7XG5cblxuLyoqXG4gKiBBIENTUzMgcGFyc2VyLlxuICogQG5hbWVzcGFjZSBwYXJzZXJsaWIuY3NzXG4gKiBAY2xhc3MgUGFyc2VyXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIChPcHRpb25hbCkgVmFyaW91cyBvcHRpb25zIGZvciB0aGUgcGFyc2VyOlxuICogICAgICBzdGFySGFjayAodHJ1ZXxmYWxzZSkgdG8gYWxsb3cgSUU2IHN0YXIgaGFjayBhcyB2YWxpZCxcbiAqICAgICAgdW5kZXJzY29yZUhhY2sgKHRydWV8ZmFsc2UpIHRvIGludGVycHJldCBsZWFkaW5nIHVuZGVyc2NvcmVzXG4gKiAgICAgIGFzIElFNi03IHRhcmdldGluZyBmb3Iga25vd24gcHJvcGVydGllcywgaWVGaWx0ZXJzICh0cnVlfGZhbHNlKVxuICogICAgICB0byBpbmRpY2F0ZSB0aGF0IElFIDwgOCBmaWx0ZXJzIHNob3VsZCBiZSBhY2NlcHRlZCBhbmQgbm90IHRocm93XG4gKiAgICAgIHN5bnRheCBlcnJvcnMuXG4gKi9cbmZ1bmN0aW9uIFBhcnNlcihvcHRpb25zKXtcblxuICAgIC8vaW5oZXJpdCBldmVudCBmdW5jdGlvbmFsaXR5XG4gICAgRXZlbnRUYXJnZXQuY2FsbCh0aGlzKTtcblxuXG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIHRoaXMuX3Rva2VuU3RyZWFtID0gbnVsbDtcbn1cblxuLy9TdGF0aWMgY29uc3RhbnRzXG5QYXJzZXIuREVGQVVMVF9UWVBFID0gMDtcblBhcnNlci5DT01CSU5BVE9SX1RZUEUgPSAxO1xuUGFyc2VyLk1FRElBX0ZFQVRVUkVfVFlQRSA9IDI7XG5QYXJzZXIuTUVESUFfUVVFUllfVFlQRSA9IDM7XG5QYXJzZXIuUFJPUEVSVFlfTkFNRV9UWVBFID0gNDtcblBhcnNlci5QUk9QRVJUWV9WQUxVRV9UWVBFID0gNTtcblBhcnNlci5QUk9QRVJUWV9WQUxVRV9QQVJUX1RZUEUgPSA2O1xuUGFyc2VyLlNFTEVDVE9SX1RZUEUgPSA3O1xuUGFyc2VyLlNFTEVDVE9SX1BBUlRfVFlQRSA9IDg7XG5QYXJzZXIuU0VMRUNUT1JfU1VCX1BBUlRfVFlQRSA9IDk7XG5cblBhcnNlci5wcm90b3R5cGUgPSBmdW5jdGlvbigpe1xuXG4gICAgdmFyIHByb3RvID0gbmV3IEV2ZW50VGFyZ2V0KCksICAvL25ldyBwcm90b3R5cGVcbiAgICAgICAgcHJvcCxcbiAgICAgICAgYWRkaXRpb25zID0gIHtcbiAgICAgICAgICAgIF9fcHJvdG9fXzogbnVsbCxcblxuICAgICAgICAgICAgLy9yZXN0b3JlIGNvbnN0cnVjdG9yXG4gICAgICAgICAgICBjb25zdHJ1Y3RvcjogUGFyc2VyLFxuXG4gICAgICAgICAgICAvL2luc3RhbmNlIGNvbnN0YW50cyAtIHl1Y2tcbiAgICAgICAgICAgIERFRkFVTFRfVFlQRSA6IDAsXG4gICAgICAgICAgICBDT01CSU5BVE9SX1RZUEUgOiAxLFxuICAgICAgICAgICAgTUVESUFfRkVBVFVSRV9UWVBFIDogMixcbiAgICAgICAgICAgIE1FRElBX1FVRVJZX1RZUEUgOiAzLFxuICAgICAgICAgICAgUFJPUEVSVFlfTkFNRV9UWVBFIDogNCxcbiAgICAgICAgICAgIFBST1BFUlRZX1ZBTFVFX1RZUEUgOiA1LFxuICAgICAgICAgICAgUFJPUEVSVFlfVkFMVUVfUEFSVF9UWVBFIDogNixcbiAgICAgICAgICAgIFNFTEVDVE9SX1RZUEUgOiA3LFxuICAgICAgICAgICAgU0VMRUNUT1JfUEFSVF9UWVBFIDogOCxcbiAgICAgICAgICAgIFNFTEVDVE9SX1NVQl9QQVJUX1RZUEUgOiA5LFxuXG4gICAgICAgICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgICAgICAvLyBHcmFtbWFyXG4gICAgICAgICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgICAgIF9zdHlsZXNoZWV0OiBmdW5jdGlvbigpe1xuXG4gICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgKiBzdHlsZXNoZWV0XG4gICAgICAgICAgICAgICAgICogIDogWyBDSEFSU0VUX1NZTSBTKiBTVFJJTkcgUyogJzsnIF0/XG4gICAgICAgICAgICAgICAgICogICAgW1N8Q0RPfENEQ10qIFsgaW1wb3J0IFtTfENET3xDRENdKiBdKlxuICAgICAgICAgICAgICAgICAqICAgIFsgbmFtZXNwYWNlIFtTfENET3xDRENdKiBdKlxuICAgICAgICAgICAgICAgICAqICAgIFsgWyBydWxlc2V0IHwgbWVkaWEgfCBwYWdlIHwgZm9udF9mYWNlIHwga2V5ZnJhbWVzIF0gW1N8Q0RPfENEQ10qIF0qXG4gICAgICAgICAgICAgICAgICogIDtcbiAgICAgICAgICAgICAgICAgKi9cblxuICAgICAgICAgICAgICAgIHZhciB0b2tlblN0cmVhbSA9IHRoaXMuX3Rva2VuU3RyZWFtLFxuICAgICAgICAgICAgICAgICAgICBjb3VudCxcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4sXG4gICAgICAgICAgICAgICAgICAgIHR0O1xuXG4gICAgICAgICAgICAgICAgdGhpcy5maXJlKFwic3RhcnRzdHlsZXNoZWV0XCIpO1xuXG4gICAgICAgICAgICAgICAgLy90cnkgdG8gcmVhZCBjaGFyYWN0ZXIgc2V0XG4gICAgICAgICAgICAgICAgdGhpcy5fY2hhcnNldCgpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5fc2tpcENydWZ0KCk7XG5cbiAgICAgICAgICAgICAgICAvL3RyeSB0byByZWFkIGltcG9ydHMgLSBtYXkgYmUgbW9yZSB0aGFuIG9uZVxuICAgICAgICAgICAgICAgIHdoaWxlICh0b2tlblN0cmVhbS5wZWVrKCkgPT09IFRva2Vucy5JTVBPUlRfU1lNKXtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faW1wb3J0KCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3NraXBDcnVmdCgpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vdHJ5IHRvIHJlYWQgbmFtZXNwYWNlcyAtIG1heSBiZSBtb3JlIHRoYW4gb25lXG4gICAgICAgICAgICAgICAgd2hpbGUgKHRva2VuU3RyZWFtLnBlZWsoKSA9PT0gVG9rZW5zLk5BTUVTUEFDRV9TWU0pe1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9uYW1lc3BhY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2tpcENydWZ0KCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy9nZXQgdGhlIG5leHQgdG9rZW5cbiAgICAgICAgICAgICAgICB0dCA9IHRva2VuU3RyZWFtLnBlZWsoKTtcblxuICAgICAgICAgICAgICAgIC8vdHJ5IHRvIHJlYWQgdGhlIHJlc3RcbiAgICAgICAgICAgICAgICB3aGlsZSh0dCA+IFRva2Vucy5FT0Ype1xuXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCh0dCl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBUb2tlbnMuTUVESUFfU1lNOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9tZWRpYSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9za2lwQ3J1ZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBUb2tlbnMuUEFHRV9TWU06XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3BhZ2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2tpcENydWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgVG9rZW5zLkZPTlRfRkFDRV9TWU06XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2ZvbnRfZmFjZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9za2lwQ3J1ZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBUb2tlbnMuS0VZRlJBTUVTX1NZTTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fa2V5ZnJhbWVzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3NraXBDcnVmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFRva2Vucy5WSUVXUE9SVF9TWU06XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3ZpZXdwb3J0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3NraXBDcnVmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFRva2Vucy5ET0NVTUVOVF9TWU06XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2RvY3VtZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3NraXBDcnVmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFRva2Vucy5VTktOT1dOX1NZTTogIC8vdW5rbm93biBAIHJ1bGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5TdHJlYW0uZ2V0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5vcHRpb25zLnN0cmljdCl7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vZmlyZSBlcnJvciBldmVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5maXJlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAgICAgICBcImVycm9yXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6ICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiAgICBcIlVua25vd24gQCBydWxlOiBcIiArIHRva2VuU3RyZWFtLkxUKDApLnZhbHVlICsgXCIuXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZTogICAgICAgdG9rZW5TdHJlYW0uTFQoMCkuc3RhcnRMaW5lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbDogICAgICAgIHRva2VuU3RyZWFtLkxUKDApLnN0YXJ0Q29sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9za2lwIGJyYWNlc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY291bnQ9MDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICh0b2tlblN0cmVhbS5hZHZhbmNlKFtUb2tlbnMuTEJSQUNFLCBUb2tlbnMuUkJSQUNFXSkgPT09IFRva2Vucy5MQlJBQ0Upe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50Kys7ICAgIC8va2VlcCB0cmFjayBvZiBuZXN0aW5nIGRlcHRoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlKGNvdW50KXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlblN0cmVhbS5hZHZhbmNlKFtUb2tlbnMuUkJSQUNFXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY291bnQtLTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9ub3QgYSBzeW50YXggZXJyb3IsIHJldGhyb3cgaXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcIlVua25vd24gQCBydWxlLlwiLCB0b2tlblN0cmVhbS5MVCgwKS5zdGFydExpbmUsIHRva2VuU3RyZWFtLkxUKDApLnN0YXJ0Q29sKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFRva2Vucy5TOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZWFkV2hpdGVzcGFjZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZighdGhpcy5fcnVsZXNldCgpKXtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9lcnJvciBoYW5kbGluZyBmb3Iga25vd24gaXNzdWVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2godHQpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgVG9rZW5zLkNIQVJTRVRfU1lNOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IHRva2VuU3RyZWFtLkxUKDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jaGFyc2V0KGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFwiQGNoYXJzZXQgbm90IGFsbG93ZWQgaGVyZS5cIiwgdG9rZW4uc3RhcnRMaW5lLCB0b2tlbi5zdGFydENvbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBUb2tlbnMuSU1QT1JUX1NZTTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSB0b2tlblN0cmVhbS5MVCgxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5faW1wb3J0KGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFwiQGltcG9ydCBub3QgYWxsb3dlZCBoZXJlLlwiLCB0b2tlbi5zdGFydExpbmUsIHRva2VuLnN0YXJ0Q29sKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFRva2Vucy5OQU1FU1BBQ0VfU1lNOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IHRva2VuU3RyZWFtLkxUKDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9uYW1lc3BhY2UoZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXCJAbmFtZXNwYWNlIG5vdCBhbGxvd2VkIGhlcmUuXCIsIHRva2VuLnN0YXJ0TGluZSwgdG9rZW4uc3RhcnRDb2wpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuU3RyZWFtLmdldCgpOyAgLy9nZXQgdGhlIGxhc3QgdG9rZW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdW5leHBlY3RlZFRva2VuKHRva2VuU3RyZWFtLnRva2VuKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaChleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV4IGluc3RhbmNlb2YgU3ludGF4RXJyb3IgJiYgIXRoaXMub3B0aW9ucy5zdHJpY3Qpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZmlyZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICAgICAgIFwiZXJyb3JcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6ICAgICAgZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICAgIGV4Lm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmU6ICAgICAgIGV4LmxpbmUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbDogICAgICAgIGV4LmNvbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBleDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHR0ID0gdG9rZW5TdHJlYW0ucGVlaygpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh0dCAhPT0gVG9rZW5zLkVPRil7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3VuZXhwZWN0ZWRUb2tlbih0b2tlblN0cmVhbS50b2tlbigpKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLmZpcmUoXCJlbmRzdHlsZXNoZWV0XCIpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgX2NoYXJzZXQ6IGZ1bmN0aW9uKGVtaXQpe1xuICAgICAgICAgICAgICAgIHZhciB0b2tlblN0cmVhbSA9IHRoaXMuX3Rva2VuU3RyZWFtLFxuICAgICAgICAgICAgICAgICAgICBjaGFyc2V0LFxuICAgICAgICAgICAgICAgICAgICB0b2tlbixcbiAgICAgICAgICAgICAgICAgICAgbGluZSxcbiAgICAgICAgICAgICAgICAgICAgY29sO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRva2VuU3RyZWFtLm1hdGNoKFRva2Vucy5DSEFSU0VUX1NZTSkpe1xuICAgICAgICAgICAgICAgICAgICBsaW5lID0gdG9rZW5TdHJlYW0udG9rZW4oKS5zdGFydExpbmU7XG4gICAgICAgICAgICAgICAgICAgIGNvbCA9IHRva2VuU3RyZWFtLnRva2VuKCkuc3RhcnRDb2w7XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVhZFdoaXRlc3BhY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5TdHJlYW0ubXVzdE1hdGNoKFRva2Vucy5TVFJJTkcpO1xuXG4gICAgICAgICAgICAgICAgICAgIHRva2VuID0gdG9rZW5TdHJlYW0udG9rZW4oKTtcbiAgICAgICAgICAgICAgICAgICAgY2hhcnNldCA9IHRva2VuLnZhbHVlO1xuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlYWRXaGl0ZXNwYWNlKCk7XG4gICAgICAgICAgICAgICAgICAgIHRva2VuU3RyZWFtLm11c3RNYXRjaChUb2tlbnMuU0VNSUNPTE9OKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoZW1pdCAhPT0gZmFsc2Upe1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5maXJlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAgIFwiY2hhcnNldFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYXJzZXQ6Y2hhcnNldCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lOiAgIGxpbmUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sOiAgICBjb2xcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgX2ltcG9ydDogZnVuY3Rpb24oZW1pdCl7XG4gICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgKiBpbXBvcnRcbiAgICAgICAgICAgICAgICAgKiAgIDogSU1QT1JUX1NZTSBTKlxuICAgICAgICAgICAgICAgICAqICAgIFtTVFJJTkd8VVJJXSBTKiBtZWRpYV9xdWVyeV9saXN0PyAnOycgUypcbiAgICAgICAgICAgICAgICAgKi9cblxuICAgICAgICAgICAgICAgIHZhciB0b2tlblN0cmVhbSA9IHRoaXMuX3Rva2VuU3RyZWFtLFxuICAgICAgICAgICAgICAgICAgICB1cmksXG4gICAgICAgICAgICAgICAgICAgIGltcG9ydFRva2VuLFxuICAgICAgICAgICAgICAgICAgICBtZWRpYUxpc3QgICA9IFtdO1xuXG4gICAgICAgICAgICAgICAgLy9yZWFkIGltcG9ydCBzeW1ib2xcbiAgICAgICAgICAgICAgICB0b2tlblN0cmVhbS5tdXN0TWF0Y2goVG9rZW5zLklNUE9SVF9TWU0pO1xuICAgICAgICAgICAgICAgIGltcG9ydFRva2VuID0gdG9rZW5TdHJlYW0udG9rZW4oKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZWFkV2hpdGVzcGFjZSgpO1xuXG4gICAgICAgICAgICAgICAgdG9rZW5TdHJlYW0ubXVzdE1hdGNoKFtUb2tlbnMuU1RSSU5HLCBUb2tlbnMuVVJJXSk7XG5cbiAgICAgICAgICAgICAgICAvL2dyYWIgdGhlIFVSSSB2YWx1ZVxuICAgICAgICAgICAgICAgIHVyaSA9IHRva2VuU3RyZWFtLnRva2VuKCkudmFsdWUucmVwbGFjZSgvXig/OnVybFxcKCk/W1wiJ10/KFteXCInXSs/KVtcIiddP1xcKT8kLywgXCIkMVwiKTtcblxuICAgICAgICAgICAgICAgIHRoaXMuX3JlYWRXaGl0ZXNwYWNlKCk7XG5cbiAgICAgICAgICAgICAgICBtZWRpYUxpc3QgPSB0aGlzLl9tZWRpYV9xdWVyeV9saXN0KCk7XG5cbiAgICAgICAgICAgICAgICAvL211c3QgZW5kIHdpdGggYSBzZW1pY29sb25cbiAgICAgICAgICAgICAgICB0b2tlblN0cmVhbS5tdXN0TWF0Y2goVG9rZW5zLlNFTUlDT0xPTik7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVhZFdoaXRlc3BhY2UoKTtcblxuICAgICAgICAgICAgICAgIGlmIChlbWl0ICE9PSBmYWxzZSl7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmlyZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAgIFwiaW1wb3J0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB1cmk6ICAgIHVyaSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lZGlhOiAgbWVkaWFMaXN0LFxuICAgICAgICAgICAgICAgICAgICAgICAgbGluZTogICBpbXBvcnRUb2tlbi5zdGFydExpbmUsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2w6ICAgIGltcG9ydFRva2VuLnN0YXJ0Q29sXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgX25hbWVzcGFjZTogZnVuY3Rpb24oZW1pdCl7XG4gICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgKiBuYW1lc3BhY2VcbiAgICAgICAgICAgICAgICAgKiAgIDogTkFNRVNQQUNFX1NZTSBTKiBbbmFtZXNwYWNlX3ByZWZpeCBTKl0/IFtTVFJJTkd8VVJJXSBTKiAnOycgUypcbiAgICAgICAgICAgICAgICAgKi9cblxuICAgICAgICAgICAgICAgIHZhciB0b2tlblN0cmVhbSA9IHRoaXMuX3Rva2VuU3RyZWFtLFxuICAgICAgICAgICAgICAgICAgICBsaW5lLFxuICAgICAgICAgICAgICAgICAgICBjb2wsXG4gICAgICAgICAgICAgICAgICAgIHByZWZpeCxcbiAgICAgICAgICAgICAgICAgICAgdXJpO1xuXG4gICAgICAgICAgICAgICAgLy9yZWFkIGltcG9ydCBzeW1ib2xcbiAgICAgICAgICAgICAgICB0b2tlblN0cmVhbS5tdXN0TWF0Y2goVG9rZW5zLk5BTUVTUEFDRV9TWU0pO1xuICAgICAgICAgICAgICAgIGxpbmUgPSB0b2tlblN0cmVhbS50b2tlbigpLnN0YXJ0TGluZTtcbiAgICAgICAgICAgICAgICBjb2wgPSB0b2tlblN0cmVhbS50b2tlbigpLnN0YXJ0Q29sO1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlYWRXaGl0ZXNwYWNlKCk7XG5cbiAgICAgICAgICAgICAgICAvL2l0J3MgYSBuYW1lc3BhY2UgcHJlZml4IC0gbm8gX25hbWVzcGFjZV9wcmVmaXgoKSBtZXRob2QgYmVjYXVzZSBpdCdzIGp1c3QgYW4gSURFTlRcbiAgICAgICAgICAgICAgICBpZiAodG9rZW5TdHJlYW0ubWF0Y2goVG9rZW5zLklERU5UKSl7XG4gICAgICAgICAgICAgICAgICAgIHByZWZpeCA9IHRva2VuU3RyZWFtLnRva2VuKCkudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlYWRXaGl0ZXNwYWNlKCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdG9rZW5TdHJlYW0ubXVzdE1hdGNoKFtUb2tlbnMuU1RSSU5HLCBUb2tlbnMuVVJJXSk7XG4gICAgICAgICAgICAgICAgLyppZiAoIXRva2VuU3RyZWFtLm1hdGNoKFRva2Vucy5TVFJJTkcpKXtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5TdHJlYW0ubXVzdE1hdGNoKFRva2Vucy5VUkkpO1xuICAgICAgICAgICAgICAgIH0qL1xuXG4gICAgICAgICAgICAgICAgLy9ncmFiIHRoZSBVUkkgdmFsdWVcbiAgICAgICAgICAgICAgICB1cmkgPSB0b2tlblN0cmVhbS50b2tlbigpLnZhbHVlLnJlcGxhY2UoLyg/OnVybFxcKCk/W1wiJ10oW15cIiddKylbXCInXVxcKT8vLCBcIiQxXCIpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVhZFdoaXRlc3BhY2UoKTtcblxuICAgICAgICAgICAgICAgIC8vbXVzdCBlbmQgd2l0aCBhIHNlbWljb2xvblxuICAgICAgICAgICAgICAgIHRva2VuU3RyZWFtLm11c3RNYXRjaChUb2tlbnMuU0VNSUNPTE9OKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZWFkV2hpdGVzcGFjZSgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGVtaXQgIT09IGZhbHNlKXtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maXJlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICAgXCJuYW1lc3BhY2VcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZWZpeDogcHJlZml4LFxuICAgICAgICAgICAgICAgICAgICAgICAgdXJpOiAgICB1cmksXG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lOiAgIGxpbmUsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2w6ICAgIGNvbFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIF9tZWRpYTogZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAqIG1lZGlhXG4gICAgICAgICAgICAgICAgICogICA6IE1FRElBX1NZTSBTKiBtZWRpYV9xdWVyeV9saXN0IFMqICd7JyBTKiBydWxlc2V0KiAnfScgUypcbiAgICAgICAgICAgICAgICAgKiAgIDtcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB2YXIgdG9rZW5TdHJlYW0gICAgID0gdGhpcy5fdG9rZW5TdHJlYW0sXG4gICAgICAgICAgICAgICAgICAgIGxpbmUsXG4gICAgICAgICAgICAgICAgICAgIGNvbCxcbiAgICAgICAgICAgICAgICAgICAgbWVkaWFMaXN0Oy8vICAgICAgID0gW107XG5cbiAgICAgICAgICAgICAgICAvL2xvb2sgZm9yIEBtZWRpYVxuICAgICAgICAgICAgICAgIHRva2VuU3RyZWFtLm11c3RNYXRjaChUb2tlbnMuTUVESUFfU1lNKTtcbiAgICAgICAgICAgICAgICBsaW5lID0gdG9rZW5TdHJlYW0udG9rZW4oKS5zdGFydExpbmU7XG4gICAgICAgICAgICAgICAgY29sID0gdG9rZW5TdHJlYW0udG9rZW4oKS5zdGFydENvbDtcblxuICAgICAgICAgICAgICAgIHRoaXMuX3JlYWRXaGl0ZXNwYWNlKCk7XG5cbiAgICAgICAgICAgICAgICBtZWRpYUxpc3QgPSB0aGlzLl9tZWRpYV9xdWVyeV9saXN0KCk7XG5cbiAgICAgICAgICAgICAgICB0b2tlblN0cmVhbS5tdXN0TWF0Y2goVG9rZW5zLkxCUkFDRSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVhZFdoaXRlc3BhY2UoKTtcblxuICAgICAgICAgICAgICAgIHRoaXMuZmlyZSh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICAgXCJzdGFydG1lZGlhXCIsXG4gICAgICAgICAgICAgICAgICAgIG1lZGlhOiAgbWVkaWFMaXN0LFxuICAgICAgICAgICAgICAgICAgICBsaW5lOiAgIGxpbmUsXG4gICAgICAgICAgICAgICAgICAgIGNvbDogICAgY29sXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICB3aGlsZSh0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0b2tlblN0cmVhbS5wZWVrKCkgPT09IFRva2Vucy5QQUdFX1NZTSl7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9wYWdlKCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodG9rZW5TdHJlYW0ucGVlaygpID09PSBUb2tlbnMuRk9OVF9GQUNFX1NZTSl7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9mb250X2ZhY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0b2tlblN0cmVhbS5wZWVrKCkgPT09IFRva2Vucy5WSUVXUE9SVF9TWU0pe1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdmlld3BvcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0b2tlblN0cmVhbS5wZWVrKCkgPT09IFRva2Vucy5ET0NVTUVOVF9TWU0pe1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZG9jdW1lbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICghdGhpcy5fcnVsZXNldCgpKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdG9rZW5TdHJlYW0ubXVzdE1hdGNoKFRva2Vucy5SQlJBQ0UpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlYWRXaGl0ZXNwYWNlKCk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLmZpcmUoe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAgIFwiZW5kbWVkaWFcIixcbiAgICAgICAgICAgICAgICAgICAgbWVkaWE6ICBtZWRpYUxpc3QsXG4gICAgICAgICAgICAgICAgICAgIGxpbmU6ICAgbGluZSxcbiAgICAgICAgICAgICAgICAgICAgY29sOiAgICBjb2xcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG5cblxuICAgICAgICAgICAgLy9DU1MzIE1lZGlhIFF1ZXJpZXNcbiAgICAgICAgICAgIF9tZWRpYV9xdWVyeV9saXN0OiBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICogbWVkaWFfcXVlcnlfbGlzdFxuICAgICAgICAgICAgICAgICAqICAgOiBTKiBbbWVkaWFfcXVlcnkgWyAnLCcgUyogbWVkaWFfcXVlcnkgXSogXT9cbiAgICAgICAgICAgICAgICAgKiAgIDtcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB2YXIgdG9rZW5TdHJlYW0gPSB0aGlzLl90b2tlblN0cmVhbSxcbiAgICAgICAgICAgICAgICAgICAgbWVkaWFMaXN0ICAgPSBbXTtcblxuXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVhZFdoaXRlc3BhY2UoKTtcblxuICAgICAgICAgICAgICAgIGlmICh0b2tlblN0cmVhbS5wZWVrKCkgPT09IFRva2Vucy5JREVOVCB8fCB0b2tlblN0cmVhbS5wZWVrKCkgPT09IFRva2Vucy5MUEFSRU4pe1xuICAgICAgICAgICAgICAgICAgICBtZWRpYUxpc3QucHVzaCh0aGlzLl9tZWRpYV9xdWVyeSgpKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB3aGlsZSh0b2tlblN0cmVhbS5tYXRjaChUb2tlbnMuQ09NTUEpKXtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVhZFdoaXRlc3BhY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgbWVkaWFMaXN0LnB1c2godGhpcy5fbWVkaWFfcXVlcnkoKSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG1lZGlhTGlzdDtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgKiBOb3RlOiBcImV4cHJlc3Npb25cIiBpbiB0aGUgZ3JhbW1hciBtYXBzIHRvIHRoZSBfbWVkaWFfZXhwcmVzc2lvblxuICAgICAgICAgICAgICogbWV0aG9kLlxuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIF9tZWRpYV9xdWVyeTogZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAqIG1lZGlhX3F1ZXJ5XG4gICAgICAgICAgICAgICAgICogICA6IFtPTkxZIHwgTk9UXT8gUyogbWVkaWFfdHlwZSBTKiBbIEFORCBTKiBleHByZXNzaW9uIF0qXG4gICAgICAgICAgICAgICAgICogICB8IGV4cHJlc3Npb24gWyBBTkQgUyogZXhwcmVzc2lvbiBdKlxuICAgICAgICAgICAgICAgICAqICAgO1xuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHZhciB0b2tlblN0cmVhbSA9IHRoaXMuX3Rva2VuU3RyZWFtLFxuICAgICAgICAgICAgICAgICAgICB0eXBlICAgICAgICA9IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIGlkZW50ICAgICAgID0gbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4gICAgICAgPSBudWxsLFxuICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9ucyA9IFtdO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRva2VuU3RyZWFtLm1hdGNoKFRva2Vucy5JREVOVCkpe1xuICAgICAgICAgICAgICAgICAgICBpZGVudCA9IHRva2VuU3RyZWFtLnRva2VuKCkudmFsdWUudG9Mb3dlckNhc2UoKTtcblxuICAgICAgICAgICAgICAgICAgICAvL3NpbmNlIHRoZXJlJ3Mgbm8gY3VzdG9tIHRva2VucyBmb3IgdGhlc2UsIG5lZWQgdG8gbWFudWFsbHkgY2hlY2tcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlkZW50ICE9PSBcIm9ubHlcIiAmJiBpZGVudCAhPT0gXCJub3RcIil7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlblN0cmVhbS51bmdldCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWRlbnQgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSB0b2tlblN0cmVhbS50b2tlbigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVhZFdoaXRlc3BhY2UoKTtcblxuICAgICAgICAgICAgICAgIGlmICh0b2tlblN0cmVhbS5wZWVrKCkgPT09IFRva2Vucy5JREVOVCl7XG4gICAgICAgICAgICAgICAgICAgIHR5cGUgPSB0aGlzLl9tZWRpYV90eXBlKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0b2tlbiA9PT0gbnVsbCl7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IHRva2VuU3RyZWFtLnRva2VuKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRva2VuU3RyZWFtLnBlZWsoKSA9PT0gVG9rZW5zLkxQQVJFTil7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0b2tlbiA9PT0gbnVsbCl7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IHRva2VuU3RyZWFtLkxUKDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb25zLnB1c2godGhpcy5fbWVkaWFfZXhwcmVzc2lvbigpKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gbnVsbCAmJiBleHByZXNzaW9ucy5sZW5ndGggPT09IDApe1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZWFkV2hpdGVzcGFjZSgpO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAodG9rZW5TdHJlYW0ubWF0Y2goVG9rZW5zLklERU5UKSl7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodG9rZW5TdHJlYW0udG9rZW4oKS52YWx1ZS50b0xvd2VyQ2FzZSgpICE9PSBcImFuZFwiKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl91bmV4cGVjdGVkVG9rZW4odG9rZW5TdHJlYW0udG9rZW4oKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlYWRXaGl0ZXNwYWNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9ucy5wdXNoKHRoaXMuX21lZGlhX2V4cHJlc3Npb24oKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IE1lZGlhUXVlcnkoaWRlbnQsIHR5cGUsIGV4cHJlc3Npb25zLCB0b2tlbi5zdGFydExpbmUsIHRva2VuLnN0YXJ0Q29sKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8vQ1NTMyBNZWRpYSBRdWVyaWVzXG4gICAgICAgICAgICBfbWVkaWFfdHlwZTogZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAqIG1lZGlhX3R5cGVcbiAgICAgICAgICAgICAgICAgKiAgIDogSURFTlRcbiAgICAgICAgICAgICAgICAgKiAgIDtcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbWVkaWFfZmVhdHVyZSgpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBOb3RlOiBpbiBDU1MzIE1lZGlhIFF1ZXJpZXMsIHRoaXMgaXMgY2FsbGVkIFwiZXhwcmVzc2lvblwiLlxuICAgICAgICAgICAgICogUmVuYW1lZCBoZXJlIHRvIGF2b2lkIGNvbmZsaWN0IHdpdGggQ1NTMyBTZWxlY3RvcnNcbiAgICAgICAgICAgICAqIGRlZmluaXRpb24gb2YgXCJleHByZXNzaW9uXCIuIEFsc28gbm90ZSB0aGF0IFwiZXhwclwiIGluIHRoZVxuICAgICAgICAgICAgICogZ3JhbW1hciBub3cgbWFwcyB0byBcImV4cHJlc3Npb25cIiBmcm9tIENTUzMgc2VsZWN0b3JzLlxuICAgICAgICAgICAgICogQG1ldGhvZCBfbWVkaWFfZXhwcmVzc2lvblxuICAgICAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgX21lZGlhX2V4cHJlc3Npb246IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgKiBleHByZXNzaW9uXG4gICAgICAgICAgICAgICAgICogIDogJygnIFMqIG1lZGlhX2ZlYXR1cmUgUyogWyAnOicgUyogZXhwciBdPyAnKScgUypcbiAgICAgICAgICAgICAgICAgKiAgO1xuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHZhciB0b2tlblN0cmVhbSA9IHRoaXMuX3Rva2VuU3RyZWFtLFxuICAgICAgICAgICAgICAgICAgICBmZWF0dXJlICAgICA9IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHRva2VuLFxuICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uICA9IG51bGw7XG5cbiAgICAgICAgICAgICAgICB0b2tlblN0cmVhbS5tdXN0TWF0Y2goVG9rZW5zLkxQQVJFTik7XG5cbiAgICAgICAgICAgICAgICBmZWF0dXJlID0gdGhpcy5fbWVkaWFfZmVhdHVyZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlYWRXaGl0ZXNwYWNlKCk7XG5cbiAgICAgICAgICAgICAgICBpZiAodG9rZW5TdHJlYW0ubWF0Y2goVG9rZW5zLkNPTE9OKSl7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlYWRXaGl0ZXNwYWNlKCk7XG4gICAgICAgICAgICAgICAgICAgIHRva2VuID0gdG9rZW5TdHJlYW0uTFQoMSk7XG4gICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb24gPSB0aGlzLl9leHByZXNzaW9uKCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdG9rZW5TdHJlYW0ubXVzdE1hdGNoKFRva2Vucy5SUEFSRU4pO1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlYWRXaGl0ZXNwYWNlKCk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IE1lZGlhRmVhdHVyZShmZWF0dXJlLCAoZXhwcmVzc2lvbiA/IG5ldyBTeW50YXhVbml0KGV4cHJlc3Npb24sIHRva2VuLnN0YXJ0TGluZSwgdG9rZW4uc3RhcnRDb2wpIDogbnVsbCkpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLy9DU1MzIE1lZGlhIFF1ZXJpZXNcbiAgICAgICAgICAgIF9tZWRpYV9mZWF0dXJlOiBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICogbWVkaWFfZmVhdHVyZVxuICAgICAgICAgICAgICAgICAqICAgOiBJREVOVFxuICAgICAgICAgICAgICAgICAqICAgO1xuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHZhciB0b2tlblN0cmVhbSA9IHRoaXMuX3Rva2VuU3RyZWFtO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVhZFdoaXRlc3BhY2UoKTtcblxuICAgICAgICAgICAgICAgIHRva2VuU3RyZWFtLm11c3RNYXRjaChUb2tlbnMuSURFTlQpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIFN5bnRheFVuaXQuZnJvbVRva2VuKHRva2VuU3RyZWFtLnRva2VuKCkpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLy9DU1MzIFBhZ2VkIE1lZGlhXG4gICAgICAgICAgICBfcGFnZTogZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAqIHBhZ2U6XG4gICAgICAgICAgICAgICAgICogICAgUEFHRV9TWU0gUyogSURFTlQ/IHBzZXVkb19wYWdlPyBTKlxuICAgICAgICAgICAgICAgICAqICAgICd7JyBTKiBbIGRlY2xhcmF0aW9uIHwgbWFyZ2luIF0/IFsgJzsnIFMqIFsgZGVjbGFyYXRpb24gfCBtYXJnaW4gXT8gXSogJ30nIFMqXG4gICAgICAgICAgICAgICAgICogICAgO1xuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHZhciB0b2tlblN0cmVhbSA9IHRoaXMuX3Rva2VuU3RyZWFtLFxuICAgICAgICAgICAgICAgICAgICBsaW5lLFxuICAgICAgICAgICAgICAgICAgICBjb2wsXG4gICAgICAgICAgICAgICAgICAgIGlkZW50aWZpZXIgID0gbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgcHNldWRvUGFnZSAgPSBudWxsO1xuXG4gICAgICAgICAgICAgICAgLy9sb29rIGZvciBAcGFnZVxuICAgICAgICAgICAgICAgIHRva2VuU3RyZWFtLm11c3RNYXRjaChUb2tlbnMuUEFHRV9TWU0pO1xuICAgICAgICAgICAgICAgIGxpbmUgPSB0b2tlblN0cmVhbS50b2tlbigpLnN0YXJ0TGluZTtcbiAgICAgICAgICAgICAgICBjb2wgPSB0b2tlblN0cmVhbS50b2tlbigpLnN0YXJ0Q29sO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVhZFdoaXRlc3BhY2UoKTtcblxuICAgICAgICAgICAgICAgIGlmICh0b2tlblN0cmVhbS5tYXRjaChUb2tlbnMuSURFTlQpKXtcbiAgICAgICAgICAgICAgICAgICAgaWRlbnRpZmllciA9IHRva2VuU3RyZWFtLnRva2VuKCkudmFsdWU7XG5cbiAgICAgICAgICAgICAgICAgICAgLy9UaGUgdmFsdWUgJ2F1dG8nIG1heSBub3QgYmUgdXNlZCBhcyBhIHBhZ2UgbmFtZSBhbmQgTVVTVCBiZSB0cmVhdGVkIGFzIGEgc3ludGF4IGVycm9yLlxuICAgICAgICAgICAgICAgICAgICBpZiAoaWRlbnRpZmllci50b0xvd2VyQ2FzZSgpID09PSBcImF1dG9cIil7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl91bmV4cGVjdGVkVG9rZW4odG9rZW5TdHJlYW0udG9rZW4oKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvL3NlZSBpZiB0aGVyZSdzIGEgY29sb24gdXBjb21pbmdcbiAgICAgICAgICAgICAgICBpZiAodG9rZW5TdHJlYW0ucGVlaygpID09PSBUb2tlbnMuQ09MT04pe1xuICAgICAgICAgICAgICAgICAgICBwc2V1ZG9QYWdlID0gdGhpcy5fcHNldWRvX3BhZ2UoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9yZWFkV2hpdGVzcGFjZSgpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5maXJlKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogICBcInN0YXJ0cGFnZVwiLFxuICAgICAgICAgICAgICAgICAgICBpZDogICAgIGlkZW50aWZpZXIsXG4gICAgICAgICAgICAgICAgICAgIHBzZXVkbzogcHNldWRvUGFnZSxcbiAgICAgICAgICAgICAgICAgICAgbGluZTogICBsaW5lLFxuICAgICAgICAgICAgICAgICAgICBjb2w6ICAgIGNvbFxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVhZERlY2xhcmF0aW9ucyh0cnVlLCB0cnVlKTtcblxuICAgICAgICAgICAgICAgIHRoaXMuZmlyZSh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICAgXCJlbmRwYWdlXCIsXG4gICAgICAgICAgICAgICAgICAgIGlkOiAgICAgaWRlbnRpZmllcixcbiAgICAgICAgICAgICAgICAgICAgcHNldWRvOiBwc2V1ZG9QYWdlLFxuICAgICAgICAgICAgICAgICAgICBsaW5lOiAgIGxpbmUsXG4gICAgICAgICAgICAgICAgICAgIGNvbDogICAgY29sXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8vQ1NTMyBQYWdlZCBNZWRpYVxuICAgICAgICAgICAgX21hcmdpbjogZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAqIG1hcmdpbiA6XG4gICAgICAgICAgICAgICAgICogICAgbWFyZ2luX3N5bSBTKiAneycgZGVjbGFyYXRpb24gWyAnOycgUyogZGVjbGFyYXRpb24/IF0qICd9JyBTKlxuICAgICAgICAgICAgICAgICAqICAgIDtcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB2YXIgdG9rZW5TdHJlYW0gPSB0aGlzLl90b2tlblN0cmVhbSxcbiAgICAgICAgICAgICAgICAgICAgbGluZSxcbiAgICAgICAgICAgICAgICAgICAgY29sLFxuICAgICAgICAgICAgICAgICAgICBtYXJnaW5TeW0gICA9IHRoaXMuX21hcmdpbl9zeW0oKTtcblxuICAgICAgICAgICAgICAgIGlmIChtYXJnaW5TeW0pe1xuICAgICAgICAgICAgICAgICAgICBsaW5lID0gdG9rZW5TdHJlYW0udG9rZW4oKS5zdGFydExpbmU7XG4gICAgICAgICAgICAgICAgICAgIGNvbCA9IHRva2VuU3RyZWFtLnRva2VuKCkuc3RhcnRDb2w7XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maXJlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwic3RhcnRwYWdlbWFyZ2luXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXJnaW46IG1hcmdpblN5bSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmU6ICAgbGluZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbDogICAgY29sXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlYWREZWNsYXJhdGlvbnModHJ1ZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maXJlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiZW5kcGFnZW1hcmdpblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWFyZ2luOiBtYXJnaW5TeW0sXG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lOiAgIGxpbmUsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2w6ICAgIGNvbFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8vQ1NTMyBQYWdlZCBNZWRpYVxuICAgICAgICAgICAgX21hcmdpbl9zeW06IGZ1bmN0aW9uKCl7XG5cbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAqIG1hcmdpbl9zeW0gOlxuICAgICAgICAgICAgICAgICAqICAgIFRPUExFRlRDT1JORVJfU1lNIHxcbiAgICAgICAgICAgICAgICAgKiAgICBUT1BMRUZUX1NZTSB8XG4gICAgICAgICAgICAgICAgICogICAgVE9QQ0VOVEVSX1NZTSB8XG4gICAgICAgICAgICAgICAgICogICAgVE9QUklHSFRfU1lNIHxcbiAgICAgICAgICAgICAgICAgKiAgICBUT1BSSUdIVENPUk5FUl9TWU0gfFxuICAgICAgICAgICAgICAgICAqICAgIEJPVFRPTUxFRlRDT1JORVJfU1lNIHxcbiAgICAgICAgICAgICAgICAgKiAgICBCT1RUT01MRUZUX1NZTSB8XG4gICAgICAgICAgICAgICAgICogICAgQk9UVE9NQ0VOVEVSX1NZTSB8XG4gICAgICAgICAgICAgICAgICogICAgQk9UVE9NUklHSFRfU1lNIHxcbiAgICAgICAgICAgICAgICAgKiAgICBCT1RUT01SSUdIVENPUk5FUl9TWU0gfFxuICAgICAgICAgICAgICAgICAqICAgIExFRlRUT1BfU1lNIHxcbiAgICAgICAgICAgICAgICAgKiAgICBMRUZUTUlERExFX1NZTSB8XG4gICAgICAgICAgICAgICAgICogICAgTEVGVEJPVFRPTV9TWU0gfFxuICAgICAgICAgICAgICAgICAqICAgIFJJR0hUVE9QX1NZTSB8XG4gICAgICAgICAgICAgICAgICogICAgUklHSFRNSURETEVfU1lNIHxcbiAgICAgICAgICAgICAgICAgKiAgICBSSUdIVEJPVFRPTV9TWU1cbiAgICAgICAgICAgICAgICAgKiAgICA7XG4gICAgICAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgICAgICB2YXIgdG9rZW5TdHJlYW0gPSB0aGlzLl90b2tlblN0cmVhbTtcblxuICAgICAgICAgICAgICAgIGlmKHRva2VuU3RyZWFtLm1hdGNoKFtUb2tlbnMuVE9QTEVGVENPUk5FUl9TWU0sIFRva2Vucy5UT1BMRUZUX1NZTSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFRva2Vucy5UT1BDRU5URVJfU1lNLCBUb2tlbnMuVE9QUklHSFRfU1lNLCBUb2tlbnMuVE9QUklHSFRDT1JORVJfU1lNLFxuICAgICAgICAgICAgICAgICAgICAgICAgVG9rZW5zLkJPVFRPTUxFRlRDT1JORVJfU1lNLCBUb2tlbnMuQk9UVE9NTEVGVF9TWU0sXG4gICAgICAgICAgICAgICAgICAgICAgICBUb2tlbnMuQk9UVE9NQ0VOVEVSX1NZTSwgVG9rZW5zLkJPVFRPTVJJR0hUX1NZTSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFRva2Vucy5CT1RUT01SSUdIVENPUk5FUl9TWU0sIFRva2Vucy5MRUZUVE9QX1NZTSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFRva2Vucy5MRUZUTUlERExFX1NZTSwgVG9rZW5zLkxFRlRCT1RUT01fU1lNLCBUb2tlbnMuUklHSFRUT1BfU1lNLFxuICAgICAgICAgICAgICAgICAgICAgICAgVG9rZW5zLlJJR0hUTUlERExFX1NZTSwgVG9rZW5zLlJJR0hUQk9UVE9NX1NZTV0pKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFN5bnRheFVuaXQuZnJvbVRva2VuKHRva2VuU3RyZWFtLnRva2VuKCkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgX3BzZXVkb19wYWdlOiBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICogcHNldWRvX3BhZ2VcbiAgICAgICAgICAgICAgICAgKiAgIDogJzonIElERU5UXG4gICAgICAgICAgICAgICAgICogICA7XG4gICAgICAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgICAgICB2YXIgdG9rZW5TdHJlYW0gPSB0aGlzLl90b2tlblN0cmVhbTtcblxuICAgICAgICAgICAgICAgIHRva2VuU3RyZWFtLm11c3RNYXRjaChUb2tlbnMuQ09MT04pO1xuICAgICAgICAgICAgICAgIHRva2VuU3RyZWFtLm11c3RNYXRjaChUb2tlbnMuSURFTlQpO1xuXG4gICAgICAgICAgICAgICAgLy9UT0RPOiBDU1MzIFBhZ2VkIE1lZGlhIHNheXMgb25seSBcImxlZnRcIiwgXCJjZW50ZXJcIiwgYW5kIFwicmlnaHRcIiBhcmUgYWxsb3dlZFxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRva2VuU3RyZWFtLnRva2VuKCkudmFsdWU7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBfZm9udF9mYWNlOiBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICogZm9udF9mYWNlXG4gICAgICAgICAgICAgICAgICogICA6IEZPTlRfRkFDRV9TWU0gUypcbiAgICAgICAgICAgICAgICAgKiAgICAgJ3snIFMqIGRlY2xhcmF0aW9uIFsgJzsnIFMqIGRlY2xhcmF0aW9uIF0qICd9JyBTKlxuICAgICAgICAgICAgICAgICAqICAgO1xuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHZhciB0b2tlblN0cmVhbSA9IHRoaXMuX3Rva2VuU3RyZWFtLFxuICAgICAgICAgICAgICAgICAgICBsaW5lLFxuICAgICAgICAgICAgICAgICAgICBjb2w7XG5cbiAgICAgICAgICAgICAgICAvL2xvb2sgZm9yIEBwYWdlXG4gICAgICAgICAgICAgICAgdG9rZW5TdHJlYW0ubXVzdE1hdGNoKFRva2Vucy5GT05UX0ZBQ0VfU1lNKTtcbiAgICAgICAgICAgICAgICBsaW5lID0gdG9rZW5TdHJlYW0udG9rZW4oKS5zdGFydExpbmU7XG4gICAgICAgICAgICAgICAgY29sID0gdG9rZW5TdHJlYW0udG9rZW4oKS5zdGFydENvbDtcblxuICAgICAgICAgICAgICAgIHRoaXMuX3JlYWRXaGl0ZXNwYWNlKCk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLmZpcmUoe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAgIFwic3RhcnRmb250ZmFjZVwiLFxuICAgICAgICAgICAgICAgICAgICBsaW5lOiAgIGxpbmUsXG4gICAgICAgICAgICAgICAgICAgIGNvbDogICAgY29sXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9yZWFkRGVjbGFyYXRpb25zKHRydWUpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5maXJlKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogICBcImVuZGZvbnRmYWNlXCIsXG4gICAgICAgICAgICAgICAgICAgIGxpbmU6ICAgbGluZSxcbiAgICAgICAgICAgICAgICAgICAgY29sOiAgICBjb2xcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIF92aWV3cG9ydDogZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAqIHZpZXdwb3J0XG4gICAgICAgICAgICAgICAgICogICA6IFZJRVdQT1JUX1NZTSBTKlxuICAgICAgICAgICAgICAgICAqICAgICAneycgUyogZGVjbGFyYXRpb24/IFsgJzsnIFMqIGRlY2xhcmF0aW9uPyBdKiAnfScgUypcbiAgICAgICAgICAgICAgICAgKiAgIDtcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgdmFyIHRva2VuU3RyZWFtID0gdGhpcy5fdG9rZW5TdHJlYW0sXG4gICAgICAgICAgICAgICAgICAgIGxpbmUsXG4gICAgICAgICAgICAgICAgICAgIGNvbDtcblxuICAgICAgICAgICAgICAgICAgICB0b2tlblN0cmVhbS5tdXN0TWF0Y2goVG9rZW5zLlZJRVdQT1JUX1NZTSk7XG4gICAgICAgICAgICAgICAgICAgIGxpbmUgPSB0b2tlblN0cmVhbS50b2tlbigpLnN0YXJ0TGluZTtcbiAgICAgICAgICAgICAgICAgICAgY29sID0gdG9rZW5TdHJlYW0udG9rZW4oKS5zdGFydENvbDtcblxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZWFkV2hpdGVzcGFjZSgpO1xuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmlyZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAgIFwic3RhcnR2aWV3cG9ydFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGluZTogICBsaW5lLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sOiAgICBjb2xcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVhZERlY2xhcmF0aW9ucyh0cnVlKTtcblxuICAgICAgICAgICAgICAgICAgICB0aGlzLmZpcmUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogICBcImVuZHZpZXdwb3J0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lOiAgIGxpbmUsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2w6ICAgIGNvbFxuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgX2RvY3VtZW50OiBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICogZG9jdW1lbnRcbiAgICAgICAgICAgICAgICAgKiAgIDogRE9DVU1FTlRfU1lNIFMqXG4gICAgICAgICAgICAgICAgICogICAgIF9kb2N1bWVudF9mdW5jdGlvbiBbICcsJyBTKiBfZG9jdW1lbnRfZnVuY3Rpb24gXSogUypcbiAgICAgICAgICAgICAgICAgKiAgICAgJ3snIFMqIHJ1bGVzZXQqICd9J1xuICAgICAgICAgICAgICAgICAqICAgO1xuICAgICAgICAgICAgICAgICAqL1xuXG4gICAgICAgICAgICAgICAgdmFyIHRva2VuU3RyZWFtID0gdGhpcy5fdG9rZW5TdHJlYW0sXG4gICAgICAgICAgICAgICAgICAgIHRva2VuLFxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbnMgPSBbXSxcbiAgICAgICAgICAgICAgICAgICAgcHJlZml4ID0gXCJcIjtcblxuICAgICAgICAgICAgICAgIHRva2VuU3RyZWFtLm11c3RNYXRjaChUb2tlbnMuRE9DVU1FTlRfU1lNKTtcbiAgICAgICAgICAgICAgICB0b2tlbiA9IHRva2VuU3RyZWFtLnRva2VuKCk7XG4gICAgICAgICAgICAgICAgaWYgKC9eQFxcLShbXlxcLV0rKVxcLS8udGVzdCh0b2tlbi52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJlZml4ID0gUmVnRXhwLiQxO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuX3JlYWRXaGl0ZXNwYWNlKCk7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb25zLnB1c2godGhpcy5fZG9jdW1lbnRfZnVuY3Rpb24oKSk7XG5cbiAgICAgICAgICAgICAgICB3aGlsZSh0b2tlblN0cmVhbS5tYXRjaChUb2tlbnMuQ09NTUEpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlYWRXaGl0ZXNwYWNlKCk7XG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9ucy5wdXNoKHRoaXMuX2RvY3VtZW50X2Z1bmN0aW9uKCkpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRva2VuU3RyZWFtLm11c3RNYXRjaChUb2tlbnMuTEJSQUNFKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZWFkV2hpdGVzcGFjZSgpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5maXJlKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogICAgICBcInN0YXJ0ZG9jdW1lbnRcIixcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25zOiBmdW5jdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgIHByZWZpeDogICAgcHJlZml4LFxuICAgICAgICAgICAgICAgICAgICBsaW5lOiAgICAgIHRva2VuLnN0YXJ0TGluZSxcbiAgICAgICAgICAgICAgICAgICAgY29sOiAgICAgICB0b2tlbi5zdGFydENvbFxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgd2hpbGUodHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodG9rZW5TdHJlYW0ucGVlaygpID09PSBUb2tlbnMuUEFHRV9TWU0pe1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcGFnZSgpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRva2VuU3RyZWFtLnBlZWsoKSA9PT0gVG9rZW5zLkZPTlRfRkFDRV9TWU0pe1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZm9udF9mYWNlKCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodG9rZW5TdHJlYW0ucGVlaygpID09PSBUb2tlbnMuVklFV1BPUlRfU1lNKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3ZpZXdwb3J0KCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodG9rZW5TdHJlYW0ucGVlaygpID09PSBUb2tlbnMuTUVESUFfU1lNKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX21lZGlhKCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIXRoaXMuX3J1bGVzZXQoKSl7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRva2VuU3RyZWFtLm11c3RNYXRjaChUb2tlbnMuUkJSQUNFKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZWFkV2hpdGVzcGFjZSgpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5maXJlKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogICAgICBcImVuZGRvY3VtZW50XCIsXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uczogZnVuY3Rpb25zLFxuICAgICAgICAgICAgICAgICAgICBwcmVmaXg6ICAgIHByZWZpeCxcbiAgICAgICAgICAgICAgICAgICAgbGluZTogICAgICB0b2tlbi5zdGFydExpbmUsXG4gICAgICAgICAgICAgICAgICAgIGNvbDogICAgICAgdG9rZW4uc3RhcnRDb2xcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIF9kb2N1bWVudF9mdW5jdGlvbjogZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAqIGRvY3VtZW50X2Z1bmN0aW9uXG4gICAgICAgICAgICAgICAgICogICA6IGZ1bmN0aW9uIHwgVVJJIFMqXG4gICAgICAgICAgICAgICAgICogICA7XG4gICAgICAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgICAgICB2YXIgdG9rZW5TdHJlYW0gPSB0aGlzLl90b2tlblN0cmVhbSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU7XG5cbiAgICAgICAgICAgICAgICBpZiAodG9rZW5TdHJlYW0ubWF0Y2goVG9rZW5zLlVSSSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB0b2tlblN0cmVhbS50b2tlbigpLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZWFkV2hpdGVzcGFjZSgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpcy5fZnVuY3Rpb24oKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBfb3BlcmF0b3I6IGZ1bmN0aW9uKGluRnVuY3Rpb24pe1xuXG4gICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgKiBvcGVyYXRvciAob3V0c2lkZSBmdW5jdGlvbilcbiAgICAgICAgICAgICAgICAgKiAgOiAnLycgUyogfCAnLCcgUyogfCAvKCBlbXB0eSApL1xuICAgICAgICAgICAgICAgICAqIG9wZXJhdG9yIChpbnNpZGUgZnVuY3Rpb24pXG4gICAgICAgICAgICAgICAgICogIDogJy8nIFMqIHwgJysnIFMqIHwgJyonIFMqIHwgJy0nIFMqIC8oIGVtcHR5ICkvXG4gICAgICAgICAgICAgICAgICogIDtcbiAgICAgICAgICAgICAgICAgKi9cblxuICAgICAgICAgICAgICAgIHZhciB0b2tlblN0cmVhbSA9IHRoaXMuX3Rva2VuU3RyZWFtLFxuICAgICAgICAgICAgICAgICAgICB0b2tlbiAgICAgICA9IG51bGw7XG5cbiAgICAgICAgICAgICAgICBpZiAodG9rZW5TdHJlYW0ubWF0Y2goW1Rva2Vucy5TTEFTSCwgVG9rZW5zLkNPTU1BXSkgfHxcbiAgICAgICAgICAgICAgICAgICAgKGluRnVuY3Rpb24gJiYgdG9rZW5TdHJlYW0ubWF0Y2goW1Rva2Vucy5QTFVTLCBUb2tlbnMuU1RBUiwgVG9rZW5zLk1JTlVTXSkpKXtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSAgdG9rZW5TdHJlYW0udG9rZW4oKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVhZFdoaXRlc3BhY2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRva2VuID8gUHJvcGVydHlWYWx1ZVBhcnQuZnJvbVRva2VuKHRva2VuKSA6IG51bGw7XG5cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIF9jb21iaW5hdG9yOiBmdW5jdGlvbigpe1xuXG4gICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgKiBjb21iaW5hdG9yXG4gICAgICAgICAgICAgICAgICogIDogUExVUyBTKiB8IEdSRUFURVIgUyogfCBUSUxERSBTKiB8IFMrXG4gICAgICAgICAgICAgICAgICogIDtcbiAgICAgICAgICAgICAgICAgKi9cblxuICAgICAgICAgICAgICAgIHZhciB0b2tlblN0cmVhbSA9IHRoaXMuX3Rva2VuU3RyZWFtLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSAgICAgICA9IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHRva2VuO1xuXG4gICAgICAgICAgICAgICAgaWYodG9rZW5TdHJlYW0ubWF0Y2goW1Rva2Vucy5QTFVTLCBUb2tlbnMuR1JFQVRFUiwgVG9rZW5zLlRJTERFXSkpe1xuICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IHRva2VuU3RyZWFtLnRva2VuKCk7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gbmV3IENvbWJpbmF0b3IodG9rZW4udmFsdWUsIHRva2VuLnN0YXJ0TGluZSwgdG9rZW4uc3RhcnRDb2wpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZWFkV2hpdGVzcGFjZSgpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIF91bmFyeV9vcGVyYXRvcjogZnVuY3Rpb24oKXtcblxuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICogdW5hcnlfb3BlcmF0b3JcbiAgICAgICAgICAgICAgICAgKiAgOiAnLScgfCAnKydcbiAgICAgICAgICAgICAgICAgKiAgO1xuICAgICAgICAgICAgICAgICAqL1xuXG4gICAgICAgICAgICAgICAgdmFyIHRva2VuU3RyZWFtID0gdGhpcy5fdG9rZW5TdHJlYW07XG5cbiAgICAgICAgICAgICAgICBpZiAodG9rZW5TdHJlYW0ubWF0Y2goW1Rva2Vucy5NSU5VUywgVG9rZW5zLlBMVVNdKSl7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0b2tlblN0cmVhbS50b2tlbigpLnZhbHVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIF9wcm9wZXJ0eTogZnVuY3Rpb24oKXtcblxuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICogcHJvcGVydHlcbiAgICAgICAgICAgICAgICAgKiAgIDogSURFTlQgUypcbiAgICAgICAgICAgICAgICAgKiAgIDtcbiAgICAgICAgICAgICAgICAgKi9cblxuICAgICAgICAgICAgICAgIHZhciB0b2tlblN0cmVhbSA9IHRoaXMuX3Rva2VuU3RyZWFtLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSAgICAgICA9IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIGhhY2sgICAgICAgID0gbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5WYWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4sXG4gICAgICAgICAgICAgICAgICAgIGxpbmUsXG4gICAgICAgICAgICAgICAgICAgIGNvbDtcblxuICAgICAgICAgICAgICAgIC8vY2hlY2sgZm9yIHN0YXIgaGFjayAtIHRocm93cyBlcnJvciBpZiBub3QgYWxsb3dlZFxuICAgICAgICAgICAgICAgIGlmICh0b2tlblN0cmVhbS5wZWVrKCkgPT09IFRva2Vucy5TVEFSICYmIHRoaXMub3B0aW9ucy5zdGFySGFjayl7XG4gICAgICAgICAgICAgICAgICAgIHRva2VuU3RyZWFtLmdldCgpO1xuICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IHRva2VuU3RyZWFtLnRva2VuKCk7XG4gICAgICAgICAgICAgICAgICAgIGhhY2sgPSB0b2tlbi52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgbGluZSA9IHRva2VuLnN0YXJ0TGluZTtcbiAgICAgICAgICAgICAgICAgICAgY29sID0gdG9rZW4uc3RhcnRDb2w7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYodG9rZW5TdHJlYW0ubWF0Y2goVG9rZW5zLklERU5UKSl7XG4gICAgICAgICAgICAgICAgICAgIHRva2VuID0gdG9rZW5TdHJlYW0udG9rZW4oKTtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5WYWx1ZSA9IHRva2VuLnZhbHVlO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vY2hlY2sgZm9yIHVuZGVyc2NvcmUgaGFjayAtIG5vIGVycm9yIGlmIG5vdCBhbGxvd2VkIGJlY2F1c2UgaXQncyB2YWxpZCBDU1Mgc3ludGF4XG4gICAgICAgICAgICAgICAgICAgIGlmICh0b2tlblZhbHVlLmNoYXJBdCgwKSA9PT0gXCJfXCIgJiYgdGhpcy5vcHRpb25zLnVuZGVyc2NvcmVIYWNrKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhY2sgPSBcIl9cIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuVmFsdWUgPSB0b2tlblZhbHVlLnN1YnN0cmluZygxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gbmV3IFByb3BlcnR5TmFtZSh0b2tlblZhbHVlLCBoYWNrLCAobGluZXx8dG9rZW4uc3RhcnRMaW5lKSwgKGNvbHx8dG9rZW4uc3RhcnRDb2wpKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVhZFdoaXRlc3BhY2UoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvL0F1Z21lbnRlZCB3aXRoIENTUzMgU2VsZWN0b3JzXG4gICAgICAgICAgICBfcnVsZXNldDogZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAqIHJ1bGVzZXRcbiAgICAgICAgICAgICAgICAgKiAgIDogc2VsZWN0b3JzX2dyb3VwXG4gICAgICAgICAgICAgICAgICogICAgICd7JyBTKiBkZWNsYXJhdGlvbj8gWyAnOycgUyogZGVjbGFyYXRpb24/IF0qICd9JyBTKlxuICAgICAgICAgICAgICAgICAqICAgO1xuICAgICAgICAgICAgICAgICAqL1xuXG4gICAgICAgICAgICAgICAgdmFyIHRva2VuU3RyZWFtID0gdGhpcy5fdG9rZW5TdHJlYW0sXG4gICAgICAgICAgICAgICAgICAgIHR0LFxuICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcnM7XG5cblxuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICogRXJyb3IgUmVjb3Zlcnk6IElmIGV2ZW4gYSBzaW5nbGUgc2VsZWN0b3IgZmFpbHMgdG8gcGFyc2UsXG4gICAgICAgICAgICAgICAgICogdGhlbiB0aGUgZW50aXJlIHJ1bGVzZXQgc2hvdWxkIGJlIHRocm93biBhd2F5LlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdG9ycyA9IHRoaXMuX3NlbGVjdG9yc19ncm91cCgpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGV4KXtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV4IGluc3RhbmNlb2YgU3ludGF4RXJyb3IgJiYgIXRoaXMub3B0aW9ucy5zdHJpY3Qpe1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2ZpcmUgZXJyb3IgZXZlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZmlyZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogICAgICAgXCJlcnJvclwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiAgICAgIGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICAgIGV4Lm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZTogICAgICAgZXgubGluZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2w6ICAgICAgICBleC5jb2xcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvL3NraXAgb3ZlciBldmVyeXRoaW5nIHVudGlsIGNsb3NpbmcgYnJhY2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHR0ID0gdG9rZW5TdHJlYW0uYWR2YW5jZShbVG9rZW5zLlJCUkFDRV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR0ID09PSBUb2tlbnMuUkJSQUNFKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2lmIHRoZXJlJ3MgYSByaWdodCBicmFjZSwgdGhlIHJ1bGUgaXMgZmluaXNoZWQgc28gZG9uJ3QgZG8gYW55dGhpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9vdGhlcndpc2UsIHJldGhyb3cgdGhlIGVycm9yIGJlY2F1c2UgaXQgd2Fzbid0IGhhbmRsZWQgcHJvcGVybHlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBleDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9ub3QgYSBzeW50YXggZXJyb3IsIHJldGhyb3cgaXRcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGV4O1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy90cmlnZ2VyIHBhcnNlciB0byBjb250aW51ZVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvL2lmIGl0IGdvdCBoZXJlLCBhbGwgc2VsZWN0b3JzIHBhcnNlZFxuICAgICAgICAgICAgICAgIGlmIChzZWxlY3RvcnMpe1xuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmlyZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAgICAgICBcInN0YXJ0cnVsZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3JzOiAgc2VsZWN0b3JzLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGluZTogICAgICAgc2VsZWN0b3JzWzBdLmxpbmUsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2w6ICAgICAgICBzZWxlY3RvcnNbMF0uY29sXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlYWREZWNsYXJhdGlvbnModHJ1ZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maXJlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICAgICAgIFwiZW5kcnVsZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3JzOiAgc2VsZWN0b3JzLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGluZTogICAgICAgc2VsZWN0b3JzWzBdLmxpbmUsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2w6ICAgICAgICBzZWxlY3RvcnNbMF0uY29sXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGVjdG9ycztcblxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLy9DU1MzIFNlbGVjdG9yc1xuICAgICAgICAgICAgX3NlbGVjdG9yc19ncm91cDogZnVuY3Rpb24oKXtcblxuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICogc2VsZWN0b3JzX2dyb3VwXG4gICAgICAgICAgICAgICAgICogICA6IHNlbGVjdG9yIFsgQ09NTUEgUyogc2VsZWN0b3IgXSpcbiAgICAgICAgICAgICAgICAgKiAgIDtcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB2YXIgdG9rZW5TdHJlYW0gPSB0aGlzLl90b2tlblN0cmVhbSxcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3JzICAgPSBbXSxcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3I7XG5cbiAgICAgICAgICAgICAgICBzZWxlY3RvciA9IHRoaXMuX3NlbGVjdG9yKCk7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGVjdG9yICE9PSBudWxsKXtcblxuICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcnMucHVzaChzZWxlY3Rvcik7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlKHRva2VuU3RyZWFtLm1hdGNoKFRva2Vucy5DT01NQSkpe1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVhZFdoaXRlc3BhY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yID0gdGhpcy5fc2VsZWN0b3IoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZWxlY3RvciAhPT0gbnVsbCl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3JzLnB1c2goc2VsZWN0b3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl91bmV4cGVjdGVkVG9rZW4odG9rZW5TdHJlYW0uTFQoMSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGVjdG9ycy5sZW5ndGggPyBzZWxlY3RvcnMgOiBudWxsO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLy9DU1MzIFNlbGVjdG9yc1xuICAgICAgICAgICAgX3NlbGVjdG9yOiBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICogc2VsZWN0b3JcbiAgICAgICAgICAgICAgICAgKiAgIDogc2ltcGxlX3NlbGVjdG9yX3NlcXVlbmNlIFsgY29tYmluYXRvciBzaW1wbGVfc2VsZWN0b3Jfc2VxdWVuY2UgXSpcbiAgICAgICAgICAgICAgICAgKiAgIDtcbiAgICAgICAgICAgICAgICAgKi9cblxuICAgICAgICAgICAgICAgIHZhciB0b2tlblN0cmVhbSA9IHRoaXMuX3Rva2VuU3RyZWFtLFxuICAgICAgICAgICAgICAgICAgICBzZWxlY3RvciAgICA9IFtdLFxuICAgICAgICAgICAgICAgICAgICBuZXh0U2VsZWN0b3IgPSBudWxsLFxuICAgICAgICAgICAgICAgICAgICBjb21iaW5hdG9yICA9IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHdzICAgICAgICAgID0gbnVsbDtcblxuICAgICAgICAgICAgICAgIC8vaWYgdGhlcmUncyBubyBzaW1wbGUgc2VsZWN0b3IsIHRoZW4gdGhlcmUncyBubyBzZWxlY3RvclxuICAgICAgICAgICAgICAgIG5leHRTZWxlY3RvciA9IHRoaXMuX3NpbXBsZV9zZWxlY3Rvcl9zZXF1ZW5jZSgpO1xuICAgICAgICAgICAgICAgIGlmIChuZXh0U2VsZWN0b3IgPT09IG51bGwpe1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBzZWxlY3Rvci5wdXNoKG5leHRTZWxlY3Rvcik7XG5cbiAgICAgICAgICAgICAgICBkbyB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy9sb29rIGZvciBhIGNvbWJpbmF0b3JcbiAgICAgICAgICAgICAgICAgICAgY29tYmluYXRvciA9IHRoaXMuX2NvbWJpbmF0b3IoKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoY29tYmluYXRvciAhPT0gbnVsbCl7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3Rvci5wdXNoKGNvbWJpbmF0b3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dFNlbGVjdG9yID0gdGhpcy5fc2ltcGxlX3NlbGVjdG9yX3NlcXVlbmNlKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vdGhlcmUgbXVzdCBiZSBhIG5leHQgc2VsZWN0b3JcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXh0U2VsZWN0b3IgPT09IG51bGwpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3VuZXhwZWN0ZWRUb2tlbih0b2tlblN0cmVhbS5MVCgxKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9uZXh0U2VsZWN0b3IgaXMgYW4gaW5zdGFuY2Ugb2YgU2VsZWN0b3JQYXJ0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3IucHVzaChuZXh0U2VsZWN0b3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2lmIHRoZXJlJ3Mgbm90IHdoaXRlc3BhY2UsIHdlJ3JlIGRvbmVcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9yZWFkV2hpdGVzcGFjZSgpKXtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vYWRkIHdoaXRlc3BhY2Ugc2VwYXJhdG9yXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd3MgPSBuZXcgQ29tYmluYXRvcih0b2tlblN0cmVhbS50b2tlbigpLnZhbHVlLCB0b2tlblN0cmVhbS50b2tlbigpLnN0YXJ0TGluZSwgdG9rZW5TdHJlYW0udG9rZW4oKS5zdGFydENvbCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2NvbWJpbmF0b3IgaXMgbm90IHJlcXVpcmVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tYmluYXRvciA9IHRoaXMuX2NvbWJpbmF0b3IoKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vc2VsZWN0b3IgaXMgcmVxdWlyZWQgaWYgdGhlcmUncyBhIGNvbWJpbmF0b3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0U2VsZWN0b3IgPSB0aGlzLl9zaW1wbGVfc2VsZWN0b3Jfc2VxdWVuY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV4dFNlbGVjdG9yID09PSBudWxsKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbWJpbmF0b3IgIT09IG51bGwpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdW5leHBlY3RlZFRva2VuKHRva2VuU3RyZWFtLkxUKDEpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbWJpbmF0b3IgIT09IG51bGwpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3IucHVzaChjb21iaW5hdG9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yLnB1c2god3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3IucHVzaChuZXh0U2VsZWN0b3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gd2hpbGUodHJ1ZSk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFNlbGVjdG9yKHNlbGVjdG9yLCBzZWxlY3RvclswXS5saW5lLCBzZWxlY3RvclswXS5jb2wpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLy9DU1MzIFNlbGVjdG9yc1xuICAgICAgICAgICAgX3NpbXBsZV9zZWxlY3Rvcl9zZXF1ZW5jZTogZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAqIHNpbXBsZV9zZWxlY3Rvcl9zZXF1ZW5jZVxuICAgICAgICAgICAgICAgICAqICAgOiBbIHR5cGVfc2VsZWN0b3IgfCB1bml2ZXJzYWwgXVxuICAgICAgICAgICAgICAgICAqICAgICBbIEhBU0ggfCBjbGFzcyB8IGF0dHJpYiB8IHBzZXVkbyB8IG5lZ2F0aW9uIF0qXG4gICAgICAgICAgICAgICAgICogICB8IFsgSEFTSCB8IGNsYXNzIHwgYXR0cmliIHwgcHNldWRvIHwgbmVnYXRpb24gXStcbiAgICAgICAgICAgICAgICAgKiAgIDtcbiAgICAgICAgICAgICAgICAgKi9cblxuICAgICAgICAgICAgICAgIHZhciB0b2tlblN0cmVhbSA9IHRoaXMuX3Rva2VuU3RyZWFtLFxuXG4gICAgICAgICAgICAgICAgICAgIC8vcGFydHMgb2YgYSBzaW1wbGUgc2VsZWN0b3JcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudE5hbWUgPSBudWxsLFxuICAgICAgICAgICAgICAgICAgICBtb2RpZmllcnMgICA9IFtdLFxuXG4gICAgICAgICAgICAgICAgICAgIC8vY29tcGxldGUgc2VsZWN0b3IgdGV4dFxuICAgICAgICAgICAgICAgICAgICBzZWxlY3RvclRleHQ9IFwiXCIsXG5cbiAgICAgICAgICAgICAgICAgICAgLy90aGUgZGlmZmVyZW50IHBhcnRzIGFmdGVyIHRoZSBlbGVtZW50IG5hbWUgdG8gc2VhcmNoIGZvclxuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRzICA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vSEFTSFxuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW5TdHJlYW0ubWF0Y2goVG9rZW5zLkhBU0gpID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBTZWxlY3RvclN1YlBhcnQodG9rZW5TdHJlYW0udG9rZW4oKS52YWx1ZSwgXCJpZFwiLCB0b2tlblN0cmVhbS50b2tlbigpLnN0YXJ0TGluZSwgdG9rZW5TdHJlYW0udG9rZW4oKS5zdGFydENvbCkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jbGFzcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2F0dHJpYixcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3BzZXVkbyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX25lZ2F0aW9uXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgIGkgICAgICAgICAgID0gMCxcbiAgICAgICAgICAgICAgICAgICAgbGVuICAgICAgICAgPSBjb21wb25lbnRzLmxlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50ICAgPSBudWxsLFxuICAgICAgICAgICAgICAgICAgICBsaW5lLFxuICAgICAgICAgICAgICAgICAgICBjb2w7XG5cblxuICAgICAgICAgICAgICAgIC8vZ2V0IHN0YXJ0aW5nIGxpbmUgYW5kIGNvbHVtbiBmb3IgdGhlIHNlbGVjdG9yXG4gICAgICAgICAgICAgICAgbGluZSA9IHRva2VuU3RyZWFtLkxUKDEpLnN0YXJ0TGluZTtcbiAgICAgICAgICAgICAgICBjb2wgPSB0b2tlblN0cmVhbS5MVCgxKS5zdGFydENvbDtcblxuICAgICAgICAgICAgICAgIGVsZW1lbnROYW1lID0gdGhpcy5fdHlwZV9zZWxlY3RvcigpO1xuICAgICAgICAgICAgICAgIGlmICghZWxlbWVudE5hbWUpe1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50TmFtZSA9IHRoaXMuX3VuaXZlcnNhbCgpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50TmFtZSAhPT0gbnVsbCl7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yVGV4dCArPSBlbGVtZW50TmFtZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB3aGlsZSh0cnVlKXtcblxuICAgICAgICAgICAgICAgICAgICAvL3doaXRlc3BhY2UgbWVhbnMgd2UncmUgZG9uZVxuICAgICAgICAgICAgICAgICAgICBpZiAodG9rZW5TdHJlYW0ucGVlaygpID09PSBUb2tlbnMuUyl7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vY2hlY2sgZm9yIGVhY2ggY29tcG9uZW50XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlKGkgPCBsZW4gJiYgY29tcG9uZW50ID09PSBudWxsKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudCA9IGNvbXBvbmVudHNbaSsrXS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbXBvbmVudCA9PT0gbnVsbCl7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vd2UgZG9uJ3QgaGF2ZSBhIHNlbGVjdG9yXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZWN0b3JUZXh0ID09PSBcIlwiKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGlmaWVycy5wdXNoKGNvbXBvbmVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RvclRleHQgKz0gY29tcG9uZW50LnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG5cbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZWN0b3JUZXh0ICE9PSBcIlwiID9cbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBTZWxlY3RvclBhcnQoZWxlbWVudE5hbWUsIG1vZGlmaWVycywgc2VsZWN0b3JUZXh0LCBsaW5lLCBjb2wpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIG51bGw7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvL0NTUzMgU2VsZWN0b3JzXG4gICAgICAgICAgICBfdHlwZV9zZWxlY3RvcjogZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAqIHR5cGVfc2VsZWN0b3JcbiAgICAgICAgICAgICAgICAgKiAgIDogWyBuYW1lc3BhY2VfcHJlZml4IF0/IGVsZW1lbnRfbmFtZVxuICAgICAgICAgICAgICAgICAqICAgO1xuICAgICAgICAgICAgICAgICAqL1xuXG4gICAgICAgICAgICAgICAgdmFyIHRva2VuU3RyZWFtID0gdGhpcy5fdG9rZW5TdHJlYW0sXG4gICAgICAgICAgICAgICAgICAgIG5zICAgICAgICAgID0gdGhpcy5fbmFtZXNwYWNlX3ByZWZpeCgpLFxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50TmFtZSA9IHRoaXMuX2VsZW1lbnRfbmFtZSgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFlbGVtZW50TmFtZSl7XG4gICAgICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICAgICAqIE5lZWQgdG8gYmFjayBvdXQgdGhlIG5hbWVzcGFjZSB0aGF0IHdhcyByZWFkIGR1ZSB0byBib3RoXG4gICAgICAgICAgICAgICAgICAgICAqIHR5cGVfc2VsZWN0b3IgYW5kIHVuaXZlcnNhbCByZWFkaW5nIG5hbWVzcGFjZV9wcmVmaXhcbiAgICAgICAgICAgICAgICAgICAgICogZmlyc3QuIEtpbmQgb2YgaGFja3ksIGJ1dCBvbmx5IHdheSBJIGNhbiBmaWd1cmUgb3V0XG4gICAgICAgICAgICAgICAgICAgICAqIHJpZ2h0IG5vdyBob3cgdG8gbm90IGNoYW5nZSB0aGUgZ3JhbW1hci5cbiAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIGlmIChucyl7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlblN0cmVhbS51bmdldCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5zLmxlbmd0aCA+IDEpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuU3RyZWFtLnVuZ2V0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAobnMpe1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudE5hbWUudGV4dCA9IG5zICsgZWxlbWVudE5hbWUudGV4dDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnROYW1lLmNvbCAtPSBucy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnROYW1lO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8vQ1NTMyBTZWxlY3RvcnNcbiAgICAgICAgICAgIF9jbGFzczogZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAqIGNsYXNzXG4gICAgICAgICAgICAgICAgICogICA6ICcuJyBJREVOVFxuICAgICAgICAgICAgICAgICAqICAgO1xuICAgICAgICAgICAgICAgICAqL1xuXG4gICAgICAgICAgICAgICAgdmFyIHRva2VuU3RyZWFtID0gdGhpcy5fdG9rZW5TdHJlYW0sXG4gICAgICAgICAgICAgICAgICAgIHRva2VuO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRva2VuU3RyZWFtLm1hdGNoKFRva2Vucy5ET1QpKXtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5TdHJlYW0ubXVzdE1hdGNoKFRva2Vucy5JREVOVCk7XG4gICAgICAgICAgICAgICAgICAgIHRva2VuID0gdG9rZW5TdHJlYW0udG9rZW4oKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTZWxlY3RvclN1YlBhcnQoXCIuXCIgKyB0b2tlbi52YWx1ZSwgXCJjbGFzc1wiLCB0b2tlbi5zdGFydExpbmUsIHRva2VuLnN0YXJ0Q29sIC0gMSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvL0NTUzMgU2VsZWN0b3JzXG4gICAgICAgICAgICBfZWxlbWVudF9uYW1lOiBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICogZWxlbWVudF9uYW1lXG4gICAgICAgICAgICAgICAgICogICA6IElERU5UXG4gICAgICAgICAgICAgICAgICogICA7XG4gICAgICAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgICAgICB2YXIgdG9rZW5TdHJlYW0gPSB0aGlzLl90b2tlblN0cmVhbSxcbiAgICAgICAgICAgICAgICAgICAgdG9rZW47XG5cbiAgICAgICAgICAgICAgICBpZiAodG9rZW5TdHJlYW0ubWF0Y2goVG9rZW5zLklERU5UKSl7XG4gICAgICAgICAgICAgICAgICAgIHRva2VuID0gdG9rZW5TdHJlYW0udG9rZW4oKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTZWxlY3RvclN1YlBhcnQodG9rZW4udmFsdWUsIFwiZWxlbWVudE5hbWVcIiwgdG9rZW4uc3RhcnRMaW5lLCB0b2tlbi5zdGFydENvbCk7XG5cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvL0NTUzMgU2VsZWN0b3JzXG4gICAgICAgICAgICBfbmFtZXNwYWNlX3ByZWZpeDogZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAqIG5hbWVzcGFjZV9wcmVmaXhcbiAgICAgICAgICAgICAgICAgKiAgIDogWyBJREVOVCB8ICcqJyBdPyAnfCdcbiAgICAgICAgICAgICAgICAgKiAgIDtcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB2YXIgdG9rZW5TdHJlYW0gPSB0aGlzLl90b2tlblN0cmVhbSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgICAgICAgPSBcIlwiO1xuXG4gICAgICAgICAgICAgICAgLy92ZXJpZnkgdGhhdCB0aGlzIGlzIGEgbmFtZXNwYWNlIHByZWZpeFxuICAgICAgICAgICAgICAgIGlmICh0b2tlblN0cmVhbS5MQSgxKSA9PT0gVG9rZW5zLlBJUEUgfHwgdG9rZW5TdHJlYW0uTEEoMikgPT09IFRva2Vucy5QSVBFKXtcblxuICAgICAgICAgICAgICAgICAgICBpZih0b2tlblN0cmVhbS5tYXRjaChbVG9rZW5zLklERU5ULCBUb2tlbnMuU1RBUl0pKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlICs9IHRva2VuU3RyZWFtLnRva2VuKCkudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB0b2tlblN0cmVhbS5tdXN0TWF0Y2goVG9rZW5zLlBJUEUpO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSArPSBcInxcIjtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZS5sZW5ndGggPyB2YWx1ZSA6IG51bGw7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvL0NTUzMgU2VsZWN0b3JzXG4gICAgICAgICAgICBfdW5pdmVyc2FsOiBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICogdW5pdmVyc2FsXG4gICAgICAgICAgICAgICAgICogICA6IFsgbmFtZXNwYWNlX3ByZWZpeCBdPyAnKidcbiAgICAgICAgICAgICAgICAgKiAgIDtcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB2YXIgdG9rZW5TdHJlYW0gPSB0aGlzLl90b2tlblN0cmVhbSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgICAgICAgPSBcIlwiLFxuICAgICAgICAgICAgICAgICAgICBucztcblxuICAgICAgICAgICAgICAgIG5zID0gdGhpcy5fbmFtZXNwYWNlX3ByZWZpeCgpO1xuICAgICAgICAgICAgICAgIGlmKG5zKXtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgKz0gbnM7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYodG9rZW5TdHJlYW0ubWF0Y2goVG9rZW5zLlNUQVIpKXtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgKz0gXCIqXCI7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLmxlbmd0aCA/IHZhbHVlIDogbnVsbDtcblxuICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvL0NTUzMgU2VsZWN0b3JzXG4gICAgICAgICAgICBfYXR0cmliOiBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICogYXR0cmliXG4gICAgICAgICAgICAgICAgICogICA6ICdbJyBTKiBbIG5hbWVzcGFjZV9wcmVmaXggXT8gSURFTlQgUypcbiAgICAgICAgICAgICAgICAgKiAgICAgICAgIFsgWyBQUkVGSVhNQVRDSCB8XG4gICAgICAgICAgICAgICAgICogICAgICAgICAgICAgU1VGRklYTUFUQ0ggfFxuICAgICAgICAgICAgICAgICAqICAgICAgICAgICAgIFNVQlNUUklOR01BVENIIHxcbiAgICAgICAgICAgICAgICAgKiAgICAgICAgICAgICAnPScgfFxuICAgICAgICAgICAgICAgICAqICAgICAgICAgICAgIElOQ0xVREVTIHxcbiAgICAgICAgICAgICAgICAgKiAgICAgICAgICAgICBEQVNITUFUQ0ggXSBTKiBbIElERU5UIHwgU1RSSU5HIF0gUypcbiAgICAgICAgICAgICAgICAgKiAgICAgICAgIF0/ICddJ1xuICAgICAgICAgICAgICAgICAqICAgO1xuICAgICAgICAgICAgICAgICAqL1xuXG4gICAgICAgICAgICAgICAgdmFyIHRva2VuU3RyZWFtID0gdGhpcy5fdG9rZW5TdHJlYW0sXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlICAgICAgID0gbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgbnMsXG4gICAgICAgICAgICAgICAgICAgIHRva2VuO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRva2VuU3RyZWFtLm1hdGNoKFRva2Vucy5MQlJBQ0tFVCkpe1xuICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IHRva2VuU3RyZWFtLnRva2VuKCk7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdG9rZW4udmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlICs9IHRoaXMuX3JlYWRXaGl0ZXNwYWNlKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgbnMgPSB0aGlzLl9uYW1lc3BhY2VfcHJlZml4KCk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKG5zKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlICs9IG5zO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdG9rZW5TdHJlYW0ubXVzdE1hdGNoKFRva2Vucy5JREVOVCk7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlICs9IHRva2VuU3RyZWFtLnRva2VuKCkudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlICs9IHRoaXMuX3JlYWRXaGl0ZXNwYWNlKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYodG9rZW5TdHJlYW0ubWF0Y2goW1Rva2Vucy5QUkVGSVhNQVRDSCwgVG9rZW5zLlNVRkZJWE1BVENILCBUb2tlbnMuU1VCU1RSSU5HTUFUQ0gsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgVG9rZW5zLkVRVUFMUywgVG9rZW5zLklOQ0xVREVTLCBUb2tlbnMuREFTSE1BVENIXSkpe1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSArPSB0b2tlblN0cmVhbS50b2tlbigpLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgKz0gdGhpcy5fcmVhZFdoaXRlc3BhY2UoKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5TdHJlYW0ubXVzdE1hdGNoKFtUb2tlbnMuSURFTlQsIFRva2Vucy5TVFJJTkddKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlICs9IHRva2VuU3RyZWFtLnRva2VuKCkudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSArPSB0aGlzLl9yZWFkV2hpdGVzcGFjZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdG9rZW5TdHJlYW0ubXVzdE1hdGNoKFRva2Vucy5SQlJBQ0tFVCk7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTZWxlY3RvclN1YlBhcnQodmFsdWUgKyBcIl1cIiwgXCJhdHRyaWJ1dGVcIiwgdG9rZW4uc3RhcnRMaW5lLCB0b2tlbi5zdGFydENvbCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLy9DU1MzIFNlbGVjdG9yc1xuICAgICAgICAgICAgX3BzZXVkbzogZnVuY3Rpb24oKXtcblxuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICogcHNldWRvXG4gICAgICAgICAgICAgICAgICogICA6ICc6JyAnOic/IFsgSURFTlQgfCBmdW5jdGlvbmFsX3BzZXVkbyBdXG4gICAgICAgICAgICAgICAgICogICA7XG4gICAgICAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgICAgICB2YXIgdG9rZW5TdHJlYW0gPSB0aGlzLl90b2tlblN0cmVhbSxcbiAgICAgICAgICAgICAgICAgICAgcHNldWRvICAgICAgPSBudWxsLFxuICAgICAgICAgICAgICAgICAgICBjb2xvbnMgICAgICA9IFwiOlwiLFxuICAgICAgICAgICAgICAgICAgICBsaW5lLFxuICAgICAgICAgICAgICAgICAgICBjb2w7XG5cbiAgICAgICAgICAgICAgICBpZiAodG9rZW5TdHJlYW0ubWF0Y2goVG9rZW5zLkNPTE9OKSl7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRva2VuU3RyZWFtLm1hdGNoKFRva2Vucy5DT0xPTikpe1xuICAgICAgICAgICAgICAgICAgICAgICAgY29sb25zICs9IFwiOlwiO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRva2VuU3RyZWFtLm1hdGNoKFRva2Vucy5JREVOVCkpe1xuICAgICAgICAgICAgICAgICAgICAgICAgcHNldWRvID0gdG9rZW5TdHJlYW0udG9rZW4oKS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmUgPSB0b2tlblN0cmVhbS50b2tlbigpLnN0YXJ0TGluZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbCA9IHRva2VuU3RyZWFtLnRva2VuKCkuc3RhcnRDb2wgLSBjb2xvbnMubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRva2VuU3RyZWFtLnBlZWsoKSA9PT0gVG9rZW5zLkZVTkNUSU9OKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmUgPSB0b2tlblN0cmVhbS5MVCgxKS5zdGFydExpbmU7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2wgPSB0b2tlblN0cmVhbS5MVCgxKS5zdGFydENvbCAtIGNvbG9ucy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICBwc2V1ZG8gPSB0aGlzLl9mdW5jdGlvbmFsX3BzZXVkbygpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHBzZXVkbyl7XG4gICAgICAgICAgICAgICAgICAgICAgICBwc2V1ZG8gPSBuZXcgU2VsZWN0b3JTdWJQYXJ0KGNvbG9ucyArIHBzZXVkbywgXCJwc2V1ZG9cIiwgbGluZSwgY29sKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBwc2V1ZG87XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvL0NTUzMgU2VsZWN0b3JzXG4gICAgICAgICAgICBfZnVuY3Rpb25hbF9wc2V1ZG86IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgKiBmdW5jdGlvbmFsX3BzZXVkb1xuICAgICAgICAgICAgICAgICAqICAgOiBGVU5DVElPTiBTKiBleHByZXNzaW9uICcpJ1xuICAgICAgICAgICAgICAgICAqICAgO1xuICAgICAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgICAgICB2YXIgdG9rZW5TdHJlYW0gPSB0aGlzLl90b2tlblN0cmVhbSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBudWxsO1xuXG4gICAgICAgICAgICAgICAgaWYodG9rZW5TdHJlYW0ubWF0Y2goVG9rZW5zLkZVTkNUSU9OKSl7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdG9rZW5TdHJlYW0udG9rZW4oKS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgKz0gdGhpcy5fcmVhZFdoaXRlc3BhY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgKz0gdGhpcy5fZXhwcmVzc2lvbigpO1xuICAgICAgICAgICAgICAgICAgICB0b2tlblN0cmVhbS5tdXN0TWF0Y2goVG9rZW5zLlJQQVJFTik7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlICs9IFwiKVwiO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8vQ1NTMyBTZWxlY3RvcnNcbiAgICAgICAgICAgIF9leHByZXNzaW9uOiBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICogZXhwcmVzc2lvblxuICAgICAgICAgICAgICAgICAqICAgOiBbIFsgUExVUyB8ICctJyB8IERJTUVOU0lPTiB8IE5VTUJFUiB8IFNUUklORyB8IElERU5UIF0gUyogXStcbiAgICAgICAgICAgICAgICAgKiAgIDtcbiAgICAgICAgICAgICAgICAgKi9cblxuICAgICAgICAgICAgICAgIHZhciB0b2tlblN0cmVhbSA9IHRoaXMuX3Rva2VuU3RyZWFtLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSAgICAgICA9IFwiXCI7XG5cbiAgICAgICAgICAgICAgICB3aGlsZSh0b2tlblN0cmVhbS5tYXRjaChbVG9rZW5zLlBMVVMsIFRva2Vucy5NSU5VUywgVG9rZW5zLkRJTUVOU0lPTixcbiAgICAgICAgICAgICAgICAgICAgICAgIFRva2Vucy5OVU1CRVIsIFRva2Vucy5TVFJJTkcsIFRva2Vucy5JREVOVCwgVG9rZW5zLkxFTkdUSCxcbiAgICAgICAgICAgICAgICAgICAgICAgIFRva2Vucy5GUkVRLCBUb2tlbnMuQU5HTEUsIFRva2Vucy5USU1FLFxuICAgICAgICAgICAgICAgICAgICAgICAgVG9rZW5zLlJFU09MVVRJT04sIFRva2Vucy5TTEFTSF0pKXtcblxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSArPSB0b2tlblN0cmVhbS50b2tlbigpLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSArPSB0aGlzLl9yZWFkV2hpdGVzcGFjZSgpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZS5sZW5ndGggPyB2YWx1ZSA6IG51bGw7XG5cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8vQ1NTMyBTZWxlY3RvcnNcbiAgICAgICAgICAgIF9uZWdhdGlvbjogZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAqIG5lZ2F0aW9uXG4gICAgICAgICAgICAgICAgICogICA6IE5PVCBTKiBuZWdhdGlvbl9hcmcgUyogJyknXG4gICAgICAgICAgICAgICAgICogICA7XG4gICAgICAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgICAgICB2YXIgdG9rZW5TdHJlYW0gPSB0aGlzLl90b2tlblN0cmVhbSxcbiAgICAgICAgICAgICAgICAgICAgbGluZSxcbiAgICAgICAgICAgICAgICAgICAgY29sLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSAgICAgICA9IFwiXCIsXG4gICAgICAgICAgICAgICAgICAgIGFyZyxcbiAgICAgICAgICAgICAgICAgICAgc3VicGFydCAgICAgPSBudWxsO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRva2VuU3RyZWFtLm1hdGNoKFRva2Vucy5OT1QpKXtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB0b2tlblN0cmVhbS50b2tlbigpLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBsaW5lID0gdG9rZW5TdHJlYW0udG9rZW4oKS5zdGFydExpbmU7XG4gICAgICAgICAgICAgICAgICAgIGNvbCA9IHRva2VuU3RyZWFtLnRva2VuKCkuc3RhcnRDb2w7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlICs9IHRoaXMuX3JlYWRXaGl0ZXNwYWNlKCk7XG4gICAgICAgICAgICAgICAgICAgIGFyZyA9IHRoaXMuX25lZ2F0aW9uX2FyZygpO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSArPSBhcmc7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlICs9IHRoaXMuX3JlYWRXaGl0ZXNwYWNlKCk7XG4gICAgICAgICAgICAgICAgICAgIHRva2VuU3RyZWFtLm1hdGNoKFRva2Vucy5SUEFSRU4pO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSArPSB0b2tlblN0cmVhbS50b2tlbigpLnZhbHVlO1xuXG4gICAgICAgICAgICAgICAgICAgIHN1YnBhcnQgPSBuZXcgU2VsZWN0b3JTdWJQYXJ0KHZhbHVlLCBcIm5vdFwiLCBsaW5lLCBjb2wpO1xuICAgICAgICAgICAgICAgICAgICBzdWJwYXJ0LmFyZ3MucHVzaChhcmcpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBzdWJwYXJ0O1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLy9DU1MzIFNlbGVjdG9yc1xuICAgICAgICAgICAgX25lZ2F0aW9uX2FyZzogZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAqIG5lZ2F0aW9uX2FyZ1xuICAgICAgICAgICAgICAgICAqICAgOiB0eXBlX3NlbGVjdG9yIHwgdW5pdmVyc2FsIHwgSEFTSCB8IGNsYXNzIHwgYXR0cmliIHwgcHNldWRvXG4gICAgICAgICAgICAgICAgICogICA7XG4gICAgICAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgICAgICB2YXIgdG9rZW5TdHJlYW0gPSB0aGlzLl90b2tlblN0cmVhbSxcbiAgICAgICAgICAgICAgICAgICAgYXJncyAgICAgICAgPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl90eXBlX3NlbGVjdG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdW5pdmVyc2FsLFxuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW5TdHJlYW0ubWF0Y2goVG9rZW5zLkhBU0gpID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBTZWxlY3RvclN1YlBhcnQodG9rZW5TdHJlYW0udG9rZW4oKS52YWx1ZSwgXCJpZFwiLCB0b2tlblN0cmVhbS50b2tlbigpLnN0YXJ0TGluZSwgdG9rZW5TdHJlYW0udG9rZW4oKS5zdGFydENvbCkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jbGFzcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2F0dHJpYixcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3BzZXVkb1xuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICBhcmcgICAgICAgICA9IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIGkgICAgICAgICAgID0gMCxcbiAgICAgICAgICAgICAgICAgICAgbGVuICAgICAgICAgPSBhcmdzLmxlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgbGluZSxcbiAgICAgICAgICAgICAgICAgICAgY29sLFxuICAgICAgICAgICAgICAgICAgICBwYXJ0O1xuXG4gICAgICAgICAgICAgICAgbGluZSA9IHRva2VuU3RyZWFtLkxUKDEpLnN0YXJ0TGluZTtcbiAgICAgICAgICAgICAgICBjb2wgPSB0b2tlblN0cmVhbS5MVCgxKS5zdGFydENvbDtcblxuICAgICAgICAgICAgICAgIHdoaWxlKGkgPCBsZW4gJiYgYXJnID09PSBudWxsKXtcblxuICAgICAgICAgICAgICAgICAgICBhcmcgPSBhcmdzW2ldLmNhbGwodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvL211c3QgYmUgYSBuZWdhdGlvbiBhcmdcbiAgICAgICAgICAgICAgICBpZiAoYXJnID09PSBudWxsKXtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdW5leHBlY3RlZFRva2VuKHRva2VuU3RyZWFtLkxUKDEpKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvL2l0J3MgYW4gZWxlbWVudCBuYW1lXG4gICAgICAgICAgICAgICAgaWYgKGFyZy50eXBlID09PSBcImVsZW1lbnROYW1lXCIpe1xuICAgICAgICAgICAgICAgICAgICBwYXJ0ID0gbmV3IFNlbGVjdG9yUGFydChhcmcsIFtdLCBhcmcudG9TdHJpbmcoKSwgbGluZSwgY29sKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwYXJ0ID0gbmV3IFNlbGVjdG9yUGFydChudWxsLCBbYXJnXSwgYXJnLnRvU3RyaW5nKCksIGxpbmUsIGNvbCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnQ7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBfZGVjbGFyYXRpb246IGZ1bmN0aW9uKCl7XG5cbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAqIGRlY2xhcmF0aW9uXG4gICAgICAgICAgICAgICAgICogICA6IHByb3BlcnR5ICc6JyBTKiBleHByIHByaW8/XG4gICAgICAgICAgICAgICAgICogICB8IC8oIGVtcHR5ICkvXG4gICAgICAgICAgICAgICAgICogICA7XG4gICAgICAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgICAgICB2YXIgdG9rZW5TdHJlYW0gPSB0aGlzLl90b2tlblN0cmVhbSxcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydHkgICAgPSBudWxsLFxuICAgICAgICAgICAgICAgICAgICBleHByICAgICAgICA9IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHByaW8gICAgICAgID0gbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgaW52YWxpZCAgICAgPSBudWxsLFxuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eU5hbWU9IFwiXCI7XG5cbiAgICAgICAgICAgICAgICBwcm9wZXJ0eSA9IHRoaXMuX3Byb3BlcnR5KCk7XG4gICAgICAgICAgICAgICAgaWYgKHByb3BlcnR5ICE9PSBudWxsKXtcblxuICAgICAgICAgICAgICAgICAgICB0b2tlblN0cmVhbS5tdXN0TWF0Y2goVG9rZW5zLkNPTE9OKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVhZFdoaXRlc3BhY2UoKTtcblxuICAgICAgICAgICAgICAgICAgICBleHByID0gdGhpcy5fZXhwcigpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vaWYgdGhlcmUncyBubyBwYXJ0cyBmb3IgdGhlIHZhbHVlLCBpdCdzIGFuIGVycm9yXG4gICAgICAgICAgICAgICAgICAgIGlmICghZXhwciB8fCBleHByLmxlbmd0aCA9PT0gMCl7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl91bmV4cGVjdGVkVG9rZW4odG9rZW5TdHJlYW0uTFQoMSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcHJpbyA9IHRoaXMuX3ByaW8oKTtcblxuICAgICAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAgICAgKiBJZiBoYWNrcyBzaG91bGQgYmUgYWxsb3dlZCwgdGhlbiBvbmx5IGNoZWNrIHRoZSByb290XG4gICAgICAgICAgICAgICAgICAgICAqIHByb3BlcnR5LiBJZiBoYWNrcyBzaG91bGQgbm90IGJlIGFsbG93ZWQsIHRyZWF0XG4gICAgICAgICAgICAgICAgICAgICAqIF9wcm9wZXJ0eSBvciAqcHJvcGVydHkgYXMgaW52YWxpZCBwcm9wZXJ0aWVzLlxuICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydHlOYW1lID0gcHJvcGVydHkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zdGFySGFjayAmJiBwcm9wZXJ0eS5oYWNrID09PSBcIipcIiB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy51bmRlcnNjb3JlSGFjayAmJiBwcm9wZXJ0eS5oYWNrID09PSBcIl9cIikge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eU5hbWUgPSBwcm9wZXJ0eS50ZXh0O1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3ZhbGlkYXRlUHJvcGVydHkocHJvcGVydHlOYW1lLCBleHByKTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGludmFsaWQgPSBleDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmlyZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAgICAgICBcInByb3BlcnR5XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eTogICBwcm9wZXJ0eSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiAgICAgIGV4cHIsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbXBvcnRhbnQ6ICBwcmlvLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGluZTogICAgICAgcHJvcGVydHkubGluZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbDogICAgICAgIHByb3BlcnR5LmNvbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGludmFsaWQ6ICAgIGludmFsaWRcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIF9wcmlvOiBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICogcHJpb1xuICAgICAgICAgICAgICAgICAqICAgOiBJTVBPUlRBTlRfU1lNIFMqXG4gICAgICAgICAgICAgICAgICogICA7XG4gICAgICAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgICAgICB2YXIgdG9rZW5TdHJlYW0gPSB0aGlzLl90b2tlblN0cmVhbSxcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICAgICAgPSB0b2tlblN0cmVhbS5tYXRjaChUb2tlbnMuSU1QT1JUQU5UX1NZTSk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9yZWFkV2hpdGVzcGFjZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBfZXhwcjogZnVuY3Rpb24oaW5GdW5jdGlvbil7XG4gICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgKiBleHByXG4gICAgICAgICAgICAgICAgICogICA6IHRlcm0gWyBvcGVyYXRvciB0ZXJtIF0qXG4gICAgICAgICAgICAgICAgICogICA7XG4gICAgICAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgICAgICB2YXIgdmFsdWVzICAgICAgPSBbXSxcblx0XHRcdFx0XHQvL3ZhbHVlUGFydHNcdD0gW10sXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlICAgICAgID0gbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgb3BlcmF0b3IgICAgPSBudWxsO1xuXG4gICAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzLl90ZXJtKGluRnVuY3Rpb24pO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gbnVsbCl7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzLnB1c2godmFsdWUpO1xuXG4gICAgICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdG9yID0gdGhpcy5fb3BlcmF0b3IoaW5GdW5jdGlvbik7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vaWYgdGhlcmUncyBhbiBvcGVyYXRvciwga2VlcCBidWlsZGluZyB1cCB0aGUgdmFsdWUgcGFydHNcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcGVyYXRvcil7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzLnB1c2gob3BlcmF0b3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSAvKmVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vaWYgdGhlcmUncyBub3QgYW4gb3BlcmF0b3IsIHlvdSBoYXZlIGEgZnVsbCB2YWx1ZVxuXHRcdFx0XHRcdFx0XHR2YWx1ZXMucHVzaChuZXcgUHJvcGVydHlWYWx1ZSh2YWx1ZVBhcnRzLCB2YWx1ZVBhcnRzWzBdLmxpbmUsIHZhbHVlUGFydHNbMF0uY29sKSk7XG5cdFx0XHRcdFx0XHRcdHZhbHVlUGFydHMgPSBbXTtcblx0XHRcdFx0XHRcdH0qL1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXMuX3Rlcm0oaW5GdW5jdGlvbik7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlcy5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSB3aGlsZSh0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG5cblx0XHRcdFx0Ly9jbGVhbnVwXG4gICAgICAgICAgICAgICAgLyppZiAodmFsdWVQYXJ0cy5sZW5ndGgpe1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZXMucHVzaChuZXcgUHJvcGVydHlWYWx1ZSh2YWx1ZVBhcnRzLCB2YWx1ZVBhcnRzWzBdLmxpbmUsIHZhbHVlUGFydHNbMF0uY29sKSk7XG4gICAgICAgICAgICAgICAgfSovXG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWVzLmxlbmd0aCA+IDAgPyBuZXcgUHJvcGVydHlWYWx1ZSh2YWx1ZXMsIHZhbHVlc1swXS5saW5lLCB2YWx1ZXNbMF0uY29sKSA6IG51bGw7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBfdGVybTogZnVuY3Rpb24oaW5GdW5jdGlvbil7XG5cbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAqIHRlcm1cbiAgICAgICAgICAgICAgICAgKiAgIDogdW5hcnlfb3BlcmF0b3I/XG4gICAgICAgICAgICAgICAgICogICAgIFsgTlVNQkVSIFMqIHwgUEVSQ0VOVEFHRSBTKiB8IExFTkdUSCBTKiB8IEFOR0xFIFMqIHxcbiAgICAgICAgICAgICAgICAgKiAgICAgICBUSU1FIFMqIHwgRlJFUSBTKiB8IGZ1bmN0aW9uIHwgaWVfZnVuY3Rpb24gXVxuICAgICAgICAgICAgICAgICAqICAgfCBTVFJJTkcgUyogfCBJREVOVCBTKiB8IFVSSSBTKiB8IFVOSUNPREVSQU5HRSBTKiB8IGhleGNvbG9yXG4gICAgICAgICAgICAgICAgICogICA7XG4gICAgICAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgICAgICB2YXIgdG9rZW5TdHJlYW0gPSB0aGlzLl90b2tlblN0cmVhbSxcbiAgICAgICAgICAgICAgICAgICAgdW5hcnkgICAgICAgPSBudWxsLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSAgICAgICA9IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIGVuZENoYXIgICAgID0gbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4sXG4gICAgICAgICAgICAgICAgICAgIGxpbmUsXG4gICAgICAgICAgICAgICAgICAgIGNvbDtcblxuICAgICAgICAgICAgICAgIC8vcmV0dXJucyB0aGUgb3BlcmF0b3Igb3IgbnVsbFxuICAgICAgICAgICAgICAgIHVuYXJ5ID0gdGhpcy5fdW5hcnlfb3BlcmF0b3IoKTtcbiAgICAgICAgICAgICAgICBpZiAodW5hcnkgIT09IG51bGwpe1xuICAgICAgICAgICAgICAgICAgICBsaW5lID0gdG9rZW5TdHJlYW0udG9rZW4oKS5zdGFydExpbmU7XG4gICAgICAgICAgICAgICAgICAgIGNvbCA9IHRva2VuU3RyZWFtLnRva2VuKCkuc3RhcnRDb2w7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy9leGNlcHRpb24gZm9yIElFIGZpbHRlcnNcbiAgICAgICAgICAgICAgICBpZiAodG9rZW5TdHJlYW0ucGVlaygpID09PSBUb2tlbnMuSUVfRlVOQ1RJT04gJiYgdGhpcy5vcHRpb25zLmllRmlsdGVycyl7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzLl9pZV9mdW5jdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodW5hcnkgPT09IG51bGwpe1xuICAgICAgICAgICAgICAgICAgICAgICAgbGluZSA9IHRva2VuU3RyZWFtLnRva2VuKCkuc3RhcnRMaW5lO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29sID0gdG9rZW5TdHJlYW0udG9rZW4oKS5zdGFydENvbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy9zZWUgaWYgaXQncyBhIHNpbXBsZSBibG9ja1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaW5GdW5jdGlvbiAmJiB0b2tlblN0cmVhbS5tYXRjaChbVG9rZW5zLkxQQVJFTiwgVG9rZW5zLkxCUkFDRSwgVG9rZW5zLkxCUkFDS0VUXSkpe1xuXG4gICAgICAgICAgICAgICAgICAgIHRva2VuID0gdG9rZW5TdHJlYW0udG9rZW4oKTtcbiAgICAgICAgICAgICAgICAgICAgZW5kQ2hhciA9IHRva2VuLmVuZENoYXI7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdG9rZW4udmFsdWUgKyB0aGlzLl9leHByKGluRnVuY3Rpb24pLnRleHQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1bmFyeSA9PT0gbnVsbCl7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lID0gdG9rZW5TdHJlYW0udG9rZW4oKS5zdGFydExpbmU7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2wgPSB0b2tlblN0cmVhbS50b2tlbigpLnN0YXJ0Q29sO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRva2VuU3RyZWFtLm11c3RNYXRjaChUb2tlbnMudHlwZShlbmRDaGFyKSk7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlICs9IGVuZENoYXI7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlYWRXaGl0ZXNwYWNlKCk7XG5cbiAgICAgICAgICAgICAgICAvL3NlZSBpZiB0aGVyZSdzIGEgc2ltcGxlIG1hdGNoXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0b2tlblN0cmVhbS5tYXRjaChbVG9rZW5zLk5VTUJFUiwgVG9rZW5zLlBFUkNFTlRBR0UsIFRva2Vucy5MRU5HVEgsXG4gICAgICAgICAgICAgICAgICAgICAgICBUb2tlbnMuQU5HTEUsIFRva2Vucy5USU1FLFxuICAgICAgICAgICAgICAgICAgICAgICAgVG9rZW5zLkZSRVEsIFRva2Vucy5TVFJJTkcsIFRva2Vucy5JREVOVCwgVG9rZW5zLlVSSSwgVG9rZW5zLlVOSUNPREVfUkFOR0VdKSl7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB0b2tlblN0cmVhbS50b2tlbigpLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAodW5hcnkgPT09IG51bGwpe1xuICAgICAgICAgICAgICAgICAgICAgICAgbGluZSA9IHRva2VuU3RyZWFtLnRva2VuKCkuc3RhcnRMaW5lO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29sID0gdG9rZW5TdHJlYW0udG9rZW4oKS5zdGFydENvbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZWFkV2hpdGVzcGFjZSgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy9zZWUgaWYgaXQncyBhIGNvbG9yXG4gICAgICAgICAgICAgICAgICAgIHRva2VuID0gdGhpcy5faGV4Y29sb3IoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRva2VuID09PSBudWxsKXtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy9pZiB0aGVyZSdzIG5vIHVuYXJ5LCBnZXQgdGhlIHN0YXJ0IG9mIHRoZSBuZXh0IHRva2VuIGZvciBsaW5lL2NvbCBpbmZvXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodW5hcnkgPT09IG51bGwpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmUgPSB0b2tlblN0cmVhbS5MVCgxKS5zdGFydExpbmU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sID0gdG9rZW5TdHJlYW0uTFQoMSkuc3RhcnRDb2w7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vaGFzIHRvIGJlIGEgZnVuY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCl7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIFRoaXMgY2hlY2tzIGZvciBhbHBoYShvcGFjaXR5PTApIHN0eWxlIG9mIElFXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogZnVuY3Rpb25zLiBJRV9GVU5DVElPTiBvbmx5IHByZXNlbnRzIHByb2dpZDogc3R5bGUuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRva2VuU3RyZWFtLkxBKDMpID09PSBUb2tlbnMuRVFVQUxTICYmIHRoaXMub3B0aW9ucy5pZUZpbHRlcnMpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXMuX2llX2Z1bmN0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzLl9mdW5jdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLyppZiAodmFsdWUgPT09IG51bGwpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgaWRlbnRpZmllciBhdCBsaW5lIFwiICsgdG9rZW5TdHJlYW0udG9rZW4oKS5zdGFydExpbmUgKyBcIiwgY2hhcmFjdGVyIFwiICsgIHRva2VuU3RyZWFtLnRva2VuKCkuc3RhcnRDb2wgKyBcIi5cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9Ki9cblxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB0b2tlbi52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1bmFyeSA9PT0gbnVsbCl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZSA9IHRva2VuLnN0YXJ0TGluZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2wgPSB0b2tlbi5zdGFydENvbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlICE9PSBudWxsID9cbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBQcm9wZXJ0eVZhbHVlUGFydCh1bmFyeSAhPT0gbnVsbCA/IHVuYXJ5ICsgdmFsdWUgOiB2YWx1ZSwgbGluZSwgY29sKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICBudWxsO1xuXG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBfZnVuY3Rpb246IGZ1bmN0aW9uKCl7XG5cbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAqIGZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgICogICA6IEZVTkNUSU9OIFMqIGV4cHIgJyknIFMqXG4gICAgICAgICAgICAgICAgICogICA7XG4gICAgICAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgICAgICB2YXIgdG9rZW5TdHJlYW0gPSB0aGlzLl90b2tlblN0cmVhbSxcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25UZXh0ID0gbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgZXhwciAgICAgICAgPSBudWxsLFxuICAgICAgICAgICAgICAgICAgICBsdDtcblxuICAgICAgICAgICAgICAgIGlmICh0b2tlblN0cmVhbS5tYXRjaChUb2tlbnMuRlVOQ1RJT04pKXtcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25UZXh0ID0gdG9rZW5TdHJlYW0udG9rZW4oKS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVhZFdoaXRlc3BhY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgZXhwciA9IHRoaXMuX2V4cHIodHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uVGV4dCArPSBleHByO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vU1RBUlQ6IEhvcnJpYmxlIGhhY2sgaW4gY2FzZSBpdCdzIGFuIElFIGZpbHRlclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmllRmlsdGVycyAmJiB0b2tlblN0cmVhbS5wZWVrKCkgPT09IFRva2Vucy5FUVVBTFMpe1xuICAgICAgICAgICAgICAgICAgICAgICAgZG8ge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX3JlYWRXaGl0ZXNwYWNlKCkpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvblRleHQgKz0gdG9rZW5TdHJlYW0udG9rZW4oKS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL21pZ2h0IGJlIHNlY29uZCB0aW1lIGluIHRoZSBsb29wXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRva2VuU3RyZWFtLkxBKDApID09PSBUb2tlbnMuQ09NTUEpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvblRleHQgKz0gdG9rZW5TdHJlYW0udG9rZW4oKS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlblN0cmVhbS5tYXRjaChUb2tlbnMuSURFTlQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uVGV4dCArPSB0b2tlblN0cmVhbS50b2tlbigpLnZhbHVlO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5TdHJlYW0ubWF0Y2goVG9rZW5zLkVRVUFMUyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25UZXh0ICs9IHRva2VuU3RyZWFtLnRva2VuKCkudmFsdWU7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2Z1bmN0aW9uVGV4dCArPSB0aGlzLl90ZXJtKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbHQgPSB0b2tlblN0cmVhbS5wZWVrKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUobHQgIT09IFRva2Vucy5DT01NQSAmJiBsdCAhPT0gVG9rZW5zLlMgJiYgbHQgIT09IFRva2Vucy5SUEFSRU4pe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlblN0cmVhbS5nZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25UZXh0ICs9IHRva2VuU3RyZWFtLnRva2VuKCkudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGx0ID0gdG9rZW5TdHJlYW0ucGVlaygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gd2hpbGUodG9rZW5TdHJlYW0ubWF0Y2goW1Rva2Vucy5DT01NQSwgVG9rZW5zLlNdKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvL0VORDogSG9ycmlibGUgSGFja1xuXG4gICAgICAgICAgICAgICAgICAgIHRva2VuU3RyZWFtLm1hdGNoKFRva2Vucy5SUEFSRU4pO1xuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvblRleHQgKz0gXCIpXCI7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlYWRXaGl0ZXNwYWNlKCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uVGV4dDtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIF9pZV9mdW5jdGlvbjogZnVuY3Rpb24oKXtcblxuICAgICAgICAgICAgICAgIC8qIChNeSBvd24gZXh0ZW5zaW9uKVxuICAgICAgICAgICAgICAgICAqIGllX2Z1bmN0aW9uXG4gICAgICAgICAgICAgICAgICogICA6IElFX0ZVTkNUSU9OIFMqIElERU5UICc9JyB0ZXJtIFtTKiAnLCc/IElERU5UICc9JyB0ZXJtXSsgJyknIFMqXG4gICAgICAgICAgICAgICAgICogICA7XG4gICAgICAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgICAgICB2YXIgdG9rZW5TdHJlYW0gPSB0aGlzLl90b2tlblN0cmVhbSxcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25UZXh0ID0gbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgbHQ7XG5cbiAgICAgICAgICAgICAgICAvL0lFIGZ1bmN0aW9uIGNhbiBiZWdpbiBsaWtlIGEgcmVndWxhciBmdW5jdGlvbiwgdG9vXG4gICAgICAgICAgICAgICAgaWYgKHRva2VuU3RyZWFtLm1hdGNoKFtUb2tlbnMuSUVfRlVOQ1RJT04sIFRva2Vucy5GVU5DVElPTl0pKXtcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25UZXh0ID0gdG9rZW5TdHJlYW0udG9rZW4oKS52YWx1ZTtcblxuICAgICAgICAgICAgICAgICAgICBkbyB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9yZWFkV2hpdGVzcGFjZSgpKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvblRleHQgKz0gdG9rZW5TdHJlYW0udG9rZW4oKS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy9taWdodCBiZSBzZWNvbmQgdGltZSBpbiB0aGUgbG9vcFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRva2VuU3RyZWFtLkxBKDApID09PSBUb2tlbnMuQ09NTUEpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uVGV4dCArPSB0b2tlblN0cmVhbS50b2tlbigpLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlblN0cmVhbS5tYXRjaChUb2tlbnMuSURFTlQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25UZXh0ICs9IHRva2VuU3RyZWFtLnRva2VuKCkudmFsdWU7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuU3RyZWFtLm1hdGNoKFRva2Vucy5FUVVBTFMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25UZXh0ICs9IHRva2VuU3RyZWFtLnRva2VuKCkudmFsdWU7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vZnVuY3Rpb25UZXh0ICs9IHRoaXMuX3Rlcm0oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGx0ID0gdG9rZW5TdHJlYW0ucGVlaygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUobHQgIT09IFRva2Vucy5DT01NQSAmJiBsdCAhPT0gVG9rZW5zLlMgJiYgbHQgIT09IFRva2Vucy5SUEFSRU4pe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuU3RyZWFtLmdldCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uVGV4dCArPSB0b2tlblN0cmVhbS50b2tlbigpLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGx0ID0gdG9rZW5TdHJlYW0ucGVlaygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IHdoaWxlKHRva2VuU3RyZWFtLm1hdGNoKFtUb2tlbnMuQ09NTUEsIFRva2Vucy5TXSkpO1xuXG4gICAgICAgICAgICAgICAgICAgIHRva2VuU3RyZWFtLm1hdGNoKFRva2Vucy5SUEFSRU4pO1xuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvblRleHQgKz0gXCIpXCI7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlYWRXaGl0ZXNwYWNlKCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uVGV4dDtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIF9oZXhjb2xvcjogZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAqIFRoZXJlIGlzIGEgY29uc3RyYWludCBvbiB0aGUgY29sb3IgdGhhdCBpdCBtdXN0XG4gICAgICAgICAgICAgICAgICogaGF2ZSBlaXRoZXIgMyBvciA2IGhleC1kaWdpdHMgKGkuZS4sIFswLTlhLWZBLUZdKVxuICAgICAgICAgICAgICAgICAqIGFmdGVyIHRoZSBcIiNcIjsgZS5nLiwgXCIjMDAwXCIgaXMgT0ssIGJ1dCBcIiNhYmNkXCIgaXMgbm90LlxuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogaGV4Y29sb3JcbiAgICAgICAgICAgICAgICAgKiAgIDogSEFTSCBTKlxuICAgICAgICAgICAgICAgICAqICAgO1xuICAgICAgICAgICAgICAgICAqL1xuXG4gICAgICAgICAgICAgICAgdmFyIHRva2VuU3RyZWFtID0gdGhpcy5fdG9rZW5TdHJlYW0sXG4gICAgICAgICAgICAgICAgICAgIHRva2VuID0gbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgY29sb3I7XG5cbiAgICAgICAgICAgICAgICBpZih0b2tlblN0cmVhbS5tYXRjaChUb2tlbnMuSEFTSCkpe1xuXG4gICAgICAgICAgICAgICAgICAgIC8vbmVlZCB0byBkbyBzb21lIHZhbGlkYXRpb24gaGVyZVxuXG4gICAgICAgICAgICAgICAgICAgIHRva2VuID0gdG9rZW5TdHJlYW0udG9rZW4oKTtcbiAgICAgICAgICAgICAgICAgICAgY29sb3IgPSB0b2tlbi52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEvI1thLWYwLTldezMsNn0vaS50ZXN0KGNvbG9yKSl7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXCJFeHBlY3RlZCBhIGhleCBjb2xvciBidXQgZm91bmQgJ1wiICsgY29sb3IgKyBcIicgYXQgbGluZSBcIiArIHRva2VuLnN0YXJ0TGluZSArIFwiLCBjb2wgXCIgKyB0b2tlbi5zdGFydENvbCArIFwiLlwiLCB0b2tlbi5zdGFydExpbmUsIHRva2VuLnN0YXJ0Q29sKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZWFkV2hpdGVzcGFjZSgpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgICAgIC8vIEFuaW1hdGlvbnMgbWV0aG9kc1xuICAgICAgICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICAgICAgICBfa2V5ZnJhbWVzOiBmdW5jdGlvbigpe1xuXG4gICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgKiBrZXlmcmFtZXM6XG4gICAgICAgICAgICAgICAgICogICA6IEtFWUZSQU1FU19TWU0gUyoga2V5ZnJhbWVfbmFtZSBTKiAneycgUyoga2V5ZnJhbWVfcnVsZSogJ30nIHtcbiAgICAgICAgICAgICAgICAgKiAgIDtcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB2YXIgdG9rZW5TdHJlYW0gPSB0aGlzLl90b2tlblN0cmVhbSxcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4sXG4gICAgICAgICAgICAgICAgICAgIHR0LFxuICAgICAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgICAgICBwcmVmaXggPSBcIlwiO1xuXG4gICAgICAgICAgICAgICAgdG9rZW5TdHJlYW0ubXVzdE1hdGNoKFRva2Vucy5LRVlGUkFNRVNfU1lNKTtcbiAgICAgICAgICAgICAgICB0b2tlbiA9IHRva2VuU3RyZWFtLnRva2VuKCk7XG4gICAgICAgICAgICAgICAgaWYgKC9eQFxcLShbXlxcLV0rKVxcLS8udGVzdCh0b2tlbi52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJlZml4ID0gUmVnRXhwLiQxO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuX3JlYWRXaGl0ZXNwYWNlKCk7XG4gICAgICAgICAgICAgICAgbmFtZSA9IHRoaXMuX2tleWZyYW1lX25hbWUoKTtcblxuICAgICAgICAgICAgICAgIHRoaXMuX3JlYWRXaGl0ZXNwYWNlKCk7XG4gICAgICAgICAgICAgICAgdG9rZW5TdHJlYW0ubXVzdE1hdGNoKFRva2Vucy5MQlJBQ0UpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5maXJlKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogICBcInN0YXJ0a2V5ZnJhbWVzXCIsXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICAgbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgcHJlZml4OiBwcmVmaXgsXG4gICAgICAgICAgICAgICAgICAgIGxpbmU6ICAgdG9rZW4uc3RhcnRMaW5lLFxuICAgICAgICAgICAgICAgICAgICBjb2w6ICAgIHRva2VuLnN0YXJ0Q29sXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9yZWFkV2hpdGVzcGFjZSgpO1xuICAgICAgICAgICAgICAgIHR0ID0gdG9rZW5TdHJlYW0ucGVlaygpO1xuXG4gICAgICAgICAgICAgICAgLy9jaGVjayBmb3Iga2V5XG4gICAgICAgICAgICAgICAgd2hpbGUodHQgPT09IFRva2Vucy5JREVOVCB8fCB0dCA9PT0gVG9rZW5zLlBFUkNFTlRBR0UpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fa2V5ZnJhbWVfcnVsZSgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZWFkV2hpdGVzcGFjZSgpO1xuICAgICAgICAgICAgICAgICAgICB0dCA9IHRva2VuU3RyZWFtLnBlZWsoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLmZpcmUoe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAgIFwiZW5ka2V5ZnJhbWVzXCIsXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICAgbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgcHJlZml4OiBwcmVmaXgsXG4gICAgICAgICAgICAgICAgICAgIGxpbmU6ICAgdG9rZW4uc3RhcnRMaW5lLFxuICAgICAgICAgICAgICAgICAgICBjb2w6ICAgIHRva2VuLnN0YXJ0Q29sXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9yZWFkV2hpdGVzcGFjZSgpO1xuICAgICAgICAgICAgICAgIHRva2VuU3RyZWFtLm11c3RNYXRjaChUb2tlbnMuUkJSQUNFKTtcblxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgX2tleWZyYW1lX25hbWU6IGZ1bmN0aW9uKCl7XG5cbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAqIGtleWZyYW1lX25hbWU6XG4gICAgICAgICAgICAgICAgICogICA6IElERU5UXG4gICAgICAgICAgICAgICAgICogICB8IFNUUklOR1xuICAgICAgICAgICAgICAgICAqICAgO1xuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHZhciB0b2tlblN0cmVhbSA9IHRoaXMuX3Rva2VuU3RyZWFtO1xuXG4gICAgICAgICAgICAgICAgdG9rZW5TdHJlYW0ubXVzdE1hdGNoKFtUb2tlbnMuSURFTlQsIFRva2Vucy5TVFJJTkddKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gU3ludGF4VW5pdC5mcm9tVG9rZW4odG9rZW5TdHJlYW0udG9rZW4oKSk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBfa2V5ZnJhbWVfcnVsZTogZnVuY3Rpb24oKXtcblxuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICoga2V5ZnJhbWVfcnVsZTpcbiAgICAgICAgICAgICAgICAgKiAgIDoga2V5X2xpc3QgUypcbiAgICAgICAgICAgICAgICAgKiAgICAgJ3snIFMqIGRlY2xhcmF0aW9uIFsgJzsnIFMqIGRlY2xhcmF0aW9uIF0qICd9JyBTKlxuICAgICAgICAgICAgICAgICAqICAgO1xuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHZhciBrZXlMaXN0ID0gdGhpcy5fa2V5X2xpc3QoKTtcblxuICAgICAgICAgICAgICAgIHRoaXMuZmlyZSh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICAgXCJzdGFydGtleWZyYW1lcnVsZVwiLFxuICAgICAgICAgICAgICAgICAgICBrZXlzOiAgIGtleUxpc3QsXG4gICAgICAgICAgICAgICAgICAgIGxpbmU6ICAga2V5TGlzdFswXS5saW5lLFxuICAgICAgICAgICAgICAgICAgICBjb2w6ICAgIGtleUxpc3RbMF0uY29sXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9yZWFkRGVjbGFyYXRpb25zKHRydWUpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5maXJlKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogICBcImVuZGtleWZyYW1lcnVsZVwiLFxuICAgICAgICAgICAgICAgICAgICBrZXlzOiAgIGtleUxpc3QsXG4gICAgICAgICAgICAgICAgICAgIGxpbmU6ICAga2V5TGlzdFswXS5saW5lLFxuICAgICAgICAgICAgICAgICAgICBjb2w6ICAgIGtleUxpc3RbMF0uY29sXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIF9rZXlfbGlzdDogZnVuY3Rpb24oKXtcblxuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICoga2V5X2xpc3Q6XG4gICAgICAgICAgICAgICAgICogICA6IGtleSBbIFMqICcsJyBTKiBrZXldKlxuICAgICAgICAgICAgICAgICAqICAgO1xuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHZhciB0b2tlblN0cmVhbSA9IHRoaXMuX3Rva2VuU3RyZWFtLFxuICAgICAgICAgICAgICAgICAgICBrZXlMaXN0ID0gW107XG5cbiAgICAgICAgICAgICAgICAvL211c3QgYmUgbGVhc3Qgb25lIGtleVxuICAgICAgICAgICAgICAgIGtleUxpc3QucHVzaCh0aGlzLl9rZXkoKSk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9yZWFkV2hpdGVzcGFjZSgpO1xuXG4gICAgICAgICAgICAgICAgd2hpbGUodG9rZW5TdHJlYW0ubWF0Y2goVG9rZW5zLkNPTU1BKSl7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlYWRXaGl0ZXNwYWNlKCk7XG4gICAgICAgICAgICAgICAgICAgIGtleUxpc3QucHVzaCh0aGlzLl9rZXkoKSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlYWRXaGl0ZXNwYWNlKCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGtleUxpc3Q7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBfa2V5OiBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICogVGhlcmUgaXMgYSByZXN0cmljdGlvbiB0aGF0IElERU5UIGNhbiBiZSBvbmx5IFwiZnJvbVwiIG9yIFwidG9cIi5cbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqIGtleVxuICAgICAgICAgICAgICAgICAqICAgOiBQRVJDRU5UQUdFXG4gICAgICAgICAgICAgICAgICogICB8IElERU5UXG4gICAgICAgICAgICAgICAgICogICA7XG4gICAgICAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgICAgICB2YXIgdG9rZW5TdHJlYW0gPSB0aGlzLl90b2tlblN0cmVhbSxcbiAgICAgICAgICAgICAgICAgICAgdG9rZW47XG5cbiAgICAgICAgICAgICAgICBpZiAodG9rZW5TdHJlYW0ubWF0Y2goVG9rZW5zLlBFUkNFTlRBR0UpKXtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFN5bnRheFVuaXQuZnJvbVRva2VuKHRva2VuU3RyZWFtLnRva2VuKCkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodG9rZW5TdHJlYW0ubWF0Y2goVG9rZW5zLklERU5UKSl7XG4gICAgICAgICAgICAgICAgICAgIHRva2VuID0gdG9rZW5TdHJlYW0udG9rZW4oKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoL2Zyb218dG8vaS50ZXN0KHRva2VuLnZhbHVlKSl7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gU3ludGF4VW5pdC5mcm9tVG9rZW4odG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdG9rZW5TdHJlYW0udW5nZXQoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvL2lmIGl0IGdldHMgaGVyZSwgdGhlcmUgd2Fzbid0IGEgdmFsaWQgdG9rZW4sIHNvIHRpbWUgdG8gZXhwbG9kZVxuICAgICAgICAgICAgICAgIHRoaXMuX3VuZXhwZWN0ZWRUb2tlbih0b2tlblN0cmVhbS5MVCgxKSk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgICAgICAvLyBIZWxwZXIgbWV0aG9kc1xuICAgICAgICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIE5vdCBwYXJ0IG9mIENTUyBncmFtbWFyLCBidXQgdXNlZnVsIGZvciBza2lwcGluZyBvdmVyXG4gICAgICAgICAgICAgKiBjb21iaW5hdGlvbiBvZiB3aGl0ZSBzcGFjZSBhbmQgSFRNTC1zdHlsZSBjb21tZW50cy5cbiAgICAgICAgICAgICAqIEByZXR1cm4ge3ZvaWR9XG4gICAgICAgICAgICAgKiBAbWV0aG9kIF9za2lwQ3J1ZnRcbiAgICAgICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIF9za2lwQ3J1ZnQ6IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgd2hpbGUodGhpcy5fdG9rZW5TdHJlYW0ubWF0Y2goW1Rva2Vucy5TLCBUb2tlbnMuQ0RPLCBUb2tlbnMuQ0RDXSkpe1xuICAgICAgICAgICAgICAgICAgICAvL25vb3BcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIE5vdCBwYXJ0IG9mIENTUyBncmFtbWFyLCBidXQgdGhpcyBwYXR0ZXJuIG9jY3VycyBmcmVxdWVudGx5XG4gICAgICAgICAgICAgKiBpbiB0aGUgb2ZmaWNpYWwgQ1NTIGdyYW1tYXIuIFNwbGl0IG91dCBoZXJlIHRvIGVsaW1pbmF0ZVxuICAgICAgICAgICAgICogZHVwbGljYXRlIGNvZGUuXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGNoZWNrU3RhcnQgSW5kaWNhdGVzIGlmIHRoZSBydWxlIHNob3VsZCBjaGVja1xuICAgICAgICAgICAgICogICAgICBmb3IgdGhlIGxlZnQgYnJhY2UgYXQgdGhlIGJlZ2lubmluZy5cbiAgICAgICAgICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gcmVhZE1hcmdpbnMgSW5kaWNhdGVzIGlmIHRoZSBydWxlIHNob3VsZCBjaGVja1xuICAgICAgICAgICAgICogICAgICBmb3IgbWFyZ2luIHBhdHRlcm5zLlxuICAgICAgICAgICAgICogQHJldHVybiB7dm9pZH1cbiAgICAgICAgICAgICAqIEBtZXRob2QgX3JlYWREZWNsYXJhdGlvbnNcbiAgICAgICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIF9yZWFkRGVjbGFyYXRpb25zOiBmdW5jdGlvbihjaGVja1N0YXJ0LCByZWFkTWFyZ2lucyl7XG4gICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgKiBSZWFkcyB0aGUgcGF0dGVyblxuICAgICAgICAgICAgICAgICAqIFMqICd7JyBTKiBkZWNsYXJhdGlvbiBbICc7JyBTKiBkZWNsYXJhdGlvbiBdKiAnfScgUypcbiAgICAgICAgICAgICAgICAgKiBvclxuICAgICAgICAgICAgICAgICAqIFMqICd7JyBTKiBbIGRlY2xhcmF0aW9uIHwgbWFyZ2luIF0/IFsgJzsnIFMqIFsgZGVjbGFyYXRpb24gfCBtYXJnaW4gXT8gXSogJ30nIFMqXG4gICAgICAgICAgICAgICAgICogTm90ZSB0aGF0IHRoaXMgaXMgaG93IGl0IGlzIGRlc2NyaWJlZCBpbiBDU1MzIFBhZ2VkIE1lZGlhLCBidXQgaXMgYWN0dWFsbHkgaW5jb3JyZWN0LlxuICAgICAgICAgICAgICAgICAqIEEgc2VtaWNvbG9uIGlzIG9ubHkgbmVjZXNzYXJ5IGZvbGxvd2luZyBhIGRlY2xhcmF0aW9uIGlmIHRoZXJlJ3MgYW5vdGhlciBkZWNsYXJhdGlvblxuICAgICAgICAgICAgICAgICAqIG9yIG1hcmdpbiBhZnRlcndhcmRzLlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHZhciB0b2tlblN0cmVhbSA9IHRoaXMuX3Rva2VuU3RyZWFtLFxuICAgICAgICAgICAgICAgICAgICB0dDtcblxuXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVhZFdoaXRlc3BhY2UoKTtcblxuICAgICAgICAgICAgICAgIGlmIChjaGVja1N0YXJ0KXtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5TdHJlYW0ubXVzdE1hdGNoKFRva2Vucy5MQlJBQ0UpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuX3JlYWRXaGl0ZXNwYWNlKCk7XG5cbiAgICAgICAgICAgICAgICB0cnkge1xuXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlKHRydWUpe1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodG9rZW5TdHJlYW0ubWF0Y2goVG9rZW5zLlNFTUlDT0xPTikgfHwgKHJlYWRNYXJnaW5zICYmIHRoaXMuX21hcmdpbigpKSl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9ub29wXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2RlY2xhcmF0aW9uKCkpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdG9rZW5TdHJlYW0ubWF0Y2goVG9rZW5zLlNFTUlDT0xPTikpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2lmICgoIXRoaXMuX21hcmdpbigpICYmICF0aGlzLl9kZWNsYXJhdGlvbigpKSB8fCAhdG9rZW5TdHJlYW0ubWF0Y2goVG9rZW5zLlNFTUlDT0xPTikpe1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL31cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlYWRXaGl0ZXNwYWNlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB0b2tlblN0cmVhbS5tdXN0TWF0Y2goVG9rZW5zLlJCUkFDRSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlYWRXaGl0ZXNwYWNlKCk7XG5cbiAgICAgICAgICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXggaW5zdGFuY2VvZiBTeW50YXhFcnJvciAmJiAhdGhpcy5vcHRpb25zLnN0cmljdCl7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vZmlyZSBlcnJvciBldmVudFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5maXJlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAgICAgICBcImVycm9yXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6ICAgICAgZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogICAgZXgubWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lOiAgICAgICBleC5saW5lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbDogICAgICAgIGV4LmNvbFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vc2VlIGlmIHRoZXJlJ3MgYW5vdGhlciBkZWNsYXJhdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgdHQgPSB0b2tlblN0cmVhbS5hZHZhbmNlKFtUb2tlbnMuU0VNSUNPTE9OLCBUb2tlbnMuUkJSQUNFXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHQgPT09IFRva2Vucy5TRU1JQ09MT04pe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vaWYgdGhlcmUncyBhIHNlbWljb2xvbiwgdGhlbiB0aGVyZSBtaWdodCBiZSBhbm90aGVyIGRlY2xhcmF0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVhZERlY2xhcmF0aW9ucyhmYWxzZSwgcmVhZE1hcmdpbnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0dCAhPT0gVG9rZW5zLlJCUkFDRSl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9pZiB0aGVyZSdzIGEgcmlnaHQgYnJhY2UsIHRoZSBydWxlIGlzIGZpbmlzaGVkIHNvIGRvbid0IGRvIGFueXRoaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9vdGhlcndpc2UsIHJldGhyb3cgdGhlIGVycm9yIGJlY2F1c2UgaXQgd2Fzbid0IGhhbmRsZWQgcHJvcGVybHlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBleDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9ub3QgYSBzeW50YXggZXJyb3IsIHJldGhyb3cgaXRcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGV4O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEluIHNvbWUgY2FzZXMsIHlvdSBjYW4gZW5kIHVwIHdpdGggdHdvIHdoaXRlIHNwYWNlIHRva2VucyBpbiBhXG4gICAgICAgICAgICAgKiByb3cuIEluc3RlYWQgb2YgbWFraW5nIGEgY2hhbmdlIGluIGV2ZXJ5IGZ1bmN0aW9uIHRoYXQgbG9va3MgZm9yXG4gICAgICAgICAgICAgKiB3aGl0ZSBzcGFjZSwgdGhpcyBmdW5jdGlvbiBpcyB1c2VkIHRvIG1hdGNoIGFzIG11Y2ggd2hpdGUgc3BhY2VcbiAgICAgICAgICAgICAqIGFzIG5lY2Vzc2FyeS5cbiAgICAgICAgICAgICAqIEBtZXRob2QgX3JlYWRXaGl0ZXNwYWNlXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSB3aGl0ZSBzcGFjZSBpZiBmb3VuZCwgZW1wdHkgc3RyaW5nIGlmIG5vdC5cbiAgICAgICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIF9yZWFkV2hpdGVzcGFjZTogZnVuY3Rpb24oKXtcblxuICAgICAgICAgICAgICAgIHZhciB0b2tlblN0cmVhbSA9IHRoaXMuX3Rva2VuU3RyZWFtLFxuICAgICAgICAgICAgICAgICAgICB3cyA9IFwiXCI7XG5cbiAgICAgICAgICAgICAgICB3aGlsZSh0b2tlblN0cmVhbS5tYXRjaChUb2tlbnMuUykpe1xuICAgICAgICAgICAgICAgICAgICB3cyArPSB0b2tlblN0cmVhbS50b2tlbigpLnZhbHVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB3cztcbiAgICAgICAgICAgIH0sXG5cblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUaHJvd3MgYW4gZXJyb3Igd2hlbiBhbiB1bmV4cGVjdGVkIHRva2VuIGlzIGZvdW5kLlxuICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHRva2VuIFRoZSB0b2tlbiB0aGF0IHdhcyBmb3VuZC5cbiAgICAgICAgICAgICAqIEBtZXRob2QgX3VuZXhwZWN0ZWRUb2tlblxuICAgICAgICAgICAgICogQHJldHVybiB7dm9pZH1cbiAgICAgICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIF91bmV4cGVjdGVkVG9rZW46IGZ1bmN0aW9uKHRva2VuKXtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXCJVbmV4cGVjdGVkIHRva2VuICdcIiArIHRva2VuLnZhbHVlICsgXCInIGF0IGxpbmUgXCIgKyB0b2tlbi5zdGFydExpbmUgKyBcIiwgY29sIFwiICsgdG9rZW4uc3RhcnRDb2wgKyBcIi5cIiwgdG9rZW4uc3RhcnRMaW5lLCB0b2tlbi5zdGFydENvbCk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEhlbHBlciBtZXRob2QgdXNlZCBmb3IgcGFyc2luZyBzdWJwYXJ0cyBvZiBhIHN0eWxlIHNoZWV0LlxuICAgICAgICAgICAgICogQHJldHVybiB7dm9pZH1cbiAgICAgICAgICAgICAqIEBtZXRob2QgX3ZlcmlmeUVuZFxuICAgICAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgX3ZlcmlmeUVuZDogZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fdG9rZW5TdHJlYW0uTEEoMSkgIT09IFRva2Vucy5FT0Ype1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl91bmV4cGVjdGVkVG9rZW4odGhpcy5fdG9rZW5TdHJlYW0uTFQoMSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgICAgIC8vIFZhbGlkYXRpb24gbWV0aG9kc1xuICAgICAgICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAgICAgX3ZhbGlkYXRlUHJvcGVydHk6IGZ1bmN0aW9uKHByb3BlcnR5LCB2YWx1ZSl7XG4gICAgICAgICAgICAgICAgVmFsaWRhdGlvbi52YWxpZGF0ZShwcm9wZXJ0eSwgdmFsdWUpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAgICAgLy8gUGFyc2luZyBtZXRob2RzXG4gICAgICAgICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgICAgIHBhcnNlOiBmdW5jdGlvbihpbnB1dCl7XG4gICAgICAgICAgICAgICAgdGhpcy5fdG9rZW5TdHJlYW0gPSBuZXcgVG9rZW5TdHJlYW0oaW5wdXQsIFRva2Vucyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3R5bGVzaGVldCgpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgcGFyc2VTdHlsZVNoZWV0OiBmdW5jdGlvbihpbnB1dCl7XG4gICAgICAgICAgICAgICAgLy9qdXN0IHBhc3N0aHJvdWdoXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2UoaW5wdXQpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgcGFyc2VNZWRpYVF1ZXJ5OiBmdW5jdGlvbihpbnB1dCl7XG4gICAgICAgICAgICAgICAgdGhpcy5fdG9rZW5TdHJlYW0gPSBuZXcgVG9rZW5TdHJlYW0oaW5wdXQsIFRva2Vucyk7XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuX21lZGlhX3F1ZXJ5KCk7XG5cbiAgICAgICAgICAgICAgICAvL2lmIHRoZXJlJ3MgYW55dGhpbmcgbW9yZSwgdGhlbiBpdCdzIGFuIGludmFsaWQgc2VsZWN0b3JcbiAgICAgICAgICAgICAgICB0aGlzLl92ZXJpZnlFbmQoKTtcblxuICAgICAgICAgICAgICAgIC8vb3RoZXJ3aXNlIHJldHVybiByZXN1bHRcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBQYXJzZXMgYSBwcm9wZXJ0eSB2YWx1ZSAoZXZlcnl0aGluZyBhZnRlciB0aGUgc2VtaWNvbG9uKS5cbiAgICAgICAgICAgICAqIEByZXR1cm4ge3BhcnNlcmxpYi5jc3MuUHJvcGVydHlWYWx1ZX0gVGhlIHByb3BlcnR5IHZhbHVlLlxuICAgICAgICAgICAgICogQHRocm93cyBwYXJzZXJsaWIudXRpbC5TeW50YXhFcnJvciBJZiBhbiB1bmV4cGVjdGVkIHRva2VuIGlzIGZvdW5kLlxuICAgICAgICAgICAgICogQG1ldGhvZCBwYXJzZXJQcm9wZXJ0eVZhbHVlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHBhcnNlUHJvcGVydHlWYWx1ZTogZnVuY3Rpb24oaW5wdXQpe1xuXG4gICAgICAgICAgICAgICAgdGhpcy5fdG9rZW5TdHJlYW0gPSBuZXcgVG9rZW5TdHJlYW0oaW5wdXQsIFRva2Vucyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVhZFdoaXRlc3BhY2UoKTtcblxuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLl9leHByKCk7XG5cbiAgICAgICAgICAgICAgICAvL29rYXkgdG8gaGF2ZSBhIHRyYWlsaW5nIHdoaXRlIHNwYWNlXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVhZFdoaXRlc3BhY2UoKTtcblxuICAgICAgICAgICAgICAgIC8vaWYgdGhlcmUncyBhbnl0aGluZyBtb3JlLCB0aGVuIGl0J3MgYW4gaW52YWxpZCBzZWxlY3RvclxuICAgICAgICAgICAgICAgIHRoaXMuX3ZlcmlmeUVuZCgpO1xuXG4gICAgICAgICAgICAgICAgLy9vdGhlcndpc2UgcmV0dXJuIHJlc3VsdFxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFBhcnNlcyBhIGNvbXBsZXRlIENTUyBydWxlLCBpbmNsdWRpbmcgc2VsZWN0b3JzIGFuZFxuICAgICAgICAgICAgICogcHJvcGVydGllcy5cbiAgICAgICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgdGV4dCB0byBwYXJzZXIuXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBUcnVlIGlmIHRoZSBwYXJzZSBjb21wbGV0ZWQgc3VjY2Vzc2Z1bGx5LCBmYWxzZSBpZiBub3QuXG4gICAgICAgICAgICAgKiBAbWV0aG9kIHBhcnNlUnVsZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBwYXJzZVJ1bGU6IGZ1bmN0aW9uKGlucHV0KXtcbiAgICAgICAgICAgICAgICB0aGlzLl90b2tlblN0cmVhbSA9IG5ldyBUb2tlblN0cmVhbShpbnB1dCwgVG9rZW5zKTtcblxuICAgICAgICAgICAgICAgIC8vc2tpcCBhbnkgbGVhZGluZyB3aGl0ZSBzcGFjZVxuICAgICAgICAgICAgICAgIHRoaXMuX3JlYWRXaGl0ZXNwYWNlKCk7XG5cbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5fcnVsZXNldCgpO1xuXG4gICAgICAgICAgICAgICAgLy9za2lwIGFueSB0cmFpbGluZyB3aGl0ZSBzcGFjZVxuICAgICAgICAgICAgICAgIHRoaXMuX3JlYWRXaGl0ZXNwYWNlKCk7XG5cbiAgICAgICAgICAgICAgICAvL2lmIHRoZXJlJ3MgYW55dGhpbmcgbW9yZSwgdGhlbiBpdCdzIGFuIGludmFsaWQgc2VsZWN0b3JcbiAgICAgICAgICAgICAgICB0aGlzLl92ZXJpZnlFbmQoKTtcblxuICAgICAgICAgICAgICAgIC8vb3RoZXJ3aXNlIHJldHVybiByZXN1bHRcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBQYXJzZXMgYSBzaW5nbGUgQ1NTIHNlbGVjdG9yIChubyBjb21tYSlcbiAgICAgICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgdGV4dCB0byBwYXJzZSBhcyBhIENTUyBzZWxlY3Rvci5cbiAgICAgICAgICAgICAqIEByZXR1cm4ge1NlbGVjdG9yfSBBbiBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBzZWxlY3Rvci5cbiAgICAgICAgICAgICAqIEB0aHJvd3MgcGFyc2VybGliLnV0aWwuU3ludGF4RXJyb3IgSWYgYW4gdW5leHBlY3RlZCB0b2tlbiBpcyBmb3VuZC5cbiAgICAgICAgICAgICAqIEBtZXRob2QgcGFyc2VTZWxlY3RvclxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBwYXJzZVNlbGVjdG9yOiBmdW5jdGlvbihpbnB1dCl7XG5cbiAgICAgICAgICAgICAgICB0aGlzLl90b2tlblN0cmVhbSA9IG5ldyBUb2tlblN0cmVhbShpbnB1dCwgVG9rZW5zKTtcblxuICAgICAgICAgICAgICAgIC8vc2tpcCBhbnkgbGVhZGluZyB3aGl0ZSBzcGFjZVxuICAgICAgICAgICAgICAgIHRoaXMuX3JlYWRXaGl0ZXNwYWNlKCk7XG5cbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5fc2VsZWN0b3IoKTtcblxuICAgICAgICAgICAgICAgIC8vc2tpcCBhbnkgdHJhaWxpbmcgd2hpdGUgc3BhY2VcbiAgICAgICAgICAgICAgICB0aGlzLl9yZWFkV2hpdGVzcGFjZSgpO1xuXG4gICAgICAgICAgICAgICAgLy9pZiB0aGVyZSdzIGFueXRoaW5nIG1vcmUsIHRoZW4gaXQncyBhbiBpbnZhbGlkIHNlbGVjdG9yXG4gICAgICAgICAgICAgICAgdGhpcy5fdmVyaWZ5RW5kKCk7XG5cbiAgICAgICAgICAgICAgICAvL290aGVyd2lzZSByZXR1cm4gcmVzdWx0XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUGFyc2VzIGFuIEhUTUwgc3R5bGUgYXR0cmlidXRlOiBhIHNldCBvZiBDU1MgZGVjbGFyYXRpb25zXG4gICAgICAgICAgICAgKiBzZXBhcmF0ZWQgYnkgc2VtaWNvbG9ucy5cbiAgICAgICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgdGV4dCB0byBwYXJzZSBhcyBhIHN0eWxlIGF0dHJpYnV0ZVxuICAgICAgICAgICAgICogQHJldHVybiB7dm9pZH1cbiAgICAgICAgICAgICAqIEBtZXRob2QgcGFyc2VTdHlsZUF0dHJpYnV0ZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBwYXJzZVN0eWxlQXR0cmlidXRlOiBmdW5jdGlvbihpbnB1dCl7XG4gICAgICAgICAgICAgICAgaW5wdXQgKz0gXCJ9XCI7IC8vIGZvciBlcnJvciByZWNvdmVyeSBpbiBfcmVhZERlY2xhcmF0aW9ucygpXG4gICAgICAgICAgICAgICAgdGhpcy5fdG9rZW5TdHJlYW0gPSBuZXcgVG9rZW5TdHJlYW0oaW5wdXQsIFRva2Vucyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVhZERlY2xhcmF0aW9ucygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgLy9jb3B5IG92ZXIgb250byBwcm90b3R5cGVcbiAgICBmb3IgKHByb3AgaW4gYWRkaXRpb25zKXtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChhZGRpdGlvbnMsIHByb3ApKXtcbiAgICAgICAgICAgIHByb3RvW3Byb3BdID0gYWRkaXRpb25zW3Byb3BdO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHByb3RvO1xufSgpO1xuXG5cbi8qXG5udGhcbiAgOiBTKiBbIFsnLSd8JysnXT8gSU5URUdFUj8ge059IFsgUyogWyctJ3wnKyddIFMqIElOVEVHRVIgXT8gfFxuICAgICAgICAgWyctJ3wnKyddPyBJTlRFR0VSIHwge099e0R9e0R9IHwge0V9e1Z9e0V9e059IF0gUypcbiAgO1xuKi9cbnZhciBQcm9wZXJ0aWVzID0ge1xuICAgIF9fcHJvdG9fXzogbnVsbCxcblxuICAgIC8vQVxuICAgIFwiYWxpZ24taXRlbXNcIiAgICAgICAgICAgICAgICAgICA6IFwiZmxleC1zdGFydCB8IGZsZXgtZW5kIHwgY2VudGVyIHwgYmFzZWxpbmUgfCBzdHJldGNoXCIsXG4gICAgXCJhbGlnbi1jb250ZW50XCIgICAgICAgICAgICAgICAgIDogXCJmbGV4LXN0YXJ0IHwgZmxleC1lbmQgfCBjZW50ZXIgfCBzcGFjZS1iZXR3ZWVuIHwgc3BhY2UtYXJvdW5kIHwgc3RyZXRjaFwiLFxuICAgIFwiYWxpZ24tc2VsZlwiICAgICAgICAgICAgICAgICAgICA6IFwiYXV0byB8IGZsZXgtc3RhcnQgfCBmbGV4LWVuZCB8IGNlbnRlciB8IGJhc2VsaW5lIHwgc3RyZXRjaFwiLFxuICAgIFwiLXdlYmtpdC1hbGlnbi1pdGVtc1wiICAgICAgICAgICA6IFwiZmxleC1zdGFydCB8IGZsZXgtZW5kIHwgY2VudGVyIHwgYmFzZWxpbmUgfCBzdHJldGNoXCIsXG4gICAgXCItd2Via2l0LWFsaWduLWNvbnRlbnRcIiAgICAgICAgIDogXCJmbGV4LXN0YXJ0IHwgZmxleC1lbmQgfCBjZW50ZXIgfCBzcGFjZS1iZXR3ZWVuIHwgc3BhY2UtYXJvdW5kIHwgc3RyZXRjaFwiLFxuICAgIFwiLXdlYmtpdC1hbGlnbi1zZWxmXCIgICAgICAgICAgICA6IFwiYXV0byB8IGZsZXgtc3RhcnQgfCBmbGV4LWVuZCB8IGNlbnRlciB8IGJhc2VsaW5lIHwgc3RyZXRjaFwiLFxuICAgIFwiYWxpZ25tZW50LWFkanVzdFwiICAgICAgICAgICAgICA6IFwiYXV0byB8IGJhc2VsaW5lIHwgYmVmb3JlLWVkZ2UgfCB0ZXh0LWJlZm9yZS1lZGdlIHwgbWlkZGxlIHwgY2VudHJhbCB8IGFmdGVyLWVkZ2UgfCB0ZXh0LWFmdGVyLWVkZ2UgfCBpZGVvZ3JhcGhpYyB8IGFscGhhYmV0aWMgfCBoYW5naW5nIHwgbWF0aGVtYXRpY2FsIHwgPHBlcmNlbnRhZ2U+IHwgPGxlbmd0aD5cIixcbiAgICBcImFsaWdubWVudC1iYXNlbGluZVwiICAgICAgICAgICAgOiBcImJhc2VsaW5lIHwgdXNlLXNjcmlwdCB8IGJlZm9yZS1lZGdlIHwgdGV4dC1iZWZvcmUtZWRnZSB8IGFmdGVyLWVkZ2UgfCB0ZXh0LWFmdGVyLWVkZ2UgfCBjZW50cmFsIHwgbWlkZGxlIHwgaWRlb2dyYXBoaWMgfCBhbHBoYWJldGljIHwgaGFuZ2luZyB8IG1hdGhlbWF0aWNhbFwiLFxuICAgIFwiYW5pbWF0aW9uXCIgICAgICAgICAgICAgICAgICAgICA6IDEsXG4gICAgXCJhbmltYXRpb24tZGVsYXlcIiAgICAgICAgICAgICAgIDogeyBtdWx0aTogXCI8dGltZT5cIiwgY29tbWE6IHRydWUgfSxcbiAgICBcImFuaW1hdGlvbi1kaXJlY3Rpb25cIiAgICAgICAgICAgOiB7IG11bHRpOiBcIm5vcm1hbCB8IGFsdGVybmF0ZVwiLCBjb21tYTogdHJ1ZSB9LFxuICAgIFwiYW5pbWF0aW9uLWR1cmF0aW9uXCIgICAgICAgICAgICA6IHsgbXVsdGk6IFwiPHRpbWU+XCIsIGNvbW1hOiB0cnVlIH0sXG4gICAgXCJhbmltYXRpb24tZmlsbC1tb2RlXCIgICAgICAgICAgIDogeyBtdWx0aTogXCJub25lIHwgZm9yd2FyZHMgfCBiYWNrd2FyZHMgfCBib3RoXCIsIGNvbW1hOiB0cnVlIH0sXG4gICAgXCJhbmltYXRpb24taXRlcmF0aW9uLWNvdW50XCIgICAgIDogeyBtdWx0aTogXCI8bnVtYmVyPiB8IGluZmluaXRlXCIsIGNvbW1hOiB0cnVlIH0sXG4gICAgXCJhbmltYXRpb24tbmFtZVwiICAgICAgICAgICAgICAgIDogeyBtdWx0aTogXCJub25lIHwgPGlkZW50PlwiLCBjb21tYTogdHJ1ZSB9LFxuICAgIFwiYW5pbWF0aW9uLXBsYXktc3RhdGVcIiAgICAgICAgICA6IHsgbXVsdGk6IFwicnVubmluZyB8IHBhdXNlZFwiLCBjb21tYTogdHJ1ZSB9LFxuICAgIFwiYW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvblwiICAgICA6IDEsXG5cbiAgICAvL3ZlbmRvciBwcmVmaXhlZFxuICAgIFwiLW1vei1hbmltYXRpb24tZGVsYXlcIiAgICAgICAgICAgICAgIDogeyBtdWx0aTogXCI8dGltZT5cIiwgY29tbWE6IHRydWUgfSxcbiAgICBcIi1tb3otYW5pbWF0aW9uLWRpcmVjdGlvblwiICAgICAgICAgICA6IHsgbXVsdGk6IFwibm9ybWFsIHwgYWx0ZXJuYXRlXCIsIGNvbW1hOiB0cnVlIH0sXG4gICAgXCItbW96LWFuaW1hdGlvbi1kdXJhdGlvblwiICAgICAgICAgICAgOiB7IG11bHRpOiBcIjx0aW1lPlwiLCBjb21tYTogdHJ1ZSB9LFxuICAgIFwiLW1vei1hbmltYXRpb24taXRlcmF0aW9uLWNvdW50XCIgICAgIDogeyBtdWx0aTogXCI8bnVtYmVyPiB8IGluZmluaXRlXCIsIGNvbW1hOiB0cnVlIH0sXG4gICAgXCItbW96LWFuaW1hdGlvbi1uYW1lXCIgICAgICAgICAgICAgICAgOiB7IG11bHRpOiBcIm5vbmUgfCA8aWRlbnQ+XCIsIGNvbW1hOiB0cnVlIH0sXG4gICAgXCItbW96LWFuaW1hdGlvbi1wbGF5LXN0YXRlXCIgICAgICAgICAgOiB7IG11bHRpOiBcInJ1bm5pbmcgfCBwYXVzZWRcIiwgY29tbWE6IHRydWUgfSxcblxuICAgIFwiLW1zLWFuaW1hdGlvbi1kZWxheVwiICAgICAgICAgICAgICAgOiB7IG11bHRpOiBcIjx0aW1lPlwiLCBjb21tYTogdHJ1ZSB9LFxuICAgIFwiLW1zLWFuaW1hdGlvbi1kaXJlY3Rpb25cIiAgICAgICAgICAgOiB7IG11bHRpOiBcIm5vcm1hbCB8IGFsdGVybmF0ZVwiLCBjb21tYTogdHJ1ZSB9LFxuICAgIFwiLW1zLWFuaW1hdGlvbi1kdXJhdGlvblwiICAgICAgICAgICAgOiB7IG11bHRpOiBcIjx0aW1lPlwiLCBjb21tYTogdHJ1ZSB9LFxuICAgIFwiLW1zLWFuaW1hdGlvbi1pdGVyYXRpb24tY291bnRcIiAgICAgOiB7IG11bHRpOiBcIjxudW1iZXI+IHwgaW5maW5pdGVcIiwgY29tbWE6IHRydWUgfSxcbiAgICBcIi1tcy1hbmltYXRpb24tbmFtZVwiICAgICAgICAgICAgICAgIDogeyBtdWx0aTogXCJub25lIHwgPGlkZW50PlwiLCBjb21tYTogdHJ1ZSB9LFxuICAgIFwiLW1zLWFuaW1hdGlvbi1wbGF5LXN0YXRlXCIgICAgICAgICAgOiB7IG11bHRpOiBcInJ1bm5pbmcgfCBwYXVzZWRcIiwgY29tbWE6IHRydWUgfSxcblxuICAgIFwiLXdlYmtpdC1hbmltYXRpb24tZGVsYXlcIiAgICAgICAgICAgICAgIDogeyBtdWx0aTogXCI8dGltZT5cIiwgY29tbWE6IHRydWUgfSxcbiAgICBcIi13ZWJraXQtYW5pbWF0aW9uLWRpcmVjdGlvblwiICAgICAgICAgICA6IHsgbXVsdGk6IFwibm9ybWFsIHwgYWx0ZXJuYXRlXCIsIGNvbW1hOiB0cnVlIH0sXG4gICAgXCItd2Via2l0LWFuaW1hdGlvbi1kdXJhdGlvblwiICAgICAgICAgICAgOiB7IG11bHRpOiBcIjx0aW1lPlwiLCBjb21tYTogdHJ1ZSB9LFxuICAgIFwiLXdlYmtpdC1hbmltYXRpb24tZmlsbC1tb2RlXCIgICAgICAgICAgIDogeyBtdWx0aTogXCJub25lIHwgZm9yd2FyZHMgfCBiYWNrd2FyZHMgfCBib3RoXCIsIGNvbW1hOiB0cnVlIH0sXG4gICAgXCItd2Via2l0LWFuaW1hdGlvbi1pdGVyYXRpb24tY291bnRcIiAgICAgOiB7IG11bHRpOiBcIjxudW1iZXI+IHwgaW5maW5pdGVcIiwgY29tbWE6IHRydWUgfSxcbiAgICBcIi13ZWJraXQtYW5pbWF0aW9uLW5hbWVcIiAgICAgICAgICAgICAgICA6IHsgbXVsdGk6IFwibm9uZSB8IDxpZGVudD5cIiwgY29tbWE6IHRydWUgfSxcbiAgICBcIi13ZWJraXQtYW5pbWF0aW9uLXBsYXktc3RhdGVcIiAgICAgICAgICA6IHsgbXVsdGk6IFwicnVubmluZyB8IHBhdXNlZFwiLCBjb21tYTogdHJ1ZSB9LFxuXG4gICAgXCItby1hbmltYXRpb24tZGVsYXlcIiAgICAgICAgICAgICAgIDogeyBtdWx0aTogXCI8dGltZT5cIiwgY29tbWE6IHRydWUgfSxcbiAgICBcIi1vLWFuaW1hdGlvbi1kaXJlY3Rpb25cIiAgICAgICAgICAgOiB7IG11bHRpOiBcIm5vcm1hbCB8IGFsdGVybmF0ZVwiLCBjb21tYTogdHJ1ZSB9LFxuICAgIFwiLW8tYW5pbWF0aW9uLWR1cmF0aW9uXCIgICAgICAgICAgICA6IHsgbXVsdGk6IFwiPHRpbWU+XCIsIGNvbW1hOiB0cnVlIH0sXG4gICAgXCItby1hbmltYXRpb24taXRlcmF0aW9uLWNvdW50XCIgICAgIDogeyBtdWx0aTogXCI8bnVtYmVyPiB8IGluZmluaXRlXCIsIGNvbW1hOiB0cnVlIH0sXG4gICAgXCItby1hbmltYXRpb24tbmFtZVwiICAgICAgICAgICAgICAgIDogeyBtdWx0aTogXCJub25lIHwgPGlkZW50PlwiLCBjb21tYTogdHJ1ZSB9LFxuICAgIFwiLW8tYW5pbWF0aW9uLXBsYXktc3RhdGVcIiAgICAgICAgICA6IHsgbXVsdGk6IFwicnVubmluZyB8IHBhdXNlZFwiLCBjb21tYTogdHJ1ZSB9LFxuXG4gICAgXCJhcHBlYXJhbmNlXCIgICAgICAgICAgICAgICAgICAgIDogXCJpY29uIHwgd2luZG93IHwgZGVza3RvcCB8IHdvcmtzcGFjZSB8IGRvY3VtZW50IHwgdG9vbHRpcCB8IGRpYWxvZyB8IGJ1dHRvbiB8IHB1c2gtYnV0dG9uIHwgaHlwZXJsaW5rIHwgcmFkaW8gfCByYWRpby1idXR0b24gfCBjaGVja2JveCB8IG1lbnUtaXRlbSB8IHRhYiB8IG1lbnUgfCBtZW51YmFyIHwgcHVsbC1kb3duLW1lbnUgfCBwb3AtdXAtbWVudSB8IGxpc3QtbWVudSB8IHJhZGlvLWdyb3VwIHwgY2hlY2tib3gtZ3JvdXAgfCBvdXRsaW5lLXRyZWUgfCByYW5nZSB8IGZpZWxkIHwgY29tYm8tYm94IHwgc2lnbmF0dXJlIHwgcGFzc3dvcmQgfCBub3JtYWwgfCBub25lIHwgaW5oZXJpdFwiLFxuICAgIFwiYXppbXV0aFwiICAgICAgICAgICAgICAgICAgICAgICA6IGZ1bmN0aW9uIChleHByZXNzaW9uKSB7XG4gICAgICAgIHZhciBzaW1wbGUgICAgICA9IFwiPGFuZ2xlPiB8IGxlZnR3YXJkcyB8IHJpZ2h0d2FyZHMgfCBpbmhlcml0XCIsXG4gICAgICAgICAgICBkaXJlY3Rpb24gICA9IFwibGVmdC1zaWRlIHwgZmFyLWxlZnQgfCBsZWZ0IHwgY2VudGVyLWxlZnQgfCBjZW50ZXIgfCBjZW50ZXItcmlnaHQgfCByaWdodCB8IGZhci1yaWdodCB8IHJpZ2h0LXNpZGVcIixcbiAgICAgICAgICAgIGJlaGluZCAgICAgID0gZmFsc2UsXG4gICAgICAgICAgICB2YWxpZCAgICAgICA9IGZhbHNlLFxuICAgICAgICAgICAgcGFydDtcblxuICAgICAgICBpZiAoIVZhbGlkYXRpb25UeXBlcy5pc0FueShleHByZXNzaW9uLCBzaW1wbGUpKSB7XG4gICAgICAgICAgICBpZiAoVmFsaWRhdGlvblR5cGVzLmlzQW55KGV4cHJlc3Npb24sIFwiYmVoaW5kXCIpKSB7XG4gICAgICAgICAgICAgICAgYmVoaW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB2YWxpZCA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChWYWxpZGF0aW9uVHlwZXMuaXNBbnkoZXhwcmVzc2lvbiwgZGlyZWN0aW9uKSkge1xuICAgICAgICAgICAgICAgIHZhbGlkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAoIWJlaGluZCkge1xuICAgICAgICAgICAgICAgICAgICBWYWxpZGF0aW9uVHlwZXMuaXNBbnkoZXhwcmVzc2lvbiwgXCJiZWhpbmRcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGV4cHJlc3Npb24uaGFzTmV4dCgpKSB7XG4gICAgICAgICAgICBwYXJ0ID0gZXhwcmVzc2lvbi5uZXh0KCk7XG4gICAgICAgICAgICBpZiAodmFsaWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKFwiRXhwZWN0ZWQgZW5kIG9mIHZhbHVlIGJ1dCBmb3VuZCAnXCIgKyBwYXJ0ICsgXCInLlwiLCBwYXJ0LmxpbmUsIHBhcnQuY29sKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcihcIkV4cGVjdGVkICg8J2F6aW11dGgnPikgYnV0IGZvdW5kICdcIiArIHBhcnQgKyBcIicuXCIsIHBhcnQubGluZSwgcGFydC5jb2wpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8vQlxuICAgIFwiYmFja2ZhY2UtdmlzaWJpbGl0eVwiICAgICAgICAgICA6IFwidmlzaWJsZSB8IGhpZGRlblwiLFxuICAgIFwiYmFja2dyb3VuZFwiICAgICAgICAgICAgICAgICAgICA6IDEsXG4gICAgXCJiYWNrZ3JvdW5kLWF0dGFjaG1lbnRcIiAgICAgICAgIDogeyBtdWx0aTogXCI8YXR0YWNobWVudD5cIiwgY29tbWE6IHRydWUgfSxcbiAgICBcImJhY2tncm91bmQtY2xpcFwiICAgICAgICAgICAgICAgOiB7IG11bHRpOiBcIjxib3g+XCIsIGNvbW1hOiB0cnVlIH0sXG4gICAgXCJiYWNrZ3JvdW5kLWNvbG9yXCIgICAgICAgICAgICAgIDogXCI8Y29sb3I+IHwgaW5oZXJpdFwiLFxuICAgIFwiYmFja2dyb3VuZC1pbWFnZVwiICAgICAgICAgICAgICA6IHsgbXVsdGk6IFwiPGJnLWltYWdlPlwiLCBjb21tYTogdHJ1ZSB9LFxuICAgIFwiYmFja2dyb3VuZC1vcmlnaW5cIiAgICAgICAgICAgICA6IHsgbXVsdGk6IFwiPGJveD5cIiwgY29tbWE6IHRydWUgfSxcbiAgICBcImJhY2tncm91bmQtcG9zaXRpb25cIiAgICAgICAgICAgOiB7IG11bHRpOiBcIjxiZy1wb3NpdGlvbj5cIiwgY29tbWE6IHRydWUgfSxcbiAgICBcImJhY2tncm91bmQtcmVwZWF0XCIgICAgICAgICAgICAgOiB7IG11bHRpOiBcIjxyZXBlYXQtc3R5bGU+XCIgfSxcbiAgICBcImJhY2tncm91bmQtc2l6ZVwiICAgICAgICAgICAgICAgOiB7IG11bHRpOiBcIjxiZy1zaXplPlwiLCBjb21tYTogdHJ1ZSB9LFxuICAgIFwiYmFzZWxpbmUtc2hpZnRcIiAgICAgICAgICAgICAgICA6IFwiYmFzZWxpbmUgfCBzdWIgfCBzdXBlciB8IDxwZXJjZW50YWdlPiB8IDxsZW5ndGg+XCIsXG4gICAgXCJiZWhhdmlvclwiICAgICAgICAgICAgICAgICAgICAgIDogMSxcbiAgICBcImJpbmRpbmdcIiAgICAgICAgICAgICAgICAgICAgICAgOiAxLFxuICAgIFwiYmxlZWRcIiAgICAgICAgICAgICAgICAgICAgICAgICA6IFwiPGxlbmd0aD5cIixcbiAgICBcImJvb2ttYXJrLWxhYmVsXCIgICAgICAgICAgICAgICAgOiBcIjxjb250ZW50PiB8IDxhdHRyPiB8IDxzdHJpbmc+XCIsXG4gICAgXCJib29rbWFyay1sZXZlbFwiICAgICAgICAgICAgICAgIDogXCJub25lIHwgPGludGVnZXI+XCIsXG4gICAgXCJib29rbWFyay1zdGF0ZVwiICAgICAgICAgICAgICAgIDogXCJvcGVuIHwgY2xvc2VkXCIsXG4gICAgXCJib29rbWFyay10YXJnZXRcIiAgICAgICAgICAgICAgIDogXCJub25lIHwgPHVyaT4gfCA8YXR0cj5cIixcbiAgICBcImJvcmRlclwiICAgICAgICAgICAgICAgICAgICAgICAgOiBcIjxib3JkZXItd2lkdGg+IHx8IDxib3JkZXItc3R5bGU+IHx8IDxjb2xvcj5cIixcbiAgICBcImJvcmRlci1ib3R0b21cIiAgICAgICAgICAgICAgICAgOiBcIjxib3JkZXItd2lkdGg+IHx8IDxib3JkZXItc3R5bGU+IHx8IDxjb2xvcj5cIixcbiAgICBcImJvcmRlci1ib3R0b20tY29sb3JcIiAgICAgICAgICAgOiBcIjxjb2xvcj4gfCBpbmhlcml0XCIsXG4gICAgXCJib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzXCIgICAgIDogIFwiPHgtb25lLXJhZGl1cz5cIixcbiAgICBcImJvcmRlci1ib3R0b20tcmlnaHQtcmFkaXVzXCIgICAgOiAgXCI8eC1vbmUtcmFkaXVzPlwiLFxuICAgIFwiYm9yZGVyLWJvdHRvbS1zdHlsZVwiICAgICAgICAgICA6IFwiPGJvcmRlci1zdHlsZT5cIixcbiAgICBcImJvcmRlci1ib3R0b20td2lkdGhcIiAgICAgICAgICAgOiBcIjxib3JkZXItd2lkdGg+XCIsXG4gICAgXCJib3JkZXItY29sbGFwc2VcIiAgICAgICAgICAgICAgIDogXCJjb2xsYXBzZSB8IHNlcGFyYXRlIHwgaW5oZXJpdFwiLFxuICAgIFwiYm9yZGVyLWNvbG9yXCIgICAgICAgICAgICAgICAgICA6IHsgbXVsdGk6IFwiPGNvbG9yPiB8IGluaGVyaXRcIiwgbWF4OiA0IH0sXG4gICAgXCJib3JkZXItaW1hZ2VcIiAgICAgICAgICAgICAgICAgIDogMSxcbiAgICBcImJvcmRlci1pbWFnZS1vdXRzZXRcIiAgICAgICAgICAgOiB7IG11bHRpOiBcIjxsZW5ndGg+IHwgPG51bWJlcj5cIiwgbWF4OiA0IH0sXG4gICAgXCJib3JkZXItaW1hZ2UtcmVwZWF0XCIgICAgICAgICAgIDogeyBtdWx0aTogXCJzdHJldGNoIHwgcmVwZWF0IHwgcm91bmRcIiwgbWF4OiAyIH0sXG4gICAgXCJib3JkZXItaW1hZ2Utc2xpY2VcIiAgICAgICAgICAgIDogZnVuY3Rpb24oZXhwcmVzc2lvbikge1xuXG4gICAgICAgIHZhciB2YWxpZCAgID0gZmFsc2UsXG4gICAgICAgICAgICBudW1lcmljID0gXCI8bnVtYmVyPiB8IDxwZXJjZW50YWdlPlwiLFxuICAgICAgICAgICAgZmlsbCAgICA9IGZhbHNlLFxuICAgICAgICAgICAgY291bnQgICA9IDAsXG4gICAgICAgICAgICBtYXggICAgID0gNCxcbiAgICAgICAgICAgIHBhcnQ7XG5cbiAgICAgICAgaWYgKFZhbGlkYXRpb25UeXBlcy5pc0FueShleHByZXNzaW9uLCBcImZpbGxcIikpIHtcbiAgICAgICAgICAgIGZpbGwgPSB0cnVlO1xuICAgICAgICAgICAgdmFsaWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgd2hpbGUgKGV4cHJlc3Npb24uaGFzTmV4dCgpICYmIGNvdW50IDwgbWF4KSB7XG4gICAgICAgICAgICB2YWxpZCA9IFZhbGlkYXRpb25UeXBlcy5pc0FueShleHByZXNzaW9uLCBudW1lcmljKTtcbiAgICAgICAgICAgIGlmICghdmFsaWQpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvdW50Kys7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGlmICghZmlsbCkge1xuICAgICAgICAgICAgVmFsaWRhdGlvblR5cGVzLmlzQW55KGV4cHJlc3Npb24sIFwiZmlsbFwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhbGlkID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChleHByZXNzaW9uLmhhc05leHQoKSkge1xuICAgICAgICAgICAgcGFydCA9IGV4cHJlc3Npb24ubmV4dCgpO1xuICAgICAgICAgICAgaWYgKHZhbGlkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcihcIkV4cGVjdGVkIGVuZCBvZiB2YWx1ZSBidXQgZm91bmQgJ1wiICsgcGFydCArIFwiJy5cIiwgcGFydC5saW5lLCBwYXJ0LmNvbCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBWYWxpZGF0aW9uRXJyb3IoXCJFeHBlY3RlZCAoWzxudW1iZXI+IHwgPHBlcmNlbnRhZ2U+XXsxLDR9ICYmIGZpbGw/KSBidXQgZm91bmQgJ1wiICsgcGFydCArIFwiJy5cIiwgcGFydC5saW5lLCBwYXJ0LmNvbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuICAgIFwiYm9yZGVyLWltYWdlLXNvdXJjZVwiICAgICAgICAgICA6IFwiPGltYWdlPiB8IG5vbmVcIixcbiAgICBcImJvcmRlci1pbWFnZS13aWR0aFwiICAgICAgICAgICAgOiB7IG11bHRpOiBcIjxsZW5ndGg+IHwgPHBlcmNlbnRhZ2U+IHwgPG51bWJlcj4gfCBhdXRvXCIsIG1heDogNCB9LFxuICAgIFwiYm9yZGVyLWxlZnRcIiAgICAgICAgICAgICAgICAgICA6IFwiPGJvcmRlci13aWR0aD4gfHwgPGJvcmRlci1zdHlsZT4gfHwgPGNvbG9yPlwiLFxuICAgIFwiYm9yZGVyLWxlZnQtY29sb3JcIiAgICAgICAgICAgICA6IFwiPGNvbG9yPiB8IGluaGVyaXRcIixcbiAgICBcImJvcmRlci1sZWZ0LXN0eWxlXCIgICAgICAgICAgICAgOiBcIjxib3JkZXItc3R5bGU+XCIsXG4gICAgXCJib3JkZXItbGVmdC13aWR0aFwiICAgICAgICAgICAgIDogXCI8Ym9yZGVyLXdpZHRoPlwiLFxuICAgIFwiYm9yZGVyLXJhZGl1c1wiICAgICAgICAgICAgICAgICA6IGZ1bmN0aW9uKGV4cHJlc3Npb24pIHtcblxuICAgICAgICB2YXIgdmFsaWQgICA9IGZhbHNlLFxuICAgICAgICAgICAgc2ltcGxlID0gXCI8bGVuZ3RoPiB8IDxwZXJjZW50YWdlPiB8IGluaGVyaXRcIixcbiAgICAgICAgICAgIHNsYXNoICAgPSBmYWxzZSxcbiAgICAgICAgICAgIGNvdW50ICAgPSAwLFxuICAgICAgICAgICAgbWF4ICAgICA9IDgsXG4gICAgICAgICAgICBwYXJ0O1xuXG4gICAgICAgIHdoaWxlIChleHByZXNzaW9uLmhhc05leHQoKSAmJiBjb3VudCA8IG1heCkge1xuICAgICAgICAgICAgdmFsaWQgPSBWYWxpZGF0aW9uVHlwZXMuaXNBbnkoZXhwcmVzc2lvbiwgc2ltcGxlKTtcbiAgICAgICAgICAgIGlmICghdmFsaWQpIHtcblxuICAgICAgICAgICAgICAgIGlmIChTdHJpbmcoZXhwcmVzc2lvbi5wZWVrKCkpID09PSBcIi9cIiAmJiBjb3VudCA+IDAgJiYgIXNsYXNoKSB7XG4gICAgICAgICAgICAgICAgICAgIHNsYXNoID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgbWF4ID0gY291bnQgKyA1O1xuICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uLm5leHQoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb3VudCsrO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGV4cHJlc3Npb24uaGFzTmV4dCgpKSB7XG4gICAgICAgICAgICBwYXJ0ID0gZXhwcmVzc2lvbi5uZXh0KCk7XG4gICAgICAgICAgICBpZiAodmFsaWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKFwiRXhwZWN0ZWQgZW5kIG9mIHZhbHVlIGJ1dCBmb3VuZCAnXCIgKyBwYXJ0ICsgXCInLlwiLCBwYXJ0LmxpbmUsIHBhcnQuY29sKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcihcIkV4cGVjdGVkICg8J2JvcmRlci1yYWRpdXMnPikgYnV0IGZvdW5kICdcIiArIHBhcnQgKyBcIicuXCIsIHBhcnQubGluZSwgcGFydC5jb2wpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbiAgICBcImJvcmRlci1yaWdodFwiICAgICAgICAgICAgICAgICAgOiBcIjxib3JkZXItd2lkdGg+IHx8IDxib3JkZXItc3R5bGU+IHx8IDxjb2xvcj5cIixcbiAgICBcImJvcmRlci1yaWdodC1jb2xvclwiICAgICAgICAgICAgOiBcIjxjb2xvcj4gfCBpbmhlcml0XCIsXG4gICAgXCJib3JkZXItcmlnaHQtc3R5bGVcIiAgICAgICAgICAgIDogXCI8Ym9yZGVyLXN0eWxlPlwiLFxuICAgIFwiYm9yZGVyLXJpZ2h0LXdpZHRoXCIgICAgICAgICAgICA6IFwiPGJvcmRlci13aWR0aD5cIixcbiAgICBcImJvcmRlci1zcGFjaW5nXCIgICAgICAgICAgICAgICAgOiB7IG11bHRpOiBcIjxsZW5ndGg+IHwgaW5oZXJpdFwiLCBtYXg6IDIgfSxcbiAgICBcImJvcmRlci1zdHlsZVwiICAgICAgICAgICAgICAgICAgOiB7IG11bHRpOiBcIjxib3JkZXItc3R5bGU+XCIsIG1heDogNCB9LFxuICAgIFwiYm9yZGVyLXRvcFwiICAgICAgICAgICAgICAgICAgICA6IFwiPGJvcmRlci13aWR0aD4gfHwgPGJvcmRlci1zdHlsZT4gfHwgPGNvbG9yPlwiLFxuICAgIFwiYm9yZGVyLXRvcC1jb2xvclwiICAgICAgICAgICAgICA6IFwiPGNvbG9yPiB8IGluaGVyaXRcIixcbiAgICBcImJvcmRlci10b3AtbGVmdC1yYWRpdXNcIiAgICAgICAgOiBcIjx4LW9uZS1yYWRpdXM+XCIsXG4gICAgXCJib3JkZXItdG9wLXJpZ2h0LXJhZGl1c1wiICAgICAgIDogXCI8eC1vbmUtcmFkaXVzPlwiLFxuICAgIFwiYm9yZGVyLXRvcC1zdHlsZVwiICAgICAgICAgICAgICA6IFwiPGJvcmRlci1zdHlsZT5cIixcbiAgICBcImJvcmRlci10b3Atd2lkdGhcIiAgICAgICAgICAgICAgOiBcIjxib3JkZXItd2lkdGg+XCIsXG4gICAgXCJib3JkZXItd2lkdGhcIiAgICAgICAgICAgICAgICAgIDogeyBtdWx0aTogXCI8Ym9yZGVyLXdpZHRoPlwiLCBtYXg6IDQgfSxcbiAgICBcImJvdHRvbVwiICAgICAgICAgICAgICAgICAgICAgICAgOiBcIjxtYXJnaW4td2lkdGg+IHwgaW5oZXJpdFwiLFxuICAgIFwiLW1vei1ib3gtYWxpZ25cIiAgICAgICAgICAgICAgICA6IFwic3RhcnQgfCBlbmQgfCBjZW50ZXIgfCBiYXNlbGluZSB8IHN0cmV0Y2hcIixcbiAgICBcIi1tb3otYm94LWRlY29yYXRpb24tYnJlYWtcIiAgICAgOiBcInNsaWNlIHxjbG9uZVwiLFxuICAgIFwiLW1vei1ib3gtZGlyZWN0aW9uXCIgICAgICAgICAgICA6IFwibm9ybWFsIHwgcmV2ZXJzZSB8IGluaGVyaXRcIixcbiAgICBcIi1tb3otYm94LWZsZXhcIiAgICAgICAgICAgICAgICAgOiBcIjxudW1iZXI+XCIsXG4gICAgXCItbW96LWJveC1mbGV4LWdyb3VwXCIgICAgICAgICAgIDogXCI8aW50ZWdlcj5cIixcbiAgICBcIi1tb3otYm94LWxpbmVzXCIgICAgICAgICAgICAgICAgOiBcInNpbmdsZSB8IG11bHRpcGxlXCIsXG4gICAgXCItbW96LWJveC1vcmRpbmFsLWdyb3VwXCIgICAgICAgIDogXCI8aW50ZWdlcj5cIixcbiAgICBcIi1tb3otYm94LW9yaWVudFwiICAgICAgICAgICAgICAgOiBcImhvcml6b250YWwgfCB2ZXJ0aWNhbCB8IGlubGluZS1heGlzIHwgYmxvY2stYXhpcyB8IGluaGVyaXRcIixcbiAgICBcIi1tb3otYm94LXBhY2tcIiAgICAgICAgICAgICAgICAgOiBcInN0YXJ0IHwgZW5kIHwgY2VudGVyIHwganVzdGlmeVwiLFxuICAgIFwiLW8tYm94LWRlY29yYXRpb24tYnJlYWtcIiAgICAgICA6IFwic2xpY2UgfCBjbG9uZVwiLFxuICAgIFwiLXdlYmtpdC1ib3gtYWxpZ25cIiAgICAgICAgICAgICA6IFwic3RhcnQgfCBlbmQgfCBjZW50ZXIgfCBiYXNlbGluZSB8IHN0cmV0Y2hcIixcbiAgICBcIi13ZWJraXQtYm94LWRlY29yYXRpb24tYnJlYWtcIiAgOiBcInNsaWNlIHxjbG9uZVwiLFxuICAgIFwiLXdlYmtpdC1ib3gtZGlyZWN0aW9uXCIgICAgICAgICA6IFwibm9ybWFsIHwgcmV2ZXJzZSB8IGluaGVyaXRcIixcbiAgICBcIi13ZWJraXQtYm94LWZsZXhcIiAgICAgICAgICAgICAgOiBcIjxudW1iZXI+XCIsXG4gICAgXCItd2Via2l0LWJveC1mbGV4LWdyb3VwXCIgICAgICAgIDogXCI8aW50ZWdlcj5cIixcbiAgICBcIi13ZWJraXQtYm94LWxpbmVzXCIgICAgICAgICAgICAgOiBcInNpbmdsZSB8IG11bHRpcGxlXCIsXG4gICAgXCItd2Via2l0LWJveC1vcmRpbmFsLWdyb3VwXCIgICAgIDogXCI8aW50ZWdlcj5cIixcbiAgICBcIi13ZWJraXQtYm94LW9yaWVudFwiICAgICAgICAgICAgOiBcImhvcml6b250YWwgfCB2ZXJ0aWNhbCB8IGlubGluZS1heGlzIHwgYmxvY2stYXhpcyB8IGluaGVyaXRcIixcbiAgICBcIi13ZWJraXQtYm94LXBhY2tcIiAgICAgICAgICAgICAgOiBcInN0YXJ0IHwgZW5kIHwgY2VudGVyIHwganVzdGlmeVwiLFxuICAgIFwiYm94LWRlY29yYXRpb24tYnJlYWtcIiAgICAgICAgICA6IFwic2xpY2UgfCBjbG9uZVwiLFxuICAgIFwiYm94LXNoYWRvd1wiICAgICAgICAgICAgICAgICAgICA6IGZ1bmN0aW9uIChleHByZXNzaW9uKSB7XG4gICAgICAgIHZhciBwYXJ0O1xuXG4gICAgICAgIGlmICghVmFsaWRhdGlvblR5cGVzLmlzQW55KGV4cHJlc3Npb24sIFwibm9uZVwiKSkge1xuICAgICAgICAgICAgVmFsaWRhdGlvbi5tdWx0aVByb3BlcnR5KFwiPHNoYWRvdz5cIiwgZXhwcmVzc2lvbiwgdHJ1ZSwgSW5maW5pdHkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGV4cHJlc3Npb24uaGFzTmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgcGFydCA9IGV4cHJlc3Npb24ubmV4dCgpO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBWYWxpZGF0aW9uRXJyb3IoXCJFeHBlY3RlZCBlbmQgb2YgdmFsdWUgYnV0IGZvdW5kICdcIiArIHBhcnQgKyBcIicuXCIsIHBhcnQubGluZSwgcGFydC5jb2wpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbiAgICBcImJveC1zaXppbmdcIiAgICAgICAgICAgICAgICAgICAgOiBcImNvbnRlbnQtYm94IHwgYm9yZGVyLWJveCB8IGluaGVyaXRcIixcbiAgICBcImJyZWFrLWFmdGVyXCIgICAgICAgICAgICAgICAgICAgOiBcImF1dG8gfCBhbHdheXMgfCBhdm9pZCB8IGxlZnQgfCByaWdodCB8IHBhZ2UgfCBjb2x1bW4gfCBhdm9pZC1wYWdlIHwgYXZvaWQtY29sdW1uXCIsXG4gICAgXCJicmVhay1iZWZvcmVcIiAgICAgICAgICAgICAgICAgIDogXCJhdXRvIHwgYWx3YXlzIHwgYXZvaWQgfCBsZWZ0IHwgcmlnaHQgfCBwYWdlIHwgY29sdW1uIHwgYXZvaWQtcGFnZSB8IGF2b2lkLWNvbHVtblwiLFxuICAgIFwiYnJlYWstaW5zaWRlXCIgICAgICAgICAgICAgICAgICA6IFwiYXV0byB8IGF2b2lkIHwgYXZvaWQtcGFnZSB8IGF2b2lkLWNvbHVtblwiLFxuXG4gICAgLy9DXG4gICAgXCJjYXB0aW9uLXNpZGVcIiAgICAgICAgICAgICAgICAgIDogXCJ0b3AgfCBib3R0b20gfCBpbmhlcml0XCIsXG4gICAgXCJjbGVhclwiICAgICAgICAgICAgICAgICAgICAgICAgIDogXCJub25lIHwgcmlnaHQgfCBsZWZ0IHwgYm90aCB8IGluaGVyaXRcIixcbiAgICBcImNsaXBcIiAgICAgICAgICAgICAgICAgICAgICAgICAgOiAxLFxuICAgIFwiY29sb3JcIiAgICAgICAgICAgICAgICAgICAgICAgICA6IFwiPGNvbG9yPiB8IGluaGVyaXRcIixcbiAgICBcImNvbG9yLXByb2ZpbGVcIiAgICAgICAgICAgICAgICAgOiAxLFxuICAgIFwiY29sdW1uLWNvdW50XCIgICAgICAgICAgICAgICAgICA6IFwiPGludGVnZXI+IHwgYXV0b1wiLCAgICAgICAgICAgICAgICAgICAgICAvL2h0dHA6Ly93d3cudzMub3JnL1RSL2NzczMtbXVsdGljb2wvXG4gICAgXCJjb2x1bW4tZmlsbFwiICAgICAgICAgICAgICAgICAgIDogXCJhdXRvIHwgYmFsYW5jZVwiLFxuICAgIFwiY29sdW1uLWdhcFwiICAgICAgICAgICAgICAgICAgICA6IFwiPGxlbmd0aD4gfCBub3JtYWxcIixcbiAgICBcImNvbHVtbi1ydWxlXCIgICAgICAgICAgICAgICAgICAgOiBcIjxib3JkZXItd2lkdGg+IHx8IDxib3JkZXItc3R5bGU+IHx8IDxjb2xvcj5cIixcbiAgICBcImNvbHVtbi1ydWxlLWNvbG9yXCIgICAgICAgICAgICAgOiBcIjxjb2xvcj5cIixcbiAgICBcImNvbHVtbi1ydWxlLXN0eWxlXCIgICAgICAgICAgICAgOiBcIjxib3JkZXItc3R5bGU+XCIsXG4gICAgXCJjb2x1bW4tcnVsZS13aWR0aFwiICAgICAgICAgICAgIDogXCI8Ym9yZGVyLXdpZHRoPlwiLFxuICAgIFwiY29sdW1uLXNwYW5cIiAgICAgICAgICAgICAgICAgICA6IFwibm9uZSB8IGFsbFwiLFxuICAgIFwiY29sdW1uLXdpZHRoXCIgICAgICAgICAgICAgICAgICA6IFwiPGxlbmd0aD4gfCBhdXRvXCIsXG4gICAgXCJjb2x1bW5zXCIgICAgICAgICAgICAgICAgICAgICAgIDogMSxcbiAgICBcImNvbnRlbnRcIiAgICAgICAgICAgICAgICAgICAgICAgOiAxLFxuICAgIFwiY291bnRlci1pbmNyZW1lbnRcIiAgICAgICAgICAgICA6IDEsXG4gICAgXCJjb3VudGVyLXJlc2V0XCIgICAgICAgICAgICAgICAgIDogMSxcbiAgICBcImNyb3BcIiAgICAgICAgICAgICAgICAgICAgICAgICAgOiBcIjxzaGFwZT4gfCBhdXRvXCIsXG4gICAgXCJjdWVcIiAgICAgICAgICAgICAgICAgICAgICAgICAgIDogXCJjdWUtYWZ0ZXIgfCBjdWUtYmVmb3JlIHwgaW5oZXJpdFwiLFxuICAgIFwiY3VlLWFmdGVyXCIgICAgICAgICAgICAgICAgICAgICA6IDEsXG4gICAgXCJjdWUtYmVmb3JlXCIgICAgICAgICAgICAgICAgICAgIDogMSxcbiAgICBcImN1cnNvclwiICAgICAgICAgICAgICAgICAgICAgICAgOiAxLFxuXG4gICAgLy9EXG4gICAgXCJkaXJlY3Rpb25cIiAgICAgICAgICAgICAgICAgICAgIDogXCJsdHIgfCBydGwgfCBpbmhlcml0XCIsXG4gICAgXCJkaXNwbGF5XCIgICAgICAgICAgICAgICAgICAgICAgIDogXCJpbmxpbmUgfCBibG9jayB8IGxpc3QtaXRlbSB8IGlubGluZS1ibG9jayB8IHRhYmxlIHwgaW5saW5lLXRhYmxlIHwgdGFibGUtcm93LWdyb3VwIHwgdGFibGUtaGVhZGVyLWdyb3VwIHwgdGFibGUtZm9vdGVyLWdyb3VwIHwgdGFibGUtcm93IHwgdGFibGUtY29sdW1uLWdyb3VwIHwgdGFibGUtY29sdW1uIHwgdGFibGUtY2VsbCB8IHRhYmxlLWNhcHRpb24gfCBncmlkIHwgaW5saW5lLWdyaWQgfCBydW4taW4gfCBydWJ5IHwgcnVieS1iYXNlIHwgcnVieS10ZXh0IHwgcnVieS1iYXNlLWNvbnRhaW5lciB8IHJ1YnktdGV4dC1jb250YWluZXIgfCBjb250ZW50cyB8IG5vbmUgfCBpbmhlcml0IHwgLW1vei1ib3ggfCAtbW96LWlubGluZS1ibG9jayB8IC1tb3otaW5saW5lLWJveCB8IC1tb3otaW5saW5lLWdyaWQgfCAtbW96LWlubGluZS1zdGFjayB8IC1tb3otaW5saW5lLXRhYmxlIHwgLW1vei1ncmlkIHwgLW1vei1ncmlkLWdyb3VwIHwgLW1vei1ncmlkLWxpbmUgfCAtbW96LWdyb3VwYm94IHwgLW1vei1kZWNrIHwgLW1vei1wb3B1cCB8IC1tb3otc3RhY2sgfCAtbW96LW1hcmtlciB8IC13ZWJraXQtYm94IHwgLXdlYmtpdC1pbmxpbmUtYm94IHwgLW1zLWZsZXhib3ggfCAtbXMtaW5saW5lLWZsZXhib3ggfCBmbGV4IHwgLXdlYmtpdC1mbGV4IHwgaW5saW5lLWZsZXggfCAtd2Via2l0LWlubGluZS1mbGV4XCIsXG4gICAgXCJkb21pbmFudC1iYXNlbGluZVwiICAgICAgICAgICAgIDogMSxcbiAgICBcImRyb3AtaW5pdGlhbC1hZnRlci1hZGp1c3RcIiAgICAgOiBcImNlbnRyYWwgfCBtaWRkbGUgfCBhZnRlci1lZGdlIHwgdGV4dC1hZnRlci1lZGdlIHwgaWRlb2dyYXBoaWMgfCBhbHBoYWJldGljIHwgbWF0aGVtYXRpY2FsIHwgPHBlcmNlbnRhZ2U+IHwgPGxlbmd0aD5cIixcbiAgICBcImRyb3AtaW5pdGlhbC1hZnRlci1hbGlnblwiICAgICAgOiBcImJhc2VsaW5lIHwgdXNlLXNjcmlwdCB8IGJlZm9yZS1lZGdlIHwgdGV4dC1iZWZvcmUtZWRnZSB8IGFmdGVyLWVkZ2UgfCB0ZXh0LWFmdGVyLWVkZ2UgfCBjZW50cmFsIHwgbWlkZGxlIHwgaWRlb2dyYXBoaWMgfCBhbHBoYWJldGljIHwgaGFuZ2luZyB8IG1hdGhlbWF0aWNhbFwiLFxuICAgIFwiZHJvcC1pbml0aWFsLWJlZm9yZS1hZGp1c3RcIiAgICA6IFwiYmVmb3JlLWVkZ2UgfCB0ZXh0LWJlZm9yZS1lZGdlIHwgY2VudHJhbCB8IG1pZGRsZSB8IGhhbmdpbmcgfCBtYXRoZW1hdGljYWwgfCA8cGVyY2VudGFnZT4gfCA8bGVuZ3RoPlwiLFxuICAgIFwiZHJvcC1pbml0aWFsLWJlZm9yZS1hbGlnblwiICAgICA6IFwiY2Fwcy1oZWlnaHQgfCBiYXNlbGluZSB8IHVzZS1zY3JpcHQgfCBiZWZvcmUtZWRnZSB8IHRleHQtYmVmb3JlLWVkZ2UgfCBhZnRlci1lZGdlIHwgdGV4dC1hZnRlci1lZGdlIHwgY2VudHJhbCB8IG1pZGRsZSB8IGlkZW9ncmFwaGljIHwgYWxwaGFiZXRpYyB8IGhhbmdpbmcgfCBtYXRoZW1hdGljYWxcIixcbiAgICBcImRyb3AtaW5pdGlhbC1zaXplXCIgICAgICAgICAgICAgOiBcImF1dG8gfCBsaW5lIHwgPGxlbmd0aD4gfCA8cGVyY2VudGFnZT5cIixcbiAgICBcImRyb3AtaW5pdGlhbC12YWx1ZVwiICAgICAgICAgICAgOiBcImluaXRpYWwgfCA8aW50ZWdlcj5cIixcblxuICAgIC8vRVxuICAgIFwiZWxldmF0aW9uXCIgICAgICAgICAgICAgICAgICAgICA6IFwiPGFuZ2xlPiB8IGJlbG93IHwgbGV2ZWwgfCBhYm92ZSB8IGhpZ2hlciB8IGxvd2VyIHwgaW5oZXJpdFwiLFxuICAgIFwiZW1wdHktY2VsbHNcIiAgICAgICAgICAgICAgICAgICA6IFwic2hvdyB8IGhpZGUgfCBpbmhlcml0XCIsXG5cbiAgICAvL0ZcbiAgICBcImZpbHRlclwiICAgICAgICAgICAgICAgICAgICAgICAgOiAxLFxuICAgIFwiZml0XCIgICAgICAgICAgICAgICAgICAgICAgICAgICA6IFwiZmlsbCB8IGhpZGRlbiB8IG1lZXQgfCBzbGljZVwiLFxuICAgIFwiZml0LXBvc2l0aW9uXCIgICAgICAgICAgICAgICAgICA6IDEsXG4gICAgXCJmbGV4XCIgICAgICAgICAgICAgICAgICAgICAgICAgIDogXCI8ZmxleD5cIixcbiAgICBcImZsZXgtYmFzaXNcIiAgICAgICAgICAgICAgICAgICAgOiBcIjx3aWR0aD5cIixcbiAgICBcImZsZXgtZGlyZWN0aW9uXCIgICAgICAgICAgICAgICAgOiBcInJvdyB8IHJvdy1yZXZlcnNlIHwgY29sdW1uIHwgY29sdW1uLXJldmVyc2VcIixcbiAgICBcImZsZXgtZmxvd1wiICAgICAgICAgICAgICAgICAgICAgOiBcIjxmbGV4LWRpcmVjdGlvbj4gfHwgPGZsZXgtd3JhcD5cIixcbiAgICBcImZsZXgtZ3Jvd1wiICAgICAgICAgICAgICAgICAgICAgOiBcIjxudW1iZXI+XCIsXG4gICAgXCJmbGV4LXNocmlua1wiICAgICAgICAgICAgICAgICAgIDogXCI8bnVtYmVyPlwiLFxuICAgIFwiZmxleC13cmFwXCIgICAgICAgICAgICAgICAgICAgICA6IFwibm93cmFwIHwgd3JhcCB8IHdyYXAtcmV2ZXJzZVwiLFxuICAgIFwiLXdlYmtpdC1mbGV4XCIgICAgICAgICAgICAgICAgICA6IFwiPGZsZXg+XCIsXG4gICAgXCItd2Via2l0LWZsZXgtYmFzaXNcIiAgICAgICAgICAgIDogXCI8d2lkdGg+XCIsXG4gICAgXCItd2Via2l0LWZsZXgtZGlyZWN0aW9uXCIgICAgICAgIDogXCJyb3cgfCByb3ctcmV2ZXJzZSB8IGNvbHVtbiB8IGNvbHVtbi1yZXZlcnNlXCIsXG4gICAgXCItd2Via2l0LWZsZXgtZmxvd1wiICAgICAgICAgICAgIDogXCI8ZmxleC1kaXJlY3Rpb24+IHx8IDxmbGV4LXdyYXA+XCIsXG4gICAgXCItd2Via2l0LWZsZXgtZ3Jvd1wiICAgICAgICAgICAgIDogXCI8bnVtYmVyPlwiLFxuICAgIFwiLXdlYmtpdC1mbGV4LXNocmlua1wiICAgICAgICAgICA6IFwiPG51bWJlcj5cIixcbiAgICBcIi13ZWJraXQtZmxleC13cmFwXCIgICAgICAgICAgICAgOiBcIm5vd3JhcCB8IHdyYXAgfCB3cmFwLXJldmVyc2VcIixcbiAgICBcIi1tcy1mbGV4XCIgICAgICAgICAgICAgICAgICAgICAgOiBcIjxmbGV4PlwiLFxuICAgIFwiLW1zLWZsZXgtYWxpZ25cIiAgICAgICAgICAgICAgICA6IFwic3RhcnQgfCBlbmQgfCBjZW50ZXIgfCBzdHJldGNoIHwgYmFzZWxpbmVcIixcbiAgICBcIi1tcy1mbGV4LWRpcmVjdGlvblwiICAgICAgICAgICAgOiBcInJvdyB8IHJvdy1yZXZlcnNlIHwgY29sdW1uIHwgY29sdW1uLXJldmVyc2UgfCBpbmhlcml0XCIsXG4gICAgXCItbXMtZmxleC1vcmRlclwiICAgICAgICAgICAgICAgIDogXCI8bnVtYmVyPlwiLFxuICAgIFwiLW1zLWZsZXgtcGFja1wiICAgICAgICAgICAgICAgICA6IFwic3RhcnQgfCBlbmQgfCBjZW50ZXIgfCBqdXN0aWZ5XCIsXG4gICAgXCItbXMtZmxleC13cmFwXCIgICAgICAgICAgICAgICAgIDogXCJub3dyYXAgfCB3cmFwIHwgd3JhcC1yZXZlcnNlXCIsXG4gICAgXCJmbG9hdFwiICAgICAgICAgICAgICAgICAgICAgICAgIDogXCJsZWZ0IHwgcmlnaHQgfCBub25lIHwgaW5oZXJpdFwiLFxuICAgIFwiZmxvYXQtb2Zmc2V0XCIgICAgICAgICAgICAgICAgICA6IDEsXG4gICAgXCJmb250XCIgICAgICAgICAgICAgICAgICAgICAgICAgIDogMSxcbiAgICBcImZvbnQtZmFtaWx5XCIgICAgICAgICAgICAgICAgICAgOiAxLFxuICAgIFwiZm9udC1mZWF0dXJlLXNldHRpbmdzXCIgICAgICAgICA6IFwiPGZlYXR1cmUtdGFnLXZhbHVlPiB8IG5vcm1hbCB8IGluaGVyaXRcIixcbiAgICBcImZvbnQta2VybmluZ1wiICAgICAgICAgICAgICAgICAgOiBcImF1dG8gfCBub3JtYWwgfCBub25lIHwgaW5pdGlhbCB8IGluaGVyaXQgfCB1bnNldFwiLFxuICAgIFwiZm9udC1zaXplXCIgICAgICAgICAgICAgICAgICAgICA6IFwiPGFic29sdXRlLXNpemU+IHwgPHJlbGF0aXZlLXNpemU+IHwgPGxlbmd0aD4gfCA8cGVyY2VudGFnZT4gfCBpbmhlcml0XCIsXG4gICAgXCJmb250LXNpemUtYWRqdXN0XCIgICAgICAgICAgICAgIDogXCI8bnVtYmVyPiB8IG5vbmUgfCBpbmhlcml0XCIsXG4gICAgXCJmb250LXN0cmV0Y2hcIiAgICAgICAgICAgICAgICAgIDogXCJub3JtYWwgfCB1bHRyYS1jb25kZW5zZWQgfCBleHRyYS1jb25kZW5zZWQgfCBjb25kZW5zZWQgfCBzZW1pLWNvbmRlbnNlZCB8IHNlbWktZXhwYW5kZWQgfCBleHBhbmRlZCB8IGV4dHJhLWV4cGFuZGVkIHwgdWx0cmEtZXhwYW5kZWQgfCBpbmhlcml0XCIsXG4gICAgXCJmb250LXN0eWxlXCIgICAgICAgICAgICAgICAgICAgIDogXCJub3JtYWwgfCBpdGFsaWMgfCBvYmxpcXVlIHwgaW5oZXJpdFwiLFxuICAgIFwiZm9udC12YXJpYW50XCIgICAgICAgICAgICAgICAgICA6IFwibm9ybWFsIHwgc21hbGwtY2FwcyB8IGluaGVyaXRcIixcbiAgICBcImZvbnQtdmFyaWFudC1jYXBzXCIgICAgICAgICAgICAgOiBcIm5vcm1hbCB8IHNtYWxsLWNhcHMgfCBhbGwtc21hbGwtY2FwcyB8IHBldGl0ZS1jYXBzIHwgYWxsLXBldGl0ZS1jYXBzIHwgdW5pY2FzZSB8IHRpdGxpbmctY2Fwc1wiLFxuICAgIFwiZm9udC12YXJpYW50LXBvc2l0aW9uXCIgICAgICAgICA6IFwibm9ybWFsIHwgc3ViIHwgc3VwZXIgfCBpbmhlcml0IHwgaW5pdGlhbCB8IHVuc2V0XCIsXG4gICAgXCJmb250LXdlaWdodFwiICAgICAgICAgICAgICAgICAgIDogXCJub3JtYWwgfCBib2xkIHwgYm9sZGVyIHwgbGlnaHRlciB8IDEwMCB8IDIwMCB8IDMwMCB8IDQwMCB8IDUwMCB8IDYwMCB8IDcwMCB8IDgwMCB8IDkwMCB8IGluaGVyaXRcIixcblxuICAgIC8vR1xuICAgIFwiZ3JpZFwiICAgICAgICAgICAgICAgICAgICAgICAgICA6IDEsXG4gICAgXCJncmlkLWFyZWFcIiAgICAgICAgICAgICAgICAgICAgIDogMSxcbiAgICBcImdyaWQtYXV0by1jb2x1bW5zXCIgICAgICAgICAgICAgOiAxLFxuICAgIFwiZ3JpZC1hdXRvLWZsb3dcIiAgICAgICAgICAgICAgICA6IDEsXG4gICAgXCJncmlkLWF1dG8tcG9zaXRpb25cIiAgICAgICAgICAgIDogMSxcbiAgICBcImdyaWQtYXV0by1yb3dzXCIgICAgICAgICAgICAgICAgOiAxLFxuICAgIFwiZ3JpZC1jZWxsLXN0YWNraW5nXCIgICAgICAgICAgICA6IFwiY29sdW1ucyB8IHJvd3MgfCBsYXllclwiLFxuICAgIFwiZ3JpZC1jb2x1bW5cIiAgICAgICAgICAgICAgICAgICA6IDEsXG4gICAgXCJncmlkLWNvbHVtbnNcIiAgICAgICAgICAgICAgICAgIDogMSxcbiAgICBcImdyaWQtY29sdW1uLWFsaWduXCIgICAgICAgICAgICAgOiBcInN0YXJ0IHwgZW5kIHwgY2VudGVyIHwgc3RyZXRjaFwiLFxuICAgIFwiZ3JpZC1jb2x1bW4tc2l6aW5nXCIgICAgICAgICAgICA6IDEsXG4gICAgXCJncmlkLWNvbHVtbi1zdGFydFwiICAgICAgICAgICAgIDogMSxcbiAgICBcImdyaWQtY29sdW1uLWVuZFwiICAgICAgICAgICAgICAgOiAxLFxuICAgIFwiZ3JpZC1jb2x1bW4tc3BhblwiICAgICAgICAgICAgICA6IFwiPGludGVnZXI+XCIsXG4gICAgXCJncmlkLWZsb3dcIiAgICAgICAgICAgICAgICAgICAgIDogXCJub25lIHwgcm93cyB8IGNvbHVtbnNcIixcbiAgICBcImdyaWQtbGF5ZXJcIiAgICAgICAgICAgICAgICAgICAgOiBcIjxpbnRlZ2VyPlwiLFxuICAgIFwiZ3JpZC1yb3dcIiAgICAgICAgICAgICAgICAgICAgICA6IDEsXG4gICAgXCJncmlkLXJvd3NcIiAgICAgICAgICAgICAgICAgICAgIDogMSxcbiAgICBcImdyaWQtcm93LWFsaWduXCIgICAgICAgICAgICAgICAgOiBcInN0YXJ0IHwgZW5kIHwgY2VudGVyIHwgc3RyZXRjaFwiLFxuICAgIFwiZ3JpZC1yb3ctc3RhcnRcIiAgICAgICAgICAgICAgICA6IDEsXG4gICAgXCJncmlkLXJvdy1lbmRcIiAgICAgICAgICAgICAgICAgIDogMSxcbiAgICBcImdyaWQtcm93LXNwYW5cIiAgICAgICAgICAgICAgICAgOiBcIjxpbnRlZ2VyPlwiLFxuICAgIFwiZ3JpZC1yb3ctc2l6aW5nXCIgICAgICAgICAgICAgICA6IDEsXG4gICAgXCJncmlkLXRlbXBsYXRlXCIgICAgICAgICAgICAgICAgIDogMSxcbiAgICBcImdyaWQtdGVtcGxhdGUtYXJlYXNcIiAgICAgICAgICAgOiAxLFxuICAgIFwiZ3JpZC10ZW1wbGF0ZS1jb2x1bW5zXCIgICAgICAgICA6IDEsXG4gICAgXCJncmlkLXRlbXBsYXRlLXJvd3NcIiAgICAgICAgICAgIDogMSxcblxuICAgIC8vSFxuICAgIFwiaGFuZ2luZy1wdW5jdHVhdGlvblwiICAgICAgICAgICA6IDEsXG4gICAgXCJoZWlnaHRcIiAgICAgICAgICAgICAgICAgICAgICAgIDogXCI8bWFyZ2luLXdpZHRoPiB8IDxjb250ZW50LXNpemluZz4gfCBpbmhlcml0XCIsXG4gICAgXCJoeXBoZW5hdGUtYWZ0ZXJcIiAgICAgICAgICAgICAgIDogXCI8aW50ZWdlcj4gfCBhdXRvXCIsXG4gICAgXCJoeXBoZW5hdGUtYmVmb3JlXCIgICAgICAgICAgICAgIDogXCI8aW50ZWdlcj4gfCBhdXRvXCIsXG4gICAgXCJoeXBoZW5hdGUtY2hhcmFjdGVyXCIgICAgICAgICAgIDogXCI8c3RyaW5nPiB8IGF1dG9cIixcbiAgICBcImh5cGhlbmF0ZS1saW5lc1wiICAgICAgICAgICAgICAgOiBcIm5vLWxpbWl0IHwgPGludGVnZXI+XCIsXG4gICAgXCJoeXBoZW5hdGUtcmVzb3VyY2VcIiAgICAgICAgICAgIDogMSxcbiAgICBcImh5cGhlbnNcIiAgICAgICAgICAgICAgICAgICAgICAgOiBcIm5vbmUgfCBtYW51YWwgfCBhdXRvXCIsXG5cbiAgICAvL0lcbiAgICBcImljb25cIiAgICAgICAgICAgICAgICAgICAgICAgICAgOiAxLFxuICAgIFwiaW1hZ2Utb3JpZW50YXRpb25cIiAgICAgICAgICAgICA6IFwiYW5nbGUgfCBhdXRvXCIsXG4gICAgXCJpbWFnZS1yZW5kZXJpbmdcIiAgICAgICAgICAgICAgIDogMSxcbiAgICBcImltYWdlLXJlc29sdXRpb25cIiAgICAgICAgICAgICAgOiAxLFxuICAgIFwiaW1lLW1vZGVcIiAgICAgICAgICAgICAgICAgICAgICA6IFwiYXV0byB8IG5vcm1hbCB8IGFjdGl2ZSB8IGluYWN0aXZlIHwgZGlzYWJsZWQgfCBpbmhlcml0XCIsXG4gICAgXCJpbmxpbmUtYm94LWFsaWduXCIgICAgICAgICAgICAgIDogXCJpbml0aWFsIHwgbGFzdCB8IDxpbnRlZ2VyPlwiLFxuXG4gICAgLy9KXG4gICAgXCJqdXN0aWZ5LWNvbnRlbnRcIiAgICAgICAgICAgICAgIDogXCJmbGV4LXN0YXJ0IHwgZmxleC1lbmQgfCBjZW50ZXIgfCBzcGFjZS1iZXR3ZWVuIHwgc3BhY2UtYXJvdW5kXCIsXG4gICAgXCItd2Via2l0LWp1c3RpZnktY29udGVudFwiICAgICAgIDogXCJmbGV4LXN0YXJ0IHwgZmxleC1lbmQgfCBjZW50ZXIgfCBzcGFjZS1iZXR3ZWVuIHwgc3BhY2UtYXJvdW5kXCIsXG5cbiAgICAvL0xcbiAgICBcImxlZnRcIiAgICAgICAgICAgICAgICAgICAgICAgICAgOiBcIjxtYXJnaW4td2lkdGg+IHwgaW5oZXJpdFwiLFxuICAgIFwibGV0dGVyLXNwYWNpbmdcIiAgICAgICAgICAgICAgICA6IFwiPGxlbmd0aD4gfCBub3JtYWwgfCBpbmhlcml0XCIsXG4gICAgXCJsaW5lLWhlaWdodFwiICAgICAgICAgICAgICAgICAgIDogXCI8bnVtYmVyPiB8IDxsZW5ndGg+IHwgPHBlcmNlbnRhZ2U+IHwgbm9ybWFsIHwgaW5oZXJpdFwiLFxuICAgIFwibGluZS1icmVha1wiICAgICAgICAgICAgICAgICAgICA6IFwiYXV0byB8IGxvb3NlIHwgbm9ybWFsIHwgc3RyaWN0XCIsXG4gICAgXCJsaW5lLXN0YWNraW5nXCIgICAgICAgICAgICAgICAgIDogMSxcbiAgICBcImxpbmUtc3RhY2tpbmctcnVieVwiICAgICAgICAgICAgOiBcImV4Y2x1ZGUtcnVieSB8IGluY2x1ZGUtcnVieVwiLFxuICAgIFwibGluZS1zdGFja2luZy1zaGlmdFwiICAgICAgICAgICA6IFwiY29uc2lkZXItc2hpZnRzIHwgZGlzcmVnYXJkLXNoaWZ0c1wiLFxuICAgIFwibGluZS1zdGFja2luZy1zdHJhdGVneVwiICAgICAgICA6IFwiaW5saW5lLWxpbmUtaGVpZ2h0IHwgYmxvY2stbGluZS1oZWlnaHQgfCBtYXgtaGVpZ2h0IHwgZ3JpZC1oZWlnaHRcIixcbiAgICBcImxpc3Qtc3R5bGVcIiAgICAgICAgICAgICAgICAgICAgOiAxLFxuICAgIFwibGlzdC1zdHlsZS1pbWFnZVwiICAgICAgICAgICAgICA6IFwiPHVyaT4gfCBub25lIHwgaW5oZXJpdFwiLFxuICAgIFwibGlzdC1zdHlsZS1wb3NpdGlvblwiICAgICAgICAgICA6IFwiaW5zaWRlIHwgb3V0c2lkZSB8IGluaGVyaXRcIixcbiAgICBcImxpc3Qtc3R5bGUtdHlwZVwiICAgICAgICAgICAgICAgOiBcImRpc2MgfCBjaXJjbGUgfCBzcXVhcmUgfCBkZWNpbWFsIHwgZGVjaW1hbC1sZWFkaW5nLXplcm8gfCBsb3dlci1yb21hbiB8IHVwcGVyLXJvbWFuIHwgbG93ZXItZ3JlZWsgfCBsb3dlci1sYXRpbiB8IHVwcGVyLWxhdGluIHwgYXJtZW5pYW4gfCBnZW9yZ2lhbiB8IGxvd2VyLWFscGhhIHwgdXBwZXItYWxwaGEgfCBub25lIHwgaW5oZXJpdFwiLFxuXG4gICAgLy9NXG4gICAgXCJtYXJnaW5cIiAgICAgICAgICAgICAgICAgICAgICAgIDogeyBtdWx0aTogXCI8bWFyZ2luLXdpZHRoPiB8IGluaGVyaXRcIiwgbWF4OiA0IH0sXG4gICAgXCJtYXJnaW4tYm90dG9tXCIgICAgICAgICAgICAgICAgIDogXCI8bWFyZ2luLXdpZHRoPiB8IGluaGVyaXRcIixcbiAgICBcIm1hcmdpbi1sZWZ0XCIgICAgICAgICAgICAgICAgICAgOiBcIjxtYXJnaW4td2lkdGg+IHwgaW5oZXJpdFwiLFxuICAgIFwibWFyZ2luLXJpZ2h0XCIgICAgICAgICAgICAgICAgICA6IFwiPG1hcmdpbi13aWR0aD4gfCBpbmhlcml0XCIsXG4gICAgXCJtYXJnaW4tdG9wXCIgICAgICAgICAgICAgICAgICAgIDogXCI8bWFyZ2luLXdpZHRoPiB8IGluaGVyaXRcIixcbiAgICBcIm1hcmtcIiAgICAgICAgICAgICAgICAgICAgICAgICAgOiAxLFxuICAgIFwibWFyay1hZnRlclwiICAgICAgICAgICAgICAgICAgICA6IDEsXG4gICAgXCJtYXJrLWJlZm9yZVwiICAgICAgICAgICAgICAgICAgIDogMSxcbiAgICBcIm1hcmtzXCIgICAgICAgICAgICAgICAgICAgICAgICAgOiAxLFxuICAgIFwibWFycXVlZS1kaXJlY3Rpb25cIiAgICAgICAgICAgICA6IDEsXG4gICAgXCJtYXJxdWVlLXBsYXktY291bnRcIiAgICAgICAgICAgIDogMSxcbiAgICBcIm1hcnF1ZWUtc3BlZWRcIiAgICAgICAgICAgICAgICAgOiAxLFxuICAgIFwibWFycXVlZS1zdHlsZVwiICAgICAgICAgICAgICAgICA6IDEsXG4gICAgXCJtYXgtaGVpZ2h0XCIgICAgICAgICAgICAgICAgICAgIDogXCI8bGVuZ3RoPiB8IDxwZXJjZW50YWdlPiB8IDxjb250ZW50LXNpemluZz4gfCBub25lIHwgaW5oZXJpdFwiLFxuICAgIFwibWF4LXdpZHRoXCIgICAgICAgICAgICAgICAgICAgICA6IFwiPGxlbmd0aD4gfCA8cGVyY2VudGFnZT4gfCA8Y29udGVudC1zaXppbmc+IHwgbm9uZSB8IGluaGVyaXRcIixcbiAgICBcIm1pbi1oZWlnaHRcIiAgICAgICAgICAgICAgICAgICAgOiBcIjxsZW5ndGg+IHwgPHBlcmNlbnRhZ2U+IHwgPGNvbnRlbnQtc2l6aW5nPiB8IGNvbnRhaW4tZmxvYXRzIHwgLW1vei1jb250YWluLWZsb2F0cyB8IC13ZWJraXQtY29udGFpbi1mbG9hdHMgfCBpbmhlcml0XCIsXG4gICAgXCJtaW4td2lkdGhcIiAgICAgICAgICAgICAgICAgICAgIDogXCI8bGVuZ3RoPiB8IDxwZXJjZW50YWdlPiB8IDxjb250ZW50LXNpemluZz4gfCBjb250YWluLWZsb2F0cyB8IC1tb3otY29udGFpbi1mbG9hdHMgfCAtd2Via2l0LWNvbnRhaW4tZmxvYXRzIHwgaW5oZXJpdFwiLFxuICAgIFwibW92ZS10b1wiICAgICAgICAgICAgICAgICAgICAgICA6IDEsXG5cbiAgICAvL05cbiAgICBcIm5hdi1kb3duXCIgICAgICAgICAgICAgICAgICAgICAgOiAxLFxuICAgIFwibmF2LWluZGV4XCIgICAgICAgICAgICAgICAgICAgICA6IDEsXG4gICAgXCJuYXYtbGVmdFwiICAgICAgICAgICAgICAgICAgICAgIDogMSxcbiAgICBcIm5hdi1yaWdodFwiICAgICAgICAgICAgICAgICAgICAgOiAxLFxuICAgIFwibmF2LXVwXCIgICAgICAgICAgICAgICAgICAgICAgICA6IDEsXG5cbiAgICAvL09cbiAgICBcIm9iamVjdC1maXRcIiAgICAgICAgICAgICAgICAgICAgOiBcImZpbGwgfCBjb250YWluIHwgY292ZXIgfCBub25lIHwgc2NhbGUtZG93blwiLFxuICAgIFwib2JqZWN0LXBvc2l0aW9uXCIgICAgICAgICAgICAgICA6IFwiPGJnLXBvc2l0aW9uPlwiLFxuICAgIFwib3BhY2l0eVwiICAgICAgICAgICAgICAgICAgICAgICA6IFwiPG51bWJlcj4gfCBpbmhlcml0XCIsXG4gICAgXCJvcmRlclwiICAgICAgICAgICAgICAgICAgICAgICAgIDogXCI8aW50ZWdlcj5cIixcbiAgICBcIi13ZWJraXQtb3JkZXJcIiAgICAgICAgICAgICAgICAgOiBcIjxpbnRlZ2VyPlwiLFxuICAgIFwib3JwaGFuc1wiICAgICAgICAgICAgICAgICAgICAgICA6IFwiPGludGVnZXI+IHwgaW5oZXJpdFwiLFxuICAgIFwib3V0bGluZVwiICAgICAgICAgICAgICAgICAgICAgICA6IDEsXG4gICAgXCJvdXRsaW5lLWNvbG9yXCIgICAgICAgICAgICAgICAgIDogXCI8Y29sb3I+IHwgaW52ZXJ0IHwgaW5oZXJpdFwiLFxuICAgIFwib3V0bGluZS1vZmZzZXRcIiAgICAgICAgICAgICAgICA6IDEsXG4gICAgXCJvdXRsaW5lLXN0eWxlXCIgICAgICAgICAgICAgICAgIDogXCI8Ym9yZGVyLXN0eWxlPiB8IGluaGVyaXRcIixcbiAgICBcIm91dGxpbmUtd2lkdGhcIiAgICAgICAgICAgICAgICAgOiBcIjxib3JkZXItd2lkdGg+IHwgaW5oZXJpdFwiLFxuICAgIFwib3ZlcmZsb3dcIiAgICAgICAgICAgICAgICAgICAgICA6IFwidmlzaWJsZSB8IGhpZGRlbiB8IHNjcm9sbCB8IGF1dG8gfCBpbmhlcml0XCIsXG4gICAgXCJvdmVyZmxvdy1zdHlsZVwiICAgICAgICAgICAgICAgIDogMSxcbiAgICBcIm92ZXJmbG93LXdyYXBcIiAgICAgICAgICAgICAgICAgOiBcIm5vcm1hbCB8IGJyZWFrLXdvcmRcIixcbiAgICBcIm92ZXJmbG93LXhcIiAgICAgICAgICAgICAgICAgICAgOiAxLFxuICAgIFwib3ZlcmZsb3cteVwiICAgICAgICAgICAgICAgICAgICA6IDEsXG5cbiAgICAvL1BcbiAgICBcInBhZGRpbmdcIiAgICAgICAgICAgICAgICAgICAgICAgOiB7IG11bHRpOiBcIjxwYWRkaW5nLXdpZHRoPiB8IGluaGVyaXRcIiwgbWF4OiA0IH0sXG4gICAgXCJwYWRkaW5nLWJvdHRvbVwiICAgICAgICAgICAgICAgIDogXCI8cGFkZGluZy13aWR0aD4gfCBpbmhlcml0XCIsXG4gICAgXCJwYWRkaW5nLWxlZnRcIiAgICAgICAgICAgICAgICAgIDogXCI8cGFkZGluZy13aWR0aD4gfCBpbmhlcml0XCIsXG4gICAgXCJwYWRkaW5nLXJpZ2h0XCIgICAgICAgICAgICAgICAgIDogXCI8cGFkZGluZy13aWR0aD4gfCBpbmhlcml0XCIsXG4gICAgXCJwYWRkaW5nLXRvcFwiICAgICAgICAgICAgICAgICAgIDogXCI8cGFkZGluZy13aWR0aD4gfCBpbmhlcml0XCIsXG4gICAgXCJwYWdlXCIgICAgICAgICAgICAgICAgICAgICAgICAgIDogMSxcbiAgICBcInBhZ2UtYnJlYWstYWZ0ZXJcIiAgICAgICAgICAgICAgOiBcImF1dG8gfCBhbHdheXMgfCBhdm9pZCB8IGxlZnQgfCByaWdodCB8IGluaGVyaXRcIixcbiAgICBcInBhZ2UtYnJlYWstYmVmb3JlXCIgICAgICAgICAgICAgOiBcImF1dG8gfCBhbHdheXMgfCBhdm9pZCB8IGxlZnQgfCByaWdodCB8IGluaGVyaXRcIixcbiAgICBcInBhZ2UtYnJlYWstaW5zaWRlXCIgICAgICAgICAgICAgOiBcImF1dG8gfCBhdm9pZCB8IGluaGVyaXRcIixcbiAgICBcInBhZ2UtcG9saWN5XCIgICAgICAgICAgICAgICAgICAgOiAxLFxuICAgIFwicGF1c2VcIiAgICAgICAgICAgICAgICAgICAgICAgICA6IDEsXG4gICAgXCJwYXVzZS1hZnRlclwiICAgICAgICAgICAgICAgICAgIDogMSxcbiAgICBcInBhdXNlLWJlZm9yZVwiICAgICAgICAgICAgICAgICAgOiAxLFxuICAgIFwicGVyc3BlY3RpdmVcIiAgICAgICAgICAgICAgICAgICA6IDEsXG4gICAgXCJwZXJzcGVjdGl2ZS1vcmlnaW5cIiAgICAgICAgICAgIDogMSxcbiAgICBcInBob25lbWVzXCIgICAgICAgICAgICAgICAgICAgICAgOiAxLFxuICAgIFwicGl0Y2hcIiAgICAgICAgICAgICAgICAgICAgICAgICA6IDEsXG4gICAgXCJwaXRjaC1yYW5nZVwiICAgICAgICAgICAgICAgICAgIDogMSxcbiAgICBcInBsYXktZHVyaW5nXCIgICAgICAgICAgICAgICAgICAgOiAxLFxuICAgIFwicG9pbnRlci1ldmVudHNcIiAgICAgICAgICAgICAgICA6IFwiYXV0byB8IG5vbmUgfCB2aXNpYmxlUGFpbnRlZCB8IHZpc2libGVGaWxsIHwgdmlzaWJsZVN0cm9rZSB8IHZpc2libGUgfCBwYWludGVkIHwgZmlsbCB8IHN0cm9rZSB8IGFsbCB8IGluaGVyaXRcIixcbiAgICBcInBvc2l0aW9uXCIgICAgICAgICAgICAgICAgICAgICAgOiBcInN0YXRpYyB8IHJlbGF0aXZlIHwgYWJzb2x1dGUgfCBmaXhlZCB8IGluaGVyaXRcIixcbiAgICBcInByZXNlbnRhdGlvbi1sZXZlbFwiICAgICAgICAgICAgOiAxLFxuICAgIFwicHVuY3R1YXRpb24tdHJpbVwiICAgICAgICAgICAgICA6IDEsXG5cbiAgICAvL1FcbiAgICBcInF1b3Rlc1wiICAgICAgICAgICAgICAgICAgICAgICAgOiAxLFxuXG4gICAgLy9SXG4gICAgXCJyZW5kZXJpbmctaW50ZW50XCIgICAgICAgICAgICAgIDogMSxcbiAgICBcInJlc2l6ZVwiICAgICAgICAgICAgICAgICAgICAgICAgOiAxLFxuICAgIFwicmVzdFwiICAgICAgICAgICAgICAgICAgICAgICAgICA6IDEsXG4gICAgXCJyZXN0LWFmdGVyXCIgICAgICAgICAgICAgICAgICAgIDogMSxcbiAgICBcInJlc3QtYmVmb3JlXCIgICAgICAgICAgICAgICAgICAgOiAxLFxuICAgIFwicmljaG5lc3NcIiAgICAgICAgICAgICAgICAgICAgICA6IDEsXG4gICAgXCJyaWdodFwiICAgICAgICAgICAgICAgICAgICAgICAgIDogXCI8bWFyZ2luLXdpZHRoPiB8IGluaGVyaXRcIixcbiAgICBcInJvdGF0aW9uXCIgICAgICAgICAgICAgICAgICAgICAgOiAxLFxuICAgIFwicm90YXRpb24tcG9pbnRcIiAgICAgICAgICAgICAgICA6IDEsXG4gICAgXCJydWJ5LWFsaWduXCIgICAgICAgICAgICAgICAgICAgIDogMSxcbiAgICBcInJ1Ynktb3ZlcmhhbmdcIiAgICAgICAgICAgICAgICAgOiAxLFxuICAgIFwicnVieS1wb3NpdGlvblwiICAgICAgICAgICAgICAgICA6IDEsXG4gICAgXCJydWJ5LXNwYW5cIiAgICAgICAgICAgICAgICAgICAgIDogMSxcblxuICAgIC8vU1xuICAgIFwic2l6ZVwiICAgICAgICAgICAgICAgICAgICAgICAgICA6IDEsXG4gICAgXCJzcGVha1wiICAgICAgICAgICAgICAgICAgICAgICAgIDogXCJub3JtYWwgfCBub25lIHwgc3BlbGwtb3V0IHwgaW5oZXJpdFwiLFxuICAgIFwic3BlYWstaGVhZGVyXCIgICAgICAgICAgICAgICAgICA6IFwib25jZSB8IGFsd2F5cyB8IGluaGVyaXRcIixcbiAgICBcInNwZWFrLW51bWVyYWxcIiAgICAgICAgICAgICAgICAgOiBcImRpZ2l0cyB8IGNvbnRpbnVvdXMgfCBpbmhlcml0XCIsXG4gICAgXCJzcGVhay1wdW5jdHVhdGlvblwiICAgICAgICAgICAgIDogXCJjb2RlIHwgbm9uZSB8IGluaGVyaXRcIixcbiAgICBcInNwZWVjaC1yYXRlXCIgICAgICAgICAgICAgICAgICAgOiAxLFxuICAgIFwic3JjXCIgICAgICAgICAgICAgICAgICAgICAgICAgICA6IDEsXG4gICAgXCJzdHJlc3NcIiAgICAgICAgICAgICAgICAgICAgICAgIDogMSxcbiAgICBcInN0cmluZy1zZXRcIiAgICAgICAgICAgICAgICAgICAgOiAxLFxuXG4gICAgXCJ0YWJsZS1sYXlvdXRcIiAgICAgICAgICAgICAgICAgIDogXCJhdXRvIHwgZml4ZWQgfCBpbmhlcml0XCIsXG4gICAgXCJ0YWItc2l6ZVwiICAgICAgICAgICAgICAgICAgICAgIDogXCI8aW50ZWdlcj4gfCA8bGVuZ3RoPlwiLFxuICAgIFwidGFyZ2V0XCIgICAgICAgICAgICAgICAgICAgICAgICA6IDEsXG4gICAgXCJ0YXJnZXQtbmFtZVwiICAgICAgICAgICAgICAgICAgIDogMSxcbiAgICBcInRhcmdldC1uZXdcIiAgICAgICAgICAgICAgICAgICAgOiAxLFxuICAgIFwidGFyZ2V0LXBvc2l0aW9uXCIgICAgICAgICAgICAgICA6IDEsXG4gICAgXCJ0ZXh0LWFsaWduXCIgICAgICAgICAgICAgICAgICAgIDogXCJsZWZ0IHwgcmlnaHQgfCBjZW50ZXIgfCBqdXN0aWZ5IHwgbWF0Y2gtcGFyZW50IHwgc3RhcnQgfCBlbmQgfCBpbmhlcml0XCIgLFxuICAgIFwidGV4dC1hbGlnbi1sYXN0XCIgICAgICAgICAgICAgICA6IDEsXG4gICAgXCJ0ZXh0LWRlY29yYXRpb25cIiAgICAgICAgICAgICAgIDogMSxcbiAgICBcInRleHQtZW1waGFzaXNcIiAgICAgICAgICAgICAgICAgOiAxLFxuICAgIFwidGV4dC1oZWlnaHRcIiAgICAgICAgICAgICAgICAgICA6IDEsXG4gICAgXCJ0ZXh0LWluZGVudFwiICAgICAgICAgICAgICAgICAgIDogXCI8bGVuZ3RoPiB8IDxwZXJjZW50YWdlPiB8IGluaGVyaXRcIixcbiAgICBcInRleHQtanVzdGlmeVwiICAgICAgICAgICAgICAgICAgOiBcImF1dG8gfCBub25lIHwgaW50ZXItd29yZCB8IGludGVyLWlkZW9ncmFwaCB8IGludGVyLWNsdXN0ZXIgfCBkaXN0cmlidXRlIHwga2FzaGlkYVwiLFxuICAgIFwidGV4dC1vdXRsaW5lXCIgICAgICAgICAgICAgICAgICA6IDEsXG4gICAgXCJ0ZXh0LW92ZXJmbG93XCIgICAgICAgICAgICAgICAgIDogMSxcbiAgICBcInRleHQtcmVuZGVyaW5nXCIgICAgICAgICAgICAgICAgOiBcImF1dG8gfCBvcHRpbWl6ZVNwZWVkIHwgb3B0aW1pemVMZWdpYmlsaXR5IHwgZ2VvbWV0cmljUHJlY2lzaW9uIHwgaW5oZXJpdFwiLFxuICAgIFwidGV4dC1zaGFkb3dcIiAgICAgICAgICAgICAgICAgICA6IDEsXG4gICAgXCJ0ZXh0LXRyYW5zZm9ybVwiICAgICAgICAgICAgICAgIDogXCJjYXBpdGFsaXplIHwgdXBwZXJjYXNlIHwgbG93ZXJjYXNlIHwgbm9uZSB8IGluaGVyaXRcIixcbiAgICBcInRleHQtd3JhcFwiICAgICAgICAgICAgICAgICAgICAgOiBcIm5vcm1hbCB8IG5vbmUgfCBhdm9pZFwiLFxuICAgIFwidG9wXCIgICAgICAgICAgICAgICAgICAgICAgICAgICA6IFwiPG1hcmdpbi13aWR0aD4gfCBpbmhlcml0XCIsXG4gICAgXCItbXMtdG91Y2gtYWN0aW9uXCIgICAgICAgICAgICAgIDogXCJhdXRvIHwgbm9uZSB8IHBhbi14IHwgcGFuLXkgfCBwYW4tbGVmdCB8IHBhbi1yaWdodCB8IHBhbi11cCB8IHBhbi1kb3duIHwgbWFuaXB1bGF0aW9uXCIsXG4gICAgXCJ0b3VjaC1hY3Rpb25cIiAgICAgICAgICAgICAgICAgIDogXCJhdXRvIHwgbm9uZSB8IHBhbi14IHwgcGFuLXkgfCBwYW4tbGVmdCB8IHBhbi1yaWdodCB8IHBhbi11cCB8IHBhbi1kb3duIHwgbWFuaXB1bGF0aW9uXCIsXG4gICAgXCJ0cmFuc2Zvcm1cIiAgICAgICAgICAgICAgICAgICAgIDogMSxcbiAgICBcInRyYW5zZm9ybS1vcmlnaW5cIiAgICAgICAgICAgICAgOiAxLFxuICAgIFwidHJhbnNmb3JtLXN0eWxlXCIgICAgICAgICAgICAgICA6IDEsXG4gICAgXCJ0cmFuc2l0aW9uXCIgICAgICAgICAgICAgICAgICAgIDogMSxcbiAgICBcInRyYW5zaXRpb24tZGVsYXlcIiAgICAgICAgICAgICAgOiAxLFxuICAgIFwidHJhbnNpdGlvbi1kdXJhdGlvblwiICAgICAgICAgICA6IDEsXG4gICAgXCJ0cmFuc2l0aW9uLXByb3BlcnR5XCIgICAgICAgICAgIDogMSxcbiAgICBcInRyYW5zaXRpb24tdGltaW5nLWZ1bmN0aW9uXCIgICAgOiAxLFxuXG4gICAgLy9VXG4gICAgXCJ1bmljb2RlLWJpZGlcIiAgICAgICAgICAgICAgICAgIDogXCJub3JtYWwgfCBlbWJlZCB8IGlzb2xhdGUgfCBiaWRpLW92ZXJyaWRlIHwgaXNvbGF0ZS1vdmVycmlkZSB8IHBsYWludGV4dCB8IGluaGVyaXRcIixcbiAgICBcInVzZXItbW9kaWZ5XCIgICAgICAgICAgICAgICAgICAgOiBcInJlYWQtb25seSB8IHJlYWQtd3JpdGUgfCB3cml0ZS1vbmx5IHwgaW5oZXJpdFwiLFxuICAgIFwidXNlci1zZWxlY3RcIiAgICAgICAgICAgICAgICAgICA6IFwibm9uZSB8IHRleHQgfCB0b2dnbGUgfCBlbGVtZW50IHwgZWxlbWVudHMgfCBhbGwgfCBpbmhlcml0XCIsXG5cbiAgICAvL1ZcbiAgICBcInZlcnRpY2FsLWFsaWduXCIgICAgICAgICAgICAgICAgOiBcImF1dG8gfCB1c2Utc2NyaXB0IHwgYmFzZWxpbmUgfCBzdWIgfCBzdXBlciB8IHRvcCB8IHRleHQtdG9wIHwgY2VudHJhbCB8IG1pZGRsZSB8IGJvdHRvbSB8IHRleHQtYm90dG9tIHwgPHBlcmNlbnRhZ2U+IHwgPGxlbmd0aD4gfCBpbmhlcml0XCIsXG4gICAgXCJ2aXNpYmlsaXR5XCIgICAgICAgICAgICAgICAgICAgIDogXCJ2aXNpYmxlIHwgaGlkZGVuIHwgY29sbGFwc2UgfCBpbmhlcml0XCIsXG4gICAgXCJ2b2ljZS1iYWxhbmNlXCIgICAgICAgICAgICAgICAgIDogMSxcbiAgICBcInZvaWNlLWR1cmF0aW9uXCIgICAgICAgICAgICAgICAgOiAxLFxuICAgIFwidm9pY2UtZmFtaWx5XCIgICAgICAgICAgICAgICAgICA6IDEsXG4gICAgXCJ2b2ljZS1waXRjaFwiICAgICAgICAgICAgICAgICAgIDogMSxcbiAgICBcInZvaWNlLXBpdGNoLXJhbmdlXCIgICAgICAgICAgICAgOiAxLFxuICAgIFwidm9pY2UtcmF0ZVwiICAgICAgICAgICAgICAgICAgICA6IDEsXG4gICAgXCJ2b2ljZS1zdHJlc3NcIiAgICAgICAgICAgICAgICAgIDogMSxcbiAgICBcInZvaWNlLXZvbHVtZVwiICAgICAgICAgICAgICAgICAgOiAxLFxuICAgIFwidm9sdW1lXCIgICAgICAgICAgICAgICAgICAgICAgICA6IDEsXG5cbiAgICAvL1dcbiAgICBcIndoaXRlLXNwYWNlXCIgICAgICAgICAgICAgICAgICAgOiBcIm5vcm1hbCB8IHByZSB8IG5vd3JhcCB8IHByZS13cmFwIHwgcHJlLWxpbmUgfCBpbmhlcml0IHwgLXByZS13cmFwIHwgLW8tcHJlLXdyYXAgfCAtbW96LXByZS13cmFwIHwgLWhwLXByZS13cmFwXCIsIC8vaHR0cDovL3BlcmlzaGFibGVwcmVzcy5jb20vd3JhcHBpbmctY29udGVudC9cbiAgICBcIndoaXRlLXNwYWNlLWNvbGxhcHNlXCIgICAgICAgICAgOiAxLFxuICAgIFwid2lkb3dzXCIgICAgICAgICAgICAgICAgICAgICAgICA6IFwiPGludGVnZXI+IHwgaW5oZXJpdFwiLFxuICAgIFwid2lkdGhcIiAgICAgICAgICAgICAgICAgICAgICAgICA6IFwiPGxlbmd0aD4gfCA8cGVyY2VudGFnZT4gfCA8Y29udGVudC1zaXppbmc+IHwgYXV0byB8IGluaGVyaXRcIixcbiAgICBcIndpbGwtY2hhbmdlXCIgICAgICAgICAgICAgICAgICAgOiB7IG11bHRpOiBcIjxpZGVudD5cIiwgY29tbWE6IHRydWUgfSxcbiAgICBcIndvcmQtYnJlYWtcIiAgICAgICAgICAgICAgICAgICAgOiBcIm5vcm1hbCB8IGtlZXAtYWxsIHwgYnJlYWstYWxsXCIsXG4gICAgXCJ3b3JkLXNwYWNpbmdcIiAgICAgICAgICAgICAgICAgIDogXCI8bGVuZ3RoPiB8IG5vcm1hbCB8IGluaGVyaXRcIixcbiAgICBcIndvcmQtd3JhcFwiICAgICAgICAgICAgICAgICAgICAgOiBcIm5vcm1hbCB8IGJyZWFrLXdvcmRcIixcbiAgICBcIndyaXRpbmctbW9kZVwiICAgICAgICAgICAgICAgICAgOiBcImhvcml6b250YWwtdGIgfCB2ZXJ0aWNhbC1ybCB8IHZlcnRpY2FsLWxyIHwgbHItdGIgfCBybC10YiB8IHRiLXJsIHwgYnQtcmwgfCB0Yi1sciB8IGJ0LWxyIHwgbHItYnQgfCBybC1idCB8IGxyIHwgcmwgfCB0YiB8IGluaGVyaXRcIixcblxuICAgIC8vWlxuICAgIFwiei1pbmRleFwiICAgICAgICAgICAgICAgICAgICAgICA6IFwiPGludGVnZXI+IHwgYXV0byB8IGluaGVyaXRcIixcbiAgICBcInpvb21cIiAgICAgICAgICAgICAgICAgICAgICAgICAgOiBcIjxudW1iZXI+IHwgPHBlcmNlbnRhZ2U+IHwgbm9ybWFsXCJcbn07XG4vKipcbiAqIFJlcHJlc2VudHMgYSBzZWxlY3RvciBjb21iaW5hdG9yICh3aGl0ZXNwYWNlLCArLCA+KS5cbiAqIEBuYW1lc3BhY2UgcGFyc2VybGliLmNzc1xuICogQGNsYXNzIFByb3BlcnR5TmFtZVxuICogQGV4dGVuZHMgcGFyc2VybGliLnV0aWwuU3ludGF4VW5pdFxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge1N0cmluZ30gdGV4dCBUaGUgdGV4dCByZXByZXNlbnRhdGlvbiBvZiB0aGUgdW5pdC5cbiAqIEBwYXJhbSB7U3RyaW5nfSBoYWNrIFRoZSB0eXBlIG9mIElFIGhhY2sgYXBwbGllZCAoXCIqXCIsIFwiX1wiLCBvciBudWxsKS5cbiAqIEBwYXJhbSB7aW50fSBsaW5lIFRoZSBsaW5lIG9mIHRleHQgb24gd2hpY2ggdGhlIHVuaXQgcmVzaWRlcy5cbiAqIEBwYXJhbSB7aW50fSBjb2wgVGhlIGNvbHVtbiBvZiB0ZXh0IG9uIHdoaWNoIHRoZSB1bml0IHJlc2lkZXMuXG4gKi9cbmZ1bmN0aW9uIFByb3BlcnR5TmFtZSh0ZXh0LCBoYWNrLCBsaW5lLCBjb2wpe1xuXG4gICAgU3ludGF4VW5pdC5jYWxsKHRoaXMsIHRleHQsIGxpbmUsIGNvbCwgUGFyc2VyLlBST1BFUlRZX05BTUVfVFlQRSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdHlwZSBvZiBJRSBoYWNrIGFwcGxpZWQgKFwiKlwiLCBcIl9cIiwgb3IgbnVsbCkuXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQHByb3BlcnR5IGhhY2tcbiAgICAgKi9cbiAgICB0aGlzLmhhY2sgPSBoYWNrO1xuXG59XG5cblByb3BlcnR5TmFtZS5wcm90b3R5cGUgPSBuZXcgU3ludGF4VW5pdCgpO1xuUHJvcGVydHlOYW1lLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFByb3BlcnR5TmFtZTtcblByb3BlcnR5TmFtZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpe1xuICAgIHJldHVybiAodGhpcy5oYWNrID8gdGhpcy5oYWNrIDogXCJcIikgKyB0aGlzLnRleHQ7XG59O1xuLyoqXG4gKiBSZXByZXNlbnRzIGEgc2luZ2xlIHBhcnQgb2YgYSBDU1MgcHJvcGVydHkgdmFsdWUsIG1lYW5pbmcgdGhhdCBpdCByZXByZXNlbnRzXG4gKiBqdXN0IGV2ZXJ5dGhpbmcgc2luZ2xlIHBhcnQgYmV0d2VlbiBcIjpcIiBhbmQgXCI7XCIuIElmIHRoZXJlIGFyZSBtdWx0aXBsZSB2YWx1ZXNcbiAqIHNlcGFyYXRlZCBieSBjb21tYXMsIHRoaXMgdHlwZSByZXByZXNlbnRzIGp1c3Qgb25lIG9mIHRoZSB2YWx1ZXMuXG4gKiBAcGFyYW0ge1N0cmluZ1tdfSBwYXJ0cyBBbiBhcnJheSBvZiB2YWx1ZSBwYXJ0cyBtYWtpbmcgdXAgdGhpcyB2YWx1ZS5cbiAqIEBwYXJhbSB7aW50fSBsaW5lIFRoZSBsaW5lIG9mIHRleHQgb24gd2hpY2ggdGhlIHVuaXQgcmVzaWRlcy5cbiAqIEBwYXJhbSB7aW50fSBjb2wgVGhlIGNvbHVtbiBvZiB0ZXh0IG9uIHdoaWNoIHRoZSB1bml0IHJlc2lkZXMuXG4gKiBAbmFtZXNwYWNlIHBhcnNlcmxpYi5jc3NcbiAqIEBjbGFzcyBQcm9wZXJ0eVZhbHVlXG4gKiBAZXh0ZW5kcyBwYXJzZXJsaWIudXRpbC5TeW50YXhVbml0XG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gUHJvcGVydHlWYWx1ZShwYXJ0cywgbGluZSwgY29sKXtcblxuICAgIFN5bnRheFVuaXQuY2FsbCh0aGlzLCBwYXJ0cy5qb2luKFwiIFwiKSwgbGluZSwgY29sLCBQYXJzZXIuUFJPUEVSVFlfVkFMVUVfVFlQRSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgcGFydHMgdGhhdCBtYWtlIHVwIHRoZSBzZWxlY3Rvci5cbiAgICAgKiBAdHlwZSBBcnJheVxuICAgICAqIEBwcm9wZXJ0eSBwYXJ0c1xuICAgICAqL1xuICAgIHRoaXMucGFydHMgPSBwYXJ0cztcblxufVxuXG5Qcm9wZXJ0eVZhbHVlLnByb3RvdHlwZSA9IG5ldyBTeW50YXhVbml0KCk7XG5Qcm9wZXJ0eVZhbHVlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFByb3BlcnR5VmFsdWU7XG5cbi8qKlxuICogQSB1dGlsaXR5IGNsYXNzIHRoYXQgYWxsb3dzIGZvciBlYXN5IGl0ZXJhdGlvbiBvdmVyIHRoZSB2YXJpb3VzIHBhcnRzIG9mIGFcbiAqIHByb3BlcnR5IHZhbHVlLlxuICogQHBhcmFtIHtwYXJzZXJsaWIuY3NzLlByb3BlcnR5VmFsdWV9IHZhbHVlIFRoZSBwcm9wZXJ0eSB2YWx1ZSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAbmFtZXNwYWNlIHBhcnNlcmxpYi5jc3NcbiAqIEBjbGFzcyBQcm9wZXJ0eVZhbHVlSXRlcmF0b3JcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBQcm9wZXJ0eVZhbHVlSXRlcmF0b3IodmFsdWUpe1xuXG4gICAgLyoqXG4gICAgICogSXRlcmF0b3IgdmFsdWVcbiAgICAgKiBAdHlwZSBpbnRcbiAgICAgKiBAcHJvcGVydHkgX2lcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX2kgPSAwO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHBhcnRzIHRoYXQgbWFrZSB1cCB0aGUgdmFsdWUuXG4gICAgICogQHR5cGUgQXJyYXlcbiAgICAgKiBAcHJvcGVydHkgX3BhcnRzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9wYXJ0cyA9IHZhbHVlLnBhcnRzO1xuXG4gICAgLyoqXG4gICAgICogS2VlcHMgdHJhY2sgb2YgYm9va21hcmtzIGFsb25nIHRoZSB3YXkuXG4gICAgICogQHR5cGUgQXJyYXlcbiAgICAgKiBAcHJvcGVydHkgX21hcmtzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9tYXJrcyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogSG9sZHMgdGhlIG9yaWdpbmFsIHByb3BlcnR5IHZhbHVlLlxuICAgICAqIEB0eXBlIHBhcnNlcmxpYi5jc3MuUHJvcGVydHlWYWx1ZVxuICAgICAqIEBwcm9wZXJ0eSB2YWx1ZVxuICAgICAqL1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcblxufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIHRvdGFsIG51bWJlciBvZiBwYXJ0cyBpbiB0aGUgdmFsdWUuXG4gKiBAcmV0dXJuIHtpbnR9IFRoZSB0b3RhbCBudW1iZXIgb2YgcGFydHMgaW4gdGhlIHZhbHVlLlxuICogQG1ldGhvZCBjb3VudFxuICovXG5Qcm9wZXJ0eVZhbHVlSXRlcmF0b3IucHJvdG90eXBlLmNvdW50ID0gZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gdGhpcy5fcGFydHMubGVuZ3RoO1xufTtcblxuLyoqXG4gKiBJbmRpY2F0ZXMgaWYgdGhlIGl0ZXJhdG9yIGlzIHBvc2l0aW9uZWQgYXQgdGhlIGZpcnN0IGl0ZW0uXG4gKiBAcmV0dXJuIHtCb29sZWFufSBUcnVlIGlmIHBvc2l0aW9uZWQgYXQgZmlyc3QgaXRlbSwgZmFsc2UgaWYgbm90LlxuICogQG1ldGhvZCBpc0ZpcnN0XG4gKi9cblByb3BlcnR5VmFsdWVJdGVyYXRvci5wcm90b3R5cGUuaXNGaXJzdCA9IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIHRoaXMuX2kgPT09IDA7XG59O1xuXG4vKipcbiAqIEluZGljYXRlcyBpZiB0aGVyZSBhcmUgbW9yZSBwYXJ0cyBvZiB0aGUgcHJvcGVydHkgdmFsdWUuXG4gKiBAcmV0dXJuIHtCb29sZWFufSBUcnVlIGlmIHRoZXJlIGFyZSBtb3JlIHBhcnRzLCBmYWxzZSBpZiBub3QuXG4gKiBAbWV0aG9kIGhhc05leHRcbiAqL1xuUHJvcGVydHlWYWx1ZUl0ZXJhdG9yLnByb3RvdHlwZS5oYXNOZXh0ID0gZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gKHRoaXMuX2kgPCB0aGlzLl9wYXJ0cy5sZW5ndGgpO1xufTtcblxuLyoqXG4gKiBNYXJrcyB0aGUgY3VycmVudCBzcG90IGluIHRoZSBpdGVyYXRpb24gc28gaXQgY2FuIGJlIHJlc3RvcmVkIHRvXG4gKiBsYXRlciBvbi5cbiAqIEByZXR1cm4ge3ZvaWR9XG4gKiBAbWV0aG9kIG1hcmtcbiAqL1xuUHJvcGVydHlWYWx1ZUl0ZXJhdG9yLnByb3RvdHlwZS5tYXJrID0gZnVuY3Rpb24oKXtcbiAgICB0aGlzLl9tYXJrcy5wdXNoKHRoaXMuX2kpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBuZXh0IHBhcnQgb2YgdGhlIHByb3BlcnR5IHZhbHVlIG9yIG51bGwgaWYgdGhlcmUgaXMgbm8gbmV4dFxuICogcGFydC4gRG9lcyBub3QgbW92ZSB0aGUgaW50ZXJuYWwgY291bnRlciBmb3J3YXJkLlxuICogQHJldHVybiB7cGFyc2VybGliLmNzcy5Qcm9wZXJ0eVZhbHVlUGFydH0gVGhlIG5leHQgcGFydCBvZiB0aGUgcHJvcGVydHkgdmFsdWUgb3IgbnVsbCBpZiB0aGVyZSBpcyBubyBuZXh0XG4gKiBwYXJ0LlxuICogQG1ldGhvZCBwZWVrXG4gKi9cblByb3BlcnR5VmFsdWVJdGVyYXRvci5wcm90b3R5cGUucGVlayA9IGZ1bmN0aW9uKGNvdW50KXtcbiAgICByZXR1cm4gdGhpcy5oYXNOZXh0KCkgPyB0aGlzLl9wYXJ0c1t0aGlzLl9pICsgKGNvdW50IHx8IDApXSA6IG51bGw7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIG5leHQgcGFydCBvZiB0aGUgcHJvcGVydHkgdmFsdWUgb3IgbnVsbCBpZiB0aGVyZSBpcyBubyBuZXh0XG4gKiBwYXJ0LlxuICogQHJldHVybiB7cGFyc2VybGliLmNzcy5Qcm9wZXJ0eVZhbHVlUGFydH0gVGhlIG5leHQgcGFydCBvZiB0aGUgcHJvcGVydHkgdmFsdWUgb3IgbnVsbCBpZiB0aGVyZSBpcyBubyBuZXh0XG4gKiBwYXJ0LlxuICogQG1ldGhvZCBuZXh0XG4gKi9cblByb3BlcnR5VmFsdWVJdGVyYXRvci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIHRoaXMuaGFzTmV4dCgpID8gdGhpcy5fcGFydHNbdGhpcy5faSsrXSA6IG51bGw7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIHByZXZpb3VzIHBhcnQgb2YgdGhlIHByb3BlcnR5IHZhbHVlIG9yIG51bGwgaWYgdGhlcmUgaXMgbm9cbiAqIHByZXZpb3VzIHBhcnQuXG4gKiBAcmV0dXJuIHtwYXJzZXJsaWIuY3NzLlByb3BlcnR5VmFsdWVQYXJ0fSBUaGUgcHJldmlvdXMgcGFydCBvZiB0aGVcbiAqIHByb3BlcnR5IHZhbHVlIG9yIG51bGwgaWYgdGhlcmUgaXMgbm8gcHJldmlvdXMgcGFydC5cbiAqIEBtZXRob2QgcHJldmlvdXNcbiAqL1xuUHJvcGVydHlWYWx1ZUl0ZXJhdG9yLnByb3RvdHlwZS5wcmV2aW91cyA9IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIHRoaXMuX2kgPiAwID8gdGhpcy5fcGFydHNbLS10aGlzLl9pXSA6IG51bGw7XG59O1xuXG4vKipcbiAqIFJlc3RvcmVzIHRoZSBsYXN0IHNhdmVkIGJvb2ttYXJrLlxuICogQHJldHVybiB7dm9pZH1cbiAqIEBtZXRob2QgcmVzdG9yZVxuICovXG5Qcm9wZXJ0eVZhbHVlSXRlcmF0b3IucHJvdG90eXBlLnJlc3RvcmUgPSBmdW5jdGlvbigpe1xuICAgIGlmICh0aGlzLl9tYXJrcy5sZW5ndGgpe1xuICAgICAgICB0aGlzLl9pID0gdGhpcy5fbWFya3MucG9wKCk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgc2luZ2xlIHBhcnQgb2YgYSBDU1MgcHJvcGVydHkgdmFsdWUsIG1lYW5pbmcgdGhhdCBpdCByZXByZXNlbnRzXG4gKiBqdXN0IG9uZSBwYXJ0IG9mIHRoZSBkYXRhIGJldHdlZW4gXCI6XCIgYW5kIFwiO1wiLlxuICogQHBhcmFtIHtTdHJpbmd9IHRleHQgVGhlIHRleHQgcmVwcmVzZW50YXRpb24gb2YgdGhlIHVuaXQuXG4gKiBAcGFyYW0ge2ludH0gbGluZSBUaGUgbGluZSBvZiB0ZXh0IG9uIHdoaWNoIHRoZSB1bml0IHJlc2lkZXMuXG4gKiBAcGFyYW0ge2ludH0gY29sIFRoZSBjb2x1bW4gb2YgdGV4dCBvbiB3aGljaCB0aGUgdW5pdCByZXNpZGVzLlxuICogQG5hbWVzcGFjZSBwYXJzZXJsaWIuY3NzXG4gKiBAY2xhc3MgUHJvcGVydHlWYWx1ZVBhcnRcbiAqIEBleHRlbmRzIHBhcnNlcmxpYi51dGlsLlN5bnRheFVuaXRcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBQcm9wZXJ0eVZhbHVlUGFydCh0ZXh0LCBsaW5lLCBjb2wpe1xuXG4gICAgU3ludGF4VW5pdC5jYWxsKHRoaXMsIHRleHQsIGxpbmUsIGNvbCwgUGFyc2VyLlBST1BFUlRZX1ZBTFVFX1BBUlRfVFlQRSk7XG5cbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgdGhlIHR5cGUgb2YgdmFsdWUgdW5pdC5cbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAcHJvcGVydHkgdHlwZVxuICAgICAqL1xuICAgIHRoaXMudHlwZSA9IFwidW5rbm93blwiO1xuXG4gICAgLy9maWd1cmUgb3V0IHdoYXQgdHlwZSBvZiBkYXRhIGl0IGlzXG5cbiAgICB2YXIgdGVtcDtcblxuICAgIC8vaXQgaXMgYSBtZWFzdXJlbWVudD9cbiAgICBpZiAoL14oWytcXC1dP1tcXGRcXC5dKykoW2Etel0rKSQvaS50ZXN0KHRleHQpKXsgIC8vZGltZW5zaW9uXG4gICAgICAgIHRoaXMudHlwZSA9IFwiZGltZW5zaW9uXCI7XG4gICAgICAgIHRoaXMudmFsdWUgPSArUmVnRXhwLiQxO1xuICAgICAgICB0aGlzLnVuaXRzID0gUmVnRXhwLiQyO1xuXG4gICAgICAgIC8vdHJ5IHRvIG5hcnJvdyBkb3duXG4gICAgICAgIHN3aXRjaCh0aGlzLnVuaXRzLnRvTG93ZXJDYXNlKCkpe1xuXG4gICAgICAgICAgICBjYXNlIFwiZW1cIjpcbiAgICAgICAgICAgIGNhc2UgXCJyZW1cIjpcbiAgICAgICAgICAgIGNhc2UgXCJleFwiOlxuICAgICAgICAgICAgY2FzZSBcInB4XCI6XG4gICAgICAgICAgICBjYXNlIFwiY21cIjpcbiAgICAgICAgICAgIGNhc2UgXCJtbVwiOlxuICAgICAgICAgICAgY2FzZSBcImluXCI6XG4gICAgICAgICAgICBjYXNlIFwicHRcIjpcbiAgICAgICAgICAgIGNhc2UgXCJwY1wiOlxuICAgICAgICAgICAgY2FzZSBcImNoXCI6XG4gICAgICAgICAgICBjYXNlIFwidmhcIjpcbiAgICAgICAgICAgIGNhc2UgXCJ2d1wiOlxuICAgICAgICAgICAgY2FzZSBcInZtYXhcIjpcbiAgICAgICAgICAgIGNhc2UgXCJ2bWluXCI6XG4gICAgICAgICAgICAgICAgdGhpcy50eXBlID0gXCJsZW5ndGhcIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIGNhc2UgXCJmclwiOlxuICAgICAgICAgICAgICAgIHRoaXMudHlwZSA9IFwiZ3JpZFwiO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIFwiZGVnXCI6XG4gICAgICAgICAgICBjYXNlIFwicmFkXCI6XG4gICAgICAgICAgICBjYXNlIFwiZ3JhZFwiOlxuICAgICAgICAgICAgICAgIHRoaXMudHlwZSA9IFwiYW5nbGVcIjtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBcIm1zXCI6XG4gICAgICAgICAgICBjYXNlIFwic1wiOlxuICAgICAgICAgICAgICAgIHRoaXMudHlwZSA9IFwidGltZVwiO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIFwiaHpcIjpcbiAgICAgICAgICAgIGNhc2UgXCJraHpcIjpcbiAgICAgICAgICAgICAgICB0aGlzLnR5cGUgPSBcImZyZXF1ZW5jeVwiO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIFwiZHBpXCI6XG4gICAgICAgICAgICBjYXNlIFwiZHBjbVwiOlxuICAgICAgICAgICAgICAgIHRoaXMudHlwZSA9IFwicmVzb2x1dGlvblwiO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAvL2RlZmF1bHRcblxuICAgICAgICB9XG5cbiAgICB9IGVsc2UgaWYgKC9eKFsrXFwtXT9bXFxkXFwuXSspJSQvaS50ZXN0KHRleHQpKXsgIC8vcGVyY2VudGFnZVxuICAgICAgICB0aGlzLnR5cGUgPSBcInBlcmNlbnRhZ2VcIjtcbiAgICAgICAgdGhpcy52YWx1ZSA9ICtSZWdFeHAuJDE7XG4gICAgfSBlbHNlIGlmICgvXihbK1xcLV0/XFxkKykkL2kudGVzdCh0ZXh0KSl7ICAvL2ludGVnZXJcbiAgICAgICAgdGhpcy50eXBlID0gXCJpbnRlZ2VyXCI7XG4gICAgICAgIHRoaXMudmFsdWUgPSArUmVnRXhwLiQxO1xuICAgIH0gZWxzZSBpZiAoL14oWytcXC1dP1tcXGRcXC5dKykkL2kudGVzdCh0ZXh0KSl7ICAvL251bWJlclxuICAgICAgICB0aGlzLnR5cGUgPSBcIm51bWJlclwiO1xuICAgICAgICB0aGlzLnZhbHVlID0gK1JlZ0V4cC4kMTtcblxuICAgIH0gZWxzZSBpZiAoL14jKFthLWYwLTldezMsNn0pL2kudGVzdCh0ZXh0KSl7ICAvL2hleGNvbG9yXG4gICAgICAgIHRoaXMudHlwZSA9IFwiY29sb3JcIjtcbiAgICAgICAgdGVtcCA9IFJlZ0V4cC4kMTtcbiAgICAgICAgaWYgKHRlbXAubGVuZ3RoID09PSAzKXtcbiAgICAgICAgICAgIHRoaXMucmVkICAgID0gcGFyc2VJbnQodGVtcC5jaGFyQXQoMCkrdGVtcC5jaGFyQXQoMCksMTYpO1xuICAgICAgICAgICAgdGhpcy5ncmVlbiAgPSBwYXJzZUludCh0ZW1wLmNoYXJBdCgxKSt0ZW1wLmNoYXJBdCgxKSwxNik7XG4gICAgICAgICAgICB0aGlzLmJsdWUgICA9IHBhcnNlSW50KHRlbXAuY2hhckF0KDIpK3RlbXAuY2hhckF0KDIpLDE2KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucmVkICAgID0gcGFyc2VJbnQodGVtcC5zdWJzdHJpbmcoMCwyKSwxNik7XG4gICAgICAgICAgICB0aGlzLmdyZWVuICA9IHBhcnNlSW50KHRlbXAuc3Vic3RyaW5nKDIsNCksMTYpO1xuICAgICAgICAgICAgdGhpcy5ibHVlICAgPSBwYXJzZUludCh0ZW1wLnN1YnN0cmluZyg0LDYpLDE2KTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAoL15yZ2JcXChcXHMqKFxcZCspXFxzKixcXHMqKFxcZCspXFxzKixcXHMqKFxcZCspXFxzKlxcKS9pLnRlc3QodGV4dCkpeyAvL3JnYigpIGNvbG9yIHdpdGggYWJzb2x1dGUgbnVtYmVyc1xuICAgICAgICB0aGlzLnR5cGUgICA9IFwiY29sb3JcIjtcbiAgICAgICAgdGhpcy5yZWQgICAgPSArUmVnRXhwLiQxO1xuICAgICAgICB0aGlzLmdyZWVuICA9ICtSZWdFeHAuJDI7XG4gICAgICAgIHRoaXMuYmx1ZSAgID0gK1JlZ0V4cC4kMztcbiAgICB9IGVsc2UgaWYgKC9ecmdiXFwoXFxzKihcXGQrKSVcXHMqLFxccyooXFxkKyklXFxzKixcXHMqKFxcZCspJVxccypcXCkvaS50ZXN0KHRleHQpKXsgLy9yZ2IoKSBjb2xvciB3aXRoIHBlcmNlbnRhZ2VzXG4gICAgICAgIHRoaXMudHlwZSAgID0gXCJjb2xvclwiO1xuICAgICAgICB0aGlzLnJlZCAgICA9ICtSZWdFeHAuJDEgKiAyNTUgLyAxMDA7XG4gICAgICAgIHRoaXMuZ3JlZW4gID0gK1JlZ0V4cC4kMiAqIDI1NSAvIDEwMDtcbiAgICAgICAgdGhpcy5ibHVlICAgPSArUmVnRXhwLiQzICogMjU1IC8gMTAwO1xuICAgIH0gZWxzZSBpZiAoL15yZ2JhXFwoXFxzKihcXGQrKVxccyosXFxzKihcXGQrKVxccyosXFxzKihcXGQrKVxccyosXFxzKihbXFxkXFwuXSspXFxzKlxcKS9pLnRlc3QodGV4dCkpeyAvL3JnYmEoKSBjb2xvciB3aXRoIGFic29sdXRlIG51bWJlcnNcbiAgICAgICAgdGhpcy50eXBlICAgPSBcImNvbG9yXCI7XG4gICAgICAgIHRoaXMucmVkICAgID0gK1JlZ0V4cC4kMTtcbiAgICAgICAgdGhpcy5ncmVlbiAgPSArUmVnRXhwLiQyO1xuICAgICAgICB0aGlzLmJsdWUgICA9ICtSZWdFeHAuJDM7XG4gICAgICAgIHRoaXMuYWxwaGEgID0gK1JlZ0V4cC4kNDtcbiAgICB9IGVsc2UgaWYgKC9ecmdiYVxcKFxccyooXFxkKyklXFxzKixcXHMqKFxcZCspJVxccyosXFxzKihcXGQrKSVcXHMqLFxccyooW1xcZFxcLl0rKVxccypcXCkvaS50ZXN0KHRleHQpKXsgLy9yZ2JhKCkgY29sb3Igd2l0aCBwZXJjZW50YWdlc1xuICAgICAgICB0aGlzLnR5cGUgICA9IFwiY29sb3JcIjtcbiAgICAgICAgdGhpcy5yZWQgICAgPSArUmVnRXhwLiQxICogMjU1IC8gMTAwO1xuICAgICAgICB0aGlzLmdyZWVuICA9ICtSZWdFeHAuJDIgKiAyNTUgLyAxMDA7XG4gICAgICAgIHRoaXMuYmx1ZSAgID0gK1JlZ0V4cC4kMyAqIDI1NSAvIDEwMDtcbiAgICAgICAgdGhpcy5hbHBoYSAgPSArUmVnRXhwLiQ0O1xuICAgIH0gZWxzZSBpZiAoL15oc2xcXChcXHMqKFxcZCspXFxzKixcXHMqKFxcZCspJVxccyosXFxzKihcXGQrKSVcXHMqXFwpL2kudGVzdCh0ZXh0KSl7IC8vaHNsKClcbiAgICAgICAgdGhpcy50eXBlICAgPSBcImNvbG9yXCI7XG4gICAgICAgIHRoaXMuaHVlICAgID0gK1JlZ0V4cC4kMTtcbiAgICAgICAgdGhpcy5zYXR1cmF0aW9uID0gK1JlZ0V4cC4kMiAvIDEwMDtcbiAgICAgICAgdGhpcy5saWdodG5lc3MgID0gK1JlZ0V4cC4kMyAvIDEwMDtcbiAgICB9IGVsc2UgaWYgKC9eaHNsYVxcKFxccyooXFxkKylcXHMqLFxccyooXFxkKyklXFxzKixcXHMqKFxcZCspJVxccyosXFxzKihbXFxkXFwuXSspXFxzKlxcKS9pLnRlc3QodGV4dCkpeyAvL2hzbGEoKSBjb2xvciB3aXRoIHBlcmNlbnRhZ2VzXG4gICAgICAgIHRoaXMudHlwZSAgID0gXCJjb2xvclwiO1xuICAgICAgICB0aGlzLmh1ZSAgICA9ICtSZWdFeHAuJDE7XG4gICAgICAgIHRoaXMuc2F0dXJhdGlvbiA9ICtSZWdFeHAuJDIgLyAxMDA7XG4gICAgICAgIHRoaXMubGlnaHRuZXNzICA9ICtSZWdFeHAuJDMgLyAxMDA7XG4gICAgICAgIHRoaXMuYWxwaGEgID0gK1JlZ0V4cC4kNDtcbiAgICB9IGVsc2UgaWYgKC9edXJsXFwoW1wiJ10/KFteXFwpXCInXSspW1wiJ10/XFwpL2kudGVzdCh0ZXh0KSl7IC8vVVJJXG4gICAgICAgIHRoaXMudHlwZSAgID0gXCJ1cmlcIjtcbiAgICAgICAgdGhpcy51cmkgICAgPSBSZWdFeHAuJDE7XG4gICAgfSBlbHNlIGlmICgvXihbXlxcKF0rKVxcKC9pLnRlc3QodGV4dCkpe1xuICAgICAgICB0aGlzLnR5cGUgICA9IFwiZnVuY3Rpb25cIjtcbiAgICAgICAgdGhpcy5uYW1lICAgPSBSZWdFeHAuJDE7XG4gICAgICAgIHRoaXMudmFsdWUgID0gdGV4dDtcbiAgICB9IGVsc2UgaWYgKC9eXCIoW15cXG5cXHJcXGZcXFxcXCJdfFxcXFxcXHJcXG58XFxcXFteXFxyMC05YS1mXXxcXFxcWzAtOWEtZl17MSw2fShcXHJcXG58WyBcXG5cXHJcXHRcXGZdKT8pKlwiL2kudGVzdCh0ZXh0KSl7ICAgIC8vZG91YmxlLXF1b3RlZCBzdHJpbmdcbiAgICAgICAgdGhpcy50eXBlICAgPSBcInN0cmluZ1wiO1xuICAgICAgICB0aGlzLnZhbHVlICA9IFByb3BlcnR5VmFsdWVQYXJ0LnBhcnNlU3RyaW5nKHRleHQpO1xuICAgIH0gZWxzZSBpZiAoL14nKFteXFxuXFxyXFxmXFxcXCddfFxcXFxcXHJcXG58XFxcXFteXFxyMC05YS1mXXxcXFxcWzAtOWEtZl17MSw2fShcXHJcXG58WyBcXG5cXHJcXHRcXGZdKT8pKicvaS50ZXN0KHRleHQpKXsgICAgLy9zaW5nbGUtcXVvdGVkIHN0cmluZ1xuICAgICAgICB0aGlzLnR5cGUgICA9IFwic3RyaW5nXCI7XG4gICAgICAgIHRoaXMudmFsdWUgID0gUHJvcGVydHlWYWx1ZVBhcnQucGFyc2VTdHJpbmcodGV4dCk7XG4gICAgfSBlbHNlIGlmIChDb2xvcnNbdGV4dC50b0xvd2VyQ2FzZSgpXSl7ICAvL25hbWVkIGNvbG9yXG4gICAgICAgIHRoaXMudHlwZSAgID0gXCJjb2xvclwiO1xuICAgICAgICB0ZW1wICAgICAgICA9IENvbG9yc1t0ZXh0LnRvTG93ZXJDYXNlKCldLnN1YnN0cmluZygxKTtcbiAgICAgICAgdGhpcy5yZWQgICAgPSBwYXJzZUludCh0ZW1wLnN1YnN0cmluZygwLDIpLDE2KTtcbiAgICAgICAgdGhpcy5ncmVlbiAgPSBwYXJzZUludCh0ZW1wLnN1YnN0cmluZygyLDQpLDE2KTtcbiAgICAgICAgdGhpcy5ibHVlICAgPSBwYXJzZUludCh0ZW1wLnN1YnN0cmluZyg0LDYpLDE2KTtcbiAgICB9IGVsc2UgaWYgKC9eW1xcLFxcL10kLy50ZXN0KHRleHQpKXtcbiAgICAgICAgdGhpcy50eXBlICAgPSBcIm9wZXJhdG9yXCI7XG4gICAgICAgIHRoaXMudmFsdWUgID0gdGV4dDtcbiAgICB9IGVsc2UgaWYgKC9eW2EtelxcLV9cXHUwMDgwLVxcdUZGRkZdW2EtejAtOVxcLV9cXHUwMDgwLVxcdUZGRkZdKiQvaS50ZXN0KHRleHQpKXtcbiAgICAgICAgdGhpcy50eXBlICAgPSBcImlkZW50aWZpZXJcIjtcbiAgICAgICAgdGhpcy52YWx1ZSAgPSB0ZXh0O1xuICAgIH1cblxufVxuXG5Qcm9wZXJ0eVZhbHVlUGFydC5wcm90b3R5cGUgPSBuZXcgU3ludGF4VW5pdCgpO1xuUHJvcGVydHlWYWx1ZVBhcnQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUHJvcGVydHlWYWx1ZVBhcnQ7XG5cbi8qKlxuICogSGVscGVyIG1ldGhvZCB0byBwYXJzZSBhIENTUyBzdHJpbmcuXG4gKi9cblByb3BlcnR5VmFsdWVQYXJ0LnBhcnNlU3RyaW5nID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgc3RyID0gc3RyLnNsaWNlKDEsIC0xKTsgLy8gU3RyaXAgc3Vycm91bmRpbmcgc2luZ2xlL2RvdWJsZSBxdW90ZXNcbiAgICB2YXIgcmVwbGFjZXIgPSBmdW5jdGlvbihtYXRjaCwgZXNjKSB7XG4gICAgICAgIGlmICgvXihcXG58XFxyXFxufFxccnxcXGYpJC8udGVzdChlc2MpKSB7IHJldHVybiAnJzsgfVxuICAgICAgICB2YXIgbSA9IC9eWzAtOWEtZl17MSw2fS9pLmV4ZWMoZXNjKTtcbiAgICAgICAgaWYgKG0pIHtcbiAgICAgICAgICAgIHZhciBjb2RlUG9pbnQgPSBwYXJzZUludChtWzBdLCAxNik7XG4gICAgICAgICAgICBpZiAoU3RyaW5nLmZyb21Db2RlUG9pbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21Db2RlUG9pbnQoY29kZVBvaW50KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gWFhYIE5vIHN1cHBvcnQgZm9yIHN1cnJvZ2F0ZXMgb24gb2xkIEphdmFTY3JpcHQgZW5naW5lcy5cbiAgICAgICAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlUG9pbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlc2M7XG4gICAgfTtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoL1xcXFwoXFxyXFxufFteXFxyMC05YS1mXXxbMC05YS1mXXsxLDZ9KFxcclxcbnxbIFxcblxcclxcdFxcZl0pPykvaWcsXG4gICAgICAgICAgICAgICAgICAgICAgIHJlcGxhY2VyKTtcbn07XG5cbi8qKlxuICogSGVscGVyIG1ldGhvZCB0byBzZXJpYWxpemUgYSBDU1Mgc3RyaW5nLlxuICovXG5Qcm9wZXJ0eVZhbHVlUGFydC5zZXJpYWxpemVTdHJpbmcgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHZhciByZXBsYWNlciA9IGZ1bmN0aW9uKG1hdGNoLCBjKSB7XG4gICAgICAgIGlmIChjID09PSAnXCInKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJcXFxcXCIgKyBjO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjcCA9IFN0cmluZy5jb2RlUG9pbnRBdCA/IFN0cmluZy5jb2RlUG9pbnRBdCgwKSA6XG4gICAgICAgICAgICAvLyBXZSBvbmx5IGVzY2FwZSBub24tc3Vycm9nYXRlIGNoYXJzLCBzbyB1c2luZyBjaGFyQ29kZUF0XG4gICAgICAgICAgICAvLyBpcyBoYXJtbGVzcyBoZXJlLlxuICAgICAgICAgICAgU3RyaW5nLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgIHJldHVybiBcIlxcXFxcIiArIGNwLnRvU3RyaW5nKDE2KSArIFwiIFwiO1xuICAgIH07XG4gICAgcmV0dXJuICdcIicgKyB2YWx1ZS5yZXBsYWNlKC9bXCJcXHJcXG5cXGZdL2csIHJlcGxhY2VyKSArICdcIic7XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBzeW50YXggdW5pdCBiYXNlZCBzb2xlbHkgb24gdGhlIGdpdmVuIHRva2VuLlxuICogQ29udmVuaWVuY2UgbWV0aG9kIGZvciBjcmVhdGluZyBhIG5ldyBzeW50YXggdW5pdCB3aGVuXG4gKiBpdCByZXByZXNlbnRzIGEgc2luZ2xlIHRva2VuIGluc3RlYWQgb2YgbXVsdGlwbGUuXG4gKiBAcGFyYW0ge09iamVjdH0gdG9rZW4gVGhlIHRva2VuIG9iamVjdCB0byByZXByZXNlbnQuXG4gKiBAcmV0dXJuIHtwYXJzZXJsaWIuY3NzLlByb3BlcnR5VmFsdWVQYXJ0fSBUaGUgb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgdG9rZW4uXG4gKiBAc3RhdGljXG4gKiBAbWV0aG9kIGZyb21Ub2tlblxuICovXG5Qcm9wZXJ0eVZhbHVlUGFydC5mcm9tVG9rZW4gPSBmdW5jdGlvbih0b2tlbil7XG4gICAgcmV0dXJuIG5ldyBQcm9wZXJ0eVZhbHVlUGFydCh0b2tlbi52YWx1ZSwgdG9rZW4uc3RhcnRMaW5lLCB0b2tlbi5zdGFydENvbCk7XG59O1xudmFyIFBzZXVkb3MgPSB7XG4gICAgX19wcm90b19fOiAgICAgICBudWxsLFxuICAgIFwiOmZpcnN0LWxldHRlclwiOiAxLFxuICAgIFwiOmZpcnN0LWxpbmVcIjogICAxLFxuICAgIFwiOmJlZm9yZVwiOiAgICAgICAxLFxuICAgIFwiOmFmdGVyXCI6ICAgICAgICAxXG59O1xuXG5Qc2V1ZG9zLkVMRU1FTlQgPSAxO1xuUHNldWRvcy5DTEFTUyA9IDI7XG5cblBzZXVkb3MuaXNFbGVtZW50ID0gZnVuY3Rpb24ocHNldWRvKXtcbiAgICByZXR1cm4gcHNldWRvLmluZGV4T2YoXCI6OlwiKSA9PT0gMCB8fCBQc2V1ZG9zW3BzZXVkby50b0xvd2VyQ2FzZSgpXSA9PT0gUHNldWRvcy5FTEVNRU5UO1xufTtcbi8qKlxuICogUmVwcmVzZW50cyBhbiBlbnRpcmUgc2luZ2xlIHNlbGVjdG9yLCBpbmNsdWRpbmcgYWxsIHBhcnRzIGJ1dCBub3RcbiAqIGluY2x1ZGluZyBtdWx0aXBsZSBzZWxlY3RvcnMgKHRob3NlIHNlcGFyYXRlZCBieSBjb21tYXMpLlxuICogQG5hbWVzcGFjZSBwYXJzZXJsaWIuY3NzXG4gKiBAY2xhc3MgU2VsZWN0b3JcbiAqIEBleHRlbmRzIHBhcnNlcmxpYi51dGlsLlN5bnRheFVuaXRcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gcGFydHMgQXJyYXkgb2Ygc2VsZWN0b3JzIHBhcnRzIG1ha2luZyB1cCB0aGlzIHNlbGVjdG9yLlxuICogQHBhcmFtIHtpbnR9IGxpbmUgVGhlIGxpbmUgb2YgdGV4dCBvbiB3aGljaCB0aGUgdW5pdCByZXNpZGVzLlxuICogQHBhcmFtIHtpbnR9IGNvbCBUaGUgY29sdW1uIG9mIHRleHQgb24gd2hpY2ggdGhlIHVuaXQgcmVzaWRlcy5cbiAqL1xuZnVuY3Rpb24gU2VsZWN0b3IocGFydHMsIGxpbmUsIGNvbCl7XG5cbiAgICBTeW50YXhVbml0LmNhbGwodGhpcywgcGFydHMuam9pbihcIiBcIiksIGxpbmUsIGNvbCwgUGFyc2VyLlNFTEVDVE9SX1RZUEUpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHBhcnRzIHRoYXQgbWFrZSB1cCB0aGUgc2VsZWN0b3IuXG4gICAgICogQHR5cGUgQXJyYXlcbiAgICAgKiBAcHJvcGVydHkgcGFydHNcbiAgICAgKi9cbiAgICB0aGlzLnBhcnRzID0gcGFydHM7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgc3BlY2lmaWNpdHkgb2YgdGhlIHNlbGVjdG9yLlxuICAgICAqIEB0eXBlIHBhcnNlcmxpYi5jc3MuU3BlY2lmaWNpdHlcbiAgICAgKiBAcHJvcGVydHkgc3BlY2lmaWNpdHlcbiAgICAgKi9cbiAgICB0aGlzLnNwZWNpZmljaXR5ID0gU3BlY2lmaWNpdHkuY2FsY3VsYXRlKHRoaXMpO1xuXG59XG5cblNlbGVjdG9yLnByb3RvdHlwZSA9IG5ldyBTeW50YXhVbml0KCk7XG5TZWxlY3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTZWxlY3RvcjtcblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgc2luZ2xlIHBhcnQgb2YgYSBzZWxlY3RvciBzdHJpbmcsIG1lYW5pbmcgYSBzaW5nbGUgc2V0IG9mXG4gKiBlbGVtZW50IG5hbWUgYW5kIG1vZGlmaWVycy4gVGhpcyBkb2VzIG5vdCBpbmNsdWRlIGNvbWJpbmF0b3JzIHN1Y2ggYXNcbiAqIHNwYWNlcywgKywgPiwgZXRjLlxuICogQG5hbWVzcGFjZSBwYXJzZXJsaWIuY3NzXG4gKiBAY2xhc3MgU2VsZWN0b3JQYXJ0XG4gKiBAZXh0ZW5kcyBwYXJzZXJsaWIudXRpbC5TeW50YXhVbml0XG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7U3RyaW5nfSBlbGVtZW50TmFtZSBUaGUgZWxlbWVudCBuYW1lIGluIHRoZSBzZWxlY3RvciBvciBudWxsXG4gKiAgICAgIGlmIHRoZXJlIGlzIG5vIGVsZW1lbnQgbmFtZS5cbiAqIEBwYXJhbSB7QXJyYXl9IG1vZGlmaWVycyBBcnJheSBvZiBpbmRpdmlkdWFsIG1vZGlmaWVycyBmb3IgdGhlIGVsZW1lbnQuXG4gKiAgICAgIE1heSBiZSBlbXB0eSBpZiB0aGVyZSBhcmUgbm9uZS5cbiAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0IFRoZSB0ZXh0IHJlcHJlc2VudGF0aW9uIG9mIHRoZSB1bml0LlxuICogQHBhcmFtIHtpbnR9IGxpbmUgVGhlIGxpbmUgb2YgdGV4dCBvbiB3aGljaCB0aGUgdW5pdCByZXNpZGVzLlxuICogQHBhcmFtIHtpbnR9IGNvbCBUaGUgY29sdW1uIG9mIHRleHQgb24gd2hpY2ggdGhlIHVuaXQgcmVzaWRlcy5cbiAqL1xuZnVuY3Rpb24gU2VsZWN0b3JQYXJ0KGVsZW1lbnROYW1lLCBtb2RpZmllcnMsIHRleHQsIGxpbmUsIGNvbCl7XG5cbiAgICBTeW50YXhVbml0LmNhbGwodGhpcywgdGV4dCwgbGluZSwgY29sLCBQYXJzZXIuU0VMRUNUT1JfUEFSVF9UWVBFKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSB0YWcgbmFtZSBvZiB0aGUgZWxlbWVudCB0byB3aGljaCB0aGlzIHBhcnRcbiAgICAgKiBvZiB0aGUgc2VsZWN0b3IgYWZmZWN0cy5cbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAcHJvcGVydHkgZWxlbWVudE5hbWVcbiAgICAgKi9cbiAgICB0aGlzLmVsZW1lbnROYW1lID0gZWxlbWVudE5hbWU7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgcGFydHMgdGhhdCBjb21lIGFmdGVyIHRoZSBlbGVtZW50IG5hbWUsIHN1Y2ggYXMgY2xhc3MgbmFtZXMsIElEcyxcbiAgICAgKiBwc2V1ZG8gY2xhc3Nlcy9lbGVtZW50cywgZXRjLlxuICAgICAqIEB0eXBlIEFycmF5XG4gICAgICogQHByb3BlcnR5IG1vZGlmaWVyc1xuICAgICAqL1xuICAgIHRoaXMubW9kaWZpZXJzID0gbW9kaWZpZXJzO1xuXG59XG5cblNlbGVjdG9yUGFydC5wcm90b3R5cGUgPSBuZXcgU3ludGF4VW5pdCgpO1xuU2VsZWN0b3JQYXJ0LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNlbGVjdG9yUGFydDtcblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgc2VsZWN0b3IgbW9kaWZpZXIgc3RyaW5nLCBtZWFuaW5nIGEgY2xhc3MgbmFtZSwgZWxlbWVudCBuYW1lLFxuICogZWxlbWVudCBJRCwgcHNldWRvIHJ1bGUsIGV0Yy5cbiAqIEBuYW1lc3BhY2UgcGFyc2VybGliLmNzc1xuICogQGNsYXNzIFNlbGVjdG9yU3ViUGFydFxuICogQGV4dGVuZHMgcGFyc2VybGliLnV0aWwuU3ludGF4VW5pdFxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge1N0cmluZ30gdGV4dCBUaGUgdGV4dCByZXByZXNlbnRhdGlvbiBvZiB0aGUgdW5pdC5cbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSB0eXBlIG9mIHNlbGVjdG9yIG1vZGlmaWVyLlxuICogQHBhcmFtIHtpbnR9IGxpbmUgVGhlIGxpbmUgb2YgdGV4dCBvbiB3aGljaCB0aGUgdW5pdCByZXNpZGVzLlxuICogQHBhcmFtIHtpbnR9IGNvbCBUaGUgY29sdW1uIG9mIHRleHQgb24gd2hpY2ggdGhlIHVuaXQgcmVzaWRlcy5cbiAqL1xuZnVuY3Rpb24gU2VsZWN0b3JTdWJQYXJ0KHRleHQsIHR5cGUsIGxpbmUsIGNvbCl7XG5cbiAgICBTeW50YXhVbml0LmNhbGwodGhpcywgdGV4dCwgbGluZSwgY29sLCBQYXJzZXIuU0VMRUNUT1JfU1VCX1BBUlRfVFlQRSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdHlwZSBvZiBtb2RpZmllci5cbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAcHJvcGVydHkgdHlwZVxuICAgICAqL1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG5cbiAgICAvKipcbiAgICAgKiBTb21lIHN1YnBhcnRzIGhhdmUgYXJndW1lbnRzLCB0aGlzIHJlcHJlc2VudHMgdGhlbS5cbiAgICAgKiBAdHlwZSBBcnJheVxuICAgICAqIEBwcm9wZXJ0eSBhcmdzXG4gICAgICovXG4gICAgdGhpcy5hcmdzID0gW107XG5cbn1cblxuU2VsZWN0b3JTdWJQYXJ0LnByb3RvdHlwZSA9IG5ldyBTeW50YXhVbml0KCk7XG5TZWxlY3RvclN1YlBhcnQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU2VsZWN0b3JTdWJQYXJ0O1xuXG4vKipcbiAqIFJlcHJlc2VudHMgYSBzZWxlY3RvcidzIHNwZWNpZmljaXR5LlxuICogQG5hbWVzcGFjZSBwYXJzZXJsaWIuY3NzXG4gKiBAY2xhc3MgU3BlY2lmaWNpdHlcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtpbnR9IGEgU2hvdWxkIGJlIDEgZm9yIGlubGluZSBzdHlsZXMsIHplcm8gZm9yIHN0eWxlc2hlZXQgc3R5bGVzXG4gKiBAcGFyYW0ge2ludH0gYiBOdW1iZXIgb2YgSUQgc2VsZWN0b3JzXG4gKiBAcGFyYW0ge2ludH0gYyBOdW1iZXIgb2YgY2xhc3NlcyBhbmQgcHNldWRvIGNsYXNzZXNcbiAqIEBwYXJhbSB7aW50fSBkIE51bWJlciBvZiBlbGVtZW50IG5hbWVzIGFuZCBwc2V1ZG8gZWxlbWVudHNcbiAqL1xuZnVuY3Rpb24gU3BlY2lmaWNpdHkoYSwgYiwgYywgZCl7XG4gICAgdGhpcy5hID0gYTtcbiAgICB0aGlzLmIgPSBiO1xuICAgIHRoaXMuYyA9IGM7XG4gICAgdGhpcy5kID0gZDtcbn1cblxuU3BlY2lmaWNpdHkucHJvdG90eXBlID0ge1xuICAgIGNvbnN0cnVjdG9yOiBTcGVjaWZpY2l0eSxcblxuICAgIC8qKlxuICAgICAqIENvbXBhcmUgdGhpcyBzcGVjaWZpY2l0eSB0byBhbm90aGVyLlxuICAgICAqIEBwYXJhbSB7U3BlY2lmaWNpdHl9IG90aGVyIFRoZSBvdGhlciBzcGVjaWZpY2l0eSB0byBjb21wYXJlIHRvLlxuICAgICAqIEByZXR1cm4ge2ludH0gLTEgaWYgdGhlIG90aGVyIHNwZWNpZmljaXR5IGlzIGxhcmdlciwgMSBpZiBzbWFsbGVyLCAwIGlmIGVxdWFsLlxuICAgICAqIEBtZXRob2QgY29tcGFyZVxuICAgICAqL1xuICAgIGNvbXBhcmU6IGZ1bmN0aW9uKG90aGVyKXtcbiAgICAgICAgdmFyIGNvbXBzID0gW1wiYVwiLCBcImJcIiwgXCJjXCIsIFwiZFwiXSxcbiAgICAgICAgICAgIGksIGxlbjtcblxuICAgICAgICBmb3IgKGk9MCwgbGVuPWNvbXBzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKXtcbiAgICAgICAgICAgIGlmICh0aGlzW2NvbXBzW2ldXSA8IG90aGVyW2NvbXBzW2ldXSl7XG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzW2NvbXBzW2ldXSA+IG90aGVyW2NvbXBzW2ldXSl7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gMDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG51bWVyaWMgdmFsdWUgZm9yIHRoZSBzcGVjaWZpY2l0eS5cbiAgICAgKiBAcmV0dXJuIHtpbnR9IFRoZSBudW1lcmljIHZhbHVlIGZvciB0aGUgc3BlY2lmaWNpdHkuXG4gICAgICogQG1ldGhvZCB2YWx1ZU9mXG4gICAgICovXG4gICAgdmFsdWVPZjogZnVuY3Rpb24oKXtcbiAgICAgICAgcmV0dXJuICh0aGlzLmEgKiAxMDAwKSArICh0aGlzLmIgKiAxMDApICsgKHRoaXMuYyAqIDEwKSArIHRoaXMuZDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBmb3Igc3BlY2lmaWNpdHkuXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBUaGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHNwZWNpZmljaXR5LlxuICAgICAqIEBtZXRob2QgdG9TdHJpbmdcbiAgICAgKi9cbiAgICB0b1N0cmluZzogZnVuY3Rpb24oKXtcbiAgICAgICAgcmV0dXJuIHRoaXMuYSArIFwiLFwiICsgdGhpcy5iICsgXCIsXCIgKyB0aGlzLmMgKyBcIixcIiArIHRoaXMuZDtcbiAgICB9XG5cbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgc3BlY2lmaWNpdHkgb2YgdGhlIGdpdmVuIHNlbGVjdG9yLlxuICogQHBhcmFtIHtwYXJzZXJsaWIuY3NzLlNlbGVjdG9yfSBUaGUgc2VsZWN0b3IgdG8gY2FsY3VsYXRlIHNwZWNpZmljaXR5IGZvci5cbiAqIEByZXR1cm4ge3BhcnNlcmxpYi5jc3MuU3BlY2lmaWNpdHl9IFRoZSBzcGVjaWZpY2l0eSBvZiB0aGUgc2VsZWN0b3IuXG4gKiBAc3RhdGljXG4gKiBAbWV0aG9kIGNhbGN1bGF0ZVxuICovXG5TcGVjaWZpY2l0eS5jYWxjdWxhdGUgPSBmdW5jdGlvbihzZWxlY3Rvcil7XG5cbiAgICB2YXIgaSwgbGVuLFxuICAgICAgICBwYXJ0LFxuICAgICAgICBiPTAsIGM9MCwgZD0wO1xuXG4gICAgZnVuY3Rpb24gdXBkYXRlVmFsdWVzKHBhcnQpe1xuXG4gICAgICAgIHZhciBpLCBqLCBsZW4sIG51bSxcbiAgICAgICAgICAgIGVsZW1lbnROYW1lID0gcGFydC5lbGVtZW50TmFtZSA/IHBhcnQuZWxlbWVudE5hbWUudGV4dCA6IFwiXCIsXG4gICAgICAgICAgICBtb2RpZmllcjtcblxuICAgICAgICBpZiAoZWxlbWVudE5hbWUgJiYgZWxlbWVudE5hbWUuY2hhckF0KGVsZW1lbnROYW1lLmxlbmd0aC0xKSAhPT0gXCIqXCIpIHtcbiAgICAgICAgICAgIGQrKztcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaT0wLCBsZW49cGFydC5tb2RpZmllcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspe1xuICAgICAgICAgICAgbW9kaWZpZXIgPSBwYXJ0Lm1vZGlmaWVyc1tpXTtcbiAgICAgICAgICAgIHN3aXRjaChtb2RpZmllci50eXBlKXtcbiAgICAgICAgICAgICAgICBjYXNlIFwiY2xhc3NcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwiYXR0cmlidXRlXCI6XG4gICAgICAgICAgICAgICAgICAgIGMrKztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlIFwiaWRcIjpcbiAgICAgICAgICAgICAgICAgICAgYisrO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgXCJwc2V1ZG9cIjpcbiAgICAgICAgICAgICAgICAgICAgaWYgKFBzZXVkb3MuaXNFbGVtZW50KG1vZGlmaWVyLnRleHQpKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGQrKztcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgXCJub3RcIjpcbiAgICAgICAgICAgICAgICAgICAgZm9yIChqPTAsIG51bT1tb2RpZmllci5hcmdzLmxlbmd0aDsgaiA8IG51bTsgaisrKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZVZhbHVlcyhtb2RpZmllci5hcmdzW2pdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgfVxuICAgIH1cblxuICAgIGZvciAoaT0wLCBsZW49c2VsZWN0b3IucGFydHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspe1xuICAgICAgICBwYXJ0ID0gc2VsZWN0b3IucGFydHNbaV07XG5cbiAgICAgICAgaWYgKHBhcnQgaW5zdGFuY2VvZiBTZWxlY3RvclBhcnQpe1xuICAgICAgICAgICAgdXBkYXRlVmFsdWVzKHBhcnQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBTcGVjaWZpY2l0eSgwLCBiLCBjLCBkKTtcbn07XG5cbnZhciBoID0gL15bMC05YS1mQS1GXSQvLFxuICAgIC8vbm9uYXNjaWkgPSAvXltcXHUwMDgwLVxcdUZGRkZdJC8sXG4gICAgbmwgPSAvXFxufFxcclxcbnxcXHJ8XFxmLztcblxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gSGVscGVyIGZ1bmN0aW9uc1xuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cbmZ1bmN0aW9uIGlzSGV4RGlnaXQoYyl7XG4gICAgcmV0dXJuIGMgIT09IG51bGwgJiYgaC50ZXN0KGMpO1xufVxuXG5mdW5jdGlvbiBpc0RpZ2l0KGMpe1xuICAgIHJldHVybiBjICE9PSBudWxsICYmIC9cXGQvLnRlc3QoYyk7XG59XG5cbmZ1bmN0aW9uIGlzV2hpdGVzcGFjZShjKXtcbiAgICByZXR1cm4gYyAhPT0gbnVsbCAmJiAvXFxzLy50ZXN0KGMpO1xufVxuXG5mdW5jdGlvbiBpc05ld0xpbmUoYyl7XG4gICAgcmV0dXJuIGMgIT09IG51bGwgJiYgbmwudGVzdChjKTtcbn1cblxuZnVuY3Rpb24gaXNOYW1lU3RhcnQoYyl7XG4gICAgcmV0dXJuIGMgIT09IG51bGwgJiYgKC9bYS16X1xcdTAwODAtXFx1RkZGRlxcXFxdL2kudGVzdChjKSk7XG59XG5cbmZ1bmN0aW9uIGlzTmFtZUNoYXIoYyl7XG4gICAgcmV0dXJuIGMgIT09IG51bGwgJiYgKGlzTmFtZVN0YXJ0KGMpIHx8IC9bMC05XFwtXFxcXF0vLnRlc3QoYykpO1xufVxuXG5mdW5jdGlvbiBpc0lkZW50U3RhcnQoYyl7XG4gICAgcmV0dXJuIGMgIT09IG51bGwgJiYgKGlzTmFtZVN0YXJ0KGMpIHx8IC9cXC1cXFxcLy50ZXN0KGMpKTtcbn1cblxuZnVuY3Rpb24gbWl4KHJlY2VpdmVyLCBzdXBwbGllcil7XG5cdGZvciAodmFyIHByb3AgaW4gc3VwcGxpZXIpe1xuXHRcdGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc3VwcGxpZXIsIHByb3ApKXtcblx0XHRcdHJlY2VpdmVyW3Byb3BdID0gc3VwcGxpZXJbcHJvcF07XG5cdFx0fVxuXHR9XG5cdHJldHVybiByZWNlaXZlcjtcbn1cblxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gQ1NTIFRva2VuIFN0cmVhbVxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cbi8qKlxuICogQSB0b2tlbiBzdHJlYW0gdGhhdCBwcm9kdWNlcyBDU1MgdG9rZW5zLlxuICogQHBhcmFtIHtTdHJpbmd8UmVhZGVyfSBpbnB1dCBUaGUgc291cmNlIG9mIHRleHQgdG8gdG9rZW5pemUuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBjbGFzcyBUb2tlblN0cmVhbVxuICogQG5hbWVzcGFjZSBwYXJzZXJsaWIuY3NzXG4gKi9cbmZ1bmN0aW9uIFRva2VuU3RyZWFtKGlucHV0KXtcblx0VG9rZW5TdHJlYW1CYXNlLmNhbGwodGhpcywgaW5wdXQsIFRva2Vucyk7XG59XG5cblRva2VuU3RyZWFtLnByb3RvdHlwZSA9IG1peChuZXcgVG9rZW5TdHJlYW1CYXNlKCksIHtcblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlcyB0aGUgVG9rZW5TdHJlYW1CYXNlIG1ldGhvZCBvZiB0aGUgc2FtZSBuYW1lXG4gICAgICogdG8gcHJvZHVjZSBDU1MgdG9rZW5zLlxuICAgICAqIEBwYXJhbSB7dmFyaWFudH0gY2hhbm5lbCBUaGUgbmFtZSBvZiB0aGUgY2hhbm5lbCB0byB1c2VcbiAgICAgKiAgICAgIGZvciB0aGUgbmV4dCB0b2tlbi5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IEEgdG9rZW4gb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgbmV4dCB0b2tlbi5cbiAgICAgKiBAbWV0aG9kIF9nZXRUb2tlblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2dldFRva2VuOiBmdW5jdGlvbihjaGFubmVsKXtcblxuICAgICAgICB2YXIgYyxcbiAgICAgICAgICAgIHJlYWRlciA9IHRoaXMuX3JlYWRlcixcbiAgICAgICAgICAgIHRva2VuICAgPSBudWxsLFxuICAgICAgICAgICAgc3RhcnRMaW5lICAgPSByZWFkZXIuZ2V0TGluZSgpLFxuICAgICAgICAgICAgc3RhcnRDb2wgICAgPSByZWFkZXIuZ2V0Q29sKCk7XG5cbiAgICAgICAgYyA9IHJlYWRlci5yZWFkKCk7XG5cblxuICAgICAgICB3aGlsZShjKXtcbiAgICAgICAgICAgIHN3aXRjaChjKXtcblxuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICogUG90ZW50aWFsIHRva2VuczpcbiAgICAgICAgICAgICAgICAgKiAtIENPTU1FTlRcbiAgICAgICAgICAgICAgICAgKiAtIFNMQVNIXG4gICAgICAgICAgICAgICAgICogLSBDSEFSXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgY2FzZSBcIi9cIjpcblxuICAgICAgICAgICAgICAgICAgICBpZihyZWFkZXIucGVlaygpID09PSBcIipcIil7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IHRoaXMuY29tbWVudFRva2VuKGMsIHN0YXJ0TGluZSwgc3RhcnRDb2wpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLmNoYXJUb2tlbihjLCBzdGFydExpbmUsIHN0YXJ0Q29sKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICogUG90ZW50aWFsIHRva2VuczpcbiAgICAgICAgICAgICAgICAgKiAtIERBU0hNQVRDSFxuICAgICAgICAgICAgICAgICAqIC0gSU5DTFVERVNcbiAgICAgICAgICAgICAgICAgKiAtIFBSRUZJWE1BVENIXG4gICAgICAgICAgICAgICAgICogLSBTVUZGSVhNQVRDSFxuICAgICAgICAgICAgICAgICAqIC0gU1VCU1RSSU5HTUFUQ0hcbiAgICAgICAgICAgICAgICAgKiAtIENIQVJcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBjYXNlIFwifFwiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJ+XCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcIl5cIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwiJFwiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCIqXCI6XG4gICAgICAgICAgICAgICAgICAgIGlmKHJlYWRlci5wZWVrKCkgPT09IFwiPVwiKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuID0gdGhpcy5jb21wYXJpc29uVG9rZW4oYywgc3RhcnRMaW5lLCBzdGFydENvbCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IHRoaXMuY2hhclRva2VuKGMsIHN0YXJ0TGluZSwgc3RhcnRDb2wpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgKiBQb3RlbnRpYWwgdG9rZW5zOlxuICAgICAgICAgICAgICAgICAqIC0gU1RSSU5HXG4gICAgICAgICAgICAgICAgICogLSBJTlZBTElEXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgY2FzZSBcIlxcXCJcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwiJ1wiOlxuICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IHRoaXMuc3RyaW5nVG9rZW4oYywgc3RhcnRMaW5lLCBzdGFydENvbCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgKiBQb3RlbnRpYWwgdG9rZW5zOlxuICAgICAgICAgICAgICAgICAqIC0gSEFTSFxuICAgICAgICAgICAgICAgICAqIC0gQ0hBUlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGNhc2UgXCIjXCI6XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc05hbWVDaGFyKHJlYWRlci5wZWVrKCkpKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuID0gdGhpcy5oYXNoVG9rZW4oYywgc3RhcnRMaW5lLCBzdGFydENvbCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IHRoaXMuY2hhclRva2VuKGMsIHN0YXJ0TGluZSwgc3RhcnRDb2wpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgKiBQb3RlbnRpYWwgdG9rZW5zOlxuICAgICAgICAgICAgICAgICAqIC0gRE9UXG4gICAgICAgICAgICAgICAgICogLSBOVU1CRVJcbiAgICAgICAgICAgICAgICAgKiAtIERJTUVOU0lPTlxuICAgICAgICAgICAgICAgICAqIC0gUEVSQ0VOVEFHRVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGNhc2UgXCIuXCI6XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0RpZ2l0KHJlYWRlci5wZWVrKCkpKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuID0gdGhpcy5udW1iZXJUb2tlbihjLCBzdGFydExpbmUsIHN0YXJ0Q29sKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuID0gdGhpcy5jaGFyVG9rZW4oYywgc3RhcnRMaW5lLCBzdGFydENvbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAqIFBvdGVudGlhbCB0b2tlbnM6XG4gICAgICAgICAgICAgICAgICogLSBDRENcbiAgICAgICAgICAgICAgICAgKiAtIE1JTlVTXG4gICAgICAgICAgICAgICAgICogLSBOVU1CRVJcbiAgICAgICAgICAgICAgICAgKiAtIERJTUVOU0lPTlxuICAgICAgICAgICAgICAgICAqIC0gUEVSQ0VOVEFHRVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGNhc2UgXCItXCI6XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWFkZXIucGVlaygpID09PSBcIi1cIil7ICAvL2NvdWxkIGJlIGNsb3NpbmcgSFRNTC1zdHlsZSBjb21tZW50XG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IHRoaXMuaHRtbENvbW1lbnRFbmRUb2tlbihjLCBzdGFydExpbmUsIHN0YXJ0Q29sKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpc05hbWVTdGFydChyZWFkZXIucGVlaygpKSl7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IHRoaXMuaWRlbnRPckZ1bmN0aW9uVG9rZW4oYywgc3RhcnRMaW5lLCBzdGFydENvbCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IHRoaXMuY2hhclRva2VuKGMsIHN0YXJ0TGluZSwgc3RhcnRDb2wpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgKiBQb3RlbnRpYWwgdG9rZW5zOlxuICAgICAgICAgICAgICAgICAqIC0gSU1QT1JUQU5UX1NZTVxuICAgICAgICAgICAgICAgICAqIC0gQ0hBUlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGNhc2UgXCIhXCI6XG4gICAgICAgICAgICAgICAgICAgIHRva2VuID0gdGhpcy5pbXBvcnRhbnRUb2tlbihjLCBzdGFydExpbmUsIHN0YXJ0Q29sKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAqIEFueSBhdC1rZXl3b3JkIG9yIENIQVJcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBjYXNlIFwiQFwiOlxuICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IHRoaXMuYXRSdWxlVG9rZW4oYywgc3RhcnRMaW5lLCBzdGFydENvbCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgKiBQb3RlbnRpYWwgdG9rZW5zOlxuICAgICAgICAgICAgICAgICAqIC0gTk9UXG4gICAgICAgICAgICAgICAgICogLSBDSEFSXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgY2FzZSBcIjpcIjpcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLm5vdFRva2VuKGMsIHN0YXJ0TGluZSwgc3RhcnRDb2wpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICogUG90ZW50aWFsIHRva2VuczpcbiAgICAgICAgICAgICAgICAgKiAtIENET1xuICAgICAgICAgICAgICAgICAqIC0gQ0hBUlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGNhc2UgXCI8XCI6XG4gICAgICAgICAgICAgICAgICAgIHRva2VuID0gdGhpcy5odG1sQ29tbWVudFN0YXJ0VG9rZW4oYywgc3RhcnRMaW5lLCBzdGFydENvbCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgKiBQb3RlbnRpYWwgdG9rZW5zOlxuICAgICAgICAgICAgICAgICAqIC0gVU5JQ09ERV9SQU5HRVxuICAgICAgICAgICAgICAgICAqIC0gVVJMXG4gICAgICAgICAgICAgICAgICogLSBDSEFSXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgY2FzZSBcIlVcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwidVwiOlxuICAgICAgICAgICAgICAgICAgICBpZiAocmVhZGVyLnBlZWsoKSA9PT0gXCIrXCIpe1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLnVuaWNvZGVSYW5nZVRva2VuKGMsIHN0YXJ0TGluZSwgc3RhcnRDb2wpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG5cbiAgICAgICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgICAgICogUG90ZW50aWFsIHRva2VuczpcbiAgICAgICAgICAgICAgICAgICAgICogLSBOVU1CRVJcbiAgICAgICAgICAgICAgICAgICAgICogLSBESU1FTlNJT05cbiAgICAgICAgICAgICAgICAgICAgICogLSBMRU5HVEhcbiAgICAgICAgICAgICAgICAgICAgICogLSBGUkVRXG4gICAgICAgICAgICAgICAgICAgICAqIC0gVElNRVxuICAgICAgICAgICAgICAgICAgICAgKiAtIEVNU1xuICAgICAgICAgICAgICAgICAgICAgKiAtIEVYU1xuICAgICAgICAgICAgICAgICAgICAgKiAtIEFOR0xFXG4gICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNEaWdpdChjKSl7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IHRoaXMubnVtYmVyVG9rZW4oYywgc3RhcnRMaW5lLCBzdGFydENvbCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZVxuXG4gICAgICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICAgICAqIFBvdGVudGlhbCB0b2tlbnM6XG4gICAgICAgICAgICAgICAgICAgICAqIC0gU1xuICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzV2hpdGVzcGFjZShjKSl7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IHRoaXMud2hpdGVzcGFjZVRva2VuKGMsIHN0YXJ0TGluZSwgc3RhcnRDb2wpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2VcblxuICAgICAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAgICAgKiBQb3RlbnRpYWwgdG9rZW5zOlxuICAgICAgICAgICAgICAgICAgICAgKiAtIElERU5UXG4gICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNJZGVudFN0YXJ0KGMpKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuID0gdGhpcy5pZGVudE9yRnVuY3Rpb25Ub2tlbihjLCBzdGFydExpbmUsIHN0YXJ0Q29sKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlXG5cbiAgICAgICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgICAgICogUG90ZW50aWFsIHRva2VuczpcbiAgICAgICAgICAgICAgICAgICAgICogLSBDSEFSXG4gICAgICAgICAgICAgICAgICAgICAqIC0gUExVU1xuICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLmNoYXJUb2tlbihjLCBzdGFydExpbmUsIHN0YXJ0Q29sKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG5cblxuXG5cblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvL21ha2Ugc3VyZSB0aGlzIHRva2VuIGlzIHdhbnRlZFxuICAgICAgICAgICAgLy9UT0RPOiBjaGVjayBjaGFubmVsXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdG9rZW4gJiYgYyA9PT0gbnVsbCl7XG4gICAgICAgICAgICB0b2tlbiA9IHRoaXMuY3JlYXRlVG9rZW4oVG9rZW5zLkVPRixudWxsLHN0YXJ0TGluZSxzdGFydENvbCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgfSxcblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIE1ldGhvZHMgdG8gY3JlYXRlIHRva2Vuc1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgLyoqXG4gICAgICogUHJvZHVjZXMgYSB0b2tlbiBiYXNlZCBvbiBhdmFpbGFibGUgZGF0YSBhbmQgdGhlIGN1cnJlbnRcbiAgICAgKiByZWFkZXIgcG9zaXRpb24gaW5mb3JtYXRpb24uIFRoaXMgbWV0aG9kIGlzIGNhbGxlZCBieSBvdGhlclxuICAgICAqIHByaXZhdGUgbWV0aG9kcyB0byBjcmVhdGUgdG9rZW5zIGFuZCBpcyBuZXZlciBjYWxsZWQgZGlyZWN0bHkuXG4gICAgICogQHBhcmFtIHtpbnR9IHR0IFRoZSB0b2tlbiB0eXBlLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZSBUaGUgdGV4dCB2YWx1ZSBvZiB0aGUgdG9rZW4uXG4gICAgICogQHBhcmFtIHtpbnR9IHN0YXJ0TGluZSBUaGUgYmVnaW5uaW5nIGxpbmUgZm9yIHRoZSBjaGFyYWN0ZXIuXG4gICAgICogQHBhcmFtIHtpbnR9IHN0YXJ0Q29sIFRoZSBiZWdpbm5pbmcgY29sdW1uIGZvciB0aGUgY2hhcmFjdGVyLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIChPcHRpb25hbCkgU3BlY2lmaWVzIGEgY2hhbm5lbCBwcm9wZXJ0eVxuICAgICAqICAgICAgdG8gaW5kaWNhdGUgdGhhdCBhIGRpZmZlcmVudCBjaGFubmVsIHNob3VsZCBiZSBzY2FubmVkXG4gICAgICogICAgICBhbmQvb3IgYSBoaWRlIHByb3BlcnR5IGluZGljYXRpbmcgdGhhdCB0aGUgdG9rZW4gc2hvdWxkXG4gICAgICogICAgICBiZSBoaWRkZW4uXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBBIHRva2VuIG9iamVjdC5cbiAgICAgKiBAbWV0aG9kIGNyZWF0ZVRva2VuXG4gICAgICovXG4gICAgY3JlYXRlVG9rZW46IGZ1bmN0aW9uKHR0LCB2YWx1ZSwgc3RhcnRMaW5lLCBzdGFydENvbCwgb3B0aW9ucyl7XG4gICAgICAgIHZhciByZWFkZXIgPSB0aGlzLl9yZWFkZXI7XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2YWx1ZTogICAgICB2YWx1ZSxcbiAgICAgICAgICAgIHR5cGU6ICAgICAgIHR0LFxuICAgICAgICAgICAgY2hhbm5lbDogICAgb3B0aW9ucy5jaGFubmVsLFxuICAgICAgICAgICAgZW5kQ2hhcjogICAgb3B0aW9ucy5lbmRDaGFyLFxuICAgICAgICAgICAgaGlkZTogICAgICAgb3B0aW9ucy5oaWRlIHx8IGZhbHNlLFxuICAgICAgICAgICAgc3RhcnRMaW5lOiAgc3RhcnRMaW5lLFxuICAgICAgICAgICAgc3RhcnRDb2w6ICAgc3RhcnRDb2wsXG4gICAgICAgICAgICBlbmRMaW5lOiAgICByZWFkZXIuZ2V0TGluZSgpLFxuICAgICAgICAgICAgZW5kQ29sOiAgICAgcmVhZGVyLmdldENvbCgpXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIE1ldGhvZHMgdG8gY3JlYXRlIHNwZWNpZmljIHRva2Vuc1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgLyoqXG4gICAgICogUHJvZHVjZXMgYSB0b2tlbiBmb3IgYW55IGF0LXJ1bGUuIElmIHRoZSBhdC1ydWxlIGlzIHVua25vd24sIHRoZW5cbiAgICAgKiB0aGUgdG9rZW4gaXMgZm9yIGEgc2luZ2xlIFwiQFwiIGNoYXJhY3Rlci5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZmlyc3QgVGhlIGZpcnN0IGNoYXJhY3RlciBmb3IgdGhlIHRva2VuLlxuICAgICAqIEBwYXJhbSB7aW50fSBzdGFydExpbmUgVGhlIGJlZ2lubmluZyBsaW5lIGZvciB0aGUgY2hhcmFjdGVyLlxuICAgICAqIEBwYXJhbSB7aW50fSBzdGFydENvbCBUaGUgYmVnaW5uaW5nIGNvbHVtbiBmb3IgdGhlIGNoYXJhY3Rlci5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IEEgdG9rZW4gb2JqZWN0LlxuICAgICAqIEBtZXRob2QgYXRSdWxlVG9rZW5cbiAgICAgKi9cbiAgICBhdFJ1bGVUb2tlbjogZnVuY3Rpb24oZmlyc3QsIHN0YXJ0TGluZSwgc3RhcnRDb2wpe1xuICAgICAgICB2YXIgcnVsZSAgICA9IGZpcnN0LFxuICAgICAgICAgICAgcmVhZGVyICA9IHRoaXMuX3JlYWRlcixcbiAgICAgICAgICAgIHR0ICAgICAgPSBUb2tlbnMuQ0hBUixcbiAgICAgICAgICAgIGlkZW50O1xuXG4gICAgICAgIC8qXG4gICAgICAgICAqIEZpcnN0LCBtYXJrIHdoZXJlIHdlIGFyZS4gVGhlcmUgYXJlIG9ubHkgZm91ciBAIHJ1bGVzLFxuICAgICAgICAgKiBzbyBhbnl0aGluZyBlbHNlIGlzIHJlYWxseSBqdXN0IGFuIGludmFsaWQgdG9rZW4uXG4gICAgICAgICAqIEJhc2ljYWxseSwgaWYgdGhpcyBkb2Vzbid0IG1hdGNoIG9uZSBvZiB0aGUga25vd24gQFxuICAgICAgICAgKiBydWxlcywganVzdCByZXR1cm4gJ0AnIGFzIGFuIHVua25vd24gdG9rZW4gYW5kIGFsbG93XG4gICAgICAgICAqIHBhcnNpbmcgdG8gY29udGludWUgYWZ0ZXIgdGhhdCBwb2ludC5cbiAgICAgICAgICovXG4gICAgICAgIHJlYWRlci5tYXJrKCk7XG5cbiAgICAgICAgLy90cnkgdG8gZmluZCB0aGUgYXQta2V5d29yZFxuICAgICAgICBpZGVudCA9IHRoaXMucmVhZE5hbWUoKTtcbiAgICAgICAgcnVsZSA9IGZpcnN0ICsgaWRlbnQ7XG4gICAgICAgIHR0ID0gVG9rZW5zLnR5cGUocnVsZS50b0xvd2VyQ2FzZSgpKTtcblxuICAgICAgICAvL2lmIGl0J3Mgbm90IHZhbGlkLCB1c2UgdGhlIGZpcnN0IGNoYXJhY3RlciBvbmx5IGFuZCByZXNldCB0aGUgcmVhZGVyXG4gICAgICAgIGlmICh0dCA9PT0gVG9rZW5zLkNIQVIgfHwgdHQgPT09IFRva2Vucy5VTktOT1dOKXtcbiAgICAgICAgICAgIGlmIChydWxlLmxlbmd0aCA+IDEpe1xuICAgICAgICAgICAgICAgIHR0ID0gVG9rZW5zLlVOS05PV05fU1lNO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0dCA9IFRva2Vucy5DSEFSO1xuICAgICAgICAgICAgICAgIHJ1bGUgPSBmaXJzdDtcbiAgICAgICAgICAgICAgICByZWFkZXIucmVzZXQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVRva2VuKHR0LCBydWxlLCBzdGFydExpbmUsIHN0YXJ0Q29sKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUHJvZHVjZXMgYSBjaGFyYWN0ZXIgdG9rZW4gYmFzZWQgb24gdGhlIGdpdmVuIGNoYXJhY3RlclxuICAgICAqIGFuZCBsb2NhdGlvbiBpbiB0aGUgc3RyZWFtLiBJZiB0aGVyZSdzIGEgc3BlY2lhbCAobm9uLXN0YW5kYXJkKVxuICAgICAqIHRva2VuIG5hbWUsIHRoaXMgaXMgdXNlZDsgb3RoZXJ3aXNlIENIQVIgaXMgdXNlZC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYyBUaGUgY2hhcmFjdGVyIGZvciB0aGUgdG9rZW4uXG4gICAgICogQHBhcmFtIHtpbnR9IHN0YXJ0TGluZSBUaGUgYmVnaW5uaW5nIGxpbmUgZm9yIHRoZSBjaGFyYWN0ZXIuXG4gICAgICogQHBhcmFtIHtpbnR9IHN0YXJ0Q29sIFRoZSBiZWdpbm5pbmcgY29sdW1uIGZvciB0aGUgY2hhcmFjdGVyLlxuICAgICAqIEByZXR1cm4ge09iamVjdH0gQSB0b2tlbiBvYmplY3QuXG4gICAgICogQG1ldGhvZCBjaGFyVG9rZW5cbiAgICAgKi9cbiAgICBjaGFyVG9rZW46IGZ1bmN0aW9uKGMsIHN0YXJ0TGluZSwgc3RhcnRDb2wpe1xuICAgICAgICB2YXIgdHQgPSBUb2tlbnMudHlwZShjKTtcbiAgICAgICAgdmFyIG9wdHMgPSB7fTtcblxuICAgICAgICBpZiAodHQgPT09IC0xKXtcbiAgICAgICAgICAgIHR0ID0gVG9rZW5zLkNIQVI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvcHRzLmVuZENoYXIgPSBUb2tlbnNbdHRdLmVuZENoYXI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVUb2tlbih0dCwgYywgc3RhcnRMaW5lLCBzdGFydENvbCwgb3B0cyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFByb2R1Y2VzIGEgY2hhcmFjdGVyIHRva2VuIGJhc2VkIG9uIHRoZSBnaXZlbiBjaGFyYWN0ZXJcbiAgICAgKiBhbmQgbG9jYXRpb24gaW4gdGhlIHN0cmVhbS4gSWYgdGhlcmUncyBhIHNwZWNpYWwgKG5vbi1zdGFuZGFyZClcbiAgICAgKiB0b2tlbiBuYW1lLCB0aGlzIGlzIHVzZWQ7IG90aGVyd2lzZSBDSEFSIGlzIHVzZWQuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGZpcnN0IFRoZSBmaXJzdCBjaGFyYWN0ZXIgZm9yIHRoZSB0b2tlbi5cbiAgICAgKiBAcGFyYW0ge2ludH0gc3RhcnRMaW5lIFRoZSBiZWdpbm5pbmcgbGluZSBmb3IgdGhlIGNoYXJhY3Rlci5cbiAgICAgKiBAcGFyYW0ge2ludH0gc3RhcnRDb2wgVGhlIGJlZ2lubmluZyBjb2x1bW4gZm9yIHRoZSBjaGFyYWN0ZXIuXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBBIHRva2VuIG9iamVjdC5cbiAgICAgKiBAbWV0aG9kIGNvbW1lbnRUb2tlblxuICAgICAqL1xuICAgIGNvbW1lbnRUb2tlbjogZnVuY3Rpb24oZmlyc3QsIHN0YXJ0TGluZSwgc3RhcnRDb2wpe1xuICAgICAgICB2YXIgY29tbWVudCA9IHRoaXMucmVhZENvbW1lbnQoZmlyc3QpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVRva2VuKFRva2Vucy5DT01NRU5ULCBjb21tZW50LCBzdGFydExpbmUsIHN0YXJ0Q29sKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUHJvZHVjZXMgYSBjb21wYXJpc29uIHRva2VuIGJhc2VkIG9uIHRoZSBnaXZlbiBjaGFyYWN0ZXJcbiAgICAgKiBhbmQgbG9jYXRpb24gaW4gdGhlIHN0cmVhbS4gVGhlIG5leHQgY2hhcmFjdGVyIG11c3QgYmVcbiAgICAgKiByZWFkIGFuZCBpcyBhbHJlYWR5IGtub3duIHRvIGJlIGFuIGVxdWFscyBzaWduLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjIFRoZSBjaGFyYWN0ZXIgZm9yIHRoZSB0b2tlbi5cbiAgICAgKiBAcGFyYW0ge2ludH0gc3RhcnRMaW5lIFRoZSBiZWdpbm5pbmcgbGluZSBmb3IgdGhlIGNoYXJhY3Rlci5cbiAgICAgKiBAcGFyYW0ge2ludH0gc3RhcnRDb2wgVGhlIGJlZ2lubmluZyBjb2x1bW4gZm9yIHRoZSBjaGFyYWN0ZXIuXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBBIHRva2VuIG9iamVjdC5cbiAgICAgKiBAbWV0aG9kIGNvbXBhcmlzb25Ub2tlblxuICAgICAqL1xuICAgIGNvbXBhcmlzb25Ub2tlbjogZnVuY3Rpb24oYywgc3RhcnRMaW5lLCBzdGFydENvbCl7XG4gICAgICAgIHZhciByZWFkZXIgID0gdGhpcy5fcmVhZGVyLFxuICAgICAgICAgICAgY29tcGFyaXNvbiAgPSBjICsgcmVhZGVyLnJlYWQoKSxcbiAgICAgICAgICAgIHR0ICAgICAgPSBUb2tlbnMudHlwZShjb21wYXJpc29uKSB8fCBUb2tlbnMuQ0hBUjtcblxuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVUb2tlbih0dCwgY29tcGFyaXNvbiwgc3RhcnRMaW5lLCBzdGFydENvbCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFByb2R1Y2VzIGEgaGFzaCB0b2tlbiBiYXNlZCBvbiB0aGUgc3BlY2lmaWVkIGluZm9ybWF0aW9uLiBUaGVcbiAgICAgKiBmaXJzdCBjaGFyYWN0ZXIgcHJvdmlkZWQgaXMgdGhlIHBvdW5kIHNpZ24gKCMpIGFuZCB0aGVuIHRoaXNcbiAgICAgKiBtZXRob2QgcmVhZHMgYSBuYW1lIGFmdGVyd2FyZC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZmlyc3QgVGhlIGZpcnN0IGNoYXJhY3RlciAoIykgaW4gdGhlIGhhc2ggbmFtZS5cbiAgICAgKiBAcGFyYW0ge2ludH0gc3RhcnRMaW5lIFRoZSBiZWdpbm5pbmcgbGluZSBmb3IgdGhlIGNoYXJhY3Rlci5cbiAgICAgKiBAcGFyYW0ge2ludH0gc3RhcnRDb2wgVGhlIGJlZ2lubmluZyBjb2x1bW4gZm9yIHRoZSBjaGFyYWN0ZXIuXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBBIHRva2VuIG9iamVjdC5cbiAgICAgKiBAbWV0aG9kIGhhc2hUb2tlblxuICAgICAqL1xuICAgIGhhc2hUb2tlbjogZnVuY3Rpb24oZmlyc3QsIHN0YXJ0TGluZSwgc3RhcnRDb2wpe1xuICAgICAgICB2YXIgbmFtZSAgICA9IHRoaXMucmVhZE5hbWUoZmlyc3QpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVRva2VuKFRva2Vucy5IQVNILCBuYW1lLCBzdGFydExpbmUsIHN0YXJ0Q29sKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUHJvZHVjZXMgYSBDRE8gb3IgQ0hBUiB0b2tlbiBiYXNlZCBvbiB0aGUgc3BlY2lmaWVkIGluZm9ybWF0aW9uLiBUaGVcbiAgICAgKiBmaXJzdCBjaGFyYWN0ZXIgaXMgcHJvdmlkZWQgYW5kIHRoZSByZXN0IGlzIHJlYWQgYnkgdGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZVxuICAgICAqIHRoZSBjb3JyZWN0IHRva2VuIHRvIGNyZWF0ZS5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZmlyc3QgVGhlIGZpcnN0IGNoYXJhY3RlciBpbiB0aGUgdG9rZW4uXG4gICAgICogQHBhcmFtIHtpbnR9IHN0YXJ0TGluZSBUaGUgYmVnaW5uaW5nIGxpbmUgZm9yIHRoZSBjaGFyYWN0ZXIuXG4gICAgICogQHBhcmFtIHtpbnR9IHN0YXJ0Q29sIFRoZSBiZWdpbm5pbmcgY29sdW1uIGZvciB0aGUgY2hhcmFjdGVyLlxuICAgICAqIEByZXR1cm4ge09iamVjdH0gQSB0b2tlbiBvYmplY3QuXG4gICAgICogQG1ldGhvZCBodG1sQ29tbWVudFN0YXJ0VG9rZW5cbiAgICAgKi9cbiAgICBodG1sQ29tbWVudFN0YXJ0VG9rZW46IGZ1bmN0aW9uKGZpcnN0LCBzdGFydExpbmUsIHN0YXJ0Q29sKXtcbiAgICAgICAgdmFyIHJlYWRlciAgICAgID0gdGhpcy5fcmVhZGVyLFxuICAgICAgICAgICAgdGV4dCAgICAgICAgPSBmaXJzdDtcblxuICAgICAgICByZWFkZXIubWFyaygpO1xuICAgICAgICB0ZXh0ICs9IHJlYWRlci5yZWFkQ291bnQoMyk7XG5cbiAgICAgICAgaWYgKHRleHQgPT09IFwiPCEtLVwiKXtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVRva2VuKFRva2Vucy5DRE8sIHRleHQsIHN0YXJ0TGluZSwgc3RhcnRDb2wpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVhZGVyLnJlc2V0KCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jaGFyVG9rZW4oZmlyc3QsIHN0YXJ0TGluZSwgc3RhcnRDb2wpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFByb2R1Y2VzIGEgQ0RDIG9yIENIQVIgdG9rZW4gYmFzZWQgb24gdGhlIHNwZWNpZmllZCBpbmZvcm1hdGlvbi4gVGhlXG4gICAgICogZmlyc3QgY2hhcmFjdGVyIGlzIHByb3ZpZGVkIGFuZCB0aGUgcmVzdCBpcyByZWFkIGJ5IHRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmVcbiAgICAgKiB0aGUgY29ycmVjdCB0b2tlbiB0byBjcmVhdGUuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGZpcnN0IFRoZSBmaXJzdCBjaGFyYWN0ZXIgaW4gdGhlIHRva2VuLlxuICAgICAqIEBwYXJhbSB7aW50fSBzdGFydExpbmUgVGhlIGJlZ2lubmluZyBsaW5lIGZvciB0aGUgY2hhcmFjdGVyLlxuICAgICAqIEBwYXJhbSB7aW50fSBzdGFydENvbCBUaGUgYmVnaW5uaW5nIGNvbHVtbiBmb3IgdGhlIGNoYXJhY3Rlci5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IEEgdG9rZW4gb2JqZWN0LlxuICAgICAqIEBtZXRob2QgaHRtbENvbW1lbnRFbmRUb2tlblxuICAgICAqL1xuICAgIGh0bWxDb21tZW50RW5kVG9rZW46IGZ1bmN0aW9uKGZpcnN0LCBzdGFydExpbmUsIHN0YXJ0Q29sKXtcbiAgICAgICAgdmFyIHJlYWRlciAgICAgID0gdGhpcy5fcmVhZGVyLFxuICAgICAgICAgICAgdGV4dCAgICAgICAgPSBmaXJzdDtcblxuICAgICAgICByZWFkZXIubWFyaygpO1xuICAgICAgICB0ZXh0ICs9IHJlYWRlci5yZWFkQ291bnQoMik7XG5cbiAgICAgICAgaWYgKHRleHQgPT09IFwiLS0+XCIpe1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlVG9rZW4oVG9rZW5zLkNEQywgdGV4dCwgc3RhcnRMaW5lLCBzdGFydENvbCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZWFkZXIucmVzZXQoKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNoYXJUb2tlbihmaXJzdCwgc3RhcnRMaW5lLCBzdGFydENvbCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUHJvZHVjZXMgYW4gSURFTlQgb3IgRlVOQ1RJT04gdG9rZW4gYmFzZWQgb24gdGhlIHNwZWNpZmllZCBpbmZvcm1hdGlvbi4gVGhlXG4gICAgICogZmlyc3QgY2hhcmFjdGVyIGlzIHByb3ZpZGVkIGFuZCB0aGUgcmVzdCBpcyByZWFkIGJ5IHRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmVcbiAgICAgKiB0aGUgY29ycmVjdCB0b2tlbiB0byBjcmVhdGUuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGZpcnN0IFRoZSBmaXJzdCBjaGFyYWN0ZXIgaW4gdGhlIGlkZW50aWZpZXIuXG4gICAgICogQHBhcmFtIHtpbnR9IHN0YXJ0TGluZSBUaGUgYmVnaW5uaW5nIGxpbmUgZm9yIHRoZSBjaGFyYWN0ZXIuXG4gICAgICogQHBhcmFtIHtpbnR9IHN0YXJ0Q29sIFRoZSBiZWdpbm5pbmcgY29sdW1uIGZvciB0aGUgY2hhcmFjdGVyLlxuICAgICAqIEByZXR1cm4ge09iamVjdH0gQSB0b2tlbiBvYmplY3QuXG4gICAgICogQG1ldGhvZCBpZGVudE9yRnVuY3Rpb25Ub2tlblxuICAgICAqL1xuICAgIGlkZW50T3JGdW5jdGlvblRva2VuOiBmdW5jdGlvbihmaXJzdCwgc3RhcnRMaW5lLCBzdGFydENvbCl7XG4gICAgICAgIHZhciByZWFkZXIgID0gdGhpcy5fcmVhZGVyLFxuICAgICAgICAgICAgaWRlbnQgICA9IHRoaXMucmVhZE5hbWUoZmlyc3QpLFxuICAgICAgICAgICAgdHQgICAgICA9IFRva2Vucy5JREVOVCxcbiAgICAgICAgICAgIHVyaUZucyAgPSBbXCJ1cmwoXCIsIFwidXJsLXByZWZpeChcIiwgXCJkb21haW4oXCJdO1xuXG4gICAgICAgIC8vaWYgdGhlcmUncyBhIGxlZnQgcGFyZW4gaW1tZWRpYXRlbHkgYWZ0ZXIsIGl0J3MgYSBVUkkgb3IgZnVuY3Rpb25cbiAgICAgICAgaWYgKHJlYWRlci5wZWVrKCkgPT09IFwiKFwiKXtcbiAgICAgICAgICAgIGlkZW50ICs9IHJlYWRlci5yZWFkKCk7XG4gICAgICAgICAgICBpZiAodXJpRm5zLmluZGV4T2YoaWRlbnQudG9Mb3dlckNhc2UoKSkgPiAtMSl7XG4gICAgICAgICAgICAgICAgdHQgPSBUb2tlbnMuVVJJO1xuICAgICAgICAgICAgICAgIGlkZW50ID0gdGhpcy5yZWFkVVJJKGlkZW50KTtcblxuICAgICAgICAgICAgICAgIC8vZGlkbid0IGZpbmQgYSB2YWxpZCBVUkwgb3IgdGhlcmUncyBubyBjbG9zaW5nIHBhcmVuXG4gICAgICAgICAgICAgICAgaWYgKHVyaUZucy5pbmRleE9mKGlkZW50LnRvTG93ZXJDYXNlKCkpID4gLTEpe1xuICAgICAgICAgICAgICAgICAgICB0dCA9IFRva2Vucy5GVU5DVElPTjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHR0ID0gVG9rZW5zLkZVTkNUSU9OO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHJlYWRlci5wZWVrKCkgPT09IFwiOlwiKXsgIC8vbWlnaHQgYmUgYW4gSUUgZnVuY3Rpb25cblxuICAgICAgICAgICAgLy9JRS1zcGVjaWZpYyBmdW5jdGlvbnMgYWx3YXlzIGJlaW5nIHdpdGggcHJvZ2lkOlxuICAgICAgICAgICAgaWYgKGlkZW50LnRvTG93ZXJDYXNlKCkgPT09IFwicHJvZ2lkXCIpe1xuICAgICAgICAgICAgICAgIGlkZW50ICs9IHJlYWRlci5yZWFkVG8oXCIoXCIpO1xuICAgICAgICAgICAgICAgIHR0ID0gVG9rZW5zLklFX0ZVTkNUSU9OO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlVG9rZW4odHQsIGlkZW50LCBzdGFydExpbmUsIHN0YXJ0Q29sKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUHJvZHVjZXMgYW4gSU1QT1JUQU5UX1NZTSBvciBDSEFSIHRva2VuIGJhc2VkIG9uIHRoZSBzcGVjaWZpZWQgaW5mb3JtYXRpb24uIFRoZVxuICAgICAqIGZpcnN0IGNoYXJhY3RlciBpcyBwcm92aWRlZCBhbmQgdGhlIHJlc3QgaXMgcmVhZCBieSB0aGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lXG4gICAgICogdGhlIGNvcnJlY3QgdG9rZW4gdG8gY3JlYXRlLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBmaXJzdCBUaGUgZmlyc3QgY2hhcmFjdGVyIGluIHRoZSB0b2tlbi5cbiAgICAgKiBAcGFyYW0ge2ludH0gc3RhcnRMaW5lIFRoZSBiZWdpbm5pbmcgbGluZSBmb3IgdGhlIGNoYXJhY3Rlci5cbiAgICAgKiBAcGFyYW0ge2ludH0gc3RhcnRDb2wgVGhlIGJlZ2lubmluZyBjb2x1bW4gZm9yIHRoZSBjaGFyYWN0ZXIuXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBBIHRva2VuIG9iamVjdC5cbiAgICAgKiBAbWV0aG9kIGltcG9ydGFudFRva2VuXG4gICAgICovXG4gICAgaW1wb3J0YW50VG9rZW46IGZ1bmN0aW9uKGZpcnN0LCBzdGFydExpbmUsIHN0YXJ0Q29sKXtcbiAgICAgICAgdmFyIHJlYWRlciAgICAgID0gdGhpcy5fcmVhZGVyLFxuICAgICAgICAgICAgaW1wb3J0YW50ICAgPSBmaXJzdCxcbiAgICAgICAgICAgIHR0ICAgICAgICAgID0gVG9rZW5zLkNIQVIsXG4gICAgICAgICAgICB0ZW1wLFxuICAgICAgICAgICAgYztcblxuICAgICAgICByZWFkZXIubWFyaygpO1xuICAgICAgICBjID0gcmVhZGVyLnJlYWQoKTtcblxuICAgICAgICB3aGlsZShjKXtcblxuICAgICAgICAgICAgLy90aGVyZSBjYW4gYmUgYSBjb21tZW50IGluIGhlcmVcbiAgICAgICAgICAgIGlmIChjID09PSBcIi9cIil7XG5cbiAgICAgICAgICAgICAgICAvL2lmIHRoZSBuZXh0IGNoYXJhY3RlciBpc24ndCBhIHN0YXIsIHRoZW4gdGhpcyBpc24ndCBhIHZhbGlkICFpbXBvcnRhbnQgdG9rZW5cbiAgICAgICAgICAgICAgICBpZiAocmVhZGVyLnBlZWsoKSAhPT0gXCIqXCIpe1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0ZW1wID0gdGhpcy5yZWFkQ29tbWVudChjKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRlbXAgPT09IFwiXCIpeyAgICAvL2Jyb2tlbiFcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChpc1doaXRlc3BhY2UoYykpe1xuICAgICAgICAgICAgICAgIGltcG9ydGFudCArPSBjICsgdGhpcy5yZWFkV2hpdGVzcGFjZSgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICgvaS9pLnRlc3QoYykpe1xuICAgICAgICAgICAgICAgIHRlbXAgPSByZWFkZXIucmVhZENvdW50KDgpO1xuICAgICAgICAgICAgICAgIGlmICgvbXBvcnRhbnQvaS50ZXN0KHRlbXApKXtcbiAgICAgICAgICAgICAgICAgICAgaW1wb3J0YW50ICs9IGMgKyB0ZW1wO1xuICAgICAgICAgICAgICAgICAgICB0dCA9IFRva2Vucy5JTVBPUlRBTlRfU1lNO1xuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrOyAgLy93ZSdyZSBkb25lXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjID0gcmVhZGVyLnJlYWQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0dCA9PT0gVG9rZW5zLkNIQVIpe1xuICAgICAgICAgICAgcmVhZGVyLnJlc2V0KCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jaGFyVG9rZW4oZmlyc3QsIHN0YXJ0TGluZSwgc3RhcnRDb2wpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlVG9rZW4odHQsIGltcG9ydGFudCwgc3RhcnRMaW5lLCBzdGFydENvbCk7XG4gICAgICAgIH1cblxuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFByb2R1Y2VzIGEgTk9UIG9yIENIQVIgdG9rZW4gYmFzZWQgb24gdGhlIHNwZWNpZmllZCBpbmZvcm1hdGlvbi4gVGhlXG4gICAgICogZmlyc3QgY2hhcmFjdGVyIGlzIHByb3ZpZGVkIGFuZCB0aGUgcmVzdCBpcyByZWFkIGJ5IHRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmVcbiAgICAgKiB0aGUgY29ycmVjdCB0b2tlbiB0byBjcmVhdGUuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGZpcnN0IFRoZSBmaXJzdCBjaGFyYWN0ZXIgaW4gdGhlIHRva2VuLlxuICAgICAqIEBwYXJhbSB7aW50fSBzdGFydExpbmUgVGhlIGJlZ2lubmluZyBsaW5lIGZvciB0aGUgY2hhcmFjdGVyLlxuICAgICAqIEBwYXJhbSB7aW50fSBzdGFydENvbCBUaGUgYmVnaW5uaW5nIGNvbHVtbiBmb3IgdGhlIGNoYXJhY3Rlci5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IEEgdG9rZW4gb2JqZWN0LlxuICAgICAqIEBtZXRob2Qgbm90VG9rZW5cbiAgICAgKi9cbiAgICBub3RUb2tlbjogZnVuY3Rpb24oZmlyc3QsIHN0YXJ0TGluZSwgc3RhcnRDb2wpe1xuICAgICAgICB2YXIgcmVhZGVyICAgICAgPSB0aGlzLl9yZWFkZXIsXG4gICAgICAgICAgICB0ZXh0ICAgICAgICA9IGZpcnN0O1xuXG4gICAgICAgIHJlYWRlci5tYXJrKCk7XG4gICAgICAgIHRleHQgKz0gcmVhZGVyLnJlYWRDb3VudCg0KTtcblxuICAgICAgICBpZiAodGV4dC50b0xvd2VyQ2FzZSgpID09PSBcIjpub3QoXCIpe1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlVG9rZW4oVG9rZW5zLk5PVCwgdGV4dCwgc3RhcnRMaW5lLCBzdGFydENvbCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZWFkZXIucmVzZXQoKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNoYXJUb2tlbihmaXJzdCwgc3RhcnRMaW5lLCBzdGFydENvbCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUHJvZHVjZXMgYSBudW1iZXIgdG9rZW4gYmFzZWQgb24gdGhlIGdpdmVuIGNoYXJhY3RlclxuICAgICAqIGFuZCBsb2NhdGlvbiBpbiB0aGUgc3RyZWFtLiBUaGlzIG1heSByZXR1cm4gYSB0b2tlbiBvZlxuICAgICAqIE5VTUJFUiwgRU1TLCBFWFMsIExFTkdUSCwgQU5HTEUsIFRJTUUsIEZSRVEsIERJTUVOU0lPTixcbiAgICAgKiBvciBQRVJDRU5UQUdFLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBmaXJzdCBUaGUgZmlyc3QgY2hhcmFjdGVyIGZvciB0aGUgdG9rZW4uXG4gICAgICogQHBhcmFtIHtpbnR9IHN0YXJ0TGluZSBUaGUgYmVnaW5uaW5nIGxpbmUgZm9yIHRoZSBjaGFyYWN0ZXIuXG4gICAgICogQHBhcmFtIHtpbnR9IHN0YXJ0Q29sIFRoZSBiZWdpbm5pbmcgY29sdW1uIGZvciB0aGUgY2hhcmFjdGVyLlxuICAgICAqIEByZXR1cm4ge09iamVjdH0gQSB0b2tlbiBvYmplY3QuXG4gICAgICogQG1ldGhvZCBudW1iZXJUb2tlblxuICAgICAqL1xuICAgIG51bWJlclRva2VuOiBmdW5jdGlvbihmaXJzdCwgc3RhcnRMaW5lLCBzdGFydENvbCl7XG4gICAgICAgIHZhciByZWFkZXIgID0gdGhpcy5fcmVhZGVyLFxuICAgICAgICAgICAgdmFsdWUgICA9IHRoaXMucmVhZE51bWJlcihmaXJzdCksXG4gICAgICAgICAgICBpZGVudCxcbiAgICAgICAgICAgIHR0ICAgICAgPSBUb2tlbnMuTlVNQkVSLFxuICAgICAgICAgICAgYyAgICAgICA9IHJlYWRlci5wZWVrKCk7XG5cbiAgICAgICAgaWYgKGlzSWRlbnRTdGFydChjKSl7XG4gICAgICAgICAgICBpZGVudCA9IHRoaXMucmVhZE5hbWUocmVhZGVyLnJlYWQoKSk7XG4gICAgICAgICAgICB2YWx1ZSArPSBpZGVudDtcblxuICAgICAgICAgICAgaWYgKC9eZW0kfF5leCR8XnB4JHxeZ2QkfF5yZW0kfF52dyR8XnZoJHxedm1heCR8XnZtaW4kfF5jaCR8XmNtJHxebW0kfF5pbiR8XnB0JHxecGMkL2kudGVzdChpZGVudCkpe1xuICAgICAgICAgICAgICAgIHR0ID0gVG9rZW5zLkxFTkdUSDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoL15kZWd8XnJhZCR8XmdyYWQkL2kudGVzdChpZGVudCkpe1xuICAgICAgICAgICAgICAgIHR0ID0gVG9rZW5zLkFOR0xFO1xuICAgICAgICAgICAgfSBlbHNlIGlmICgvXm1zJHxecyQvaS50ZXN0KGlkZW50KSl7XG4gICAgICAgICAgICAgICAgdHQgPSBUb2tlbnMuVElNRTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoL15oeiR8XmtoeiQvaS50ZXN0KGlkZW50KSl7XG4gICAgICAgICAgICAgICAgdHQgPSBUb2tlbnMuRlJFUTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoL15kcGkkfF5kcGNtJC9pLnRlc3QoaWRlbnQpKXtcbiAgICAgICAgICAgICAgICB0dCA9IFRva2Vucy5SRVNPTFVUSU9OO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0dCA9IFRva2Vucy5ESU1FTlNJT047XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIGlmIChjID09PSBcIiVcIil7XG4gICAgICAgICAgICB2YWx1ZSArPSByZWFkZXIucmVhZCgpO1xuICAgICAgICAgICAgdHQgPSBUb2tlbnMuUEVSQ0VOVEFHRTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVRva2VuKHR0LCB2YWx1ZSwgc3RhcnRMaW5lLCBzdGFydENvbCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFByb2R1Y2VzIGEgc3RyaW5nIHRva2VuIGJhc2VkIG9uIHRoZSBnaXZlbiBjaGFyYWN0ZXJcbiAgICAgKiBhbmQgbG9jYXRpb24gaW4gdGhlIHN0cmVhbS4gU2luY2Ugc3RyaW5ncyBtYXkgYmUgaW5kaWNhdGVkXG4gICAgICogYnkgc2luZ2xlIG9yIGRvdWJsZSBxdW90ZXMsIGEgZmFpbHVyZSB0byBtYXRjaCBzdGFydGluZ1xuICAgICAqIGFuZCBlbmRpbmcgcXVvdGVzIHJlc3VsdHMgaW4gYW4gSU5WQUxJRCB0b2tlbiBiZWluZyBnZW5lcmF0ZWQuXG4gICAgICogVGhlIGZpcnN0IGNoYXJhY3RlciBpbiB0aGUgc3RyaW5nIGlzIHBhc3NlZCBpbiBhbmQgdGhlblxuICAgICAqIHRoZSByZXN0IGFyZSByZWFkIHVwIHRvIGFuZCBpbmNsdWRpbmcgdGhlIGZpbmFsIHF1b3RhdGlvbiBtYXJrLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBmaXJzdCBUaGUgZmlyc3QgY2hhcmFjdGVyIGluIHRoZSBzdHJpbmcuXG4gICAgICogQHBhcmFtIHtpbnR9IHN0YXJ0TGluZSBUaGUgYmVnaW5uaW5nIGxpbmUgZm9yIHRoZSBjaGFyYWN0ZXIuXG4gICAgICogQHBhcmFtIHtpbnR9IHN0YXJ0Q29sIFRoZSBiZWdpbm5pbmcgY29sdW1uIGZvciB0aGUgY2hhcmFjdGVyLlxuICAgICAqIEByZXR1cm4ge09iamVjdH0gQSB0b2tlbiBvYmplY3QuXG4gICAgICogQG1ldGhvZCBzdHJpbmdUb2tlblxuICAgICAqL1xuICAgIHN0cmluZ1Rva2VuOiBmdW5jdGlvbihmaXJzdCwgc3RhcnRMaW5lLCBzdGFydENvbCl7XG4gICAgICAgIHZhciBkZWxpbSAgID0gZmlyc3QsXG4gICAgICAgICAgICBzdHJpbmcgID0gZmlyc3QsXG4gICAgICAgICAgICByZWFkZXIgID0gdGhpcy5fcmVhZGVyLFxuICAgICAgICAgICAgcHJldiAgICA9IGZpcnN0LFxuICAgICAgICAgICAgdHQgICAgICA9IFRva2Vucy5TVFJJTkcsXG4gICAgICAgICAgICBjICAgICAgID0gcmVhZGVyLnJlYWQoKTtcblxuICAgICAgICB3aGlsZShjKXtcbiAgICAgICAgICAgIHN0cmluZyArPSBjO1xuXG4gICAgICAgICAgICAvL2lmIHRoZSBkZWxpbWl0ZXIgaXMgZm91bmQgd2l0aCBhbiBlc2NhcGVtZW50LCB3ZSdyZSBkb25lLlxuICAgICAgICAgICAgaWYgKGMgPT09IGRlbGltICYmIHByZXYgIT09IFwiXFxcXFwiKXtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy9pZiB0aGVyZSdzIGEgbmV3bGluZSB3aXRob3V0IGFuIGVzY2FwZW1lbnQsIGl0J3MgYW4gaW52YWxpZCBzdHJpbmdcbiAgICAgICAgICAgIGlmIChpc05ld0xpbmUocmVhZGVyLnBlZWsoKSkgJiYgYyAhPT0gXCJcXFxcXCIpe1xuICAgICAgICAgICAgICAgIHR0ID0gVG9rZW5zLklOVkFMSUQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vc2F2ZSBwcmV2aW91cyBhbmQgZ2V0IG5leHRcbiAgICAgICAgICAgIHByZXYgPSBjO1xuICAgICAgICAgICAgYyA9IHJlYWRlci5yZWFkKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvL2lmIGMgaXMgbnVsbCwgdGhhdCBtZWFucyB3ZSdyZSBvdXQgb2YgaW5wdXQgYW5kIHRoZSBzdHJpbmcgd2FzIG5ldmVyIGNsb3NlZFxuICAgICAgICBpZiAoYyA9PT0gbnVsbCl7XG4gICAgICAgICAgICB0dCA9IFRva2Vucy5JTlZBTElEO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlVG9rZW4odHQsIHN0cmluZywgc3RhcnRMaW5lLCBzdGFydENvbCk7XG4gICAgfSxcblxuICAgIHVuaWNvZGVSYW5nZVRva2VuOiBmdW5jdGlvbihmaXJzdCwgc3RhcnRMaW5lLCBzdGFydENvbCl7XG4gICAgICAgIHZhciByZWFkZXIgID0gdGhpcy5fcmVhZGVyLFxuICAgICAgICAgICAgdmFsdWUgICA9IGZpcnN0LFxuICAgICAgICAgICAgdGVtcCxcbiAgICAgICAgICAgIHR0ICAgICAgPSBUb2tlbnMuQ0hBUjtcblxuICAgICAgICAvL3RoZW4gaXQgc2hvdWxkIGJlIGEgdW5pY29kZSByYW5nZVxuICAgICAgICBpZiAocmVhZGVyLnBlZWsoKSA9PT0gXCIrXCIpe1xuICAgICAgICAgICAgcmVhZGVyLm1hcmsoKTtcbiAgICAgICAgICAgIHZhbHVlICs9IHJlYWRlci5yZWFkKCk7XG4gICAgICAgICAgICB2YWx1ZSArPSB0aGlzLnJlYWRVbmljb2RlUmFuZ2VQYXJ0KHRydWUpO1xuXG4gICAgICAgICAgICAvL2Vuc3VyZSB0aGVyZSdzIGFuIGFjdHVhbCB1bmljb2RlIHJhbmdlIGhlcmVcbiAgICAgICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPT09IDIpe1xuICAgICAgICAgICAgICAgIHJlYWRlci5yZXNldCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgIHR0ID0gVG9rZW5zLlVOSUNPREVfUkFOR0U7XG5cbiAgICAgICAgICAgICAgICAvL2lmIHRoZXJlJ3MgYSA/IGluIHRoZSBmaXJzdCBwYXJ0LCB0aGVyZSBjYW4ndCBiZSBhIHNlY29uZCBwYXJ0XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlLmluZGV4T2YoXCI/XCIpID09PSAtMSl7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlYWRlci5wZWVrKCkgPT09IFwiLVwiKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRlci5tYXJrKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZW1wID0gcmVhZGVyLnJlYWQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbXAgKz0gdGhpcy5yZWFkVW5pY29kZVJhbmdlUGFydChmYWxzZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vaWYgdGhlcmUncyBub3QgYW5vdGhlciB2YWx1ZSwgYmFjayB1cCBhbmQganVzdCB0YWtlIHRoZSBmaXJzdFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRlbXAubGVuZ3RoID09PSAxKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFkZXIucmVzZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgKz0gdGVtcDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlVG9rZW4odHQsIHZhbHVlLCBzdGFydExpbmUsIHN0YXJ0Q29sKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUHJvZHVjZXMgYSBTIHRva2VuIGJhc2VkIG9uIHRoZSBzcGVjaWZpZWQgaW5mb3JtYXRpb24uIFNpbmNlIHdoaXRlc3BhY2VcbiAgICAgKiBtYXkgaGF2ZSBtdWx0aXBsZSBjaGFyYWN0ZXJzLCB0aGlzIGNvbnN1bWVzIGFsbCB3aGl0ZXNwYWNlIGNoYXJhY3RlcnNcbiAgICAgKiBpbnRvIGEgc2luZ2xlIHRva2VuLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBmaXJzdCBUaGUgZmlyc3QgY2hhcmFjdGVyIGluIHRoZSB0b2tlbi5cbiAgICAgKiBAcGFyYW0ge2ludH0gc3RhcnRMaW5lIFRoZSBiZWdpbm5pbmcgbGluZSBmb3IgdGhlIGNoYXJhY3Rlci5cbiAgICAgKiBAcGFyYW0ge2ludH0gc3RhcnRDb2wgVGhlIGJlZ2lubmluZyBjb2x1bW4gZm9yIHRoZSBjaGFyYWN0ZXIuXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBBIHRva2VuIG9iamVjdC5cbiAgICAgKiBAbWV0aG9kIHdoaXRlc3BhY2VUb2tlblxuICAgICAqL1xuICAgIHdoaXRlc3BhY2VUb2tlbjogZnVuY3Rpb24oZmlyc3QsIHN0YXJ0TGluZSwgc3RhcnRDb2wpe1xuICAgICAgICB2YXIgdmFsdWUgICA9IGZpcnN0ICsgdGhpcy5yZWFkV2hpdGVzcGFjZSgpO1xuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVUb2tlbihUb2tlbnMuUywgdmFsdWUsIHN0YXJ0TGluZSwgc3RhcnRDb2wpO1xuICAgIH0sXG5cblxuXG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBNZXRob2RzIHRvIHJlYWQgdmFsdWVzIGZyb20gdGhlIHN0cmluZyBzdHJlYW1cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIHJlYWRVbmljb2RlUmFuZ2VQYXJ0OiBmdW5jdGlvbihhbGxvd1F1ZXN0aW9uTWFyayl7XG4gICAgICAgIHZhciByZWFkZXIgID0gdGhpcy5fcmVhZGVyLFxuICAgICAgICAgICAgcGFydCA9IFwiXCIsXG4gICAgICAgICAgICBjICAgICAgID0gcmVhZGVyLnBlZWsoKTtcblxuICAgICAgICAvL2ZpcnN0IHJlYWQgaGV4IGRpZ2l0c1xuICAgICAgICB3aGlsZShpc0hleERpZ2l0KGMpICYmIHBhcnQubGVuZ3RoIDwgNil7XG4gICAgICAgICAgICByZWFkZXIucmVhZCgpO1xuICAgICAgICAgICAgcGFydCArPSBjO1xuICAgICAgICAgICAgYyA9IHJlYWRlci5wZWVrKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvL3RoZW4gcmVhZCBxdWVzdGlvbiBtYXJrcyBpZiBhbGxvd2VkXG4gICAgICAgIGlmIChhbGxvd1F1ZXN0aW9uTWFyayl7XG4gICAgICAgICAgICB3aGlsZShjID09PSBcIj9cIiAmJiBwYXJ0Lmxlbmd0aCA8IDYpe1xuICAgICAgICAgICAgICAgIHJlYWRlci5yZWFkKCk7XG4gICAgICAgICAgICAgICAgcGFydCArPSBjO1xuICAgICAgICAgICAgICAgIGMgPSByZWFkZXIucGVlaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy90aGVyZSBjYW4ndCBiZSBhbnkgb3RoZXIgY2hhcmFjdGVycyBhZnRlciB0aGlzIHBvaW50XG5cbiAgICAgICAgcmV0dXJuIHBhcnQ7XG4gICAgfSxcblxuICAgIHJlYWRXaGl0ZXNwYWNlOiBmdW5jdGlvbigpe1xuICAgICAgICB2YXIgcmVhZGVyICA9IHRoaXMuX3JlYWRlcixcbiAgICAgICAgICAgIHdoaXRlc3BhY2UgPSBcIlwiLFxuICAgICAgICAgICAgYyAgICAgICA9IHJlYWRlci5wZWVrKCk7XG5cbiAgICAgICAgd2hpbGUoaXNXaGl0ZXNwYWNlKGMpKXtcbiAgICAgICAgICAgIHJlYWRlci5yZWFkKCk7XG4gICAgICAgICAgICB3aGl0ZXNwYWNlICs9IGM7XG4gICAgICAgICAgICBjID0gcmVhZGVyLnBlZWsoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB3aGl0ZXNwYWNlO1xuICAgIH0sXG4gICAgcmVhZE51bWJlcjogZnVuY3Rpb24oZmlyc3Qpe1xuICAgICAgICB2YXIgcmVhZGVyICA9IHRoaXMuX3JlYWRlcixcbiAgICAgICAgICAgIG51bWJlciAgPSBmaXJzdCxcbiAgICAgICAgICAgIGhhc0RvdCAgPSAoZmlyc3QgPT09IFwiLlwiKSxcbiAgICAgICAgICAgIGMgICAgICAgPSByZWFkZXIucGVlaygpO1xuXG5cbiAgICAgICAgd2hpbGUoYyl7XG4gICAgICAgICAgICBpZiAoaXNEaWdpdChjKSl7XG4gICAgICAgICAgICAgICAgbnVtYmVyICs9IHJlYWRlci5yZWFkKCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGMgPT09IFwiLlwiKXtcbiAgICAgICAgICAgICAgICBpZiAoaGFzRG90KXtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaGFzRG90ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgbnVtYmVyICs9IHJlYWRlci5yZWFkKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYyA9IHJlYWRlci5wZWVrKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVtYmVyO1xuICAgIH0sXG4gICAgcmVhZFN0cmluZzogZnVuY3Rpb24oKXtcbiAgICAgICAgdmFyIHJlYWRlciAgPSB0aGlzLl9yZWFkZXIsXG4gICAgICAgICAgICBkZWxpbSAgID0gcmVhZGVyLnJlYWQoKSxcbiAgICAgICAgICAgIHN0cmluZyAgPSBkZWxpbSxcbiAgICAgICAgICAgIHByZXYgICAgPSBkZWxpbSxcbiAgICAgICAgICAgIGMgICAgICAgPSByZWFkZXIucGVlaygpO1xuXG4gICAgICAgIHdoaWxlKGMpe1xuICAgICAgICAgICAgYyA9IHJlYWRlci5yZWFkKCk7XG4gICAgICAgICAgICBzdHJpbmcgKz0gYztcblxuICAgICAgICAgICAgLy9pZiB0aGUgZGVsaW1pdGVyIGlzIGZvdW5kIHdpdGggYW4gZXNjYXBlbWVudCwgd2UncmUgZG9uZS5cbiAgICAgICAgICAgIGlmIChjID09PSBkZWxpbSAmJiBwcmV2ICE9PSBcIlxcXFxcIil7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vaWYgdGhlcmUncyBhIG5ld2xpbmUgd2l0aG91dCBhbiBlc2NhcGVtZW50LCBpdCdzIGFuIGludmFsaWQgc3RyaW5nXG4gICAgICAgICAgICBpZiAoaXNOZXdMaW5lKHJlYWRlci5wZWVrKCkpICYmIGMgIT09IFwiXFxcXFwiKXtcbiAgICAgICAgICAgICAgICBzdHJpbmcgPSBcIlwiO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvL3NhdmUgcHJldmlvdXMgYW5kIGdldCBuZXh0XG4gICAgICAgICAgICBwcmV2ID0gYztcbiAgICAgICAgICAgIGMgPSByZWFkZXIucGVlaygpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9pZiBjIGlzIG51bGwsIHRoYXQgbWVhbnMgd2UncmUgb3V0IG9mIGlucHV0IGFuZCB0aGUgc3RyaW5nIHdhcyBuZXZlciBjbG9zZWRcbiAgICAgICAgaWYgKGMgPT09IG51bGwpe1xuICAgICAgICAgICAgc3RyaW5nID0gXCJcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgfSxcbiAgICByZWFkVVJJOiBmdW5jdGlvbihmaXJzdCl7XG4gICAgICAgIHZhciByZWFkZXIgID0gdGhpcy5fcmVhZGVyLFxuICAgICAgICAgICAgdXJpICAgICA9IGZpcnN0LFxuICAgICAgICAgICAgaW5uZXIgICA9IFwiXCIsXG4gICAgICAgICAgICBjICAgICAgID0gcmVhZGVyLnBlZWsoKTtcblxuICAgICAgICByZWFkZXIubWFyaygpO1xuXG4gICAgICAgIC8vc2tpcCB3aGl0ZXNwYWNlIGJlZm9yZVxuICAgICAgICB3aGlsZShjICYmIGlzV2hpdGVzcGFjZShjKSl7XG4gICAgICAgICAgICByZWFkZXIucmVhZCgpO1xuICAgICAgICAgICAgYyA9IHJlYWRlci5wZWVrKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvL2l0J3MgYSBzdHJpbmdcbiAgICAgICAgaWYgKGMgPT09IFwiJ1wiIHx8IGMgPT09IFwiXFxcIlwiKXtcbiAgICAgICAgICAgIGlubmVyID0gdGhpcy5yZWFkU3RyaW5nKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpbm5lciA9IHRoaXMucmVhZFVSTCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgYyA9IHJlYWRlci5wZWVrKCk7XG5cbiAgICAgICAgLy9za2lwIHdoaXRlc3BhY2UgYWZ0ZXJcbiAgICAgICAgd2hpbGUoYyAmJiBpc1doaXRlc3BhY2UoYykpe1xuICAgICAgICAgICAgcmVhZGVyLnJlYWQoKTtcbiAgICAgICAgICAgIGMgPSByZWFkZXIucGVlaygpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9pZiB0aGVyZSB3YXMgbm8gaW5uZXIgdmFsdWUgb3IgdGhlIG5leHQgY2hhcmFjdGVyIGlzbid0IGNsb3NpbmcgcGFyZW4sIGl0J3Mgbm90IGEgVVJJXG4gICAgICAgIGlmIChpbm5lciA9PT0gXCJcIiB8fCBjICE9PSBcIilcIil7XG4gICAgICAgICAgICB1cmkgPSBmaXJzdDtcbiAgICAgICAgICAgIHJlYWRlci5yZXNldCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdXJpICs9IGlubmVyICsgcmVhZGVyLnJlYWQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB1cmk7XG4gICAgfSxcbiAgICByZWFkVVJMOiBmdW5jdGlvbigpe1xuICAgICAgICB2YXIgcmVhZGVyICA9IHRoaXMuX3JlYWRlcixcbiAgICAgICAgICAgIHVybCAgICAgPSBcIlwiLFxuICAgICAgICAgICAgYyAgICAgICA9IHJlYWRlci5wZWVrKCk7XG5cbiAgICAgICAgLy9UT0RPOiBDaGVjayBmb3IgZXNjYXBlIGFuZCBub25hc2NpaVxuICAgICAgICB3aGlsZSAoL15bISMkJSZcXFxcKi1+XSQvLnRlc3QoYykpe1xuICAgICAgICAgICAgdXJsICs9IHJlYWRlci5yZWFkKCk7XG4gICAgICAgICAgICBjID0gcmVhZGVyLnBlZWsoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB1cmw7XG5cbiAgICB9LFxuICAgIHJlYWROYW1lOiBmdW5jdGlvbihmaXJzdCl7XG4gICAgICAgIHZhciByZWFkZXIgID0gdGhpcy5fcmVhZGVyLFxuICAgICAgICAgICAgaWRlbnQgICA9IGZpcnN0IHx8IFwiXCIsXG4gICAgICAgICAgICBjICAgICAgID0gcmVhZGVyLnBlZWsoKTtcblxuICAgICAgICB3aGlsZSh0cnVlKXtcbiAgICAgICAgICAgIGlmIChjID09PSBcIlxcXFxcIil7XG4gICAgICAgICAgICAgICAgaWRlbnQgKz0gdGhpcy5yZWFkRXNjYXBlKHJlYWRlci5yZWFkKCkpO1xuICAgICAgICAgICAgICAgIGMgPSByZWFkZXIucGVlaygpO1xuICAgICAgICAgICAgfSBlbHNlIGlmKGMgJiYgaXNOYW1lQ2hhcihjKSl7XG4gICAgICAgICAgICAgICAgaWRlbnQgKz0gcmVhZGVyLnJlYWQoKTtcbiAgICAgICAgICAgICAgICBjID0gcmVhZGVyLnBlZWsoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaWRlbnQ7XG4gICAgfSxcblxuICAgIHJlYWRFc2NhcGU6IGZ1bmN0aW9uKGZpcnN0KXtcbiAgICAgICAgdmFyIHJlYWRlciAgPSB0aGlzLl9yZWFkZXIsXG4gICAgICAgICAgICBjc3NFc2NhcGUgPSBmaXJzdCB8fCBcIlwiLFxuICAgICAgICAgICAgaSAgICAgICA9IDAsXG4gICAgICAgICAgICBjICAgICAgID0gcmVhZGVyLnBlZWsoKTtcblxuICAgICAgICBpZiAoaXNIZXhEaWdpdChjKSl7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgY3NzRXNjYXBlICs9IHJlYWRlci5yZWFkKCk7XG4gICAgICAgICAgICAgICAgYyA9IHJlYWRlci5wZWVrKCk7XG4gICAgICAgICAgICB9IHdoaWxlKGMgJiYgaXNIZXhEaWdpdChjKSAmJiArK2kgPCA2KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjc3NFc2NhcGUubGVuZ3RoID09PSAzICYmIC9cXHMvLnRlc3QoYykgfHxcbiAgICAgICAgICAgIGNzc0VzY2FwZS5sZW5ndGggPT09IDcgfHwgY3NzRXNjYXBlLmxlbmd0aCA9PT0gMSl7XG4gICAgICAgICAgICAgICAgcmVhZGVyLnJlYWQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGMgPSBcIlwiO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNzc0VzY2FwZSArIGM7XG4gICAgfSxcblxuICAgIHJlYWRDb21tZW50OiBmdW5jdGlvbihmaXJzdCl7XG4gICAgICAgIHZhciByZWFkZXIgID0gdGhpcy5fcmVhZGVyLFxuICAgICAgICAgICAgY29tbWVudCA9IGZpcnN0IHx8IFwiXCIsXG4gICAgICAgICAgICBjICAgICAgID0gcmVhZGVyLnJlYWQoKTtcblxuICAgICAgICBpZiAoYyA9PT0gXCIqXCIpe1xuICAgICAgICAgICAgd2hpbGUoYyl7XG4gICAgICAgICAgICAgICAgY29tbWVudCArPSBjO1xuXG4gICAgICAgICAgICAgICAgLy9sb29rIGZvciBlbmQgb2YgY29tbWVudFxuICAgICAgICAgICAgICAgIGlmIChjb21tZW50Lmxlbmd0aCA+IDIgJiYgYyA9PT0gXCIqXCIgJiYgcmVhZGVyLnBlZWsoKSA9PT0gXCIvXCIpe1xuICAgICAgICAgICAgICAgICAgICBjb21tZW50ICs9IHJlYWRlci5yZWFkKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGMgPSByZWFkZXIucmVhZCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gY29tbWVudDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICB9XG5cbiAgICB9XG59KTtcblxudmFyIFRva2VucyAgPSBbXG5cbiAgICAvKlxuICAgICAqIFRoZSBmb2xsb3dpbmcgdG9rZW4gbmFtZXMgYXJlIGRlZmluZWQgaW4gQ1NTMyBHcmFtbWFyOiBodHRwOi8vd3d3LnczLm9yZy9UUi9jc3MzLXN5bnRheC8jbGV4aWNhbFxuICAgICAqL1xuXG4gICAgLy9IVE1MLXN0eWxlIGNvbW1lbnRzXG4gICAgeyBuYW1lOiBcIkNET1wifSxcbiAgICB7IG5hbWU6IFwiQ0RDXCJ9LFxuXG4gICAgLy9pZ25vcmFibGVzXG4gICAgeyBuYW1lOiBcIlNcIiwgd2hpdGVzcGFjZTogdHJ1ZS8qLCBjaGFubmVsOiBcIndzXCIqL30sXG4gICAgeyBuYW1lOiBcIkNPTU1FTlRcIiwgY29tbWVudDogdHJ1ZSwgaGlkZTogdHJ1ZSwgY2hhbm5lbDogXCJjb21tZW50XCIgfSxcblxuICAgIC8vYXR0cmlidXRlIGVxdWFsaXR5XG4gICAgeyBuYW1lOiBcIklOQ0xVREVTXCIsIHRleHQ6IFwifj1cIn0sXG4gICAgeyBuYW1lOiBcIkRBU0hNQVRDSFwiLCB0ZXh0OiBcInw9XCJ9LFxuICAgIHsgbmFtZTogXCJQUkVGSVhNQVRDSFwiLCB0ZXh0OiBcIl49XCJ9LFxuICAgIHsgbmFtZTogXCJTVUZGSVhNQVRDSFwiLCB0ZXh0OiBcIiQ9XCJ9LFxuICAgIHsgbmFtZTogXCJTVUJTVFJJTkdNQVRDSFwiLCB0ZXh0OiBcIio9XCJ9LFxuXG4gICAgLy9pZGVudGlmaWVyIHR5cGVzXG4gICAgeyBuYW1lOiBcIlNUUklOR1wifSxcbiAgICB7IG5hbWU6IFwiSURFTlRcIn0sXG4gICAgeyBuYW1lOiBcIkhBU0hcIn0sXG5cbiAgICAvL2F0LWtleXdvcmRzXG4gICAgeyBuYW1lOiBcIklNUE9SVF9TWU1cIiwgdGV4dDogXCJAaW1wb3J0XCJ9LFxuICAgIHsgbmFtZTogXCJQQUdFX1NZTVwiLCB0ZXh0OiBcIkBwYWdlXCJ9LFxuICAgIHsgbmFtZTogXCJNRURJQV9TWU1cIiwgdGV4dDogXCJAbWVkaWFcIn0sXG4gICAgeyBuYW1lOiBcIkZPTlRfRkFDRV9TWU1cIiwgdGV4dDogXCJAZm9udC1mYWNlXCJ9LFxuICAgIHsgbmFtZTogXCJDSEFSU0VUX1NZTVwiLCB0ZXh0OiBcIkBjaGFyc2V0XCJ9LFxuICAgIHsgbmFtZTogXCJOQU1FU1BBQ0VfU1lNXCIsIHRleHQ6IFwiQG5hbWVzcGFjZVwifSxcbiAgICB7IG5hbWU6IFwiVklFV1BPUlRfU1lNXCIsIHRleHQ6IFtcIkB2aWV3cG9ydFwiLCBcIkAtbXMtdmlld3BvcnRcIiwgXCJALW8tdmlld3BvcnRcIl19LFxuICAgIHsgbmFtZTogXCJET0NVTUVOVF9TWU1cIiwgdGV4dDogW1wiQGRvY3VtZW50XCIsIFwiQC1tb3otZG9jdW1lbnRcIl19LFxuICAgIHsgbmFtZTogXCJVTktOT1dOX1NZTVwiIH0sXG4gICAgLy97IG5hbWU6IFwiQVRLRVlXT1JEXCJ9LFxuXG4gICAgLy9DU1MzIGFuaW1hdGlvbnNcbiAgICB7IG5hbWU6IFwiS0VZRlJBTUVTX1NZTVwiLCB0ZXh0OiBbIFwiQGtleWZyYW1lc1wiLCBcIkAtd2Via2l0LWtleWZyYW1lc1wiLCBcIkAtbW96LWtleWZyYW1lc1wiLCBcIkAtby1rZXlmcmFtZXNcIiBdIH0sXG5cbiAgICAvL2ltcG9ydGFudCBzeW1ib2xcbiAgICB7IG5hbWU6IFwiSU1QT1JUQU5UX1NZTVwifSxcblxuICAgIC8vbWVhc3VyZW1lbnRzXG4gICAgeyBuYW1lOiBcIkxFTkdUSFwifSxcbiAgICB7IG5hbWU6IFwiQU5HTEVcIn0sXG4gICAgeyBuYW1lOiBcIlRJTUVcIn0sXG4gICAgeyBuYW1lOiBcIkZSRVFcIn0sXG4gICAgeyBuYW1lOiBcIkRJTUVOU0lPTlwifSxcbiAgICB7IG5hbWU6IFwiUEVSQ0VOVEFHRVwifSxcbiAgICB7IG5hbWU6IFwiTlVNQkVSXCJ9LFxuXG4gICAgLy9mdW5jdGlvbnNcbiAgICB7IG5hbWU6IFwiVVJJXCJ9LFxuICAgIHsgbmFtZTogXCJGVU5DVElPTlwifSxcblxuICAgIC8vVW5pY29kZSByYW5nZXNcbiAgICB7IG5hbWU6IFwiVU5JQ09ERV9SQU5HRVwifSxcblxuICAgIC8qXG4gICAgICogVGhlIGZvbGxvd2luZyB0b2tlbiBuYW1lcyBhcmUgZGVmaW5lZCBpbiBDU1MzIFNlbGVjdG9yczogaHR0cDovL3d3dy53My5vcmcvVFIvY3NzMy1zZWxlY3RvcnMvI3NlbGVjdG9yLXN5bnRheFxuICAgICAqL1xuXG4gICAgLy9pbnZhbGlkIHN0cmluZ1xuICAgIHsgbmFtZTogXCJJTlZBTElEXCJ9LFxuXG4gICAgLy9jb21iaW5hdG9yc1xuICAgIHsgbmFtZTogXCJQTFVTXCIsIHRleHQ6IFwiK1wiIH0sXG4gICAgeyBuYW1lOiBcIkdSRUFURVJcIiwgdGV4dDogXCI+XCJ9LFxuICAgIHsgbmFtZTogXCJDT01NQVwiLCB0ZXh0OiBcIixcIn0sXG4gICAgeyBuYW1lOiBcIlRJTERFXCIsIHRleHQ6IFwiflwifSxcblxuICAgIC8vbW9kaWZpZXJcbiAgICB7IG5hbWU6IFwiTk9UXCJ9LFxuXG4gICAgLypcbiAgICAgKiBEZWZpbmVkIGluIENTUzMgUGFnZWQgTWVkaWFcbiAgICAgKi9cbiAgICB7IG5hbWU6IFwiVE9QTEVGVENPUk5FUl9TWU1cIiwgdGV4dDogXCJAdG9wLWxlZnQtY29ybmVyXCJ9LFxuICAgIHsgbmFtZTogXCJUT1BMRUZUX1NZTVwiLCB0ZXh0OiBcIkB0b3AtbGVmdFwifSxcbiAgICB7IG5hbWU6IFwiVE9QQ0VOVEVSX1NZTVwiLCB0ZXh0OiBcIkB0b3AtY2VudGVyXCJ9LFxuICAgIHsgbmFtZTogXCJUT1BSSUdIVF9TWU1cIiwgdGV4dDogXCJAdG9wLXJpZ2h0XCJ9LFxuICAgIHsgbmFtZTogXCJUT1BSSUdIVENPUk5FUl9TWU1cIiwgdGV4dDogXCJAdG9wLXJpZ2h0LWNvcm5lclwifSxcbiAgICB7IG5hbWU6IFwiQk9UVE9NTEVGVENPUk5FUl9TWU1cIiwgdGV4dDogXCJAYm90dG9tLWxlZnQtY29ybmVyXCJ9LFxuICAgIHsgbmFtZTogXCJCT1RUT01MRUZUX1NZTVwiLCB0ZXh0OiBcIkBib3R0b20tbGVmdFwifSxcbiAgICB7IG5hbWU6IFwiQk9UVE9NQ0VOVEVSX1NZTVwiLCB0ZXh0OiBcIkBib3R0b20tY2VudGVyXCJ9LFxuICAgIHsgbmFtZTogXCJCT1RUT01SSUdIVF9TWU1cIiwgdGV4dDogXCJAYm90dG9tLXJpZ2h0XCJ9LFxuICAgIHsgbmFtZTogXCJCT1RUT01SSUdIVENPUk5FUl9TWU1cIiwgdGV4dDogXCJAYm90dG9tLXJpZ2h0LWNvcm5lclwifSxcbiAgICB7IG5hbWU6IFwiTEVGVFRPUF9TWU1cIiwgdGV4dDogXCJAbGVmdC10b3BcIn0sXG4gICAgeyBuYW1lOiBcIkxFRlRNSURETEVfU1lNXCIsIHRleHQ6IFwiQGxlZnQtbWlkZGxlXCJ9LFxuICAgIHsgbmFtZTogXCJMRUZUQk9UVE9NX1NZTVwiLCB0ZXh0OiBcIkBsZWZ0LWJvdHRvbVwifSxcbiAgICB7IG5hbWU6IFwiUklHSFRUT1BfU1lNXCIsIHRleHQ6IFwiQHJpZ2h0LXRvcFwifSxcbiAgICB7IG5hbWU6IFwiUklHSFRNSURETEVfU1lNXCIsIHRleHQ6IFwiQHJpZ2h0LW1pZGRsZVwifSxcbiAgICB7IG5hbWU6IFwiUklHSFRCT1RUT01fU1lNXCIsIHRleHQ6IFwiQHJpZ2h0LWJvdHRvbVwifSxcblxuICAgIC8qXG4gICAgICogVGhlIGZvbGxvd2luZyB0b2tlbiBuYW1lcyBhcmUgZGVmaW5lZCBpbiBDU1MzIE1lZGlhIFF1ZXJpZXM6IGh0dHA6Ly93d3cudzMub3JnL1RSL2NzczMtbWVkaWFxdWVyaWVzLyNzeW50YXhcbiAgICAgKi9cbiAgICAvKnsgbmFtZTogXCJNRURJQV9PTkxZXCIsIHN0YXRlOiBcIm1lZGlhXCJ9LFxuICAgIHsgbmFtZTogXCJNRURJQV9OT1RcIiwgc3RhdGU6IFwibWVkaWFcIn0sXG4gICAgeyBuYW1lOiBcIk1FRElBX0FORFwiLCBzdGF0ZTogXCJtZWRpYVwifSwqL1xuICAgIHsgbmFtZTogXCJSRVNPTFVUSU9OXCIsIHN0YXRlOiBcIm1lZGlhXCJ9LFxuXG4gICAgLypcbiAgICAgKiBUaGUgZm9sbG93aW5nIHRva2VuIG5hbWVzIGFyZSBub3QgZGVmaW5lZCBpbiBhbnkgQ1NTIHNwZWNpZmljYXRpb24gYnV0IGFyZSB1c2VkIGJ5IHRoZSBsZXhlci5cbiAgICAgKi9cblxuICAgIC8vbm90IGEgcmVhbCB0b2tlbiwgYnV0IHVzZWZ1bCBmb3Igc3R1cGlkIElFIGZpbHRlcnNcbiAgICB7IG5hbWU6IFwiSUVfRlVOQ1RJT05cIiB9LFxuXG4gICAgLy9wYXJ0IG9mIENTUzMgZ3JhbW1hciBidXQgbm90IHRoZSBGbGV4IGNvZGVcbiAgICB7IG5hbWU6IFwiQ0hBUlwiIH0sXG5cbiAgICAvL1RPRE86IE5lZWRlZD9cbiAgICAvL05vdCBkZWZpbmVkIGFzIHRva2VucywgYnV0IG1pZ2h0IGFzIHdlbGwgYmVcbiAgICB7XG4gICAgICAgIG5hbWU6IFwiUElQRVwiLFxuICAgICAgICB0ZXh0OiBcInxcIlxuICAgIH0sXG4gICAge1xuICAgICAgICBuYW1lOiBcIlNMQVNIXCIsXG4gICAgICAgIHRleHQ6IFwiL1wiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIG5hbWU6IFwiTUlOVVNcIixcbiAgICAgICAgdGV4dDogXCItXCJcbiAgICB9LFxuICAgIHtcbiAgICAgICAgbmFtZTogXCJTVEFSXCIsXG4gICAgICAgIHRleHQ6IFwiKlwiXG4gICAgfSxcblxuICAgIHtcbiAgICAgICAgbmFtZTogXCJMQlJBQ0VcIixcbiAgICAgICAgZW5kQ2hhcjogXCJ9XCIsXG4gICAgICAgIHRleHQ6IFwie1wiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIG5hbWU6IFwiUkJSQUNFXCIsXG4gICAgICAgIHRleHQ6IFwifVwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIG5hbWU6IFwiTEJSQUNLRVRcIixcbiAgICAgICAgZW5kQ2hhcjogXCJdXCIsXG4gICAgICAgIHRleHQ6IFwiW1wiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIG5hbWU6IFwiUkJSQUNLRVRcIixcbiAgICAgICAgdGV4dDogXCJdXCJcbiAgICB9LFxuICAgIHtcbiAgICAgICAgbmFtZTogXCJFUVVBTFNcIixcbiAgICAgICAgdGV4dDogXCI9XCJcbiAgICB9LFxuICAgIHtcbiAgICAgICAgbmFtZTogXCJDT0xPTlwiLFxuICAgICAgICB0ZXh0OiBcIjpcIlxuICAgIH0sXG4gICAge1xuICAgICAgICBuYW1lOiBcIlNFTUlDT0xPTlwiLFxuICAgICAgICB0ZXh0OiBcIjtcIlxuICAgIH0sXG5cbiAgICB7XG4gICAgICAgIG5hbWU6IFwiTFBBUkVOXCIsXG4gICAgICAgIGVuZENoYXI6IFwiKVwiLFxuICAgICAgICB0ZXh0OiBcIihcIlxuICAgIH0sXG4gICAge1xuICAgICAgICBuYW1lOiBcIlJQQVJFTlwiLFxuICAgICAgICB0ZXh0OiBcIilcIlxuICAgIH0sXG4gICAge1xuICAgICAgICBuYW1lOiBcIkRPVFwiLFxuICAgICAgICB0ZXh0OiBcIi5cIlxuICAgIH1cbl07XG5cbihmdW5jdGlvbigpe1xuXG4gICAgdmFyIG5hbWVNYXAgPSBbXSxcbiAgICAgICAgdHlwZU1hcCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgICBUb2tlbnMuVU5LTk9XTiA9IC0xO1xuICAgIFRva2Vucy51bnNoaWZ0KHtuYW1lOlwiRU9GXCJ9KTtcbiAgICBmb3IgKHZhciBpPTAsIGxlbiA9IFRva2Vucy5sZW5ndGg7IGkgPCBsZW47IGkrKyl7XG4gICAgICAgIG5hbWVNYXAucHVzaChUb2tlbnNbaV0ubmFtZSk7XG4gICAgICAgIFRva2Vuc1tUb2tlbnNbaV0ubmFtZV0gPSBpO1xuICAgICAgICBpZiAoVG9rZW5zW2ldLnRleHQpe1xuICAgICAgICAgICAgaWYgKFRva2Vuc1tpXS50ZXh0IGluc3RhbmNlb2YgQXJyYXkpe1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGo9MDsgaiA8IFRva2Vuc1tpXS50ZXh0Lmxlbmd0aDsgaisrKXtcbiAgICAgICAgICAgICAgICAgICAgdHlwZU1hcFtUb2tlbnNbaV0udGV4dFtqXV0gPSBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdHlwZU1hcFtUb2tlbnNbaV0udGV4dF0gPSBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgVG9rZW5zLm5hbWUgPSBmdW5jdGlvbih0dCl7XG4gICAgICAgIHJldHVybiBuYW1lTWFwW3R0XTtcbiAgICB9O1xuXG4gICAgVG9rZW5zLnR5cGUgPSBmdW5jdGlvbihjKXtcbiAgICAgICAgcmV0dXJuIHR5cGVNYXBbY10gfHwgLTE7XG4gICAgfTtcblxufSkoKTtcblxuXG5cbi8vVGhpcyBmaWxlIHdpbGwgbGlrZWx5IGNoYW5nZSBhIGxvdCEgVmVyeSBleHBlcmltZW50YWwhXG52YXIgVmFsaWRhdGlvbiA9IHtcblxuICAgIHZhbGlkYXRlOiBmdW5jdGlvbihwcm9wZXJ0eSwgdmFsdWUpe1xuXG4gICAgICAgIC8vbm9ybWFsaXplIG5hbWVcbiAgICAgICAgdmFyIG5hbWUgICAgICAgID0gcHJvcGVydHkudG9TdHJpbmcoKS50b0xvd2VyQ2FzZSgpLFxuICAgICAgICAgICAgZXhwcmVzc2lvbiAgPSBuZXcgUHJvcGVydHlWYWx1ZUl0ZXJhdG9yKHZhbHVlKSxcbiAgICAgICAgICAgIHNwZWMgICAgICAgID0gUHJvcGVydGllc1tuYW1lXTtcblxuICAgICAgICBpZiAoIXNwZWMpIHtcbiAgICAgICAgICAgIGlmIChuYW1lLmluZGV4T2YoXCItXCIpICE9PSAwKXsgICAgLy92ZW5kb3IgcHJlZml4ZWQgYXJlIG9rXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcihcIlVua25vd24gcHJvcGVydHkgJ1wiICsgcHJvcGVydHkgKyBcIicuXCIsIHByb3BlcnR5LmxpbmUsIHByb3BlcnR5LmNvbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHNwZWMgIT09IFwibnVtYmVyXCIpe1xuXG4gICAgICAgICAgICAvL2luaXRpYWxpemF0aW9uXG4gICAgICAgICAgICBpZiAodHlwZW9mIHNwZWMgPT09IFwic3RyaW5nXCIpe1xuICAgICAgICAgICAgICAgIGlmIChzcGVjLmluZGV4T2YoXCJ8fFwiKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXBQcm9wZXJ0eShzcGVjLCBleHByZXNzaW9uKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNpbmdsZVByb3BlcnR5KHNwZWMsIGV4cHJlc3Npb24sIDEpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfSBlbHNlIGlmIChzcGVjLm11bHRpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tdWx0aVByb3BlcnR5KHNwZWMubXVsdGksIGV4cHJlc3Npb24sIHNwZWMuY29tbWEsIHNwZWMubWF4IHx8IEluZmluaXR5KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHNwZWMgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIHNwZWMoZXhwcmVzc2lvbik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIHNpbmdsZVByb3BlcnR5OiBmdW5jdGlvbih0eXBlcywgZXhwcmVzc2lvbiwgbWF4LCBwYXJ0aWFsKSB7XG5cbiAgICAgICAgdmFyIHJlc3VsdCAgICAgID0gZmFsc2UsXG4gICAgICAgICAgICB2YWx1ZSAgICAgICA9IGV4cHJlc3Npb24udmFsdWUsXG4gICAgICAgICAgICBjb3VudCAgICAgICA9IDAsXG4gICAgICAgICAgICBwYXJ0O1xuXG4gICAgICAgIHdoaWxlIChleHByZXNzaW9uLmhhc05leHQoKSAmJiBjb3VudCA8IG1heCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gVmFsaWRhdGlvblR5cGVzLmlzQW55KGV4cHJlc3Npb24sIHR5cGVzKTtcbiAgICAgICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb3VudCsrO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICAgIGlmIChleHByZXNzaW9uLmhhc05leHQoKSAmJiAhZXhwcmVzc2lvbi5pc0ZpcnN0KCkpIHtcbiAgICAgICAgICAgICAgICBwYXJ0ID0gZXhwcmVzc2lvbi5wZWVrKCk7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcihcIkV4cGVjdGVkIGVuZCBvZiB2YWx1ZSBidXQgZm91bmQgJ1wiICsgcGFydCArIFwiJy5cIiwgcGFydC5saW5lLCBwYXJ0LmNvbCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKFwiRXhwZWN0ZWQgKFwiICsgdHlwZXMgKyBcIikgYnV0IGZvdW5kICdcIiArIHZhbHVlICsgXCInLlwiLCB2YWx1ZS5saW5lLCB2YWx1ZS5jb2wpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGV4cHJlc3Npb24uaGFzTmV4dCgpKSB7XG4gICAgICAgICAgICBwYXJ0ID0gZXhwcmVzc2lvbi5uZXh0KCk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKFwiRXhwZWN0ZWQgZW5kIG9mIHZhbHVlIGJ1dCBmb3VuZCAnXCIgKyBwYXJ0ICsgXCInLlwiLCBwYXJ0LmxpbmUsIHBhcnQuY29sKTtcbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIG11bHRpUHJvcGVydHk6IGZ1bmN0aW9uICh0eXBlcywgZXhwcmVzc2lvbiwgY29tbWEsIG1heCkge1xuXG4gICAgICAgIHZhciByZXN1bHQgICAgICA9IGZhbHNlLFxuICAgICAgICAgICAgdmFsdWUgICAgICAgPSBleHByZXNzaW9uLnZhbHVlLFxuICAgICAgICAgICAgY291bnQgICAgICAgPSAwLFxuICAgICAgICAgICAgcGFydDtcblxuICAgICAgICB3aGlsZShleHByZXNzaW9uLmhhc05leHQoKSAmJiAhcmVzdWx0ICYmIGNvdW50IDwgbWF4KSB7XG4gICAgICAgICAgICBpZiAoVmFsaWRhdGlvblR5cGVzLmlzQW55KGV4cHJlc3Npb24sIHR5cGVzKSkge1xuICAgICAgICAgICAgICAgIGNvdW50Kys7XG4gICAgICAgICAgICAgICAgaWYgKCFleHByZXNzaW9uLmhhc05leHQoKSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjb21tYSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoU3RyaW5nKGV4cHJlc3Npb24ucGVlaygpKSA9PT0gXCIsXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnQgPSBleHByZXNzaW9uLm5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICAgIGlmIChleHByZXNzaW9uLmhhc05leHQoKSAmJiAhZXhwcmVzc2lvbi5pc0ZpcnN0KCkpIHtcbiAgICAgICAgICAgICAgICBwYXJ0ID0gZXhwcmVzc2lvbi5wZWVrKCk7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcihcIkV4cGVjdGVkIGVuZCBvZiB2YWx1ZSBidXQgZm91bmQgJ1wiICsgcGFydCArIFwiJy5cIiwgcGFydC5saW5lLCBwYXJ0LmNvbCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhcnQgPSBleHByZXNzaW9uLnByZXZpb3VzKCk7XG4gICAgICAgICAgICAgICAgaWYgKGNvbW1hICYmIFN0cmluZyhwYXJ0KSA9PT0gXCIsXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcihcIkV4cGVjdGVkIGVuZCBvZiB2YWx1ZSBidXQgZm91bmQgJ1wiICsgcGFydCArIFwiJy5cIiwgcGFydC5saW5lLCBwYXJ0LmNvbCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcihcIkV4cGVjdGVkIChcIiArIHR5cGVzICsgXCIpIGJ1dCBmb3VuZCAnXCIgKyB2YWx1ZSArIFwiJy5cIiwgdmFsdWUubGluZSwgdmFsdWUuY29sKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIGlmIChleHByZXNzaW9uLmhhc05leHQoKSkge1xuICAgICAgICAgICAgcGFydCA9IGV4cHJlc3Npb24ubmV4dCgpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcihcIkV4cGVjdGVkIGVuZCBvZiB2YWx1ZSBidXQgZm91bmQgJ1wiICsgcGFydCArIFwiJy5cIiwgcGFydC5saW5lLCBwYXJ0LmNvbCk7XG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICBncm91cFByb3BlcnR5OiBmdW5jdGlvbiAodHlwZXMsIGV4cHJlc3Npb24sIGNvbW1hKSB7XG5cbiAgICAgICAgdmFyIHJlc3VsdCAgICAgID0gZmFsc2UsXG4gICAgICAgICAgICB2YWx1ZSAgICAgICA9IGV4cHJlc3Npb24udmFsdWUsXG4gICAgICAgICAgICB0eXBlQ291bnQgICA9IHR5cGVzLnNwbGl0KFwifHxcIikubGVuZ3RoLFxuICAgICAgICAgICAgZ3JvdXBzICAgICAgPSB7IGNvdW50OiAwIH0sXG4gICAgICAgICAgICBwYXJ0aWFsICAgICA9IGZhbHNlLFxuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIHBhcnQ7XG5cbiAgICAgICAgd2hpbGUoZXhwcmVzc2lvbi5oYXNOZXh0KCkgJiYgIXJlc3VsdCkge1xuICAgICAgICAgICAgbmFtZSA9IFZhbGlkYXRpb25UeXBlcy5pc0FueU9mR3JvdXAoZXhwcmVzc2lvbiwgdHlwZXMpO1xuICAgICAgICAgICAgaWYgKG5hbWUpIHtcblxuICAgICAgICAgICAgICAgIC8vbm8gZHVwZXNcbiAgICAgICAgICAgICAgICBpZiAoZ3JvdXBzW25hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGdyb3Vwc1tuYW1lXSA9IDE7XG4gICAgICAgICAgICAgICAgICAgIGdyb3Vwcy5jb3VudCsrO1xuICAgICAgICAgICAgICAgICAgICBwYXJ0aWFsID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoZ3JvdXBzLmNvdW50ID09PSB0eXBlQ291bnQgfHwgIWV4cHJlc3Npb24uaGFzTmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgICBpZiAocGFydGlhbCAmJiBleHByZXNzaW9uLmhhc05leHQoKSkge1xuICAgICAgICAgICAgICAgICAgICBwYXJ0ID0gZXhwcmVzc2lvbi5wZWVrKCk7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBWYWxpZGF0aW9uRXJyb3IoXCJFeHBlY3RlZCBlbmQgb2YgdmFsdWUgYnV0IGZvdW5kICdcIiArIHBhcnQgKyBcIicuXCIsIHBhcnQubGluZSwgcGFydC5jb2wpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKFwiRXhwZWN0ZWQgKFwiICsgdHlwZXMgKyBcIikgYnV0IGZvdW5kICdcIiArIHZhbHVlICsgXCInLlwiLCB2YWx1ZS5saW5lLCB2YWx1ZS5jb2wpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGV4cHJlc3Npb24uaGFzTmV4dCgpKSB7XG4gICAgICAgICAgICBwYXJ0ID0gZXhwcmVzc2lvbi5uZXh0KCk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKFwiRXhwZWN0ZWQgZW5kIG9mIHZhbHVlIGJ1dCBmb3VuZCAnXCIgKyBwYXJ0ICsgXCInLlwiLCBwYXJ0LmxpbmUsIHBhcnQuY29sKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn07XG4vKipcbiAqIFR5cGUgdG8gdXNlIHdoZW4gYSB2YWxpZGF0aW9uIGVycm9yIG9jY3Vycy5cbiAqIEBjbGFzcyBWYWxpZGF0aW9uRXJyb3JcbiAqIEBuYW1lc3BhY2UgcGFyc2VybGliLnV0aWxcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgVGhlIGVycm9yIG1lc3NhZ2UuXG4gKiBAcGFyYW0ge2ludH0gbGluZSBUaGUgbGluZSBhdCB3aGljaCB0aGUgZXJyb3Igb2NjdXJyZWQuXG4gKiBAcGFyYW0ge2ludH0gY29sIFRoZSBjb2x1bW4gYXQgd2hpY2ggdGhlIGVycm9yIG9jY3VycmVkLlxuICovXG5mdW5jdGlvbiBWYWxpZGF0aW9uRXJyb3IobWVzc2FnZSwgbGluZSwgY29sKXtcblxuICAgIC8qKlxuICAgICAqIFRoZSBjb2x1bW4gYXQgd2hpY2ggdGhlIGVycm9yIG9jY3VycmVkLlxuICAgICAqIEB0eXBlIGludFxuICAgICAqIEBwcm9wZXJ0eSBjb2xcbiAgICAgKi9cbiAgICB0aGlzLmNvbCA9IGNvbDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBsaW5lIGF0IHdoaWNoIHRoZSBlcnJvciBvY2N1cnJlZC5cbiAgICAgKiBAdHlwZSBpbnRcbiAgICAgKiBAcHJvcGVydHkgbGluZVxuICAgICAqL1xuICAgIHRoaXMubGluZSA9IGxpbmU7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdGV4dCByZXByZXNlbnRhdGlvbiBvZiB0aGUgdW5pdC5cbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAcHJvcGVydHkgdGV4dFxuICAgICAqL1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG5cbn1cblxuLy9pbmhlcml0IGZyb20gRXJyb3JcblZhbGlkYXRpb25FcnJvci5wcm90b3R5cGUgPSBuZXcgRXJyb3IoKTtcbi8vVGhpcyBmaWxlIHdpbGwgbGlrZWx5IGNoYW5nZSBhIGxvdCEgVmVyeSBleHBlcmltZW50YWwhXG52YXIgVmFsaWRhdGlvblR5cGVzID0ge1xuXG4gICAgaXNMaXRlcmFsOiBmdW5jdGlvbiAocGFydCwgbGl0ZXJhbHMpIHtcbiAgICAgICAgdmFyIHRleHQgPSBwYXJ0LnRleHQudG9TdHJpbmcoKS50b0xvd2VyQ2FzZSgpLFxuICAgICAgICAgICAgYXJncyA9IGxpdGVyYWxzLnNwbGl0KFwiIHwgXCIpLFxuICAgICAgICAgICAgaSwgbGVuLCBmb3VuZCA9IGZhbHNlO1xuXG4gICAgICAgIGZvciAoaT0wLGxlbj1hcmdzLmxlbmd0aDsgaSA8IGxlbiAmJiAhZm91bmQ7IGkrKyl7XG4gICAgICAgICAgICBpZiAodGV4dCA9PT0gYXJnc1tpXS50b0xvd2VyQ2FzZSgpKXtcbiAgICAgICAgICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZm91bmQ7XG4gICAgfSxcblxuICAgIGlzU2ltcGxlOiBmdW5jdGlvbih0eXBlKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuc2ltcGxlW3R5cGVdO1xuICAgIH0sXG5cbiAgICBpc0NvbXBsZXg6IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5jb21wbGV4W3R5cGVdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIGlmIHRoZSBuZXh0IHBhcnQocykgb2YgdGhlIGdpdmVuIGV4cHJlc3Npb25cbiAgICAgKiBhcmUgYW55IG9mIHRoZSBnaXZlbiB0eXBlcy5cbiAgICAgKi9cbiAgICBpc0FueTogZnVuY3Rpb24gKGV4cHJlc3Npb24sIHR5cGVzKSB7XG4gICAgICAgIHZhciBhcmdzID0gdHlwZXMuc3BsaXQoXCIgfCBcIiksXG4gICAgICAgICAgICBpLCBsZW4sIGZvdW5kID0gZmFsc2U7XG5cbiAgICAgICAgZm9yIChpPTAsbGVuPWFyZ3MubGVuZ3RoOyBpIDwgbGVuICYmICFmb3VuZCAmJiBleHByZXNzaW9uLmhhc05leHQoKTsgaSsrKXtcbiAgICAgICAgICAgIGZvdW5kID0gdGhpcy5pc1R5cGUoZXhwcmVzc2lvbiwgYXJnc1tpXSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZm91bmQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgaWYgdGhlIG5leHQgcGFydChzKSBvZiB0aGUgZ2l2ZW4gZXhwcmVzc2lvblxuICAgICAqIGFyZSBvbmUgb2YgYSBncm91cC5cbiAgICAgKi9cbiAgICBpc0FueU9mR3JvdXA6IGZ1bmN0aW9uKGV4cHJlc3Npb24sIHR5cGVzKSB7XG4gICAgICAgIHZhciBhcmdzID0gdHlwZXMuc3BsaXQoXCIgfHwgXCIpLFxuICAgICAgICAgICAgaSwgbGVuLCBmb3VuZCA9IGZhbHNlO1xuXG4gICAgICAgIGZvciAoaT0wLGxlbj1hcmdzLmxlbmd0aDsgaSA8IGxlbiAmJiAhZm91bmQ7IGkrKyl7XG4gICAgICAgICAgICBmb3VuZCA9IHRoaXMuaXNUeXBlKGV4cHJlc3Npb24sIGFyZ3NbaV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZvdW5kID8gYXJnc1tpLTFdIDogZmFsc2U7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgaWYgdGhlIG5leHQgcGFydChzKSBvZiB0aGUgZ2l2ZW4gZXhwcmVzc2lvblxuICAgICAqIGFyZSBvZiBhIGdpdmVuIHR5cGUuXG4gICAgICovXG4gICAgaXNUeXBlOiBmdW5jdGlvbiAoZXhwcmVzc2lvbiwgdHlwZSkge1xuICAgICAgICB2YXIgcGFydCA9IGV4cHJlc3Npb24ucGVlaygpLFxuICAgICAgICAgICAgcmVzdWx0ID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKHR5cGUuY2hhckF0KDApICE9PSBcIjxcIikge1xuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5pc0xpdGVyYWwocGFydCwgdHlwZSk7XG4gICAgICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgZXhwcmVzc2lvbi5uZXh0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5zaW1wbGVbdHlwZV0pIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuc2ltcGxlW3R5cGVdKHBhcnQpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIGV4cHJlc3Npb24ubmV4dCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5jb21wbGV4W3R5cGVdKGV4cHJlc3Npb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG5cblxuICAgIHNpbXBsZToge1xuICAgICAgICBfX3Byb3RvX186IG51bGwsXG5cbiAgICAgICAgXCI8YWJzb2x1dGUtc2l6ZT5cIjogZnVuY3Rpb24ocGFydCl7XG4gICAgICAgICAgICByZXR1cm4gVmFsaWRhdGlvblR5cGVzLmlzTGl0ZXJhbChwYXJ0LCBcInh4LXNtYWxsIHwgeC1zbWFsbCB8IHNtYWxsIHwgbWVkaXVtIHwgbGFyZ2UgfCB4LWxhcmdlIHwgeHgtbGFyZ2VcIik7XG4gICAgICAgIH0sXG5cbiAgICAgICAgXCI8YXR0YWNobWVudD5cIjogZnVuY3Rpb24ocGFydCl7XG4gICAgICAgICAgICByZXR1cm4gVmFsaWRhdGlvblR5cGVzLmlzTGl0ZXJhbChwYXJ0LCBcInNjcm9sbCB8IGZpeGVkIHwgbG9jYWxcIik7XG4gICAgICAgIH0sXG5cbiAgICAgICAgXCI8YXR0cj5cIjogZnVuY3Rpb24ocGFydCl7XG4gICAgICAgICAgICByZXR1cm4gcGFydC50eXBlID09PSBcImZ1bmN0aW9uXCIgJiYgcGFydC5uYW1lID09PSBcImF0dHJcIjtcbiAgICAgICAgfSxcblxuICAgICAgICBcIjxiZy1pbWFnZT5cIjogZnVuY3Rpb24ocGFydCl7XG4gICAgICAgICAgICByZXR1cm4gdGhpc1tcIjxpbWFnZT5cIl0ocGFydCkgfHwgdGhpc1tcIjxncmFkaWVudD5cIl0ocGFydCkgfHwgIFN0cmluZyhwYXJ0KSA9PT0gXCJub25lXCI7XG4gICAgICAgIH0sXG5cbiAgICAgICAgXCI8Z3JhZGllbnQ+XCI6IGZ1bmN0aW9uKHBhcnQpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJ0LnR5cGUgPT09IFwiZnVuY3Rpb25cIiAmJiAvXig/OlxcLSg/Om1zfG1venxvfHdlYmtpdClcXC0pPyg/OnJlcGVhdGluZ1xcLSk/KD86cmFkaWFsXFwtfGxpbmVhclxcLSk/Z3JhZGllbnQvaS50ZXN0KHBhcnQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIFwiPGJveD5cIjogZnVuY3Rpb24ocGFydCl7XG4gICAgICAgICAgICByZXR1cm4gVmFsaWRhdGlvblR5cGVzLmlzTGl0ZXJhbChwYXJ0LCBcInBhZGRpbmctYm94IHwgYm9yZGVyLWJveCB8IGNvbnRlbnQtYm94XCIpO1xuICAgICAgICB9LFxuXG4gICAgICAgIFwiPGNvbnRlbnQ+XCI6IGZ1bmN0aW9uKHBhcnQpe1xuICAgICAgICAgICAgcmV0dXJuIHBhcnQudHlwZSA9PT0gXCJmdW5jdGlvblwiICYmIHBhcnQubmFtZSA9PT0gXCJjb250ZW50XCI7XG4gICAgICAgIH0sXG5cbiAgICAgICAgXCI8cmVsYXRpdmUtc2l6ZT5cIjogZnVuY3Rpb24ocGFydCl7XG4gICAgICAgICAgICByZXR1cm4gVmFsaWRhdGlvblR5cGVzLmlzTGl0ZXJhbChwYXJ0LCBcInNtYWxsZXIgfCBsYXJnZXJcIik7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy9hbnkgaWRlbnRpZmllclxuICAgICAgICBcIjxpZGVudD5cIjogZnVuY3Rpb24ocGFydCl7XG4gICAgICAgICAgICByZXR1cm4gcGFydC50eXBlID09PSBcImlkZW50aWZpZXJcIjtcbiAgICAgICAgfSxcblxuICAgICAgICBcIjxsZW5ndGg+XCI6IGZ1bmN0aW9uKHBhcnQpe1xuICAgICAgICAgICAgaWYgKHBhcnQudHlwZSA9PT0gXCJmdW5jdGlvblwiICYmIC9eKD86XFwtKD86bXN8bW96fG98d2Via2l0KVxcLSk/Y2FsYy9pLnRlc3QocGFydCkpe1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnQudHlwZSA9PT0gXCJsZW5ndGhcIiB8fCBwYXJ0LnR5cGUgPT09IFwibnVtYmVyXCIgfHwgcGFydC50eXBlID09PSBcImludGVnZXJcIiB8fCBTdHJpbmcocGFydCkgPT09IFwiMFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIFwiPGNvbG9yPlwiOiBmdW5jdGlvbihwYXJ0KXtcbiAgICAgICAgICAgIHJldHVybiBwYXJ0LnR5cGUgPT09IFwiY29sb3JcIiB8fCBTdHJpbmcocGFydCkgPT09IFwidHJhbnNwYXJlbnRcIiB8fCBTdHJpbmcocGFydCkgPT09IFwiY3VycmVudENvbG9yXCI7XG4gICAgICAgIH0sXG5cbiAgICAgICAgXCI8bnVtYmVyPlwiOiBmdW5jdGlvbihwYXJ0KXtcbiAgICAgICAgICAgIHJldHVybiBwYXJ0LnR5cGUgPT09IFwibnVtYmVyXCIgfHwgdGhpc1tcIjxpbnRlZ2VyPlwiXShwYXJ0KTtcbiAgICAgICAgfSxcblxuICAgICAgICBcIjxpbnRlZ2VyPlwiOiBmdW5jdGlvbihwYXJ0KXtcbiAgICAgICAgICAgIHJldHVybiBwYXJ0LnR5cGUgPT09IFwiaW50ZWdlclwiO1xuICAgICAgICB9LFxuXG4gICAgICAgIFwiPGxpbmU+XCI6IGZ1bmN0aW9uKHBhcnQpe1xuICAgICAgICAgICAgcmV0dXJuIHBhcnQudHlwZSA9PT0gXCJpbnRlZ2VyXCI7XG4gICAgICAgIH0sXG5cbiAgICAgICAgXCI8YW5nbGU+XCI6IGZ1bmN0aW9uKHBhcnQpe1xuICAgICAgICAgICAgcmV0dXJuIHBhcnQudHlwZSA9PT0gXCJhbmdsZVwiO1xuICAgICAgICB9LFxuXG4gICAgICAgIFwiPHVyaT5cIjogZnVuY3Rpb24ocGFydCl7XG4gICAgICAgICAgICByZXR1cm4gcGFydC50eXBlID09PSBcInVyaVwiO1xuICAgICAgICB9LFxuXG4gICAgICAgIFwiPGltYWdlPlwiOiBmdW5jdGlvbihwYXJ0KXtcbiAgICAgICAgICAgIHJldHVybiB0aGlzW1wiPHVyaT5cIl0ocGFydCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgXCI8cGVyY2VudGFnZT5cIjogZnVuY3Rpb24ocGFydCl7XG4gICAgICAgICAgICByZXR1cm4gcGFydC50eXBlID09PSBcInBlcmNlbnRhZ2VcIiB8fCBTdHJpbmcocGFydCkgPT09IFwiMFwiO1xuICAgICAgICB9LFxuXG4gICAgICAgIFwiPGJvcmRlci13aWR0aD5cIjogZnVuY3Rpb24ocGFydCl7XG4gICAgICAgICAgICByZXR1cm4gdGhpc1tcIjxsZW5ndGg+XCJdKHBhcnQpIHx8IFZhbGlkYXRpb25UeXBlcy5pc0xpdGVyYWwocGFydCwgXCJ0aGluIHwgbWVkaXVtIHwgdGhpY2tcIik7XG4gICAgICAgIH0sXG5cbiAgICAgICAgXCI8Ym9yZGVyLXN0eWxlPlwiOiBmdW5jdGlvbihwYXJ0KXtcbiAgICAgICAgICAgIHJldHVybiBWYWxpZGF0aW9uVHlwZXMuaXNMaXRlcmFsKHBhcnQsIFwibm9uZSB8IGhpZGRlbiB8IGRvdHRlZCB8IGRhc2hlZCB8IHNvbGlkIHwgZG91YmxlIHwgZ3Jvb3ZlIHwgcmlkZ2UgfCBpbnNldCB8IG91dHNldFwiKTtcbiAgICAgICAgfSxcblxuICAgICAgICBcIjxjb250ZW50LXNpemluZz5cIjogZnVuY3Rpb24ocGFydCl7IC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL2NzczMtc2l6aW5nLyN3aWR0aC1oZWlnaHQta2V5d29yZHNcbiAgICAgICAgICAgIHJldHVybiBWYWxpZGF0aW9uVHlwZXMuaXNMaXRlcmFsKHBhcnQsIFwiZmlsbC1hdmFpbGFibGUgfCAtbW96LWF2YWlsYWJsZSB8IC13ZWJraXQtZmlsbC1hdmFpbGFibGUgfCBtYXgtY29udGVudCB8IC1tb3otbWF4LWNvbnRlbnQgfCAtd2Via2l0LW1heC1jb250ZW50IHwgbWluLWNvbnRlbnQgfCAtbW96LW1pbi1jb250ZW50IHwgLXdlYmtpdC1taW4tY29udGVudCB8IGZpdC1jb250ZW50IHwgLW1vei1maXQtY29udGVudCB8IC13ZWJraXQtZml0LWNvbnRlbnRcIik7XG4gICAgICAgIH0sXG5cbiAgICAgICAgXCI8bWFyZ2luLXdpZHRoPlwiOiBmdW5jdGlvbihwYXJ0KXtcbiAgICAgICAgICAgIHJldHVybiB0aGlzW1wiPGxlbmd0aD5cIl0ocGFydCkgfHwgdGhpc1tcIjxwZXJjZW50YWdlPlwiXShwYXJ0KSB8fCBWYWxpZGF0aW9uVHlwZXMuaXNMaXRlcmFsKHBhcnQsIFwiYXV0b1wiKTtcbiAgICAgICAgfSxcblxuICAgICAgICBcIjxwYWRkaW5nLXdpZHRoPlwiOiBmdW5jdGlvbihwYXJ0KXtcbiAgICAgICAgICAgIHJldHVybiB0aGlzW1wiPGxlbmd0aD5cIl0ocGFydCkgfHwgdGhpc1tcIjxwZXJjZW50YWdlPlwiXShwYXJ0KTtcbiAgICAgICAgfSxcblxuICAgICAgICBcIjxzaGFwZT5cIjogZnVuY3Rpb24ocGFydCl7XG4gICAgICAgICAgICByZXR1cm4gcGFydC50eXBlID09PSBcImZ1bmN0aW9uXCIgJiYgKHBhcnQubmFtZSA9PT0gXCJyZWN0XCIgfHwgcGFydC5uYW1lID09PSBcImluc2V0LXJlY3RcIik7XG4gICAgICAgIH0sXG5cbiAgICAgICAgXCI8dGltZT5cIjogZnVuY3Rpb24ocGFydCkge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnQudHlwZSA9PT0gXCJ0aW1lXCI7XG4gICAgICAgIH0sXG5cbiAgICAgICAgXCI8ZmxleC1ncm93PlwiOiBmdW5jdGlvbihwYXJ0KXtcbiAgICAgICAgICAgIHJldHVybiB0aGlzW1wiPG51bWJlcj5cIl0ocGFydCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgXCI8ZmxleC1zaHJpbms+XCI6IGZ1bmN0aW9uKHBhcnQpe1xuICAgICAgICAgICAgcmV0dXJuIHRoaXNbXCI8bnVtYmVyPlwiXShwYXJ0KTtcbiAgICAgICAgfSxcblxuICAgICAgICBcIjx3aWR0aD5cIjogZnVuY3Rpb24ocGFydCl7XG4gICAgICAgICAgICByZXR1cm4gdGhpc1tcIjxtYXJnaW4td2lkdGg+XCJdKHBhcnQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIFwiPGZsZXgtYmFzaXM+XCI6IGZ1bmN0aW9uKHBhcnQpe1xuICAgICAgICAgICAgcmV0dXJuIHRoaXNbXCI8d2lkdGg+XCJdKHBhcnQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIFwiPGZsZXgtZGlyZWN0aW9uPlwiOiBmdW5jdGlvbihwYXJ0KXtcbiAgICAgICAgICAgIHJldHVybiBWYWxpZGF0aW9uVHlwZXMuaXNMaXRlcmFsKHBhcnQsIFwicm93IHwgcm93LXJldmVyc2UgfCBjb2x1bW4gfCBjb2x1bW4tcmV2ZXJzZVwiKTtcbiAgICAgICAgfSxcblxuICAgICAgICBcIjxmbGV4LXdyYXA+XCI6IGZ1bmN0aW9uKHBhcnQpe1xuICAgICAgICAgICAgcmV0dXJuIFZhbGlkYXRpb25UeXBlcy5pc0xpdGVyYWwocGFydCwgXCJub3dyYXAgfCB3cmFwIHwgd3JhcC1yZXZlcnNlXCIpO1xuICAgICAgICB9LFxuXG4gICAgICAgIFwiPGZlYXR1cmUtdGFnLXZhbHVlPlwiOiBmdW5jdGlvbihwYXJ0KXtcbiAgICAgICAgICAgIHJldHVybiAocGFydC50eXBlID09PSBcImZ1bmN0aW9uXCIgJiYgL15bQS1aMC05XXs0fSQvaS50ZXN0KHBhcnQpKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBjb21wbGV4OiB7XG4gICAgICAgIF9fcHJvdG9fXzogbnVsbCxcblxuICAgICAgICBcIjxiZy1wb3NpdGlvbj5cIjogZnVuY3Rpb24oZXhwcmVzc2lvbil7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ICA9IGZhbHNlLFxuICAgICAgICAgICAgICAgIG51bWVyaWMgPSBcIjxwZXJjZW50YWdlPiB8IDxsZW5ndGg+XCIsXG4gICAgICAgICAgICAgICAgeERpciAgICA9IFwibGVmdCB8IHJpZ2h0XCIsXG4gICAgICAgICAgICAgICAgeURpciAgICA9IFwidG9wIHwgYm90dG9tXCIsXG4gICAgICAgICAgICAgICAgY291bnQgPSAwO1xuXG4gICAgICAgICAgICB3aGlsZSAoZXhwcmVzc2lvbi5wZWVrKGNvdW50KSAmJiBleHByZXNzaW9uLnBlZWsoY291bnQpLnRleHQgIT09IFwiLFwiKSB7XG4gICAgICAgICAgICAgICAgY291bnQrKztcbiAgICAgICAgICAgIH1cblxuLypcbjxwb3NpdGlvbj4gPSBbXG4gIFsgbGVmdCB8IGNlbnRlciB8IHJpZ2h0IHwgdG9wIHwgYm90dG9tIHwgPHBlcmNlbnRhZ2U+IHwgPGxlbmd0aD4gXVxufFxuICBbIGxlZnQgfCBjZW50ZXIgfCByaWdodCB8IDxwZXJjZW50YWdlPiB8IDxsZW5ndGg+IF1cbiAgWyB0b3AgfCBjZW50ZXIgfCBib3R0b20gfCA8cGVyY2VudGFnZT4gfCA8bGVuZ3RoPiBdXG58XG4gIFsgY2VudGVyIHwgWyBsZWZ0IHwgcmlnaHQgXSBbIDxwZXJjZW50YWdlPiB8IDxsZW5ndGg+IF0/IF0gJiZcbiAgWyBjZW50ZXIgfCBbIHRvcCB8IGJvdHRvbSBdIFsgPHBlcmNlbnRhZ2U+IHwgPGxlbmd0aD4gXT8gXVxuXVxuKi9cblxuICAgICAgICAgICAgaWYgKGNvdW50IDwgMykge1xuICAgICAgICAgICAgICAgIGlmIChWYWxpZGF0aW9uVHlwZXMuaXNBbnkoZXhwcmVzc2lvbiwgeERpciArIFwiIHwgY2VudGVyIHwgXCIgKyBudW1lcmljKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIFZhbGlkYXRpb25UeXBlcy5pc0FueShleHByZXNzaW9uLCB5RGlyICsgXCIgfCBjZW50ZXIgfCBcIiArIG51bWVyaWMpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoVmFsaWRhdGlvblR5cGVzLmlzQW55KGV4cHJlc3Npb24sIHlEaXIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgVmFsaWRhdGlvblR5cGVzLmlzQW55KGV4cHJlc3Npb24sIHhEaXIgKyBcIiB8IGNlbnRlclwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChWYWxpZGF0aW9uVHlwZXMuaXNBbnkoZXhwcmVzc2lvbiwgeERpcikpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFZhbGlkYXRpb25UeXBlcy5pc0FueShleHByZXNzaW9uLCB5RGlyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIFZhbGlkYXRpb25UeXBlcy5pc0FueShleHByZXNzaW9uLCBudW1lcmljKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChWYWxpZGF0aW9uVHlwZXMuaXNBbnkoZXhwcmVzc2lvbiwgbnVtZXJpYykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChWYWxpZGF0aW9uVHlwZXMuaXNBbnkoZXhwcmVzc2lvbiwgeURpcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFZhbGlkYXRpb25UeXBlcy5pc0FueShleHByZXNzaW9uLCBudW1lcmljKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoVmFsaWRhdGlvblR5cGVzLmlzQW55KGV4cHJlc3Npb24sIFwiY2VudGVyXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoVmFsaWRhdGlvblR5cGVzLmlzQW55KGV4cHJlc3Npb24sIHlEaXIpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChWYWxpZGF0aW9uVHlwZXMuaXNBbnkoZXhwcmVzc2lvbiwgeERpcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBWYWxpZGF0aW9uVHlwZXMuaXNBbnkoZXhwcmVzc2lvbiwgbnVtZXJpYyk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoVmFsaWRhdGlvblR5cGVzLmlzQW55KGV4cHJlc3Npb24sIG51bWVyaWMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoVmFsaWRhdGlvblR5cGVzLmlzQW55KGV4cHJlc3Npb24sIHhEaXIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFZhbGlkYXRpb25UeXBlcy5pc0FueShleHByZXNzaW9uLCBudW1lcmljKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoVmFsaWRhdGlvblR5cGVzLmlzQW55KGV4cHJlc3Npb24sIFwiY2VudGVyXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoVmFsaWRhdGlvblR5cGVzLmlzQW55KGV4cHJlc3Npb24sIFwiY2VudGVyXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChWYWxpZGF0aW9uVHlwZXMuaXNBbnkoZXhwcmVzc2lvbiwgeERpciArIFwiIHwgXCIgKyB5RGlyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIFZhbGlkYXRpb25UeXBlcy5pc0FueShleHByZXNzaW9uLCBudW1lcmljKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSxcblxuICAgICAgICBcIjxiZy1zaXplPlwiOiBmdW5jdGlvbihleHByZXNzaW9uKXtcbiAgICAgICAgICAgIC8vPGJnLXNpemU+ID0gWyA8bGVuZ3RoPiB8IDxwZXJjZW50YWdlPiB8IGF1dG8gXXsxLDJ9IHwgY292ZXIgfCBjb250YWluXG4gICAgICAgICAgICB2YXIgcmVzdWx0ICA9IGZhbHNlLFxuICAgICAgICAgICAgICAgIG51bWVyaWMgPSBcIjxwZXJjZW50YWdlPiB8IDxsZW5ndGg+IHwgYXV0b1wiO1xuXG4gICAgICAgICAgICBpZiAoVmFsaWRhdGlvblR5cGVzLmlzQW55KGV4cHJlc3Npb24sIFwiY292ZXIgfCBjb250YWluXCIpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoVmFsaWRhdGlvblR5cGVzLmlzQW55KGV4cHJlc3Npb24sIG51bWVyaWMpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBWYWxpZGF0aW9uVHlwZXMuaXNBbnkoZXhwcmVzc2lvbiwgbnVtZXJpYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgXCI8cmVwZWF0LXN0eWxlPlwiOiBmdW5jdGlvbihleHByZXNzaW9uKXtcbiAgICAgICAgICAgIC8vcmVwZWF0LXggfCByZXBlYXQteSB8IFtyZXBlYXQgfCBzcGFjZSB8IHJvdW5kIHwgbm8tcmVwZWF0XXsxLDJ9XG4gICAgICAgICAgICB2YXIgcmVzdWx0ICA9IGZhbHNlLFxuICAgICAgICAgICAgICAgIHZhbHVlcyAgPSBcInJlcGVhdCB8IHNwYWNlIHwgcm91bmQgfCBuby1yZXBlYXRcIixcbiAgICAgICAgICAgICAgICBwYXJ0O1xuXG4gICAgICAgICAgICBpZiAoZXhwcmVzc2lvbi5oYXNOZXh0KCkpe1xuICAgICAgICAgICAgICAgIHBhcnQgPSBleHByZXNzaW9uLm5leHQoKTtcblxuICAgICAgICAgICAgICAgIGlmIChWYWxpZGF0aW9uVHlwZXMuaXNMaXRlcmFsKHBhcnQsIFwicmVwZWF0LXggfCByZXBlYXQteVwiKSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoVmFsaWRhdGlvblR5cGVzLmlzTGl0ZXJhbChwYXJ0LCB2YWx1ZXMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGV4cHJlc3Npb24uaGFzTmV4dCgpICYmIFZhbGlkYXRpb25UeXBlcy5pc0xpdGVyYWwoZXhwcmVzc2lvbi5wZWVrKCksIHZhbHVlcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb24ubmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgXCI8c2hhZG93PlwiOiBmdW5jdGlvbihleHByZXNzaW9uKSB7XG4gICAgICAgICAgICAvL2luc2V0PyAmJiBbIDxsZW5ndGg+ezIsNH0gJiYgPGNvbG9yPj8gXVxuICAgICAgICAgICAgdmFyIHJlc3VsdCAgPSBmYWxzZSxcbiAgICAgICAgICAgICAgICBjb3VudCAgID0gMCxcbiAgICAgICAgICAgICAgICBpbnNldCAgID0gZmFsc2UsXG4gICAgICAgICAgICAgICAgY29sb3IgICA9IGZhbHNlO1xuXG4gICAgICAgICAgICBpZiAoZXhwcmVzc2lvbi5oYXNOZXh0KCkpIHtcblxuICAgICAgICAgICAgICAgIGlmIChWYWxpZGF0aW9uVHlwZXMuaXNBbnkoZXhwcmVzc2lvbiwgXCJpbnNldFwiKSl7XG4gICAgICAgICAgICAgICAgICAgIGluc2V0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoVmFsaWRhdGlvblR5cGVzLmlzQW55KGV4cHJlc3Npb24sIFwiPGNvbG9yPlwiKSkge1xuICAgICAgICAgICAgICAgICAgICBjb2xvciA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgd2hpbGUgKFZhbGlkYXRpb25UeXBlcy5pc0FueShleHByZXNzaW9uLCBcIjxsZW5ndGg+XCIpICYmIGNvdW50IDwgNCkge1xuICAgICAgICAgICAgICAgICAgICBjb3VudCsrO1xuICAgICAgICAgICAgICAgIH1cblxuXG4gICAgICAgICAgICAgICAgaWYgKGV4cHJlc3Npb24uaGFzTmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY29sb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFZhbGlkYXRpb25UeXBlcy5pc0FueShleHByZXNzaW9uLCBcIjxjb2xvcj5cIik7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoIWluc2V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBWYWxpZGF0aW9uVHlwZXMuaXNBbnkoZXhwcmVzc2lvbiwgXCJpbnNldFwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gKGNvdW50ID49IDIgJiYgY291bnQgPD0gNCk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSxcblxuICAgICAgICBcIjx4LW9uZS1yYWRpdXM+XCI6IGZ1bmN0aW9uKGV4cHJlc3Npb24pIHtcbiAgICAgICAgICAgIC8vWyA8bGVuZ3RoPiB8IDxwZXJjZW50YWdlPiBdIFsgPGxlbmd0aD4gfCA8cGVyY2VudGFnZT4gXT9cbiAgICAgICAgICAgIHZhciByZXN1bHQgID0gZmFsc2UsXG4gICAgICAgICAgICAgICAgc2ltcGxlID0gXCI8bGVuZ3RoPiB8IDxwZXJjZW50YWdlPiB8IGluaGVyaXRcIjtcblxuICAgICAgICAgICAgaWYgKFZhbGlkYXRpb25UeXBlcy5pc0FueShleHByZXNzaW9uLCBzaW1wbGUpKXtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIFZhbGlkYXRpb25UeXBlcy5pc0FueShleHByZXNzaW9uLCBzaW1wbGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9LFxuXG4gICAgICAgIFwiPGZsZXg+XCI6IGZ1bmN0aW9uKGV4cHJlc3Npb24pIHtcbiAgICAgICAgICAgIC8vIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTQvV0QtY3NzLWZsZXhib3gtMS0yMDE0MDMyNS8jZmxleC1wcm9wZXJ0eVxuICAgICAgICAgICAgLy8gbm9uZSB8IFsgPGZsZXgtZ3Jvdz4gPGZsZXgtc2hyaW5rPj8gfHwgPGZsZXgtYmFzaXM+IF1cbiAgICAgICAgICAgIC8vIFZhbGlkIHN5bnRheGVzLCBhY2NvcmRpbmcgdG8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL2ZsZXgjU3ludGF4XG4gICAgICAgICAgICAvLyAqIG5vbmVcbiAgICAgICAgICAgIC8vICogPGZsZXgtZ3Jvdz5cbiAgICAgICAgICAgIC8vICogPGZsZXgtYmFzaXM+XG4gICAgICAgICAgICAvLyAqIDxmbGV4LWdyb3c+IDxmbGV4LWJhc2lzPlxuICAgICAgICAgICAgLy8gKiA8ZmxleC1ncm93PiA8ZmxleC1zaHJpbms+XG4gICAgICAgICAgICAvLyAqIDxmbGV4LWdyb3c+IDxmbGV4LXNocmluaz4gPGZsZXgtYmFzaXM+XG4gICAgICAgICAgICAvLyAqIGluaGVyaXRcbiAgICAgICAgICAgIHZhciBwYXJ0LFxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKFZhbGlkYXRpb25UeXBlcy5pc0FueShleHByZXNzaW9uLCBcIm5vbmUgfCBpbmhlcml0XCIpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKFZhbGlkYXRpb25UeXBlcy5pc1R5cGUoZXhwcmVzc2lvbiwgXCI8ZmxleC1ncm93PlwiKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXhwcmVzc2lvbi5wZWVrKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChWYWxpZGF0aW9uVHlwZXMuaXNUeXBlKGV4cHJlc3Npb24sIFwiPGZsZXgtc2hyaW5rPlwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChleHByZXNzaW9uLnBlZWsoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBWYWxpZGF0aW9uVHlwZXMuaXNUeXBlKGV4cHJlc3Npb24sIFwiPGZsZXgtYmFzaXM+XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChWYWxpZGF0aW9uVHlwZXMuaXNUeXBlKGV4cHJlc3Npb24sIFwiPGZsZXgtYmFzaXM+XCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gZXhwcmVzc2lvbi5wZWVrKCkgPT09IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChWYWxpZGF0aW9uVHlwZXMuaXNUeXBlKGV4cHJlc3Npb24sIFwiPGZsZXgtYmFzaXM+XCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgICAgICAgIC8vIEdlbmVyYXRlIGEgbW9yZSB2ZXJib3NlIGVycm9yIHRoYW4gXCJFeHBlY3RlZCA8ZmxleD4uLi5cIlxuICAgICAgICAgICAgICAgIHBhcnQgPSBleHByZXNzaW9uLnBlZWsoKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKFwiRXhwZWN0ZWQgKG5vbmUgfCBbIDxmbGV4LWdyb3c+IDxmbGV4LXNocmluaz4/IHx8IDxmbGV4LWJhc2lzPiBdKSBidXQgZm91bmQgJ1wiICsgZXhwcmVzc2lvbi52YWx1ZS50ZXh0ICsgXCInLlwiLCBwYXJ0LmxpbmUsIHBhcnQuY29sKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbnBhcnNlcmxpYi5jc3MgPSB7XG5fX3Byb3RvX18gICAgICAgICAgIDpudWxsLFxuQ29sb3JzICAgICAgICAgICAgICA6Q29sb3JzLFxuQ29tYmluYXRvciAgICAgICAgICA6Q29tYmluYXRvcixcblBhcnNlciAgICAgICAgICAgICAgOlBhcnNlcixcblByb3BlcnR5TmFtZSAgICAgICAgOlByb3BlcnR5TmFtZSxcblByb3BlcnR5VmFsdWUgICAgICAgOlByb3BlcnR5VmFsdWUsXG5Qcm9wZXJ0eVZhbHVlUGFydCAgIDpQcm9wZXJ0eVZhbHVlUGFydCxcbk1lZGlhRmVhdHVyZSAgICAgICAgOk1lZGlhRmVhdHVyZSxcbk1lZGlhUXVlcnkgICAgICAgICAgOk1lZGlhUXVlcnksXG5TZWxlY3RvciAgICAgICAgICAgIDpTZWxlY3RvcixcblNlbGVjdG9yUGFydCAgICAgICAgOlNlbGVjdG9yUGFydCxcblNlbGVjdG9yU3ViUGFydCAgICAgOlNlbGVjdG9yU3ViUGFydCxcblNwZWNpZmljaXR5ICAgICAgICAgOlNwZWNpZmljaXR5LFxuVG9rZW5TdHJlYW0gICAgICAgICA6VG9rZW5TdHJlYW0sXG5Ub2tlbnMgICAgICAgICAgICAgIDpUb2tlbnMsXG5WYWxpZGF0aW9uRXJyb3IgICAgIDpWYWxpZGF0aW9uRXJyb3Jcbn07XG59KSgpO1xuXG4oZnVuY3Rpb24oKXtcbi8qIGpzaGludCBmb3JpbjpmYWxzZSAqL1xuZm9yKHZhciBwcm9wIGluIHBhcnNlcmxpYil7XG5leHBvcnRzW3Byb3BdID0gcGFyc2VybGliW3Byb3BdO1xufVxufSkoKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2RvbWluby9saWIvY3NzcGFyc2VyLmpzXG4vLyBtb2R1bGUgaWQgPSA4MlxuLy8gbW9kdWxlIGNodW5rcyA9IDQiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBVUkwgPSByZXF1aXJlKCcuL1VSTCcpO1xudmFyIFVSTFV0aWxzID0gcmVxdWlyZSgnLi9VUkxVdGlscycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IExvY2F0aW9uO1xuXG5mdW5jdGlvbiBMb2NhdGlvbih3aW5kb3csIGhyZWYpIHtcbiAgdGhpcy5fd2luZG93ID0gd2luZG93O1xuICB0aGlzLl9ocmVmID0gaHJlZjtcbn1cblxuTG9jYXRpb24ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShVUkxVdGlscy5wcm90b3R5cGUsIHtcbiAgY29uc3RydWN0b3I6IHsgdmFsdWU6IExvY2F0aW9uIH0sXG5cbiAgLy8gU3BlY2lhbCBiZWhhdmlvciB3aGVuIGhyZWYgaXMgc2V0XG4gIGhyZWY6IHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5faHJlZjsgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uKHYpIHsgdGhpcy5hc3NpZ24odik7IH1cbiAgfSxcblxuICBhc3NpZ246IHsgdmFsdWU6IGZ1bmN0aW9uKHVybCkge1xuICAgIC8vIFJlc29sdmUgdGhlIG5ldyB1cmwgYWdhaW5zdCB0aGUgY3VycmVudCBvbmVcbiAgICAvLyBYWFg6XG4gICAgLy8gVGhpcyBpcyBub3QgYWN0dWFsbHkgY29ycmVjdC4gSXQgc2hvdWxkIGJlIHJlc29sdmVkIGFnYWluc3RcbiAgICAvLyB0aGUgVVJMIG9mIHRoZSBkb2N1bWVudCBvZiB0aGUgc2NyaXB0LiBGb3Igbm93LCB0aG91Z2gsIEkgb25seVxuICAgIC8vIHN1cHBvcnQgYSBzaW5nbGUgd2luZG93IGFuZCB0aGVyZSBpcyBvbmx5IG9uZSBiYXNlIHVybC5cbiAgICAvLyBTbyB0aGlzIGlzIGdvb2QgZW5vdWdoIGZvciBub3cuXG4gICAgdmFyIGN1cnJlbnQgPSBuZXcgVVJMKHRoaXMuX2hyZWYpO1xuICAgIHZhciBuZXd1cmwgPSBjdXJyZW50LnJlc29sdmUodXJsKTtcblxuICAgIC8vIFNhdmUgdGhlIG5ldyB1cmxcbiAgICB0aGlzLl9ocmVmID0gbmV3dXJsO1xuXG4gICAgLy8gU3RhcnQgbG9hZGluZyB0aGUgbmV3IGRvY3VtZW50IVxuICAgIC8vIFhYWFxuICAgIC8vIFRoaXMgaXMganVzdCBzb21ldGhpbmcgaGFja2VkIHRvZ2V0aGVyLlxuICAgIC8vIFRoZSByZWFsIGFsZ29yaXRobSBpczogaHR0cDovL3d3dy53aGF0d2cub3JnL3NwZWNzL3dlYi1hcHBzL2N1cnJlbnQtd29yay9tdWx0aXBhZ2UvaGlzdG9yeS5odG1sI25hdmlnYXRlXG4gIH19LFxuXG4gIHJlcGxhY2U6IHsgdmFsdWU6IGZ1bmN0aW9uKHVybCkge1xuICAgIC8vIFhYWFxuICAgIC8vIFNpbmNlIHdlIGFyZW4ndCB0cmFja2luZyBoaXN0b3J5IHlldCwgcmVwbGFjZSBpcyB0aGUgc2FtZSBhcyBhc3NpZ25cbiAgICB0aGlzLmFzc2lnbih1cmwpO1xuICB9fSxcblxuICByZWxvYWQ6IHsgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgIC8vIFhYWDpcbiAgICAvLyBBY3R1YWxseSwgdGhlIHNwZWMgaXMgYSBsb3QgbW9yZSBjb21wbGljYXRlZCB0aGFuIHRoaXNcbiAgICB0aGlzLmFzc2lnbih0aGlzLmhyZWYpO1xuICB9fSxcblxuICB0b1N0cmluZzogeyB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuaHJlZjtcbiAgfX1cblxufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9kb21pbm8vbGliL0xvY2F0aW9uLmpzXG4vLyBtb2R1bGUgaWQgPSA4M1xuLy8gbW9kdWxlIGNodW5rcyA9IDQiLCJcInVzZSBzdHJpY3RcIjtcblxuLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvd2ViYXBwYXBpcy5odG1sI25hdmlnYXRvcmlkXG52YXIgTmF2aWdhdG9ySUQgPSBPYmplY3QuY3JlYXRlKG51bGwsIHtcbiAgYXBwQ29kZU5hbWU6IHsgdmFsdWU6IFwiTW96aWxsYVwiIH0sXG4gIGFwcE5hbWU6IHsgdmFsdWU6IFwiTmV0c2NhcGVcIiB9LFxuICBhcHBWZXJzaW9uOiB7IHZhbHVlOiBcIjQuMFwiIH0sXG4gIHBsYXRmb3JtOiB7IHZhbHVlOiBcIlwiIH0sXG4gIHByb2R1Y3Q6IHsgdmFsdWU6IFwiR2Vja29cIiB9LFxuICBwcm9kdWN0U3ViOiB7IHZhbHVlOiBcIjIwMTAwMTAxXCIgfSxcbiAgdXNlckFnZW50OiB7IHZhbHVlOiBcIlwiIH0sXG4gIHZlbmRvcjogeyB2YWx1ZTogXCJcIiB9LFxuICB2ZW5kb3JTdWI6IHsgdmFsdWU6IFwiXCIgfSxcbiAgdGFpbnRFbmFibGVkOiB7IHZhbHVlOiBmdW5jdGlvbigpIHsgcmV0dXJuIGZhbHNlOyB9IH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE5hdmlnYXRvcklEO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZG9taW5vL2xpYi9OYXZpZ2F0b3JJRC5qc1xuLy8gbW9kdWxlIGlkID0gODRcbi8vIG1vZHVsZSBjaHVua3MgPSA0IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3dlYmFwcGFwaXMuaHRtbCN3aW5kb3d0aW1lcnNcbnZhciBXaW5kb3dUaW1lcnMgPSB7XG4gIHNldFRpbWVvdXQ6IHNldFRpbWVvdXQsXG4gIGNsZWFyVGltZW91dDogY2xlYXJUaW1lb3V0LFxuICBzZXRJbnRlcnZhbDogc2V0SW50ZXJ2YWwsXG4gIGNsZWFySW50ZXJ2YWw6IGNsZWFySW50ZXJ2YWxcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gV2luZG93VGltZXJzO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZG9taW5vL2xpYi9XaW5kb3dUaW1lcnMuanNcbi8vIG1vZHVsZSBpZCA9IDg1XG4vLyBtb2R1bGUgY2h1bmtzID0gNCIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFZBTFVFOiAxLCAvLyBUaGUgdmFsdWUgb2YgYSBUZXh0LCBDb21tZW50IG9yIFBJIG5vZGUgY2hhbmdlZFxuICBBVFRSOiAyLCAvLyBBIG5ldyBhdHRyaWJ1dGUgd2FzIGFkZGVkIG9yIGFuIGF0dHJpYnV0ZSB2YWx1ZSBhbmQvb3IgcHJlZml4IGNoYW5nZWRcbiAgUkVNT1ZFX0FUVFI6IDMsIC8vIEFuIGF0dHJpYnV0ZSB3YXMgcmVtb3ZlZFxuICBSRU1PVkU6IDQsIC8vIEEgbm9kZSB3YXMgcmVtb3ZlZFxuICBNT1ZFOiA1LCAvLyBBIG5vZGUgd2FzIG1vdmVkXG4gIElOU0VSVDogNiAvLyBBIG5vZGUgKG9yIGEgc3VidHJlZSBvZiBub2Rlcykgd2FzIGluc2VydGVkXG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2RvbWluby9saWIvTXV0YXRpb25Db25zdGFudHMuanNcbi8vIG1vZHVsZSBpZCA9IDg2XG4vLyBtb2R1bGUgY2h1bmtzID0gNCIsIi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMS4xMi4yXG4oZnVuY3Rpb24oKSB7XG4gIHZhciBJbnZhbGlkU3RhdGVFcnJvciwgTmV0d29ya0Vycm9yLCBQcm9ncmVzc0V2ZW50LCBTZWN1cml0eUVycm9yLCBTeW50YXhFcnJvciwgWE1MSHR0cFJlcXVlc3QsIFhNTEh0dHBSZXF1ZXN0RXZlbnRUYXJnZXQsIFhNTEh0dHBSZXF1ZXN0VXBsb2FkLCBodHRwLCBodHRwcywgb3MsIHVybCxcbiAgICBleHRlbmQgPSBmdW5jdGlvbihjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHsgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTsgfSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sXG4gICAgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xuXG4gIFhNTEh0dHBSZXF1ZXN0RXZlbnRUYXJnZXQgPSAoZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gWE1MSHR0cFJlcXVlc3RFdmVudFRhcmdldCgpIHtcbiAgICAgIHRoaXMub25sb2Fkc3RhcnQgPSBudWxsO1xuICAgICAgdGhpcy5vbnByb2dyZXNzID0gbnVsbDtcbiAgICAgIHRoaXMub25hYm9ydCA9IG51bGw7XG4gICAgICB0aGlzLm9uZXJyb3IgPSBudWxsO1xuICAgICAgdGhpcy5vbmxvYWQgPSBudWxsO1xuICAgICAgdGhpcy5vbnRpbWVvdXQgPSBudWxsO1xuICAgICAgdGhpcy5vbmxvYWRlbmQgPSBudWxsO1xuICAgICAgdGhpcy5fbGlzdGVuZXJzID0ge307XG4gICAgfVxuXG4gICAgWE1MSHR0cFJlcXVlc3RFdmVudFRhcmdldC5wcm90b3R5cGUub25sb2Fkc3RhcnQgPSBudWxsO1xuXG4gICAgWE1MSHR0cFJlcXVlc3RFdmVudFRhcmdldC5wcm90b3R5cGUub25wcm9ncmVzcyA9IG51bGw7XG5cbiAgICBYTUxIdHRwUmVxdWVzdEV2ZW50VGFyZ2V0LnByb3RvdHlwZS5vbmFib3J0ID0gbnVsbDtcblxuICAgIFhNTEh0dHBSZXF1ZXN0RXZlbnRUYXJnZXQucHJvdG90eXBlLm9uZXJyb3IgPSBudWxsO1xuXG4gICAgWE1MSHR0cFJlcXVlc3RFdmVudFRhcmdldC5wcm90b3R5cGUub25sb2FkID0gbnVsbDtcblxuICAgIFhNTEh0dHBSZXF1ZXN0RXZlbnRUYXJnZXQucHJvdG90eXBlLm9udGltZW91dCA9IG51bGw7XG5cbiAgICBYTUxIdHRwUmVxdWVzdEV2ZW50VGFyZ2V0LnByb3RvdHlwZS5vbmxvYWRlbmQgPSBudWxsO1xuXG4gICAgWE1MSHR0cFJlcXVlc3RFdmVudFRhcmdldC5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKGV2ZW50VHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIHZhciBiYXNlO1xuICAgICAgZXZlbnRUeXBlID0gZXZlbnRUeXBlLnRvTG93ZXJDYXNlKCk7XG4gICAgICAoYmFzZSA9IHRoaXMuX2xpc3RlbmVycylbZXZlbnRUeXBlXSB8fCAoYmFzZVtldmVudFR5cGVdID0gW10pO1xuICAgICAgdGhpcy5fbGlzdGVuZXJzW2V2ZW50VHlwZV0ucHVzaChsaXN0ZW5lcik7XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH07XG5cbiAgICBYTUxIdHRwUmVxdWVzdEV2ZW50VGFyZ2V0LnByb3RvdHlwZS5yZW1vdmVFdmVudExpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnRUeXBlLCBsaXN0ZW5lcikge1xuICAgICAgdmFyIGluZGV4O1xuICAgICAgZXZlbnRUeXBlID0gZXZlbnRUeXBlLnRvTG93ZXJDYXNlKCk7XG4gICAgICBpZiAodGhpcy5fbGlzdGVuZXJzW2V2ZW50VHlwZV0pIHtcbiAgICAgICAgaW5kZXggPSB0aGlzLl9saXN0ZW5lcnNbZXZlbnRUeXBlXS5pbmRleE9mKGxpc3RlbmVyKTtcbiAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICAgIHRoaXMuX2xpc3RlbmVyc1tldmVudFR5cGVdLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfTtcblxuICAgIFhNTEh0dHBSZXF1ZXN0RXZlbnRUYXJnZXQucHJvdG90eXBlLmRpc3BhdGNoRXZlbnQgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgdmFyIGV2ZW50VHlwZSwgaiwgbGVuLCBsaXN0ZW5lciwgbGlzdGVuZXJzO1xuICAgICAgZXZlbnQuY3VycmVudFRhcmdldCA9IGV2ZW50LnRhcmdldCA9IHRoaXM7XG4gICAgICBldmVudFR5cGUgPSBldmVudC50eXBlO1xuICAgICAgaWYgKGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVyc1tldmVudFR5cGVdKSB7XG4gICAgICAgIGZvciAoaiA9IDAsIGxlbiA9IGxpc3RlbmVycy5sZW5ndGg7IGogPCBsZW47IGorKykge1xuICAgICAgICAgIGxpc3RlbmVyID0gbGlzdGVuZXJzW2pdO1xuICAgICAgICAgIGxpc3RlbmVyLmNhbGwodGhpcywgZXZlbnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobGlzdGVuZXIgPSB0aGlzW1wib25cIiArIGV2ZW50VHlwZV0pIHtcbiAgICAgICAgbGlzdGVuZXIuY2FsbCh0aGlzLCBldmVudCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH07XG5cbiAgICByZXR1cm4gWE1MSHR0cFJlcXVlc3RFdmVudFRhcmdldDtcblxuICB9KSgpO1xuXG4gIGh0dHAgPSByZXF1aXJlKCdodHRwJyk7XG5cbiAgaHR0cHMgPSByZXF1aXJlKCdodHRwcycpO1xuXG4gIG9zID0gcmVxdWlyZSgnb3MnKTtcblxuICB1cmwgPSByZXF1aXJlKCd1cmwnKTtcblxuICBYTUxIdHRwUmVxdWVzdCA9IChmdW5jdGlvbihzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKFhNTEh0dHBSZXF1ZXN0LCBzdXBlckNsYXNzKTtcblxuICAgIGZ1bmN0aW9uIFhNTEh0dHBSZXF1ZXN0KG9wdGlvbnMpIHtcbiAgICAgIFhNTEh0dHBSZXF1ZXN0Ll9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5jYWxsKHRoaXMpO1xuICAgICAgdGhpcy5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuICAgICAgdGhpcy5fYW5vbnltb3VzID0gb3B0aW9ucyAmJiBvcHRpb25zLmFub247XG4gICAgICB0aGlzLnJlYWR5U3RhdGUgPSBYTUxIdHRwUmVxdWVzdC5VTlNFTlQ7XG4gICAgICB0aGlzLnJlc3BvbnNlID0gbnVsbDtcbiAgICAgIHRoaXMucmVzcG9uc2VUZXh0ID0gJyc7XG4gICAgICB0aGlzLnJlc3BvbnNlVHlwZSA9ICcnO1xuICAgICAgdGhpcy5yZXNwb25zZVVSTCA9ICcnO1xuICAgICAgdGhpcy5zdGF0dXMgPSAwO1xuICAgICAgdGhpcy5zdGF0dXNUZXh0ID0gJyc7XG4gICAgICB0aGlzLnRpbWVvdXQgPSAwO1xuICAgICAgdGhpcy51cGxvYWQgPSBuZXcgWE1MSHR0cFJlcXVlc3RVcGxvYWQodGhpcyk7XG4gICAgICB0aGlzLl9tZXRob2QgPSBudWxsO1xuICAgICAgdGhpcy5fdXJsID0gbnVsbDtcbiAgICAgIHRoaXMuX3N5bmMgPSBmYWxzZTtcbiAgICAgIHRoaXMuX2hlYWRlcnMgPSBudWxsO1xuICAgICAgdGhpcy5fbG93ZXJlZEhlYWRlcnMgPSBudWxsO1xuICAgICAgdGhpcy5fbWltZU92ZXJyaWRlID0gbnVsbDtcbiAgICAgIHRoaXMuX3JlcXVlc3QgPSBudWxsO1xuICAgICAgdGhpcy5fcmVzcG9uc2UgPSBudWxsO1xuICAgICAgdGhpcy5fcmVzcG9uc2VQYXJ0cyA9IG51bGw7XG4gICAgICB0aGlzLl9yZXNwb25zZUhlYWRlcnMgPSBudWxsO1xuICAgICAgdGhpcy5fYWJvcnRpbmcgPSBudWxsO1xuICAgICAgdGhpcy5fZXJyb3IgPSBudWxsO1xuICAgICAgdGhpcy5fbG9hZGVkQnl0ZXMgPSAwO1xuICAgICAgdGhpcy5fdG90YWxCeXRlcyA9IDA7XG4gICAgICB0aGlzLl9sZW5ndGhDb21wdXRhYmxlID0gZmFsc2U7XG4gICAgfVxuXG4gICAgWE1MSHR0cFJlcXVlc3QucHJvdG90eXBlLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGw7XG5cbiAgICBYTUxIdHRwUmVxdWVzdC5wcm90b3R5cGUucmVhZHlTdGF0ZSA9IG51bGw7XG5cbiAgICBYTUxIdHRwUmVxdWVzdC5wcm90b3R5cGUucmVzcG9uc2UgPSBudWxsO1xuXG4gICAgWE1MSHR0cFJlcXVlc3QucHJvdG90eXBlLnJlc3BvbnNlVGV4dCA9IG51bGw7XG5cbiAgICBYTUxIdHRwUmVxdWVzdC5wcm90b3R5cGUucmVzcG9uc2VUeXBlID0gbnVsbDtcblxuICAgIFhNTEh0dHBSZXF1ZXN0LnByb3RvdHlwZS5zdGF0dXMgPSBudWxsO1xuXG4gICAgWE1MSHR0cFJlcXVlc3QucHJvdG90eXBlLnRpbWVvdXQgPSBudWxsO1xuXG4gICAgWE1MSHR0cFJlcXVlc3QucHJvdG90eXBlLnVwbG9hZCA9IG51bGw7XG5cbiAgICBYTUxIdHRwUmVxdWVzdC5wcm90b3R5cGUub3BlbiA9IGZ1bmN0aW9uKG1ldGhvZCwgdXJsLCBhc3luYywgdXNlciwgcGFzc3dvcmQpIHtcbiAgICAgIHZhciB4aHJVcmw7XG4gICAgICBtZXRob2QgPSBtZXRob2QudG9VcHBlckNhc2UoKTtcbiAgICAgIGlmIChtZXRob2QgaW4gdGhpcy5fcmVzdHJpY3RlZE1ldGhvZHMpIHtcbiAgICAgICAgdGhyb3cgbmV3IFNlY3VyaXR5RXJyb3IoXCJIVFRQIG1ldGhvZCBcIiArIG1ldGhvZCArIFwiIGlzIG5vdCBhbGxvd2VkIGluIFhIUlwiKTtcbiAgICAgIH1cbiAgICAgIHhoclVybCA9IHRoaXMuX3BhcnNlVXJsKHVybCk7XG4gICAgICBpZiAoYXN5bmMgPT09IHZvaWQgMCkge1xuICAgICAgICBhc3luYyA9IHRydWU7XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKHRoaXMucmVhZHlTdGF0ZSkge1xuICAgICAgICBjYXNlIFhNTEh0dHBSZXF1ZXN0LlVOU0VOVDpcbiAgICAgICAgY2FzZSBYTUxIdHRwUmVxdWVzdC5PUEVORUQ6XG4gICAgICAgIGNhc2UgWE1MSHR0cFJlcXVlc3QuRE9ORTpcbiAgICAgICAgICBudWxsO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFhNTEh0dHBSZXF1ZXN0LkhFQURFUlNfUkVDRUlWRUQ6XG4gICAgICAgIGNhc2UgWE1MSHR0cFJlcXVlc3QuTE9BRElORzpcbiAgICAgICAgICBudWxsO1xuICAgICAgfVxuICAgICAgdGhpcy5fbWV0aG9kID0gbWV0aG9kO1xuICAgICAgdGhpcy5fdXJsID0geGhyVXJsO1xuICAgICAgdGhpcy5fc3luYyA9ICFhc3luYztcbiAgICAgIHRoaXMuX2hlYWRlcnMgPSB7fTtcbiAgICAgIHRoaXMuX2xvd2VyZWRIZWFkZXJzID0ge307XG4gICAgICB0aGlzLl9taW1lT3ZlcnJpZGUgPSBudWxsO1xuICAgICAgdGhpcy5fc2V0UmVhZHlTdGF0ZShYTUxIdHRwUmVxdWVzdC5PUEVORUQpO1xuICAgICAgdGhpcy5fcmVxdWVzdCA9IG51bGw7XG4gICAgICB0aGlzLl9yZXNwb25zZSA9IG51bGw7XG4gICAgICB0aGlzLnN0YXR1cyA9IDA7XG4gICAgICB0aGlzLnN0YXR1c1RleHQgPSAnJztcbiAgICAgIHRoaXMuX3Jlc3BvbnNlUGFydHMgPSBbXTtcbiAgICAgIHRoaXMuX3Jlc3BvbnNlSGVhZGVycyA9IG51bGw7XG4gICAgICB0aGlzLl9sb2FkZWRCeXRlcyA9IDA7XG4gICAgICB0aGlzLl90b3RhbEJ5dGVzID0gMDtcbiAgICAgIHRoaXMuX2xlbmd0aENvbXB1dGFibGUgPSBmYWxzZTtcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfTtcblxuICAgIFhNTEh0dHBSZXF1ZXN0LnByb3RvdHlwZS5zZXRSZXF1ZXN0SGVhZGVyID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICAgIHZhciBsb3dlcmVkTmFtZTtcbiAgICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgIT09IFhNTEh0dHBSZXF1ZXN0Lk9QRU5FRCkge1xuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFN0YXRlRXJyb3IoXCJYSFIgcmVhZHlTdGF0ZSBtdXN0IGJlIE9QRU5FRFwiKTtcbiAgICAgIH1cbiAgICAgIGxvd2VyZWROYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgaWYgKHRoaXMuX3Jlc3RyaWN0ZWRIZWFkZXJzW2xvd2VyZWROYW1lXSB8fCAvXnNlY1xcLS8udGVzdChsb3dlcmVkTmFtZSkgfHwgL15wcm94eS0vLnRlc3QobG93ZXJlZE5hbWUpKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIlJlZnVzZWQgdG8gc2V0IHVuc2FmZSBoZWFkZXIgXFxcIlwiICsgbmFtZSArIFwiXFxcIlwiKTtcbiAgICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICAgIH1cbiAgICAgIHZhbHVlID0gdmFsdWUudG9TdHJpbmcoKTtcbiAgICAgIGlmIChsb3dlcmVkTmFtZSBpbiB0aGlzLl9sb3dlcmVkSGVhZGVycykge1xuICAgICAgICBuYW1lID0gdGhpcy5fbG93ZXJlZEhlYWRlcnNbbG93ZXJlZE5hbWVdO1xuICAgICAgICB0aGlzLl9oZWFkZXJzW25hbWVdID0gdGhpcy5faGVhZGVyc1tuYW1lXSArICcsICcgKyB2YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2xvd2VyZWRIZWFkZXJzW2xvd2VyZWROYW1lXSA9IG5hbWU7XG4gICAgICAgIHRoaXMuX2hlYWRlcnNbbmFtZV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfTtcblxuICAgIFhNTEh0dHBSZXF1ZXN0LnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24oZGF0YSkge1xuICAgICAgaWYgKHRoaXMucmVhZHlTdGF0ZSAhPT0gWE1MSHR0cFJlcXVlc3QuT1BFTkVEKSB7XG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkU3RhdGVFcnJvcihcIlhIUiByZWFkeVN0YXRlIG11c3QgYmUgT1BFTkVEXCIpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX3JlcXVlc3QpIHtcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRTdGF0ZUVycm9yKFwic2VuZCgpIGFscmVhZHkgY2FsbGVkXCIpO1xuICAgICAgfVxuICAgICAgc3dpdGNoICh0aGlzLl91cmwucHJvdG9jb2wpIHtcbiAgICAgICAgY2FzZSAnZmlsZTonOlxuICAgICAgICAgIHRoaXMuX3NlbmRGaWxlKGRhdGEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdodHRwOic6XG4gICAgICAgIGNhc2UgJ2h0dHBzOic6XG4gICAgICAgICAgdGhpcy5fc2VuZEh0dHAoZGF0YSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IE5ldHdvcmtFcnJvcihcIlVuc3VwcG9ydGVkIHByb3RvY29sIFwiICsgdGhpcy5fdXJsLnByb3RvY29sKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfTtcblxuICAgIFhNTEh0dHBSZXF1ZXN0LnByb3RvdHlwZS5hYm9ydCA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCF0aGlzLl9yZXF1ZXN0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3JlcXVlc3QuYWJvcnQoKTtcbiAgICAgIHRoaXMuX3NldEVycm9yKCk7XG4gICAgICB0aGlzLl9kaXNwYXRjaFByb2dyZXNzKCdhYm9ydCcpO1xuICAgICAgdGhpcy5fZGlzcGF0Y2hQcm9ncmVzcygnbG9hZGVuZCcpO1xuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9O1xuXG4gICAgWE1MSHR0cFJlcXVlc3QucHJvdG90eXBlLmdldFJlc3BvbnNlSGVhZGVyID0gZnVuY3Rpb24obmFtZSkge1xuICAgICAgdmFyIGxvd2VyZWROYW1lO1xuICAgICAgaWYgKCF0aGlzLl9yZXNwb25zZUhlYWRlcnMpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBsb3dlcmVkTmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgIGlmIChsb3dlcmVkTmFtZSBpbiB0aGlzLl9yZXNwb25zZUhlYWRlcnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Jlc3BvbnNlSGVhZGVyc1tsb3dlcmVkTmFtZV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgWE1MSHR0cFJlcXVlc3QucHJvdG90eXBlLmdldEFsbFJlc3BvbnNlSGVhZGVycyA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGxpbmVzLCBuYW1lLCB2YWx1ZTtcbiAgICAgIGlmICghdGhpcy5fcmVzcG9uc2VIZWFkZXJzKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICAgIH1cbiAgICAgIGxpbmVzID0gKGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcmVmLCByZXN1bHRzO1xuICAgICAgICByZWYgPSB0aGlzLl9yZXNwb25zZUhlYWRlcnM7XG4gICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgZm9yIChuYW1lIGluIHJlZikge1xuICAgICAgICAgIHZhbHVlID0gcmVmW25hbWVdO1xuICAgICAgICAgIHJlc3VsdHMucHVzaChuYW1lICsgXCI6IFwiICsgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgfSkuY2FsbCh0aGlzKTtcbiAgICAgIHJldHVybiBsaW5lcy5qb2luKFwiXFxyXFxuXCIpO1xuICAgIH07XG5cbiAgICBYTUxIdHRwUmVxdWVzdC5wcm90b3R5cGUub3ZlcnJpZGVNaW1lVHlwZSA9IGZ1bmN0aW9uKG5ld01pbWVUeXBlKSB7XG4gICAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSBYTUxIdHRwUmVxdWVzdC5MT0FESU5HIHx8IHRoaXMucmVhZHlTdGF0ZSA9PT0gWE1MSHR0cFJlcXVlc3QuRE9ORSkge1xuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFN0YXRlRXJyb3IoXCJvdmVycmlkZU1pbWVUeXBlKCkgbm90IGFsbG93ZWQgaW4gTE9BRElORyBvciBET05FXCIpO1xuICAgICAgfVxuICAgICAgdGhpcy5fbWltZU92ZXJyaWRlID0gbmV3TWltZVR5cGUudG9Mb3dlckNhc2UoKTtcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfTtcblxuICAgIFhNTEh0dHBSZXF1ZXN0LnByb3RvdHlwZS5ub2RlanNTZXQgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICB2YXIgYmFzZVVybCwgcGFyc2VkVXJsO1xuICAgICAgaWYgKCdodHRwQWdlbnQnIGluIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5ub2RlanNIdHRwQWdlbnQgPSBvcHRpb25zLmh0dHBBZ2VudDtcbiAgICAgIH1cbiAgICAgIGlmICgnaHR0cHNBZ2VudCcgaW4gb3B0aW9ucykge1xuICAgICAgICB0aGlzLm5vZGVqc0h0dHBzQWdlbnQgPSBvcHRpb25zLmh0dHBzQWdlbnQ7XG4gICAgICB9XG4gICAgICBpZiAoJ2Jhc2VVcmwnIGluIG9wdGlvbnMpIHtcbiAgICAgICAgYmFzZVVybCA9IG9wdGlvbnMuYmFzZVVybDtcbiAgICAgICAgaWYgKGJhc2VVcmwgIT09IG51bGwpIHtcbiAgICAgICAgICBwYXJzZWRVcmwgPSB1cmwucGFyc2UoYmFzZVVybCwgZmFsc2UsIHRydWUpO1xuICAgICAgICAgIGlmICghcGFyc2VkVXJsLnByb3RvY29sKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXCJiYXNlVXJsIG11c3QgYmUgYW4gYWJzb2x1dGUgVVJMXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLm5vZGVqc0Jhc2VVcmwgPSBiYXNlVXJsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9O1xuXG4gICAgWE1MSHR0cFJlcXVlc3Qubm9kZWpzU2V0ID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgWE1MSHR0cFJlcXVlc3QucHJvdG90eXBlLm5vZGVqc1NldChvcHRpb25zKTtcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfTtcblxuICAgIFhNTEh0dHBSZXF1ZXN0LnByb3RvdHlwZS5VTlNFTlQgPSAwO1xuXG4gICAgWE1MSHR0cFJlcXVlc3QuVU5TRU5UID0gMDtcblxuICAgIFhNTEh0dHBSZXF1ZXN0LnByb3RvdHlwZS5PUEVORUQgPSAxO1xuXG4gICAgWE1MSHR0cFJlcXVlc3QuT1BFTkVEID0gMTtcblxuICAgIFhNTEh0dHBSZXF1ZXN0LnByb3RvdHlwZS5IRUFERVJTX1JFQ0VJVkVEID0gMjtcblxuICAgIFhNTEh0dHBSZXF1ZXN0LkhFQURFUlNfUkVDRUlWRUQgPSAyO1xuXG4gICAgWE1MSHR0cFJlcXVlc3QucHJvdG90eXBlLkxPQURJTkcgPSAzO1xuXG4gICAgWE1MSHR0cFJlcXVlc3QuTE9BRElORyA9IDM7XG5cbiAgICBYTUxIdHRwUmVxdWVzdC5wcm90b3R5cGUuRE9ORSA9IDQ7XG5cbiAgICBYTUxIdHRwUmVxdWVzdC5ET05FID0gNDtcblxuICAgIFhNTEh0dHBSZXF1ZXN0LnByb3RvdHlwZS5ub2RlanNIdHRwQWdlbnQgPSBodHRwLmdsb2JhbEFnZW50O1xuXG4gICAgWE1MSHR0cFJlcXVlc3QucHJvdG90eXBlLm5vZGVqc0h0dHBzQWdlbnQgPSBodHRwcy5nbG9iYWxBZ2VudDtcblxuICAgIFhNTEh0dHBSZXF1ZXN0LnByb3RvdHlwZS5ub2RlanNCYXNlVXJsID0gbnVsbDtcblxuICAgIFhNTEh0dHBSZXF1ZXN0LnByb3RvdHlwZS5fcmVzdHJpY3RlZE1ldGhvZHMgPSB7XG4gICAgICBDT05ORUNUOiB0cnVlLFxuICAgICAgVFJBQ0U6IHRydWUsXG4gICAgICBUUkFDSzogdHJ1ZVxuICAgIH07XG5cbiAgICBYTUxIdHRwUmVxdWVzdC5wcm90b3R5cGUuX3Jlc3RyaWN0ZWRIZWFkZXJzID0ge1xuICAgICAgJ2FjY2VwdC1jaGFyc2V0JzogdHJ1ZSxcbiAgICAgICdhY2NlcHQtZW5jb2RpbmcnOiB0cnVlLFxuICAgICAgJ2FjY2Vzcy1jb250cm9sLXJlcXVlc3QtaGVhZGVycyc6IHRydWUsXG4gICAgICAnYWNjZXNzLWNvbnRyb2wtcmVxdWVzdC1tZXRob2QnOiB0cnVlLFxuICAgICAgY29ubmVjdGlvbjogdHJ1ZSxcbiAgICAgICdjb250ZW50LWxlbmd0aCc6IHRydWUsXG4gICAgICBjb29raWU6IHRydWUsXG4gICAgICBjb29raWUyOiB0cnVlLFxuICAgICAgZGF0ZTogdHJ1ZSxcbiAgICAgIGRudDogdHJ1ZSxcbiAgICAgIGV4cGVjdDogdHJ1ZSxcbiAgICAgIGhvc3Q6IHRydWUsXG4gICAgICAna2VlcC1hbGl2ZSc6IHRydWUsXG4gICAgICBvcmlnaW46IHRydWUsXG4gICAgICByZWZlcmVyOiB0cnVlLFxuICAgICAgdGU6IHRydWUsXG4gICAgICB0cmFpbGVyOiB0cnVlLFxuICAgICAgJ3RyYW5zZmVyLWVuY29kaW5nJzogdHJ1ZSxcbiAgICAgIHVwZ3JhZGU6IHRydWUsXG4gICAgICAndXNlci1hZ2VudCc6IHRydWUsXG4gICAgICB2aWE6IHRydWVcbiAgICB9O1xuXG4gICAgWE1MSHR0cFJlcXVlc3QucHJvdG90eXBlLl9wcml2YXRlSGVhZGVycyA9IHtcbiAgICAgICdzZXQtY29va2llJzogdHJ1ZSxcbiAgICAgICdzZXQtY29va2llMic6IHRydWVcbiAgICB9O1xuXG4gICAgWE1MSHR0cFJlcXVlc3QucHJvdG90eXBlLl91c2VyQWdlbnQgPSAoXCJNb3ppbGxhLzUuMCAoXCIgKyAob3MudHlwZSgpKSArIFwiIFwiICsgKG9zLmFyY2goKSkgKyBcIikgXCIpICsgKFwibm9kZS5qcy9cIiArIHByb2Nlc3MudmVyc2lvbnMubm9kZSArIFwiIHY4L1wiICsgcHJvY2Vzcy52ZXJzaW9ucy52OCk7XG5cbiAgICBYTUxIdHRwUmVxdWVzdC5wcm90b3R5cGUuX3NldFJlYWR5U3RhdGUgPSBmdW5jdGlvbihuZXdSZWFkeVN0YXRlKSB7XG4gICAgICB2YXIgZXZlbnQ7XG4gICAgICB0aGlzLnJlYWR5U3RhdGUgPSBuZXdSZWFkeVN0YXRlO1xuICAgICAgZXZlbnQgPSBuZXcgUHJvZ3Jlc3NFdmVudCgncmVhZHlzdGF0ZWNoYW5nZScpO1xuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfTtcblxuICAgIFhNTEh0dHBSZXF1ZXN0LnByb3RvdHlwZS5fc2VuZEZpbGUgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLl91cmwubWV0aG9kICE9PSAnR0VUJykge1xuICAgICAgICB0aHJvdyBuZXcgTmV0d29ya0Vycm9yKCdUaGUgZmlsZSBwcm90b2NvbCBvbmx5IHN1cHBvcnRzIEdFVCcpO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUHJvdG9jb2wgZmlsZTogbm90IGltcGxlbWVudGVkXCIpO1xuICAgIH07XG5cbiAgICBYTUxIdHRwUmVxdWVzdC5wcm90b3R5cGUuX3NlbmRIdHRwID0gZnVuY3Rpb24oZGF0YSkge1xuICAgICAgaWYgKHRoaXMuX3N5bmMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU3luY2hyb25vdXMgWEhSIHByb2Nlc3Npbmcgbm90IGltcGxlbWVudGVkXCIpO1xuICAgICAgfVxuICAgICAgaWYgKChkYXRhICE9IG51bGwpICYmICh0aGlzLl9tZXRob2QgPT09ICdHRVQnIHx8IHRoaXMuX21ldGhvZCA9PT0gJ0hFQUQnKSkge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJEaXNjYXJkaW5nIGVudGl0eSBib2R5IGZvciBcIiArIHRoaXMuX21ldGhvZCArIFwiIHJlcXVlc3RzXCIpO1xuICAgICAgICBkYXRhID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRhdGEgfHwgKGRhdGEgPSAnJyk7XG4gICAgICB9XG4gICAgICB0aGlzLnVwbG9hZC5fc2V0RGF0YShkYXRhKTtcbiAgICAgIHRoaXMuX2ZpbmFsaXplSGVhZGVycygpO1xuICAgICAgdGhpcy5fc2VuZEh4eHBSZXF1ZXN0KCk7XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH07XG5cbiAgICBYTUxIdHRwUmVxdWVzdC5wcm90b3R5cGUuX3NlbmRIeHhwUmVxdWVzdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGFnZW50LCBoeHhwLCByZXF1ZXN0O1xuICAgICAgaWYgKHRoaXMuX3VybC5wcm90b2NvbCA9PT0gJ2h0dHA6Jykge1xuICAgICAgICBoeHhwID0gaHR0cDtcbiAgICAgICAgYWdlbnQgPSB0aGlzLm5vZGVqc0h0dHBBZ2VudDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGh4eHAgPSBodHRwcztcbiAgICAgICAgYWdlbnQgPSB0aGlzLm5vZGVqc0h0dHBzQWdlbnQ7XG4gICAgICB9XG4gICAgICByZXF1ZXN0ID0gaHh4cC5yZXF1ZXN0KHtcbiAgICAgICAgaG9zdG5hbWU6IHRoaXMuX3VybC5ob3N0bmFtZSxcbiAgICAgICAgcG9ydDogdGhpcy5fdXJsLnBvcnQsXG4gICAgICAgIHBhdGg6IHRoaXMuX3VybC5wYXRoLFxuICAgICAgICBhdXRoOiB0aGlzLl91cmwuYXV0aCxcbiAgICAgICAgbWV0aG9kOiB0aGlzLl9tZXRob2QsXG4gICAgICAgIGhlYWRlcnM6IHRoaXMuX2hlYWRlcnMsXG4gICAgICAgIGFnZW50OiBhZ2VudFxuICAgICAgfSk7XG4gICAgICB0aGlzLl9yZXF1ZXN0ID0gcmVxdWVzdDtcbiAgICAgIGlmICh0aGlzLnRpbWVvdXQpIHtcbiAgICAgICAgcmVxdWVzdC5zZXRUaW1lb3V0KHRoaXMudGltZW91dCwgKGZ1bmN0aW9uKF90aGlzKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9vbkh0dHBUaW1lb3V0KHJlcXVlc3QpO1xuICAgICAgICAgIH07XG4gICAgICAgIH0pKHRoaXMpKTtcbiAgICAgIH1cbiAgICAgIHJlcXVlc3Qub24oJ3Jlc3BvbnNlJywgKGZ1bmN0aW9uKF90aGlzKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICAgIHJldHVybiBfdGhpcy5fb25IdHRwUmVzcG9uc2UocmVxdWVzdCwgcmVzcG9uc2UpO1xuICAgICAgICB9O1xuICAgICAgfSkodGhpcykpO1xuICAgICAgcmVxdWVzdC5vbignZXJyb3InLCAoZnVuY3Rpb24oX3RoaXMpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzLl9vbkh0dHBSZXF1ZXN0RXJyb3IocmVxdWVzdCwgZXJyb3IpO1xuICAgICAgICB9O1xuICAgICAgfSkodGhpcykpO1xuICAgICAgdGhpcy51cGxvYWQuX3N0YXJ0VXBsb2FkKHJlcXVlc3QpO1xuICAgICAgaWYgKHRoaXMuX3JlcXVlc3QgPT09IHJlcXVlc3QpIHtcbiAgICAgICAgdGhpcy5fZGlzcGF0Y2hQcm9ncmVzcygnbG9hZHN0YXJ0Jyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH07XG5cbiAgICBYTUxIdHRwUmVxdWVzdC5wcm90b3R5cGUuX2ZpbmFsaXplSGVhZGVycyA9IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5faGVhZGVyc1snQ29ubmVjdGlvbiddID0gJ2tlZXAtYWxpdmUnO1xuICAgICAgdGhpcy5faGVhZGVyc1snSG9zdCddID0gdGhpcy5fdXJsLmhvc3Q7XG4gICAgICBpZiAodGhpcy5fYW5vbnltb3VzKSB7XG4gICAgICAgIHRoaXMuX2hlYWRlcnNbJ1JlZmVyZXInXSA9ICdhYm91dDpibGFuayc7XG4gICAgICB9XG4gICAgICB0aGlzLl9oZWFkZXJzWydVc2VyLUFnZW50J10gPSB0aGlzLl91c2VyQWdlbnQ7XG4gICAgICB0aGlzLnVwbG9hZC5fZmluYWxpemVIZWFkZXJzKHRoaXMuX2hlYWRlcnMsIHRoaXMuX2xvd2VyZWRIZWFkZXJzKTtcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfTtcblxuICAgIFhNTEh0dHBSZXF1ZXN0LnByb3RvdHlwZS5fb25IdHRwUmVzcG9uc2UgPSBmdW5jdGlvbihyZXF1ZXN0LCByZXNwb25zZSkge1xuICAgICAgdmFyIGxlbmd0aFN0cmluZztcbiAgICAgIGlmICh0aGlzLl9yZXF1ZXN0ICE9PSByZXF1ZXN0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAocmVzcG9uc2Uuc3RhdHVzQ29kZSkge1xuICAgICAgICBjYXNlIDMwMTpcbiAgICAgICAgY2FzZSAzMDI6XG4gICAgICAgIGNhc2UgMzAzOlxuICAgICAgICBjYXNlIDMwNzpcbiAgICAgICAgY2FzZSAzMDg6XG4gICAgICAgICAgdGhpcy5fdXJsID0gdGhpcy5fcGFyc2VVcmwocmVzcG9uc2UuaGVhZGVyc1snbG9jYXRpb24nXSk7XG4gICAgICAgICAgdGhpcy5fbWV0aG9kID0gJ0dFVCc7XG4gICAgICAgICAgaWYgKCdjb250ZW50LXR5cGUnIGluIHRoaXMuX2xvd2VyZWRIZWFkZXJzKSB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5faGVhZGVyc1t0aGlzLl9sb3dlcmVkSGVhZGVyc1snY29udGVudC10eXBlJ11dO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2xvd2VyZWRIZWFkZXJzWydjb250ZW50LXR5cGUnXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCdDb250ZW50LVR5cGUnIGluIHRoaXMuX2hlYWRlcnMpIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9oZWFkZXJzWydDb250ZW50LVR5cGUnXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZGVsZXRlIHRoaXMuX2hlYWRlcnNbJ0NvbnRlbnQtTGVuZ3RoJ107XG4gICAgICAgICAgdGhpcy51cGxvYWQuX3Jlc2V0KCk7XG4gICAgICAgICAgdGhpcy5fZmluYWxpemVIZWFkZXJzKCk7XG4gICAgICAgICAgdGhpcy5fc2VuZEh4eHBSZXF1ZXN0KCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5fcmVzcG9uc2UgPSByZXNwb25zZTtcbiAgICAgIHRoaXMuX3Jlc3BvbnNlLm9uKCdkYXRhJywgKGZ1bmN0aW9uKF90aGlzKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzLl9vbkh0dHBSZXNwb25zZURhdGEocmVzcG9uc2UsIGRhdGEpO1xuICAgICAgICB9O1xuICAgICAgfSkodGhpcykpO1xuICAgICAgdGhpcy5fcmVzcG9uc2Uub24oJ2VuZCcsIChmdW5jdGlvbihfdGhpcykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzLl9vbkh0dHBSZXNwb25zZUVuZChyZXNwb25zZSk7XG4gICAgICAgIH07XG4gICAgICB9KSh0aGlzKSk7XG4gICAgICB0aGlzLl9yZXNwb25zZS5vbignY2xvc2UnLCAoZnVuY3Rpb24oX3RoaXMpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBfdGhpcy5fb25IdHRwUmVzcG9uc2VDbG9zZShyZXNwb25zZSk7XG4gICAgICAgIH07XG4gICAgICB9KSh0aGlzKSk7XG4gICAgICB0aGlzLnJlc3BvbnNlVVJMID0gdGhpcy5fdXJsLmhyZWYuc3BsaXQoJyMnKVswXTtcbiAgICAgIHRoaXMuc3RhdHVzID0gdGhpcy5fcmVzcG9uc2Uuc3RhdHVzQ29kZTtcbiAgICAgIHRoaXMuc3RhdHVzVGV4dCA9IGh0dHAuU1RBVFVTX0NPREVTW3RoaXMuc3RhdHVzXTtcbiAgICAgIHRoaXMuX3BhcnNlUmVzcG9uc2VIZWFkZXJzKHJlc3BvbnNlKTtcbiAgICAgIGlmIChsZW5ndGhTdHJpbmcgPSB0aGlzLl9yZXNwb25zZUhlYWRlcnNbJ2NvbnRlbnQtbGVuZ3RoJ10pIHtcbiAgICAgICAgdGhpcy5fdG90YWxCeXRlcyA9IHBhcnNlSW50KGxlbmd0aFN0cmluZyk7XG4gICAgICAgIHRoaXMuX2xlbmd0aENvbXB1dGFibGUgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fbGVuZ3RoQ29tcHV0YWJsZSA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuX3NldFJlYWR5U3RhdGUoWE1MSHR0cFJlcXVlc3QuSEVBREVSU19SRUNFSVZFRCk7XG4gICAgfTtcblxuICAgIFhNTEh0dHBSZXF1ZXN0LnByb3RvdHlwZS5fb25IdHRwUmVzcG9uc2VEYXRhID0gZnVuY3Rpb24ocmVzcG9uc2UsIGRhdGEpIHtcbiAgICAgIGlmICh0aGlzLl9yZXNwb25zZSAhPT0gcmVzcG9uc2UpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5fcmVzcG9uc2VQYXJ0cy5wdXNoKGRhdGEpO1xuICAgICAgdGhpcy5fbG9hZGVkQnl0ZXMgKz0gZGF0YS5sZW5ndGg7XG4gICAgICBpZiAodGhpcy5yZWFkeVN0YXRlICE9PSBYTUxIdHRwUmVxdWVzdC5MT0FESU5HKSB7XG4gICAgICAgIHRoaXMuX3NldFJlYWR5U3RhdGUoWE1MSHR0cFJlcXVlc3QuTE9BRElORyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5fZGlzcGF0Y2hQcm9ncmVzcygncHJvZ3Jlc3MnKTtcbiAgICB9O1xuXG4gICAgWE1MSHR0cFJlcXVlc3QucHJvdG90eXBlLl9vbkh0dHBSZXNwb25zZUVuZCA9IGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICBpZiAodGhpcy5fcmVzcG9uc2UgIT09IHJlc3BvbnNlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3BhcnNlUmVzcG9uc2UoKTtcbiAgICAgIHRoaXMuX3JlcXVlc3QgPSBudWxsO1xuICAgICAgdGhpcy5fcmVzcG9uc2UgPSBudWxsO1xuICAgICAgdGhpcy5fc2V0UmVhZHlTdGF0ZShYTUxIdHRwUmVxdWVzdC5ET05FKTtcbiAgICAgIHRoaXMuX2Rpc3BhdGNoUHJvZ3Jlc3MoJ2xvYWQnKTtcbiAgICAgIHJldHVybiB0aGlzLl9kaXNwYXRjaFByb2dyZXNzKCdsb2FkZW5kJyk7XG4gICAgfTtcblxuICAgIFhNTEh0dHBSZXF1ZXN0LnByb3RvdHlwZS5fb25IdHRwUmVzcG9uc2VDbG9zZSA9IGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICB2YXIgcmVxdWVzdDtcbiAgICAgIGlmICh0aGlzLl9yZXNwb25zZSAhPT0gcmVzcG9uc2UpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcmVxdWVzdCA9IHRoaXMuX3JlcXVlc3Q7XG4gICAgICB0aGlzLl9zZXRFcnJvcigpO1xuICAgICAgcmVxdWVzdC5hYm9ydCgpO1xuICAgICAgdGhpcy5fc2V0UmVhZHlTdGF0ZShYTUxIdHRwUmVxdWVzdC5ET05FKTtcbiAgICAgIHRoaXMuX2Rpc3BhdGNoUHJvZ3Jlc3MoJ2Vycm9yJyk7XG4gICAgICByZXR1cm4gdGhpcy5fZGlzcGF0Y2hQcm9ncmVzcygnbG9hZGVuZCcpO1xuICAgIH07XG5cbiAgICBYTUxIdHRwUmVxdWVzdC5wcm90b3R5cGUuX29uSHR0cFRpbWVvdXQgPSBmdW5jdGlvbihyZXF1ZXN0KSB7XG4gICAgICBpZiAodGhpcy5fcmVxdWVzdCAhPT0gcmVxdWVzdCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLl9zZXRFcnJvcigpO1xuICAgICAgcmVxdWVzdC5hYm9ydCgpO1xuICAgICAgdGhpcy5fc2V0UmVhZHlTdGF0ZShYTUxIdHRwUmVxdWVzdC5ET05FKTtcbiAgICAgIHRoaXMuX2Rpc3BhdGNoUHJvZ3Jlc3MoJ3RpbWVvdXQnKTtcbiAgICAgIHJldHVybiB0aGlzLl9kaXNwYXRjaFByb2dyZXNzKCdsb2FkZW5kJyk7XG4gICAgfTtcblxuICAgIFhNTEh0dHBSZXF1ZXN0LnByb3RvdHlwZS5fb25IdHRwUmVxdWVzdEVycm9yID0gZnVuY3Rpb24ocmVxdWVzdCwgZXJyb3IpIHtcbiAgICAgIGlmICh0aGlzLl9yZXF1ZXN0ICE9PSByZXF1ZXN0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3NldEVycm9yKCk7XG4gICAgICByZXF1ZXN0LmFib3J0KCk7XG4gICAgICB0aGlzLl9zZXRSZWFkeVN0YXRlKFhNTEh0dHBSZXF1ZXN0LkRPTkUpO1xuICAgICAgdGhpcy5fZGlzcGF0Y2hQcm9ncmVzcygnZXJyb3InKTtcbiAgICAgIHJldHVybiB0aGlzLl9kaXNwYXRjaFByb2dyZXNzKCdsb2FkZW5kJyk7XG4gICAgfTtcblxuICAgIFhNTEh0dHBSZXF1ZXN0LnByb3RvdHlwZS5fZGlzcGF0Y2hQcm9ncmVzcyA9IGZ1bmN0aW9uKGV2ZW50VHlwZSkge1xuICAgICAgdmFyIGV2ZW50O1xuICAgICAgZXZlbnQgPSBuZXcgUHJvZ3Jlc3NFdmVudChldmVudFR5cGUpO1xuICAgICAgZXZlbnQubGVuZ3RoQ29tcHV0YWJsZSA9IHRoaXMuX2xlbmd0aENvbXB1dGFibGU7XG4gICAgICBldmVudC5sb2FkZWQgPSB0aGlzLl9sb2FkZWRCeXRlcztcbiAgICAgIGV2ZW50LnRvdGFsID0gdGhpcy5fdG90YWxCeXRlcztcbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH07XG5cbiAgICBYTUxIdHRwUmVxdWVzdC5wcm90b3R5cGUuX3NldEVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLl9yZXF1ZXN0ID0gbnVsbDtcbiAgICAgIHRoaXMuX3Jlc3BvbnNlID0gbnVsbDtcbiAgICAgIHRoaXMuX3Jlc3BvbnNlSGVhZGVycyA9IG51bGw7XG4gICAgICB0aGlzLl9yZXNwb25zZVBhcnRzID0gbnVsbDtcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfTtcblxuICAgIFhNTEh0dHBSZXF1ZXN0LnByb3RvdHlwZS5fcGFyc2VVcmwgPSBmdW5jdGlvbih1cmxTdHJpbmcpIHtcbiAgICAgIHZhciBhYnNvbHV0ZVVybFN0cmluZywgaW5kZXgsIHBhc3N3b3JkLCB1c2VyLCB4aHJVcmw7XG4gICAgICBpZiAodGhpcy5ub2RlanNCYXNlVXJsID09PSBudWxsKSB7XG4gICAgICAgIGFic29sdXRlVXJsU3RyaW5nID0gdXJsU3RyaW5nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWJzb2x1dGVVcmxTdHJpbmcgPSB1cmwucmVzb2x2ZSh0aGlzLm5vZGVqc0Jhc2VVcmwsIHVybFN0cmluZyk7XG4gICAgICB9XG4gICAgICB4aHJVcmwgPSB1cmwucGFyc2UoYWJzb2x1dGVVcmxTdHJpbmcsIGZhbHNlLCB0cnVlKTtcbiAgICAgIHhoclVybC5oYXNoID0gbnVsbDtcbiAgICAgIGlmICh4aHJVcmwuYXV0aCAmJiAoKHR5cGVvZiB1c2VyICE9PSBcInVuZGVmaW5lZFwiICYmIHVzZXIgIT09IG51bGwpIHx8ICh0eXBlb2YgcGFzc3dvcmQgIT09IFwidW5kZWZpbmVkXCIgJiYgcGFzc3dvcmQgIT09IG51bGwpKSkge1xuICAgICAgICBpbmRleCA9IHhoclVybC5hdXRoLmluZGV4T2YoJzonKTtcbiAgICAgICAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgICAgICAgIGlmICghdXNlcikge1xuICAgICAgICAgICAgdXNlciA9IHhoclVybC5hdXRoO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoIXVzZXIpIHtcbiAgICAgICAgICAgIHVzZXIgPSB4aHJVcmwuc3Vic3RyaW5nKDAsIGluZGV4KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFwYXNzd29yZCkge1xuICAgICAgICAgICAgcGFzc3dvcmQgPSB4aHJVcmwuc3Vic3RyaW5nKGluZGV4ICsgMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodXNlciB8fCBwYXNzd29yZCkge1xuICAgICAgICB4aHJVcmwuYXV0aCA9IHVzZXIgKyBcIjpcIiArIHBhc3N3b3JkO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHhoclVybDtcbiAgICB9O1xuXG4gICAgWE1MSHR0cFJlcXVlc3QucHJvdG90eXBlLl9wYXJzZVJlc3BvbnNlSGVhZGVycyA9IGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICB2YXIgbG93ZXJlZE5hbWUsIG5hbWUsIHJlZiwgdmFsdWU7XG4gICAgICB0aGlzLl9yZXNwb25zZUhlYWRlcnMgPSB7fTtcbiAgICAgIHJlZiA9IHJlc3BvbnNlLmhlYWRlcnM7XG4gICAgICBmb3IgKG5hbWUgaW4gcmVmKSB7XG4gICAgICAgIHZhbHVlID0gcmVmW25hbWVdO1xuICAgICAgICBsb3dlcmVkTmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVIZWFkZXJzW2xvd2VyZWROYW1lXSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9taW1lT3ZlcnJpZGUgIT09IG51bGwgJiYgbG93ZXJlZE5hbWUgPT09ICdjb250ZW50LXR5cGUnKSB7XG4gICAgICAgICAgdmFsdWUgPSB0aGlzLl9taW1lT3ZlcnJpZGU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcmVzcG9uc2VIZWFkZXJzW2xvd2VyZWROYW1lXSA9IHZhbHVlO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX21pbWVPdmVycmlkZSAhPT0gbnVsbCAmJiAhKCdjb250ZW50LXR5cGUnIGluIHRoaXMuX3Jlc3BvbnNlSGVhZGVycykpIHtcbiAgICAgICAgdGhpcy5fcmVzcG9uc2VIZWFkZXJzWydjb250ZW50LXR5cGUnXSA9IHRoaXMuX21pbWVPdmVycmlkZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfTtcblxuICAgIFhNTEh0dHBSZXF1ZXN0LnByb3RvdHlwZS5fcGFyc2VSZXNwb25zZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGFycmF5QnVmZmVyLCBidWZmZXIsIGksIGosIGpzb25FcnJvciwgcmVmLCB2aWV3O1xuICAgICAgaWYgKEJ1ZmZlci5jb25jYXQpIHtcbiAgICAgICAgYnVmZmVyID0gQnVmZmVyLmNvbmNhdCh0aGlzLl9yZXNwb25zZVBhcnRzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJ1ZmZlciA9IHRoaXMuX2NvbmNhdEJ1ZmZlcnModGhpcy5fcmVzcG9uc2VQYXJ0cyk7XG4gICAgICB9XG4gICAgICB0aGlzLl9yZXNwb25zZVBhcnRzID0gbnVsbDtcbiAgICAgIHN3aXRjaCAodGhpcy5yZXNwb25zZVR5cGUpIHtcbiAgICAgICAgY2FzZSAndGV4dCc6XG4gICAgICAgICAgdGhpcy5fcGFyc2VUZXh0UmVzcG9uc2UoYnVmZmVyKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnanNvbic6XG4gICAgICAgICAgdGhpcy5yZXNwb25zZVRleHQgPSBudWxsO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLnJlc3BvbnNlID0gSlNPTi5wYXJzZShidWZmZXIudG9TdHJpbmcoJ3V0Zi04JykpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yMSkge1xuICAgICAgICAgICAganNvbkVycm9yID0gZXJyb3IxO1xuICAgICAgICAgICAgdGhpcy5yZXNwb25zZSA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdidWZmZXInOlxuICAgICAgICAgIHRoaXMucmVzcG9uc2VUZXh0ID0gbnVsbDtcbiAgICAgICAgICB0aGlzLnJlc3BvbnNlID0gYnVmZmVyO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdhcnJheWJ1ZmZlcic6XG4gICAgICAgICAgdGhpcy5yZXNwb25zZVRleHQgPSBudWxsO1xuICAgICAgICAgIGFycmF5QnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKGJ1ZmZlci5sZW5ndGgpO1xuICAgICAgICAgIHZpZXcgPSBuZXcgVWludDhBcnJheShhcnJheUJ1ZmZlcik7XG4gICAgICAgICAgZm9yIChpID0gaiA9IDAsIHJlZiA9IGJ1ZmZlci5sZW5ndGg7IDAgPD0gcmVmID8gaiA8IHJlZiA6IGogPiByZWY7IGkgPSAwIDw9IHJlZiA/ICsraiA6IC0taikge1xuICAgICAgICAgICAgdmlld1tpXSA9IGJ1ZmZlcltpXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5yZXNwb25zZSA9IGFycmF5QnVmZmVyO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRoaXMuX3BhcnNlVGV4dFJlc3BvbnNlKGJ1ZmZlcik7XG4gICAgICB9XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH07XG5cbiAgICBYTUxIdHRwUmVxdWVzdC5wcm90b3R5cGUuX3BhcnNlVGV4dFJlc3BvbnNlID0gZnVuY3Rpb24oYnVmZmVyKSB7XG4gICAgICB2YXIgZTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMucmVzcG9uc2VUZXh0ID0gYnVmZmVyLnRvU3RyaW5nKHRoaXMuX3BhcnNlUmVzcG9uc2VFbmNvZGluZygpKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yMSkge1xuICAgICAgICBlID0gZXJyb3IxO1xuICAgICAgICB0aGlzLnJlc3BvbnNlVGV4dCA9IGJ1ZmZlci50b1N0cmluZygnYmluYXJ5Jyk7XG4gICAgICB9XG4gICAgICB0aGlzLnJlc3BvbnNlID0gdGhpcy5yZXNwb25zZVRleHQ7XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH07XG5cbiAgICBYTUxIdHRwUmVxdWVzdC5wcm90b3R5cGUuX3BhcnNlUmVzcG9uc2VFbmNvZGluZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGNvbnRlbnRUeXBlLCBlbmNvZGluZywgbWF0Y2g7XG4gICAgICBlbmNvZGluZyA9IG51bGw7XG4gICAgICBpZiAoY29udGVudFR5cGUgPSB0aGlzLl9yZXNwb25zZUhlYWRlcnNbJ2NvbnRlbnQtdHlwZSddKSB7XG4gICAgICAgIGlmIChtYXRjaCA9IC9cXDtcXHMqY2hhcnNldFxcPSguKikkLy5leGVjKGNvbnRlbnRUeXBlKSkge1xuICAgICAgICAgIHJldHVybiBtYXRjaFsxXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuICd1dGYtOCc7XG4gICAgfTtcblxuICAgIFhNTEh0dHBSZXF1ZXN0LnByb3RvdHlwZS5fY29uY2F0QnVmZmVycyA9IGZ1bmN0aW9uKGJ1ZmZlcnMpIHtcbiAgICAgIHZhciBidWZmZXIsIGosIGssIGxlbiwgbGVuMSwgbGVuZ3RoLCB0YXJnZXQ7XG4gICAgICBpZiAoYnVmZmVycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCdWZmZXIoMCk7XG4gICAgICB9XG4gICAgICBpZiAoYnVmZmVycy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIGJ1ZmZlcnNbMF07XG4gICAgICB9XG4gICAgICBsZW5ndGggPSAwO1xuICAgICAgZm9yIChqID0gMCwgbGVuID0gYnVmZmVycy5sZW5ndGg7IGogPCBsZW47IGorKykge1xuICAgICAgICBidWZmZXIgPSBidWZmZXJzW2pdO1xuICAgICAgICBsZW5ndGggKz0gYnVmZmVyLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIHRhcmdldCA9IG5ldyBCdWZmZXIobGVuZ3RoKTtcbiAgICAgIGxlbmd0aCA9IDA7XG4gICAgICBmb3IgKGsgPSAwLCBsZW4xID0gYnVmZmVycy5sZW5ndGg7IGsgPCBsZW4xOyBrKyspIHtcbiAgICAgICAgYnVmZmVyID0gYnVmZmVyc1trXTtcbiAgICAgICAgYnVmZmVyLmNvcHkodGFyZ2V0LCBsZW5ndGgpO1xuICAgICAgICBsZW5ndGggKz0gYnVmZmVyLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfTtcblxuICAgIHJldHVybiBYTUxIdHRwUmVxdWVzdDtcblxuICB9KShYTUxIdHRwUmVxdWVzdEV2ZW50VGFyZ2V0KTtcblxuICBtb2R1bGUuZXhwb3J0cyA9IFhNTEh0dHBSZXF1ZXN0O1xuXG4gIFhNTEh0dHBSZXF1ZXN0LlhNTEh0dHBSZXF1ZXN0ID0gWE1MSHR0cFJlcXVlc3Q7XG5cbiAgU2VjdXJpdHlFcnJvciA9IChmdW5jdGlvbihzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKFNlY3VyaXR5RXJyb3IsIHN1cGVyQ2xhc3MpO1xuXG4gICAgZnVuY3Rpb24gU2VjdXJpdHlFcnJvcigpIHtcbiAgICAgIFNlY3VyaXR5RXJyb3IuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFNlY3VyaXR5RXJyb3I7XG5cbiAgfSkoRXJyb3IpO1xuXG4gIFhNTEh0dHBSZXF1ZXN0LlNlY3VyaXR5RXJyb3IgPSBTZWN1cml0eUVycm9yO1xuXG4gIEludmFsaWRTdGF0ZUVycm9yID0gKGZ1bmN0aW9uKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoSW52YWxpZFN0YXRlRXJyb3IsIHN1cGVyQ2xhc3MpO1xuXG4gICAgZnVuY3Rpb24gSW52YWxpZFN0YXRlRXJyb3IoKSB7XG4gICAgICBJbnZhbGlkU3RhdGVFcnJvci5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gSW52YWxpZFN0YXRlRXJyb3I7XG5cbiAgfSkoRXJyb3IpO1xuXG4gIEludmFsaWRTdGF0ZUVycm9yID0gKGZ1bmN0aW9uKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoSW52YWxpZFN0YXRlRXJyb3IsIHN1cGVyQ2xhc3MpO1xuXG4gICAgZnVuY3Rpb24gSW52YWxpZFN0YXRlRXJyb3IoKSB7XG4gICAgICByZXR1cm4gSW52YWxpZFN0YXRlRXJyb3IuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIEludmFsaWRTdGF0ZUVycm9yO1xuXG4gIH0pKEVycm9yKTtcblxuICBYTUxIdHRwUmVxdWVzdC5JbnZhbGlkU3RhdGVFcnJvciA9IEludmFsaWRTdGF0ZUVycm9yO1xuXG4gIE5ldHdvcmtFcnJvciA9IChmdW5jdGlvbihzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKE5ldHdvcmtFcnJvciwgc3VwZXJDbGFzcyk7XG5cbiAgICBmdW5jdGlvbiBOZXR3b3JrRXJyb3IoKSB7XG4gICAgICBOZXR3b3JrRXJyb3IuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIE5ldHdvcmtFcnJvcjtcblxuICB9KShFcnJvcik7XG5cbiAgWE1MSHR0cFJlcXVlc3QuU3ludGF4RXJyb3IgPSBTeW50YXhFcnJvcjtcblxuICBTeW50YXhFcnJvciA9IChmdW5jdGlvbihzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKFN5bnRheEVycm9yLCBzdXBlckNsYXNzKTtcblxuICAgIGZ1bmN0aW9uIFN5bnRheEVycm9yKCkge1xuICAgICAgU3ludGF4RXJyb3IuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFN5bnRheEVycm9yO1xuXG4gIH0pKEVycm9yKTtcblxuICBQcm9ncmVzc0V2ZW50ID0gKGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIFByb2dyZXNzRXZlbnQodHlwZSkge1xuICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgIHRoaXMudGFyZ2V0ID0gbnVsbDtcbiAgICAgIHRoaXMuY3VycmVudFRhcmdldCA9IG51bGw7XG4gICAgICB0aGlzLmxlbmd0aENvbXB1dGFibGUgPSBmYWxzZTtcbiAgICAgIHRoaXMubG9hZGVkID0gMDtcbiAgICAgIHRoaXMudG90YWwgPSAwO1xuICAgIH1cblxuICAgIFByb2dyZXNzRXZlbnQucHJvdG90eXBlLmJ1YmJsZXMgPSBmYWxzZTtcblxuICAgIFByb2dyZXNzRXZlbnQucHJvdG90eXBlLmNhbmNlbGFibGUgPSBmYWxzZTtcblxuICAgIFByb2dyZXNzRXZlbnQucHJvdG90eXBlLnRhcmdldCA9IG51bGw7XG5cbiAgICBQcm9ncmVzc0V2ZW50LnByb3RvdHlwZS5sb2FkZWQgPSBudWxsO1xuXG4gICAgUHJvZ3Jlc3NFdmVudC5wcm90b3R5cGUubGVuZ3RoQ29tcHV0YWJsZSA9IG51bGw7XG5cbiAgICBQcm9ncmVzc0V2ZW50LnByb3RvdHlwZS50b3RhbCA9IG51bGw7XG5cbiAgICByZXR1cm4gUHJvZ3Jlc3NFdmVudDtcblxuICB9KSgpO1xuXG4gIFhNTEh0dHBSZXF1ZXN0LlByb2dyZXNzRXZlbnQgPSBQcm9ncmVzc0V2ZW50O1xuXG4gIFhNTEh0dHBSZXF1ZXN0VXBsb2FkID0gKGZ1bmN0aW9uKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoWE1MSHR0cFJlcXVlc3RVcGxvYWQsIHN1cGVyQ2xhc3MpO1xuXG4gICAgZnVuY3Rpb24gWE1MSHR0cFJlcXVlc3RVcGxvYWQocmVxdWVzdCkge1xuICAgICAgWE1MSHR0cFJlcXVlc3RVcGxvYWQuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmNhbGwodGhpcyk7XG4gICAgICB0aGlzLl9yZXF1ZXN0ID0gcmVxdWVzdDtcbiAgICAgIHRoaXMuX3Jlc2V0KCk7XG4gICAgfVxuXG4gICAgWE1MSHR0cFJlcXVlc3RVcGxvYWQucHJvdG90eXBlLl9yZXNldCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5fY29udGVudFR5cGUgPSBudWxsO1xuICAgICAgdGhpcy5fYm9keSA9IG51bGw7XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH07XG5cbiAgICBYTUxIdHRwUmVxdWVzdFVwbG9hZC5wcm90b3R5cGUuX3NldERhdGEgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgICB2YXIgYm9keSwgaSwgaiwgaywgb2Zmc2V0LCByZWYsIHJlZjEsIHZpZXc7XG4gICAgICBpZiAodHlwZW9mIGRhdGEgPT09ICd1bmRlZmluZWQnIHx8IGRhdGEgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAoZGF0YS5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICB0aGlzLl9jb250ZW50VHlwZSA9ICd0ZXh0L3BsYWluO2NoYXJzZXQ9VVRGLTgnO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2JvZHkgPSBuZXcgQnVmZmVyKGRhdGEsICd1dGY4Jyk7XG4gICAgICB9IGVsc2UgaWYgKEJ1ZmZlci5pc0J1ZmZlcihkYXRhKSkge1xuICAgICAgICB0aGlzLl9ib2R5ID0gZGF0YTtcbiAgICAgIH0gZWxzZSBpZiAoZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICAgIGJvZHkgPSBuZXcgQnVmZmVyKGRhdGEuYnl0ZUxlbmd0aCk7XG4gICAgICAgIHZpZXcgPSBuZXcgVWludDhBcnJheShkYXRhKTtcbiAgICAgICAgZm9yIChpID0gaiA9IDAsIHJlZiA9IGRhdGEuYnl0ZUxlbmd0aDsgMCA8PSByZWYgPyBqIDwgcmVmIDogaiA+IHJlZjsgaSA9IDAgPD0gcmVmID8gKytqIDogLS1qKSB7XG4gICAgICAgICAgYm9keVtpXSA9IHZpZXdbaV07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fYm9keSA9IGJvZHk7XG4gICAgICB9IGVsc2UgaWYgKGRhdGEuYnVmZmVyICYmIGRhdGEuYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgYm9keSA9IG5ldyBCdWZmZXIoZGF0YS5ieXRlTGVuZ3RoKTtcbiAgICAgICAgb2Zmc2V0ID0gZGF0YS5ieXRlT2Zmc2V0O1xuICAgICAgICB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkoZGF0YS5idWZmZXIpO1xuICAgICAgICBmb3IgKGkgPSBrID0gMCwgcmVmMSA9IGRhdGEuYnl0ZUxlbmd0aDsgMCA8PSByZWYxID8gayA8IHJlZjEgOiBrID4gcmVmMTsgaSA9IDAgPD0gcmVmMSA/ICsrayA6IC0taykge1xuICAgICAgICAgIGJvZHlbaV0gPSB2aWV3W2kgKyBvZmZzZXRdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2JvZHkgPSBib2R5O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5zdXBwb3J0ZWQgc2VuZCgpIGRhdGEgXCIgKyBkYXRhKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfTtcblxuICAgIFhNTEh0dHBSZXF1ZXN0VXBsb2FkLnByb3RvdHlwZS5fZmluYWxpemVIZWFkZXJzID0gZnVuY3Rpb24oaGVhZGVycywgbG93ZXJlZEhlYWRlcnMpIHtcbiAgICAgIGlmICh0aGlzLl9jb250ZW50VHlwZSkge1xuICAgICAgICBpZiAoISgnY29udGVudC10eXBlJyBpbiBsb3dlcmVkSGVhZGVycykpIHtcbiAgICAgICAgICBoZWFkZXJzWydDb250ZW50LVR5cGUnXSA9IHRoaXMuX2NvbnRlbnRUeXBlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fYm9keSkge1xuICAgICAgICBoZWFkZXJzWydDb250ZW50LUxlbmd0aCddID0gdGhpcy5fYm9keS5sZW5ndGgudG9TdHJpbmcoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfTtcblxuICAgIFhNTEh0dHBSZXF1ZXN0VXBsb2FkLnByb3RvdHlwZS5fc3RhcnRVcGxvYWQgPSBmdW5jdGlvbihyZXF1ZXN0KSB7XG4gICAgICBpZiAodGhpcy5fYm9keSkge1xuICAgICAgICByZXF1ZXN0LndyaXRlKHRoaXMuX2JvZHkpO1xuICAgICAgfVxuICAgICAgcmVxdWVzdC5lbmQoKTtcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfTtcblxuICAgIHJldHVybiBYTUxIdHRwUmVxdWVzdFVwbG9hZDtcblxuICB9KShYTUxIdHRwUmVxdWVzdEV2ZW50VGFyZ2V0KTtcblxuICBYTUxIdHRwUmVxdWVzdC5YTUxIdHRwUmVxdWVzdFVwbG9hZCA9IFhNTEh0dHBSZXF1ZXN0VXBsb2FkO1xuXG59KS5jYWxsKHRoaXMpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMveGhyMi9saWIveGhyMi5qc1xuLy8gbW9kdWxlIGlkID0gODdcbi8vIG1vZHVsZSBjaHVua3MgPSA0IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiaHR0cFwiKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcImh0dHBcIlxuLy8gbW9kdWxlIGlkID0gODhcbi8vIG1vZHVsZSBjaHVua3MgPSA0IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiaHR0cHNcIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJodHRwc1wiXG4vLyBtb2R1bGUgaWQgPSA4OVxuLy8gbW9kdWxlIGNodW5rcyA9IDQiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJvc1wiKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcIm9zXCJcbi8vIG1vZHVsZSBpZCA9IDkwXG4vLyBtb2R1bGUgY2h1bmtzID0gNCIsIm1vZHVsZS5leHBvcnRzID0gKF9fd2VicGFja19yZXF1aXJlX18oMikpKDM3Mik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZGVsZWdhdGVkIC4vbm9kZV9tb2R1bGVzL2FzcG5ldC1wcmVyZW5kZXJpbmcvaW5kZXguanMgZnJvbSBkbGwtcmVmZXJlbmNlIC4vdmVuZG9yXG4vLyBtb2R1bGUgaWQgPSA5MVxuLy8gbW9kdWxlIGNodW5rcyA9IDQiLCJpbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBTZXJ2ZXJNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9wbGF0Zm9ybS1zZXJ2ZXInO1xyXG5pbXBvcnQgeyBOb29wQW5pbWF0aW9uc01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXIvYW5pbWF0aW9ucyc7XHJcbmltcG9ydCB7IEFwcE1vZHVsZVNoYXJlZCB9IGZyb20gJy4vYXBwLm1vZHVsZS5zaGFyZWQnO1xyXG5pbXBvcnQgeyBBcHBDb21wb25lbnQgfSBmcm9tICcuL2FwcC5jb21wb25lbnQnO1xyXG5cclxuQE5nTW9kdWxlKHtcclxuICAgIGJvb3RzdHJhcDogW0FwcENvbXBvbmVudF0sXHJcbiAgICBkZWNsYXJhdGlvbnM6IFtBcHBDb21wb25lbnRdLFxyXG4gICAgaW1wb3J0czogW1xyXG4gICAgICAgIFNlcnZlck1vZHVsZSxcclxuICAgICAgICAvLyBBcyBleHBsYWluZWQgaGVyZSwgYW5pbWF0aW9ucyBtb2R1bGUgdXNlZCBkb2N1bWVudCBoZW5jZSB3ZSBuZWVkIE5vb3AgYW5pbWF0aW9ucyBtb2R1bGUgb24gc2VydmVyXHJcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvYW5ndWxhci9pc3N1ZXMvMTQ3ODRcclxuICAgICAgICBOb29wQW5pbWF0aW9uc01vZHVsZSxcclxuICAgICAgICBBcHBNb2R1bGVTaGFyZWQsXHJcbiAgICBdXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBBcHBNb2R1bGUgeyB9XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9hbmd1bGFyMi10ZW1wbGF0ZS1sb2FkZXIhLi9DbGllbnRBcHAvYXBwL2FwcC5tb2R1bGUuc2VydmVyLnRzIiwiaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgQnJvd3Nlck1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXInO1xyXG5pbXBvcnQgeyBTaGFyZWRNb2R1bGUgfSBmcm9tICcuL3NoYXJlZC9zaGFyZWQubW9kdWxlJztcclxuaW1wb3J0IHsgQ29yZU1vZHVsZSB9IGZyb20gJy4vY29yZS9jb3JlLm1vZHVsZSc7XHJcbmltcG9ydCB7IEhvbWVNb2R1bGUgfSBmcm9tICcuL2hvbWUvaG9tZS5tb2R1bGUnO1xyXG5cclxuaW1wb3J0IHsgcm91dGluZyB9IGZyb20gJy4vYXBwLnJvdXRlcyc7XHJcbmltcG9ydCB7IEFwcFNlcnZpY2UgfSBmcm9tICcuL2FwcC5zZXJ2aWNlJztcclxuXHJcbkBOZ01vZHVsZSh7XHJcbiAgICBpbXBvcnRzOiBbXHJcbiAgICAgICAgQnJvd3Nlck1vZHVsZSxcclxuICAgICAgICByb3V0aW5nLFxyXG4gICAgICAgIENvcmVNb2R1bGUuZm9yUm9vdCgpLFxyXG4gICAgICAgIFNoYXJlZE1vZHVsZS5mb3JSb290KCksXHJcbiAgICAgICAgSG9tZU1vZHVsZSxcclxuICAgIF0sXHJcbiAgICBwcm92aWRlcnM6IFtcclxuICAgICAgICBBcHBTZXJ2aWNlXHJcbiAgICBdLFxyXG4gICAgZXhwb3J0czogW1xyXG4gICAgICAgIFNoYXJlZE1vZHVsZVxyXG4gICAgXVxyXG59KVxyXG5leHBvcnQgY2xhc3MgQXBwTW9kdWxlU2hhcmVkIHsgfVxyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvYW5ndWxhcjItdGVtcGxhdGUtbG9hZGVyIS4vQ2xpZW50QXBwL2FwcC9hcHAubW9kdWxlLnNoYXJlZC50cyIsImltcG9ydCB7IENvbXBvbmVudCwgSW5wdXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuXHJcbkBDb21wb25lbnQoe1xyXG4gICAgc2VsZWN0b3I6ICdhcHBjLXBhZ2UtaGVhZGluZycsXHJcbiAgICB0ZW1wbGF0ZTogYDxoND57e3RleHR9fTwvaDQ+YFxyXG59KVxyXG5leHBvcnQgY2xhc3MgUGFnZUhlYWRpbmdDb21wb25lbnQge1xyXG4gICAgQElucHV0KCkgcHVibGljIHRleHQ6IHN0cmluZztcclxufVxyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvYW5ndWxhcjItdGVtcGxhdGUtbG9hZGVyIS4vQ2xpZW50QXBwL2FwcC9zaGFyZWQvZGlyZWN0aXZlcy9wYWdlLWhlYWRpbmcuZGlyZWN0aXZlLnRzIiwiaW1wb3J0IHsgQ29tcG9uZW50LCBJbnB1dCwgT3V0cHV0LCBFdmVudEVtaXR0ZXIsIE9uSW5pdCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBGb3JtR3JvdXAgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XHJcblxyXG5pbXBvcnQgeyBDb250cm9sQmFzZSB9IGZyb20gJy4vY29udHJvbC1iYXNlJztcclxuaW1wb3J0IHsgRm9ybUNvbnRyb2xTZXJ2aWNlIH0gZnJvbSAnLi9mb3JtLWNvbnRyb2wuc2VydmljZSc7XHJcblxyXG5AQ29tcG9uZW50KHtcclxuICAgIHNlbGVjdG9yOiAnYXBwYy1keW5hbWljLWZvcm0nLFxyXG4gICAgdGVtcGxhdGU6IHJlcXVpcmUoJy4vZHluYW1pYy1mb3JtLmNvbXBvbmVudC5odG1sJylcclxufSlcclxuZXhwb3J0IGNsYXNzIER5bmFtaWNGb3JtQ29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0IHtcclxuXHJcbiAgICBASW5wdXQoKSBwdWJsaWMgY29udHJvbHM6IEFycmF5PENvbnRyb2xCYXNlPGFueT4+ID0gW107XHJcbiAgICBASW5wdXQoKSBwdWJsaWMgYnRuVGV4dCA9ICdTdWJtaXQnOyAvLyBEZWZhdWx0IHZhbHVlIGF0IGxlYXN0XHJcbiAgICBASW5wdXQoKSBwdWJsaWMgZm9ybUNsYXNzID0gJ2Zvcm0taG9yaXpvbnRhbCc7XHJcbiAgICAvLyBOb3RlOiBkb24ndCBrZWVwIG5hbWUgb2Ygb3V0cHV0IGV2ZW50cyBhcyBzYW1lIGFzIG5hdGl2ZSBldmVudHMgc3VjaCBhcyBzdWJtaXQgZXRjLlxyXG4gICAgQE91dHB1dCgpIHB1YmxpYyBmb3Jtc3VibWl0OiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXI8YW55PigpO1xyXG4gICAgcHVibGljIGZvcm06IEZvcm1Hcm91cDtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgX2NvbnRyb2xTZXJ2aWNlOiBGb3JtQ29udHJvbFNlcnZpY2UpIHsgfVxyXG5cclxuICAgIHB1YmxpYyBuZ09uSW5pdCgpIHtcclxuICAgICAgICBjb25zdCBzb3J0ZWRDb250cm9scyA9IHRoaXMuY29udHJvbHMuc29ydCgoYSwgYikgPT4gYS5vcmRlciAtIGIub3JkZXIpO1xyXG4gICAgICAgIHRoaXMuZm9ybSA9IHRoaXMuX2NvbnRyb2xTZXJ2aWNlLnRvQ29udHJvbEdyb3VwKHNvcnRlZENvbnRyb2xzKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgb25TdWJtaXQoKSB7XHJcbiAgICAgICAgdGhpcy5mb3Jtc3VibWl0LmVtaXQodGhpcy5mb3JtLnZhbHVlKTtcclxuICAgIH1cclxufVxyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvYW5ndWxhcjItdGVtcGxhdGUtbG9hZGVyIS4vQ2xpZW50QXBwL2FwcC9zaGFyZWQvZm9ybXMvZHluYW1pYy1mb3JtLmNvbXBvbmVudC50cyIsIm1vZHVsZS5leHBvcnRzID0gXCI8Zm9ybSBjbGFzcz1cXFwie3tmb3JtQ2xhc3N9fVxcXCIgKG5nU3VibWl0KT1cXFwib25TdWJtaXQoKVxcXCIgW2Zvcm1Hcm91cF09XFxcImZvcm1cXFwiIHJvbGU9XFxcImZvcm1cXFwiICNmPlxcclxcbiAgICA8YXBwYy1keW5hbWljLWNvbnRyb2wgKm5nRm9yPVxcXCJsZXQgY3RybCBvZiBjb250cm9sc1xcXCIgW2NvbnRyb2xdPVxcXCJjdHJsXFxcIiBbZm9ybV09XFxcImZvcm1cXFwiPjwvYXBwYy1keW5hbWljLWNvbnRyb2w+XFxyXFxuXFxyXFxuICAgIDxidXR0b24gdHlwZT1cXFwic3VibWl0XFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi1wcmltYXJ5IHB1bGwtcmlnaHRcXFwiIFtkaXNhYmxlZF09XFxcIiFmb3JtLnZhbGlkXFxcIj57e2J0blRleHR9fTwvYnV0dG9uPlxcclxcbjwvZm9ybT5cIjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL0NsaWVudEFwcC9hcHAvc2hhcmVkL2Zvcm1zL2R5bmFtaWMtZm9ybS5jb21wb25lbnQuaHRtbFxuLy8gbW9kdWxlIGlkID0gOTZcbi8vIG1vZHVsZSBjaHVua3MgPSA0IiwiLy8gdHNsaW50OmRpc2FibGVcclxuaW1wb3J0IHsgQ29tcG9uZW50LCBJbnB1dCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBGb3JtR3JvdXAgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XHJcbmltcG9ydCB7IENvbnRyb2xCYXNlIH0gZnJvbSAnLi9jb250cm9sLWJhc2UnO1xyXG5cclxuQENvbXBvbmVudCh7XHJcbiAgICBzZWxlY3RvcjogJ2FwcGMtZHluYW1pYy1jb250cm9sJyxcclxuICAgIHRlbXBsYXRlOiByZXF1aXJlKCcuL2R5bmFtaWMtZm9ybS1jb250cm9sLmNvbXBvbmVudC5odG1sJylcclxufSlcclxuZXhwb3J0IGNsYXNzIER5bmFtaWNGb3JtQ29udHJvbENvbXBvbmVudCB7XHJcbiAgICBASW5wdXQoKSBwdWJsaWMgY29udHJvbDogQ29udHJvbEJhc2U8c3RyaW5nIHwgYm9vbGVhbj47XHJcbiAgICBASW5wdXQoKSBwdWJsaWMgZm9ybTogRm9ybUdyb3VwO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKCkgeyB9XHJcblxyXG4gICAgZ2V0IHZhbGlkKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmZvcm0uY29udHJvbHNbdGhpcy5jb250cm9sLmtleV0udmFsaWQ7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0IGludmFsaWQoKSB7XHJcbiAgICAgICAgcmV0dXJuICF0aGlzLmZvcm0uY29udHJvbHNbdGhpcy5jb250cm9sLmtleV0udmFsaWQgJiYgdGhpcy5mb3JtLmNvbnRyb2xzW3RoaXMuY29udHJvbC5rZXldLnRvdWNoZWQ7XHJcbiAgICB9XHJcbn1cclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2FuZ3VsYXIyLXRlbXBsYXRlLWxvYWRlciEuL0NsaWVudEFwcC9hcHAvc2hhcmVkL2Zvcm1zL2R5bmFtaWMtZm9ybS1jb250cm9sLmNvbXBvbmVudC50cyIsIm1vZHVsZS5leHBvcnRzID0gXCI8IS0tdHNsaW50OmRpc2FibGUtLT5cXHJcXG48ZGl2ICNmPVxcXCJuZ0Zvcm1cXFwiIFtmb3JtR3JvdXBdPVxcXCJmb3JtXFxcIiBbbmdTd2l0Y2hdPVxcXCJjb250cm9sLnR5cGVcXFwiIGNsYXNzPVxcXCJmb3JtLWdyb3VwIHt7Y29udHJvbC5jbGFzc319XFxcIiBbY2xhc3MuaGFzLWRhbmdlcl09XFxcImludmFsaWRcXFwiXFxyXFxuICAgIFtjbGFzcy5oYXMtc3VjY2Vzc109XFxcInZhbGlkXFxcIiBbY2xhc3MuZm9ybS1jaGVja109XFxcImNvbnRyb2wudHlwZSA9PT0gJ2NoZWNrYm94J1xcXCI+XFxyXFxuXFxyXFxuICAgIDxsYWJlbCAqbmdTd2l0Y2hDYXNlPVxcXCInZHJvcGRvd24nXFxcIiBbYXR0ci5mb3JdPVxcXCJjb250cm9sLmtleVxcXCIgY2xhc3M9XFxcImNvbC1mb3JtLWxhYmVsXFxcIj57e2NvbnRyb2wubGFiZWx9fTwvbGFiZWw+XFxyXFxuICAgIDxzZWxlY3QgKm5nU3dpdGNoQ2FzZT1cXFwiJ2Ryb3Bkb3duJ1xcXCIgW2lkXT1cXFwiY29udHJvbC5rZXlcXFwiIFtmb3JtQ29udHJvbE5hbWVdPVxcXCJjb250cm9sLmtleVxcXCIgW2NsYXNzLmZvcm0tY29udHJvbC1zdWNjZXNzXT1cXFwidmFsaWRcXFwiXFxyXFxuICAgICAgICBbY2xhc3MuZm9ybS1jb250cm9sLWRhbmdlcl09XFxcImludmFsaWRcXFwiIGNsYXNzPVxcXCJmb3JtLWNvbnRyb2xcXFwiPlxcclxcbjxvcHRpb24gKm5nRm9yPVxcXCJsZXQgb3B0IG9mIGNvbnRyb2wub3B0aW9uc1xcXCIgW3ZhbHVlXT1cXFwib3B0LmtleVxcXCI+e3tvcHQudmFsdWV9fTwvb3B0aW9uPlxcclxcbjwvc2VsZWN0PlxcclxcbiAgICA8bGFiZWwgKm5nU3dpdGNoQ2FzZT1cXFwiJ2NoZWNrYm94J1xcXCIgW2F0dHIuZm9yXT1cXFwiY29udHJvbC5rZXlcXFwiIGNsYXNzPVxcXCJmb3JtLWNoZWNrLWxhYmVsXFxcIj5cXHJcXG4gICAgPGlucHV0ICNjayAqbmdTd2l0Y2hDYXNlPVxcXCInY2hlY2tib3gnXFxcIiAoY2hhbmdlKT1cXFwiY29udHJvbC52YWx1ZSA9IGNrLmNoZWNrZWRcXFwiIFtpZF09XFxcImNvbnRyb2wua2V5XFxcIiBbZm9ybUNvbnRyb2xOYW1lXT1cXFwiY29udHJvbC5rZXlcXFwiXFxyXFxuICAgICAgICBbdHlwZV09XFxcImNvbnRyb2wudHlwZVxcXCIgY2xhc3M9XFxcImZvcm0tY2hlY2staW5wdXRcXFwiPlxcclxcbiAgICAgICAge3tjb250cm9sLmxhYmVsfX1cXHJcXG4gICAgPC9sYWJlbD5cXHJcXG5cXHJcXG4gICAgPCEtLVRoaXMgaXMgbm90IHRoZSBzd2l0Y2ggY2FzZSBiZWNhdXNlIG9mIG11bHRpcGxlIGNvbnRyb2wgdHlwZXMtLT5cXHJcXG4gICAgPGxhYmVsICpuZ0lmPVxcXCJjb250cm9sLnR5cGUgPT09ICd0ZXh0Ym94JyB8fCBjb250cm9sLnR5cGUgPT09ICdlbWFpbCcgfHwgY29udHJvbC50eXBlID09PSAncGFzc3dvcmQnXFxcIiBbYXR0ci5mb3JdPVxcXCJjb250cm9sLmtleVxcXCJcXHJcXG4gICAgICAgIGNsYXNzPVxcXCJjb2wtZm9ybS1sYWJlbFxcXCI+e3tjb250cm9sLmxhYmVsfX08L2xhYmVsPlxcclxcbiAgICA8aW5wdXQgKm5nSWY9XFxcImNvbnRyb2wudHlwZSA9PT0gJ3RleHRib3gnIHx8IGNvbnRyb2wudHlwZSA9PT0gJ2VtYWlsJyB8fCBjb250cm9sLnR5cGUgPT09ICdwYXNzd29yZCdcXFwiIFtpZF09XFxcImNvbnRyb2wua2V5XFxcIiBbZm9ybUNvbnRyb2xOYW1lXT1cXFwiY29udHJvbC5rZXlcXFwiXFxyXFxuICAgICAgICBbdHlwZV09XFxcImNvbnRyb2wudHlwZVxcXCIgW3BsYWNlaG9sZGVyXT1cXFwiY29udHJvbC5wbGFjZWhvbGRlclxcXCIgW2NsYXNzLmZvcm0tY29udHJvbC1zdWNjZXNzXT1cXFwidmFsaWRcXFwiIFtjbGFzcy5mb3JtLWNvbnRyb2wtZGFuZ2VyXT1cXFwiaW52YWxpZFxcXCJcXHJcXG4gICAgICAgIGNsYXNzPVxcXCJmb3JtLWNvbnRyb2xcXFwiPlxcclxcblxcclxcbiAgICA8IS0tVGV4dGFyZWEtLT5cXHJcXG4gICAgPGxhYmVsICpuZ0lmPVxcXCJjb250cm9sLnR5cGUgPT09ICd0ZXh0YXJlYSdcXFwiIFtmb3JdPVxcXCJjb250cm9sLmtleVxcXCI+e3tjb250cm9sLmxhYmVsfX08L2xhYmVsPlxcclxcbiAgICA8dGV4dGFyZWEgKm5nSWY9XFxcImNvbnRyb2wudHlwZSA9PT0gJ3RleHRhcmVhJ1xcXCIgY2xhc3M9XFxcIiBmb3JtLWNvbnRyb2xcXFwiIFtpZF09XFxcImNvbnRyb2wua2V5XFxcIiByb3dzPVxcXCIzXFxcIiBbZm9ybUNvbnRyb2xOYW1lXT1cXFwiY29udHJvbC5rZXlcXFwiXFxyXFxuICAgICAgICBbY2xhc3MuZm9ybS1jb250cm9sLXN1Y2Nlc3NdPVxcXCJ2YWxpZFxcXCIgW2NsYXNzLmZvcm0tY29udHJvbC1kYW5nZXJdPVxcXCJpbnZhbGlkXFxcIj48L3RleHRhcmVhPlxcclxcblxcclxcbiAgICA8IS0tQ2hlY2tib3gtLT5cXHJcXG4gICAgPGxhYmVsICpuZ1N3aXRjaENhc2U9XFxcIidjaGVja2JveCdcXFwiIFthdHRyLmZvcl09XFxcImNvbnRyb2wua2V5XFxcIiBjbGFzcz1cXFwiY3VzdG9tLWNvbnRyb2wgY3VzdG9tLWNoZWNrYm94XFxcIj5cXHJcXG4gICAgPGlucHV0ICpuZ1N3aXRjaENhc2U9XFxcIidjaGVja2JveCdcXFwiIFtpZF09XFxcImNvbnRyb2wua2V5XFxcIiBbZm9ybUNvbnRyb2xOYW1lXT1cXFwiY29udHJvbC5rZXlcXFwiIFxcclxcbiAgICAgICAgdHlwZT1cXFwiY2hlY2tib3hcXFwiIGNsYXNzPVxcXCJjdXN0b20tY29udHJvbC1pbnB1dFxcXCIgPlxcclxcbiAgICAgICAgPHNwYW4gY2xhc3M9XFxcImN1c3RvbS1jb250cm9sLWluZGljYXRvclxcXCI+PC9zcGFuPlxcclxcbiAgICAgICAgPHNwYW4gY2xhc3M9XFxcImN1c3RvbS1jb250cm9sLWRlc2NyaXB0aW9uXFxcIj57e2NvbnRyb2wubGFiZWx9fTwvc3Bhbj5cXHJcXG48L2xhYmVsPlxcclxcblxcclxcblxcclxcbiAgICA8YXBwYy1jb250cm9sLWVycm9yLW1lc3NhZ2UgW2Zvcm1dPVxcXCJmXFxcIiBbY29udHJvbF09XFxcImNvbnRyb2xcXFwiPjwvYXBwYy1jb250cm9sLWVycm9yLW1lc3NhZ2U+XFxyXFxuXFxyXFxuPC9kaXY+XCI7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9DbGllbnRBcHAvYXBwL3NoYXJlZC9mb3Jtcy9keW5hbWljLWZvcm0tY29udHJvbC5jb21wb25lbnQuaHRtbFxuLy8gbW9kdWxlIGlkID0gOThcbi8vIG1vZHVsZSBjaHVua3MgPSA0IiwiaW1wb3J0IHsgQ29tcG9uZW50LCBJbnB1dCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBGb3JtR3JvdXBEaXJlY3RpdmUgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XHJcblxyXG5pbXBvcnQgeyBDb250cm9sQmFzZSB9IGZyb20gJy4vY29udHJvbC1iYXNlJztcclxuaW1wb3J0IHsgVmFsaWRhdGlvblNlcnZpY2UgfSBmcm9tICcuL3ZhbGlkYXRpb24uc2VydmljZSc7XHJcblxyXG5AQ29tcG9uZW50KHtcclxuICAgIHNlbGVjdG9yOiAnYXBwYy1jb250cm9sLWVycm9yLW1lc3NhZ2UnLFxyXG4gICAgdGVtcGxhdGU6IGA8ZGl2ICpuZ0lmPVwiZXJyb3JNZXNzYWdlXCIgY2xhc3M9XCJmb3JtLWNvbnRyb2wtZmVlZGJhY2tcIj4ge3tlcnJvck1lc3NhZ2V9fSA8L2Rpdj5gXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBFcnJvck1lc3NhZ2VDb21wb25lbnQge1xyXG4gICAgQElucHV0KCkgcHVibGljIGNvbnRyb2w6IENvbnRyb2xCYXNlPGFueT47XHJcbiAgICBASW5wdXQoKSBwdWJsaWMgZm9ybTogRm9ybUdyb3VwRGlyZWN0aXZlO1xyXG5cclxuICAgIGdldCBlcnJvck1lc3NhZ2UoKSB7XHJcbiAgICAgICAgY29uc3QgYzogYW55ID0gdGhpcy5mb3JtLmZvcm0uZ2V0KHRoaXMuY29udHJvbC5rZXkpO1xyXG4gICAgICAgIGZvciAoY29uc3QgcHJvcGVydHlOYW1lIGluIGMuZXJyb3JzKSB7XHJcbiAgICAgICAgICAgIGlmIChjLmVycm9ycy5oYXNPd25Qcm9wZXJ0eShwcm9wZXJ0eU5hbWUpICYmIGMudG91Y2hlZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFZhbGlkYXRpb25TZXJ2aWNlLmdldFZhbGlkYXRvckVycm9yTWVzc2FnZShwcm9wZXJ0eU5hbWUsIHRoaXMuY29udHJvbC5taW5sZW5ndGggfHwgdGhpcy5jb250cm9sLm1heGxlbmd0aCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgIH1cclxufVxyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvYW5ndWxhcjItdGVtcGxhdGUtbG9hZGVyIS4vQ2xpZW50QXBwL2FwcC9zaGFyZWQvZm9ybXMvZXJyb3ItbWVzc2FnZS5jb21wb25lbnQudHMiLCJpbXBvcnQgeyBDb21wb25lbnQsIElucHV0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcblxyXG5AQ29tcG9uZW50KHtcclxuICAgIHNlbGVjdG9yOiAnYXBwYy1lcnJvci1zdW1tYXJ5JyxcclxuICAgIHRlbXBsYXRlOiByZXF1aXJlKCcuL2Vycm9yLXN1bW1hcnkuY29tcG9uZW50Lmh0bWwnKVxyXG59KVxyXG5leHBvcnQgY2xhc3MgRXJyb3JTdW1tYXJ5Q29tcG9uZW50IHtcclxuICAgIEBJbnB1dCgpIHB1YmxpYyBlcnJvcnM6IHN0cmluZ1tdO1xyXG59XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9hbmd1bGFyMi10ZW1wbGF0ZS1sb2FkZXIhLi9DbGllbnRBcHAvYXBwL3NoYXJlZC9mb3Jtcy9lcnJvci1zdW1tYXJ5LmNvbXBvbmVudC50cyIsIm1vZHVsZS5leHBvcnRzID0gXCI8ZGl2IGNsYXNzPVxcXCJhbGVydCBhbGVydC1kYW5nZXJcXFwiICpuZ0lmPVxcXCJlcnJvcnM/Lmxlbmd0aCA+IDBcXFwiPlxcclxcbiAgICA8ZGl2ICpuZ0Zvcj1cXFwibGV0IGVycm9yIG9mIGVycm9yc1xcXCI+XFxyXFxuICAgICAgICB7e2Vycm9yfX1cXHJcXG4gICAgPC9kaXY+XFxyXFxuPC9kaXY+XCI7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9DbGllbnRBcHAvYXBwL3NoYXJlZC9mb3Jtcy9lcnJvci1zdW1tYXJ5LmNvbXBvbmVudC5odG1sXG4vLyBtb2R1bGUgaWQgPSAxMDFcbi8vIG1vZHVsZSBjaHVua3MgPSA0IiwiaW1wb3J0IHsgQ29tcG9uZW50LCBPbkluaXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgVHJhbnNsYXRlU2VydmljZSB9IGZyb20gJ0BuZ3gtdHJhbnNsYXRlL2NvcmUnO1xyXG5pbXBvcnQgeyBBY2NvdW50U2VydmljZSB9IGZyb20gJy4uLy4uL2NvcmUvc2VydmljZXMvYWNjb3VudC5zZXJ2aWNlJztcclxuaW1wb3J0IHsgUHJvZmlsZU1vZGVsIH0gZnJvbSAnLi4vLi4vY29yZS9tb2RlbHMvcHJvZmlsZS1tb2RlbCc7XHJcblxyXG5AQ29tcG9uZW50KHtcclxuICAgIHNlbGVjdG9yOiAnYXBwYy1oZWFkZXInLFxyXG4gICAgdGVtcGxhdGU6IHJlcXVpcmUoJy4vaGVhZGVyLmNvbXBvbmVudC5odG1sJyksXHJcbiAgICBzdHlsZXM6IFtyZXF1aXJlKCcuL2hlYWRlci5jb21wb25lbnQuc2NzcycpXVxyXG59KVxyXG5leHBvcnQgY2xhc3MgSGVhZGVyQ29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0IHtcclxuICAgIHB1YmxpYyBpc0NvbGxhcHNlZCA9IHRydWU7XHJcbiAgICBwdWJsaWMgbGFuZ3VhZ2VzID0gW1xyXG4gICAgICAgIHsgbG9jYWxlOiAnZW4nLCBkZXNjcmlwdGlvbjogJ0VuZ2xpc2gnIH0sXHJcbiAgICAgICAgeyBsb2NhbGU6ICdmcicsIGRlc2NyaXB0aW9uOiAnRnJlbmNoJyB9XHJcbiAgICBdO1xyXG4gICAgcHVibGljIGN1cnJlbnRMYW5ndWFnZSA9IHRoaXMubGFuZ3VhZ2VzWzBdO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKFxyXG4gICAgICAgIHB1YmxpYyBhY2NvdW50U2VydmljZTogQWNjb3VudFNlcnZpY2UsXHJcbiAgICAgICAgcHVibGljIHRyYW5zbGF0aW9uOiBUcmFuc2xhdGVTZXJ2aWNlXHJcbiAgICApIHsgfVxyXG5cclxuICAgIHB1YmxpYyBnZXQgaXNMb2dnZWRJbigpOiBib29sZWFuIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5hY2NvdW50U2VydmljZS5pc0xvZ2dlZEluO1xyXG4gICAgfVxyXG4gICAgcHVibGljIGdldCB1c2VyKCk6IFByb2ZpbGVNb2RlbCB8IHVuZGVmaW5lZCB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYWNjb3VudFNlcnZpY2UudXNlcjtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIG5nT25Jbml0KCk6IHZvaWQgeyB9XHJcblxyXG4gICAgcHVibGljIHRvZ2dsZU5hdigpIHtcclxuICAgICAgICB0aGlzLmlzQ29sbGFwc2VkID0gIXRoaXMuaXNDb2xsYXBzZWQ7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHNldExhbmcobGFuZzogYW55KSB7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50TGFuZ3VhZ2UgPSBsYW5nO1xyXG4gICAgICAgIHRoaXMudHJhbnNsYXRpb24udXNlKGxhbmcubG9jYWxlKTtcclxuICAgIH1cclxufVxyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvYW5ndWxhcjItdGVtcGxhdGUtbG9hZGVyIS4vQ2xpZW50QXBwL2FwcC9zaGFyZWQvbGF5b3V0L2hlYWRlci5jb21wb25lbnQudHMiLCJtb2R1bGUuZXhwb3J0cyA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKDIpKSgxMDEpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGRlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9yeGpzL1J4LmpzIGZyb20gZGxsLXJlZmVyZW5jZSAuL3ZlbmRvclxuLy8gbW9kdWxlIGlkID0gMTAzXG4vLyBtb2R1bGUgY2h1bmtzID0gNCIsIm1vZHVsZS5leHBvcnRzID0gKF9fd2VicGFja19yZXF1aXJlX18oMikpKDM4MCk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZGVsZWdhdGVkIC4vbm9kZV9tb2R1bGVzL2FuZ3VsYXIyLWp3dC9hbmd1bGFyMi1qd3QuanMgZnJvbSBkbGwtcmVmZXJlbmNlIC4vdmVuZG9yXG4vLyBtb2R1bGUgaWQgPSAxMDRcbi8vIG1vZHVsZSBjaHVua3MgPSA0IiwibW9kdWxlLmV4cG9ydHMgPSBcIjxuYXYgY2xhc3M9XFxcIm5hdmJhciBuYXZiYXItZXhwYW5kLW1kIG5hdmJhci1saWdodCBiZy1mYWRlZFxcXCI+XFxyXFxuICAgIDxidXR0b24gY2xhc3M9XFxcIm5hdmJhci10b2dnbGVyIG5hdmJhci10b2dnbGVyLXJpZ2h0XFxcIiBbY2xhc3MuY29sbGFwc2VkXT1cXFwiaXNDb2xsYXBzZWRcXFwiIHR5cGU9XFxcImJ1dHRvblxcXCIgZGF0YS10b2dnbGU9XFxcImNvbGxhcHNlXFxcIlxcclxcbiAgICAgICAgZGF0YS10YXJnZXQ9XFxcIiNuYXZiYXJOYXZcXFwiIGFyaWEtY29udHJvbHM9XFxcIm5hdmJhck5hdlxcXCIgKGNsaWNrKT1cXFwidG9nZ2xlTmF2KClcXFwiIGFyaWEtZXhwYW5kZWQ9XFxcImZhbHNlXFxcIiBhcmlhLWxhYmVsPVxcXCJUb2dnbGUgbmF2aWdhdGlvblxcXCI+XFxyXFxuICAgICAgICA8c3BhbiBjbGFzcz1cXFwibmF2YmFyLXRvZ2dsZXItaWNvblxcXCI+PC9zcGFuPlxcclxcbiAgICA8L2J1dHRvbj5cXHJcXG4gICAgPGEgY2xhc3M9XFxcIm5hdmJhci1icmFuZFxcXCIgcm91dGVyTGluaz1cXFwiaG9tZVxcXCI+QXNwTmV0Q29yZVNwYTwvYT5cXHJcXG5cXHJcXG4gICAgPGRpdiBjbGFzcz1cXFwiY29sbGFwc2UgbmF2YmFyLWNvbGxhcHNlXFxcIiBpZD1cXFwibmF2YmFyTmF2XFxcIiBbY2xhc3Muc2hvd109XFxcIiFpc0NvbGxhcHNlZFxcXCI+XFxyXFxuICAgICAgICA8IS0tTGVmdCBuYXYtLT5cXHJcXG4gICAgICAgIDx1bCBjbGFzcz1cXFwibmF2YmFyLW5hdlxcXCI+XFxyXFxuICAgICAgICAgICAgPGxpIGNsYXNzPVxcXCJuYXYtaXRlbVxcXCI+XFxyXFxuICAgICAgICAgICAgICAgIDxhIGNsYXNzPVxcXCJuYXYtbGlua1xcXCIgcm91dGVyTGlua0FjdGl2ZT1cXFwiYWN0aXZlXFxcIiByb3V0ZXJMaW5rPVxcXCJob21lXFxcIj57eydBUFBfTkFWX0hPTUUnIHwgdHJhbnNsYXRlfX08L2E+XFxyXFxuICAgICAgICAgICAgPC9saT5cXHJcXG4gICAgICAgICAgICA8bGkgY2xhc3M9XFxcIm5hdi1pdGVtIGRyb3Bkb3duXFxcIj5cXHJcXG4gICAgICAgICAgICAgICAgPGRpdiBuZ2JEcm9wZG93biBjbGFzcz1cXFwiZC1pbmxpbmUtYmxvY2tcXFwiPlxcclxcbiAgICAgICAgICAgICAgICAgICAgPGEgY2xhc3M9XFxcIm5hdi1saW5rXFxcIiBpZD1cXFwibGFuZ3VhZ2VzXFxcIiBuZ2JEcm9wZG93blRvZ2dsZT57e2N1cnJlbnRMYW5ndWFnZS5kZXNjcmlwdGlvbn19PC9hPlxcclxcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiZHJvcGRvd24tbWVudSBkcm9wZG93bi1tZW51LXJpZ2h0XFxcIiBhcmlhLWxhYmVsbGVkYnk9XFxcImxhbmd1YWdlc1xcXCI+XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiAqbmdGb3I9XFxcImxldCBsYW5nIG9mIGxhbmd1YWdlc1xcXCIgKGNsaWNrKT1cXFwic2V0TGFuZyhsYW5nKVxcXCIgY2xhc3M9XFxcImRyb3Bkb3duLWl0ZW1cXFwiPlxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7e2xhbmcuZGVzY3JpcHRpb259fVxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxcclxcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxyXFxuICAgICAgICAgICAgICAgIDwvZGl2PlxcclxcbiAgICAgICAgICAgIDwvbGk+XFxyXFxuICAgICAgICA8L3VsPlxcclxcblxcclxcbiAgICAgICAgPCEtLVJpZ2h0IG5hdi0tPlxcclxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwibmF2YmFyLWNvbGxhcHNlIGp1c3RpZnktY29udGVudC1tZC1lbmRcXFwiPlxcclxcbiAgICAgICAgICAgIDx1bCBjbGFzcz1cXFwibmF2YmFyLW5hdlxcXCI+XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgIDxsaSBjbGFzcz1cXFwibmF2LWl0ZW1cXFwiICpuZ0lmPVxcXCJpc0xvZ2dlZEluXFxcIj5cXHJcXG4gICAgICAgICAgICAgICAgICAgIDxhIGNsYXNzPVxcXCJuYXYtbGlua1xcXCIgcm91dGVyTGlua0FjdGl2ZT1cXFwiYWN0aXZlXFxcIiByb3V0ZXJMaW5rPVxcXCJwcm9maWxlXFxcIj5cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpIGNsYXNzPVxcXCJmYSBmYS11c2VyXFxcIj48L2k+IHt7dXNlcj8ubmFtZX19XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvYT5cXHJcXG4gICAgICAgICAgICAgICAgPC9saT5cXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgPGxpIGNsYXNzPVxcXCJuYXYtaXRlbVxcXCIgKm5nSWY9XFxcIiFpc0xvZ2dlZEluXFxcIj5cXHJcXG4gICAgICAgICAgICAgICAgICAgIDxhIGNsYXNzPVxcXCJuYXYtbGlua1xcXCIgcm91dGVyTGlua0FjdGl2ZT1cXFwiYWN0aXZlXFxcIiByb3V0ZXJMaW5rPVxcXCJyZWdpc3RlclxcXCI+XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aSBjbGFzcz1cXFwiZmEgZmEtdXNlclxcXCI+PC9pPiB7eydBUFBfTkFWX1JFR0lTVEVSJyB8IHRyYW5zbGF0ZX19XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvYT5cXHJcXG4gICAgICAgICAgICAgICAgPC9saT5cXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgPGxpIGNsYXNzPVxcXCJuYXYtaXRlbVxcXCIgKm5nSWY9XFxcIiFpc0xvZ2dlZEluXFxcIj5cXHJcXG4gICAgICAgICAgICAgICAgICAgIDxhIGNsYXNzPVxcXCJuYXYtbGlua1xcXCIgcm91dGVyTGlua0FjdGl2ZT1cXFwiYWN0aXZlXFxcIiByb3V0ZXJMaW5rPVxcXCJsb2dpblxcXCI+XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aSBjbGFzcz1cXFwiZmEgZmEtc2lnbi1pblxcXCI+PC9pPnt7J0FQUF9OQVZfTE9HSU4nIHwgdHJhbnNsYXRlfX1cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9hPlxcclxcbiAgICAgICAgICAgICAgICA8L2xpPlxcclxcbiAgICAgICAgICAgICAgICA8bGkgY2xhc3M9XFxcIm5hdi1pdGVtXFxcIiAqbmdJZj1cXFwiaXNMb2dnZWRJbiAmJiB1c2VyPy5yb2xlPy5pbmRleE9mKCdBZG1pbicpID4gLTFcXFwiPlxcclxcbiAgICAgICAgICAgICAgICAgICAgPGEgY2xhc3M9XFxcIm5hdi1saW5rXFxcIiByb3V0ZXJMaW5rQWN0aXZlPVxcXCJhY3RpdmVcXFwiIHJvdXRlckxpbms9XFxcImFkbWluXFxcIj5cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpIGNsYXNzPVxcXCJmYSBmYS1nZWFyXFxcIj48L2k+IHt7J0FQUF9OQVZfQURNSU4nIHwgdHJhbnNsYXRlfX1cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9hPlxcclxcbiAgICAgICAgICAgICAgICA8L2xpPlxcclxcbiAgICAgICAgICAgICAgICA8bGkgY2xhc3M9XFxcIm5hdi1pdGVtXFxcIiAqbmdJZj1cXFwiaXNMb2dnZWRJblxcXCI+XFxyXFxuICAgICAgICAgICAgICAgICAgICA8YSBjbGFzcz1cXFwibmF2LWxpbmtcXFwiIChjbGljayk9XFxcImFjY291bnRTZXJ2aWNlLmxvZ291dCgpXFxcIiByb3V0ZXJMaW5rQWN0aXZlPVxcXCJhY3RpdmVcXFwiIGhyZWY9XFxcImphdmFzY3JpcHQ6dm9pZChudWxsKTtcXFwiPlxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGkgY2xhc3M9XFxcImZhIGZhLXNpZ24tb3V0XFxcIj48L2k+IHt7J0FQUF9OQVZfTE9HT1VUJyB8IHRyYW5zbGF0ZX19XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvYT5cXHJcXG4gICAgICAgICAgICAgICAgPC9saT5cXHJcXG4gICAgICAgICAgICA8L3VsPlxcclxcbiAgICAgICAgPC9kaXY+XFxyXFxuXFxyXFxuICAgIDwvZGl2PlxcclxcblxcclxcbjwvbmF2PlwiO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vQ2xpZW50QXBwL2FwcC9zaGFyZWQvbGF5b3V0L2hlYWRlci5jb21wb25lbnQuaHRtbFxuLy8gbW9kdWxlIGlkID0gMTA1XG4vLyBtb2R1bGUgY2h1bmtzID0gNCIsIlxuICAgICAgICB2YXIgcmVzdWx0ID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanMhLi9oZWFkZXIuY29tcG9uZW50LnNjc3NcIik7XG5cbiAgICAgICAgaWYgKHR5cGVvZiByZXN1bHQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gcmVzdWx0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSByZXN1bHQudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgIFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vQ2xpZW50QXBwL2FwcC9zaGFyZWQvbGF5b3V0L2hlYWRlci5jb21wb25lbnQuc2Nzc1xuLy8gbW9kdWxlIGlkID0gMTA2XG4vLyBtb2R1bGUgY2h1bmtzID0gNCIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikodW5kZWZpbmVkKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcImhlYWRlciB7XFxuICBwYWRkaW5nLXJpZ2h0OiAwcmVtO1xcbiAgcGFkZGluZy1sZWZ0OiAwcmVtOyB9XFxuXCIsIFwiXCJdKTtcblxuLy8gZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlciEuL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzIS4vQ2xpZW50QXBwL2FwcC9zaGFyZWQvbGF5b3V0L2hlYWRlci5jb21wb25lbnQuc2Nzc1xuLy8gbW9kdWxlIGlkID0gMTA3XG4vLyBtb2R1bGUgY2h1bmtzID0gNCIsImltcG9ydCB7IENvbXBvbmVudCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5cclxuQENvbXBvbmVudCh7XHJcbiAgICBzZWxlY3RvcjogJ2FwcGMtZm9vdGVyJyxcclxuICAgIHN0eWxlczogW3JlcXVpcmUoJy4vZm9vdGVyLmNvbXBvbmVudC5zY3NzJyldLFxyXG4gICAgdGVtcGxhdGU6IHJlcXVpcmUoJy4vZm9vdGVyLmNvbXBvbmVudC5odG1sJylcclxufSlcclxuZXhwb3J0IGNsYXNzIEZvb3RlckNvbXBvbmVudCB7IH1cclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2FuZ3VsYXIyLXRlbXBsYXRlLWxvYWRlciEuL0NsaWVudEFwcC9hcHAvc2hhcmVkL2xheW91dC9mb290ZXIuY29tcG9uZW50LnRzIiwiXG4gICAgICAgIHZhciByZXN1bHQgPSByZXF1aXJlKFwiISEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcyEuL2Zvb3Rlci5jb21wb25lbnQuc2Nzc1wiKTtcblxuICAgICAgICBpZiAodHlwZW9mIHJlc3VsdCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSByZXN1bHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IHJlc3VsdC50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9DbGllbnRBcHAvYXBwL3NoYXJlZC9sYXlvdXQvZm9vdGVyLmNvbXBvbmVudC5zY3NzXG4vLyBtb2R1bGUgaWQgPSAxMDlcbi8vIG1vZHVsZSBjaHVua3MgPSA0IiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKSh1bmRlZmluZWQpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiLmZvb3RlciB7XFxuICBib3R0b206IDA7IH1cXG5cIiwgXCJcIl0pO1xuXG4vLyBleHBvcnRzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyIS4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanMhLi9DbGllbnRBcHAvYXBwL3NoYXJlZC9sYXlvdXQvZm9vdGVyLmNvbXBvbmVudC5zY3NzXG4vLyBtb2R1bGUgaWQgPSAxMTBcbi8vIG1vZHVsZSBjaHVua3MgPSA0IiwibW9kdWxlLmV4cG9ydHMgPSBcIjxmb290ZXIgY2xhc3M9XFxcImZvb3RlciB0ZXh0LW11dGVkXFxcIj5cXHJcXG4gICAgPHAgY2xhc3M9XFxcInRleHQtbXV0ZWRcXFwiPlxcclxcbiAgICAgICAgJmNvcHk7IDIwMTUtMjAxNiB7eydUSVRMRScgfCB0cmFuc2xhdGV9fVxcclxcbiAgICA8L3A+XFxyXFxuPC9mb290ZXI+XFxyXFxuXCI7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9DbGllbnRBcHAvYXBwL3NoYXJlZC9sYXlvdXQvZm9vdGVyLmNvbXBvbmVudC5odG1sXG4vLyBtb2R1bGUgaWQgPSAxMTFcbi8vIG1vZHVsZSBjaHVua3MgPSA0IiwiaW1wb3J0IHsgUGlwZSwgUGlwZVRyYW5zZm9ybSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5cclxuLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOnVzZS1waXBlLXRyYW5zZm9ybS1pbnRlcmZhY2VcclxuQFBpcGUoe1xyXG4gICAgbmFtZTogJ2FwcGZVcHBlcmNhc2UnXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBVcHBlcmNhc2VQaXBlIGltcGxlbWVudHMgUGlwZVRyYW5zZm9ybSB7XHJcbiAgICBwdWJsaWMgdHJhbnNmb3JtKHZhbHVlOiBzdHJpbmcpIHtcclxuICAgICAgICByZXR1cm4gdmFsdWUudG9VcHBlckNhc2UoKTtcclxuICAgIH1cclxufVxyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvYW5ndWxhcjItdGVtcGxhdGUtbG9hZGVyIS4vQ2xpZW50QXBwL2FwcC9zaGFyZWQvcGlwZXMvdXBwZXJjYXNlLnBpcGUudHMiLCJpbXBvcnQgeyBSZXF1ZXN0TWV0aG9kIH0gZnJvbSAnQGFuZ3VsYXIvaHR0cCc7XHJcblxyXG5leHBvcnQgY2xhc3MgRGF0YVNlcnZpY2VPcHRpb25zIHtcclxuICAgIHB1YmxpYyBtZXRob2Q6IFJlcXVlc3RNZXRob2Q7XHJcbiAgICBwdWJsaWMgdXJsOiBzdHJpbmc7XHJcbiAgICBwdWJsaWMgaGVhZGVyczogYW55ID0ge307XHJcbiAgICBwdWJsaWMgcGFyYW1zID0ge307XHJcbiAgICBwdWJsaWMgZGF0YSA9IHt9O1xyXG59XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9hbmd1bGFyMi10ZW1wbGF0ZS1sb2FkZXIhLi9DbGllbnRBcHAvYXBwL2NvcmUvc2VydmljZXMvZGF0YS1zZXJ2aWNlLW9wdGlvbnMudHMiLCJpbXBvcnQgeyBJbmplY3RhYmxlLCBJbmplY3QsIFBMQVRGT1JNX0lEIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICdyeGpzL09ic2VydmFibGUnO1xyXG5pbXBvcnQgeyBUcmFuc2xhdGVMb2FkZXIsIE1pc3NpbmdUcmFuc2xhdGlvbkhhbmRsZXIsIE1pc3NpbmdUcmFuc2xhdGlvbkhhbmRsZXJQYXJhbXMgfSBmcm9tICdAbmd4LXRyYW5zbGF0ZS9jb3JlJztcclxuXHJcbmltcG9ydCB7IENvbnRlbnRTZXJ2aWNlIH0gZnJvbSAnLi9jb250ZW50LnNlcnZpY2UnO1xyXG5pbXBvcnQgeyBpc1BsYXRmb3JtQnJvd3NlciB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XHJcblxyXG5ASW5qZWN0YWJsZSgpXHJcbmV4cG9ydCBjbGFzcyBBcGlUcmFuc2xhdGlvbkxvYWRlciBpbXBsZW1lbnRzIFRyYW5zbGF0ZUxvYWRlciB7XHJcblxyXG4gICAgY29uc3RydWN0b3IocHVibGljIGNvbnRlbnRTZXJ2aWNlOiBDb250ZW50U2VydmljZSwgQEluamVjdChQTEFURk9STV9JRCkgcHJpdmF0ZSBwbGF0Zm9ybUlkOiBPYmplY3QpIHsgfVxyXG5cclxuICAgIHB1YmxpYyBnZXRUcmFuc2xhdGlvbihsYW5nOiBzdHJpbmcpOiBPYnNlcnZhYmxlPGFueT4ge1xyXG4gICAgICAgIGlmIChpc1BsYXRmb3JtQnJvd3Nlcih0aGlzLnBsYXRmb3JtSWQpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnRlbnRTZXJ2aWNlLmdldChsYW5nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIE9ic2VydmFibGUub2Yoe30pO1xyXG4gICAgfVxyXG59XHJcblxyXG4vLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bWF4LWNsYXNzZXMtcGVyLWZpbGVcclxuQEluamVjdGFibGUoKVxyXG5leHBvcnQgY2xhc3MgQ3VzdG9tTWlzc2luZ1RyYW5zbGF0aW9uSGFuZGxlciBpbXBsZW1lbnRzIE1pc3NpbmdUcmFuc2xhdGlvbkhhbmRsZXIge1xyXG4gICAgcHVibGljIGhhbmRsZShwYXJhbXM6IE1pc3NpbmdUcmFuc2xhdGlvbkhhbmRsZXJQYXJhbXMpIHtcclxuICAgICAgICByZXR1cm4gcGFyYW1zLmtleTtcclxuICAgIH1cclxufVxyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvYW5ndWxhcjItdGVtcGxhdGUtbG9hZGVyIS4vQ2xpZW50QXBwL2FwcC9zaGFyZWQvc2VydmljZXMvYXBpLXRyYW5zbGF0aW9uLWxvYWRlci5zZXJ2aWNlLnRzIiwiaW1wb3J0IHsgTmdNb2R1bGUsIE9wdGlvbmFsLCBTa2lwU2VsZiwgTW9kdWxlV2l0aFByb3ZpZGVycyB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBUaXRsZSB9IGZyb20gJ0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXInO1xyXG5cclxuLy8gU2VydmljZXNcclxuaW1wb3J0IHsgQWNjb3VudFNlcnZpY2UgfSBmcm9tICcuL3NlcnZpY2VzL2FjY291bnQuc2VydmljZSc7XHJcbmltcG9ydCB7IERhdGFTZXJ2aWNlIH0gZnJvbSAnLi9zZXJ2aWNlcy9kYXRhLnNlcnZpY2UnO1xyXG5pbXBvcnQgeyBVdGlsaXR5U2VydmljZSB9IGZyb20gJy4vc2VydmljZXMvdXRpbGl0eS5zZXJ2aWNlJztcclxuXHJcbkBOZ01vZHVsZSh7XHJcbiAgICBpbXBvcnRzOiBbXHJcbiAgICBdLFxyXG4gICAgZXhwb3J0czogW1xyXG4gICAgXSxcclxuICAgIHByb3ZpZGVyczogW11cclxufSlcclxuZXhwb3J0IGNsYXNzIENvcmVNb2R1bGUge1xyXG4gICAgLy8gZm9yUm9vdCBhbGxvd3MgdG8gb3ZlcnJpZGUgcHJvdmlkZXJzXHJcbiAgICAvLyBodHRwczovL2FuZ3VsYXIuaW8vZG9jcy90cy9sYXRlc3QvZ3VpZGUvbmdtb2R1bGUuaHRtbCMhI2NvcmUtZm9yLXJvb3RcclxuICAgIHB1YmxpYyBzdGF0aWMgZm9yUm9vdCgpOiBNb2R1bGVXaXRoUHJvdmlkZXJzIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBuZ01vZHVsZTogQ29yZU1vZHVsZSxcclxuICAgICAgICAgICAgcHJvdmlkZXJzOiBbXHJcbiAgICAgICAgICAgICAgICAvLyBQcm92aWRlcnNcclxuICAgICAgICAgICAgICAgIFRpdGxlLFxyXG4gICAgICAgICAgICAgICAgQWNjb3VudFNlcnZpY2UsXHJcbiAgICAgICAgICAgICAgICBEYXRhU2VydmljZSxcclxuICAgICAgICAgICAgICAgIFV0aWxpdHlTZXJ2aWNlXHJcbiAgICAgICAgICAgIF1cclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgY29uc3RydWN0b3IoIEBPcHRpb25hbCgpIEBTa2lwU2VsZigpIHBhcmVudE1vZHVsZTogQ29yZU1vZHVsZSkge1xyXG4gICAgICAgIGlmIChwYXJlbnRNb2R1bGUpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb3JlTW9kdWxlIGlzIGFscmVhZHkgbG9hZGVkLiBJbXBvcnQgaXQgaW4gdGhlIEFwcE1vZHVsZSBvbmx5Jyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9hbmd1bGFyMi10ZW1wbGF0ZS1sb2FkZXIhLi9DbGllbnRBcHAvYXBwL2NvcmUvY29yZS5tb2R1bGUudHMiLCJpbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5cclxuaW1wb3J0IHsgSG9tZUNvbXBvbmVudCB9IGZyb20gJy4vaG9tZS5jb21wb25lbnQnO1xyXG5pbXBvcnQgeyByb3V0aW5nIH0gZnJvbSAnLi9ob21lLnJvdXRlcyc7XHJcblxyXG5ATmdNb2R1bGUoe1xyXG4gICAgaW1wb3J0czogW3JvdXRpbmddLFxyXG4gICAgZGVjbGFyYXRpb25zOiBbSG9tZUNvbXBvbmVudF1cclxufSlcclxuZXhwb3J0IGNsYXNzIEhvbWVNb2R1bGUgeyB9XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9hbmd1bGFyMi10ZW1wbGF0ZS1sb2FkZXIhLi9DbGllbnRBcHAvYXBwL2hvbWUvaG9tZS5tb2R1bGUudHMiLCJcbiAgICAgICAgdmFyIHJlc3VsdCA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzIS4vaG9tZS5jb21wb25lbnQuc2Nzc1wiKTtcblxuICAgICAgICBpZiAodHlwZW9mIHJlc3VsdCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSByZXN1bHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IHJlc3VsdC50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9DbGllbnRBcHAvYXBwL2hvbWUvaG9tZS5jb21wb25lbnQuc2Nzc1xuLy8gbW9kdWxlIGlkID0gMTE3XG4vLyBtb2R1bGUgY2h1bmtzID0gNCIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikodW5kZWZpbmVkKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIlwiLCBcIlwiXSk7XG5cbi8vIGV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIhLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcyEuL0NsaWVudEFwcC9hcHAvaG9tZS9ob21lLmNvbXBvbmVudC5zY3NzXG4vLyBtb2R1bGUgaWQgPSAxMThcbi8vIG1vZHVsZSBjaHVua3MgPSA0IiwibW9kdWxlLmV4cG9ydHMgPSBcIjxkaXYgY2xhc3M9XFxcImp1bWJvdHJvblxcXCI+XFxyXFxuICAgIDxkaXYgY2xhc3M9XFxcImNvbnRhaW5lclxcXCI+XFxyXFxuICAgICAgICA8aDI+QXNwLk5ldCBDb3JlICZoZWFydHM7IEFuZ3VsYXIgMiAmaGVhcnRzOyBCb290c3RyYXAgNCAmaGVhcnRzOyBXZWJwYWNrPC9oMj5cXHJcXG4gICAgPC9kaXY+XFxyXFxuPC9kaXY+XFxyXFxuXFxyXFxuPGRpdiBjbGFzcz1cXFwicm93XFxcIj5cXHJcXG4gICAgPGRpdiBjbGFzcz1cXFwiY29sLW1kLTRcXFwiPlxcclxcbiAgICAgICAgPGg0PlxcclxcbiAgICAgICAgICAgIEFzcC5OZXQgQ29yZVxcclxcbiAgICAgICAgPC9oND5cXHJcXG4gICAgICAgIDxwPlxcclxcbiAgICAgICAgICAgIEFTUC5ORVQgaXMgYW4gb3BlbiBzb3VyY2Ugd2ViIGZyYW1ld29yayBmb3IgYnVpbGRpbmcgbW9kZXJuIHdlYiBhcHBsaWNhdGlvbnMgYW5kIHNlcnZpY2VzLlxcclxcbiAgICAgICAgPC9wPlxcclxcbiAgICAgICAgPHA+XFxyXFxuICAgICAgICAgICAgPGEgY2xhc3M9XFxcImJ0biBidG4tb3V0bGluZS1pbmZvXFxcIiB0YXJnZXQ9XFxcIl9ibGFua1xcXCIgaHJlZj1cXFwiaHR0cDovL3d3dy5hc3AubmV0L1xcXCI+TW9yZSBpbmZvIMK7PC9hPlxcclxcbiAgICAgICAgPC9wPlxcclxcbiAgICA8L2Rpdj5cXHJcXG4gICAgPGRpdiBjbGFzcz1cXFwiY29sLW1kLTRcXFwiPlxcclxcbiAgICAgICAgPGg0PlxcclxcbiAgICAgICAgICAgIEFuZ3VsYXIgMlxcclxcbiAgICAgICAgPC9oND5cXHJcXG4gICAgICAgIDxwPlxcclxcbiAgICAgICAgICAgIE9uZSBGcmFtZXdvcmsgTW9iaWxlIGFuZCBkZXNrdG9wXFxyXFxuICAgICAgICA8L3A+XFxyXFxuICAgICAgICA8cD5cXHJcXG4gICAgICAgICAgICA8YSBjbGFzcz1cXFwiYnRuIGJ0bi1vdXRsaW5lLWluZm9cXFwiIHRhcmdldD1cXFwiX2JsYW5rXFxcIiBocmVmPVxcXCJodHRwczovL2FuZ3VsYXIuaW8vXFxcIj5Nb3JlIGluZm8gwrs8L2E+XFxyXFxuICAgICAgICA8L3A+XFxyXFxuICAgIDwvZGl2PlxcclxcblxcclxcbiAgICA8ZGl2IGNsYXNzPVxcXCJjb2wtbWQtNFxcXCI+XFxyXFxuICAgICAgICA8aDQ+XFxyXFxuICAgICAgICAgICAgbmctYm9vdHN0cmFwXFxyXFxuICAgICAgICA8L2g0PlxcclxcbiAgICAgICAgPHA+XFxyXFxuICAgICAgICAgICAgQW5ndWxhciAyLCBwb3dlcmVkIGJ5IEJvb3RzdHJhcCA0IHdyaXR0ZW4gYnkgdGhlIGFuZ3VsYXItdWkgVGVhbS5cXHJcXG4gICAgICAgIDwvcD5cXHJcXG4gICAgICAgIDxwPlxcclxcbiAgICAgICAgICAgIDxhIGNsYXNzPVxcXCJidG4gYnRuLW91dGxpbmUtaW5mb1xcXCIgdGFyZ2V0PVxcXCJfYmxhbmtcXFwiIGhyZWY9XFxcImh0dHBzOi8vbmctYm9vdHN0cmFwLmdpdGh1Yi5pby8jL2hvbWVcXFwiPk1vcmUgaW5mbyDCuzwvYT5cXHJcXG4gICAgICAgIDwvcD5cXHJcXG4gICAgPC9kaXY+XFxyXFxuICAgIDxkaXYgY2xhc3M9XFxcImNvbC1tZC00XFxcIj5cXHJcXG4gICAgICAgIDxoND5cXHJcXG4gICAgICAgICAgICBCb290c3RyYXAgNFxcclxcbiAgICAgICAgPC9oND5cXHJcXG4gICAgICAgIDxwPlxcclxcbiAgICAgICAgICAgIEJvb3RzdHJhcCBpcyB0aGUgbW9zdCBwb3B1bGFyIEhUTUwsIENTUywgYW5kIEpTIGZyYW1ld29yayBmb3IgZGV2ZWxvcGluZyByZXNwb25zaXZlLCBtb2JpbGUgZmlyc3QgcHJvamVjdHMgb24gdGhlIHdlYi5cXHJcXG4gICAgICAgIDwvcD5cXHJcXG4gICAgICAgIDxwPlxcclxcbiAgICAgICAgICAgIDxhIGNsYXNzPVxcXCJidG4gYnRuLW91dGxpbmUtaW5mb1xcXCIgdGFyZ2V0PVxcXCJfYmxhbmtcXFwiIGhyZWY9XFxcImh0dHA6Ly92NC1hbHBoYS5nZXRib290c3RyYXAuY29tL1xcXCI+TW9yZSBpbmZvIMK7PC9hPlxcclxcbiAgICAgICAgPC9wPlxcclxcbiAgICA8L2Rpdj5cXHJcXG4gICAgPGRpdiBjbGFzcz1cXFwiY29sLW1kLTRcXFwiPlxcclxcbiAgICAgICAgPGg0PlxcclxcbiAgICAgICAgICAgIFdlYnBhY2sgMlxcclxcbiAgICAgICAgPC9oND5cXHJcXG4gICAgICAgIDxwPlxcclxcbiAgICAgICAgICAgIE1vZHVsZSBidW5kbGVyXFxyXFxuICAgICAgICA8L3A+XFxyXFxuICAgICAgICA8cD5cXHJcXG4gICAgICAgICAgICA8YSBjbGFzcz1cXFwiYnRuIGJ0bi1vdXRsaW5lLWluZm9cXFwiIHRhcmdldD1cXFwiX2JsYW5rXFxcIiBocmVmPVxcXCJodHRwczovL3dlYnBhY2suanMub3JnL1xcXCI+TW9yZSBpbmZvIMK7PC9hPlxcclxcbiAgICAgICAgPC9wPlxcclxcbiAgICA8L2Rpdj5cXHJcXG4gICAgPGRpdiBjbGFzcz1cXFwiY29sLW1kLTRcXFwiPlxcclxcbiAgICAgICAgPGg0PlxcclxcbiAgICAgICAgICAgIEBuZ3gtdHJhbnNsYXRlXFxyXFxuICAgICAgICA8L2g0PlxcclxcbiAgICAgICAgPHA+XFxyXFxuICAgICAgICAgICAgVGhlIGludGVybmF0aW9uYWxpemF0aW9uIChpMThuKSBsaWJyYXJ5IGZvciBBbmd1bGFyIDIrXFxyXFxuICAgICAgICA8L3A+XFxyXFxuICAgICAgICA8cD5cXHJcXG4gICAgICAgICAgICA8YSBjbGFzcz1cXFwiYnRuIGJ0bi1vdXRsaW5lLWluZm9cXFwiIHRhcmdldD1cXFwiX2JsYW5rXFxcIiBocmVmPVxcXCJodHRwOi8vd3d3Lm5neC10cmFuc2xhdGUuY29tL1xcXCI+TW9yZSBpbmZvIMK7PC9hPlxcclxcbiAgICAgICAgPC9wPlxcclxcbiAgICA8L2Rpdj5cXHJcXG48L2Rpdj5cIjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL0NsaWVudEFwcC9hcHAvaG9tZS9ob21lLmNvbXBvbmVudC5odG1sXG4vLyBtb2R1bGUgaWQgPSAxMTlcbi8vIG1vZHVsZSBjaHVua3MgPSA0IiwiaW1wb3J0IHsgUm91dGVzLCBSb3V0ZXJNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9yb3V0ZXInO1xyXG5cclxuaW1wb3J0IHsgSG9tZUNvbXBvbmVudCB9IGZyb20gJy4vaG9tZS5jb21wb25lbnQnO1xyXG5cclxuY29uc3Qgcm91dGVzOiBSb3V0ZXMgPSBbXHJcbiAgICB7IHBhdGg6ICdob21lJywgY29tcG9uZW50OiBIb21lQ29tcG9uZW50LCBkYXRhOiB7IHN0YXRlOiAnaG9tZScgfSB9XHJcbl07XHJcblxyXG5leHBvcnQgY29uc3Qgcm91dGluZyA9IFJvdXRlck1vZHVsZS5mb3JDaGlsZChyb3V0ZXMpO1xyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvYW5ndWxhcjItdGVtcGxhdGUtbG9hZGVyIS4vQ2xpZW50QXBwL2FwcC9ob21lL2hvbWUucm91dGVzLnRzIiwiaW1wb3J0IHsgUm91dGVzLCBSb3V0ZXJNb2R1bGUsIFByZWxvYWRBbGxNb2R1bGVzIH0gZnJvbSAnQGFuZ3VsYXIvcm91dGVyJztcclxuXHJcbmNvbnN0IHJvdXRlczogUm91dGVzID0gW1xyXG4gIHsgcGF0aDogJycsIHJlZGlyZWN0VG86ICdob21lJywgcGF0aE1hdGNoOiAnZnVsbCcgfSxcclxuICAvLyBMYXp5IGFzeW5jIG1vZHVsZXNcclxuICB7XHJcbiAgICBwYXRoOiAnbG9naW4nLCBsb2FkQ2hpbGRyZW46ICcuL2FjY291bnQvK2xvZ2luL2xvZ2luLm1vZHVsZSNMb2dpbk1vZHVsZSdcclxuICB9LFxyXG4gIHtcclxuICAgIHBhdGg6ICdyZWdpc3RlcicsIGxvYWRDaGlsZHJlbjogJy4vYWNjb3VudC8rcmVnaXN0ZXIvcmVnaXN0ZXIubW9kdWxlI1JlZ2lzdGVyTW9kdWxlJ1xyXG4gIH0sXHJcbiAge1xyXG4gICAgcGF0aDogJ3Byb2ZpbGUnLCBsb2FkQ2hpbGRyZW46ICcuL2FjY291bnQvK3Byb2ZpbGUvcHJvZmlsZS5tb2R1bGUjUHJvZmlsZU1vZHVsZSdcclxuICB9LFxyXG4gIHtcclxuICAgIHBhdGg6ICdhZG1pbicsIGxvYWRDaGlsZHJlbjogJy4vK2FkbWluL2FkbWluLm1vZHVsZSNBZG1pbk1vZHVsZSdcclxuICB9XHJcbl07XHJcblxyXG5leHBvcnQgY29uc3Qgcm91dGluZyA9IFJvdXRlck1vZHVsZS5mb3JSb290KHJvdXRlcywgeyBwcmVsb2FkaW5nU3RyYXRlZ3k6IFByZWxvYWRBbGxNb2R1bGVzIH0pO1xyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvYW5ndWxhcjItdGVtcGxhdGUtbG9hZGVyIS4vQ2xpZW50QXBwL2FwcC9hcHAucm91dGVzLnRzIiwiaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5cclxuQEluamVjdGFibGUoKVxyXG5leHBvcnQgY2xhc3MgQXBwU2VydmljZSB7IH1cclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2FuZ3VsYXIyLXRlbXBsYXRlLWxvYWRlciEuL0NsaWVudEFwcC9hcHAvYXBwLnNlcnZpY2UudHMiLCJpbXBvcnQgeyBDb21wb25lbnQsIE9uSW5pdCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBUaXRsZSB9IGZyb20gJ0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXInO1xyXG5pbXBvcnQgeyBUcmFuc2xhdGVTZXJ2aWNlIH0gZnJvbSAnQG5neC10cmFuc2xhdGUvY29yZSc7XHJcblxyXG5pbXBvcnQgeyByb3V0ZXJUcmFuc2l0aW9uIH0gZnJvbSAnLi9yb3V0ZXIuYW5pbWF0aW9ucyc7XHJcblxyXG5AQ29tcG9uZW50KHtcclxuICBzZWxlY3RvcjogJ2FwcGMtcm9vdCcsXHJcbiAgYW5pbWF0aW9uczogW3JvdXRlclRyYW5zaXRpb25dLFxyXG4gIHRlbXBsYXRlOiByZXF1aXJlKCcuL2FwcC5jb21wb25lbnQuaHRtbCcpXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBBcHBDb21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQge1xyXG5cclxuICBjb25zdHJ1Y3RvcihcclxuICAgIHB1YmxpYyB0cmFuc2xhdGU6IFRyYW5zbGF0ZVNlcnZpY2UsXHJcbiAgICBwdWJsaWMgdGl0bGVTZXJ2aWNlOiBUaXRsZSkge1xyXG4gICAgLy8gdGhpcyBsYW5ndWFnZSB3aWxsIGJlIHVzZWQgYXMgYSBmYWxsYmFjayB3aGVuIGEgdHJhbnNsYXRpb24gaXNuJ3QgZm91bmQgaW4gdGhlIGN1cnJlbnQgbGFuZ3VhZ2VcclxuICAgIHRyYW5zbGF0ZS5zZXREZWZhdWx0TGFuZygnZW4nKTtcclxuXHJcbiAgICAvLyB0aGUgbGFuZyB0byB1c2UsIGlmIHRoZSBsYW5nIGlzbid0IGF2YWlsYWJsZSwgaXQgd2lsbCB1c2UgdGhlIGN1cnJlbnQgbG9hZGVyIHRvIGdldCB0aGVtXHJcbiAgICB0cmFuc2xhdGUudXNlKCdlbicpO1xyXG4gIH1cclxuXHJcbiAgcHVibGljIG5nT25Jbml0KCkge1xyXG4gICAgdGhpcy50cmFuc2xhdGUub25MYW5nQ2hhbmdlLnN1YnNjcmliZSgobGFuOiBzdHJpbmcpID0+IHtcclxuICAgICAgdGhpcy50cmFuc2xhdGUuZ2V0KCdUSVRMRScpXHJcbiAgICAgICAgLnN1YnNjcmliZSgodGl0bGU6IHN0cmluZykgPT4gdGhpcy5zZXRUaXRsZSh0aXRsZSkpO1xyXG4gICAgfSk7XHJcblxyXG4gIH1cclxuXHJcbiAgcHVibGljIHNldFRpdGxlKG5ld1RpdGxlOiBzdHJpbmcpIHtcclxuICAgIHRoaXMudGl0bGVTZXJ2aWNlLnNldFRpdGxlKG5ld1RpdGxlKTtcclxuICB9XHJcblxyXG4gIHB1YmxpYyBnZXRTdGF0ZShvdXRsZXQ6IGFueSkge1xyXG4gICAgcmV0dXJuIG91dGxldC5hY3RpdmF0ZWRSb3V0ZURhdGEuc3RhdGU7XHJcbiAgfVxyXG5cclxufVxyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvYW5ndWxhcjItdGVtcGxhdGUtbG9hZGVyIS4vQ2xpZW50QXBwL2FwcC9hcHAuY29tcG9uZW50LnRzIiwiLy8gaW1wb3J0IHsgdHJpZ2dlciwgYW5pbWF0ZSwgc3R5bGUsIHRyYW5zaXRpb24gfSBmcm9tICdAYW5ndWxhci9hbmltYXRpb25zJztcclxuXHJcbi8vIGV4cG9ydCBmdW5jdGlvbiByb3V0ZXJUcmFuc2l0aW9uKCkge1xyXG4vLyAgICAgcmV0dXJuIHRyaWdnZXIoJ3JvdXRlclRyYW5zaXRpb24nLCBbXHJcbi8vICAgICAgICAgdHJhbnNpdGlvbigndm9pZCA9PiAqJywgW1xyXG4vLyAgICAgICAgICAgICBzdHlsZSh7IHRyYW5zZm9ybTogJ3RyYW5zbGF0ZVgoLTEwJSknIH0pLFxyXG4vLyAgICAgICAgICAgICBhbmltYXRlKDQwMClcclxuLy8gICAgICAgICBdKVxyXG4vLyAgICAgXSk7XHJcbi8vIH1cclxuXHJcbi8vIGV4cG9ydCBmdW5jdGlvbiBob3N0U3R5bGUoKSB7XHJcbi8vICAgICByZXR1cm4ge1xyXG4vLyAgICAgICAgICdbQHJvdXRlclRyYW5zaXRpb25dJzogJycsXHJcbi8vICAgICAgICAgJ1tzdHlsZS5kaXNwbGF5XSc6ICdcImJsb2NrXCInLFxyXG5cclxuLy8gICAgICAgICAvLyAnW3N0eWxlLnBvc2l0aW9uXSc6ICdcImFic29sdXRlXCInXHJcbi8vICAgICB9O1xyXG4vLyB9XHJcblxyXG5cclxuaW1wb3J0IHsgdHJpZ2dlciwgc3RhZ2dlciwgYW5pbWF0ZSwgc3R5bGUsIGdyb3VwLCBxdWVyeSwgdHJhbnNpdGlvbiB9IGZyb20gJ0Bhbmd1bGFyL2FuaW1hdGlvbnMnO1xyXG5cclxuZXhwb3J0IGNvbnN0IHJvdXRlclRyYW5zaXRpb24gPSB0cmlnZ2VyKCdyb3V0ZXJUcmFuc2l0aW9uJywgW1xyXG4gICAgdHJhbnNpdGlvbignKiA8PT4gKicsIFtcclxuICAgICAgICBxdWVyeSgnOmVudGVyLCA6bGVhdmUnLCBzdHlsZSh7IHBvc2l0aW9uOiAnZml4ZWQnLCB3aWR0aDogJzEwMCUnIH0pXHJcbiAgICAgICAgICAgICwgeyBvcHRpb25hbDogdHJ1ZSB9KSxcclxuICAgICAgICBxdWVyeSgnLmJsb2NrJywgc3R5bGUoeyBvcGFjaXR5OiAwIH0pXHJcbiAgICAgICAgICAgICwgeyBvcHRpb25hbDogdHJ1ZSB9KSxcclxuICAgICAgICBncm91cChbXHJcbiAgICAgICAgICAgIHF1ZXJ5KCc6ZW50ZXInLCBbXHJcbiAgICAgICAgICAgICAgICBzdHlsZSh7IHRyYW5zZm9ybTogJ3RyYW5zbGF0ZVgoMTAwJSknIH0pLFxyXG4gICAgICAgICAgICAgICAgYW5pbWF0ZSgnMC41cyBlYXNlLWluLW91dCcsIHN0eWxlKHsgdHJhbnNmb3JtOiAndHJhbnNsYXRlWCgwJSknIH0pKVxyXG4gICAgICAgICAgICBdLCB7IG9wdGlvbmFsOiB0cnVlIH0pLFxyXG4gICAgICAgICAgICBxdWVyeSgnOmxlYXZlJywgW1xyXG4gICAgICAgICAgICAgICAgc3R5bGUoeyB0cmFuc2Zvcm06ICd0cmFuc2xhdGVYKDAlKScgfSksXHJcbiAgICAgICAgICAgICAgICBhbmltYXRlKCcwLjVzIGVhc2UtaW4tb3V0Jywgc3R5bGUoeyB0cmFuc2Zvcm06ICd0cmFuc2xhdGVYKC0xMDAlKScgfSkpXHJcbiAgICAgICAgICAgIF0sIHsgb3B0aW9uYWw6IHRydWUgfSksXHJcbiAgICAgICAgXSksXHJcbiAgICAgICAgcXVlcnkoJzplbnRlciAuYmxvY2snLCBzdGFnZ2VyKDQwMCwgW1xyXG4gICAgICAgICAgICBzdHlsZSh7IHRyYW5zZm9ybTogJ3RyYW5zbGF0ZVkoMTAwcHgpJyB9KSxcclxuICAgICAgICAgICAgYW5pbWF0ZSgnMXMgZWFzZS1pbi1vdXQnLCBzdHlsZSh7IHRyYW5zZm9ybTogJ3RyYW5zbGF0ZVkoMHB4KScsIG9wYWNpdHk6IDEgfSkpLFxyXG4gICAgICAgIF0pLCB7IG9wdGlvbmFsOiB0cnVlIH0pLFxyXG4gICAgXSlcclxuXSlcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2FuZ3VsYXIyLXRlbXBsYXRlLWxvYWRlciEuL0NsaWVudEFwcC9hcHAvcm91dGVyLmFuaW1hdGlvbnMudHMiLCJtb2R1bGUuZXhwb3J0cyA9IFwiPCEtLSBoZWFkZXIgY29tcG9uZW50IC0tPlxcclxcbjxhcHBjLWhlYWRlcj48L2FwcGMtaGVhZGVyPlxcclxcblxcclxcbjwhLS0gY29tcG9uZW50IHJvdXRpbmcgcGxhY2Vob2xkZXIgLS0+XFxyXFxuPG1haW4gW0Byb3V0ZXJUcmFuc2l0aW9uXT1cXFwiZ2V0U3RhdGUobylcXFwiPlxcclxcbiAgICA8cm91dGVyLW91dGxldCAjbz1cXFwib3V0bGV0XFxcIj48L3JvdXRlci1vdXRsZXQ+XFxyXFxuPC9tYWluPlxcclxcblxcclxcbjwhLS0gZm9vdGVyIGNvbXBvbmVudCAtLT5cXHJcXG48YXBwYy1mb290ZXI+PC9hcHBjLWZvb3Rlcj5cIjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL0NsaWVudEFwcC9hcHAvYXBwLmNvbXBvbmVudC5odG1sXG4vLyBtb2R1bGUgaWQgPSAxMjVcbi8vIG1vZHVsZSBjaHVua3MgPSA0Il0sInNvdXJjZVJvb3QiOiIifQ==